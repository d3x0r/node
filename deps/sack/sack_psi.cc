#ifndef HAVE_SSL
#  define NO_SSL 1
#endif
#ifndef HAVE_ZLIB
#  define __NO_WEBSOCK_COMPRESSION__
#endif
#define NO_OPEN_MACRO
//#define __NO_MMAP__
#define __STATIC__
#define NO_FILEOP_ALIAS
#define SACK_BAG_EXPORTS
#define __STATIC_GLOBALS__
//#define DEFINE_DEFAULT_IMAGE_INTERFACE
//#define TYPELIB_SOURCE
#define NEED_SHLAPI
#define NEED_SHLOBJ
#define JSON_PARSER_MAIN_SOURCE
#define INTERNAL_DUMP_FONT_FILE
#define SOURCE_PSI2
#define SYSTRAY_LIBRARAY
#define TARGETNAME "someTarget"
#define _INCLUDE_CLIPBOARD
#include <stdio.h>
#include <stdarg.h>
/* Includes the system platform as required or appropriate. If
   under a linux system, include appropriate basic linux type
   headers, if under windows pull "windows.h".
   Includes the MOST stuff here ( a full windows.h parse is many
   many lines of code.)                                          */
/* A macro to build a wide character string of __FILE__ */
#define _WIDE__FILE__(n) n
#define WIDE__FILE__ _WIDE__FILE__(__FILE__)
#if _XOPEN_SOURCE < 500
#  undef _XOPEN_SOURCE
#  define _XOPEN_SOURCE 500
#endif
#ifndef STANDARD_HEADERS_INCLUDED
/* multiple inclusion protection symbol */
#define STANDARD_HEADERS_INCLUDED
#include <stdlib.h>
#include <stddef.h>
#include <stdint.h>
#if _MSC_VER
#  ifdef EXCLUDE_SAFEINT_H
#    define _INTSAFE_H_INCLUDED_
#  endif
 //_MSC_VER
#endif
#ifndef WINVER
#  define WINVER 0x0601
#endif
#ifndef _WIN32
#  ifndef __LINUX__
#    define __LINUX__
#  endif
#endif
#if !defined(__LINUX__)
#  ifndef STRICT
#    define STRICT
#  endif
#  define WIN32_LEAN_AND_MEAN
// #define NOGDICAPMASKS             // CC_*, LC_*, PC_*, CP_*, TC_*, RC_
// #define NOVIRTUALKEYCODES         // VK_*
// #define NOWINMESSAGES             // WM_*, EM_*, LB_*, CB_*
// #define NOWINSTYLES               // WS_*, CS_*, ES_*, LBS_*, SBS_*, CBS_*
// #define NOSYSMETRICS              // SM_*
// #define NOMENUS                   // MF_*
// #define NOICONS                   // IDI_*
// #define NOKEYSTATES               // MK_*
// #define NOSYSCOMMANDS             // SC_*
// #define NORASTEROPS               // Binary and Tertiary raster ops
// #define NOSHOWWINDOW              // SW_*
               // OEM Resource values
#  define OEMRESOURCE
// #define NOATOM                    // Atom Manager routines
#  ifndef _INCLUDE_CLIPBOARD
               // Clipboard routines
#    define NOCLIPBOARD
#  endif
// #define NOCOLOR                   // Screen colors
// #define NOCTLMGR                  // Control and Dialog routines
//(spv) #define NODRAWTEXT                // DrawText() and DT_*
// #define NOGDI                     // All GDI defines and routines
// #define NOKERNEL                  // All KERNEL defines and routines
// #define NOUSER                    // All USER defines and routines
#  ifndef _ARM_
#    ifndef _INCLUDE_NLS
                     // All NLS defines and routines
#      define NONLS
#    endif
#  endif
// #define NOMB                      // MB_* and MessageBox()
                  // GMEM_*, LMEM_*, GHND, LHND, associated routines
#  define NOMEMMGR
                // typedef METAFILEPICT
#  define NOMETAFILE
#  ifndef NOMINMAX
                  // Macros min(a,b) and max(a,b)
#    define NOMINMAX
#  endif
// #define NOMSG                     // typedef MSG and associated routines
// #define NOOPENFILE                // OpenFile(), OemToAnsi, AnsiToOem, and OF_*
// #define NOSCROLL                  // SB_* and scrolling routines
                 // All Service Controller routines, SERVICE_ equates, etc.
#  define NOSERVICE
//#define NOSOUND                   // Sound driver routines
#  ifndef _INCLUDE_TEXTMETRIC
              // typedef TEXTMETRIC and associated routines
#    define NOTEXTMETRIC
#  endif
// #define NOWH                      // SetWindowsHook and WH_*
// #define NOWINOFFSETS              // GWL_*, GCL_*, associated routines
// #define NOCOMM                    // COMM driver routines
                   // Kanji support stuff.
#  define NOKANJI
                    // Help engine interface.
#  define NOHELP
                // Profiler interface.
#  define NOPROFILER
//#define NODEFERWINDOWPOS          // DeferWindowPos routines
                     // Modem Configuration Extensions
#  define NOMCX
   // no StrCat StrCmp StrCpy etc functions.  (used internally)
#  define NO_SHLWAPI_STRFCNS
  // This also has defines that override StrCmp StrCpy etc... but no override
#  define STRSAFE_NO_DEPRECATE
#  ifdef _MSC_VER
#    ifndef _WIN32_WINDOWS
// needed at least this for what - updatelayeredwindow?
#      define _WIN32_WINDOWS 0x0601
#    endif
#  endif
// INCLUDE WINDOWS.H
#  ifdef __WATCOMC__
#    undef _WINDOWS_
#  endif
#  ifdef UNDER_CE
// just in case windows.h also fails after undef WIN32
// these will be the correct order for primitives we require.
#    include <excpt.h>
#    include <windef.h>
#    include <winnt.h>
#    include <winbase.h>
#    include <wingdi.h>
#    include <wtypes.h>
#    include <winuser.h>
#    undef WIN32
#  endif
#  define _WINSOCKAPI_
#  include <windows.h>
#  undef _WINSOCKAPI_
#  if defined( WIN32 ) && defined( NEED_SHLOBJ )
#    include <shlobj.h>
#  endif
#  if _MSC_VER > 1500
#    define mkdir _mkdir
#    define fileno _fileno
#    define stricmp _stricmp
#    define strdup _strdup
#  endif
//#  include <windowsx.h>
// we like timeGetTime() instead of GetTickCount()
//#  include <mmsystem.h>
#ifdef __cplusplus
extern "C"
#endif
__declspec(dllimport) DWORD WINAPI timeGetTime(void);
#  if defined( NEED_SHLAPI )
#    include <shlwapi.h>
#    include <shellapi.h>
#  endif
#  ifdef NEED_V4W
#    include <vfw.h>
#  endif
#  if defined( HAVE_ENVIRONMENT )
#    define getenv(name)       OSALOT_GetEnvironmentVariable(name)
#    define setenv(name,val)   SetEnvironmentVariable(name,val)
#  endif
#  define Relinquish()       Sleep(0)
//#pragma pragnoteonly("GetFunctionAddress is lazy and has no library cleanup - needs to be a lib func")
//#define GetFunctionAddress( lib, proc ) GetProcAddress( LoadLibrary( lib ), (proc) )
#  ifdef __cplusplus_cli
#    include <vcclr.h>
 /*lprintf( */
#    define DebugBreak() System::Console::WriteLine(gcnew System::String( WIDE__FILE__ "(" STRSYM(__LINE__) ") Would DebugBreak here..." ) );
//typedef unsigned int HANDLE;
//typedef unsigned int HMODULE;
//typedef unsigned int HWND;
//typedef unsigned int HRC;
//typedef unsigned int HMENU;
//typedef unsigned int HICON;
//typedef unsigned int HINSTANCE;
#  endif
 // ifdef unix/linux
#else
#  include <pthread.h>
#  include <sched.h>
#  include <unistd.h>
#  include <sys/time.h>
#  include <errno.h>
#  if defined( __ARM__ )
#    define DebugBreak()
#  else
/* A symbol used to cause a debugger to break at a certain
   point. Sometimes dynamicly loaded plugins can be hard to set
   the breakpoint in the debugger, so it becomes easier to
   recompile with a breakpoint in the right place.
   Example
   <code lang="c++">
   DebugBreak();
	</code>                                                      */
#    ifdef __ANDROID__
#      define DebugBreak()
#    else
#      if defined( __EMSCRIPTEN__ ) || defined( __ARM__ )
#        define DebugBreak()
#      else
#        define DebugBreak()  __asm__("int $3\n" )
#      endif
#    endif
#  endif
#  ifdef __ANDROID_OLD_PLATFORM_SUPPORT__
extern __sighandler_t bsd_signal(int, __sighandler_t);
#  endif
// moved into timers - please linnk vs timers to get Sleep...
//#define Sleep(n) (usleep((n)*1000))
#  define Relinquish() sched_yield()
#  define GetLastError() (int32_t)errno
/* return with a THREAD_ID that is a unique, universally
   identifier for the thread for inter process communication. */
#  define GetCurrentProcessId() ((uint32_t)getpid())
#  define GetCurrentThreadId() ((uint32_t)getpid())
  // end if( !__LINUX__ )
#endif
#ifndef NEED_MIN_MAX
#  ifndef NO_MIN_MAX_MACROS
#    define NO_MIN_MAX_MACROS
#  endif
#endif
#ifndef NO_MIN_MAX_MACROS
#  ifdef __cplusplus
#    ifdef __GNUC__
#      ifndef min
#        define min(a,b) ((a)<(b))?(a):(b)
#      endif
#    endif
#  endif
/* Define a min(a,b) macro when the compiler lacks it. */
#  ifndef min
#    define min(a,b) (((a)<(b))?(a):(b))
#  endif
/* Why not add the max macro, also? */
#  ifndef max
#    define max(a,b) (((a)>(b))?(a):(b))
#  endif
#endif
#ifndef SACK_PRIMITIVE_TYPES_INCLUDED
#define SACK_PRIMITIVE_TYPES_INCLUDED
/* Define most of the sack core types on which everything else is
   based. Also defines some of the primitive container
   structures. We also handle a lot of platform/compiler
   abstraction here.
   A reFactoring for stdint.h and uint32_t etc would be USEFUL!
   where types don't exist, define them as apprpritate types instead.
But WHO doesn't have stdint?  BTW is sizeof( size_t ) == sizeof( void* )
   This is automatically included with stdhdrs.h; however, when
   including sack_types.h, the minimal headers are pulled. */
#define HAS_STDINT
//#define USE_SACK_CUSTOM_MEMORY_ALLOCATION
	// this has to be a compile option (option from cmake)
   // enables debug dump mem...
#ifdef USE_SACK_CUSTOM_MEMORY_ALLOCATION
#  define USE_CUSTOM_ALLOCER 1
#else
#  define USE_CUSTOM_ALLOCER 0
#endif
#ifndef __64__
#  if defined( _WIN64 ) || defined( ENVIRONMENT64 ) || defined( __x86_64__ ) || defined( __ia64 ) || defined( __ppc64__ ) || defined( __LP64__ )
#    define __64__ 1
#  endif
#endif
#ifdef _MSC_VER
#  ifndef _WIN32_WINNT
#    define _WIN32_WINNT 0x501
#  endif
#  ifndef WIN32
#    ifdef _WIN32
#      define WIN32 _WIN32
#    endif
#  endif
// force windows on __MSVC
#  ifndef WIN32
#    define WIN32
#  endif
#endif
#if !defined( __NO_THREAD_LOCAL__ ) && ( defined( _MSC_VER ) || defined( __WATCOMC__ ) )
#  define HAS_TLS 1
#  ifdef __cplusplus
#    define DeclareThreadLocal thread_local
#    define DeclareThreadVar  thread_local
#  else
#    define DeclareThreadLocal static __declspec(thread)
#    define DeclareThreadVar __declspec(thread)
#  endif
#elif !defined( __NO_THREAD_LOCAL__ ) && ( defined( __GNUC__ ) )
#    define HAS_TLS 1
#    ifdef __cplusplus
#      define DeclareThreadLocal thread_local
#      define DeclareThreadVar thread_local
#    else
#    define DeclareThreadLocal static __thread
#    define DeclareThreadVar __thread
#  endif
#else
// if no HAS_TLS
#  define DeclareThreadLocal static
#  define DeclareThreadVar
#endif
#ifdef __cplusplus_cli
// these things define a type called 'Byte'
	// which causes confusion... so don't include vcclr for those guys.
#  ifdef SACK_BAG_EXPORTS
// maybe only do this while building sack_bag project itself...
#    if !defined( ZCONF_H )        && !defined( __FT2_BUILD_GENERIC_H__ )        && !defined( ZUTIL_H )        && !defined( SQLITE_PRIVATE )        && !defined( NETSERVICE_SOURCE )        && !defined( LIBRARY_DEF )
//using namespace System;
#    endif
#  endif
#endif
// Defined for building visual studio monolithic build.  These symbols are not relavent with cmakelists.
#ifdef SACK_BAG_EXPORTS
#  define SACK_BAG_CORE_EXPORTS
// exports don't really matter with CLI compilation.
#  ifndef BAG
//#ifndef TARGETNAME
//#  define TARGETNAME "sack_bag.dll"  //$(TargetFileName)
//#endif
#    ifndef __cplusplus_cli
// cli mode, we use this directly, and build the exports in sack_bag.dll directly
#    else
#      define LIBRARY_DEADSTART
#    endif
#define MD5_SOURCE
#define USE_SACK_FILE_IO
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define MEM_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SYSLOG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define _TYPELIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define HTTP_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define TIMER_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define IDLE_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define CLIENTMSG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define FRACTION_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define NETWORK_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define CONFIGURATION_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define FILESYSTEM_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SYSTEM_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define FILEMONITOR_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define VECTOR_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SHA1_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define CONSTRUCT_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define PROCREG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SQLPROXY_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define TYPELIB_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define JSON_EMITTER_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SERVICE_SOURCE
#  ifndef __NO_SQL__
#    ifndef __NO_OPTIONS__
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.    and not NO_SQL and not NO_OPTIONS   */
#      define SQLGETOPTION_SOURCE
#    endif
#  endif
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define PSI_SOURCE
#  ifdef _MSC_VER
#    ifndef JPEG_SOURCE
//wouldn't matter... the external things wouldn't need to define this
//#error projects were not generated with CMAKE, and JPEG_SORUCE needs to be defined
#    endif
//#define JPEG_SOURCE
//#define __PNG_LIBRARY_SOURCE__
//#define FT2_BUILD_LIBRARY   // freetype is internal
//#define FREETYPE_SOURCE		// build Dll Export
#  endif
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define MNG_BUILD_DLL
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define BAGIMAGE_EXPORTS
/* Defined when SACK_BAG_EXPORTS is defined. This was an
 individual library module once upon a time.           */
#ifndef IMAGE_LIBRARY_SOURCE
#  define IMAGE_LIBRARY_SOURCE
#endif
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SYSTRAY_LIBRARAY
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SOURCE_PSI2
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define VIDEO_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
	/* define RENDER SOURCE when building monolithic. */
#     ifndef RENDER_LIBRARY_SOURCE
#       define RENDER_LIBRARY_SOURCE
#     endif
// define a type that is a public name struct type...
// good thing that typedef and struct were split
// during the process of port to /clr option.
//#define PUBLIC_TYPE public
#  else
//#define PUBLIC_TYPE
#    ifdef __cplusplus_CLR
//using namespace System;
#    endif
#  endif
#endif
 // wchar for X_16 definition
#include <wchar.h>
#include <sys/types.h>
#include <sys/stat.h>
#if !defined( _WIN32 ) && !defined( __MAC__ )
#  include <syscall.h>
#elif defined( __MAC__ )
#  include <sys/syscall.h>
#endif
#ifndef MY_TYPES_INCLUDED
#  define MY_TYPES_INCLUDED
// include this before anything else
// thereby allowing us to redefine exit()
 // CHAR_BIT
#  include <limits.h>
 // typelib requires this
#  ifdef _MSC_VER
#    ifndef UNDER_CE
 // memlib requires this, and it MUST be included befoer string.h if it is used.
#      include <intrin.h>
#    endif
#  endif
 // typelib requires this
#  include <string.h>
#  if !defined( WIN32 ) && !defined( _WIN32 ) && !defined( _PNACL )
#    include <dlfcn.h>
#  endif
#  if defined( _MSC_VER )
// disable pointer conversion warnings - wish I could disable this
// according to types...
//#pragma warning( disable:4312; disable:4311 )
// disable deprication warnings of snprintf, et al.
//#pragma warning( disable:4996 )
#    define EMPTY_STRUCT struct { char nothing[]; }
#  endif
#  if defined( __WATCOMC__ )
#     define EMPTY_STRUCT char
#  endif
#  ifdef __cplusplus
/* Could also consider defining 'SACK_NAMESPACE' as 'extern "C"
   ' {' and '..._END' as '}'                                    */
#    define SACK_NAMESPACE namespace sack {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define SACK_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _CONTAINER_NAMESPACE namespace containers {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _CONTAINER_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _LINKLIST_NAMESPACE namespace list {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _LINKLIST_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _DATALIST_NAMESPACE namespace data_list {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _DATALIST_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _SETS_NAMESPACE namespace sets {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _SETS_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _TEXT_NAMESPACE namespace text {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _TEXT_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define TEXT_NAMESPACE SACK_NAMESPACE _CONTAINER_NAMESPACE namespace text {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define TEXT_NAMESPACE_END  } _CONTAINER_NAMESPACE_END SACK_NAMESPACE_END
#  else
/* Define the sack namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define SACK_NAMESPACE
/* Define the sack namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define SACK_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _CONTAINER_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _CONTAINER_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _LINKLIST_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _LINKLIST_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _DATALIST_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _DATALIST_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _SETS_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _SETS_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _TEXT_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _TEXT_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define TEXT_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define TEXT_NAMESPACE_END
#  endif
/* declare composite SACK_CONTAINER namespace to declare sack::container in a single line */
#  define SACK_CONTAINER_NAMESPACE SACK_NAMESPACE _CONTAINER_NAMESPACE
/* declare composite SACK_CONTAINER namespace to close sack::container in a single line */
#  define SACK_CONTAINER_NAMESPACE_END _CONTAINER_NAMESPACE_END SACK_NAMESPACE_END
/* declare composite SACK_CONTAINER namespace to declare sack::container::list in a single line */
#  define SACK_CONTAINER_LINKLIST_NAMESPACE SACK_CONTAINER_NAMESPACE _LISTLIST_NAMESPACE
/* declare composite SACK_CONTAINER namespace to close sack::container::list in a single line */
#  define SACK_CONTAINER_LINKLIST_NAMESPACE_END _LISTLIST_NAMESPACE_END SACK_CONTAINER_NAMESPACE
// this symbols is defined to enforce
// the C Procedure standard - using a stack, and resulting
// in EDX:EAX etc...
#  define CPROC
#  ifdef SACK_BAG_EXPORTS
#    ifdef BUILD_GLUE
// this is used as the export method appropriate for C#?
#      define EXPORT_METHOD [DllImport(LibName)] public
#    else
#      ifdef __cplusplus_cli
#        if defined( __STATIC__ ) || defined( __LINUX__ ) || defined( __ANDROID__ )
#          define EXPORT_METHOD
#          define IMPORT_METHOD extern
#        else
#          define EXPORT_METHOD __declspec(dllexport)
#          define IMPORT_METHOD __declspec(dllimport)
#        endif
#        define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#        define LITERAL_LIB_IMPORT_METHOD extern
//__declspec(dllimport)
#      else
#        if defined( __STATIC__ ) || defined( __LINUX__ ) || defined( __ANDROID__ )
#          define EXPORT_METHOD
#          define IMPORT_METHOD extern
#        else
/* Method to declare functions exported from a DLL. (nothign on
   LINUX or building statically, but __declspec(dllimport) on
   windows )                                                    */
#          define EXPORT_METHOD __declspec(dllexport)
/* method to define a function which will be Imported from a
   library. Under windows, this is probably
   __declspec(dllimport). Under linux this is probably 'extern'. */
#          define IMPORT_METHOD __declspec(dllimport)
#        endif
#        define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#        define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
#      endif
#    endif
#  else
#  if ( !defined( __STATIC__ ) && defined( WIN32 ) && !defined( __cplusplus_cli) )
#    define EXPORT_METHOD __declspec(dllexport)
#    define IMPORT_METHOD __declspec(dllimport)
#    define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#    define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
#  else
// MRT:  This is needed.  Need to see what may be defined wrong and fix it.
#    if defined( __LINUX__ ) || defined( __STATIC__ ) || defined( __ANDROID__ )
#      define EXPORT_METHOD
#      define IMPORT_METHOD extern
#      define LITERAL_LIB_EXPORT_METHOD
#      define LITERAL_LIB_IMPORT_METHOD extern
#    else
#      define EXPORT_METHOD __declspec(dllexport)
#      define IMPORT_METHOD __declspec(dllimport)
/* Define how methods in LITERAL_LIBRARIES are exported.
   literal_libraries are libraries that are used for plugins,
   and are dynamically loaded by code. They break the rules of
   system prefix and suffix extensions. LITERAL_LIBRARIES are
   always dynamic, and never static.                           */
#      define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
/* Define how methods in LITERAL_LIBRARIES are imported.
   literal_libraries are libraries that are used for plugins,
   and are dynamically loaded by code. They break the rules of
   system prefix and suffix extensions. LITERAL_LIBRARIES are
   always dynamic, and never static.                           */
#      define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
#    endif
#  endif
#endif
#ifdef __EMSCRIPTEN__
#include <emscripten.h>
#include <emscripten/emscripten.h>
// Emscripten exports just need to be not optimized out.
#  undef  EXPORT_METHOD
#  define EXPORT_METHOD                EMSCRIPTEN_KEEPALIVE
#  undef  LITERAL_LIB_EXPORT_METHOD
#  define LITERAL_LIB_EXPORT_METHOD    EMSCRIPTEN_KEEPALIVE
#endif
// used when the keword specifying a structure is packed
// needs to prefix the struct keyword.
#define PREFIX_PACKED
// private thing left as a note, and forgotten.  some compilers did not define offsetof
#define my_offsetof( ppstruc, member ) ((uintptr_t)&((*ppstruc)->member)) - ((uintptr_t)(*ppstruc))
SACK_NAMESPACE
#ifdef BCC16
#define __inline__
#define MAINPROC(type,name)     type _pascal name
// winproc is intended for use at libmain/wep/winmain...
#define WINPROC(type,name)      type _far _pascal _export name
// callbackproc is for things like timers, dlgprocs, wndprocs...
#define CALLBACKPROC(type,name) type _far _pascal _export name
#define PUBLIC(type,name)       type STDPROC _export name
 /* here would be if dwReason == process_attach */
#define LIBMAIN() WINPROC(int, LibMain)(HINSTANCE hInstance, WORD wDataSeg, WORD wHeapSize, LPSTR lpCmdLine )		 { {
 /* end if */
 /*endproc*/
#define LIBEXIT() } }	    int STDPROC WEP(int nSystemExit )  {
#define LIBMAIN_END()  }
// should use this define for all local defines...
// this will allow one place to modify ALL _pascal or not to _pascal decls.
#define STDPROC _far _pascal
#endif
#if defined( __LCC__ ) || defined( _MSC_VER ) || defined(__DMC__) || defined( __WATCOMC__ )
#ifdef __WATCOMC__
#undef CPROC
#define CPROC __cdecl
#define STDPROC __cdecl
#ifndef __WATCOMC__
// watcom windef.h headers define this
#define STDCALL _stdcall
#endif
#if __WATCOMC__ >= 1280
// watcom windef.h headers no longer define this.
#define STDCALL __stdcall
#endif
#undef PREFIX_PACKED
#define PREFIX_PACKED _Packed
#else
#undef CPROC
//#error blah
#define CPROC __cdecl
#define STDPROC
#define STDCALL _stdcall
#endif
#define far
#define huge
#define near
#define _far
#define _huge
#define _near
/* portability type for porting legacy 16 bit applications. */
/* portability macro for legacy 16 bit applications. */
#define __far
#ifndef FAR
#define FAR
#endif
//#define HUGE
//#ifndef NEAR
//#define NEAR
//#endif
#define _fastcall
#ifdef __cplusplus
#ifdef __cplusplus_cli
#define PUBLIC(type,name) extern "C"  LITERAL_LIB_EXPORT_METHOD type CPROC name
#else
//#error what the hell!?
// okay Public functions are meant to be loaded with LoadFuncion( "library" , "function name"  );
#define PUBLIC(type,name) extern "C"  LITERAL_LIB_EXPORT_METHOD type CPROC name
#endif
#else
#define PUBLIC(type,name) LITERAL_LIB_EXPORT_METHOD type CPROC name
#endif
#define MAINPROC(type,name)  type WINAPI name
#define WINPROC(type,name)   type WINAPI name
#define CALLBACKPROC(type,name) type CALLBACK name
#if defined( __WATCOMC__ )
#define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(TARGETNAME) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#define LIBMAIN_END() }
#else
#ifdef TARGETNAME
#define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(TARGETNAME) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#else
#define LIBMAIN()   TARGETNAME_NOT_DEFINED
#endif
#define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#define LIBMAIN_END() }
#endif
#define PACKED
#endif
#if defined( __GNUC__ )
#  ifndef STDPROC
#    define STDPROC
#  endif
#  ifndef STDCALL
 // for IsBadCodePtr which isn't a linux function...
#    define STDCALL
#  endif
#  ifndef WINAPI
#    ifdef __LINUX__
#       define WINAPI
#    else
#       define WINAPI __stdcall
#    endif
#  endif
#  ifndef PASCAL
//#define PASCAL
#  endif
#  define WINPROC(type,name)   type WINAPI name
#  define CALLBACKPROC( type, name ) type name
#  define PUBLIC(type,name) EXPORT_METHOD type CPROC name
#  define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(TARGETNAME) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#  define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#  define LIBMAIN_END()  }
/* Portability Macro for porting legacy code forward. */
#  define FAR
#  define NEAR
//#define HUGE
#  define far
#  define near
#  define huge
#  define PACKED __attribute__((packed))
#endif
#if defined( BCC32 )
#define far
#define huge
/* define obsolete keyword for porting purposes */
/* defined for porting from 16 bit environments */
#define near
/* portability macro for legacy 16 bit applications. */
#define _far
#define _huge
#define _near
/* portability type for porting to compilers that don't inline. */
/* portability macro for legacy 16 bit applications. */
#define __inline__
#define MAINPROC(type,name)     type _pascal name
// winproc is intended for use at libmain/wep/winmain...
#define WINPROC(type,name)      EXPORT_METHOD type _pascal name
// callbackproc is for things like timers, dlgprocs, wndprocs...
#define CALLBACKPROC(type,name) EXPORT_METHOD type _stdcall name
#define STDCALL _stdcall
#define PUBLIC(type,name)        type STDPROC name
#ifdef __STATIC__
			/*Log( "Library Enter" );*/
#define LIBMAIN() static WINPROC(int, LibMain)(HINSTANCE hInstance, DWORD dwReason, void *unused )		 { if( dwReason == DLL_PROCESS_ATTACH ) {
 /* end if */
#define LIBEXIT() } if( dwReason == DLL_PROCESS_DETACH ) {
#define LIBMAIN_END()  } return 1; }
#else
			/*Log( "Library Enter" );*/
#define LIBMAIN() WINPROC(int, LibMain)(HINSTANCE hInstance, DWORD dwReason, void *unused )		 { if( dwReason == DLL_PROCESS_ATTACH ) {
 /* end if */
#define LIBEXIT() } if( dwReason == DLL_PROCESS_DETACH ) {
#define LIBMAIN_END()  } return 1; }
#endif
// should use this define for all local defines...
// this will allow one place to modify ALL _pascal or not to _pascal decls.
#define STDPROC _pascal
#define PACKED
#endif
#define TOCHR(n) #n[0]
#define TOSTR(n) #n
#define STRSYM(n) TOSTR(n)
#define _WIDE__FILE__(n) n
#define WIDE__FILE__ _WIDE__FILE__(__FILE__)
/* a constant text string that represents the current source
   filename and line... fourmated as "source.c(11) :"        */
#define FILELINE  TEXT(__FILE__) "(" TEXT(STRSYM(__LINE__))" : ")
#if defined( _MSC_VER ) || defined( __PPCCPP__ )
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnote(msg) message( FILELINE msg )
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnoteonly(msg) message( msg )
#else
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnote(msg) msg
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnoteonly(msg) msg
#endif
/* specify a consistant macro to pass current file and line information.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_SRC         , __FILE__, __LINE__
/* specify a consistant macro to pass current file and line information, to functions which void param lists.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDSRC     __FILE__, __LINE__
//#define FILELINE_LEADSRC     __FILE__, __LINE__,
/* specify a consistant macro to define file and line parameters, to functions with otherwise void param lists.  This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDPASS    CTEXTSTR pFile, uint32_t nLine
//#define FILELINE_LEADPASS    CTEXTSTR pFile, uint32_t nLine,
/* specify a consistant macro to define file and line parameters.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_PASS        , CTEXTSTR pFile, uint32_t nLine
/* specify a consistant macro to forward file and line parameters.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_RELAY       , pFile, nLine
/* specify a consistant macro to forward file and line parameters.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_NULL        , NULL, 0
/* specify a consistant macro to forward file and line parameters, to functions which have void parameter lists without this information.  This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDRELAY   pFile, nLine
/* specify a consistant macro to format file and line information for printf formated strings. */
#define FILELINE_FILELINEFMT "%s(%" _32f "): "
#define FILELINE_FILELINEFMT_MIN "%s(%" _32f ")"
#define FILELINE_NULL        , NULL, 0
#define FILELINE_VOIDNULL    NULL, 0
/* define static parameters which are the declaration's current file and line, for stubbing in where debugging is being stripped.
  usage
    FILELINE_VARSRC: // declare pFile and nLine variables.
	*/
#define FILELINE_VARSRC       CTEXTSTR pFile = __FILE__; uint32_t nLine = __LINE__
// this is for passing FILE, LINE information to allocate
// useful during DEBUG phases only...
// drop out these debug relay paramters for managed code...
// we're going to have the full call frame managed and known...
#if !defined( _DEBUG ) && !defined( _DEBUG_INFO )
#  if defined( __LINUX__ ) && !defined( __PPCCPP__ )
//#warning "Setting DBG_PASS and DBG_FORWARD to be ignored."
#  else
//#pragma pragnoteonly("Setting DBG_PASS and DBG_FORWARD to be ignored"  )
#  endif
#define DBG_AVAILABLE   0
/* in NDEBUG mode, pass nothing */
#define DBG_SRC
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_VOIDSRC
/* <combine sack::DBG_PASS>
   \#define DBG_LEADSRC in NDEBUG mode, declare (void) */
/* <combine sack::DBG_PASS>
   \ \                      */
#define DBG_VOIDPASS    void
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_PASS
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_RELAY
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_NULL */
#define DBG_NULL
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_VOIDRELAY
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_FILELINEFMT
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_FILELINEFMT_MIN
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing
   Example
   printf( DBG_FILELINEFMT ": extra message" DBG_PASS ); */
#define DBG_VARSRC
#else
	// these DBG_ formats are commented out from duplication in sharemem.h
#  if defined( __LINUX__ ) && !defined( __PPCCPP__ )
//#warning "Setting DBG_PASS and DBG_FORWARD to work."
#  else
//#pragma pragnoteonly("Setting DBG_PASS and DBG_FORWARD to work"  )
#  endif
// used to specify whether debug information is being passed - can be referenced in compiled code
#define DBG_AVAILABLE   1
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_SRC */
#define DBG_SRC         FILELINE_SRC
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDSRC */
#define DBG_VOIDSRC     FILELINE_VOIDSRC
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDPASS */
#define DBG_VOIDPASS    FILELINE_VOIDPASS
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
/* Example
   This example shows forwarding debug information through a
   chain of routines.
   <code lang="c++">
   void ReportFunction( int sum DBG_PASS )
   {
       printf( "%s(%d):started this whole mess\\n" DBG_RELAY );
   }
   void TrackingFunction( int a, int b DBG_PASS )
   {
       ReportFunction( a+b, DBG_RELAY );
   }
   void CallTrack( void )
   {
       TrackingFunction( 1, 2 DBG_SRC );
   }
   </code>
   In this example, the debug information is passed to the
   logging system. This allows logging to blame the user
   application for allocations, releases, locks, etc...
   <code lang="c++">
   void MyAlloc( int size DBG_PASS )
   {
       _lprintf( DBG_RELAY )( ": alloc %d\\n", size );
   }
   void g( void )
   {
       lprintf( "Will Allocate %d\\n", 32 );
       MyAlloc( 32 DBG_SRC );
   }
   </code>
   This example uses the void argument macros
   <code>
   void SimpleFunction( DBG_VOIDPASS )
   {
       // this function usually has (void) parameters.
   }
   void f( void )
   {
       SimpleFunction( DBG_VOIDSRC );
   }
   </code>
   Description
   in NDEBUG mode, pass nothing.
   This function allows specification of DBG_RELAY or DBG_SRC
   under debug compilation. Otherwise, the simple AddLink macro
   should be used. DBG_RELAY can be used to forward file and
   line information which has been passed via DBG_PASS
   declaration in the function parameters.
   This is a part of a set of macros which allow additional
   logging information to be passed.
   These 3 are the most commonly used.
   DBG_SRC - this passes the current __FILE__, __LINE__
   \parameters.
   DBG_PASS - this is used on a function declaration, is a
   filename and line number from DBG_SRC or DBG_RELAY.
   DBG_RELAY - this passes the file and line passed to this
   function to another function with DBG_PASS defined on it.
   DBG_VOIDPASS - used when the argument list is ( void )
   without debugging information.
   DBG_VOIDSRC - used to call a function who's argument list is
   ( void ) without debugging information.
   DBG_VOIDRELAY - pass file and line information forward to
   another function, who's argument list is ( void ) without
   debugging information.
   Remarks
   The SACK library is highly instrumented with this sort of
   information. Very commonly the only difference between a
   specific function called 'MyFunctionName' and
   'MyFunctionNameEx' is the addition of debug information
   tracking.
   The following code blocks show the evolution added to add
   instrumentation...
   <code lang="c++">
   int MyFunction( int param )
   {
       // do stuff
   }
   int CallingFunction( void )
   {
       return MyFunction();
   }
   </code>
   Pretty simple code, a function that takes a parameter, and a
   function that calls it.
   The first thing is to extend the called function.
   <code>
   int MyFunctionEx( int param DBG_PASS )
   {
       // do stuff
   }
   </code>
   And provide a macro for everyone else calling the function to
   automatically pass their file and line information
   <code lang="c++">
   \#define MyFunction(param)  MyFunctionEx(param DBG_SRC)
   </code>
   Then all-together
   <code>
   \#define MyFunction(param)  MyFunctionEx(param DBG_SRC)
   int MyFunctionEx( int param DBG_PASS )
   {
       // do stuff
   }
   int CallingFunction( void )
   {
       // and this person calling doesn't matter
       // does require a recompile of source.
       return MyFunction( 3 );
   }
   </code>
   But then... what if CallingFunction decided wasn't really the
   one at fault, or responsible for the allocation, or other
   issue being tracked, then she could be extended....
   <code>
   int CallingFunctionEx( DBG_VOIDPASS )
   \#define CallingFunction() CallingFunction( DBG_VOIDSRC )
   {
       // and this person calling doesn't matter
       // does require a recompile of source.
       return MyFunction( 1 DBG_RELAY );
   }
   </code>
   Now, calling function will pass it's callers information to
   MyFunction....
   Why?
   Now, when you call CreateList, your code callng the list
   creation method is marked as the one who allocates the space.
   Or on a DeleteList, rather than some internal library code
   being blamed, the actual culprit can be tracked and
   identified, because it's surely not the fault of CreateList
   that the reference to the memory for the list wasn't managed
   correctly.
   Note
   It is important to note, every usage of these macros does not
   have a ',' before them. This allows non-debug code to
   eliminate these extra parameters cleanly. If the ',' was
   outside of the macro, then it would remain on the line, and
   an extra parameter would have be be passed that was unused.
   This is also why DBG_VOIDPASS exists, because in release mode
   this is substituted with 'void'.
   In Release mode, DBG_VOIDRELAY becomes nothing, but when in
   debug mode, DBG_RELAY has a ',' in the macro, so without a
   paramter f( DBG_RELAY ) would fail; on expansion this would
   be f( , pFile, nLine ); (note the extra comma, with no
   parameter would be a syntax error.                            */
#define DBG_PASS        FILELINE_PASS
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_RELAY */
#define DBG_RELAY       FILELINE_RELAY
/* <combine sack::DBG_PASS>
	  in _DEBUG mode, pass FILELINE_NULL */
#define DBG_NULL        FILELINE_NULL
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDRELAY */
#define DBG_VOIDRELAY   FILELINE_VOIDRELAY
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_FILELINEFMT */
#define DBG_FILELINEFMT FILELINE_FILELINEFMT
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_FILELINEFMT_MIN */
#define DBG_FILELINEFMT_MIN FILELINE_FILELINEFMT_MIN
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VARSRC */
#define DBG_VARSRC      FILELINE_VARSRC
#endif
// cannot declare _0 since that overloads the
// vector library definition for origin (0,0,0,0,...)
//typedef void             _0; // totally unusable to declare 0 size things.
/* the only type other than when used in a function declaration that void is valid is as a pointer to void. no _0 type exists
	 (it does, but it's in vectlib, and is an origin vector)*/
typedef void             *P_0;
/*
 * several compilers are rather picky about the types of data
 * used for bit field declaration, therefore this type
 * should be used instead of uint32_t (DWORD)
 */
typedef unsigned int  BIT_FIELD;
/*
 * several compilers are rather picky about the types of data
 * used for bit field declaration, therefore this type
 * should be used instead of int32_t (LONG)
 */
typedef int  SBIT_FIELD;
// have to do this on a per structure basis - otherwise
// any included headers with structures to use will get
// padded as normal; this is appended to a strcture
// and is ued on GCC comiplers for __attribute__((packed))
#ifndef PACKED
#  define PACKED
#endif
/* An pointer to a volatile unsigned integer type that is 64 bits long. */
//typedef volatile uint64_t  *volatile int64_t*;
/* An pointer to a volatile pointer size type that is as long as a pointer. */
typedef volatile uintptr_t        *PVPTRSZVAL;
/* an unsigned type meant to index arrays.  (By convention, arrays are not indexed negatively.)  An index which is not valid is INVALID_INDEX, which equates to 0xFFFFFFFFUL or negative one cast as an INDEX... ((INDEX)-1). */
typedef size_t         INDEX;
/* An index which is not valid; equates to 0xFFFFFFFFUL or negative one cast as an INDEX... ((INDEX)-1). */
#define INVALID_INDEX ((INDEX)-1)
// constant text string content
typedef const char     *CTEXTSTR;
/* A non constant array of TEXTCHAR. A pointer to TEXTCHAR. A
   pointer to non-constant characters. (A non-static string
   probably)                                                  */
typedef char           *TEXTSTR;
#if defined( __LINUX__ ) && defined( __cplusplus )
// pointer to constant text string content
typedef TEXTSTR const  *PCTEXTSTR;
#else
// char const *const *
typedef CTEXTSTR const *PCTEXTSTR;
#endif
/* a text 8 bit character  */
typedef char            TEXTCHAR;
/* a character rune.  Strings should be interpreted as UTF-8 or 16 depending on UNICODE compile option.
   GetUtfChar() from strings.  */
typedef uint32_t             TEXTRUNE;
/* Used to handle returned values that are invalid runes; past end or beginning of string for instance */
#define INVALID_RUNE  0x80000000
//typedef enum { FALSE, TRUE } LOGICAL; // smallest information
#ifndef FALSE
#define FALSE 0
/* Define TRUE when not previously defined in the platform. TRUE
   is (!FALSE) so anything not 0 is true.                        */
#define TRUE (!FALSE)
#endif
/* Meant to hold boolean and only boolean values. Should be
   implemented per-platform as appropriate for the bool type the
   compiler provides.                                            */
typedef uint32_t LOGICAL;
/* This is a pointer. It is a void*. It is meant to point to a
   single thing, and cannot be used to reference arrays of bytes
   without recasting.                                            */
typedef P_0 POINTER;
/* This is a pointer to constant data. void const *. Compatible
   with things like char const *.                               */
typedef const void *CPOINTER;
SACK_NAMESPACE_END
//------------------------------------------------------
// formatting macro defintions for [vsf]printf output of the above types
#if !defined( _MSC_VER ) || ( _MSC_VER >= 1900 )
#define __STDC_FORMAT_MACROS
#include <inttypes.h>
#endif
SACK_NAMESPACE
/* 16 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16f   "u"
/* 16 bit hex output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16fx   "x"
/* 16 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16fX   "X"
/* 16 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\>               */
#define _16fs   "d"
/* 8 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8f   "u"
/* 8 bit hex output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8fx   "x"
/* 8 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8fX   "X"
/* 8 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\>               */
#define _8fs   "d"
#if defined( __STDC_FORMAT_MACROS )
#  define _32f   PRIu32
#  define _32fx    PRIx32
#  define _32fX    PRIX32
#  define _32fs    PRId32
#  define _64f    PRIu64
#  define _64fx   PRIx64
#  define _64fX   PRIX64
#  define _64fs   PRId64
#  define _64f    PRIu64
#  define _64fx   PRIx64
#  define _64fX   PRIX64
#  define _64fs   PRId64
// non-unicode strings
#  define c_32f    PRIu32
#  define c_32fx   PRIx32
#  define c_32fX   PRIX32
#  define c_32fs   PRId32
#  define c_64f    PRIu64
#  define c_64fx   PRIx64
#  define c_64fX   PRIX64
#  define c_64fs   PRId64
#else
#  define _32f   "u"
#  define _32fx   "x"
#  define _32fX   "X"
#  define _32fs   "d"
#  define c_32f   "u"
#  define c_32fx  "x"
#  define c_32fX  "X"
#  define c_32fs  "d"
#  define c_64f    "llu"
#  define c_64fx   "llx"
#  define c_64fX   "llX"
#  define c_64fs   "lld"
#endif
#  define _cstring_f "s"
#  define _string_f "s"
#  define _ustring_f "S"
#if defined( __64__ )
#  if defined( __STDC_FORMAT_MACROS )
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f     PRIu64
#      define _size_fx    PRIx64
#      define _size_fX    PRIX64
#      define _size_fs    PRId64
#      define c_size_f    PRIu64
#      define c_size_fx   PRIx64
#      define c_size_fX   PRIX64
#      define c_size_fs   PRId64
#    else
#      define _size_f    "zu"
#      define _size_fx   "zx"
#      define _size_fX   "zX"
#      define _size_fs   "zd"
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs  PRIuPTR
#    define _PTRSZVALfx  PRIxPTR
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  else
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f    _64f
#      define _size_fx   _64fx
#      define _size_fX   _64fX
#      define _size_fs   _64fs
#      define c_size_f   c_64f
#      define c_size_fx  c_64fx
#      define c_size_fX  c_64fX
#      define c_size_fs  c_64fs
#    else
#      define _size_f    "zu"
#      define _size_fx   "zx"
#      define _size_fX   "zX"
#      define _size_fs   "zd"
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs  PRIuPTR
#    define _PTRSZVALfx  PRIxPTR
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  endif
#else
#  if defined( __STDC_FORMAT_MACROS )
      // this HAS been fixed in UCRT - 2015!  but it'll take 5 years before everyone has that...
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f     PRIu32
#      define _size_fx    PRIx32
#      define _size_fX    PRIX32
#      define _size_fs    PRId32
#      define c_size_f    PRIu32
#      define c_size_fx   PRIx32
#      define c_size_fX   PRIX32
#      define c_size_fs   PRId32
#    else
#      define _size_f    "zu"
#      define _size_fx   "zx"
#      define _size_fX   "zX"
#      define _size_fs   "zd"
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs  PRIuPTR
#    define _PTRSZVALfx  PRIxPTR
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  else
      // this HAS been fixed in UCRT - 2015!  but it'll take 5 years before everyone has that...
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f    _32f
#      define _size_fx   _32fx
#      define _size_fX   _32fX
#      define _size_fs   _32fs
#      define c_size_f    c_32f
#      define c_size_fx   c_32fx
#      define c_size_fX   c_32fX
#      define c_size_fs   c_32fs
#    else
#      define _size_f    "zu"
#      define _size_fx   "zx"
#      define _size_fX   "zX"
#      define _size_fs   "zd"
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs  PRIuPTR
#    define _PTRSZVALfx  PRIxPTR
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  endif
#endif
#define PTRSZVALf "p"
#define _PTRSZVALf "p"
#if defined( _MSC_VER ) && ( _MSC_VER < 1900 )
/* 64 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIu64              */
#define _64f    "llu"
/* 64 bit hex output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIxFAST64                */
#define _64fx   "llx"
/* 64 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIxFAST64                */
#define _64fX   "llX"
/* 64 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\> as PRIdFAST64               */
#define _64fs   "lld"
#endif
// This should be for several years a
// sufficiently large type to represent
// threads and processes.
typedef uint64_t THREAD_ID;
#define GetMyThreadIDNL GetMyThreadID
#if defined( _WIN32 )
#  define _GetMyThreadID()  ( (( ((uint64_t)GetCurrentProcessId()) << 32 ) | ( (uint64_t)GetCurrentThreadId() ) ) )
#  define GetMyThreadID()  (GetThisThreadID())
#else
// this is now always the case
// it's a safer solution anyhow...
#  ifdef __MAC__
#    define GetMyThreadID()  (( ((uint64_t)getpid()) << 32 ) | ( (uint64_t)( syscall(SYS_thread_selfid) ) ) )
#  else
#    ifndef GETPID_RETURNS_PPID
#      define GETPID_RETURNS_PPID
#    endif
#    ifdef GETPID_RETURNS_PPID
#      ifdef __ANDROID__
#        define GetMyThreadID()  (( ((uint64_t)getpid()) << 32 ) | ( (uint64_t)(gettid()) ) )
#      else
#        if defined( __EMSCRIPTEN__ )
#          define GetMyThreadID()  ( (uint64_t)(pthread_self()) )
#        else
#          define GetMyThreadID()  (( ((uint64_t)getpid()) << 32 ) | ( (uint64_t)(syscall(SYS_gettid)) ) )
#        endif
#      endif
#    else
#      define GetMyThreadID()  (( ((uint64_t)getppid()) << 32 ) | ( (uint64_t)(getpid()|0x40000000)) )
#    endif
#  endif
#  define _GetMyThreadID GetMyThreadID
#endif
//---------------------- Declare Link; 'single and a half'ly-linked lists -----------------------
// Thse macros are for linking and unlininking things in a linked list.
// The list is basically a singly-linked list, but also references the pointer that
// is pointing at the current node.  This simplifies insert/remove operations, because
// the specific list that the node is in, is not required.
// List heads will always be updated correctly.
//
// A few 'tricks' are available, such as
//     0) These are deemed dangerous; and uncomprehendable by anyone but the maintainer.
//        use at your own time and expense required to explain WHY these work.
//     1) when declaring a root node, include another node before it, and it's
//        simple to make this a circularly linked list.
//     2) defining DeclareLink at the start of the strcture, the 'me' pointer
//        also happens to be 'prior', so you can step through the list in both
//        directions.
//
//
//
// struct my_node {
//    DeclareLink( struct my_node );
//    // ...
// };
//
// that declares
//      struct my_node *next;  // the next node in list.
//      struct my_node **me;   // address of the pointer pointing to 'me';
//
//
//  struct my_node *root; // a root of a list of my_node.  It should be initialized to NULL.
//
//  struct my_node *newNode = (struct my_node*)malloc( sizeof( *newNode ) );
//     // does not require next or me to be initiialized.
//  LinkThing( root, newNode );
//     // now newNode is in the list.
//
//  to remove from a list
//
//  struct my_node *someNode; // this should be a pointer to some valid node.
//  UnlinkThing( someNode );
//     The new node is now not in the list.
//
//  To move one node from one list to another
//
//   struct my_node *rootAvail;  // available nodes
//   struct my_node *rootUsed;   // nodes in use
//
//   struct my_node *someNode; // some node in a list
//   someNode = rootAvail; // get first available.
//   if( !someNode ) ; // create a new one or abort
//   RelinkThing( rootUsed, someNode );
//      'someNode' is removed from its existing list, and added to the 'rootUsed' list.
//
// For Declaring the link structure members for lists
#define DeclareLink( type )  type *next; type **me
/* Link a new node into the list.
   Example
   struct mynode
   {
       DeclareLink( struct mynode );
   } *node;
	struct mynode *list;
   // node allocation not shown.
	LinkThing( list_root, node );
*/
#define LinkThing( root, node )		     ((( (node)->next = (root) )?	        (((root)->me) = &((node)->next)):0),	  (((node)->me) = &(root)),	             ((root) = (node)) )
/* Link a node to the end of a list. LinkThing() inserts the new
 node as the new head of the list.
 this has to scan the list to find the end, so it is a O(n) operation.
 All other linked list operations are O(1)
 */
#define LinkLast( root, type, node ) if( node ) do { if( !root )	 { root = node; (node)->me=&root; }	 else { type tmp;	 for( tmp = root; tmp->next; tmp = tmp->next );	 tmp->next = (node);	 (node)->me = &tmp->next;	 } } while (0)
// put 'Thing' after 'node'
// inserts 'node' after Thing
#define LinkThingAfter( node, thing )	 ( ( (thing)&&(node))	   ?(((((thing)->next = (node)->next))?((node)->next->me = &(thing)->next):0)	  ,((thing)->me = &(node)->next), ((node)->next = thing))	  :((node)=(thing)) )
//
// put 'Thing' before 'node'... so (*node->me) = thing
// similar to LinkThingAfter but puts the new 'thing'
// before the 'node' specified.
#define LinkThingBefore( node, thing )	 {  thing->next = (*node->me);	(*node->me) = thing;    thing->me = node->me;       node->me = &thing->next;     }
// move a list from one list to another.
// unlinks node from where it was, inserts at the head of another.
// this can also be use to reproiritize within the same list.
#define RelinkThing( root, node )	   ((( node->me && ( (*node->me)=node->next ) )?	  node->next->me = node->me:0),(node->next = NULL),(node->me = NULL),node),	 ((( node->next = root )?	        (root->me = &node->next):0),	  (node->me = &root),	             (root = node) )
/* Remove a node from a list. Requires only the node. */
#define UnlinkThing( node )	                      ((( (node) && (node)->me && ( (*(node)->me)=(node)->next ) )?	  (node)->next->me = (node)->me:0),((node)->next = NULL),((node)->me = NULL),(node))
// this has two expressions duplicated...
// but in being so safe in this expression,
// the self-circular link needs to be duplicated.
// GrabThing is used for nodes which are circularly bound
#define GrabThing( node )	    ((node)?(((node)->me)?(((*(node)->me)=(node)->next)?	 ((node)->next->me=(node)->me),((node)->me=&(node)->next):NULL):((node)->me=&(node)->next)):NULL)
/* Go to the next node with links declared by DeclareLink
 safe iterator macro that tests if node is valid, which returns
 the next item in the list, else returns NULL
 */
#define NextLink(node) ((node)?(node)->next:NULL)
// everything else is called a thing... should probably migrate to using this...
#define NextThing(node) ((node)?(node)->next:NULL)
//----------- FLAG SETS (single bit fields) -----------------
/* the default type to use for flag sets - flag sets are arrays of bits
 which can be set/read with/as integer values an index.
 All of the fields in a maskset are the same width */
#define FLAGSETTYPE uintmax_t
/* the number of bits a specific type is.
   Example
   int bit_size_int = FLAGTYPEBITS( int ); */
#define FLAGTYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* how many bits to add to make sure we round to the next greater index if even 1 bit overflows */
#define FLAGROUND(t) (FLAGTYPEBITS(t)-1)
/* the index of the FLAGSETTYPE which contains the bit in question */
#define FLAGTYPE_INDEX(t,n)  (((n)+FLAGROUND(t))/FLAGTYPEBITS(t))
/* how big the flag set is in count of FLAGSETTYPEs required in a row ( size of the array of FLAGSETTYPE that contains n bits) */
#define FLAGSETSIZE(t,n) (FLAGTYPE_INDEX(t,n) * sizeof( FLAGSETTYPE ) )
// declare a set of flags...
#define FLAGSET(v,n)   FLAGSETTYPE (v)[((n)+FLAGROUND(FLAGSETTYPE))/FLAGTYPEBITS(FLAGSETTYPE)]
// set a single flag index
#define SETFLAG(v,n)   ( ( (v)[(n)/FLAGTYPEBITS((v)[0])] |= (FLAGSETTYPE)1 << ( (n) & FLAGROUND((v)[0]) )),1)
// clear a single flag index
#define RESETFLAG(v,n) ( ( (v)[(n)/FLAGTYPEBITS((v)[0])] &= ~( (FLAGSETTYPE)1 << ( (n) & FLAGROUND((v)[0]) ) ) ),0)
// test if a flags is set
//  result is 0 or not; the value returned is the bit shifted within the word, and not always '1'
#define TESTFLAG(v,n)  ( (v)[(n)/FLAGTYPEBITS((v)[0])] & ( (FLAGSETTYPE)1 << ( (n) & FLAGROUND((v)[0]) ) ) )
// reverse a flag from 1 to 0 and vice versa
// return value is undefined... and is a whole bunch of flags from some offset...
// if you want ot toggle and flag and test the result, use TESTGOGGLEFLAG() instead.
#define TOGGLEFLAG(v,n)   ( (v)[(n)/FLAGTYPEBITS((v)[0])] ^= (FLAGSETTYPE)1 << ( (n) & FLAGROUND((v)[0]) ))
// Toggle a bit, return the state of the bit after toggling.
#define TESTTOGGLEFLAG(v,n)  ( TOGGLEFLAG(v,n), TESTFLAG(v,n) )
//----------- MASK SETS -----------------
//  MASK Sets are arrays of bit-fields of some bit-width (5, 3, ... )
//  they are set/returned as integer values.
//  They are stored-in/accessed via a uint8_t which gives byte-offset calculations.
// they return their value as uintmax_t from the offset memory address directly;
//   Some platforms(Arm) may SIGBUS because of wide offset accesses spanning word boundaries.
//   This issue may be fixed by rounding, grabbing the word aligned values and shifting manually
// Declarataion/Instantiation of a mask set is done with MASKSET macro below
// 32 bits max for range on mask
#define MASK_MAX_LENGTH (sizeof(MASKSET_READTYPE)*CHAR_BIT)
/* gives a 32 bit mask possible from flagset..
 - updated; return max int possible; but only the low N bits will be set
 - mask sets are meant for small values, but could be used for like 21 bit fields. (another form of unicode encoding I suppose)
 */
#define MASKSET_READTYPE uintmax_t
// gives byte index...
#define MASKSETTYPE uint8_t
/* how many bits the type specified can hold
   Parameters
   t :  data type to measure (int, uint32_t, ... ) */
#define MASKTYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* the maximum number of bits storable in a type */
#define MASK_MAX_TYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* round up to the next count of types that fits 1 bit - used as a cieling round factor */
#define MASKROUND(t) (MASKTYPEBITS(t)-1)
/* define MAX_MAX_ROUND factor based on MASKSET_READTYPE - how to read it... */
#define MASK_MAX_ROUND() (MASK_MAX_TYPEBITS(MASKSET_READTYPE)-1)
/* byte index of the start of the mask
   Parameters
   t :  type to measure with
   n :  mask index                     */
#define MASKTYPE_INDEX(t,n)  (((n)+MASKROUND(t))/MASKTYPEBITS(t))
/* The number of bytes the set would be.
   Parameters
   t :  the given type to measure with
   n :  the count of masks to fit.       */
#define MASKSETSIZE(t,n) (MASKTYPE_INDEX(t,(n+1)))
// declare a set of flags...
#define MASK_TOP_MASK_VAL(length,val) ((val)&( ((MASKSET_READTYPE)-1) >> ((sizeof(MASKSET_READTYPE) * CHAR_BIT)-(length)) ))
/* the mask in the dword resulting from shift-right.   (gets a mask of X bits in length) */
#define MASK_TOP_MASK(length) ( ((MASKSET_READTYPE)-1) >> ((sizeof(MASKSET_READTYPE) * CHAR_BIT)-(length)) )
/* the mast in the dword shifted to the left to overlap the field in the word */
#define MASK_MASK(n,length)   (MASK_TOP_MASK(length) << (((n)*(length)) & (sizeof(MASKSET_READTYPE) - 1) ) )
// masks value with the mask size, then applies that mask back to the correct word indexing
#define MASK_MASK_VAL(n,length,val)   (MASK_TOP_MASK_VAL(length,val) << (((n)*(length))&0x7) )
/* declare a mask set.
 MASKSET( maskVariableName
        , 32 //number of items
		  , 5 // number of bits per field
		  );
   declares
	uint8_t maskVariableName[ (32*5 +(CHAR_BIT-1))/CHAR_BIT ];  //data array used for storage.
   const int askVariableName_mask_size = 5;  // used aautomatically by macros
*/
#define MASKSET(v,n,r)  MASKSETTYPE  (v)[(((n)*(r))+MASK_MAX_ROUND())/MASKTYPEBITS(MASKSETTYPE)]; const int v##_mask_size = r;
/* set a field index to a value
    SETMASK( askVariableName, 3, 13 );  // set set member 3 to the value '13'
 */
#define SETMASK(v,n,val)    (((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS((v)[0])))[0] =    ( ((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS(uint8_t)))[0]                                  & (~(MASK_MASK(n,v##_mask_size))) )	                                                                           | MASK_MASK_VAL(n,v##_mask_size,val) )
/* get the value of a field
     GETMASK( maskVariableName, 3 );   // returns '13' given the SETMASK() example code.
 */
#define GETMASK(v,n)  ( ( ((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS((v)[0])))[0]         & MASK_MASK(n,v##_mask_size) )	                                                                           >> (((n)*(v##_mask_size))&0x7))
/* This type stores data, it has a self-contained length in
   bytes of the data stored.  Length is in characters       */
_CONTAINER_NAMESPACE
/* LIST is a slab array of pointers, each pointer may be
   assigned to point to any user data.
   Remarks
   When the list is filled to the capacity of Cnt elements, the
   list is reallocated to be larger.
   Cannot add NULL pointer to list, empty elements in the list
   are represented with NULL, and may be filled by any non-NULL
   value.                                                       */
_LINKLIST_NAMESPACE
/* <combine sack::containers::list::LinkBlock>
   \ \                                         */
typedef struct LinkBlock
{
	/* How many pointers the list can contain now. */
	INDEX     Cnt;
	/* \ \  */
	POINTER pNode[1];
} LIST, *PLIST;
_LINKLIST_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::containers::list;
#endif
_DATALIST_NAMESPACE
/* a list of data structures... a slab array of N members of X size */
typedef struct DataBlock  DATALIST;
/* A typedef of a pointer to a DATALIST struct DataList. */
typedef struct DataBlock *PDATALIST;
/* Data Blocks are like LinkBlocks, and store blocks of data in
   slab format. If the count of elements exceeds available, the
   structure is grown, to always contain a continuous array of
   structures of Size size.
   Remarks
   When blocks are deleted, all subsequent blocks are shifted
   down in the array. So the free blocks are always at the end. */
struct DataBlock
{
	/* How many elements are used. */
	INDEX     Cnt;
	/* How many elements are available in his array. */
	INDEX     Avail;
	/* A simple exchange lock on the data for insert and delete. For
	   thread safety.                                                */
	//volatile uint32_t     Lock;
	/* How big each element of the array is. */
	INDEX     Size;
	/* The physical array. */
	uint8_t      data[1];
};
_DATALIST_NAMESPACE_END
/* This is a stack that contains pointers to user objects.
   Remarks
   This is a stack 'by reference'. When extended, the stack will
   occupy different memory, care must be taken to not duplicate
   pointers to this stack.                                       */
typedef struct LinkStack
{
	/* This is the index of the next pointer to be pushed or popped.
	   If top == 0, the stack is empty, until a pointer is added and
	   top is incremented.                                           */
	INDEX     Top;
	/* How many pointers the stack can contain. */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore. For
	                  thread safety.                                            */
	//volatile uint32_t     Lock;
	/*  a defined maximum capacity of stacked values... values beyond this are lost from the bottom  */
	uint32_t     Max;
	/* Reserved data portion that stores the pointers. */
	POINTER pNode[1];
} LINKSTACK, *PLINKSTACK;
/* A Stack that stores information in an array of structures of
   known size.
   Remarks
   The size of each element must be known at stack creation
   time. Structures are literally copied to and from this stack.
   This is a stack 'by value'. When extended, the stack will
   occupy different memory, care must be taken to not duplicate
   pointers to this stack.                                       */
typedef struct DataListStack
{
	volatile INDEX     Top;
 /* enable logging the program executable (probably the same for
	                all messages, unless they are network)
	                                                                             */
 // How many elements are on the stack.
	INDEX     Cnt;
	//volatile uint32_t     Lock;  /* thread interlock using InterlockedExchange semaphore. For
	//                  thread safety.                                            */
	INDEX     Size;
	INDEX     Max;
	uint8_t      data[1];
} DATASTACK, *PDATASTACK;
/* A queue which contains pointers to user objects. If the queue
   is filled to capacity and new queue is allocated, and all
   existing pointers are transferred.                            */
typedef struct LinkQueue
{
	/* This is the index of the next pointer to be added to the
	   queue. If Top==Bottom, then the queue is empty, until a
	   pointer is added to the queue, and Top is incremented.   */
	volatile INDEX     Top;
	/* This is the index of the next element to leave the queue. */
	volatile INDEX     Bottom;
	/* This is the current count of pointers that can be stored in
	   the queue.                                                  */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore. For
	   thread safety.                                            */
#if USE_CUSTOM_ALLOCER
	volatile uint32_t     Lock;
#endif
 // need two to have distinct empty/full conditions
	POINTER pNode[2];
} LINKQUEUE, *PLINKQUEUE;
/* A queue of structure elements.
   Remarks
   The size of each element must be known at stack creation
   time. Structures are literally copied to and from this stack.
   This is a stack 'by value'. When extended, the stack will
   occupy different memory, care must be taken to not duplicate
   pointers to this stack.                                       */
typedef struct DataQueue
{
	/* This is the next index to be added to. If Top==Bottom, the
	   queue is empty, until an entry is added at Top, and Top
	   increments.                                                */
	volatile INDEX     Top;
	/* The current bottom index. This is the next one to be
	   returned.                                            */
	volatile INDEX     Bottom;
	/* How many elements the queue can hold. If a queue has more
	   elements added to it than it has count, it will be expanded,
	   and a new queue returned.                                    */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore */
	//volatile uint32_t     Lock;
	/* How big each element in the queue is. */
	INDEX     Size;
	/* How many elements to expand the queue by, when its capacity
	   is reached.                                                 */
	INDEX     ExpandBy;
	/* The data area of the queue. */
	uint8_t      data[1];
} DATAQUEUE, *PDATAQUEUE;
/* A mostly obsolete function, but can return the status of
   whether all initially scheduled startups are completed. (Or
   maybe whether we are not complete, and are processing
   startups)                                                   */
_CONTAINER_NAMESPACE_END
SACK_NAMESPACE_END
/* This contains the methods to use the base container types
   defined in sack_types.h.                                  */
#ifndef LINKSTUFF
#define LINKSTUFF
	SACK_NAMESPACE
	_CONTAINER_NAMESPACE
#    define TYPELIB_CALLTYPE
#  if defined( _TYPELIBRARY_SOURCE_STEAL )
#    define TYPELIB_PROC extern
#  elif defined( NO_EXPORTS )
#    if defined( _TYPELIBRARY_SOURCE )
#      define TYPELIB_PROC
#    else
#      define TYPELIB_PROC extern
#    endif
#  elif defined( _TYPELIBRARY_SOURCE )
#    define TYPELIB_PROC EXPORT_METHOD
#  else
#    define TYPELIB_PROC IMPORT_METHOD
#  endif
_LINKLIST_NAMESPACE
//--------------------------------------------------------
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        CreateListEx   ( DBG_VOIDPASS );
/* Destroy a PLIST. */
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        DeleteListEx   ( PLIST *plist DBG_PASS );
/* See <link AddLink>.
   See <link DBG_PASS>. */
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        AddLinkEx      ( PLIST *pList, POINTER p DBG_PASS );
/* Sets the value of a link at the specified index.
   Parameters
   pList :     address of a PLIST
   idx :       index of the element to set
   p :         new link value to be set at the specified index
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        SetLinkEx      ( PLIST *pList, INDEX idx, POINTER p DBG_PASS );
/* Gets the link at the specified index.
   Parameters
   pList :  address of a PLIST pointer.
   idx :    index to get the link from.  */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      GetLink        ( PLIST *pList, INDEX idx );
/* Gets the address of the link node in the PLIST.
   Parameters
   pList :  address of a PLIST to get the node address
   idx :    index of the node to get the adddress of
   Example
   <code lang="c++">
   PLIST list = NULL; // don't have to use CreateList();
   POINTER *a;
   POINTER b;
   POINTER *result;
   a = &amp;b;
   AddLink( &amp;list, a );
   \result = GetLinkAddress( &amp;list, 0 );
    ( (*result) == b )
   </code>                                               */
TYPELIB_PROC  POINTER* TYPELIB_CALLTYPE     GetLinkAddress ( PLIST *pList, INDEX idx );
/* Locate a pointer in a PLIST. Return the index.
   Parameters
   pList :  address of a list pointer to locate link
   value :  link to find in the list
   Return Value List
   INVALID_INDEX :  Not found in the list
   0\-n :           Index of the first occurance of the link in the
                    list.                                           */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        FindLink       ( PLIST *pList, POINTER value );
/* return the count of used members in a PLIST
    pList : the list to count
	Return Value
	   number of things in the list.
*/
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        GetLinkCount   ( PLIST pList );
/* Uses FindLink on the list for the value to delete, and then
   sets the index of the found link to NULL.
   Parameters
   pList :  Address of a PLIST pointer
   value :  the link to find and remove from the list.
   Example
   <code lang="c++">
   PLIST list = NULL;
	POINTER a = &#47;*some address*&#47;;
   </code>
   <code>
   AddLink( &amp;list, a );
   DeleteLink( &amp;list, a );
   </code>                                                     */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      DeleteLink     ( PLIST *pList, CPOINTER value );
/* Remove all links from a PLIST. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyList      ( PLIST *pList );
#ifdef __cplusplus
/* This was a basic attempt to make list into a C++ class. I
   gave up doing this sort of thing afterwards after realizing
   the methods of a library and these static methods for a class
   aren't much different.                                        */
#  if defined( INCLUDE_SAMPLE_CPLUSPLUS_WRAPPERS )
typedef class iList
{
public:
	PLIST list;
	INDEX idx;
	inline iList() { list = CreateListEx( DBG_VOIDSRC ); }
	inline ~iList() { DeleteListEx( &list DBG_SRC ); }
	inline iList &operator+=( POINTER &p ){ AddLinkEx( &list, p DBG_SRC ); return *this; }
	inline void add( POINTER p ) { AddLinkEx( &list, p DBG_SRC ); }
	inline void remove( POINTER p ) { DeleteLink( &list, p ); }
	inline POINTER first( void ) { POINTER p; for( idx = 0, p = NULL;list && (idx < list->Cnt) && (( p = GetLink( &list, idx ) )==0); )idx++; return p; }
	inline POINTER next( void ) { POINTER p; for( idx++;list && (( p = GetLink( &list, idx ) )==0) && idx < list->Cnt; )idx++; return p; }
	inline POINTER get(INDEX index) { return GetLink( &list, index ); }
} *piList;
#  endif
#endif
// address of the thing...
typedef uintptr_t (CPROC *ForProc)( uintptr_t user, INDEX idx, POINTER *item );
// if the callback function returns non 0 - then the looping is aborted,
// and the value is returned... the user value is passed to the callback.
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE     ForAllLinks    ( PLIST *pList, ForProc func, uintptr_t user );
/* This is a iterator which can be used to check each member in
   a PLIST.
   Parameters
   list :     List to iterate through
   index :    variable to use to index the list
   type :     type of the elements stored in the list (for C++)
   pointer :  variable used to get the current member of the
              list.
   Example
   <code lang="c++">
   POINTER p;  // the pointer to receive the list member pointer (should be a user type)
   INDEX idx; // indexer
   PLIST pList; // some list.
   LIST_FORALL( pList, idx, POINTER, p )
   {
       // p will never be NULL here.
       // each link stored in the list is set to p here..
       // this is a way to remove this item from the list...
       SetLink( &amp;pList, idx, NULL );
       if( some condition )
          break;
   }
   </code>
   Another example that uses data and searches..
   <code lang="c++">
   PLIST pList = NULL;
   INDEX idx;
   CTEXTSTR string;
   AddLink( &amp;pList, (POINTER)"hello" );
   </code>
   <code>
   AddLink( &amp;pList, (POINTER)"world" );
   LITS_FORALL( pList, idx, CTEXTSTR, string )
   {
       if( strcmp( string, "hello" ) == 0 )
           break;
   }
   // here 'string' will be NULL if not found, else will be what was found
   </code>
   Remarks
   This initializes the parameters passed to the macro so that
   if the list is NULL or empty, then p will be set to NULL. If
   there are no non-nulll members in the list, p will be set to
   NULL. If you break in the loop, like in the case of searching
   the list for something, then p will be non-null at the end of
   the loop.
                                                                                         */
#define LIST_FORALL( l, i, t, v )  if(((v)=(t)NULL),(l))                                                        for( ((i)=0); ((i) < ((l)->Cnt))?                                         (((v)=(t)(uintptr_t)((l)->pNode[i])),1):(((v)=(t)NULL),0); (i)++ )  if( v )
/* This can be used to continue iterating through a list after a
   LIST_FORALL has been interrupted.
   Parameters
   list :     \Description
   index :    index variable for stepping through the list
   type :     type of the members in the list.
   pointer :  variable name to use to store the the current list
              element.
   Example
   <code lang="c++">
   PLIST pList = NULL;
   CTEXTSTR p;
   INDEX idx;
   </code>
   <code>
   AddLink( &amp;pList, "this" );
   AddLink( &amp;pList, "is" );
   AddLink( &amp;pList, "a" );
   AddLink( &amp;pList, "test" );
   LIST_FORALL( pList, idx, CTEXTSTR, p )
   {
       if( strcmp( p, "is" ) == 0 )
           break;
   }
   LIST_NEXTALL( pList, idx, CTEXTSTR, p )
   {
       printf( "remaining element : %s", p );
   }
   </code>
   <code lang="c++">
   j
   </code>                                                       */
#define LIST_NEXTALL( l, i, t, v )  if(l)                for( ++(i),((v)=(t)NULL); ((i) < ((l)->Cnt))?     (((v)=(t)(l)->pNode[i]),1):(((v)=(t)NULL),0); (i)++ )  if( v )
/* <combine sack::containers::list::CreateListEx@DBG_VOIDPASS>
   \ \                                                         */
#define CreateList()       ( CreateListEx( DBG_VOIDSRC ) )
/* <combine sack::containers::list::DeleteListEx@PLIST *plist>
   \ \                                                         */
#ifndef FIX_RELEASE_COM_COLLISION
#  define DeleteList(p)      ( DeleteListEx( (p) DBG_SRC ) )
#endif
/* Adds a pointer to a user object to a list.
   Example
   <code lang="c++">
   // the list can be initialized to NULL,
   // it does not have to be assigned the result of a CreateList().
   // this allows the list to only be allocated if it is used.
   PLIST list = NULL;
   AddLink( &amp;list, (POINTER)user_pointer );
   {
       POINTER p; // this should be USER_DATA_TYPE *p;
       INDEX idx; // just a generic counter.
       LIST_FORALL( list, idx, POINTER, p )
       {
           // for each item in the list, p will be not null.
           if( p-\>something == some_other_thing )
               break;
       }
       // p will be NULL if the list is empty
       // p will be NULL if the LIST_FORALL loop completes to termination.
       // p will be not NULL if the LIST_FORALL loop executed a 'break;'
   }
   </code>                                                                 */
#define AddLink(p,v)       ( AddLinkEx( (p),((POINTER)(v)) DBG_SRC ) )
/* <combine sack::containers::list::SetLinkEx@PLIST *@INDEX@POINTER p>
   \ \                                                                 */
#define SetLink(p,i,v)     ( SetLinkEx( (p),(i),((POINTER)(v)) DBG_SRC ) )
#ifdef __cplusplus
 //		namespace list;
	}
#endif
//--------------------------------------------------------
_DATALIST_NAMESPACE
/* Creates a data list which hold data elements of the specified
   size.
                                                                 */
TYPELIB_PROC  PDATALIST TYPELIB_CALLTYPE  CreateDataListEx ( uintptr_t nSize DBG_PASS );
/* <combine sack::containers::data_list::DeleteDataList>
   \ \                                                   */
TYPELIB_PROC  void TYPELIB_CALLTYPE       DeleteDataListEx ( PDATALIST *ppdl DBG_PASS );
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    SetDataItemEx ( PDATALIST *ppdl, INDEX idx, POINTER data DBG_PASS );
/* Adds an item to a DataList.
   Example
   <code lang="c++">
   PDATALIST datalist = CreateDataList();
   struct my_struct {
       uint32_t my_data;
   }
   struct my_struct my_item;
   my_item.my_data = 0;
   AddDataItem( &amp;datalist, &amp;my_item );
   </code>                                     */
#define AddDataItem(list,data) (((list)&&(*(list)))?SetDataItemEx((list),(*list)->Cnt,data DBG_SRC ):NULL)
/* Sets the item at a specific nodes to the new data.
   Parameters
   ppdl :      address of a PDATALIST.
   idx :       index of element in list to set
   data :      POINTER to data to set element to
   DBG_PASS :  optional debug file/line information
   Example
   <code lang="c++">
      PDATALIST pdl;
      int oldval = 3;
      int newval = 5;
      pdl = CreateDataList( sizeof( int ) ); // store int's as data
      AddDataItem( &amp;pdl, &amp;oldval );
      SetDataItem( &amp;pdl, 0, &amp;newval );
   </code>                                                          */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    SetDataItemEx ( PDATALIST *ppdl, INDEX idx, POINTER data DBG_PASS );
/* \Returns a pointer to the data at a specified index.
   Parameters
   \ \
   ppdl :  address of a PDATALIST
   idx :   index of element to get                      */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    GetDataItem ( PDATALIST *ppdl, INDEX idx );
/* Removes a data element from the list (moves all other
   elements down over it since there is no used indicator.
   Parameters
   ppdl :  address of a PDATALIST.
   idx :   index of element to delete                      */
TYPELIB_PROC  void TYPELIB_CALLTYPE       DeleteDataItem ( PDATALIST *ppdl, INDEX idx );
/* Empties a PDATALIST of all content.
   Parameters
   ppdl :  address of a PDATALIST
   Example
   <code lang="c++">
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) ); // store int's as data
   EmptyDataList( &amp;pdl );
   </code>                                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE       EmptyDataList ( PDATALIST *ppdl );
/* For loop to iterate through all items in a PDATALIST.
   <code lang="c++">
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) );
   {
      INDEX index;
      int *value;
      DATA_FORALL( pdl, index, int, value )
      {
      }
   }
   </code>                                               */
#define DATA_FORALL( l, i, t, v )  if(((v)=(t)NULL),(l)&&((l)->Cnt != INVALID_INDEX))	   for( ((i)=0);	                         (((i) < (l)->Cnt)                                             ?(((v)=(t)((l)->data + (uintptr_t)(((l)->Size) * (i)))),1)	         :(((v)=(t)NULL),0))&&(v); (i)++ )
/* <code>
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) );
   {
      INDEX index;
      int *value;
      DATA_FORALL( pdl, index, int, value )
      {
          // abort loop early
      }
      DATA_NEXTALL( pdl, index, int, value )
      {
      }
   }
   </code>                                   */
#define DATA_NEXTALL( l, i, t, v )  if(((v)=(t)NULL),(l))	   for( ((i)++);	                         ((i) < (l)->Cnt)                                             ?((v)=(t)((l)->data + (((l)->Size) * (i))))	         :(((v)=(t)NULL),0); (i)++ )
/* <combine sack::containers::data_list::CreateDataListEx@uintptr_t nSize>
   Creates a DataList specifying just the size. Uses the current
   source and line for debugging parameter.                               */
#define CreateDataList(sz) ( CreateDataListEx( (sz) DBG_SRC ) )
/* Destroy a DataList.
   Example
   <code>
   PDATALIST datalist = CreateDataList( 4 );
   DeleteDataList( &amp;datalist );
   </code>
   Parameters
   ppDataList :  pointer to the PDATALIST.   */
#define DeleteDataList(p)  ( DeleteDataListEx( (p) DBG_SRC ) )
/* <combine sack::containers::data_list::SetDataItemEx@PDATALIST *@INDEX@POINTER data>
   \ \                                                                                 */
#define SetDataItem(p,i,v) ( SetDataItemEx( (p),(i),(v) DBG_SRC ) )
   _DATALIST_NAMESPACE_END
//--------------------------------------------------------
#ifdef __cplusplus
		namespace link_stack {
#endif
/* Creates a new stack for links (POINTERS).
   Parameters
   DBG_PASS :  Debug file and line information to use for the
               allocation of the stack.
   Returns
   Pointer to a new link stack.                               */
TYPELIB_PROC  PLINKSTACK TYPELIB_CALLTYPE   CreateLinkStackEx( DBG_VOIDPASS );
/* Creates a new stack for links (POINTERS).  Link stack has a limited number of entries.
    When the stack fills, the oldest item on the stack is removed automatically.
	 Parameters
	 max_entries : maximum depth of the stack.
   DBG_PASS :  Debug file and line information to use for the
               allocation of the stack.
   Returns
   Pointer to a new link stack.                               */
         // creates a link stack with maximum entries - any extra entries are pushed off the bottom into NULL
TYPELIB_PROC  PLINKSTACK TYPELIB_CALLTYPE      CreateLinkStackLimitedEx        ( int max_entries  DBG_PASS );
/* <combine sack::containers::link_stack::CreateLinkStackLimitedEx@int max_entries>
   Macro to pass default debug file and line information.                           */
#define CreateLinkStackLimited(n) CreateLinkStackLimitedEx(n DBG_SRC)
/* Destroy a link stack. Sets the pointer to the stack to NULL
   on deletion.
   Parameters
   pls :       address of a link stack pointer
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteLinkStackEx( PLINKSTACK *pls DBG_PASS);
/* Pushes a new link on the stack.
   Parameters
   pls :       address of a link stack pointer
   p :         new pointer to push on the stack
   DBG_PASS :  debug source file and line information.
   Returns
   New link stack pointer if the stack was reallocated to have
   more space. Since the address of the pointer is passed, the
   pointer is already updated, and the return value is
   unimportant.                                                */
TYPELIB_PROC  PLINKSTACK TYPELIB_CALLTYPE   PushLinkEx       ( PLINKSTACK *pls, POINTER p DBG_PASS);
/* Reads the top value of the stack and returns it, removes top
   link on the stack.
   Parameters
   pls :  address of a link stack pointer
   Return Value List
   NULL :      Stack was empty
   not NULL :  Link that was on the top of the stack.           */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopLink          ( PLINKSTACK *pls );
/* Look at the top link on the stack.
   Parameters
   pls :  address of a link stack pointer
   Return Value List
   NULL :      Nothing on stack.
   not NULL :  link on the top of the stack. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekLink         ( PLINKSTACK *pls );
/* Look at links in the stack.
   Parameters
	pls :  address of a link stack pointer
	n : index of the element from the top to look at
   Return Value List
   NULL :      Nothing on stack at the position specified.
   not NULL :  link on the top of the stack. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekLinkEx         ( PLINKSTACK *pls, INDEX n );
// thought about adding these, but decided on creating a limited stack instead.
//TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      StackLength      ( PLINKSTACK *pls );
//TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopLinkEx        ( PLINKSTACK *pls, int position );
/* <combine sack::containers::link_stack::CreateLinkStackEx@DBG_VOIDPASS>
   Macro to pass default file and line information.                       */
#define CreateLinkStack()  CreateLinkStackEx( DBG_VOIDSRC )
/* <combine sack::containers::link_stack::DeleteLinkStackEx@PLINKSTACK *pls>
   Macro to pass default file and line information.                          */
#define DeleteLinkStack(p) DeleteLinkStackEx((p) DBG_SRC)
/* <combine sack::containers::link_stack::PushLinkEx@PLINKSTACK *@POINTER p>
   Macro to pass default debug file and line information.                    */
#define PushLink(p, v)     PushLinkEx((p),(v) DBG_SRC)
#ifdef __cplusplus
 //		namespace link_stack {
		}
#endif
//--------------------------------------------------------
#ifdef __cplusplus
		namespace data_stack {
#endif
/* Creates a data stack for data element of the specified size.
   Parameters
   size :       size of elements in the stack
   DBG_PASS :  debug file and line information.                 */
TYPELIB_PROC  PDATASTACK TYPELIB_CALLTYPE   CreateDataStackEx( size_t size DBG_PASS );
/* Creates a data stack for data element of the specified size.
   Parameters
   size :       size of items in the stack
   count :      max items in stack (oldest gets deleted)
   DBG_PASS :  debug file and line information.                 */
TYPELIB_PROC  PDATASTACK TYPELIB_CALLTYPE   CreateDataStackLimitedEx( size_t size, INDEX count DBG_PASS );
/* Destroys a data stack.
   Parameters
   pds :       address of a data stack pointer. The pointer will
               be set to NULL when the queue is destroyed.
   DBG_PASS :  Debug file and line information.                  */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteDataStackEx( PDATASTACK *pds DBG_PASS);
/* Push a data element onto the stack. The size of the element
   is known at the stack creation time.
   Parameters
   pds :       address of a data stack pointer
   p :         pointer to data to push on stack
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC  PDATASTACK TYPELIB_CALLTYPE   PushDataEx     ( PDATASTACK *pds, POINTER pdata DBG_PASS );
/* \Returns an allocated buffer containing the data on the
   stack. Removes item from the stack.
   Parameters
   pds :  address of a data stack to get data from         */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopData        ( PDATASTACK *pds );
/* Clear all data stored in the stack.
   Parameters
   pds :  address of a data stack pointer. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyDataStack ( PDATASTACK *pds );
/* Look at top item in the stack without removing it.
   Parameters
   pds :  address of a data stack to look at          */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekData       ( PDATASTACK *pds );
// Incrementing Item moves progressivly down the stack
// final(invalid) stack, and/or empty stack will return NULL;
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekDataEx     ( PDATASTACK *pds, INDEX Item );
 /* keeps data on stack (can be used)
                                                                                      Parameters
                                                                                      pds :   address of a data stack pointer
                                                                                      Item :  Item to peek at; 0 is the top, 1 is just below it...
                                                                                              (maybe \-1 is last and further up)
                                                                                      Returns
                                                                                      \returns the address of the data item in the data stack.     */
/* <combine sack::containers::data_stack::CreateDataStackEx@INDEX size>
   Macro to pass default file and line information.                     */
#define CreateDataStack(size) CreateDataStackEx( size DBG_SRC )
/* <combine sack::containers::data_stack::CreateDataStackEx@INDEX size>
   Macro to pass default file and line information.                     */
#define CreateDataStackLimited(size,items) CreateDataStackLimitedEx( size,items DBG_SRC )
/* <combine sack::containers::data_stack::DeleteDataStackEx@PDATASTACK *pds>
   Macro to pass default file and line information.                          */
#define DeleteDataStack(p) DeleteDataStackEx((p) DBG_SRC)
/* <combine sack::containers::data_stack::PushDataEx@PDATASTACK *@POINTER pdata>
   Macro to pass default file and line information.                              */
#define PushData(pds,p) PushDataEx(pds,p DBG_SRC )
#ifdef __cplusplus
 //		namespace data_stack {
		}
#endif
/* Queue container - can enque (at tail) deque (from head) and preque (at head). Can also browse the queue with peekqueue. */
#ifdef __cplusplus
		namespace queue {
#endif
/* Creates a <link sack::containers::PLINKQUEUE, LinkQueue>. In
   debug mode, gets passed the current source and file so it can
   blame the user for the allocation.                            */
TYPELIB_PROC  PLINKQUEUE TYPELIB_CALLTYPE   CreateLinkQueueEx( DBG_VOIDPASS );
/* Delete a link queue. Pass the address of the pointer to the
   queue to delete, this function sets the pointer to NULL if
   the queue is actually deleted.                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteLinkQueueEx( PLINKQUEUE *pplq DBG_PASS );
/* Enque a link to the queue.  */
TYPELIB_PROC  PLINKQUEUE TYPELIB_CALLTYPE   EnqueLinkEx      ( PLINKQUEUE *pplq, POINTER link DBG_PASS );
TYPELIB_PROC  void TYPELIB_CALLTYPE   EnqueLinkNLEx( PLINKQUEUE *pplq, POINTER link DBG_PASS );
/* EnqueLink adds the new item at the end of the list. PrequeueLink
   puts the new item at the head of the queue (so it's the next
   one to be retrieved).                                            */
TYPELIB_PROC  PLINKQUEUE TYPELIB_CALLTYPE   PrequeLinkEx      ( PLINKQUEUE *pplq, POINTER link DBG_PASS );
/* If the queue is not empty, returns the address of the next
   element in the queue and removes the element from the queue.
                                                                */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      DequeLink        ( PLINKQUEUE *pplq );
TYPELIB_PROC POINTER  TYPELIB_CALLTYPE      DequeLinkNL      ( PLINKQUEUE *pplq );
/* Return TRUE/FALSE if the queue is empty or not. */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      IsQueueEmpty     ( PLINKQUEUE *pplq );
/* Gets the number of elements current in the queue. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        GetQueueLength   ( PLINKQUEUE plq );
// get a PLINKQUEUE element at index
//  If idx < 0 then count from the end of the queue, otherwise count from the start of the queue
// start of the queue is the next element to be dequeue, end of the queue is the last element added to the queue.
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekQueueEx    ( PLINKQUEUE plq, int idx );
/* Can be used to look at the next element in the queue without
   removing it from the queue. PeekQueueEx allows you to specify
   an index of an item in the queue to get.                      */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekQueue    ( PLINKQUEUE plq );
/* <combinewith sack::containers::queue::CreateLinkQueueEx@DBG_VOIDPASS>
   \ \                                                                   */
#define     CreateLinkQueue()     CreateLinkQueueEx( DBG_VOIDSRC )
/* <combine sack::containers::queue::PrequeLinkEx@PLINKQUEUE *@POINTER link>
   \ \                                                                       */
#define     PrequeLink(pplq,link) PrequeLinkEx( pplq, link DBG_SRC )
/* <combine sack::containers::queue::DeleteLinkQueueEx@PLINKQUEUE *pplq>
   \ \                                                                   */
#define     DeleteLinkQueue(pplq) DeleteLinkQueueEx( pplq DBG_SRC )
/* <combine sack::containers::queue::EnqueLinkEx@PLINKQUEUE *@POINTER link>
   \ \                                                                      */
#define     EnqueLink(pplq, link) EnqueLinkEx( pplq, link DBG_SRC )
#define     EnqueLinkNL(pplq, link) EnqueLinkNLEx( pplq, link DBG_SRC )
#ifdef __cplusplus
//		namespace queue {
		}
#endif
/* Functions related to PDATAQUEUE container. DataQueue stores
   literal data elements in the list instead of just a pointer. (could
   be used for optimized vertex arrays for instance).
   int data = 3;
   int result;
   PDATAQUEUE pdq = CreateDataQueue( sizeof( int ) );
   EnqueData( &amp;pdq, &amp;data );
   DequeData( &amp;pdq, &amp;result );
   DestroyDataQueue( &amp;pdq );                                       */
#ifdef __cplusplus
		namespace data_queue {
#endif
/* Creates a PDATAQUEUE. Can pass DBG_FILELINE information to
   blame other code for the allocation.                       */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   CreateDataQueueEx( INDEX size DBG_PASS );
/* Creates a PDATAQUEUE that has an overridden expand-by amount
   and initial amount of entries in the queue. (expecting
   something like 1000 to start and expand by 500, instead of
   the default 0, and expand by 1.                              */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   CreateLargeDataQueueEx( INDEX size, INDEX entries, INDEX expand DBG_PASS );
/* Destroys a data queue. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteDataQueueEx( PDATAQUEUE *pplq DBG_PASS );
/* Add a data element into the queue. */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   EnqueDataEx      ( PDATAQUEUE *pplq, POINTER Data DBG_PASS );
/* Enque data at the head of the queue instead of the tail. (Normally
   add at tail, take from head).                                      */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   PrequeDataEx      ( PDATAQUEUE *pplq, POINTER Data DBG_PASS );
/* Removes data from a queue, resulting with the data in the
   specified buffer, and result TRUE if there was an element
   else FALSE, and the buffer is not modified.               */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      DequeData        ( PDATAQUEUE *pplq, POINTER Data );
/* Removes the last element in the queue. (takes from the tail). */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      UnqueData        ( PDATAQUEUE *pplq, POINTER Data );
/* Checks if the queue is empty, result TRUE if nothing in it,
   else FALSE.                                                 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      IsDataQueueEmpty ( PDATAQUEUE *pplq );
/* Empty a dataqueue of all data. (Sets head=tail). */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyDataQueue ( PDATAQUEUE *pplq );
/*
 * get a PDATAQUEUE element at index
 * result buffer is a pointer to the type of structure expected to be
 * stored within this.  The buffer result is a copy of the data stored in the queue.
 * This enforces that data stored in the list is immutable.
 * Also on the basic DequeData function, after resulting, if the pointer to the
 * data within the queue were returned, it could become invalid immediatly after
 * returning by having another enque happen which overwrites that position in the buffer.
 * One could, in theory, set a flag in the queue that a deque was done, and not update the
 * bottom until that flag is encountered while within DequeData again...
 * the pointer to the data in the queue may also not be returned because the queue may be
 * reallocated and moved.
 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  PeekDataQueueEx    ( PDATAQUEUE *pplq, POINTER ResultBuffer, INDEX idx );
/* <combine sack::containers::data_queue::PeekDataQueueEx@PDATAQUEUE *@POINTER@INDEX>
   \ \                                                                                */
#define PeekDataQueueEx( q, type, result, idx ) PeekDataQueueEx( q, (POINTER)result, idx )
/*
 * Result buffer is filled with the last element, and the result is true, otherwise the return
 * value is FALSE, and the data was not filled in.
 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  PeekDataQueue    ( PDATAQUEUE *pplq, POINTER ResultBuffer );
/* <combine sack::containers::data_queue::PeekDataQueue@PDATAQUEUE *@POINTER>
   \ \                                                                        */
#define PeekDataQueue( q, type, result ) PeekDataQueue( q, (POINTER)result )
/* <combine sack::containers::data_queue::CreateDataQueueEx@INDEX size>
   \ \                                                                  */
#define     CreateDataQueue(size)     CreateDataQueueEx( size DBG_SRC )
/* <combine sack::containers::data_queue::CreateLargeDataQueueEx@INDEX@INDEX@INDEX expand>
   \ \                                                                                     */
#define     CreateLargeDataQueue(size,entries)     CreateLargeDataQueueEx( size,entries, 0 DBG_SRC )
/* <combine sack::containers::data_queue::DeleteDataQueueEx@PDATAQUEUE *pplq>
   \ \                                                                        */
#define     DeleteDataQueue(pplq) DeleteDataQueueEx( pplq DBG_SRC )
/* <combine sack::containers::data_queue::EnqueDataEx@PDATAQUEUE *@POINTER Data>
   \ \                                                                           */
#define     EnqueData(pplq, Data) EnqueDataEx( pplq, Data DBG_SRC )
/* <combine sack::containers::data_queue::PrequeDataEx@PDATAQUEUE *@POINTER Data>
   \ \                                                                            */
#define     PrequeData(pplq, Data) PrequeDataEx( pplq, Data DBG_SRC )
#ifdef __cplusplus
//		namespace data_queue {
		}
#endif
//---------------------------------------------------------------------------
#ifdef __cplusplus
namespace message {
#endif
/* handle to a message queue. */
typedef struct MsgDataHandle *PMSGHANDLE;
//typedef struct MsgDataQueue *PMSGQUEUE;
// messages sent - the first dword of them must be
// a message ID.
typedef void (CPROC *MsgQueueReadCallback)( uintptr_t psv, CPOINTER p, uintptr_t sz );
/* Create a named shared memory message queue.
   Parameters
   name :     name of the queue to create
   size :     size of the queue.
   Read :     read callback, called when a message is received on
              the queue.
   psvRead :  user data associated with the queue. Passed to the
              read callback.                                      */
TYPELIB_PROC  PMSGHANDLE TYPELIB_CALLTYPE  SackCreateMsgQueue ( CTEXTSTR name, size_t size
                                                      , MsgQueueReadCallback Read
                                                      , uintptr_t psvRead );
/* Open a message queue. Opens if it exists, does not create.
   Parameters
   name :     name of the queue.
   Read :     read callback called when a message is received.
   psvRead :  user data associated with this queue, and passed to
              the read callback.                                  */
TYPELIB_PROC  PMSGHANDLE TYPELIB_CALLTYPE  SackOpenMsgQueue ( CTEXTSTR name
													 , MsgQueueReadCallback Read
													 , uintptr_t psvRead );
/* Destroys a message queue.
   Parameters
   ppmh :  address of the message queue handle to close (sets
           pointer to NULL when deleted)                      */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteMsgQueue ( PMSGHANDLE **ppmh );
 // if enque, fail send, return immediate on fail
#define MSGQUE_NOWAIT 0x0001
                             // if deque, fail no msg ready to get...
 // read any msg BUT MsgID
#define MSGQUE_EXCEPT 0x0002
 // enque this message... it is a task ID which is waiting.
#define MSGQUE_WAIT_ID 0x0004
/* Error result if there is no message to read. (GetLastError()
   after peekmsg or readmsg returns -1)                         */
#define MSGQUE_ERROR_NOMSG 1
/* Error result if the message to read is bigger than the buffer
   passed to read the message.                                   */
#define MSGQUE_ERROR_E2BIG 2
/* Error result. Unexpected error (queue head/tail out of
   bounds)                                                */
#define MSGQUE_ERROR_EABORT 5
// result is the size of the message, or 0 if no message.
// -1 if some other error?
TYPELIB_PROC  int TYPELIB_CALLTYPE  DequeMsgEx ( PMSGHANDLE pmh, long *MsgID, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Receives a message from the message queue.
   Parameters
   Message Queue :  PMSGHANDLE to read from
   Message ID * :   a Pointer to the message ID to read. Updated
                    with the message ID from the queue.
   buffer :         buffer to read message into
   buffer length :  length of the buffer to read
   options :        extra options for the read
   Return Value List
   \-1 :  Error
   0 :    No Message to read
   \>0 :  size of message read.
   Returns
   \ \                                                           */
#define DequeMsg(q,b,s,i,o) DequeMsgEx(q,b,s,i,o DBG_SRC )
/* <combine sack::containers::message::PeekMsg>
   \ \                                          */
TYPELIB_PROC  int TYPELIB_CALLTYPE  PeekMsgEx ( PMSGHANDLE pmh, long MsgID, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Just peek at the next message.
   Parameters
   queue :        The PMSGHANDLE queue to read.
   MsgID :        what message to read. 0 is read any message.
   buffer :       where to read the message data into.
   buffer_size :  the length of the message buffer.
   options :      Options controlling the read
   Returns
   \-1 on error
   0 if no message
   length of the message read                                  */
#define PeekMsg(q,b,s,i,o) PeekMsgEx(q,b,s,i,o DBG_SRC )
/* <combine sack::containers::message::EnqueMsg>
   \ \                                          */
TYPELIB_PROC  int TYPELIB_CALLTYPE  EnqueMsgEx ( PMSGHANDLE pmh, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Add a message to the queue.
   Parameters
   Message Queue :  PMSGQUEUE to write to.
   Buffer :         pointer to the message to send. THe MSgID is
                    the first part of the message buffer.
   Buffer Length :  how long the message to send is
   Options :        Extra options for send
   Return Value List
   \-1 :  Error
   \>0 :  bytes of message sent                                  */
#define EnqueMsg(q,b,s,o) EnqueMsgEx(q,b,s,o DBG_SRC )
/* Check if the message queue is empty.
   Parameters
   pmh :  queue to check if it's empty. */
TYPELIB_PROC  int TYPELIB_CALLTYPE  IsMsgQueueEmpty ( PMSGHANDLE pmh );
#ifdef __cplusplus
 //namespace message {
}
#endif
/* Routines to deal with SLAB allocated blocks of structures.
   Each slab has multiple elements of a type in it, and the
   blocks are tracked as a linked list. Each block also has a
   bitmask of allocated elements in the set.
   \---------------------------------------------------------------------------
   Set type
   Usage:
   typedef struct name_tag { } \<name\>;
   \#define MAX\<name\>SPERSET
   DeclareSet( \<name\> );
   Should alias GetFromset, DeleteFromSet, CountUsedInSet,
   GetLinearSetArray
   etc so that the type name is reflected there
   another good place where #define defining defines is good.
   \---------------------------------------------------------------------------
                                                                                */
_SETS_NAMESPACE
//---------------------------------------------------------------------------
// Set type
//   Usage:
//      typedef struct name_tag { } <name>;
//      #define MAX<name>SPERSET
//      DeclareSet( <name> );
//    Should alias GetFromset, DeleteFromSet, CountUsedInSet, GetLinearSetArray
//       etc so that the type name is reflected there
//       another good place where #define defining defines is good.
//---------------------------------------------------------------------------
/* Hard coded 32 bit division for getting word index. (x\>\>5) */
#define UNIT_USED_IDX(n)   ((n) >> 5)
/* Hard coded 32 bit division for getting bit index. (x &amp;
   0x1f)                                                      */
#define UNIT_USED_MASK(n)  (1 << ((n) &0x1f))
/* A macro for use by internal code that marks a member of a set
   as used.
   Parameters
   set :    pointer to a genericset
   index :  item to mark used.                                   */
#define SetUsed(set,n)   ((((set)->bUsed[UNIT_USED_IDX(n)]) |= UNIT_USED_MASK(n)), (++(set)->nUsed) )
/* A macro for use by internal code that marks a member of a set
   as available.
   Parameters
   set :    pointer to a genericset
   index :  item to mark available.                              */
#define ClearUsed(set,n) ((((set)->bUsed[UNIT_USED_IDX(n)]) &= ~UNIT_USED_MASK(n)), (--(set)->nUsed) )
/* A macro for use by internal code that tests a whole set of
   bits for used. (32 bits, can check to see if any in 32 is
   free)
   Parameters
   set :    pointer to a genericset
   index :  index of an one in the set of 32 being tested.
   Returns
   0 if not all are used.
   1 if all in this block of bits are used.                   */
#define AllUsed(set,n)   (((set)->bUsed[UNIT_USED_IDX(n)]) == 0xFFFFFFFF )
/* A macro for use by internal code that tests a member of a set
   as used.
   Parameters
   set :    pointer to a genericset
   index :  item to test used.
   Returns
   not zero if is used, otherwise is free.                       */
#define IsUsed(set,n)    (((set)->bUsed[UNIT_USED_IDX(n)]) & UNIT_USED_MASK(n) )
#ifdef __cplusplus
#define CPP_(n)
/* A macro which is used to emit code in C++ mode... */
#else
#define CPP_(n)
#endif
// requires a symbol of MAX<insert name>SPERSET to declare max size...
 //ndef __cplusplus
#if 1
#define SizeOfSet(size,count)  (sizeof(POINTER)*2+sizeof(int)+sizeof( uint32_t[((count)+31)/32] ) + ((size)*(count)))
#define DeclareSet( name )  typedef struct name##set_tag {	   struct name##set_tag *next, *prior;	                      uint32_t nUsed;	                                               uint32_t nBias;	                                               uint32_t bUsed[(MAX##name##SPERSET + 31 ) / 32];	              name p[MAX##name##SPERSET];	                           CPP_(int forall(uintptr_t(CPROC*f)(void*,uintptr_t),uintptr_t psv) {if( this ) return _ForAllInSet( (struct genericset_tag*)this, sizeof(name), MAX##name##SPERSET, f, psv ); else return 0; })	 CPP_(name##set_tag() { next = NULL;prior = NULL;nUsed = 0; nBias = 0; MemSet( bUsed, 0, sizeof( bUsed ) ); MemSet( p, 0, sizeof( p ) );} )	} name##SET, *P##name##SET
#define DeclareClassSet( name ) typedef struct name##set_tag {	   struct name##set_tag *next, *prior;	                      uint32_t nUsed;	                                               uint32_t nBias;	                                               uint32_t bUsed[(MAX##name##SPERSET + 31 ) / 32];	              class name p[MAX##name##SPERSET];	                        CPP_(int forall(uintptr_t(CPROC*)(void*f,uintptr_t),uintptr_t psv) {if( this ) return _ForAllInSet( (struct genericset_tag*)this, sizeof(class name), MAX##name##SPERSET, f, psv ); else return 0; })	 } name##SET, *P##name##SET
#endif
/* This represents the basic generic set structure. Addtional
   data is allocated at the end of this strcture to fit the bit
   array that maps usage of the set, and for the set size of
   elements.
   Remarks
   \ \
   Summary
   Generic sets are good for tracking lots of tiny structures.
   They track slabs of X structures at a time. They allocate a
   slab of X structures with an array of X bits indicating
   whether a node is used or not. The structure overall has how
   many are used, so once full, a block can be quickly checked
   whether there is anything free. Then when checking a block
   that might have room, the availablility is checked 32 bits at
   a time, until a free spot is found.
   Sets of 1024 members of x,y coordinates for example are good
   for this sort of storage. the points are often static, once
   loaded they all exist until none of them do. This storage has
   gross deletion methods too, quickly evaporate all allocated
   chunks. Storing tiny chunks in a slab is more efficient
   because every allocation method has some sort of tracking
   associated with it - an overhead of having it. Plus, when
   operating on sets of data, a single solid slab of exatly the
   structures you are working with is more efficient to cache.
   Example
   <code lang="c++">
   struct treenode_tag {
       uint32_t treenode_data;  // abitrary structure data
   };
   typedef struct treenode_tag TREENODE;
   \#define MAXTREENODESPERSET 256
   DeclareSet( TREENODE );
   </code>
   The important part of the prior code is the last two lines.
   \#define MAX\<your type name\>SPERSET \<how many\>
   This defines how many of your structure are kept per set
   block.
   The DeclareSet( type ) declares a typedefed structure called
   'struct type##set_tag', 'name##SET', and '*P##name##SET'; in
   the above case, it would be 'struct TREENODEset_tag',
   'TREENODESET', and 'PTREENODESET'.
   Then to actually use the set...
   <code lang="c#">
   // declare a set pointer with one of the magic names.
   PTREENODESET nodeset = NULL;
   // get a node from the set.
   TREENODE *node = GetFromSet( TREENODE, nodeset );
   </code>
   Notice there is no CreateSet, getting a set member will
   create the set as required. Many operations may expend the
   set, except for GetUsedSetMember which will only result with
   \members that are definatly in the set. Accesses to the set
   are all prefixed by the type name the set was created with,
   'TREENODE' in this example.
   <code lang="c++">
   DeleteFromSet( TREENODE, nodeset, node );
   node = GetFromSet( TREENODE, nodeset );
   {
      int index = GetMemberIndex( TREENODE, nodeset, node );
   }
   </code>
   The accessor macros take care of expanding several parameters
   that require sizeof structure expansion.                      */
typedef struct genericset_tag {
	// wow might be nice to have some flags...
	// first flag - bSetSet - meaning that this is a set of sets of
	// the type specified...
	struct genericset_tag *next;
	/* This is the pointer that's pointing at the pointer pointing
	   to me. (did you get that?) See <link DeclareLink>.          */
	struct genericset_tag **me;
	/* number of spots in this set block that are used. */
	uint32_t nUsed;
 // hmm if I change this here? we're hozed... so.. we'll do it anyhow :) evil - recompile please
	uint32_t nBias;
 // after this p * unit must be computed
	uint32_t bUsed[1];
} GENERICSET, *PGENERICSET;
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetFromSetEx( GENERICSET **pSet, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetFromSetEx@GENERICSET **@int@int@int maxcnt>
   \ \                                                                             */
#define GetFromSeta(ps, ss, us, max) GetFromSetPoolEx( NULL, 0, 0, 0, (ps), (ss), (us), (max) DBG_SRC )
/* <combine sack::containers::sets::GetFromSetEx@GENERICSET **@int@int@int maxcnt>
   \ \
   Parameters
   name :  name of type the set contains.
   pSet :  pointer to a set to get an element from.                                */
#define GetFromSet( name, pset ) (name*)GetFromSeta( (GENERICSET**)(pset), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET )
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  PGENERICSET  TYPELIB_CALLTYPE GetFromSetPoolEx( GENERICSET **pSetSet
													 , int setsetsize, int setunitsize, int setmaxcnt
													 , GENERICSET **pSet
													 , int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetFromSetPoolEx@GENERICSET **@int@int@int@GENERICSET **@int@int@int maxcnt>
   \ \                                                                                                           */
#define GetFromSetPoola(pl, sss, sus, smax, ps, ss, us, max) GetFromSetPoolEx( (pl), (sss), (sus), (smax), (ps), (ss), (us), (max) DBG_SRC )
/* <combine sack::containers::sets::GetFromSetPoolEx@GENERICSET **@int@int@int@GENERICSET **@int@int@int maxcnt>
   \ \                                                                                                           */
#define GetFromSetPool( name, pool, pset ) (name*)GetFromSetPoola( (GENERICSET**)(pool)	    , sizeof( name##SETSET ), sizeof( name##SET ), MAX##name##SETSPERSET	, (GENERICSET**)(pset), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET )
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                     */
#define GetSetMembera(ps, member, ss, us, max) (GetSetMemberEx( (ps), (member), (ss), (us), (max) DBG_SRC ))
/* <combine sack::containers::sets::GetSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                     */
#define GetSetMember( name, pset, member ) ((name*)GetSetMembera( (GENERICSET**)(pset), (member), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET ))
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetUsedSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetUsedSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                         */
#define GetUsedSetMembera(ps, member, ss, us, max) (GetUsedSetMemberEx( (ps), (member), (ss), (us), (max) DBG_SRC ))
/* <combine sack::containers::sets::GetUsedSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                         */
#define GetUsedSetMember( name, pset, member ) ((name*)GetUsedSetMembera( (GENERICSET**)(pset), (member), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET ))
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetMemberIndex(GENERICSET **set, POINTER unit, int unitsize, int max );
/* Gets the index of a member passed as a pointer.
   Parameters
   set :       pointer to the set the member is in
   unit :      pointer to the member in the set to get the index
               of.
   unitsize :  size of each member in the set
   max :       count of members in each set block.
   Returns
   \Returns the index of the member passed in as a pointer.      */
#define GetMemberIndex(name,set,member) GetMemberIndex( (GENERICSET**)set, member, sizeof( name ), MAX##name##SPERSET )
/* <combine sack::containers::sets::GetMemberIndex>
   \ \                                              */
#define GetIndexFromSet( name, pset ) GetMemberIndex( name, pset, GetFromSet( name, pset ) )
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteFromSetExx( GENERICSET *set, POINTER unit, int unitsize, int max DBG_PASS );
/* <combine sack::containers::sets::DeleteFromSetExx@GENERICSET *@POINTER@int@int max>
   \ \                                                                                 */
#define DeleteFromSetEx( name, set, member, xx ) DeleteFromSetExx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET DBG_SRC )
/* <combine sack::containers::sets::DeleteFromSetExx@GENERICSET *@POINTER@int@int max>
   \ \                                                                                 */
#define DeleteFromSet( name, set, member ) DeleteFromSetExx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET DBG_SRC )
/* Marks a member in a set as usable.
   Parameters
   set :       pointer to a genericset pointer
   iMember :   index of member to delete
   unitsize :  (filled by macro) size of element in set
   max :       (filled by macro) size of a block of elements. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteSetMemberEx( GENERICSET *set, INDEX iMember, uintptr_t unitsize, INDEX max );
/* <combine sack::containers::sets::DeleteSetMemberEx@GENERICSET *@INDEX@uintptr_t@INDEX>
   \ \                                                                                   */
#define DeleteSetMember( name, set, member ) DeleteSetMemberEx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET )
/* This function can check to see if a pointer is a valid
   element from a set.
   Parameters
   set :       pointer to a set to check
   unit :      pointer to an element from the set
   unitsize :  size of element structures in the set.
   max :       count of structures per set block
   Returns
   TRUE if unit is in the set, else FALSE.                */
TYPELIB_PROC  int TYPELIB_CALLTYPE  MemberValidInSetEx( GENERICSET *set, POINTER unit, int unitsize, int max );
/* <combine sack::containers::sets::MemberValidInSetEx@GENERICSET *@POINTER@int@int>
   \ \                                                                               */
#define MemberValidInSet( name, set, member ) MemberValidInSetEx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET )
TYPELIB_PROC  int TYPELIB_CALLTYPE  CountUsedInSetEx( GENERICSET *set, int max );
/* Count number of elements that are allocated in the set.
   Parameters
   set :  The set to check
   max :  max items per set (may be unused, since this is stored
          internally now)
   Returns
   The number of items in the step.                              */
#define CountUsedInSet( name, set ) CountUsedInSetEx( (GENERICSET*)set, MAX##name##SPERSET )
TYPELIB_PROC  POINTER * TYPELIB_CALLTYPE GetLinearSetArrayEx( GENERICSET *pSet, int *pCount, int unitsize, int max );
/* Converts a set into a copy of the objects in the set
   organized in a flat array.
   Parameters
   pSet :      set to convert to an array
   pCount :    address of an integer to receive the count of
               elements put in the array.
   unitsize :  size of each element in the set
   max :       count of elements per set block
   Returns
   Pointer to an array that are a copy of the objects in the
   set.                                                      */
#define GetLinearSetArray( name, set, pCount ) GetLinearSetArrayEx( (GENERICSET*)set, pCount, sizeof( name ), MAX##name##SPERSET )
/* Returned the index of an item in a linear array returned from
   a set.
   Parameters
   pArray :      pointer to an array which has been returned from
                 the set
   nArraySize :  size fo the array
   unit :        pointer to an element in the array
   Returns
   Index of the unit in the array, INVALID_INDEX if not in the
   array.                                                         */
TYPELIB_PROC  int TYPELIB_CALLTYPE  FindInArray( POINTER *pArray, int nArraySize, POINTER unit );
/* Delete all allocated slabs.
   Parameters
   ppSet :  pointer to a generic set pointer to delete. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteSet( GENERICSET **ppSet );
/* <combine sack::containers::sets::DeleteSet@GENERICSET **>
   \ \                                                       */
#define DeleteSetEx( name, ppset ) { name##SET **delete_me = ppset; DeleteSet( (GENERICSET**)delete_me ); }
/* <combine sack::containers::sets::ForAllInSet>
   ForAllinSet Callback - callback fucntion used with
   ForAllInSet                                        */
typedef uintptr_t (CPROC *FAISCallback)(void*,uintptr_t);
/* \ \
   Parameters
   pSet :      poiner to a set
   unitsize :  size of elements in the array
   max :       count of elements per set block
   f :         user callback function to call for each element in
               the set
   psv :       user data passed to the user callback when it is
               invoked for a member of the set.
   Returns
   If the user callback returns 0, the loop continues. If the
   user callback returns non zero then the looping through the
   set ends, and that result is returned.                         */
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE  _ForAllInSet( GENERICSET *pSet, int unitsize, int max, FAISCallback f, uintptr_t psv );
/* <combine sack::containers::sets::ForEachSetMember>
   ForEachSetMember Callback function - for the function '
   ForEachSetMember'                                       */
typedef uintptr_t (CPROC *FESMCallback)(INDEX,uintptr_t);
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE  ForEachSetMember ( GENERICSET *pSet, int unitsize, int max, FESMCallback f, uintptr_t psv );
 //def __cplusplus
#if 0
#define DeclareSet(name)	                                struct name##set_tag {	               uint32_t set_size;	                             uint32_t element_size;	                         uint32_t element_cnt;	                          PGENERICSET pool;	                        name##set_tag() {	                        element_size = sizeof( name );	             element_cnt = MAX##name##SPERSET;	          set_size = (element_size * element_cnt )+ ((((element_cnt + 31 )/ 32 )- 1 ) * 4) + sizeof( GENERICSET );	 pool = NULL;	                               }	    ~name##set_tag() { DeleteSet( &pool ); }	 name* grab() { return (name*)GetFromSetEx( &pool, set_size, element_size, element_cnt DBG_SRC ); }	 name* grab(INDEX member) { return (name*)GetSetMemberEx( &pool, member, set_size, element_size, element_cnt DBG_SRC ); }	 name* get(INDEX member) { return (this)?(name*)GetUsedSetMemberEx( &pool, member, set_size, element_size, element_cnt DBG_SRC ):(NULL); }	 void drop( name* member ) { DeleteFromSetEx( pool, (POINTER)member, element_size, element_cnt ); }	 int valid( name* member ) { return MemberValidInSetEx( pool, (POINTER)member, element_size, element_cnt ); }	 uintptr_t forall( FAISCallback f, uintptr_t psv ) { if( this ) return _ForAllInSet( pool, element_size, element_cnt, f, psv ); else return 0; }	 };	       typedef struct name##set_tag *P##name##SET, name##SET;
#define ForAllInSet(name, pset,f,psv) _ForAllInSet( (GENERICSET*)(pset), sizeof( name ), MAX##name##SPERSET, (f), (psv) )
#else
/* <combine sack::containers::sets::_ForAllInSet@GENERICSET *@int@int@FAISCallback@uintptr_t>
   \ \                                                                                       */
#define ForAllInSet(name, pset,f,psv) _ForAllInSet( (GENERICSET*)(pset), sizeof( name ), MAX##name##SPERSET, (f), (psv) )
/* Performs an iteration over each allocated set member. Calls
   the user provided callback routine with each element in the
   set.
   Parameters
   pSet :      pointer to the set to iterate
   unitsize :  size of each element
   max :       max count of elements per set block
   f :         function to call ( uintptr_t (*)(INDEX,uintptr_t) )
   psv :       user data value to pass to function as uintptr_t
   Returns
   uintptr_t - this value is the return of the user function if
   the function does not return 0. A non zero return from the
   user callback stops iteration.                                */
#define ForEachSetMember(name,pset,f,psv) ForEachSetMember( (GENERICSET*)(pset),sizeof(name),MAX##name##SPERSET, (f), (psv) )
#endif
//---------------------------------------------------------------------------
_SETS_NAMESPACE_END
_TEXT_NAMESPACE
// this defines more esoteric formatting notions...
// these data blocks will be zero sized, and ahve the TF_FORMATEX
// bit set.
//#define DEFAULT_COLOR 0xF7
//#define PRIOR_COLOR 0xF6 // this does not change the color....
// these enumerated ops put in the foreground field of a format
// with a flag of TF_FORMATEX will cause the specified operation
// to be carried out on a display (not files) or generated into
// the appropriate sequence (ansi out encode)
// -- correction
//  this is encoded into its own field for the format
// size, due to machine optimization, 16 bits were free
// this was expanded and used for all information
// a segment may contain extended op, color, attributes,
// and text, everything short of a font for it...
//  - not sure how to address that issue... there's
// certainly modifications to current font... italic for
// instance..
	enum FORMAT_OPS {
      /* this segment clears to the end of the line.  Its content is then added to the output */
		FORMAT_OP_CLEAR_END_OF_LINE = 1
        ,FORMAT_OP_CLEAR_START_OF_LINE
                   ,
						  FORMAT_OP_CLEAR_LINE
						 ,
						  FORMAT_OP_CLEAR_END_OF_PAGE
                   ,
						  FORMAT_OP_CLEAR_START_OF_PAGE
						 ,
/* clear the entire vieable page (pushes all content to history)
                    set cursor home ;6*/
						  FORMAT_OP_CLEAR_PAGE
						 ,
						  FORMAT_OP_CONCEAL
                   ,
						  FORMAT_OP_DELETE_CHARS
                   ,
						  FORMAT_OP_SET_SCROLL_REGION
                   ,
						  FORMAT_OP_GET_CURSOR
						 ,
						  FORMAT_OP_SET_CURSOR
						 ,
						  FORMAT_OP_PAGE_BREAK
						 ,
/* break between paragraphs - kinda same as lines...
						  since lines are as long as possible... ;13 */
						 FORMAT_OP_PARAGRAPH_BREAK
						 ,
/* Justify line(s if wrapped) to the right
						   This attribute should be passed through to renderer;14*/
                   FORMAT_OP_JUSTIFY_RIGHT
						 ,
/* Justify line(s if wrapped) to the center
						 This attribute should be passed through to renderer;15*/
                   FORMAT_OP_JUSTIFY_CENTER
};
//typedef struct text_color_tag { uint32_t color: 8; } TEXTCOLOR;
// this was a 32 bit structure, but 8 fore, 8 back
// 8 x, 8 y failed for positioning...
// extended position, added more information
// reduced color, 16 colors is really all that there
// are... 4 bits... added bits for extended formatting
// like blink, bold, wide, high
// foreground/background  values will be
// sufficient... they retain full informaiton
//
typedef struct format_info_tag
{
   /* bit-packed flags indicating the type of format information that is applied to this segment.*/
	struct {
		// extended operation from enumeration above...
		// might shrink if more attributes are desired...
		// if many more are needed, one might consider
      // adding FONT!
     /* this segment uses the prior foreground, not its own. */
		BIT_FIELD prior_foreground : 1;
     /* this segment uses the prior background, not its own. */
		BIT_FIELD prior_background : 1;
     /* this segment uses the default foreground, not its own. */
		BIT_FIELD default_foreground : 1;
      /* this segment uses the default background, not its own. */
		BIT_FIELD default_background : 1;
      /* the foreground color of this segment (0-16 standard console text [ANSI text]) */
		BIT_FIELD foreground : 4;
      /* the background color of this segment (0-16 standard console text [ANSI text]) */
		BIT_FIELD background : 4;
      /* a bit indicating the text should blink if supported */
		BIT_FIELD blink : 1;
      /* a bit indicating the foreground and background color should be reversed */
		BIT_FIELD reverse : 1;
		// usually highly is bolder, perhaps it's
      // a highlighter effect and changes the background
		BIT_FIELD highlight : 1;
		// this is double height modifications to the font...
		BIT_FIELD tall : 1;
      // this is thicker characters...
		BIT_FIELD bold : 1;
      // draw a line under the text...
		BIT_FIELD underline : 1;
		// strike through - if able, draw a line right
		// through the middle of the text... maybe
		// it's a wiggly scribble line?  maybe that
      // could be extended again?
		BIT_FIELD strike : 1;
      // text is drawn wide (printer kinda font?)
		BIT_FIELD wide : 1;
       // this is pretty common......
		BIT_FIELD italic : 1;
		// --
		// these flags are free, but since we already have text segments
		// and I'm bringing in consoles, perhaps we should consider using
		// this to describe captions, but provide the api layer for CTEXTSTR
		// --
		// position data remains constant.
		// text is mounted at the top/left of the
		// first character... (unless center, then
		// the position specifies the middle of the text
		// draw vertical instead of horizontal
		BIT_FIELD bVertical:1;
		// draw opposite/upside down from normal
		// vertical/down, right/left upside down if not centered
		// if centered, the text pivots around position.
		BIT_FIELD bInvert:1;
		// 0 = default alignment 1 = left, 2 = center 3 = right
		// 0 is not set, the flag set in the lower 32 bit flags
		// is not needed any longer.... anything non zero
		// is that operation to apply.
		BIT_FIELD bAlign:2;
      /* format op indicates one of the enum FORMAT_OPS applies to this segment */
		BIT_FIELD format_op : 7;
	} flags;
	// if x,y are valid segment will have TF_POSFORMAT set...
	union {
		/* Coordinate information attached to a text segment. */
		/* Positioning specification of this text segment. with
		   basically 0 format options, position is used.
		   Position represents the distance from this segment to the
		   prior segment in count of tabs and spaces.
		   coords specifies an x,y coordinate location for the segment.
		   Usage of this union is dependant on <link text::format_info_tag::flags@1::format_op, format_op>. */
		struct {
         // Signed coordinate of this segment on a text display.  May be relative depending on format_op.
			int16_t x;
         // Signed coordinate of this segment on a text display.  May be relative depending on format_op.
			int16_t y;
		} coords;
		/* Defines the distance from the prior segment in count of tabs
		   and spaces (mostly count of spaces).                         */
		struct {
   // tabs preceed spaces....
			uint16_t tabs;
 // not sure what else to put with this...
			uint16_t spaces;
		} offset;
	} position;
} FORMAT, *PFORMAT;
 // special coordinate which is NO coordinate
#define IGNORE_CURSOR_POS -16384
/* test flag, format has position data */
#define TF_FORMATPOS (TF_FORMATABS|TF_FORMATREL|TF_FORMATEX)
/* these flags are used in PTEXT.flags member
 applications may use these flags to group expressions
 will affect the BuildLine but is not generated by library.
( TF_QUOTE, TF_SQUOTE, TF_BRACKET, TF_BRACE, TF_PAREN, and TF_TAG).
*/
enum TextFlags {
   // declared in program data.... do NOT release
 TF_STATIC    = 0x00000001,
   // double quoted string segment " "
 TF_QUOTE     = 0x00000002,
   // single quoted string ' '
 TF_SQUOTE    = 0x00000004,
   // bracketed expression []
 TF_BRACKET   = 0x00000008,
   // braced expression {}
 TF_BRACE     = 0x00000010,
   // parenthised expression ()
 TF_PAREN     = 0x00000020,
   // HTML tag like expression &lt;&gt;
 TF_TAG       = 0x00000040,
   // foreground is FORMAT_OP
 TF_FORMATEX  = 0x00000080,
   // x,y position used (relative)
 TF_FORMATREL = 0x00000100,
   // size field extually points at PTEXT
 TF_INDIRECT  = 0x00000200,
   // format position is x/y - else space count
 TF_FORMATABS = 0x00000800,
   // set during burst for last segment...
 TF_COMPLETE  = 0x00001000,
   // set for non-text variable
 TF_BINARY    = 0x00002000,
   // on release release indrect also...
 TF_DEEP      = 0x00004000,
   // set on first segment to send to omit lead \r\n
 TF_NORETURN  = 0x00008000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
// Low bound of value...
  TF_LOWER     = 0x00010000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
  // Upper bound of a value...
  TF_UPPER     = 0x00020000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
// boundry may be ON this value...
 TF_EQUAL     = 0x00040000,
   // this segment is not a permanent part (SubstToken)
 TF_TEMP      = 0x00080000,
  // this is something special do not treat as text indirect.
 TF_APPLICATION = 0x00100000,
};
//--------------------------------------------------------------------------
// flag combinatoin which represents actual data is present even with 0 size
// extended format operations (position, ops) are also considered data.
#define IS_DATA_FLAGS (TF_QUOTE|TF_SQUOTE|TF_BRACKET|TF_BRACE|                              TF_PAREN|TF_TAG|TF_FORMATEX|TF_FORMATABS|TF_FORMATREL)
// this THis defines/initializes the data part of a PTEXT/TEXT structure.
// used with DECLTEXTSZTYPE
#define DECLDATA(name,length) struct {size_t size; TEXTCHAR data[length];} name
#define DECLTEXTSZTYPE( name, size ) struct {    uint32_t flags;    struct text_segment_tag *Next, *Prior;    FORMAT format;    DECLDATA(data, size); } name
/* A macro to declare a structure which is the same physically
   as a PTEXT, (for declaring static buffers). Has to be cast to
   (PTEXT) is used. Is defined as a size, but no string content.
   Parameters
   name :  name of the variable to create
   size :  size of the static text element. (0 content)          */
#define DECLTEXTSZ( name, size ) DECLTEXTSZTYPE( name,(size) )	 = { TF_STATIC, NULL, NULL, {{1,1  ,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}} }
/* Defines an initializer block which can be used to satisfy a
   TEXT elemnt of a structure
   Parameters
   str :  string content of the TEXT
   Example
   <code lang="c++">
   TEXT something = DEFTEXT( "abc" );
   </code>                                                     */
#define DEFTEXT(str) {TF_STATIC,NULL,NULL,{{1,1}},{(sizeof(str)/sizeof(str[0]))-1,str}}
/* A macro to declare a structure which is the same physically
   as a PTEXT, (for declaring constant static strings
   basically). Has to be cast to (PTEXT) is used.
   Parameters
   name :   name of the variable to create
   value :  static string constant to initialize variable to.  */
#define DECLTEXT(name, str) static DECLTEXTSZTYPE( name, (sizeof(str)/sizeof(str[0])) ) = DEFTEXT(str)
/* Description
   A Text segment, it is based on DataBlock that has a length
   and an addtional region at the end of the structure which
   contains the text of the segment. Segments may have
   formatting attributes. Segments may be linked to other
   segments in a NEXTLINE/PRIORLINE. Segments may have indirect
   content, which may represent phrases. Sets of segments may
   represent sentence diagrams. A Pointer to a <link text::TEXT, TEXT>
   type.
   TEXT is a type I created to provide a variety of functions.
   One particular application was a common language processor,
   and I created the TEXT structure to store elements which are
   described by language. Sentences are words, and phases. A
   phrase is a set of words, but sometimes a word is a phrase.
   (sentence) = ( word ) ... (phrase ) ...
   (phrase) = (word)...
   hmm.. how to describe this.
   <code lang="c++">
   PTEXT phrase = NULL;
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   </code>
   <code>
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   </code>
   PTEXT segments point at other segments. A list of segments is
   a sentence. Segments can have information encoded on them
   that remove text from them. For instance, \< and \> tags
   might be removed around a phrase and stored as an attribute
   of the segment. A segment with such an attribute could be an
   indirect segment that points at a list of words which are the
   phrases in the tag.
   <code lang="c++">
   a map of two segments, and their content...
       (segment with TF_TAG) -\> (segment with TF_TAG)
             |                        |
             \+ - ("html")             + - (body) -\> (background="#000000")
   would actually expand to
      \<html\>\<body background="#000000"\>
   </code>
   See Also
   SegCreate
   burst
   TextParse
   SegAppend
   SegSubst
   SegSplit
   SegGrab
   SegDelete
   LineRelease
   BuildLine
   and also.....
   PVARTEXT                                                                  */
typedef struct text_segment_tag
{
	// then here I could overlap with pEnt .bshadow, bmacro, btext ?
   uint32_t flags;
	/* This points to the next segment in the sentence or phrase. NULL
	   if at the end of the line.                                      */
		struct text_segment_tag *Next;
	/* This points to the prior segment in the sentence or phrase. (NULL
	   if at the first segment)                                          */
		struct text_segment_tag *Prior;
	/* format is 64 bits.
      it's two 32 bit bitfields (position, expression)
	 valid if TF_FORMAT is set... */
	FORMAT format;
   /* A description of the data stored here.  It is compatible with a DATABLOCk.... */
   struct {
	   /* unsigned size; size is sometimes a pointer value...
                  this means bad thing when we change platforms... Or not, since we went to uintptr_t which is big enough for a pointer. */
		uintptr_t size;
		/* the data of the test segment
		 beginning of var data - this is created size+sizeof(TEXT) */
		   TEXTCHAR  data[1];
	} data;
} TEXT, *PTEXT;
//
// PTEXT DumpText( PTEXT somestring )
//    PTExT (single data segment with full description \r in text)
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  DumpText ( PTEXT text );
//SegCreateFromText( ".." );
// Burst, SegAppend, SegGrab
// segments are ment to be lines, the meaninful tag "TF_NORETURN" means it's part of the prior line.
//--------------------------------------------------------------------------
#define HAS_WHITESPACE(pText) ( pText && ( (pText)->format.position.offset.spaces || (pText)->format.position.offset.tabs ) )
/* A convenient macro to go from one segment in a line of text
   to the next segment.                                        */
#define NEXTLINE(line)   ((PTEXT)(((PTEXT)line)?(((PTEXT)line)->Next):(NULL)))
/* A convenient macro to go from one segment in a line of text
   to the prior segment.                                       */
#define PRIORLINE(line)  ((PTEXT)(((PTEXT)line)?(((PTEXT)line)->Prior):(NULL)))
/* Link one PTEXT segment to another. Sets one half of the links
   appropriate for usage.
   Example
   This example sets the prior pointer of 'word' to 'line'.
   <code>
   PTEXT line;
   PTEXT word;
   SETPRIORLINE( word, line );
   </code>                                                       */
#define SETPRIORLINE(line,p) ((line)?(((line)->Prior) = (PTEXT)(p)):0)
/* Link one PTEXT segment to another. Sets one half of the links
   appropriate for usage.
   Example
   This example sets the next pointer of 'line' to 'word'.
   <code lang="c#">
   PTEXT line;
   PTEXT word;
   SETNEXTLINE( line, word );
   </code>                                                       */
#define SETNEXTLINE(line,p)  ((line)?(((line)->Next ) = (PTEXT)(p)):0)
/* Sets a pointer to PTEXT to the first text segment in the
   list.                                                    */
#define SetStart(line)     for(; line && PRIORLINE(line);line=PRIORLINE(line))
/* Sets a PTEXT to the last segment that it points to.
   Parameters
   line :  segment in the line to move to the end of.
   Remarks
   Updates the variable passed to point to the last segment. */
#define SetEnd(line)      for(; line && NEXTLINE(line); line=NEXTLINE(line))
// might also check to see if pseg is an indirect - setting this size would be BAD
#define SetTextSize(pseg, sz ) ((pseg)?((pseg)->data.size = (sz )):0)
/* gets the indect segment content (if any) from a PTEXT
   segment.                                              */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GetIndirect(PTEXT segment );
/* Get the format flags of a PTEXT.
                                    */
TYPELIB_PROC  uint32_t TYPELIB_CALLTYPE  GetTextFlags( PTEXT segment );
/* Gets the text segment length. */
TYPELIB_PROC  size_t TYPELIB_CALLTYPE  GetTextSize( PTEXT segment );
/* Gets the text of a PTEXT segment. (convert to a CTEXTSTR)
   Parameters
   segment :  segment to get the string content from         */
TYPELIB_PROC  TEXTSTR TYPELIB_CALLTYPE  GetText( PTEXT segment );
// by registering for TF_APPLICTION is set on the segment
// and flags anded with the segment flags match, the
// function is called.... the result is the actual
// segment of this - since a TF_APPLICATION is also
// TF_INDIRECT - using the size to point to some application
// defined structure instead of a PTEXT structure.
TYPELIB_PROC  void TYPELIB_CALLTYPE  RegisterTextExtension ( uint32_t flags, PTEXT(CPROC*)(uintptr_t,POINTER), uintptr_t );
// similar to GetIndirect - but results in the literal pointer
// instead of the text that the application may have registered to result with.
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE  GetApplicationPointer ( PTEXT text );
/* Used to set the content of a segment to some application
   defined value. This allows a users application to store
   chunks of data in lists of text. These external chunks are
   handled like other words.
   Parameters
   text :  this is the text segment to set application data on
   p :     this is a pointer to application data               */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetApplicationPointer ( PTEXT text, POINTER p);
/* Set segment's indirect data.
   Parameters
   segment :  pointer to a TEXT segment to set the indirect content
              of.
   data :     pointer to a PTEXT to be referenced indirectly.       */
#define SetIndirect(Seg,Where)  ( (Seg)->data.size = ((uintptr_t)(Where)-(uintptr_t)NULL) )
		/* these return 1 for more(l1&gt;l2) -1 for (l1&lt;l2) and 0 for match.
       */
TYPELIB_PROC  int TYPELIB_CALLTYPE  SameText ( PTEXT l1, PTEXT l2 );
/* A test if one PTEXT is similar to another PTEXT.
   Parameters
   l1 :  PTEXT segment one
   l2 :  PTEXT segment two
   Return Value List
   \<0 :  l1 with case insensitive comparison is less then l2
   0 :    Texts compare case insenitive match
   \>0 :  l1 with case insensitive comparison is more than l2 */
TYPELIB_PROC  int TYPELIB_CALLTYPE  LikeText ( PTEXT l1, PTEXT l2 );
/* Compares if text is like a C string. Case Sensitive.
   <b>Returns</b>
   TRUE if they are alike.
   FALSE if they are different.
   <b>Parameters</b>                                    */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextIs  ( PTEXT pText, CTEXTSTR text );
/* Compares if text is like a C string. Case insensitive (like).
   Returns
   TRUE if they are alike.
   FALSE if they are different.
   Parameters
   pText :  PTEXT segment to compare
   text :   C string buffer to compare against                   */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextLike  ( PTEXT pText, CTEXTSTR text );
/* Compares if text is like a C string. Case insensitive (like). Uses min string length for max match.
   Returns
   TRUE if they are similar (both case insensitive using shorter of the strings for maxlen).
   FALSE if they are different.
   Parameters
   pText :  PTEXT segment to compare
   text :   C string buffer to compare against                   */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextSimilar  ( PTEXT pText, CTEXTSTR text );
//#define SameText( l1, l2 )  ( strcmp( GetText(l1), GetText(l2) ) )
#define textmin(a,b) ( (((a)>0)&&((b)>0))?(((a)<(b))?(a):(b)):(((a)>0)?(a):((b)>0)?(b):0) )
#ifdef __LINUX__
#  include <strings.h>
/* windows went with stricmp() and strnicmp(), whereas linux
 went with strcasecmp() and strncasecmp()                  */
#  define strnicmp strncasecmp
/* windows went with stricmp() and strnicmp(), whereas linux
   went with strcasecmp() and strncasecmp()                  */
#  define stricmp strcasecmp
#endif
/* Copy segment formatting to another segment... */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SegCopyFormat( PTEXT to_this, PTEXT copy_this );
/* Create a text segment of sepecified size; inclues one more character for NUL terminator */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateEx( size_t nSize DBG_PASS );
/* Create a PTEXT with specified number of character capacity.
   Example
   <code lang="c#">
   PTEXT text = SegCreate( 10 );
   </code>                                                     */
#define SegCreate(s) SegCreateEx(s DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromText> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromTextEx( CTEXTSTR text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromText( "Around the world in a day." );
   </code>                                                         */
#define SegCreateFromText(t) SegCreateFromTextEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromCharLenEx( const char *text, size_t len DBG_PASS );
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromCharEx( const char *text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromChar( "Around the world in a day." );
   </code>                                                         */
#define SegCreateFromChar(t) SegCreateFromCharEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
#define SegCreateFromCharLen(t,len) SegCreateFromCharLenEx((t),(len) DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromWideLenEx( const wchar_t *text, size_t len DBG_PASS );
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromWideEx( const wchar_t *text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromWideLen( L"Around the world in a day.", 26 );
   </code>                                                         */
#define SegCreateFromWideLen(t,len) SegCreateFromWideLenEx((t),(len) DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
#define SegCreateFromWide(t) SegCreateFromWideEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateIndirect> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateIndirectEx( PTEXT pText DBG_PASS );
/* Creates a text segment that refers to the parameter
   indirectly. The new segment is not really a clone, but a
   reference of the original PTEXT.
   Example
   <code lang="c#">
   PTEXT phrase = SegCreateIndirect( SegAppend( SegCreateFromText( "Hello" )
                                              , SegCreateFromText( "World" ) ) );
   </code>
   The resulting phrase is a single segment with no prior or
   next, but its content is "HelloWorld" if it was passed to
   buildline... it's go the content of the two text segments
   linked together, but not in its buffer. It is actually a 0
   length buffer for a TEXT segment.
                                                                                  */
#define SegCreateIndirect(t) SegCreateIndirectEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegDuplicate> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegDuplicateEx( PTEXT pText DBG_PASS);
/* This duplicates a specific segment. It duplicates the first
   segment of a string. If the segment has indirect data, then
   the first segment of the indirect data is duplicated.       */
#define SegDuplicate(pt) SegDuplicateEx( pt DBG_SRC )
/* Duplicates a linked list of segments.
   Duplicates the structure of a line. The resulting line is an
   exact duplicate of the input line. All segments linked in
   exactly the same sorts of ways.
   Parameters
   line :  list of segments to duplicate                        */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  LineDuplicateEx( PTEXT pText DBG_PASS );
/* <combine sack::containers::text::LineDuplicateEx@PTEXT pText>
   \ \                                                           */
#define LineDuplicate(pt) LineDuplicateEx(pt DBG_SRC )
/* \ \
   See Also
   <link DBG_PASS>
   <link TextDuplicate> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  TextDuplicateEx( PTEXT pText, int bSingle DBG_PASS );
/* Duplicate the whole string of text to another string with
   exactly the same content.                                 */
#define TextDuplicate(pt,s) TextDuplicateEx(pt,s DBG_SRC )
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromInt> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromIntEx( int value DBG_PASS );
/* Creates a text segment from a 64 bit integer.
   Example
   <code>
   PTEXT number = SegCreateFromInt( 3314 );
   </code>                                       */
#define SegCreateFromInt(v) SegCreateFromIntEx( v DBG_SRC )
/* Converts an integer to a PTEXT segment.
   Parameters
   _64bit_value :  integer value to convert to a PTEXT segment. */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFrom_64Ex( int64_t value DBG_PASS );
/* Create a text segment from a uint64_t bit value. (long long int) */
#define SegCreateFrom_64(v) SegCreateFrom_64Ex( v DBG_SRC )
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromFloat> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromFloatEx( float value DBG_PASS );
/* Creates a text segment from a floating point value. Probably
   uses something like '%g' to format output. Fairly limited.
   Example
   <code lang="c++">
   PTEXT short_PI = SegCreateFromFloat( 3.14 );
   </code>                                                      */
#define SegCreateFromFloat(v) SegCreateFromFloatEx( v DBG_SRC )
/* Appends a list of segments to an existing list of segments. This
   assumes that the additional segment is referncing the head of
   the segment list.
   Parameters
   source :  source list to add to
   other :   additional segments to add to source.                  */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegAppend   ( PTEXT source, PTEXT other );
/* Inserts a segment before another segment.
   Parameters
   what :    what to insert into the list
   before :  insert the segments before this segment
   Returns
   The parameter 'what'.                             */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegInsert   ( PTEXT what, PTEXT before );
/* This expands a segment by a number of characters.
   Parameters
   PTEXT :  the segment to expand
   int :    count of character to expand by
   Returns
   A pointer to a new segment that is bigger, but has the same
   existing content.                                           */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegExpandEx (PTEXT source, INDEX nSize DBG_PASS );
/* <combine sack::containers::text::SegExpandEx@PTEXT@INDEX nSize>
   \ \                                                             */
#define SegExpand(s,n) SegExpandEx( s,n DBG_SRC )
/* Release a linked list of PTEXT segments.
   Parameters
   segments :  a segment in a list of segments to delete, first
               this routine goes to the start of the segment
               list, and then deletes all segments in the list.
   DBG_PASS :  debug file and line information                  */
TYPELIB_PROC  void TYPELIB_CALLTYPE   LineReleaseEx (PTEXT line DBG_PASS );
/* Release a line of text.
   A line may be a single segment.
   This is the proper way to dispose of PTEXT segments.
   Any segment in the line may be passed, the first segment is
   found, and then all segments in the line are deleted.       */
#define LineRelease(l) LineReleaseEx(l DBG_SRC )
/* \ \
   <b>See Also</b>
   <link DBG_PASS>
   <link SegRelease> */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SegReleaseEx( PTEXT seg DBG_PASS );
/* Release a single segment. UNSAFE. Does not respect that it is
   in a list.
   See Also
   <link LineRelease>                                            */
#define SegRelease(l) SegReleaseEx(l DBG_SRC )
/* Adds a part of input to the segment list of output.
   Parameters
   output\ :   the segment list to append to.
   input\ :    the input buffer to append from
   offset :    starting offset in 'input' to start from
   length :    how much from 'offset' in input to append as a new
               segment to output.
   DBG_PASS :  \file and line debugging information               */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegConcatEx   (PTEXT output,PTEXT input,int32_t offset,size_t length DBG_PASS);
/* <combine sack::containers::text::SegConcatEx@PTEXT@PTEXT@int32_t@size_t length>
   looks like it takes a piece of one segment and appends it to
   another....
   Needs More research to document correctly and exemplify.                     */
#define SegConcat(out,in,ofs,len) SegConcatEx(out,in,ofs,len DBG_SRC)
/* Removes a segment from a list of segments. Links what was
   prior and what was after together. Sets both next and prior
   of the segment unlinked to NULL.
   Example
   <code lang="c++">
   SegUnlink( segment );
   </code>
   Returns
   The segment passed.                                         */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegUnlink   (PTEXT segment);
/* Breaks a list of PTEXT segments at the specified segment and
   \returns a segment that was before the specified.
   Parameters
   segment :  segment to break the chain at
   Returns
   Any existing segment before the segment to break at.
   Example
   <code lang="c++">
   {
      PTEXT segs;
      PTEXT breakat;
      PTEXT leftover;
		&#47;* ... segs gets populated with some segments ... *&#47;
      breakat = NEXTLINE( segs );
   </code>
   <code>
      breakat = NEXTLINE( segs );
      leftover = segbreak( breakat );
      // now breakat begins a new chain of segments
      // leftover is the segment that was just before breakat
      SegStart( leftover );  // leftover would be equal to segs...
   }
   </code>                                                         */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegBreak    (PTEXT segment);
/* Removes a segment from a list. It also releases the segment.
    Example
    <code lang="c#">
    SegDelete( segment );
    </code>
    the result is NULL;                                          */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegDelete   (PTEXT segment);
/* removes segment from any list it might be in, returns
   segment.                                              */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegGrab     (PTEXT segment);
/* Substitute one PTEXT segment for another in a list of PTEXT
   segments.
   Parameters
   _this :  This is the segment to remove
   that :   This is the segment to subustitute with. This may be
            a list of segments, and it is linked in from the
            first segment to the prior to '_this' and the last to
            the next after '_this'
   Returns
   \Returns the '_this' that was substituted.                     */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegSubst    ( PTEXT _this, PTEXT that );
/* \ \
   See Also
   <link DBG_PASS>
   <link SegSplit> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegSplitEx( PTEXT *pLine, INDEX nPos DBG_PASS);
/* Split a PTEXT segment.
   Example
   \ \
   <code lang="c++">
   PTEXT result = SegSplit( &amp;old_string, 5 );
   </code>
   Returns
   PTEXT new_string;
   Remarks
   the old string segment is split at the position indicated. The
   pointer to the old segment is modified to point to now two
   segments linked dynamically, each part of the segment after
   the split. If the index is beyond the bounds of the segment,
   the segment remains unmodified.                                */
#define SegSplit(line,pos) SegSplitEx( line, pos DBG_SRC )
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  FlattenLine ( PTEXT pLine );
/* Create a highest precision signed integer from a PTEXT. */
TYPELIB_PROC  int64_t TYPELIB_CALLTYPE  IntCreateFromSeg( PTEXT pText );
/* Converts a text to the longest precision signed integer
   value.
     allows +/- leadin ([-*]|[+*])*
     supports 0x### (hex), 0b#### (binary), 0o#### (octal), 0### (octal)
	 decimal 1-9[0-9]*
	 buggy implementation supports +/- inline continue number and are either ignored(+)
	 or changes the overall sign of the number(-).  A Decimal definatly ends the number.
	 And octal/binary digits aren't checked for range, so 8/9 will over-flow in octal,
	 and 2-9 overflow to upper bits in octal...
	    0b901090 // would be like   0b 10100110    0b1001 +  010 + 1001<<3 + 0
   */
TYPELIB_PROC  int64_t TYPELIB_CALLTYPE  IntCreateFromText( CTEXTSTR p );
/* Converts a text to the longest precision signed integer
   value.  Does the work of IntCreateFromText.
   IntCreateFromTextRef updates the pointer passed by reference so
   the pointer ends at the first character after the returned number.
   */
TYPELIB_PROC  int64_t TYPELIB_CALLTYPE  IntCreateFromTextRef( CTEXTSTR *p_ );
/* Create a high precision floating point value from PTEXT
   segment.                                                */
TYPELIB_PROC  double TYPELIB_CALLTYPE  FloatCreateFromSeg( PTEXT pText );
/* Create a high precision floating point value from text
   string.                                                */
TYPELIB_PROC  double TYPELIB_CALLTYPE  FloatCreateFromText( CTEXTSTR p, CTEXTSTR *pp );
//
// IsSegAnyNumber returns 0 if no, 1 if is int, 2 if is float
//   if pfNumber or piNumber are available then the text pointer
//   will be updated to the next segment after what was used to resolve
//   the number.
//   bUseAllSegs is for testing pTexts which are indirect, such that
//      only all segments within the indirect segment will result valid.
//   pfNumber and piNumber may be passed as NULL, and the function can still
// be used to determine ifnumber
//   the number resulting in the values pointed to will be filled in
//    with (*pfNumber)=FltCreateFromSeg(p) (or Int as appropriate)
//
//#define IsNumber(p) IsSegAnyNumberEx( &(p), NULL, NULL, NULL, 0 )
#define IsIntNumber(p, pint) IsSegAnyNumberEx( &(p), NULL, pint, NULL, 0 )
/* Tests a PTEXT segment to see if it might be a floating point
   number.                                                      */
#define IsFltNumber(p, pflt) IsSegAnyNumberEx( &(p), pflt, NULL, NULL, 0 )
/* Tests the content of a PTEXT to see if it might be a number.
   Parameters
   ppText :       pointer to PTEXT to check
   pfNumber :     pointer to double to get result of number it's
                  a float
   piNumber :     pointer to a signed 64 bit value to get the
                  \result if it's not a float.
   pbIsInt :      point to a integer \- receives boolean result
                  if the segment was an integer is TRUE else it's
                  a double.
   bUseAllSegs :  if TRUE, use all the segments starting with the
                  first, and update the pointer to the next
                  stgment. If false, use only the first segment. if
                  uses all segments, it must also use ALL
                  segments to get the number.
   Returns
   0 if not a number or fails.
   1 if a valid conversion took place.                              */
TYPELIB_PROC  int TYPELIB_CALLTYPE  IsSegAnyNumberEx ( PTEXT *ppText, double *pfNumber, int64_t *piNumber, int *pbIsInt, int bUseAllSegs );
/* <combine sack::containers::text::IsSegAnyNumberEx@PTEXT *@double *@int64_t *@int *@int>
   \ \                                                                                  */
#define IsSegAnyNumber(pptext, pfNum, piNum, pbIsInt) IsSegAnyNumberEx( pptext, pfNum, piNum, pbIsInt, 0 )
/* \Returns the amount of space required to store this segment,
   and all indirect statements it contains.
   Parameters
   segment :   segment to measure
   position :  starting position in the segment to measure from
   nTabSize :  how big tabs are supposed to be
   tabs :      list of tab positions (for arbitrary tab
               positioning\- table column alignment?)           */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentSpaceEx ( PTEXT segment, INDEX position, int nTabs, INDEX *tabs);
/* \Returns the amount of space required to store this segment,
   and all indirect statements it contains.
   Parameters
   segment :   segment to measure
   position :  starting position in the segment to measure
               from
   nTabSize :  how big tabs are supposed to be                  */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentSpace ( PTEXT segment, INDEX position, int nTabSize );
/* Simlar to getsegment space... */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentLengthEx ( PTEXT segment, INDEX position, int nTabs, INDEX *tabs );
/* \Returns the length of a single PTEXT segment.
   Parameters
   segment :   segment to measure
   position :  string position in the string to measure
   nTabSize :  how many characters a tab is supposed to be. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentLength ( PTEXT segment, INDEX position, int nTabSize );
/* Measure the length of a list of segments (combined length of
   all linked segments)                                         */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  LineLengthExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL );
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  LineLengthExx( PTEXT pt, LOGICAL bSingle,PTEXT pEOL );
/* <combine sack::containers::text::LineLengthExEx@PTEXT@LOGICAL@int@PTEXT>
   \ \                                                                      */
#define LineLengthExx(pt,single,eol) LineLengthExEx( pt,single,8,eol)
/* \ \
   Parameters
   Text segment :  PTEXT line or segment to get the length of
   single :        boolean, if set then only a single segment is
                   measured, otherwise all segments from this to
                   the end are measured.                         */
#define LineLengthEx(pt,single) LineLengthExx( pt,single,NULL)
/* Computes the length of characters in a line, if all segments
   in the line are flattened into a single word.                */
#define LineLength(pt) LineLengthEx( pt, FALSE )
/* Collapses an indirect segment or a while list of segments
   into a single segment with content expanded. When passed to
   things like TextParse and Burst, segments have their
   positioning encoded to counters for tabs and spaces; the
   segment itself contains only text without whitespace. Buildline
   expands these segments into their plain text representation.
   Parameters
   pt :        pointer to a PTEXT segment.
   bSingle :   if TRUE, build only the first segment. If the
               segment is indirect, builds entire content of
               indirect.
   nTabsize :  how wide tabs are. When written into a line, tabs
               are written as spaces. (maybe if 0, tabs are
               emitted directly?)
   pEOL :      the segment to use to represent an end of line. Often
               this is a SegCreate(0) segment.                       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  BuildLineExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL DBG_PASS );
/* Collapses an indirect segment or a while list of segments
into a single segment with content expanded. When passed to
things like TextParse and Burst, segments have their
positioning encoded to counters for tabs and spaces; the
segment itself contains only text without whitespace. Buildline
expands these segments into their plain text representation.
Parameters
pt :        pointer to a PTEXT segment.
bSingle :   if TRUE, build only the first segment. If the
segment is indirect, builds entire content of
indirect.
pEOL :      the segment to use to represent an end of line. Often
this is a SegCreate(0) segment.                       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  BuildLineExx( PTEXT pt, LOGICAL bSingle, PTEXT pEOL DBG_PASS );
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
\ \                                                                          */
#define BuildLineExx(from,single,eol) BuildLineExEx( from,single,8,NULL DBG_SRC )
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
   \ \                                                                          */
#define BuildLineEx(from,single) BuildLineExEx( from,single,8,NULL DBG_SRC )
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
   \ \
    Flattens all segments in a line to a single segment result.
*/
#define BuildLine(from) BuildLineExEx( from, FALSE,8,NULL DBG_SRC )
//
// text parse - more generic flavor of burst.
//
//static CTEXTSTR normal_punctuation=WIDE("\'\"\\({[<>]}):@%/,;!?=*&$^~#`");
// filter_to_space " \t"
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  TextParse ( PTEXT input, CTEXTSTR punctuation, CTEXTSTR filter_tospace, int bTabs, int bSpaces  DBG_PASS );
/* normal_punctuation=WIDE("'"\\({[\<\>]}):@%/,;!?=*&amp;$^~#`");
   Process a line of PTEXT into another line of PTEXT, but with
   words parsed as appropriate for common language.
   Parameters
   input\ :  pointer to a list of PTEXT segments to parse.
   Remarks
   Burst is a simple method of breaking a sentence into its word
   and phrase parts. It collapses space and tabs before words
   into the word. Any space representation is space preceeding
   the word. Sentences are also broken on any punctuation.
   "({[\<\>]})'";;.,/?\\!@#$%^&amp;*=" for instances. + and - are
   treated specially if they prefix numbers, otherwise they are
   also punctuation. Also groups of '.' like '...' are kept
   together. if the '.' is in a number, it is stored as part of
   the number. Otherwise a '.' used in an abbreviation like P.S.
   will be a '.' with 0 spaces followed by a segment also with 0
   spaces. (unless it's the lsat one)
   so initials are encoded badly.
   Bugs
   There is an exploit in the parser such that . followed by a
   number will cause fail to break into seperate words. This is
   used by configuration scripts to write binary blocks, and
   read them back in, having the block parsed into a segment
   correctly.
   See Also
   <link sack::containers::text::TextParse@PTEXT@CTEXTSTR@CTEXTSTR@int@int bSpaces, TextParse> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  burstEx( PTEXT input DBG_PASS);
/* <combine sack::containers::text::burstEx@PTEXT input>
   \ \                                                   */
#define burst( input ) burstEx( (input) DBG_SRC )
/* Compares a couple lists of text segments.
   Parameters
   pt1 :      pointer to a phrase
   single1 :  use only the first word, not the whole phrase
   pt2 :      pointer to a phrase
   single2 :  use only the first segment, not the whole phrase
   bExact :   if FALSE, match case insensitive, otherwise match
              exact case.                                       */
TYPELIB_PROC  int TYPELIB_CALLTYPE  CompareStrings( PTEXT pt1, int single1
                            , PTEXT pt2, int single2
                            , int bExact );
/* This removes indirect segments, replacing them with their
   indirect content.
   Parameters
   pLine :  pointer to a PTEXT segment list to flatten.      */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  FlattenLine ( PTEXT pLine );
/* Steps through a linked list of segments, just a convenient
   for loop wrapper.                                          */
#define FORALLTEXT(start,var)  for(var=start;var; var=NEXTLINE(var))
/* returns number of characters filled into output.  Output needs to be at maximum 6 chars */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF8( char *output, TEXTRUNE rune );
/* returns number of characters filled into output.  Output needs to be at maximum 6 chars;  if overlong is set
   characters are deliberatly padded to be overlong */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF8Ex( char *output, TEXTRUNE rune, LOGICAL overlong );
/* returns number of wchar filled into output.  Output needs to be at maximum 2 wchar. */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF16( wchar_t *output, TEXTRUNE rune );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfChar( const char **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharIndexed( const char *from, size_t *index, size_t length );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfChar( const char *start, const char **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharIndexed( const char *from, size_t *index );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharW( const wchar_t **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharIndexedW( const wchar_t *from, size_t *index );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharW( const wchar_t *start, const wchar_t **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharIndexedW( const wchar_t *from, size_t *index );
TYPELIB_PROC size_t TYPELIB_CALLTYPE GetDisplayableCharacterCount( const char *string, size_t max_bytes );
TYPELIB_PROC CTEXTSTR TYPELIB_CALLTYPE GetDisplayableCharactersAtCount( const char *string, size_t character_index );
TYPELIB_PROC size_t TYPELIB_CALLTYPE  GetDisplayableCharacterBytes( const char *string, size_t character_count );
/* You Must Deallocate the result */
TYPELIB_PROC char * TYPELIB_CALLTYPE WcharConvert_v2 ( const wchar_t *wch, size_t len, size_t *outlen DBG_PASS );
/* You Must Deallocate the result */
TYPELIB_PROC  char * TYPELIB_CALLTYPE  WcharConvertExx ( const wchar_t *wch, size_t len DBG_PASS );
/* You Must Deallocate the result */
TYPELIB_PROC  char * TYPELIB_CALLTYPE  WcharConvertEx ( const wchar_t *wch DBG_PASS );
/* <combine sack::containers::text::WcharConvertExx@wchar_t *@size_t len>
   \ \                                                                    */
#define WcharConvertLen(s,len) WcharConvertExx(s, len DBG_SRC )
/* <combine sack::containers::text::WcharConvertExx@wchar_t *@size_t len>
   \ \                                                                    */
#define WcharConvert(s) WcharConvertEx(s DBG_SRC )
/* You Must Deallocate the result */
TYPELIB_PROC wchar_t * TYPELIB_CALLTYPE CharWConvertExx ( const char *wch, size_t len DBG_PASS );
/* Convert wchar_t strings to char strings.
   Parameters
   string :    wchar_t string to convert
   DBG_PASS :  debug file and line information
   Returns
   A char * string. This string must be Release()'ed or
   Deallocate()'ed by the user.                         */
TYPELIB_PROC wchar_t * TYPELIB_CALLTYPE CharWConvertEx ( const char *wch DBG_PASS );
/* <combine sack::containers::text::CharWConvertExx@char *@size_t len>
   \ \                                                                 */
#define CharWConvertLen(s,len) CharWConvertExx(s,len DBG_SRC )
/* <combine sack::containers::text::CharWConvertExx@char *@size_t len>
   \ \                                                                 */
#define CharWConvert(s) CharWConvertEx(s DBG_SRC )
//--------------------------------------------------------------------------
/* This is a string collector type.  It has an interface to be able to vtprintf( vartext, "format string", ... ); which appends the specified string to the collected text.
  Example
   PVARTEXT pvt = VarTextCreate();
   vtprintf( pvt, "hello world!" );
   {
      PTEXT text = VarTextGet( pvt );
	  printf( "Text is : %s(%d)", GetText( text ), GetTextSize( text ) );
	  LineRelease( text );
   }
   VarTextDestroy( &pvt );
   */
typedef struct vartext_tag *PVARTEXT;
/* Creates a variable text collector. Allows specification of
   initial size and amount to expand by. SQL Command line sample
   utility uses this and allocates like 10,000 initial and sets
   expand as 40,000, because it expects to build very large
   strings, and expansion of 32 at a time is ludicrous; if the
   space required is more than the expansion factor, then it is
   expanded by the amount required plus the expansion factor.
   Parameters
   initial :   amount of initial buffer
   exand_by :  how much to expand the buffer by when more room
               is needed
   DBG_PASS :  debug file and line parameters.                   */
TYPELIB_PROC  PVARTEXT TYPELIB_CALLTYPE  VarTextCreateExEx ( uint32_t initial, uint32_t expand DBG_PASS );
/* <combine sack::containers::text::VarTextCreateExEx@uint32_t@uint32_t expand>
   \ \                                                                */
#define VarTextCreateExx(i,e) VarTextCreateExEx(i,e DBG_SRC )
/* <combine sack::containers::text::VarTextCreateExEx@uint32_t@uint32_t expand>
   Creates a variable text collector. Default initial size and
   expansion is 0 and 32.
                                                                      */
TYPELIB_PROC  PVARTEXT TYPELIB_CALLTYPE  VarTextCreateEx ( DBG_VOIDPASS );
/* The simplest, most general way to create a PVARTEXT
   collector. The most extended vartext creator allows
   specification of how long the initial buffer is, and how much
   the buffer expands by when required. This was added to
   optimize building HUGE SQL queries, working withing 100k
   buffers that expanded by 50k at a time was a lot less
   operations than expanding 32 bytes or something at a time.    */
#define VarTextCreate() VarTextCreateEx( DBG_VOIDSRC )
/* Empties and destroys all resources associated with the
   variable text collector.
   Parameters
   pvt * :     address of a PVARTEXT reference to destroy. Sets
               the pointer to NULL when it's destroyed.
   DBG_PASS :  debugging file and line parameters
   Example
   <code lang="c++">
   {
      PVARTEXT pvt = VarTextCreate();
      VarTextDestroy( &amp;pvt );
   }
   void Function( int something DBG_PASS )
   {
      pvt = VarTextCreateEx( DBG_RELAY );
      VarTextDestroyEx( &amp;pvt DBG_RELAY );
   }
   </code>
   C++ Syntax
   \ \                                                          */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextDestroyEx ( PVARTEXT* DBG_PASS );
/* Destroy a VarText collector. */
#define VarTextDestroy(pvt) VarTextDestroyEx( pvt DBG_SRC )
/* \Internal function - used to initialize a VARTEXT structure. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextInitEx( PVARTEXT pvt DBG_PASS);
/* Probably should not be exported. Initializes a VARTEXT
   structure to prepare it for subsequent VarText operations. */
#define VarTextInit(pvt) VarTextInitEx( (pvt) DBG_SRC )
/* Empties a PVARTEXT structure.
   Parameters
   pvt :  PVARTEXT to empty.     */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextEmptyEx( PVARTEXT pvt DBG_PASS);
/* <combine sack::containers::text::VarTextEmptyEx@PVARTEXT pvt>
   \ \                                                           */
#define VarTextEmpty(pvt) VarTextEmptyEx( (pvt) DBG_SRC )
/* Add a single character to a vartext collector.
   Note
   \ \
   Parameters
   pvt :       PVARTEXT to add character to
   c :         character to add
   DBG_PASS :  optional debug information         */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddCharacterEx( PVARTEXT pvt, TEXTCHAR c DBG_PASS );
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddRuneEx( PVARTEXT pvt, TEXTRUNE c, LOGICAL overlong DBG_PASS );
/* Adds a single character to a PVARTEXT collector.
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddCharacter( pvt, 'a' );
   </code>                                          */
#define VarTextAddCharacter(pvt,c) VarTextAddCharacterEx( (pvt),(c) DBG_SRC )
/* Adds a single rune to a PVARTEXT collector. (may be multiple characters convert to UTF8)
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddRune( pvt, 'a' );
   </code>                                          */
#define VarTextAddRune(pvt,c) VarTextAddRuneEx( (pvt),(c), FALSE DBG_SRC )
/* Adds a length of data to the vartext. This allows strings
   with nuls included to be added.
   Parameters
   pvt :       PVARTEXT to add data to
   block :     pointer to data to add
   size :      length of data block to add
	DBG_PASS :  optional file and line parameters             */
#define VARTEXT_ADD_DATA_NULTERM ((size_t)0xFF000000)
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddDataEx( PVARTEXT pvt, CTEXTSTR block, size_t length DBG_PASS );
/* Adds a single character to a PVARTEXT collector.
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddData( pvt, "test one", 8 );
   </code>                                          */
#define VarTextAddData(pvt,block,length) VarTextAddDataEx( (pvt),(block),(length) DBG_SRC )
/* Commits the currently collected text to segment, and adds the
   segment to the internal line accumulator.
		 returns true if any data was added...
       move any collected text to commit... */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  VarTextEndEx( PVARTEXT pvt DBG_PASS );
/* <combine sack::containers::text::VarTextEndEx@PVARTEXT pvt>
   \ \                                                         */
#define VarTextEnd(pvt) VarTextEndEx( (pvt) DBG_SRC )
/* Gets the length of the current collection in the VARTEXT.
   Parameters
   pvt :  PVARTEXT collector to get the length.              */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  VarTextLength( PVARTEXT pvt );
/* Gets the text segment built in the VarText. The PVARTEXT is
   set to empty. Clears the collector.
   Parameters
   pvt :  PVARTEXT to get text from.                           */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  VarTextGetEx( PVARTEXT pvt DBG_PASS );
/* <combine sack::containers::text::VarTextGetEx@PVARTEXT pvt>
   \ \                                                         */
#define VarTextGet(pvt) VarTextGetEx( (pvt) DBG_SRC )
/* Used to look at the vartext collector and get the current
   collection. Does not clear the collector.
   Parameters
   pvt :       PVARTEXT collector to peek at
   DBG_PASS :  debugging file and line parameters
   Return Value List
   NULL :      No data
   not NULL :  text segment which is in the collector.       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  VarTextPeekEx ( PVARTEXT pvt DBG_PASS );
/* \Returns the PTEXT that is currently in a PVARTEXT. It does
   not alter the contents of the PVARTEXT. Do not LineRelease
   this peeked value.                                          */
#define VarTextPeek(pvt) VarTextPeekEx( (pvt) DBG_SRC )
/* Increases the internal storage size of the variable text
   collector.
   Parameters
   pvt :       the var text collector to expand
   amount :    amount of size to expand the collector
   DBG_PASS :  debugging file and line parameters           */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextExpandEx( PVARTEXT pvt, INDEX size DBG_PASS );
/* Add a specified number of characters to the amount of space
   in the VARTEXT collector.                                   */
#define VarTextExpand(pvt, sz) VarTextExpandEx( (pvt), (sz) DBG_SRC )
//TYPELIB_PROC  int vtprintfEx( PVARTEXT pvt DBG_PASS TYPELIB_CALLTYPE  CTEXTSTR format, ... ;
// note - don't include format - MUST have at least one parameter passed to ...
//#define vtprintf(pvt, ...) vtprintfEx( (pvt) DBG_SRC, __VA_ARGS__ )
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  vtprintfEx( PVARTEXT pvt, CTEXTSTR format, ... );
/* <combine sack::containers::text::vtprintfEx@PVARTEXT@CTEXTSTR@...>
   Note                                                               */
#define vtprintf vtprintfEx
/* variable argument VARTEXT printf. Is passed a PVARTEXT to
   collect the formatted output using printf sort of formatting. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  vvtprintf( PVARTEXT pvt, CTEXTSTR format, va_list args );
/* encode binary buffer into base64 encoding.
   outsize is updated with the length of the buffer.
 */
TYPELIB_PROC  TEXTCHAR * TYPELIB_CALLTYPE  EncodeBase64Ex( const uint8_t* buf, size_t length, size_t *outsize, const char *encoding );
/* decode base64 buffer into binary buffer
   outsize is updated with the length of the buffer.
   result should be Release()'d
 */
TYPELIB_PROC  uint8_t * TYPELIB_CALLTYPE  DecodeBase64Ex( const char* buf, size_t length, size_t *outsize, const char *encoding );
/* xor a base64 encoded string over a utf8 string, keeping the utf8 characters in the same length...
   although technically this can result in invalid character encoding where upper bits get zeroed
   result should be Release()'d
*/
TYPELIB_PROC  char * TYPELIB_CALLTYPE  u8xor( const char *a, size_t alen, const char *b, size_t blen, int *ofs );
/* xor two base64 encoded strings, resulting in a base64 string
   result should be Release()'d
*/
TYPELIB_PROC  char * TYPELIB_CALLTYPE  b64xor( const char *a, const char *b );
//--------------------------------------------------------------------------
// extended command entry stuff... handles editing buffers with insert/overwrite/copy/paste/etc...
typedef struct user_input_buffer_tag {
	// -------------------- custom cmd buffer extension
  // position counter for pulling history; negative indexes are recalled commands.
	int nHistory;
  // a link queue which contains the prior lines of text entered for commands.
	PLINKQUEUE InputHistory;
 // set to TRUE when nHistory has wrapped...
	int   bRecallBegin;
   /* A exchange-lock variable for controlling access to the
      \history (so things aren't being read from it while it is
      scrolling old data out).                                  */
	uint32_t   CollectionBufferLock;
  // used to store index.. for insert type operations...
	INDEX CollectionIndex;
 // flag for whether we are inserting or overwriting
	int   CollectionInsert;
 // flag for whether we are inserting or overwriting
	int   storeCR;
 // used to store partial from GatherLine
	PTEXT CollectionBuffer;
 // called when a buffer is complete.
	void (CPROC*CollectedEvent)( uintptr_t psv, PTEXT text );
  // passed to the event callback when a line is completed
	uintptr_t psvCollectedEvent;
} USER_INPUT_BUFFER, *PUSER_INPUT_BUFFER;
/* Creates a buffer structure which behaves like the command
   line command recall queue.
                                                             */
TYPELIB_PROC  PUSER_INPUT_BUFFER TYPELIB_CALLTYPE  CreateUserInputBuffer ( void );
/* Destroy a created user input buffer. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DestroyUserInputBuffer ( PUSER_INPUT_BUFFER *pci );
// negative with SEEK_SET is SEEK_END -nPos
enum CommandPositionOps {
	// defined that the x,y position in the segment should be used for absolute positioning.
   // can also be SEEK_SET
 COMMAND_POS_SET = 0,
 // defined that the x,y position in the segment should be used for relative positioning.
 // can also be SEEK_CUR
 COMMAND_POS_CUR = 1
};
/* Updates the current input position, for things like input,
   etc. Some external process indicates where in the line to set
   the cursor position.                                          */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  SetUserInputPosition ( PUSER_INPUT_BUFFER pci, int nPos, int whence );
// bInsert < 0 toggle insert.  bInsert == 0 clear isnert(set overwrite) else
// set insert (clear overwrite )
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetUserInputInsert ( PUSER_INPUT_BUFFER pci, int bInsert );
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetUserInputSaveCR( PUSER_INPUT_BUFFER pci, int bSaveCR );
/* Get the next command in the queue in the speicifed direction
   Parameters
   pci :  pointer to command input buffer
   bUp :  if TRUE \- get older command; else get the newer
          command.                                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RecallUserInput ( PUSER_INPUT_BUFFER pci, int bUp );
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GetUserInputLine( PUSER_INPUT_BUFFER pOutput );
/* Add a buffer to the history buffer.
                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  EnqueUserInputHistory ( PUSER_INPUT_BUFFER pci, PTEXT pHistory );
/* Arbitrary PTEXT blocks are fed to the user input queue with
   this.
   Parameters
   pci :     pointer to command buffer
   stroke :  the stroke to add to the buffer (may be a whole
             String or linked list of segments). or NULL if
             getting existing input...
   Return Value List
   NULL :      There is no command available \- no text followed
               by a newline.
   not NULL :  A command line collected from the input text. There
               may be multiple commands in a single 'stroke'
               buffer.
   Example
   This may be used something like .... to add the storke to the
   \input buffer, and while there is a result, get the result
   from the buffer.
   <code lang="c++">
   {
       PUSER_INPUT_BUFFER pci = CreateUserInputBuffer();
       PTEXT result;
       for( result = GatherUserInput( pci, new_stroke ); result; result = GatherUserInput( pci, NULL ) )
       {
       }
   }
   </code>                                                                                               */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GatherUserInput ( PUSER_INPUT_BUFFER pci, PTEXT stroke );
/* delete 1 character at current user input index */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteUserInput( PUSER_INPUT_BUFFER pci );
/* Converts ascii character set to ebcidc. */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE  ConvertAsciiEbdic( TEXTSTR text, INDEX length );
/* Routine to convert from ebcdic character set to ascii. */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE  ConvertEbcdicAscii( TEXTSTR text, INDEX length );
/* Converts ascii 85 to ascii */
TYPELIB_PROC TEXTSTR FtnATA( TEXTSTR buf );
/* Converts ascii character set to ascii 85  */
TYPELIB_PROC TEXTSTR ATFtnA( TEXTSTR buf );
/* Expand characters which are outside of standard ascii to URI
   compatible escapes.
   Parameters
   text :        Text to convert
   length :      max length of text to convert
   skip_slash :  if TRUE, keep slash characters as literal,
                 otherwise they get converted.                  */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE ConvertTextURI( CTEXTSTR text, INDEX length, int skip_slash );
/* Converts URI escape characters like %3B to the appropriate
   ascii characters. The resulting string must be released by
   the application.
   Parameters
   text :    TEXTCHAR * string to convert.
   length :  max length of text to convert.
   Example
   <code lang="c++">
   TEXTCHAR *sample = WIDE( "https://www.google.com/#hl=en&amp;sugexp=eqn&amp;cp=11&amp;gs_id=1a&amp;xhr=t&amp;q=%3B+%5C+%2B+:+";
   TEXTCHAR *result;
   \result = ConvertURIText( sample, StrLen( sample ) );
   \result == https://www.google.com/#hl=en&amp;sugexp=eqn&amp;cp=11&amp;gs_id=1a&amp;xhr=t&amp;q=;+\\+++:+
   </code>                                                                                                                        */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE ConvertURIText( CTEXTSTR text, INDEX length );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE ParseStringVector( CTEXTSTR data, CTEXTSTR **pData, int *nData );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE ParseIntVector( CTEXTSTR data, int **pData, int *nData );
#ifdef __cplusplus
 //namespace text {
}
#endif
//--------------------------------------------------------------------------
#ifdef __cplusplus
	namespace BinaryTree {
#endif
/* This type defines a specific node in the tree. It is entirely
   private, and is a useless definition.                         */
typedef struct treenode_tag *PTREENODE;
/* Defines a Binary Tree.
   See Also
   <link CreateBinaryTree> */
typedef struct treeroot_tag *PTREEROOT;
/* This option may be passed to extended CreateBinaryTree
   methods to disallow adding of duplicates. Otherwise
   duplicates will be added; they will be added to the side of
   the node with the same value that has less children. Trees
   are created by default without this option, allowing the
   addition of duplicates.
   Example
   <code lang="c++">
   PTREEROOT = <link CreateBinaryTreeExtended>( BT_OPT_NODUPLICATES, NULL, NULL DBG_SRC );
   </code>                                                                                 */
#define BT_OPT_NODUPLICATES 1
/* Generic Compare is the type declaration for the callback routine for user custom comparisons.
  This routine should return -1 if new is less than old, it should return 1 if new is more than old, and it
  should return 0 if new and old are the same key. */
typedef int (CPROC *GenericCompare)( uintptr_t oldnode,uintptr_t newnode );
/* Signature for the user callback passed to CreateBinaryTreeEx
   that will be called for each node removed from the binary
   list.                                                        */
typedef void (CPROC *GenericDestroy)( CPOINTER user, uintptr_t key);
/* when adding a node if Compare is NULL the default method of a
   basic unsigned integer compare on the key value is done. if
   Compare is specified the specified key value of the orginal
   node (old) and of the new node (new) is added. Result of
   compare should be ( \<0 (lesser)) ( 0 (equal)) ( \>0
   (greater))
   Example
   <code lang="c++">
   int CPROC MyGenericCompare( uintptr_t oldnode,uintptr_t newnode )
   {
   </code>
   <code>
      if(oldnode\>newnode)
          return 1;
      else if(oldnode\<newnode)
          return -1;
      else return 0;
   </code>
   <code lang="c++">
      return (oldnode\>newnode)? 1
             \:(oldnode\<newnode)? -1
             \:0;
   }
   void CPROC MyGenericDestroy(POINTER user, uintptr_t key)
   {
      // do something custom with your user data and or key value
   }
   PTREEROOT tree = CreateBinaryTreeExtended( 0 // BT_OPT_NODUPLICATES
                                            , MyGenericCompare
                                            , MyGenericDestroy
                                            <link DBG_PASS, DBG_SRC> );
   </code>
   See Also
   <link CreateBinaryTreeExx>
   <link CreateBinaryTreeEx>
   <link CreateBinaryTree>                                               */
TYPELIB_PROC  PTREEROOT TYPELIB_CALLTYPE  CreateBinaryTreeExtended( uint32_t flags
															, GenericCompare Compare
															, GenericDestroy Destroy DBG_PASS);
/* This is the simpler case of <link CreateBinaryTreeExtended>,
   which does not make you pass DBG_SRC.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTreeExx( BT_OPT_NODUPLICATES, NULL, NULL );
   </code>                                                                  */
#define CreateBinaryTreeExx(flags,compare,destroy) CreateBinaryTreeExtended(flags,compare,destroy DBG_SRC)
/* Creates a binary tree, allowing specification of comparison
   and destruction routines.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTreeEx( <link CreateBinaryTreeExtended, MyGenericCompare>, <link CreateBinaryTreeExtended, MyGenericDestroy> );
   </code>                                                                                                                                      */
#define CreateBinaryTreeEx(compare,destroy) CreateBinaryTreeExx( 0, compare, destroy )
/* This is the simplest way to create a binary tree.
   The default compare routine treats 'key' as an integer value
   that is compared against other for lesser/greater condition.
   This tree also allows duplicates to be added.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   </code>                                                      */
#define CreateBinaryTree() CreateBinaryTreeEx( NULL, NULL )
/* \ \
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   DestroyBinaryTree( tree );
   tree = NULL;
   </code>                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DestroyBinaryTree( PTREEROOT root );
/* Drops all the nodes in a tree so it becomes empty...
   \ \
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   ResetBinaryTree( tree );
   tree = NULL;
   </code>                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  ResetBinaryTree( PTREEROOT root );
/* Balances a binary tree. If data is added to a binary list in
   a linear way (from least to most), the tree can become
   unbalanced, and all be on the left or right side of data. This
   routine can analyze branches and perform rotations so that
   the tree can be discretely rebalanced.
   Example
   <code lang="c++">
   <link PTREEROOT> tree;
   // <link AddBinaryNode>...
   BalanceBinaryTree( tree );
   </code>                                                        */
TYPELIB_PROC  void TYPELIB_CALLTYPE  BalanceBinaryTree( PTREEROOT root );
/* \ \
   See Also
   <link AddBinaryNode>
   <link DBG_PASS>
                        */
TYPELIB_PROC  int TYPELIB_CALLTYPE  AddBinaryNodeEx( PTREEROOT root
                                                   , CPOINTER userdata
                                                   , uintptr_t key DBG_PASS );
/* Adds a user pointer identified by key to a binary list.
   See Also
   <link BinaryTree::CreateBinaryTree, CreateBinaryTree>
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   uintptr_t key = 1;
   POINTER data = NewArray( TEXTCHAR, 32 );
   AddBinaryNode( tree, data, key );
   </code>
   Parameters
   root :  PTREEROOT binary tree instance.
   data :  POINTER to some user object.
   key :   uintptr_t a integer type which can be used to identify
           the data. (used to compare in the tree).<p /><p />If
           the user has specified a custom comparison routine in
           an extended CreateBinaryTree(), then this value might
           be a pointer to some other data. Often the thing used
           to key into a binary tree is a <link CTEXTSTR>.
   Returns
   The tree may be created with <link BT_OPT_NODUPLICATES>, in
   which case this will result FALSE if the key is found
   duplicated in the list. Otherwise this returns TRUE. if the
   root parameter is NULL, the result is FALSE.                  */
#define AddBinaryNode(r,u,k) AddBinaryNodeEx((r),(u),(k) DBG_SRC )
//TYPELIB_PROC  int TYPELIB_CALLTYPE  AddBinaryNode( PTREEROOT root
//                                    , POINTER userdata
//                                    , uintptr_t key );
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveBinaryNode( PTREEROOT root, POINTER use, uintptr_t key );
/* Search in a binary tree for the specified key.
   Returns
   user data POINTER if found, else NULL.
   Example
   <code lang="c++">
   PTREEROOT tree;
   void f( void )
   {
      CPOINTER mydata = FindInBinaryTree( tree, 5 );
      if( mydata )
      {
          // found '5' as the key in the tree
      }
   }
   </code>                                          */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  FindInBinaryTree( PTREEROOT root, uintptr_t key );
// result of fuzzy routine is 0 = match.  100 = inexact match
// 1 = no match, actual may be larger
// -1 = no match, actual may be lesser
// 100 = inexact match- checks nodes near for better match.
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  LocateInBinaryTree( PTREEROOT root, uintptr_t key
														, int (CPROC*fuzzy)( uintptr_t psv, uintptr_t node_key ) );
/* During FindInBinaryTree and LocateInBinaryTree, the last
   found result is stored. This function allows deletion of that
   node.
   Example
   <code lang="c++">
   FindInBinaryTree( tree, 5 );
   RemoveLastFoundNode( tree );
   </code>                                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveLastFoundNode(PTREEROOT root );
/* Removes the currently browsed node from the tree.
   See Also
   <link GetChildNode>                               */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveCurrentNode(PTREEROOT root );
/* Basically this is meant to dump to a log, if the print
   function is passed as NULL, then the tree's contents are
   dumped to the log. It dumps a very cryptic log of how all
   nodes in the tree are arranged. But by allowing the user to
   provide a method to log his data and key, the logging is more
   meaningful based on the application. The basic code for
   managing trees and nodes works....
   Example
   <code>
   int ForEachNode( POINTER user, uintptr_t key )
   {
       // return not 1 to dump to log the internal tree structure
       return 0; // probably did own logging here, so don't log tree internal
   }
   <link PTREEROOT> tree;
   void f( void )
   {
       DumpTree( tree, ForEachNode );
   }
   </code>                                                                    */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DumpTree( PTREEROOT root
                          , int (*Dump)( CPOINTER user, uintptr_t key ) );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLeastNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLeastNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreatestNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreatestNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLesserNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLesserNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreaterNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreaterNode( PTREEROOT root );
/* \Returns the node that is set as 'current' in the tree. There
   is a cursor within the tree that can be used for browsing.
   See Also
   <link GetChildNode>                                           */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetCurrentNodeEx( PTREEROOT root, POINTER *cursor );
/* \Returns the node that is set as 'current' in the tree. There
   is a cursor within the tree that can be used for browsing.
   See Also
   <link GetChildNode>                                           */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetCurrentNode( PTREEROOT root );
/* This sets the current node cursor to the root of the node.
   See Also
   <link GetChildNode>                                        */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetRootNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetParentNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetParentNode( PTREEROOT root );
/* While browsing the tree after a find operation move to the
   next child node, direction 0 is lesser direction !0 is
   greater.
   Binary Trees have a 'current' cursor. These operations may be
   used to browse the tree.
   Example
   \ \
   <code>
   // this assumes you have a tree, and it's fairly populated, then this demonstrates
   // all steps of browsing.
   POINTER my_data;
   // go to the 'leftmost' least node. (as determined by the compare callback)
   my_data = GetLeastNode( tree );
   // go to the 'rightmost' greatest node. (as determined by the compare callback)
   my_data = GetGreatestNode( tree );
   // move to the node that is less than the current node.  (move to the 'left')
   my_data = GetLesserNode( tree );
   // move to the node that is greater than the current node.  (move to the 'right')
   my_data = GetGreaterNode( tree );
   // follow the tree to the left down from here
   my_data = GetChildNode( tree, 0 );
   // follow the tree to the right down from here
   my_data = GetChildNode( tree, 1 );
   // follow the tree up to the node above the current one.
   //  (the one who's lesser or greater points at this)
   my_data = GetParentNode( tree );
   // this is probably the least useful, but someone clever might find a trick for it
   // Move back to the node we were just at.
   //  (makes the current the prior, and moves to what the prior was,
   //     but then it's just back and forth between the last two; it's not a stack ).
   my_data = GetPriorNode( tree );
   </code>
   A more practical example...
   <code lang="c++">
   POINTER my_data;
   for( my_data = GetLeastNode( tree );
        my_data;
        my_data = GetGreaterNode( tree ) )
   {
        // browse the tree from least to most.
   }
   </code>                                                                            */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetChildNode( PTREEROOT root, int direction );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetChildNodeEx( PTREEROOT root, POINTER *cursor, int direction );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetPriorNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetPriorNode( PTREEROOT root );
/* \Returns the total number of nodes in the tree.
   Example
   <code lang="c++">
   int total_nodes = GetNodeCount(tree);
   </code>                                         */
TYPELIB_PROC  int TYPELIB_CALLTYPE  GetNodeCount ( PTREEROOT root );
 // returns a shadow of the original.
TYPELIB_PROC  PTREEROOT TYPELIB_CALLTYPE  ShadowBinaryTree( PTREEROOT root );
#ifdef __cplusplus
 //namespace BinaryTree {
	}
#endif
//--------------------------------------------------------------------------
#ifdef __cplusplus
namespace family {
#endif
/* A family tree structure, for tracking elements that have
   multiple children.
                                                            */
typedef struct familyroot_tag *PFAMILYTREE;
typedef struct familynode_tag *PFAMILYNODE;
/* <unfinished>
   Incomplete Work in progress (maybe) */
TYPELIB_PROC  PFAMILYTREE TYPELIB_CALLTYPE  CreateFamilyTree ( int (CPROC *Compare)(uintptr_t key1, uintptr_t key2)
															, void (CPROC *Destroy)(POINTER user, uintptr_t key) );
/* <unfinished>
   Incomplete, Family tree was never completed. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE  FamilyTreeFindChild ( PFAMILYTREE root
														  , uintptr_t psvKey );
/* <unfinished>
   Incomplete, Family tree was never completed. */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE FamilyTreeFindChildEx ( PFAMILYTREE root, PFAMILYNODE root_node
													 , uintptr_t psvKey );
/* Resets the search cursors in the tree... */
TYPELIB_PROC  void TYPELIB_CALLTYPE  FamilyTreeReset ( PFAMILYTREE *option_tree );
/* Resets the content of the tree (should call destroy methods, at this time it does not) */
TYPELIB_PROC  void TYPELIB_CALLTYPE  FamilyTreeClear ( PFAMILYTREE option_tree );
/* <unfinished>
   Incomplete Work in progress (maybe) */
TYPELIB_PROC  PFAMILYNODE TYPELIB_CALLTYPE  FamilyTreeAddChild ( PFAMILYTREE *root, PFAMILYNODE parent, POINTER userdata, uintptr_t key );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE FamilyTreeForEachChild( PFAMILYTREE root, PFAMILYNODE node
			, LOGICAL (CPROC *ProcessNode)( uintptr_t psvForeach, uintptr_t psvNodeData )
			, uintptr_t psvUserData );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE FamilyTreeForEach( PFAMILYTREE root, PFAMILYNODE node
			, LOGICAL (CPROC *ProcessNode)( uintptr_t psvForeach, uintptr_t psvNodeData, int level )
			, uintptr_t psvUserData );
#ifdef __cplusplus
 //namespace family {
}
#endif
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
#ifdef __cplusplus
//} // extern "c"
 // namespace containers
}
 // namespace sack
}
using namespace sack::containers::link_stack;
using namespace sack::containers::data_stack;
using namespace sack::containers::data_list;
using namespace sack::containers::data_queue;
using namespace sack::containers::queue;
using namespace sack::containers::BinaryTree;
using namespace sack::containers::text;
using namespace sack::containers::message;
using namespace sack::containers::sets;
using namespace sack::containers::family;
using namespace sack::containers;
#else
// should 'class'ify these things....
#endif
#ifndef _TYPELIBRARY_SOURCE
//#undef TYPELIB_PROC // we don't need this symbol after having built the right prototypes
#endif
#endif
// $Log: sack_typelib.h,v $
// Revision 1.99  2005/07/10 23:56:25  d3x0r
// Fix types for C++...
//
//
// Revision 1.39  2003/03/25 08:38:11  panther
// Add logging
//
SACK_NAMESPACE
#ifndef IS_DEADSTART
// this is always statically linked with libraries, so they may contact their
// core executable to know when it's done loading everyone else also...
#  ifdef __cplusplus
extern "C"
#  endif
#  if defined( WIN32 ) && !defined( __STATIC__ ) && !defined( __ANDROID__ )
#    ifdef __NO_WIN32API__
// DllImportAttribute ?
#    else
__declspec(dllimport)
#    endif
#  else
#ifndef __cplusplus
extern
#endif
#  endif
/* a function true/false which indicates whether the root
   deadstart has been invoked already. If not, one should call
   InvokeDeadstart and MarkDeadstartComplete.
   <code lang="c++">
   int main( )
   {
       if( !is_deadstart_complete() )
       {
           InvokeDeadstart();
           MarkDeadstartComplete()
       }
       ... your code here ....
       return 0;  // or some other appropriate return.
   }
   </code>
   sack::app::deadstart                                        */
LOGICAL
#  if defined( __WATCOMC__ )
__cdecl
#  endif
is_deadstart_complete( void );
#endif
/* Define a routine to call for exit().  This triggers specific code to handle shutdown event registration */
#ifndef NO_EXPORTS
#  ifdef SACK_BAG_CORE_EXPORTS
EXPORT_METHOD
#  else
IMPORT_METHOD
#  endif
#else
#  ifndef SACK_BAG_CORE_EXPORTS
	extern
#  endif
#endif
		void CPROC BAG_Exit( int code );
#ifndef NO_SACK_EXIT_OVERRIDE
#define exit(n) BAG_Exit(n)
#endif
 // namespace sack {
SACK_NAMESPACE_END
// this should become common to all libraries and programs...
//#include <construct.h> // pronounced 'kahn-struct'
/*
 *  Crafted by James Buckeyne
 *  Part of SACK github.com/d3x0r/SACK
 *
 *   (c) Freedom Collective 2000-2006++, 2016++
 *
 *   created to provide standard logging features
 *   lprintf( format, ... ); simple, basic
 *   if DEBUG, then logs to a file of the same name as the program
 *   if RELEASE most of this logging goes away at compile time.
 *
 *  standardized to never use int.
 */
#ifndef LOGGING_MACROS_DEFINED
#define LOGGING_MACROS_DEFINED
#define SYSLOG_API CPROC
#ifdef SYSLOG_SOURCE
#define SYSLOG_PROC EXPORT_METHOD
#else
#define SYSLOG_PROC IMPORT_METHOD
#endif
#ifdef __cplusplus
#define LOGGING_NAMESPACE namespace sack { namespace logging {
#define LOGGING_NAMESPACE_END } }
#else
#define LOGGING_NAMESPACE
#define LOGGING_NAMESPACE_END
#endif
#ifdef __cplusplus
	namespace sack {
/* Handles log output. Logs can be directed to UDP directed, or
   broadcast, or localhost, or to a file location, and under
   windows the debugging console log.
   lprintf
   SetSystemLog
   SystemLogTime
   there are options, when options code is enabled, which
   control logging output and format. Log file location can be
   specified generically for instance.... see Options.
	This namespace contains the logging functions. The most basic
   thing you can do to start logging is use 'lprintf'.
   <code lang="c++">
   lprintf( "My printf like format %s %d times", "string", 15 );
   </code>
   This function takes a format string and arguments compatible
   with vsnprintf. Internally strings are truncated to 4k
   length. (that is no single logging message can be more than
   4k in length).
   There are functions to control logging behavior.
   See Also
   SetSystemLog
   SystemLogTime
   SystemLogOptions
   lprintf
   _lprintf
   xlprintf
   _xlprintf
                                                                 */
		namespace logging {
#endif
/* \Parameters for SetSystemLog() to specify where the logging
   should go.                                                  */
enum syslog_types {
 // disable any log output.
SYSLOG_NONE     =   -1
,
SYSLOG_UDP      =    0
,
SYSLOG_FILE     =    1
,
 /* Set logging to output to a file. The file passed is a FILE*. This
   may be a FILE* like stdout, stderr, or some file the
   application opens.                                                */
SYSLOG_FILENAME =    2
,
 /* Set logging to go to a file, pass the string text name of the
   \file to open as the second parameter of SetSystemLog.        */
SYSLOG_SYSTEM   =    3
,
 /* Specify that logging should go to system (this actually means
   Windows system debugging channel. OutputDebugString() ).      */
SYSLOG_UDPBROADCAST= 4
// Allow user to specify a void UserCallback( char * )
// which recieves the formatted output.
,
SYSLOG_CALLBACK    = 5
,
 /* Send Logging to a specified user callback to handle. This
   lets logging go anywhere else that's not already thought of. */
SYSLOG_AUTO_FILE = SYSLOG_FILE + 100
 /* Send logging to a file. If the file is not open, open the
   \file. If no logging happens, no log file is created.     */
,
SYSLOG_SOCKET_SYSLOGD
};
#if !defined( NO_LOGGING )
#define DO_LOGGING
#endif
// this was forced, force no_logging off...
#if defined( DO_LOGGING )
#undef NO_LOGGING
#endif
#ifdef __LINUX__
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
SYSLOG_PROC  LOGICAL SYSLOG_API  IsBadReadPtr ( CPOINTER pointer, uintptr_t len );
#endif
SYSLOG_PROC  CTEXTSTR SYSLOG_API  GetPackedTime ( void );
//  returns the millisecond of the day (since UNIX Epoch) * 256 ( << 8 )
// the lowest 8 bits are the timezone / 15.
// The effect of the low [7/]8 bits being the time zone is that within the same millisecond
// UTC +0 sorts first, followed by +1, +2, ... etc until -14, -13, -12,... -1
// the low [7/]8 bits are the signed timezone
// (timezone could have been either be hr*60 + min (ISO TZ format)
// or in minutes (hr*60+mn) this would only take 7 bits
// one would think 8 bit shifts would be slightly more efficient than 7 bits.
// and sign extension for 8 bits already exists.
// - REVISION - timezone with hr*100 does not divide by 15 cleanly.
//     The timezone is ( hour*60 + min ) / 15 which is a range from -56 to 48
//     minimal representation is 7 bits (0 - 127 or -64 - 63)
//     still keeping 8 bits for shifting, so the effective range is only -56 to 48 of -128 to 127
// struct time_of_day {
//    uint64_t epoch_milliseconds : 56;
//    int64_t timezone : 8; divided by 15... hours * 60 / 15
// }
SYSLOG_PROC  int64_t SYSLOG_API GetTimeOfDay( void );
// binary little endian order; somewhat
typedef struct sack_expanded_time_tag
{
	uint16_t ms;
	uint8_t sc,mn,hr,dy,mo;
	uint16_t yr;
	int8_t zhr, zmn;
} SACK_TIME;
typedef struct sack_expanded_time_tag *PSACK_TIME;
// convert a integer time value to an expanded structure.
SYSLOG_PROC void     SYSLOG_API ConvertTickToTime( int64_t, PSACK_TIME st );
// convert a expanded time structure to a integer value.
SYSLOG_PROC int64_t SYSLOG_API ConvertTimeToTick( PSACK_TIME st );
// returns timezone as hours*100 + minutes.
// result is often negated?
SYSLOG_PROC  int SYSLOG_API GetTimeZone(void);
//
typedef void (CPROC*UserLoggingCallback)( CTEXTSTR log_string );
SYSLOG_PROC  void SYSLOG_API  SetSystemLog ( enum syslog_types type, const void *data );
SYSLOG_PROC  void SYSLOG_API  ProtectLoggedFilenames ( LOGICAL bEnable );
SYSLOG_PROC  void SYSLOG_API  SystemLogFL ( CTEXTSTR FILELINE_PASS );
SYSLOG_PROC  void SYSLOG_API  SystemLogEx ( CTEXTSTR DBG_PASS );
SYSLOG_PROC  void SYSLOG_API  SystemLog ( CTEXTSTR );
SYSLOG_PROC  void SYSLOG_API  LogBinaryFL ( const uint8_t* buffer, size_t size FILELINE_PASS );
SYSLOG_PROC  void SYSLOG_API  LogBinaryEx ( const uint8_t* buffer, size_t size DBG_PASS );
SYSLOG_PROC  void SYSLOG_API  LogBinary ( const uint8_t* buffer, size_t size );
// logging level defaults to 1000 which is log everything
SYSLOG_PROC  void SYSLOG_API  SetSystemLoggingLevel ( uint32_t nLevel );
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
/* Log a binary buffer. Logs lines representing 16 bytes of data
   at a time. The hex of each byte in a buffer followed by the
   text is logged.
   Example
   <code lang="c#">
   char sample[] = "sample string";
   LogBinary( sample, sizeof( sample ) );
   </code>
   Results with the following output in the log...
   <code>
    73 61 6D 70 6C 65 20 73 74 72 69 6E 67 00 sample string.
   </code>
   The '.' at the end of 'sample string' is a non printable
   character. characters 0-31 and 127+ are printed as '.'.       */
#define LogBinary(buf,sz) LogBinaryFL((uint8_t*)(buf),sz DBG_SRC )
#define SystemLog(buf)    SystemLogFL(buf DBG_SRC )
#else
// need to include the typecast... binary logging doesn't really care what sort of pointer it gets.
#define LogBinary(buf,sz) LogBinary((uint8_t*)(buf),sz )
//#define LogBinaryEx(buf,sz,...) LogBinaryFL(buf,sz FILELINE_NULL)
//#define SystemLogEx(buf,...) SystemLogFL(buf FILELINE_NULL )
#endif
// int result is useless... but allows this to be
// within expressions, which with this method should be easy.
typedef INDEX (CPROC*RealVLogFunction)(CTEXTSTR format, va_list args )
//#if defined( __GNUC__ )
//	__attribute__ ((__format__ (__vprintf__, 1, 2)))
//#endif
	;
typedef INDEX (CPROC*RealLogFunction)(CTEXTSTR format,...)
#if defined( __GNUC__ )
	__attribute__ ((__format__ (__printf__, 1, 2)))
#endif
	;
SYSLOG_PROC  RealVLogFunction SYSLOG_API  _vxlprintf ( uint32_t level DBG_PASS );
SYSLOG_PROC  RealLogFunction SYSLOG_API  _xlprintf ( uint32_t level DBG_PASS );
// utility function to format a cpu delta into a buffer...
// end-start is always printed... therefore tick_end-0 is
// print absolute time... formats as millisecond.NNN
SYSLOG_PROC  void SYSLOG_API  PrintCPUDelta ( TEXTCHAR *buffer, size_t buflen, uint64_t tick_start, uint64_t tick_end );
// return the current CPU tick
SYSLOG_PROC  uint64_t SYSLOG_API  GetCPUTick ( void );
// result in nano seconds - thousanths of a millisecond...
SYSLOG_PROC  uint32_t SYSLOG_API  ConvertTickToMicrosecond ( uint64_t tick );
SYSLOG_PROC  uint64_t SYSLOG_API  GetCPUFrequency ( void );
SYSLOG_PROC  CTEXTSTR SYSLOG_API  GetTimeEx ( int bUseDay );
SYSLOG_PROC  void SYSLOG_API  SetSyslogOptions ( FLAGSETTYPE *options );
/* When setting options using SetSyslogOptions() these are the
   defines for the bits passed.
   SYSLOG_OPT_OPENAPPEND - the file, when opened, will be opened
   for append.
   SYSLOG_OPT_OPEN_BACKUP - the file, if it exists, will be
   renamed automatically.
   SYSLOG_OPT_LOG_PROGRAM_NAME - enable logging the program
   executable (probably the same for all messages, unless they
   are network)
   SYSLOG_OPT_LOG_THREAD_ID - enables logging the unique process
   and thread ID.
   SYSLOG_OPT_LOG_SOURCE_FILE - enable logging source file
   information. See <link DBG_PASS>
   SYSLOG_OPT_MAX - used for declaring a flagset to pass to
   setoptions.                                                   */
enum system_logging_option_list {
		/* the file, when opened, will be opened for append.
		 */
		SYSLOG_OPT_OPENAPPEND
										  ,
  /* the file, if it exists, will be renamed automatically.
										  */
										  SYSLOG_OPT_OPEN_BACKUP
                                ,
 /* enable logging the program executable (probably the same for
                                   all messages, unless they are network)
                                                                                                */
                                 SYSLOG_OPT_LOG_PROGRAM_NAME
										  ,
 /* enables logging the unique process and thread ID.
										                                                       */
                                 SYSLOG_OPT_LOG_THREAD_ID
                                ,
 /* enable logging source file information. See <link DBG_PASS>
                                                                                               */
										   SYSLOG_OPT_LOG_SOURCE_FILE
										  ,
										  SYSLOG_OPT_MAX
};
// this solution was developed to provide the same
// functionality for compilers that refuse to implement __VA_ARGS__
// this therefore means that the leader of the function is replace
// and that extra parenthesis exist after this... therefore the remaining
// expression must be ignored... thereofre when defining a NULL function
// this will result in other warnings, about ignored, or meaningless expressions
# if defined( DO_LOGGING )
#  define vlprintf      _vxlprintf(LOG_NOISE DBG_SRC)
#  define lprintf       _xlprintf(LOG_NOISE DBG_SRC)
#  define _lprintf(file_line,...)       _xlprintf(LOG_NOISE file_line,##__VA_ARGS__)
#  define xlprintf(level)       _xlprintf(level DBG_SRC)
#  define vxlprintf(level)       _vxlprintf(level DBG_SRC)
# else
#  ifdef _MSC_VER
#   define vlprintf      (1)?(0):
#   define lprintf       (1)?(0):
#   define _lprintf(DBG_VOIDRELAY)       (1)?(0):
#   define xlprintf(level)       (1)?(0):
#   define vxlprintf(level)      (1)?(0):
#  else
#   define vlprintf(f,...)
/* use printf formating to output to the log. (log printf).
   Parameters
   Format :  Just like printf, the format string to print.
   ... :     extra arguments passed as required for the format.
   Example
   <code lang="c++">
      lprintf( "Test Logging %d %d", 13, __LINE__ );
   </code>                                                      */
#   define lprintf(f,...)
#   define  _lprintf(DBG_VOIDRELAY)       lprintf
#   define xlprintf(level) lprintf
#   define vxlprintf(level) lprintf
#  endif
# endif
#undef LOG_WARNING
#undef LOG_ADVISORIES
#undef LOG_INFO
// Defined Logging Levels
enum {
	  // and you are free to use any numerical value,
	  // this is a rough guideline for wide range
	  // to provide a good scaling for levels of logging
 // unless logging is disabled, this will be logged
	LOG_ALWAYS = 1
 // logging level set to 50 or more will cause this to log
	, LOG_ERRORS = 50
	,
 /* Specify a logging level which only ERROR level logging is
	   logged.                                                   */
 // logging level set to 50 or more will cause this to log
	 LOG_ERROR = LOG_ERRORS
	,
 // .......
	 LOG_WARNINGS = 500
	,
 // .......
	 LOG_WARNING = LOG_WARNINGS
   ,
 /* Use to specify that the log message is a warning level
      message.                                               */
    LOG_ADVISORY = 625
   ,
    LOG_ADVISORIES = LOG_ADVISORY
	,
 /* A symbol to specify to log Adviseries, Warnings and Error
	   level messages only.                                      */
	 LOG_INFO = 750
	  ,
 /* A moderate logging level, which is near maximum verbosity of
	     logging.                                                     */
	   LOG_NOISE = 1000
     ,
 /* Define that the message is just noisy - though verbosly
	  informative, it's level is less critical than even INFO.
	  default iS LOG_NOISE which is 1000, an ddefault for disabling most messages
	  is to set log level to 999.  Have to increase to 2000 to see debug, and this name
     has beviously
	  */
      LOG_LEVEL_DEBUG = 2000
	,
 /* Specify the message is of DEBUG importance, which is far
	   above even NOISY. If debug logging is enabled, all logging,
	   ERROR, WARNING, ADVISORY, INFO, NOISY and DEBUG will be
	   logged.                                                     */
 // not quite a negative number, but really big
	 LOG_CUSTOM = 0x40000000
	,
 /* A bit with LOG_CUSTOM might be enabled, and the lower bits
	   under 0x40000000 (all bits 0x3FFFFFFF ) can be used to
	   indicate a logging type. Then SetLoggingLevel can be passed a
	   mask of bits to filter types of messages.                     */
 // not quite a negative number, but really big
	 LOG_CUSTOM_DISABLE = 0x20000000
	// bits may be user specified or'ed with this value
	// such that ...
	// Example 1:SetSystemLoggingLevel( LOG_CUSTOM | 1 ) will
	// enable custom logging messages which have the '1' bit on... a logical
	// and is used to test the low bits of this value.
	// example 2:SetSystemLogging( LOG_CUSTOM_DISABLE | 1 ) will disable logging
	// of messages with the 1 bit set.
  // mask of bits which may be used to enable and disable custom logging
#define LOG_CUSTOM_BITS 0xFFFFFF
};
 // this is a flag set consisting of 0 or more or'ed symbols
enum SyslogTimeSpecifications {
 // disable time logging
 SYSLOG_TIME_DISABLE = 0,
 // enable is anything not zero.
 SYSLOG_TIME_ENABLE  = 1,
 // specify to log milliseconds
 SYSLOG_TIME_HIGH    = 2,
 // log the year/month/day also
 SYSLOG_TIME_LOG_DAY = 4,
 // log the difference in time instead of the absolute time
 SYSLOG_TIME_DELTA   = 8,
 // logs cpu ticks... implied delta
 SYSLOG_TIME_CPU     =16
};
/* Specify how time is logged. */
SYSLOG_PROC void SYSLOG_API SystemLogTime( uint32_t enable );
#ifndef NO_LOGGING
#define OutputLogString(s) SystemLog(s)
/* Depricated. Logs a format string that takes 0 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log(s)                                   SystemLog( s )
#else
#define OutputLogString(s)
/* Depricated. Logs a format string that takes 0 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log(s)
#endif
/* Depricated. Logs a format string that takes 1 parameter.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log1(s,p1)                               lprintf( s, p1 )
/* Depricated. Logs a format string that takes 2 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log2(s,p1,p2)                            lprintf( s, p1, p2 )
/* Depricated. Logs a format string that takes 3 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log3(s,p1,p2,p3)                         lprintf( s, p1, p2, p3 )
/* Depricated. Logs a format string that takes 4 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log4(s,p1,p2,p3,p4)                      lprintf( s, p1, p2, p3,p4)
/* Depricated. Logs a format string that takes 5 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log5(s,p1,p2,p3,p4,p5)                   lprintf( s, p1, p2, p3,p4,p5)
/* Depricated. Logs a format string that takes 6 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log6(s,p1,p2,p3,p4,p5,p6)                lprintf( s, p1, p2, p3,p4,p5,p6)
/* Depricated. Logs a format string that takes 7 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log7(s,p1,p2,p3,p4,p5,p6,p7)             lprintf( s, p1, p2, p3,p4,p5,p6,p7 )
/* Depricated. Logs a format string that takes 8 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log8(s,p1,p2,p3,p4,p5,p6,p7,p8)          lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8 )
/* Depricated. Logs a format string that takes 9 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log9(s,p1,p2,p3,p4,p5,p6,p7,p8,p9)       lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8,p9 )
/* Depricated. Logs a format string that takes 10 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log10(s,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10)  lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8,p9,p10 )
LOGGING_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::logging;
#endif
#endif
#if defined( _MSC_VER ) || (1)
// huh, apparently all compiles are messed the hell up.
#  define COMPILER_THROWS_SIGNED_UNSIGNED_MISMATCH
#endif
#ifdef COMPILER_THROWS_SIGNED_UNSIGNED_MISMATCH
#  define SUS_GT(a,at,b,bt)   (((a)<0)?0:(((bt)a)>(b)))
#  define USS_GT(a,at,b,bt)   (((b)<0)?1:((a)>((at)b)))
#  define SUS_LT(a,at,b,bt)   (((a)<0)?1:(((bt)a)<(b)))
#  define USS_LT(a,at,b,bt)   (((b)<0)?0:((a)<((at)b)))
#  define SUS_GTE(a,at,b,bt)  (((a)<0)?0:(((bt)a)>=(b)))
#  define USS_GTE(a,at,b,bt)  (((b)<0)?1:((a)>=((at)b)))
#  define SUS_LTE(a,at,b,bt)  (((a)<0)?1:(((bt)a)<=(b)))
#  define USS_LTE(a,at,b,bt)  (((b)<0)?0:((a)<=((at)b)))
#else
#  define SUS_GT(a,at,b,bt)   ((a)>(b))
#  define USS_GT(a,at,b,bt)   ((a)>(b))
#  define SUS_LT(a,at,b,bt)   ((a)<(b))
#  define USS_LT(a,at,b,bt)   ((a)<(b))
#  define SUS_GTE(a,at,b,bt)  ((a)>=(b))
#  define USS_GTE(a,at,b,bt)  ((a)>=(b))
#  define SUS_LTE(a,at,b,bt)  ((a)<=(b))
#  define USS_LTE(a,at,b,bt)  ((a)<=(b))
#endif
#ifdef __cplusplus
using namespace sack;
using namespace sack::containers;
#endif
#endif
#endif
// incldue this first so we avoid a conflict.
// hopefully this comes from sack system?
/*
 *  Created by Jim Buckeyne
 *
 *  Purpose
 *    Generalization of system routines which began in
 *   dekware development.
 *   - Process control (load,start,stop)
 *   - Library runtime link control (load, unload)
 *
 */
#ifndef SYSTEM_LIBRARY_DEFINED
#define SYSTEM_LIBRARY_DEFINED
#ifdef SYSTEM_SOURCE
#define SYSTEM_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SYSTEM_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __LINUX__
// Hmm I thought that dlopen resulted in an int...
// but this doc says void * (redhat9)
//typedef void *HLIBRARY;
#else
//typedef HMODULE HLIBRARY;
#endif
#ifdef __cplusplus
#define _SYSTEM_NAMESPACE namespace system {
#define _SYSTEM_NAMESPACE_END }
#else
#define _SYSTEM_NAMESPACE
#define _SYSTEM_NAMESPACE_END
#endif
#define SACK_SYSTEM_NAMESPACE SACK_NAMESPACE _SYSTEM_NAMESPACE
#define SACK_SYSTEM_NAMESPACE_END _SYSTEM_NAMESPACE_END SACK_NAMESPACE_END
#ifndef UNDER_CE
#define HAVE_ENVIRONMENT
#endif
SACK_NAMESPACE
	_SYSTEM_NAMESPACE
typedef struct task_info_tag *PTASK_INFO;
typedef void (CPROC*TaskEnd)(uintptr_t, PTASK_INFO task_ended);
typedef void (CPROC*TaskOutput)(uintptr_t, PTASK_INFO task, CTEXTSTR buffer, size_t size );
// Run a program completely detached from the current process
// it runs independantly.  Program does not suspend until it completes.
// Use GetTaskExitCode() to get the return code of the process
#define LPP_OPTION_DO_NOT_HIDE           1
// for services to launch normal processes (never got it to work; used to work in XP/NT?)
#define LPP_OPTION_IMPERSONATE_EXPLORER  2
#define LPP_OPTION_FIRST_ARG_IS_ARG      4
#define LPP_OPTION_NEW_GROUP             8
#define LPP_OPTION_NEW_CONSOLE          16
#define LPP_OPTION_SUSPEND              32
#define LPP_OPTION_ELEVATE              64
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgramExx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
                                               , int flags
                                               , TaskOutput OutputHandler
                                               , TaskEnd EndNotice
                                               , uintptr_t psv
                                                DBG_PASS
                                               );
SYSTEM_PROC( PTASK_INFO, LaunchProgramEx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args, TaskEnd EndNotice, uintptr_t psv );
// launch a process, program name (including leading path), a optional path to start in (defaults to
// current process' current working directory.  And a array of character pointers to args
// args should be the NULL.
SYSTEM_PROC( PTASK_INFO, LaunchProgram )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR  args );
// abort task, no kill signal, sigabort basically.  Use StopProgram for a more graceful terminate.
// if (!StopProgram(task)) TerminateProgram(task) would be appropriate.
SYSTEM_PROC( uintptr_t, TerminateProgram )( PTASK_INFO task );
SYSTEM_PROC( void, ResumeProgram )( PTASK_INFO task );
// get first address of program startup code(?) Maybe first byte of program code?
SYSTEM_PROC( uintptr_t, GetProgramAddress )( PTASK_INFO task );
// before luanchProgramEx, there was no userdata...
SYSTEM_PROC( void, SetProgramUserData )( PTASK_INFO task, uintptr_t psv );
// attempt to implement a method on windows that allows a service to launch a user process
// current systems don't have such methods
SYSTEM_PROC( void, ImpersonateInteractiveUser )( void );
// after launching a process should revert to a protected state.
SYSTEM_PROC( void, EndImpersonation )( void );
// generate a Ctrl-C to the task.
// maybe also signal systray icon
// maybe also signal process.lock region
// maybe end process?
// maybe then terminate process?
SYSTEM_PROC( LOGICAL, StopProgram )( PTASK_INFO task );
// ctextstr as its own type is a pointer so a
//  PcTextStr is a pointer to strings -
//   char ** - returns a quoted string if args have spaces (and escape quotes in args?)
SYSTEM_PROC( TEXTSTR, GetArgsString )( PCTEXTSTR pArgs );
// after a task has exited, this can return its code.
// undefined if task has not exited (probably 0)
SYSTEM_PROC( uint32_t, GetTaskExitCode )( PTASK_INFO task );
// returns the name of the executable that is this process (without last . extension   .exe for instance)
SYSTEM_PROC( CTEXTSTR, GetProgramName )( void );
// returns the path of the executable that is this process
SYSTEM_PROC( CTEXTSTR, GetProgramPath )( void );
// returns the path that was the working directory when the program started
SYSTEM_PROC( CTEXTSTR, GetStartupPath )( void );
// returns the path of the current sack library.
SYSTEM_PROC( CTEXTSTR, GetLibraryPath )( void );
// on windows, queries an event that indicates the system is rebooting.
SYSTEM_PROC( LOGICAL, IsSystemShuttingDown )( void );
// HandlePeerOutput is called whenever a peer task has generated output on stdout or stderr
//   - someday evolution may require processing stdout and stderr with different event handlers
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgramEx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
                                              , TaskOutput HandlePeerOutput
                                              , TaskEnd EndNotice
                                              , uintptr_t psv
                                               DBG_PASS
                                              );
#define LaunchPeerProgram(prog,path,args,out,end,psv) LaunchPeerProgramEx(prog,path,args,out,end,psv DBG_SRC)
SYSTEM_PROC( PTASK_INFO, SystemEx )( CTEXTSTR command_line
                                   , TaskOutput OutputHandler
                                   , uintptr_t psv
                                   DBG_PASS
                                   );
#define System(command_line,output_handler,user_data) SystemEx( command_line, output_handler, user_data DBG_SRC )
// generate output to a task... read by peer task on standard input pipe
// if a task has been opened with an output handler, than IO is trapped, and this is a method of
// sending output to a task.
SYSTEM_PROC( int, pprintf )( PTASK_INFO task, CTEXTSTR format, ... );
// if a task has been opened with an otuput handler, than IO is trapped, and this is a method of
// sending output to a task.
SYSTEM_PROC( int, vpprintf )( PTASK_INFO task, CTEXTSTR format, va_list args );
typedef void (CPROC*generic_function)(void);
SYSTEM_PROC( generic_function, LoadFunctionExx )( CTEXTSTR library, CTEXTSTR function, LOGICAL bPrivate DBG_PASS);
SYSTEM_PROC( generic_function, LoadFunctionEx )( CTEXTSTR library, CTEXTSTR function DBG_PASS);
SYSTEM_PROC( void *, GetPrivateModuleHandle )( CTEXTSTR libname );
/*
  Add a custom loaded library; attach a name to the DLL space; this should allow
  getcustomsybmol to resolve these
  */
SYSTEM_PROC( void, AddMappedLibrary )( CTEXTSTR libname, POINTER image_memory );
SYSTEM_PROC( LOGICAL, IsMappedLibrary )( CTEXTSTR libname );
SYSTEM_PROC( void, DeAttachThreadToLibraries )( LOGICAL attach );
#define LoadFunction(l,f) LoadFunctionEx(l,f DBG_SRC )
SYSTEM_PROC( generic_function, LoadPrivateFunctionEx )( CTEXTSTR libname, CTEXTSTR funcname DBG_PASS );
#define LoadPrivateFunction(l,f) LoadPrivateFunctionEx(l,f DBG_SRC )
#define OnLibraryLoad(name)	  DefineRegistryMethod("SACK",_OnLibraryLoad,"system/library","load_event",name "_LoadEvent",void,(void), __LINE__)
// the callback passed will be called during LoadLibrary to allow an external
// handler to download or extract the library; the resulting library should also
// be loaded by the callback using the standard 'LoadFunction' methods
SYSTEM_PROC( void, SetExternalLoadLibrary )( LOGICAL (CPROC*f)(const char *) );
// please Release or Deallocate the reutrn value
// the callback should search for the file specified, if required, download or extract it
// and then return with a Release'able utf-8 char *.
SYSTEM_PROC( void, SetExternalFindProgram )( char * (CPROC*f)(const char *) );
// override the default program name.
// Certain program wrappers might use this to change log location, configuration, etc other defaults.
SYSTEM_PROC( void, SetProgramName )( CTEXTSTR filename );
// this is a pointer pointer - being that generic_fucntion is
// a pointer...
SYSTEM_PROC( int, UnloadFunctionEx )( generic_function* DBG_PASS );
#ifdef HAVE_ENVIRONMENT
SYSTEM_PROC( CTEXTSTR, OSALOT_GetEnvironmentVariable )(CTEXTSTR name);
SYSTEM_PROC( void, OSALOT_SetEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
SYSTEM_PROC( void, OSALOT_AppendEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
SYSTEM_PROC( void, OSALOT_PrependEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
#endif
/* this needs to have 'GetCommandLine()' passed to it.
 * Otherwise, the command line needs to have the program name, and arguments passed in the string
 * the parameter to winmain has the program name skipped
 */
SYSTEM_PROC( void, ParseIntoArgs )( TEXTCHAR *lpCmdLine, int *pArgc, TEXTCHAR ***pArgv );
#define UnloadFunction(p) UnloadFunctionEx(p DBG_SRC )
/*
   Check if task spawning is allowed...
*/
SYSTEM_PROC( LOGICAL, sack_system_allow_spawn )( void );
/*
   Disallow task spawning.
*/
SYSTEM_PROC( void, sack_system_disallow_spawn )( void );
SACK_SYSTEM_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::system;
#endif
#endif
//----------------------------------------------------------------------
// $Log: system.h,v $
// Revision 1.14  2005/07/06 00:33:55  jim
// Fixes for all sorts of mangilng with the system.h header.
//
//
// Revision 1.2  2003/10/24 14:59:21  panther
// Added Load/Unload Function for system shared library abstraction
//
// Revision 1.1  2003/10/24 13:22:06  panther
// Initial commit
//
//
#if defined( _MSC_VER )|| defined(__LCC__) || defined( __WATCOMC__ ) || defined( __GNUC__ )
/* Includes networking as appropriate for the target platform. Providing
   compatibility definitions as are lacking between platforms...
   or perhaps appropriate name aliasing to the correct types.            */
#ifndef INCLUDED_SOCKET_LIBRARY
#define INCLUDED_SOCKET_LIBRARY
#if defined( _WIN32 ) || defined( __CYGWIN__ )
//#ifndef __cplusplus_cli
#ifdef UNDER_CE
#define USE_WSA_EVENTS
#endif
#include <winsock2.h>
#include <ws2tcpip.h>
#if defined( MINGW_SUX ) && ( __GNUC__ < 5 )
/* Address information */
typedef struct addrinfoA {
    int             ai_flags;
    int             ai_family;
    int             ai_socktype;
    int             ai_protocol;
    size_t          ai_addrlen;
    char            *ai_canonname;
    struct sockaddr *ai_addr;
    struct addrinfoA *ai_next;
} ADDRINFOA;
typedef ADDRINFOA   *PADDRINFOA;
typedef struct addrinfoW {
    int                 ai_flags;
    int                 ai_family;
    int                 ai_socktype;
    int                 ai_protocol;
    size_t              ai_addrlen;
    PWSTR               ai_canonname;
    struct sockaddr     *ai_addr;
    struct addrinfoW    *ai_next;
} ADDRINFOW;
typedef ADDRINFOW   *PADDRINFOW;
typedef ADDRINFOA   ADDRINFOT;
typedef ADDRINFOA   *PADDRINFOT;
typedef ADDRINFOA   ADDRINFO;
typedef ADDRINFOA   *LPADDRINFO;
#endif
#ifdef __CYGWIN__
// just need this simple symbol
typedef int socklen_t;
#endif
//#endif
#elif defined( __LINUX__ )
#if defined( FBSD )
#endif
 // INADDR_ANY/NONE
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#if !defined( _PNACL )
#  include <net/if.h>
#endif
#define SOCKET int
#define SOCKADDR struct sockaddr
#define SOCKET_ERROR -1
//#define HWND int // unused params...
#define WSAEWOULDBLOCK EAGAIN
#define INVALID_SOCKET -1
#define WSAAsynchSelect( a,b,c,d ) (0)
#define WSAGetLastError()  (errno)
#define closesocket(s) close(s)
typedef struct hostent *PHOSTENT;
#ifndef __LINUX__
#define INADDR_ANY (-1)
#define INADDR_NONE (0)
#endif
struct win_in_addr {
	union {
		struct { uint8_t s_b1,s_b2,s_b3,s_b4; } S_un_b;
		struct { uint16_t s_w1,s_w2; } S_un_w;
		uint32_t S_addr;
	} S_un;
#ifndef __ANDROID__
#define s_addr  S_un.S_addr
/* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
	/* host on imp */
#define s_net   S_un.S_un_b.s_b1
	/* network */
#define s_imp   S_un.S_un_w.s_w2
	/* imp */
#define s_impno S_un.S_un_b.s_b4
	/* imp # */
#define s_lh    S_un.S_un_b.s_b3
	/* logical host */
#endif
};
struct win_sockaddr_in {
#ifdef __MAC__
	uint8_t sa_len;
	uint8_t sin_family;
#else
	short   sin_family;
#endif
	uint16_t sin_port;
	struct  win_in_addr sin_addr;
	char    sin_zero[8];
};
typedef struct win_sockaddr_in SOCKADDR_IN;
#endif
#endif
// $Log: loadsock.h,v $
// Revision 1.7  2005/01/27 08:09:25  panther
// Linux cleaned.
//
// Revision 1.6  2003/06/04 11:38:01  panther
// Define PACKED
//
// Revision 1.5  2003/03/25 08:38:11  panther
// Add logging
//
#  if defined( __MAC__ )
#  else
               // _heapmin() included here
#    include <malloc.h>
#  endif
#else
//#include "loadsock.h"
#endif
//#include <stdlib.h>
#ifdef __CYGWIN__
 // provided by -lgcc
// lots of things end up including 'setjmp.h' which lacks sigset_t defined here.
// lots of things end up including 'setjmp.h' which lacks sigset_t defined here.
#  include <sys/signal.h>
#endif
// GetTickCount() and Sleep(n) Are typically considered to be defined by including stdhdrs...
/*
 *  Crafted by Jim Buckeyne
 *
 *  (c)2001-2006++ Freedom Collective
 *
 *  Provide API interface for timers, critical sections
 *  and other thread things.
 *
 */
#ifndef TIMERS_DEFINED
/* timers.h mutliple inclusion protection symbol. */
#define TIMERS_DEFINED
#if defined( _WIN32 )
// on windows, we add a function that returns HANDLE
#endif
#ifndef SHARED_MEM_DEFINED
/* Multiple inclusion protection symbol. */
#define SHARED_MEM_DEFINED
#if defined (_WIN32)
//#define USE_NATIVE_CRITICAL_SECTION
#endif
#if defined( _SHLWAPI_H ) || defined( _INC_SHLWAPI )
#undef StrChr
#undef StrCpy
#undef StrDup
#undef StrRChr
#undef StrStr
#endif
#if defined( __MAC__ )
#  define strdup(s) StrDup(s)
#  define strdup_free(s) Release(s)
#else
#  define strdup_free(s) free(s)
#endif
#ifdef __cplusplus
#define SACK_MEMORY_NAMESPACE SACK_NAMESPACE namespace memory {
#define SACK_MEMORY_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define SACK_MEMORY_NAMESPACE
#define SACK_MEMORY_NAMESPACE_END
#endif
/* A declaration of the call type for memory library routines. */
#define MEM_API CPROC
#    ifdef MEM_LIBRARY_SOURCE
#      define MEM_PROC EXPORT_METHOD
#    else
/* Defines library linkage specification. */
#      define MEM_PROC IMPORT_METHOD
#    endif
#ifndef TIMER_NAMESPACE
#ifdef __cplusplus
#define _TIMER_NAMESPACE namespace timers {
/* define a timer library namespace in C++. */
#define TIMER_NAMESPACE SACK_NAMESPACE namespace timers {
/* define a timer library namespace in C++ end. */
#define TIMER_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define TIMER_NAMESPACE
#define TIMER_NAMESPACE_END
#endif
#endif
	TIMER_NAMESPACE
   // enables file/line monitoring of sections and a lot of debuglogging
//#define DEBUG_CRITICAL_SECTIONS
   /* this symbol controls the logging in timers.c... (higher level interface to NoWait primatives)*/
//#define LOG_DEBUG_CRITICAL_SECTIONS
/* A custom implementation of windows CRITICAL_SECTION api.
   Provides same capability for Linux type systems. Can be
   checked as a study in how to implement safe locks.
   See Also
   InitCriticalSec
   EnterCriticalSec
   LeaveCriticalSec
   Example
   <c>For purposes of this example this is declared in global
   memory, known to initialize to all 0.</c>
   <code lang="c++">
   CRITICALSECTION cs_lock_test;
   </code>
   In some bit of code that can be executed by several
   threads...
   <code lang="c++">
   {
      EnterCriticalSec( &amp;cs_lock_test );
      // the code in here will only be run by a single thread
      LeaveCriticalSec( &amp;cs_lock_test );
   }
   </code>
   Remarks
   The __Ex versions of functions passes source file and line
   information in debug mode. This can be used if critical
   section debugging is turned on, or if critical section
   logging is turned on. (See ... ) This allows applications to
   find deadlocks by tracking who is entering critical sections
   and probably failing to leave them.                          */
struct critical_section_tag {
 // this is set when entering or leaving (updating)...
	uint32_t dwUpdating;
  // count of locks entered.  (only low 24 bits may count for 16M entries, upper bits indicate internal statuses.
	uint32_t dwLocks;
 // windows upper 16 is process ID, lower is thread ID
	THREAD_ID dwThreadID;
 // ID of thread waiting for this..
	THREAD_ID dwThreadWaiting;
#ifdef DEBUG_CRITICAL_SECTIONS
	// these are not included without a special compile flag
	// only required by low level deveopers who may be against
   // undefined behavior.
#define MAX_SECTION_LOG_QUEUE 16
	uint32_t bCollisions ;
	CTEXTSTR pFile[16];
	uint32_t  nLine[16];
	uint32_t  nLineCS[16];
 // windows upper 16 is process ID, lower is thread ID
	THREAD_ID dwThreadPrior[16];
 // windows upper 16 is process ID, lower is thread ID
	uint8_t isLock[16];
	int nPrior;
#endif
};
#if !defined( _WIN32 )
#undef USE_NATIVE_CRITICAL_SECTION
#endif
/* <combine sack::timers::critical_section_tag>
   \ \                                          */
#if defined( USE_NATIVE_CRITICAL_SECTION )
#define CRITICALSECTION CRITICAL_SECTION
#else
typedef struct critical_section_tag CRITICALSECTION;
#endif
/* <combine sack::timers::critical_section_tag>
   defines a pointer to a CRITICALSECTION type  */
#if defined( USE_NATIVE_CRITICAL_SECTION )
#define PCRITICALSECTION LPCRITICAL_SECTION
#else
#define InitializeCriticalSection InitializeCriticalSec
typedef struct critical_section_tag *PCRITICALSECTION;
#endif
/* attempts to enter the critical section, and does not block.
   Returns
   If it enters the return is 1, else the return is 0.
   Parameters
   pcs :    pointer to a critical section
   prior :  if not NULL, prior will be set to the current thread
            ID of the owning thread.                             */
#ifndef USE_NATIVE_CRITICAL_SECTION
MEM_PROC  int32_t MEM_API  EnterCriticalSecNoWaitEx ( PCRITICALSECTION pcs, THREAD_ID *prior DBG_PASS );
#define EnterCriticalSecNoWait( pcs,prior ) EnterCriticalSecNoWaitEx( pcs, prior DBG_SRC )
#else
#define EnterCriticalSecNoWait( pcs,prior ) TryEnterCriticalSection( (pcs) )
#endif
/* <combine sack::timers::EnterCriticalSecNoWaitEx@PCRITICALSECTION@THREAD_ID *prior>
   \ \                                                                                */
//#define EnterCriticalSecNoWait( pcs,prior ) EnterCriticalSecNoWaitEx( (pcs),(prior) DBG_SRC )
/* clears all members of a CRITICALSECTION.  Same as memset( pcs, 0, sizeof( CRITICALSECTION ) ); */
#ifndef USE_NATIVE_CRITICAL_SECTION
MEM_PROC  void MEM_API  InitializeCriticalSec ( PCRITICALSECTION pcs );
#else
#define InitializeCriticalSec(pcs)  InitializeCriticalSection(pcs)
#endif
/* Get a count of how many times a critical section is locked */
//MEM_PROC  uint32_t MEM_API  CriticalSecOwners ( PCRITICALSECTION pcs );
/* Namespace of all memory related functions for allocating and
   releasing memory.                                            */
#ifdef __cplusplus
 // namespace timers
}
 // namespace sack
}
using namespace sack::timers;
#endif
#ifdef __cplusplus
namespace sack {
/* Memory namespace contains functions for allocating and
   releasing memory. Also contains methods for accessing shared
   memory (if available on the target platform).
   Allocate
   Release
   Hold
   OpenSpace                                                    */
namespace memory {
#endif
typedef struct memory_block_tag* PMEM;
// what is an abstract name for the memory mapping handle...
// where is a filename for the filebacking of the shared memory
// DigSpace( "Picture Memory", "Picture.mem", 100000 );
/* <combinewith sack::memory::OpenSpaceExx@CTEXTSTR@CTEXTSTR@uintptr_t@uintptr_t *@uint32_t*>
   \ \                                                                                 */
MEM_PROC  POINTER MEM_API  OpenSpace ( CTEXTSTR pWhat, CTEXTSTR pWhere, size_t *dwSize );
/* <unfinished>
   Open a shared memory region. The region may be named with a
   text string (this does not work under linux platforms, and
   the name of the file to back the shared region is the sharing
   point). The region may be backed with a file (and must be if
   it is to be shared on linux.
   If the region exists by name, the region is opened, and a
   pointer to that region is returned.
   If the file exists, the file is opened, and mapped into
   memory, and a pointer to the file backed memory is returned.
   if the file does not exist, and the size parameter passed is
   not 0, then the file is created, and expanded to the size
   requested. The bCreate flag is set to true.
   If NULL is passed for pWhat and pWhere, then a block of
   memory is allocated in system memory, backed by pagefile.
   if dwSize is 0, then the region is specified for open only,
   and will not create.
   Parameters
   pWhat :     String to a named shared memory region. NULL is
               unnamed.
   pWhere :    Filename to back the shared memory with. The file
               name itself may also be used to share the memory.
   address :   A base address to map the memory at. If 0,
               specifies do not care.
   dwSize :    pointer to a uintptr_t that defines the size to
               create. If 0, then the region is only opened. The
               size of the region opened is set back into this
               value after it is opened.
   bCreated :  pointer to a boolean to indicate whether the space
               was created or not.
   Returns
   Pointer to region requested to be opened. NULL on failure.
   Example
   Many examples of this are appropriate.
   1) Open or create a file backed shared space.
   2) Open a file for direct memory access, the file is loaded
   into memory by system paging routines and not any API.         */
MEM_PROC  POINTER MEM_API  OpenSpaceExx ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t address
	, size_t *dwSize, uint32_t* bCreated );
/* <combine sack::memory::OpenSpaceExx@CTEXTSTR@CTEXTSTR@uintptr_t@uintptr_t *@uint32_t*>
   \ \                                                                             */
#define OpenSpaceEx( what,where,address,psize) OpenSpaceExx( what,where,address,psize,NULL )
/* Closes a shared memory region. Calls CloseSpaceEx() with
   bFinal set TRUE.
   Parameters
   pMem :  pointer to a memory region opened by OpenSpace.  */
MEM_PROC  void MEM_API  CloseSpace ( POINTER pMem );
/* Closes a memory region. Release can also be used to close
   opened spaces.
   Parameters
   pMem :    pointer to a memory region opened with OpenSpace()
   bFinal :  If final is set, the file used for backing the shared
             region is deleted.                                    */
MEM_PROC  void MEM_API  CloseSpaceEx ( POINTER pMem, int bFinal );
/* This can give the size back of a memory space.
   Returns
   The size of the memory block.
   Parameters
   pMem :  pointer to a block of memory that was opened with
           OpenSpace().                                      */
MEM_PROC  uintptr_t MEM_API  GetSpaceSize ( POINTER pMem );
/* even if pMem is just a POINTER returned from OpenSpace this
   will create a valid heap pointer.
   will result TRUE if a valid heap is present will result FALSE
   if heap is not able to init (has content)
   Parameters
   pMem :    pointer to a memory space to setup as a heap.
   dwSize :  size of the memory space pointed at by pMem.        */
MEM_PROC  int MEM_API  InitHeap( PMEM pMem, size_t dwSize );
/* Dumps all blocks into the log.
   Parameters
   pHeap :     Heap to dump. If NULL or unspecified, dump the
               default heap.
   bVerbose :  Specify to dump each block's information,
               otherwise only summary information is generated. */
MEM_PROC  void MEM_API  DebugDumpHeapMemEx ( PMEM pHeap, LOGICAL bVerbose );
/* <combine sack::memory::DebugDumpHeapMemEx@PMEM@LOGICAL>
   Logs all of the blocks tracked in a specific heap.
   Parameters
   Heap :  Heap to dump the memory blocks of.              */
#define DebugDumpHeapMem(h)     DebugDumpMemEx( (h), TRUE )
/* <combine sack::memory::DebugDumpHeapMemEx@PMEM@LOGICAL>
   \ \                                                     */
MEM_PROC  void MEM_API  DebugDumpMemEx ( LOGICAL bVerbose );
/* Dumps all tracked heaps.
   Parameters
   None.                    */
#define DebugDumpMem()     DebugDumpMemEx( TRUE )
/* Dumps a heap to a specific file.
   Parameters
   pHeap :      Heap. If NULL or unspecified, dumps default heap.
   pFilename :  name of the file to write output to.              */
MEM_PROC  void MEM_API  DebugDumpHeapMemFile ( PMEM pHeap, CTEXTSTR pFilename );
/* <combine sack::memory::DebugDumpHeapMemFile@PMEM@CTEXTSTR>
   \ \                                                        */
MEM_PROC  void MEM_API  DebugDumpMemFile ( CTEXTSTR pFilename );
#ifdef __GNUC__
MEM_PROC  POINTER MEM_API  HeapAllocateAlignedEx ( PMEM pHeap, size_t dwSize, uint16_t alignment DBG_PASS ) __attribute__( (malloc) );
MEM_PROC  POINTER MEM_API  HeapAllocateEx ( PMEM pHeap, uintptr_t nSize DBG_PASS ) __attribute__((malloc));
MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS ) __attribute__((malloc));
#else
/* \ \
   Parameters
   pHeap :  pointer to a heap which was initialized with
            InitHeap()
   Size :   Size of block to allocate                    */
MEM_PROC  POINTER MEM_API  HeapAllocateEx ( PMEM pHeap, uintptr_t nSize DBG_PASS );
/* \ Parameters
pHeap :  pointer to a heap which was initialized with
InitHeap()
Size :   Size of block to allocate
Alignment : count of bytes to return block on (1,2,4,8,16,32)  */
MEM_PROC  POINTER MEM_API  HeapAllocateAlignedEx( PMEM pHeap, uintptr_t nSize, uint16_t alignment DBG_PASS );
/* Allocates a block of memory of specific size. Debugging
   information if passed is recorded on the block.
   Parameters
   size :  size of the memory block to create              */
MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS );
#endif
/* A simple macro to allocate a new single unit of a structure. Adds
   a typecast automatically to be (type*) so C++ compilation is
   clean. Does not burden the user with extra typecasts. This,
   being in definition use means that all other things that are
   typecast are potentially error prone. Memory is considered
   uninitialized.
   Parameters
   type :  type to allocate
   Example
   <code lang="c++">
   int *p_int = New( int );
   </code>                                                           */
#define New(type) ((type*)HeapAllocate(0,sizeof(type)))
/* Reallocates an array of type.
   Parameters
   type :  type to use for sizeof(type) * sz for resulting size.
   p :     pointer to realloc
   sz :    count of elements in the array                        */
#define Renew(type,p,sz) ((type*)HeapReallocate(0,p, sizeof(type)*sz))
/* an advantage of C, can define extra space at end of structure
   which is allowed to carry extra data, which is unknown by
   other code room for exploits rock.
   Parameters
   type :   passed to sizeof()
   extra :  Number of additional bytes to allocate beyond the
            sizeof( type )
   Example
   Create a text segment plus 18 characters of data. (This
   should not be done, use SegCreate instead)
   <code lang="c#">
   PTEXT text = NewPlus( TEXT, 18 );
   </code>                                                       */
#define NewPlus(type,extra) ((type*)HeapAllocate(0,sizeof(type)+(extra)))
/* Allocate a new array of type.
   Parameters
   type :   type to determine size of array element to allocate.
   count :  count of elements to allocate in the array.
   Returns
   A pointer to type. (this is important, since in C++ it's cast
   correctly to the destination type).                           */
#define NewArray(type,count) ((type*)HeapAllocate(0,(uintptr_t)(sizeof(type)*(count))))
/* Allocate sizeof(type). Will invoke some sort of registered
   initializer
   Parameters
   type :  type to allocate for. Passes the name of the type so
           the allocator can do a registered procedure lookup and
           invok an initializer for the type.                     */
//#define NewObject(type) ((type*)FancyAllocate(sizeof(type),#type DBG_SRC))
#ifdef __cplusplus
/* A 'safe' release macro. casts the block to the type to
   release. Makes sure the pointer being released is the type
   specified.
   Parameters
   type :   type of the variable
   thing :  the thing to actually release.                    */
#  ifdef _DEBUG
#    define Deallocate(type,thing) for(type _zzqz_tmp=thing;ReleaseEx((POINTER)(_zzqz_tmp)DBG_SRC),0;)
#  else
#    define Deallocate(type,thing) ReleaseEx((POINTER)(thing)DBG_SRC)
#  endif
#else
#  define Deallocate(type,thing) (ReleaseEx((POINTER)(thing)DBG_SRC))
#endif
/* <combine sack::memory::HeapAllocateEx@PMEM@uintptr_t nSize>
   \ \                                                        */
#define HeapAllocate(heap, n) HeapAllocateEx( (heap), (n) DBG_SRC )
   /* <combine sack::memory::HeapAllocateAlignedEx@PMEM@uintptr_t@uint32_t>
   \ \                                                        */
#define HeapAllocateAligned(heap, n, m) HeapAllocateAlignedEx( (heap), (n), m DBG_SRC )
   /* <combine sack::memory::AllocateEx@uintptr_t nSize>
   \ \                                               */
#ifdef FIX_RELEASE_COM_COLLISION
#else
#define Allocate( n ) HeapAllocateEx( (PMEM)0, (n) DBG_SRC )
#endif
//MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS );
//#define Allocate(n) AllocateEx(n DBG_SRC )
MEM_PROC  POINTER MEM_API  GetFirstUsedBlock ( PMEM pHeap );
/* Releases an allocated block. Memory becomes free to allocate
   again. If debugging information is passed, the releasing
   source and line is recorded in the block. (can be used to
   find code deallocating memory it shouldn't).
   This also works with Hold(), and decrements the hold counter.
   If there are no more holds on the block, then the block is
   released.
   Parameters
   p :  pointer to allocated block to release.                   */
MEM_PROC  POINTER MEM_API  ReleaseEx ( POINTER pData DBG_PASS ) ;
/* <combine sack::memory::ReleaseEx@POINTER pData>
   \ \                                             */
#ifdef FIX_RELEASE_COM_COLLISION
#else
/* <combine sack::memory::ReleaseEx@POINTER pData>
   \ \                                             */
#define Release(p) ReleaseEx( (p) DBG_SRC )
#endif
/* Adds a usage count to a block of memory. For each count
   added, an additional release must be used. This can be used
   to keep a copy of the block, even if some other code
   automatically releases it.
   Parameters
   pointer :  pointer to a block of memory that was Allocate()'d.
   Example
   Allocate a block of memory, and release it properly. But we
   passed it to some function. That function wanted to keep a
   copy of the block, so it can apply a hold. It needs to later
   do a Release again to actually free the memory.
   <code lang="c++">
   POINTER p = Allocate( 32 );
   call_some_function( p );
   Release( p );
   void call_some_function( POINTER p )
   {
      static POINTER my_p_copy;
      my_p_copy = p;
      Hold( p );
   }
   </code>                                                        */
MEM_PROC  POINTER MEM_API  HoldEx ( POINTER pData DBG_PASS  );
/* <combine sack::memory::HoldEx@POINTER pData>
   \ \                                          */
#define Hold(p) HoldEx(p DBG_SRC )
/* This can be used to add additional space after the end of a
   memory block.
   Parameters
   pHeap :   If NULL or not specified, uses the common memory heap.
   source :  pointer to the block to pre\-allocate. If NULL, a new
             memory block will be allocated that is filled with 0.
   size :    the new size of the block.
   Returns
   A pointer to a new block of memory that is the new size.
   Remarks
   If the size specified for the new block is larger than the
   previous size of the block, the curernt data is copied to the
   beginning of the new block, and the memory after the existing
   content is cleared to 0.
   If the size specified for the new block is smaller than the
   previous size, the end of the original block is not copied to
   the new block.
   If NULL is passed as the source block, then a new block
   filled with 0 is created.                                        */
MEM_PROC  POINTER MEM_API  HeapReallocateAlignedEx ( PMEM pHeap, POINTER source, uintptr_t size, uint16_t alignment DBG_PASS );
MEM_PROC  POINTER MEM_API  HeapReallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::HeapReallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                 */
#define HeapReallocateAligned(heap,p,sz,al) HeapReallocateEx( (heap),(p),(sz),(al) DBG_SRC )
#define HeapReallocate(heap,p,sz) HeapReallocateEx( (heap),(p),(sz) DBG_SRC )
/* <combine sack::memory::HeapReallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                 */
MEM_PROC  POINTER MEM_API  ReallocateEx ( POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::ReallocateEx@POINTER@uintptr_t size>
   \ \                                                        */
#ifdef FIX_RELEASE_COM_COLLISION
#else
#define Reallocate(p,sz) ReallocateEx( (p),(sz) DBG_SRC )
#endif
/* This can be used to add additional space before the beginning
   of a memory block.
   Parameters
   pHeap :   If NULL or not specified, uses the common memory heap.
   source :  pointer to the block to pre\-allocate. If NULL, a new
             memory block will be allocated that is filled with 0.
   size :    the new size of the block.
   Returns
   A pointer to a new block of memory that is the new size.
   Remarks
   If the size specified for the new block is larger than the
   previous size of the block, the content data is copied to the
   end of the new block, and the memory leading up to the block
   is cleared to 0.
   If the size specified for the new block is smaller than the
   previous size, the end of the original block is not copied to
   the new block.
   If NULL is passed as the source block, then a new block
   filled with 0 is created.                                        */
MEM_PROC  POINTER MEM_API  HeapPreallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::HeapPreallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                  */
#define HeapPreallocate(heap,p,sz) HeapPreallocateEx( (heap),(p),(sz) DBG_SRC )
/* <combine sack::memory::HeapPreallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                  */
MEM_PROC  POINTER MEM_API  PreallocateAlignedEx ( POINTER source, uintptr_t size, uint16_t alignment DBG_PASS );
MEM_PROC  POINTER MEM_API  PreallocateEx ( POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::PreallocateEx@POINTER@uintptr_t size>
   \ \                                                         */
#define PreallocateAligned(p,sz,al) PreallocateAlignedEx( (p),(sz),(al) DBG_SRC )
#define Preallocate(p,sz) PreallocateEx( (p),(sz) DBG_SRC )
/* Moves a block of memory from one heap to another.
   Parameters
   pNewHeap :  heap target to move the block to.
   source :    source block to move \- pointer to the data in the
               block.
   Remarks
   Since each block remembers its own size, it is possible to
   move a block from one heap to another. A heap might be a
   memory mapped file at a specific address for instance.         */
MEM_PROC  POINTER MEM_API  HeapMoveEx ( PMEM pNewHeap, POINTER source DBG_PASS );
/* <combine sack::memory::HeapMoveEx@PMEM@POINTER source>
   \ \                                                    */
#define HeapMove(h,s) HeapMoveEx( (h), (s) DBG_SRC )
/* \returns the size of a memory block which was Allocate()'d.
   Parameters
   pData :  pointer to a allocated memory block.
   Returns
   The size of the block that was specified by the Allocate(). */
MEM_PROC uintptr_t MEM_API  SizeOfMemBlock ( CPOINTER pData );
/* \returns the allocation alignment of a memory block which was Allocate()'d.
Parameters
pData :  pointer to a allocated memory block.
Returns
The alignment of the block that was specified from Allocate(). */
MEM_PROC uint16_t  AlignOfMemBlock( CPOINTER pData );
/* not so much of a fragment as a consolidation. Finds a free
   spot earlier in the heap and attempts to move the block
   there. This can help alleviate heap fragmentation.
   Parameters
   ppMemory :  pointer to a pointer to memory which might move */
MEM_PROC  LOGICAL MEM_API  Defragment ( POINTER *ppMemory );
/* \ \
   Parameters
   pHeap :        pointer to a heap
   pFree :        pointer to a 32 bit value to receive the size
                  of free space
   pUsed :        pointer to a 32 bit value to receive the size
                  of used space
   pChunks :      pointer to a 32 bit value to receive the total
                  count of chunks.
   pFreeChunks :  pointer to a 32 bit value to receive the total
                  count of free chunks.
   Remarks
   It looks like DBG_PASS parameter isn't used... not sure why
   it would here, there is no allocate or delete.
   The count of allocated chunks can be gotten by subtracting
   FreeChunks from Chunks.
   Example
   <code lang="c++">
   uint32_t free;
   uint32_t used;
   uint32_t chunks;
   uint32_t free_chunks;
   GetHeapMemStatsEx( NULL, &amp;free, &amp;used, &amp;chunks, &amp;free_chunks );
   </code>                                                                         */
MEM_PROC  void MEM_API  GetHeapMemStatsEx ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks DBG_PASS );
/* <combine sack::memory::GetHeapMemStatsEx@PMEM@uint32_t *@uint32_t *@uint32_t *@uint32_t *pFreeChunks>
   \ \                                                                               */
#define GetHeapMemStats(h,f,u,c,fc) GetHeapMemStatsEx( h,f,u,c,fc DBG_SRC )
//MEM_PROC  void MEM_API  GetHeapMemStats ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks );
MEM_PROC  void MEM_API  GetMemStats ( uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks );
/* Sets whether to log allocations or not.
   \returns the prior state of logging...
   Parameters
   bTrueFalse :  if TRUE, allocation logging is turned on. Enables
                 logging when each block is Allocated, Released,
                 or Held.                                          */
MEM_PROC  int MEM_API  SetAllocateLogging ( LOGICAL bTrueFalse );
/* disables storing file/line, also disables auto GetMemStats
   checking
   Parameters
   bDisable :  set to TRUE to disable allocate debug logging. */
MEM_PROC  int MEM_API  SetAllocateDebug ( LOGICAL bDisable );
/* disables auto GemMemStats on every allocate/release/Hold
   GetMemStats will evaluate each and every block allocated in
   memory and inspect it for corruption.
   Parameters
   bDisable :  set to TRUE to disable auto mem check.          */
MEM_PROC  int MEM_API  SetManualAllocateCheck ( LOGICAL bDisable );
/* Sets whether to log critical sections or not.
   \returns the prior state of logging...
   Parameters
   bTrueFalse :  if TRUE, critical section logging is turned on. Logs
                 when each thread enters or leaves a
                 CRITICIALSECTION.                                    */
MEM_PROC  int MEM_API  SetCriticalLogging ( LOGICAL bTrueFalse );
/* Sets the minimum size to allocate. If a block size less than
   this is allocated, then this much is actually allocated.
   Parameters
   nSize :  Specify the minimum allocation size                 */
MEM_PROC  void MEM_API  SetMinAllocate ( size_t nSize );
/* Sets how much a heap is expanded by when it is out of space. Default
   is like 512k.
   Parameters
   dwSize :  the new size to expand heaps by.
   Remarks
   Probably internally, this is rounded up to the next 4k
   boundary.                                                            */
MEM_PROC  void MEM_API  SetHeapUnit ( size_t dwSize );
/* Multi-processor safe exchange operation. Returns the prior
   value at the pointer.
   Parameters
   p :    pointer to a volatile 64 bit value.
   val :  a new 64 bit value to put at (*p)
   Example
   <code lang="c#">
   uint64_t value = 13;
   uint64_t oldvalue = LockedExchange64( &amp;value, 15 );
   // old value will be 13
   // value will be 15
   </code>                                                    */
MEM_PROC  uint64_t MEM_API  LockedExchange64 ( volatile uint64_t* p, uint64_t val );
/* A multi-processor safe increment of a variable.
   Parameters
   p :  pointer to a 32 bit value to increment.    */
MEM_PROC  uint32_t MEM_API  LockedIncrement ( volatile uint32_t* p );
/* Does a multi-processor safe decrement on a variable.
   Parameters
   p :  pointer to a 32 bit value to decrement.         */
MEM_PROC  uint32_t MEM_API  LockedDecrement ( volatile uint32_t* p );
#ifdef __cplusplus
// like also __if_assembly__
//extern "C" {
#endif
#ifdef __64__
#define LockedExchangePtrSzVal(a,b) LockedExchange64((volatile uint64_t*)(a),b)
#else
#define LockedExchangePtrSzVal(a,b) LockedExchange((volatile uint32_t*)(a),b)
#endif
/* Multiprocessor safe swap of the contents of a variable with a
   new value, and result with the old variable.
   Parameters
   p :    pointer to a 32 bit value to exchange
   val :  value to set into the variable
   Returns
   The prior value in p.
   Example
   <code>
   uint32_t variable = 0;
   uint32_t oldvalue = LockedExchange( &amp;variable, 1 );
   </code>                                                       */
MEM_PROC  uint32_t MEM_API  LockedExchange ( volatile uint32_t* p, uint32_t val );
/* Sets a 32 bit value into memory. If the length to set is not
   a whole number of 32 bit words, the last bytes may contain
   the low 16 bits of the value and the low 8 bits.
   Parameters
   p :   pointer to memory to set
   n :   32 bit value to set memory with
   sz :  length to set
   Remarks
   Writes as many 32 it values as will fit in sz.
   If (sz &amp; 2), the low 16 bits of n are written at the end.
   then if ( sz &amp; 1 ) the low 8 bits of n are written at the
   end.                                                          */
MEM_PROC  void MEM_API  MemSet ( POINTER p, uintptr_t n, size_t sz );
//#define _memset_ MemSet
/* memory copy operation. not safe when buffers overlap. Performs
   platform-native memory stream operation to copy from one
   place in memory to another. (32 or 64 bit operations as
   possible).
   Parameters
   pTo :    Memory to copy to
   pFrom :  memory to copy from
   sz :     size of block of memory to copy                       */
MEM_PROC  void MEM_API  MemCpy ( POINTER pTo, CPOINTER pFrom, size_t sz );
//#define _memcpy_ MemCpy
/* Binary byte comparison of one block of memory to another. Results
   \-1 if less, 1 if more and 0 if equal.
   Parameters
   pOne :  pointer to memory one
   pTwo :  pointer to some other memory
   sz :    count of bytes to compare
   Returns
   0 if equal
   \-1 if the first different byte in pOne is less than pTwo.
   1 if the first different byte in pOne is more than pTwo.          */
MEM_PROC  int MEM_API  MemCmp ( CPOINTER pOne, CPOINTER pTwo, size_t sz );
	/* nothing.
   does nothing, returns nothing. */
//#define memnop(mem,sz,comment)
/* Compares two strings. Must match exactly.
   Parameters
   s1 :  string to compare
   s2 :  string to compare
   Returns
   0 if equal.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
	if s1 and s2 are NULL return is 0.              */
#ifdef StrCmp
#undef StrCmp
 // StrCmp
#endif
MEM_PROC  int MEM_API  StrCmp ( CTEXTSTR pOne, CTEXTSTR pTwo );
/* Compares two strings, case insensitively.
   Parameters
   s1 :  string to compare
   s2 :  string to compare
   Returns
   0 if equal.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
   if s1 and s2 are NULL return is 0.              */
MEM_PROC  int MEM_API  StrCaseCmp ( CTEXTSTR s1, CTEXTSTR s2 );
/* String insensitive case comparison with maximum length
   specified.
   Parameters
   s1 :      string to compare
   s2 :      string to compare
   maxlen :  maximum character required to match
   Returns
   0 if equal up to the number of characters.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
   if s1 and s2 are NULL return is 0.                     */
MEM_PROC  int MEM_API  StrCaseCmpEx ( CTEXTSTR s1, CTEXTSTR s2, size_t maxlen );
/* This searches a string for the first character that matches
   some specified character.
   A custom strchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This flavor is the only one on C where operator overloading
   cannot switch between CTEXTSTR and TEXTSTR parameters, to
   \result with the correct type. If a CTEXTSTR is passed to
   this it should result with a CTEXTSTR, but if that's the only
   choice, then the result of this is never modifiable, even if
	it is a pointer to a non-const TEXTSTR.                       */
MEM_PROC  CTEXTSTR MEM_API  StrChr ( CTEXTSTR s1, TEXTCHAR c );
/* copy S2 to S1, with a maximum of N characters.
   The last byte of S1 will always be a 'nul'. If S2 was longer
   than S1, then it will be truncated to fit within S1. Perferred
   method over this is SaveText or StrDup.
   Parameters
   s1 :      desitnation TEXTCHAR buffer
   s2 :      source string
   length :  the maximum number of characters that S1 can hold. (this
             is not a size, but is a character count)                 */
MEM_PROC  TEXTSTR MEM_API  StrCpyEx ( TEXTSTR s1, CTEXTSTR s2, size_t n );
/* copy S2 to S1. This is 'unsafe', since neither paramter's
   size is known. Prefer StrCpyEx which passes the maximum
   length for S1.
   Parameters
   s1 :  desitnation TEXTCHAR buffer
   s2 :  source string                                       */
MEM_PROC  TEXTSTR MEM_API  StrCpy ( TEXTSTR s1, CTEXTSTR s2 );
/* \Returns the count of characters in a string.
   Parameters
   s :  string to measure
   Returns
   length of string.                             */
MEM_PROC  size_t MEM_API  StrLen ( CTEXTSTR s );
/* Get the length of a string in C chars.
   Parameters
   s :  char * to count.
   Returns
   the length of s. If s is NULL, return 0. */
MEM_PROC  size_t MEM_API  CStrLen ( char const*s );
/* Finds the last instance of a character in a string.
   Parameters
   s1 :  String to search in
   c :   character to find
   Returns
   NULL if character is not in the string.
   a pointer to the last character in s1 that matches c. */
MEM_PROC  CTEXTSTR MEM_API  StrRChr ( CTEXTSTR s1, TEXTCHAR c );
#ifdef __cplusplus
/* This searches a string for the first character that matches
   some specified character.
   A custom strchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This second flavor is only available on C++ where operator
   overloading will switch between CTEXTSTR and TEXTSTR
   \parameters, to result with the correct type. If a CTEXTSTR
   is passed to this it should result with a CTEXTSTR, but if
   that's the only choice, then the result of this is never
   modifiable, even if it is a pointer to a non-const TEXTSTR.  */
MEM_PROC  TEXTSTR MEM_API  StrChr ( TEXTSTR s1, TEXTCHAR c );
/* This searches a string for the last character that matches
   some specified character.
   A custom strrchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This second flavor is only available on C++ where operator
   overloading will switch between CTEXTSTR and TEXTSTR
   \parameters, to result with the correct type. If a CTEXTSTR
   is passed to this it should result with a CTEXTSTR, but if
   that's the only choice, then the result of this is never
   modifiable, even if it is a pointer to a non-const TEXTSTR.  */
MEM_PROC  TEXTSTR MEM_API  StrRChr ( TEXTSTR s1, TEXTCHAR c );
/* <combine sack::memory::StrCmp@CTEXTSTR@CTEXTSTR>
   \ \                                              */
MEM_PROC  int MEM_API  StrCmp ( const char * s1, CTEXTSTR s2 );
#endif
/* <combine sack::memory::StrCmp@char *@CTEXTSTR>
   \ \                                            */
MEM_PROC  int MEM_API  StrCmpEx ( CTEXTSTR s1, CTEXTSTR s2, INDEX maxlen );
/* Finds an instance of a string in another string.
   Custom implementation because strstr is declared unsafe, and
   to handle switching between unicode and char.
   Parameters
   s1 :  the string to search in
   s2 :  the string to locate
   Returns
   NULL if s2 is not in s1.
   The beginning of the string in s1 that matches s2.
   Example
   <code lang="c++">
   TEXTCHAR const *found = StrStr( "look in this string", "in" );
                                               ^returns a pointer to here.
   </code>                                                                        */
MEM_PROC  CTEXTSTR MEM_API  StrStr ( CTEXTSTR s1, CTEXTSTR s2 );
#ifdef __cplusplus
/* Finds an instance of a string in another string.
   Custom implementation because strstr is declared unsafe, and
   to handle switching between unicode and char.
   Parameters
   s1 :  the string to search in
   s2 :  the string to locate
   Returns
   NULL if s2 is not in s1.
   The beginning of the string in s1 that matches s2.
   Example
   <code>
   TEXTCHAR *writable_string = StrDup( "look in this string" );
   TEXTCHAR *found = StrStr( writable_string, "in" );
   // returns a pointer to 'in' in the writable string, which can then be modified.
   </code>                                                                          */
MEM_PROC  TEXTSTR MEM_API  StrStr ( TEXTSTR s1, CTEXTSTR s2 );
#endif
/* Searches for one string in another. Compares case
   insensitively.
   Parameters
   s1 :  string to search in
   s2 :  string to locate
   See Also
   <link sack::memory::StrStr@CTEXTSTR@CTEXTSTR, StrStr> */
MEM_PROC  CTEXTSTR MEM_API  StrCaseStr ( CTEXTSTR s1, CTEXTSTR s2 );
/* This duplicates a block of memory.
   Parameters
   p :  pointer to a block of memory that was allocated.
   Returns
   a pointer to a new block of memory that has the same content
   as the original.                                             */
MEM_PROC  POINTER MEM_API  MemDupEx ( CPOINTER thing DBG_PASS );
/* <combine sack::memory::MemDupEx@CPOINTER thing>
   \ \                                             */
#define MemDup(thing) MemDupEx(thing DBG_SRC )
/* Duplicates a string, and returns a pointer to the copy.
   Parameters
   original :  string to duplicate                         */
MEM_PROC  TEXTSTR MEM_API  StrDupEx ( CTEXTSTR original DBG_PASS );
/* Translates from a TEXTCHAR string to a char string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  char *  MEM_API  CStrDupEx ( CTEXTSTR original DBG_PASS );
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  wchar_t *  MEM_API  DupTextToWideEx( CTEXTSTR original DBG_PASS );
#define DupTextToWide(s) DupTextToWideEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  char *     MEM_API  DupTextToCharEx( CTEXTSTR original DBG_PASS );
#define DupTextToChar(s) DupTextToCharEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC TEXTSTR     MEM_API  DupWideToTextEx( const wchar_t *original DBG_PASS );
#define DupWideToText(s) DupWideToTextEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC TEXTSTR     MEM_API  DupCharToTextEx( const char *original DBG_PASS );
#define DupCharToText(s) DupCharToTextEx( s DBG_SRC )
/* Converts from 8 bit char to 16 bit wchar (or no-op if not
   UNICODE compiled)
   Parameters
   original :  original string of C char.
   Returns
   a pointer to a wide character string.                     */
MEM_PROC  TEXTSTR MEM_API  DupCStrEx ( const char * original DBG_PASS );
/* Converts from 8 bit char to 16 bit wchar (or no-op if not
UNICODE compiled)
Parameters
original :  original string of C char.
Returns
a pointer to a wide character string.                     */
MEM_PROC  TEXTSTR MEM_API  DupCStrLenEx( const char * original, size_t chars DBG_PASS );
/* <combine sack::memory::StrDupEx@CTEXTSTR original>
   \ \                                                */
#define StrDup(o) StrDupEx( (o) DBG_SRC )
/* <combine sack::memory::CStrDupEx@CTEXTSTR original>
   \ \                                                 */
#define CStrDup(o) CStrDupEx( (o) DBG_SRC )
/* <combine sack::memory::DupCStrEx@char * original>
   \ \                                               */
#define DupCStr(o) DupCStrEx( (o) DBG_SRC )
/* <combine sack::memory::DupCStrLenEx@char * original@size_t chars>
   \ \                                               */
#define DupCStrLen(o,l) DupCStrLenEx( (o),(l) DBG_SRC )
//------------------------------------------------------------------------
#if 0
// this code was going to provide network oriented shared memory.
#ifndef TRANSPORT_STRUCTURE_DEFINED
typedef uintptr_t PTRANSPORT_QUEUE;
struct transport_queue_tag { uint8_t private_data_here; };
#endif
MEM_PROC  struct transport_queue_tag * MEM_API  CreateQueue ( int size );
MEM_PROC  int MEM_API  EnqueMessage ( struct transport_queue_tag *queue, POINTER msg, int size );
MEM_PROC  int MEM_API  DequeMessage ( struct transport_queue_tag *queue, POINTER msg, int *size );
MEM_PROC  int MEM_API  PequeMessage ( struct transport_queue_tag *queue, POINTER *msg, int *size );
#endif
//------------------------------------------------------------------------
#ifdef __cplusplus
 // namespace memory
}
 // namespace sack
}
using namespace sack::memory;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
/*
inline void operator delete( void * p )
{ Release( p ); }
#ifdef DELETE_HANDLES_OPTIONAL_ARGS
inline void operator delete (void * p DBG_PASS )
{ ReleaseEx( p DBG_RELAY ); }
#define delete delete( DBG_VOIDSRC )
#endif
//#define deleteEx(file,line) delete(file,line)
#ifdef USE_SACK_ALLOCER
inline void * operator new( size_t size DBG_PASS )
{ return AllocateEx( (uintptr_t)size DBG_RELAY ); }
static void * operator new[]( size_t size DBG_PASS )
{ return AllocateEx( (uintptr_t)size DBG_RELAY ); }
#define new new( DBG_VOIDSRC )
#define newEx(file,line) new(file,line)
#endif
*/
// common names - sometimes in conflict when declaring
// other functions... AND - release is a common
// component of iComObject
//#undef Allocate
//#undef Release
// Hmm wonder where this conflicted....
//#undef LineDuplicate
#else
#ifdef USE_SACK_ALLOCER
inline void * operator new(size_t size)
{ return AllocateEx( size ); }
inline void operator delete (void * p)
{ ReleaseEx( p ); }
#endif
#endif
#endif
#endif
#ifdef __LINUX__
#endif
#ifndef _TIMER_NAMESPACE
#ifdef __cplusplus
#define _TIMER_NAMESPACE namespace timers {
/* define a timer library namespace in C++. */
#define TIMER_NAMESPACE SACK_NAMESPACE namespace timers {
/* define a timer library namespace in C++ end. */
#define TIMER_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define _TIMER_NAMESPACE
#define TIMER_NAMESPACE
#define TIMER_NAMESPACE_END
#endif
#endif
// this is a method replacement to use PIPEs instead of SEMAPHORES
// replacement code only affects linux.
#if defined( __QNX__ ) || defined( __MAC__) || defined( __LINUX__ )
#  if defined( __ANDROID__ ) || defined( EMSCRIPTEN ) || defined( __MAC__ )
// android > 21 can use pthread_mutex_timedop
#    define USE_PIPE_SEMS
#  else
//   Default behavior is to use pthread_mutex_timedlock for wakeable sleeps.
// no semtimedop; no semctl, etc
//#    include <sys/sem.h>
//originally used semctl; but that consumes system resources that are not
//cleaned up when the process exits.
#endif
#endif
#ifdef USE_PIPE_SEMS
#  define _NO_SEMTIMEDOP_
#endif
SACK_NAMESPACE
/* This namespace contains methods for working with timers and
   threads. Since timers are implemented in an asynchronous
   thread, the thread creation and control can be exposed here
   also.
   ThreadTo
   WakeThread
   WakeableSleep [Example]
   AddTimer
   RemoveTimer
   RescheduleTimer
   EnterCriticalSec see Also
 EnterCriticalSecNoWait
   LeaveCriticalSec                                            */
_TIMER_NAMESPACE
#ifdef TIMER_SOURCE
#define TIMER_PROC(type,name) EXPORT_METHOD type CPROC name
#else
/* Defines import export and call method for timers. Looks like
   timers are native calltype by default instead of CPROC.      */
#define TIMER_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#if defined( __LINUX__ ) || defined( __ANDROID__ )
TIMER_PROC( uint32_t, timeGetTime )( void );
TIMER_PROC( uint32_t, GetTickCount )( void );
TIMER_PROC( void, Sleep )( uint32_t ms );
#endif
/* Function signature for user callbacks passed to AddTimer. */
typedef void (CPROC *TimerCallbackProc)( uintptr_t psv );
/* Adds a new periodic timer. From now, until the timer is
   removed with RemoveTimer, it will call the timer procedure at
   the specified frequency of milliseconds. The delay until the
   first time the timer fires can be specified independant of
   frequency. If it is not specified, the first time the timer
   will get invoked is at +1 frequency from now.
   Parameters
   start :      how long in milliseconds until the timer starts. Can
                be 0 and timer will fire at the next opportunity.
   frequency :  how long the delay is between event invocations,
                in milliseconds.
   callback :   user routine to call when the timer's delay
                expires.
   user :       user data to pass to the callback when it is
                invoked.
   Returns
   a 32 bit ID that identifies the timer for this application.
   Example
   First some setup valid for all timer creations...
   <code lang="c++">
   void CPROC TimerProc( uintptr_t user_data )
   {
       // user_data of the timer is the 'user' parameter passed to AddTimer(Exx)
   }
   </code>
   you might want to save this for something like
   RescheduleTimer
   <code>
   uint32_t timer_id;
   </code>
   Create a simple timer, it will fire at 250 milliseconds from
   now, and again every 250 milliseconds from the time it
   starts.
   <code lang="c++">
   timer_id = AddTimer( 250, TimerProc, 0 );
   </code>
   Create a timer that fires immediately, and 732 milliseconds
   after, passing some value 1234 as user data...
   <code lang="c++">
   timer_id = AddTimerEx( 0, 732, TimerProc, 1234 );
	</code>
	Remarks
	if a timer is dispatched and needs to wait - please link with idlelib, and call Idle.
	this will allow other timers to fire on schedule.  The timer that is waiting is not
	in the list of timers to process.
	*/
TIMER_PROC( uint32_t, AddTimerExx )( uint32_t start, uint32_t frequency
					, TimerCallbackProc callback
					, uintptr_t user DBG_PASS);
/* <combine sack::timers::AddTimerExx@uint32_t@uint32_t@TimerCallbackProc@uintptr_t user>
   \ \                                                                         */
#define AddTimerEx( s,f,c,u ) AddTimerExx( (s),(f),(c),(u) DBG_SRC )
/* <combine sack::timers::AddTimerExx@uint32_t@uint32_t@TimerCallbackProc@uintptr_t user>
   \ \                                                                         */
#define AddTimer( f, c, u ) AddTimerExx( (f), (f), (c), (u) DBG_SRC)
/* Stops a timer. The next time this timer would run, it will be
   removed. If it is currently dispatched, it is safe to remove
   from within the timer itself.
   Parameters
   timer :  32 bit timer ID from AddTimer.                       */
TIMER_PROC( void, RemoveTimer )( uint32_t timer );
/* Reschedule when a timer can fire. The delay can be 0 to make
   wake the timer.
   Parameters
   timer :  32 bit timer identifier from AddTimer.
   delay :  How long before the timer should run now.<p />If 0,
            will issue timer immediately.<p />If not specified,
            using the macro, the default delay is the timer's
            frequency. (can prevent the timer from firing until
            it's frequency from now.)                           */
TIMER_PROC( void, RescheduleTimerEx )( uint32_t timer, uint32_t delay );
/* <combine sack::timers::RescheduleTimerEx@uint32_t@uint32_t>
   \ \                                               */
TIMER_PROC( void, RescheduleTimer )( uint32_t timer );
/* Changes the frequency of a timer. Reschedule timer only
   changes the next time it fires, this can adjust the
   frequency. The simple ChangeTimer macro is sufficient.
   Parameters
   ID :         32 bit ID of the time created by AddTimer.
   initial :    initial delay of the timer. (Might matter if the
                timer hasn't fired the first time)
   frequency :  new delay between timer callback invokations.    */
TIMER_PROC( void, ChangeTimerEx )( uint32_t ID, uint32_t initial, uint32_t frequency );
/* <combine sack::timers::ChangeTimerEx@uint32_t@uint32_t@uint32_t>
   \ \                                               */
#define ChangeTimer( ID, Freq ) ChangeTimerEx( ID, Freq, Freq )
/* This is the type returned by MakeThread, and passed to
   ThreadTo. This is a private structure, and no definition is
   publicly available, this should be treated like a handle.   */
typedef struct threads_tag *PTHREAD;
/* Function signature for a thread entry point passed to
   ThreadTo.                                             */
typedef uintptr_t (CPROC*ThreadStartProc)( PTHREAD );
/* Function signature for a thread entry point passed to
   ThreadToSimple.                                             */
typedef uintptr_t (*ThreadSimpleStartProc)( POINTER );
/*
  OnThreadCreate allows registering a procedure to run
  when a thread is created.  (Or an existing thread becomes
  tracked within this library, via MakeThread() ).
  It is called once per thread, for each thread created
  after registering the callback.
*/
TIMER_PROC( void, OnThreadCreate )( void ( *v )( void ) );
/* Create a separate thread that starts in the routine
   specified. The uintptr_t value (something that might be a
   pointer), is passed in the PTHREAD structure. (See
   GetThreadParam)
   Parameters
   proc :       starting routine for the thread
   user_data :  some value that can be stored in the number of
                bits that a pointer is. This is passed to the
                proc when the thread starts.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( PTHREAD, ThreadToEx )( ThreadStartProc proc, uintptr_t param DBG_PASS );
/* <combine sack::timers::ThreadToEx@ThreadStartProc@uintptr_t param>
   \ \                                                               */
#define ThreadTo(proc,param) ThreadToEx( proc,param DBG_SRC )
/* Create a separate thread that starts in the routine
   specified. The uintptr_t value (something that might be a
   pointer), is passed in the PTHREAD structure. (See
   GetThreadParam)
   Parameters
   proc :       starting routine for the thread
   user_data :  some value that can be stored in the number of
                bits that a pointer is. This is passed to the
                proc when the thread starts.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( PTHREAD, ThreadToSimpleEx )( ThreadSimpleStartProc proc, POINTER param DBG_PASS );
/* <combine sack::timers::ThreadToEx@ThreadStartProc@uintptr_t param>
   \ \                                                               */
#define ThreadToSimple(proc,param) ThreadToSimpleEx( proc,param DBG_SRC )
/* \Returns a PTHREAD that represents the current thread. This
   can be used to create a PTHREAD identifier for the main
   thread.
   Parameters
   None.
   Returns
   a pointer to a thread structure that identifies the current
   thread. If this thread already has this structure created,
   the same one results on subsequent MakeThread calls.        */
TIMER_PROC( PTHREAD, MakeThread )( void );
/* This returns the parameter passed as user data to ThreadTo.
   Parameters
   thread :  thread to get the parameter from.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( uintptr_t, GetThreadParam )( PTHREAD thread );
/* \returns the numeric THREAD_ID from a PTHREAD.
   Parameters
   thread :  thread to get the system wide unique ID of. */
TIMER_PROC( THREAD_ID, GetThreadID )( PTHREAD thread );
/* \returns the numeric THREAD_ID from a PTHREAD.
   Parameters
   thread :  thread to get the system wide unique ID of. */
TIMER_PROC( THREAD_ID, GetThisThreadID )( void );
/* Symbol defined to pass to Wakeable_Sleep to sleep until
   someone calls WakeThread.                               */
#define SLEEP_FOREVER 0xFFFFFFFF
/* Sleeps a number of milliseconds or until the thread is passed
   to WakeThread.
   Parameters
   dwMilliseconds :  How long to sleep. Can be indefinite if
                     value is SLEEP_FOREVER.
   Example
   <code lang="c++">
   PTHREAD main_thread;
   uintptr_t CPROC WakeMeThread( PTHREAD thread )
   {
      // get the value passed to ThreadTo as user_data.
      uintptr_t user_data = GetThreadParam( thread );
      // let the main thread sleep a little wile
       WakeableSleep( 250 );
      // then wake it up
       WakeThread( main_thread );
       return 0;
   }
   int main( void )
   {
       // save my PTHREAD globally.
       main_thread = MakeThread();
       // create a thread that can wake us
       ThreadTo( WakeMeThread, 0 );
       // demonstrate sleeping
       WakableSleep( SLEEP_FOREVER );
       return 0;
   }
   </code>                                                       */
TIMER_PROC( void, WakeableSleepEx )( uint32_t milliseconds DBG_PASS );
TIMER_PROC( void, WakeableSleep )( uint32_t milliseconds );
TIMER_PROC( void, WakeableNamedSleepEx )( CTEXTSTR name, uint32_t n DBG_PASS );
#define WakeableNamedSleep( name, n )   WakeableNamedSleepEx( name, n DBG_SRC )
TIMER_PROC( void, WakeNamedSleeperEx )( CTEXTSTR name DBG_PASS );
#define WakeNamedSleeper( name )   WakeNamedSleeperEx( name DBG_SRC )
TIMER_PROC( void, WakeableNamedThreadSleepEx )( CTEXTSTR name, uint32_t n DBG_PASS );
#define WakeableNamedThreadSleep( name, n )   WakeableNamedThreadSleepEx( name, n DBG_SRC )
TIMER_PROC( void, WakeNamedThreadSleeperEx )( CTEXTSTR name, THREAD_ID therad DBG_PASS );
#define WakeNamedThreadSleeper( name, thread )   WakeNamedThreadSleeperEx( name, thread DBG_SRC )
#ifdef USE_PIPE_SEMS
TIMER_PROC( int, GetThreadSleeper )( PTHREAD thread );
#endif
/* <combine sack::timers::WakeableSleepEx@uint32_t milliseconds>
   \ \                                                      */
#define WakeableSleep(n) WakeableSleepEx(n DBG_SRC )
/* Wake a thread by ID, if the pThread is not available. Can be
   used cross-process for instance. Although someone could add a
   method to provide a PTHREAD wrapper around THREAD_ID for
   threads in remote processes, this may not be a best practice.
   Parameters
   thread_id :  THREAD_ID from GetMyThreadID, which is a macro
                appropriate for a platform.                      */
TIMER_PROC( void, WakeThreadIDEx )( THREAD_ID thread DBG_PASS );
/* Wake a thread.
   Example
   See WakeableSleepEx.
   Parameters
   pThread :  thread to wake up from a WakeableSleep. */
TIMER_PROC( void, WakeThreadEx )( PTHREAD thread DBG_PASS );
/* <combine sack::timers::WakeThreadIDEx@THREAD_ID thread>
   \ \                                                     */
#define WakeThreadID(thread) WakeThreadIDEx( thread DBG_SRC )
/* <combine sack::timers::WakeThreadEx@PTHREAD thread>
   \ \                                                 */
#define WakeThread(t) WakeThreadEx(t DBG_SRC )
/* This can be checked to see if the THREAD_ID to wake still has
   an event. Sometimes threads end.
   Parameters
   thread :  thread identifier to check to see if it exists/can be
             woken.
   Returns
   TRUE if the thread can be signaled to wake up.
   FALSE if the thread cannot be found or cannot be woken up.      */
TIMER_PROC( int, TestWakeThreadID )( THREAD_ID thread );
/* This can be checked to see if the PTHREAD to wake still has
   an event. Sometimes threads call UnmakeThread(). This is a
   more practical test using a THREAD_ID instead. See
   TestWakeThreadID.
   Returns
   TRUE if the thread can be signaled to wake up.
   FALSE if the thread cannot be found or cannot be woken up.  */
TIMER_PROC( int, TestWakeThread )( PTHREAD thread );
//TIMER_PROC( void, WakeThread )( PTHREAD thread );
TIMER_PROC( void, EndThread )( PTHREAD thread );
/* This tests to see if a pointer to a thread references the
   current thread.
   Parameters
   thread :  thread to check to see if it is the current thread.
   Returns
   TRUE if this thread is the same as the PTHREAD passed.
   otherwise FALSE.
   Example
   <code lang="c++">
   PTHREAD main_thread;
   LOGICAL thread_finished_check;
   uintptr_t CPROC ThreadProc( PTHREAD thread )
   {
       if( IsThisThread( main_thread ) )
            printf( "This thread is not the main thread.\\n" );
       else
            printf( "This is the main thread - cannot happen :)\\n" );
   </code>
   <code>
       // mark that this thread is complete
       thread_finished_check = TRUE;
   </code>
   <code lang="c++">
       // hmm - for some reason, just pass the uintptr_t that was passed to ThreadTo as the result.
       return GetThreadParam( thread );
   }
   int main( void )
   {
        main_thread = MakeThread();
        ThreadTo( ThreadProc, 0 );
        // wait for the thread to finish its thread identity check.
        while( !thread_finished_check )
            Relinquish();
        return 0;
   }
   </code>                                                                                         */
TIMER_PROC( int, IsThisThreadEx )( PTHREAD pThreadTest DBG_PASS );
/* <combine sack::timers::IsThisThreadEx@PTHREAD pThreadTest>
   \ \                                                        */
#define IsThisThread(thread) IsThisThreadEx(thread DBG_SRC)
/* Enter a critical section. Only a single thread may be in a
   critical section, if a second thread attempts to enter the
   section while another thread is in it will block until the
   original thread leaves the section. The same thread may enter
   a critical section multiple times. For each time a critical
   section is entered, the thread must also leave the critical
   section (See LeaveCriticalSection).
   Parameters
   pcs :  pointer to a critical section to enter                 */
TIMER_PROC( LOGICAL, EnterCriticalSecEx )( PCRITICALSECTION pcs DBG_PASS );
/* Leaves a critical section. See EnterCriticalSecEx.
   Parameters
   pcs :  pointer to a critical section.              */
TIMER_PROC( LOGICAL, LeaveCriticalSecEx )( PCRITICALSECTION pcs DBG_PASS );
/* Does nothing. There are no extra resources required for
   critical sections, and the memory is allocated by the
   application.
   Parameters
   pcs :  pointer to critical section to do nothing with.  */
TIMER_PROC( void, DeleteCriticalSec )( PCRITICALSECTION pcs );
#ifdef _WIN32
	TIMER_PROC( HANDLE, GetWakeEvent )( void );
	TIMER_PROC( HANDLE, GetThreadHandle )( PTHREAD thread );
#endif
#ifdef __LINUX__
	TIMER_PROC( pthread_t, GetThreadHandle )(PTHREAD thread);
#endif
#ifdef USE_NATIVE_CRITICAL_SECTION
#define EnterCriticalSec(pcs) EnterCriticalSection( pcs )
#define LeaveCriticalSec(pcs) LeaveCriticalSection( pcs )
#else
/* <combine sack::timers::EnterCriticalSecEx@PCRITICALSECTION pcs>
   \ \                                                             */
#define EnterCriticalSec( pcs ) EnterCriticalSecEx( (pcs) DBG_SRC )
/* <combine sack::timers::LeaveCriticalSecEx@PCRITICALSECTION pcs>
   \ \                                                             */
#define LeaveCriticalSec( pcs ) LeaveCriticalSecEx( (pcs) DBG_SRC )
#endif
TIMER_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::timers;
#endif
#endif
// $Log: timers.h,v $
// Revision 1.37  2005/05/16 19:06:58  jim
// Extend wakeable sleep to know the originator of the sleep.
//
// Revision 1.36  2004/09/29 16:42:51  d3x0r
// fixed queues a bit - added a test wait function for timers/threads
//
// Revision 1.35  2004/07/07 15:33:54  d3x0r
// Cleaned c++ warnings, bad headers, fixed make system, fixed reallocate...
//
// Revision 1.34  2004/05/02 02:04:16  d3x0r
// Begin border exclusive option, define PushMethod explicitly, fix LaunchProgram in timers.h
//
// Revision 1.33  2003/12/10 15:38:25  panther
// Move Sleep and GetTickCount to real code
//
// Revision 1.32  2003/11/02 00:31:47  panther
// Added debuginfo pass to wakethread
//
// Revision 1.31  2003/10/24 14:59:21  panther
// Added Load/Unload Function for system shared library abstraction
//
// Revision 1.30  2003/10/17 00:56:04  panther
// Rework critical sections.
// Moved most of heart of these sections to timers.
// When waiting, sleep forever is used, waking only when
// released... This is preferred rather than continuous
// polling of section with a Relinquish.
// Things to test, event wakeup order uner linxu and windows.
// Even see if the wake ever happens.
// Wake should be able to occur across processes.
// Also begin implmeenting MessageQueue in containers....
// These work out of a common shared memory so multiple
// processes have access to this region.
//
// Revision 1.29  2003/09/21 04:03:30  panther
// Build thread ID with pthread_self and getgid
//
// Revision 1.28  2003/07/29 10:41:25  panther
// Predefine struct threads_tag to avoid warning
//
// Revision 1.27  2003/07/24 22:49:20  panther
// Define callback procs as CDECL
//
// Revision 1.26  2003/07/24 16:56:41  panther
// Updates to expliclity define C procedure model for callbacks and assembly modules - incomplete
//
// Revision 1.25  2003/07/22 15:33:19  panther
// Added comment about idle()
//
// Revision 1.24  2003/04/03 10:10:20  panther
// Add file/line debugging to addtimer
//
// Revision 1.23  2003/03/27 13:47:14  panther
// Immplement a EndThread
//
// Revision 1.22  2003/03/25 08:38:11  panther
// Add logging
//
#ifndef MAXPATH
// windef.h has MAX_PATH
#  define MAXPATH MAX_PATH
#  if (!MAXPATH)
#    undef MAXPATH
#    define MAXPATH 256
#  endif
#endif
#ifndef PATH_MAX
// sometimes PATH_MAX is what's used, well it's should be MAXPATH which is MAX_PATH
# define PATH_MAX MAXPATH
#endif
#ifdef _WIN32
#  ifdef CONSOLE_SHELL
 // in order to get wide characters from the commandline we have to use the GetCommandLineW function, convert it to utf8 for internal usage.
#    define SaneWinMain(a,b) int main( int a, char **argv_real ) { char *tmp; TEXTCHAR **b; ParseIntoArgs( tmp = WcharConvert( GetCommandLineW() ), &a, &b ); Deallocate( char*, tmp ); {
#    define EndSaneWinMain() } }
#  else
#    define SaneWinMain(a,b) int APIENTRY WinMain( HINSTANCE hInst, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow ) { int a; char *tmp; TEXTCHAR **b; ParseIntoArgs( tmp = WcharConvert( GetCommandLineW() ), &a, &b ); {
#    define EndSaneWinMain() } }
#  endif
#else
#  if defined( __ANDROID__ ) && !defined( ANDROID_CONSOLE_UTIL )
#    define SaneWinMain(a,b) int SACK_Main( int a, char **b )
#    define EndSaneWinMain()
#  else
#    define SaneWinMain(a,b) int main( int a, char **b ) { char **argv_real = b; {
#    define EndSaneWinMain() } }
#  endif
#endif
//  these are rude defines overloading otherwise very practical types
// but - they have to be dispatched after all standard headers.
#ifndef FINAL_TYPES
#define FINAL_TYPES
#  ifdef __WATCOMC__
 //__WATCOMC__
#  endif
#  ifdef _WIN32
#    include <basetsd.h>
  // this redefines lprintf sprintf etc... and strsafe is preferred
 // more things that need override by strsafe.h
#    include <tchar.h>
 // added for mingw64 actually
#    ifdef __GNUC__
#      undef __CRT__NO_INLINE
#    endif
#    ifndef MINGW_SUX
#      include <strsafe.h>
#    else
#      define STRSAFE_E_INSUFFICIENT_BUFFER  0x8007007AL
#    endif
#  else
#  endif
// may consider changing this to uint16_t* for unicode...
#ifdef UNICODE
#  ifndef NO_UNICODE_C
#    define strrchr          wcsrchr
#    define strchr           wcschr
#    define strncpy          wcsncpy
#    ifdef strcpy
#      undef strcpy
#    endif
#    define strcpy           wcscpy
#    define strcmp           wcscmp
#    ifndef __LINUX__
// linux also translates 'i' to 'case' in sack_typelib.h
#      define stricmp          wcsicmp
#      define strnicmp         wcsnicmp
//#  define strlen           mbrlen
#    endif
#    define strlen           wcslen
#    ifdef WIN32
#      define stat(a,b)        _wstat(a,b)
#    else
#    endif
#    define printf           wprintf
#    define fprintf          fwprintf
#    define fputs            fputws
#    define fgets            fgetws
#    define atoi             _wtoi
#    ifdef __WATCOMC__
#      undef atof
#    endif
//#    define atof             _wtof
#    ifdef _MSC_VER
#      ifndef __cplusplus_cli
#        define fprintf   fwprintf
#        define atoi      _wtoi
// define sprintf here.
#      endif
#    endif
#    if defined( _ARM_ ) && defined( WIN32 )
// len should be passed as character count. this was the wrongw ay to default this.
#      define snprintf StringCbPrintf
//#define snprintf StringCbPrintf
#    endif
#  else
//#    define atoi             wtoi
#  endif
 // not unicode...
#else
#endif
#  ifdef _MSC_VER
#    define snprintf _snprintf
#    define vsnprintf _vsnprintf
#    if defined( _UNICODE )
#      define tnprintf _snwprintf
#      define vtnprintf _vsnwprintf
#    else
#      define tnprintf _snprintf
#      define vtnprintf _vsnprintf
#    endif
#    define snwprintf _snwprintf
#    if defined( _UNICODE ) && !defined( NO_UNICODE_C )
#    define tscanf swscanf_s
#    else
#    define tscanf sscanf_s
#    endif
#    define scanf sscanf_s
#    define swcanf swscanf_s
 // _MSC_VER
#  endif
#  ifdef  __GNUC__
#      if defined( _UNICODE )
#        define VSNPRINTF_FAILS_RETURN_SIZE
#        define tnprintf  swprintf
#        define vtnprintf vswprintf
#        if !defined( NO_UNICODE_C )
#           define snprintf   swprintf
#           define vsnprintf  vswprintf
//#           define sscanf     swscanf
#        else
#        endif
#      else
#        define tnprintf snprintf
#        define vtnprintf vsnprintf
//#        define snprintf snprintf
//#        define vsnprintf vsnprintf
#    if defined( _UNICODE ) && !defined( NO_UNICODE_C )
#    define tscanf swscanf
#    else
#    define tscanf sscanf
#    endif
#      endif
 // __GNUC__
#  endif
#  ifdef __WATCOMC__
#      if defined( _UNICODE )
#        define tnprintf  _snwprintf
#        define vtnprintf _vsnwprintf
#        if !defined( NO_UNICODE_C )
#           define snprintf  _snwprintf
#           define vsnprintf _vsnwprintf
#           define sscanf     swscanf
#        else
#        endif
#      else
#         define tnprintf  snprintf
#         define vtnprintf vsnprintf
//#        define snprintf snprintf
//#        define vsnprintf vsnprintf
#      endif
#        define snwprintf  _snwprintf
 // __WATCOMC__
#  endif
#endif
#endif
#if 0
#ifdef __cplusplus
namespace sack {
   namespace logging {
#endif
      INDEX real_lprintf( char const* f,... ) { va_list va; int n; va_start(va,f); n = vprintf(f ,va); puts(""); return n; }
      INDEX null_lprintf( char const* f,... ) { return 0; }
      RealLogFunction _xlprintf(uint32_t level DBG_PASS) { return real_lprintf; };
      void SystemLog( char const* f ) { puts( f ); puts( "ZZZZ\n" ); }
#ifdef __cplusplus
   }
}
#endif
#endif
/* Includes the system platform as required or appropriate. If
   under a linux system, include appropriate basic linux type
   headers, if under windows pull "windows.h".
   Includes the MOST stuff here ( a full windows.h parse is many
   many lines of code.)                                          */
/* A macro to build a wide character string of __FILE__ */
#define _WIDE__FILE__(n) n
#define WIDE__FILE__ _WIDE__FILE__(__FILE__)
#if _XOPEN_SOURCE < 500
#  undef _XOPEN_SOURCE
#  define _XOPEN_SOURCE 500
#endif
#ifndef STANDARD_HEADERS_INCLUDED
/* multiple inclusion protection symbol */
#define STANDARD_HEADERS_INCLUDED
#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>
#include <stdint.h>
#if _MSC_VER
#  ifdef EXCLUDE_SAFEINT_H
#    define _INTSAFE_H_INCLUDED_
#  endif
 //_MSC_VER
#endif
#ifndef WINVER
#  define WINVER 0x0601
#endif
#ifndef _WIN32
#  ifndef __LINUX__
#    define __LINUX__
#  endif
#endif
#if !defined(__LINUX__)
#  ifndef STRICT
#    define STRICT
#  endif
#  define WIN32_LEAN_AND_MEAN
// #define NOGDICAPMASKS             // CC_*, LC_*, PC_*, CP_*, TC_*, RC_
// #define NOVIRTUALKEYCODES         // VK_*
// #define NOWINMESSAGES             // WM_*, EM_*, LB_*, CB_*
// #define NOWINSTYLES               // WS_*, CS_*, ES_*, LBS_*, SBS_*, CBS_*
// #define NOSYSMETRICS              // SM_*
// #define NOMENUS                   // MF_*
// #define NOICONS                   // IDI_*
// #define NOKEYSTATES               // MK_*
// #define NOSYSCOMMANDS             // SC_*
// #define NORASTEROPS               // Binary and Tertiary raster ops
// #define NOSHOWWINDOW              // SW_*
               // OEM Resource values
#  define OEMRESOURCE
// #define NOATOM                    // Atom Manager routines
#  ifndef _INCLUDE_CLIPBOARD
               // Clipboard routines
#    define NOCLIPBOARD
#  endif
// #define NOCOLOR                   // Screen colors
// #define NOCTLMGR                  // Control and Dialog routines
//(spv) #define NODRAWTEXT                // DrawText() and DT_*
// #define NOGDI                     // All GDI defines and routines
// #define NOKERNEL                  // All KERNEL defines and routines
// #define NOUSER                    // All USER defines and routines
#  ifndef _ARM_
#    ifndef _INCLUDE_NLS
                     // All NLS defines and routines
#      define NONLS
#    endif
#  endif
// #define NOMB                      // MB_* and MessageBox()
                  // GMEM_*, LMEM_*, GHND, LHND, associated routines
#  define NOMEMMGR
                // typedef METAFILEPICT
#  define NOMETAFILE
#  ifndef NOMINMAX
                  // Macros min(a,b) and max(a,b)
#    define NOMINMAX
#  endif
// #define NOMSG                     // typedef MSG and associated routines
// #define NOOPENFILE                // OpenFile(), OemToAnsi, AnsiToOem, and OF_*
// #define NOSCROLL                  // SB_* and scrolling routines
                 // All Service Controller routines, SERVICE_ equates, etc.
#  define NOSERVICE
//#define NOSOUND                   // Sound driver routines
#  ifndef _INCLUDE_TEXTMETRIC
              // typedef TEXTMETRIC and associated routines
#    define NOTEXTMETRIC
#  endif
// #define NOWH                      // SetWindowsHook and WH_*
// #define NOWINOFFSETS              // GWL_*, GCL_*, associated routines
// #define NOCOMM                    // COMM driver routines
                   // Kanji support stuff.
#  define NOKANJI
                    // Help engine interface.
#  define NOHELP
                // Profiler interface.
#  define NOPROFILER
//#define NODEFERWINDOWPOS          // DeferWindowPos routines
                     // Modem Configuration Extensions
#  define NOMCX
   // no StrCat StrCmp StrCpy etc functions.  (used internally)
#  define NO_SHLWAPI_STRFCNS
  // This also has defines that override StrCmp StrCpy etc... but no override
#  define STRSAFE_NO_DEPRECATE
#  ifdef _MSC_VER
#    ifndef _WIN32_WINDOWS
// needed at least this for what - updatelayeredwindow?
#      define _WIN32_WINDOWS 0x0601
#    endif
#  endif
// INCLUDE WINDOWS.H
#  ifdef __WATCOMC__
#    undef _WINDOWS_
#  endif
#  ifdef UNDER_CE
// just in case windows.h also fails after undef WIN32
// these will be the correct order for primitives we require.
#    include <excpt.h>
#    include <windef.h>
#    include <winnt.h>
#    include <winbase.h>
#    include <wingdi.h>
#    include <wtypes.h>
#    include <winuser.h>
#    undef WIN32
#  endif
#  define _WINSOCKAPI_
#  include <windows.h>
#  undef _WINSOCKAPI_
#  if defined( WIN32 ) && defined( NEED_SHLOBJ )
#    include <shlobj.h>
#  endif
#  if _MSC_VER > 1500
#    define mkdir _mkdir
#    define fileno _fileno
#    define stricmp _stricmp
#    define strdup _strdup
#  endif
//#  include <windowsx.h>
// we like timeGetTime() instead of GetTickCount()
//#  include <mmsystem.h>
#ifdef __cplusplus
extern "C"
#endif
__declspec(dllimport) DWORD WINAPI timeGetTime(void);
#  if defined( NEED_SHLAPI )
#    include <shlwapi.h>
#    include <shellapi.h>
#  endif
#  ifdef NEED_V4W
#    include <vfw.h>
#  endif
#  if defined( HAVE_ENVIRONMENT )
#    define getenv(name)       OSALOT_GetEnvironmentVariable(name)
#    define setenv(name,val)   SetEnvironmentVariable(name,val)
#  endif
#  define Relinquish()       Sleep(0)
//#pragma pragnoteonly("GetFunctionAddress is lazy and has no library cleanup - needs to be a lib func")
//#define GetFunctionAddress( lib, proc ) GetProcAddress( LoadLibrary( lib ), (proc) )
#  ifdef __cplusplus_cli
#    include <vcclr.h>
 /*lprintf( */
#    define DebugBreak() System::Console::WriteLine(gcnew System::String( WIDE__FILE__ "(" STRSYM(__LINE__) ") Would DebugBreak here..." ) );
//typedef unsigned int HANDLE;
//typedef unsigned int HMODULE;
//typedef unsigned int HWND;
//typedef unsigned int HRC;
//typedef unsigned int HMENU;
//typedef unsigned int HICON;
//typedef unsigned int HINSTANCE;
#  endif
 // ifdef unix/linux
#else
#  include <pthread.h>
#  include <sched.h>
#  include <unistd.h>
#  include <sys/time.h>
#  include <errno.h>
#  if defined( __ARM__ )
#    define DebugBreak()
#  else
/* A symbol used to cause a debugger to break at a certain
   point. Sometimes dynamicly loaded plugins can be hard to set
   the breakpoint in the debugger, so it becomes easier to
   recompile with a breakpoint in the right place.
   Example
   <code lang="c++">
   DebugBreak();
	</code>                                                      */
#    ifdef __ANDROID__
#      define DebugBreak()
#    else
#      if defined( __EMSCRIPTEN__ ) || defined( __ARM__ )
#        define DebugBreak()
#      else
#        define DebugBreak()  __asm__("int $3\n" )
#      endif
#    endif
#  endif
#  ifdef __ANDROID_OLD_PLATFORM_SUPPORT__
extern __sighandler_t bsd_signal(int, __sighandler_t);
#  endif
// moved into timers - please linnk vs timers to get Sleep...
//#define Sleep(n) (usleep((n)*1000))
#  define Relinquish() sched_yield()
#  define GetLastError() (int32_t)errno
/* return with a THREAD_ID that is a unique, universally
   identifier for the thread for inter process communication. */
#  define GetCurrentProcessId() ((uint32_t)getpid())
#  define GetCurrentThreadId() ((uint32_t)getpid())
  // end if( !__LINUX__ )
#endif
#ifndef NEED_MIN_MAX
#  ifndef NO_MIN_MAX_MACROS
#    define NO_MIN_MAX_MACROS
#  endif
#endif
#ifndef NO_MIN_MAX_MACROS
#  ifdef __cplusplus
#    ifdef __GNUC__
#      ifndef min
#        define min(a,b) ((a)<(b))?(a):(b)
#      endif
#    endif
#  endif
/* Define a min(a,b) macro when the compiler lacks it. */
#  ifndef min
#    define min(a,b) (((a)<(b))?(a):(b))
#  endif
/* Why not add the max macro, also? */
#  ifndef max
#    define max(a,b) (((a)>(b))?(a):(b))
#  endif
#endif
#ifndef SACK_PRIMITIVE_TYPES_INCLUDED
#define SACK_PRIMITIVE_TYPES_INCLUDED
/* Define most of the sack core types on which everything else is
   based. Also defines some of the primitive container
   structures. We also handle a lot of platform/compiler
   abstraction here.
   A reFactoring for stdint.h and uint32_t etc would be USEFUL!
   where types don't exist, define them as apprpritate types instead.
But WHO doesn't have stdint?  BTW is sizeof( size_t ) == sizeof( void* )
   This is automatically included with stdhdrs.h; however, when
   including sack_types.h, the minimal headers are pulled. */
#define HAS_STDINT
//#define USE_SACK_CUSTOM_MEMORY_ALLOCATION
	// this has to be a compile option (option from cmake)
   // enables debug dump mem...
#ifdef USE_SACK_CUSTOM_MEMORY_ALLOCATION
#  define USE_CUSTOM_ALLOCER 1
#else
#  define USE_CUSTOM_ALLOCER 0
#endif
#ifndef __64__
#  if defined( _WIN64 ) || defined( ENVIRONMENT64 ) || defined( __x86_64__ ) || defined( __ia64 ) || defined( __ppc64__ ) || defined( __LP64__ )
#    define __64__ 1
#  endif
#endif
#ifdef _MSC_VER
#  ifndef _WIN32_WINNT
#    define _WIN32_WINNT 0x501
#  endif
#  ifndef WIN32
#    ifdef _WIN32
#      define WIN32 _WIN32
#    endif
#  endif
// force windows on __MSVC
#  ifndef WIN32
#    define WIN32
#  endif
#endif
#if !defined( __NO_THREAD_LOCAL__ ) && ( defined( _MSC_VER ) || defined( __WATCOMC__ ) )
#  define HAS_TLS 1
#  ifdef __cplusplus
#    define DeclareThreadLocal thread_local
#    define DeclareThreadVar  thread_local
#  else
#    define DeclareThreadLocal static __declspec(thread)
#    define DeclareThreadVar __declspec(thread)
#  endif
#elif !defined( __NO_THREAD_LOCAL__ ) && ( defined( __GNUC__ ) )
#    define HAS_TLS 1
#    ifdef __cplusplus
#      define DeclareThreadLocal thread_local
#      define DeclareThreadVar thread_local
#    else
#    define DeclareThreadLocal static __thread
#    define DeclareThreadVar __thread
#  endif
#else
// if no HAS_TLS
#  define DeclareThreadLocal static
#  define DeclareThreadVar
#endif
#ifdef __cplusplus_cli
// these things define a type called 'Byte'
	// which causes confusion... so don't include vcclr for those guys.
#  ifdef SACK_BAG_EXPORTS
// maybe only do this while building sack_bag project itself...
#    if !defined( ZCONF_H )        && !defined( __FT2_BUILD_GENERIC_H__ )        && !defined( ZUTIL_H )        && !defined( SQLITE_PRIVATE )        && !defined( NETSERVICE_SOURCE )        && !defined( LIBRARY_DEF )
//using namespace System;
#    endif
#  endif
#endif
// Defined for building visual studio monolithic build.  These symbols are not relavent with cmakelists.
#ifdef SACK_BAG_EXPORTS
#  define SACK_BAG_CORE_EXPORTS
// exports don't really matter with CLI compilation.
#  ifndef BAG
//#ifndef TARGETNAME
//#  define TARGETNAME "sack_bag.dll"  //$(TargetFileName)
//#endif
#    ifndef __cplusplus_cli
// cli mode, we use this directly, and build the exports in sack_bag.dll directly
#    else
#      define LIBRARY_DEADSTART
#    endif
#define MD5_SOURCE
#define USE_SACK_FILE_IO
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define MEM_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SYSLOG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define _TYPELIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define HTTP_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define TIMER_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define IDLE_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define CLIENTMSG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define FRACTION_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define NETWORK_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define CONFIGURATION_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define FILESYSTEM_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SYSTEM_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define FILEMONITOR_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define VECTOR_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SHA1_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define CONSTRUCT_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define PROCREG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SQLPROXY_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define TYPELIB_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define JSON_EMITTER_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SERVICE_SOURCE
#  ifndef __NO_SQL__
#    ifndef __NO_OPTIONS__
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.    and not NO_SQL and not NO_OPTIONS   */
#      define SQLGETOPTION_SOURCE
#    endif
#  endif
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define PSI_SOURCE
#  ifdef _MSC_VER
#    ifndef JPEG_SOURCE
//wouldn't matter... the external things wouldn't need to define this
//#error projects were not generated with CMAKE, and JPEG_SORUCE needs to be defined
#    endif
//#define JPEG_SOURCE
//#define __PNG_LIBRARY_SOURCE__
//#define FT2_BUILD_LIBRARY   // freetype is internal
//#define FREETYPE_SOURCE		// build Dll Export
#  endif
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define MNG_BUILD_DLL
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define BAGIMAGE_EXPORTS
/* Defined when SACK_BAG_EXPORTS is defined. This was an
 individual library module once upon a time.           */
#ifndef IMAGE_LIBRARY_SOURCE
#  define IMAGE_LIBRARY_SOURCE
#endif
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SYSTRAY_LIBRARAY
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SOURCE_PSI2
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define VIDEO_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
	/* define RENDER SOURCE when building monolithic. */
#     ifndef RENDER_LIBRARY_SOURCE
#       define RENDER_LIBRARY_SOURCE
#     endif
// define a type that is a public name struct type...
// good thing that typedef and struct were split
// during the process of port to /clr option.
//#define PUBLIC_TYPE public
#  else
//#define PUBLIC_TYPE
#    ifdef __cplusplus_CLR
//using namespace System;
#    endif
#  endif
#endif
 // wchar for X_16 definition
#include <wchar.h>
#include <sys/types.h>
#include <sys/stat.h>
#if !defined( _WIN32 ) && !defined( __MAC__ )
#  include <syscall.h>
#elif defined( __MAC__ )
#  include <sys/syscall.h>
#endif
#ifndef MY_TYPES_INCLUDED
#  define MY_TYPES_INCLUDED
// include this before anything else
// thereby allowing us to redefine exit()
 // CHAR_BIT
#  include <limits.h>
 // typelib requires this
#  include <stdarg.h>
#  ifdef _MSC_VER
#    ifndef UNDER_CE
 // memlib requires this, and it MUST be included befoer string.h if it is used.
#      include <intrin.h>
#    endif
#  endif
 // typelib requires this
#  include <string.h>
#  if !defined( WIN32 ) && !defined( _WIN32 ) && !defined( _PNACL )
#    include <dlfcn.h>
#  endif
#  if defined( _MSC_VER )
// disable pointer conversion warnings - wish I could disable this
// according to types...
//#pragma warning( disable:4312; disable:4311 )
// disable deprication warnings of snprintf, et al.
//#pragma warning( disable:4996 )
#    define EMPTY_STRUCT struct { char nothing[]; }
#  endif
#  if defined( __WATCOMC__ )
#     define EMPTY_STRUCT char
#  endif
#  ifdef __cplusplus
/* Could also consider defining 'SACK_NAMESPACE' as 'extern "C"
   ' {' and '..._END' as '}'                                    */
#    define SACK_NAMESPACE namespace sack {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define SACK_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _CONTAINER_NAMESPACE namespace containers {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _CONTAINER_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _LINKLIST_NAMESPACE namespace list {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _LINKLIST_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _DATALIST_NAMESPACE namespace data_list {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _DATALIST_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _SETS_NAMESPACE namespace sets {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _SETS_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _TEXT_NAMESPACE namespace text {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _TEXT_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define TEXT_NAMESPACE SACK_NAMESPACE _CONTAINER_NAMESPACE namespace text {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define TEXT_NAMESPACE_END  } _CONTAINER_NAMESPACE_END SACK_NAMESPACE_END
#  else
/* Define the sack namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define SACK_NAMESPACE
/* Define the sack namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define SACK_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _CONTAINER_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _CONTAINER_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _LINKLIST_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _LINKLIST_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _DATALIST_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _DATALIST_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _SETS_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _SETS_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _TEXT_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _TEXT_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define TEXT_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define TEXT_NAMESPACE_END
#  endif
/* declare composite SACK_CONTAINER namespace to declare sack::container in a single line */
#  define SACK_CONTAINER_NAMESPACE SACK_NAMESPACE _CONTAINER_NAMESPACE
/* declare composite SACK_CONTAINER namespace to close sack::container in a single line */
#  define SACK_CONTAINER_NAMESPACE_END _CONTAINER_NAMESPACE_END SACK_NAMESPACE_END
/* declare composite SACK_CONTAINER namespace to declare sack::container::list in a single line */
#  define SACK_CONTAINER_LINKLIST_NAMESPACE SACK_CONTAINER_NAMESPACE _LISTLIST_NAMESPACE
/* declare composite SACK_CONTAINER namespace to close sack::container::list in a single line */
#  define SACK_CONTAINER_LINKLIST_NAMESPACE_END _LISTLIST_NAMESPACE_END SACK_CONTAINER_NAMESPACE
// this symbols is defined to enforce
// the C Procedure standard - using a stack, and resulting
// in EDX:EAX etc...
#  define CPROC
#  ifdef SACK_BAG_EXPORTS
#    ifdef BUILD_GLUE
// this is used as the export method appropriate for C#?
#      define EXPORT_METHOD [DllImport(LibName)] public
#    else
#      ifdef __cplusplus_cli
#        if defined( __STATIC__ ) || defined( __LINUX__ ) || defined( __ANDROID__ )
#          define EXPORT_METHOD
#          define IMPORT_METHOD extern
#        else
#          define EXPORT_METHOD __declspec(dllexport)
#          define IMPORT_METHOD __declspec(dllimport)
#        endif
#        define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#        define LITERAL_LIB_IMPORT_METHOD extern
//__declspec(dllimport)
#      else
#        if defined( __STATIC__ ) || defined( __LINUX__ ) || defined( __ANDROID__ )
#          define EXPORT_METHOD
#          define IMPORT_METHOD extern
#        else
/* Method to declare functions exported from a DLL. (nothign on
   LINUX or building statically, but __declspec(dllimport) on
   windows )                                                    */
#          define EXPORT_METHOD __declspec(dllexport)
/* method to define a function which will be Imported from a
   library. Under windows, this is probably
   __declspec(dllimport). Under linux this is probably 'extern'. */
#          define IMPORT_METHOD __declspec(dllimport)
#        endif
#        define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#        define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
#      endif
#    endif
#  else
#  if ( !defined( __STATIC__ ) && defined( WIN32 ) && !defined( __cplusplus_cli) )
#    define EXPORT_METHOD __declspec(dllexport)
#    define IMPORT_METHOD __declspec(dllimport)
#    define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#    define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
#  else
// MRT:  This is needed.  Need to see what may be defined wrong and fix it.
#    if defined( __LINUX__ ) || defined( __STATIC__ ) || defined( __ANDROID__ )
#      define EXPORT_METHOD
#      define IMPORT_METHOD extern
#      define LITERAL_LIB_EXPORT_METHOD
#      define LITERAL_LIB_IMPORT_METHOD extern
#    else
#      define EXPORT_METHOD __declspec(dllexport)
#      define IMPORT_METHOD __declspec(dllimport)
/* Define how methods in LITERAL_LIBRARIES are exported.
   literal_libraries are libraries that are used for plugins,
   and are dynamically loaded by code. They break the rules of
   system prefix and suffix extensions. LITERAL_LIBRARIES are
   always dynamic, and never static.                           */
#      define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
/* Define how methods in LITERAL_LIBRARIES are imported.
   literal_libraries are libraries that are used for plugins,
   and are dynamically loaded by code. They break the rules of
   system prefix and suffix extensions. LITERAL_LIBRARIES are
   always dynamic, and never static.                           */
#      define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
#    endif
#  endif
#endif
#ifdef __EMSCRIPTEN__
#include <emscripten.h>
#include <emscripten/emscripten.h>
// Emscripten exports just need to be not optimized out.
#  undef  EXPORT_METHOD
#  define EXPORT_METHOD                EMSCRIPTEN_KEEPALIVE
#  undef  LITERAL_LIB_EXPORT_METHOD
#  define LITERAL_LIB_EXPORT_METHOD    EMSCRIPTEN_KEEPALIVE
#endif
// used when the keword specifying a structure is packed
// needs to prefix the struct keyword.
#define PREFIX_PACKED
// private thing left as a note, and forgotten.  some compilers did not define offsetof
#define my_offsetof( ppstruc, member ) ((uintptr_t)&((*ppstruc)->member)) - ((uintptr_t)(*ppstruc))
SACK_NAMESPACE
#ifdef BCC16
#define __inline__
#define MAINPROC(type,name)     type _pascal name
// winproc is intended for use at libmain/wep/winmain...
#define WINPROC(type,name)      type _far _pascal _export name
// callbackproc is for things like timers, dlgprocs, wndprocs...
#define CALLBACKPROC(type,name) type _far _pascal _export name
#define PUBLIC(type,name)       type STDPROC _export name
 /* here would be if dwReason == process_attach */
#define LIBMAIN() WINPROC(int, LibMain)(HINSTANCE hInstance, WORD wDataSeg, WORD wHeapSize, LPSTR lpCmdLine )		 { {
 /* end if */
 /*endproc*/
#define LIBEXIT() } }	    int STDPROC WEP(int nSystemExit )  {
#define LIBMAIN_END()  }
// should use this define for all local defines...
// this will allow one place to modify ALL _pascal or not to _pascal decls.
#define STDPROC _far _pascal
#endif
#if defined( __LCC__ ) || defined( _MSC_VER ) || defined(__DMC__) || defined( __WATCOMC__ )
#ifdef __WATCOMC__
#undef CPROC
#define CPROC __cdecl
#define STDPROC __cdecl
#ifndef __WATCOMC__
// watcom windef.h headers define this
#define STDCALL _stdcall
#endif
#if __WATCOMC__ >= 1280
// watcom windef.h headers no longer define this.
#define STDCALL __stdcall
#endif
#undef PREFIX_PACKED
#define PREFIX_PACKED _Packed
#else
#undef CPROC
//#error blah
#define CPROC __cdecl
#define STDPROC
#define STDCALL _stdcall
#endif
#define far
#define huge
#define near
#define _far
#define _huge
#define _near
/* portability type for porting legacy 16 bit applications. */
/* portability macro for legacy 16 bit applications. */
#define __far
#ifndef FAR
#define FAR
#endif
//#define HUGE
//#ifndef NEAR
//#define NEAR
//#endif
#define _fastcall
#ifdef __cplusplus
#ifdef __cplusplus_cli
#define PUBLIC(type,name) extern "C"  LITERAL_LIB_EXPORT_METHOD type CPROC name
#else
//#error what the hell!?
// okay Public functions are meant to be loaded with LoadFuncion( "library" , "function name"  );
#define PUBLIC(type,name) extern "C"  LITERAL_LIB_EXPORT_METHOD type CPROC name
#endif
#else
#define PUBLIC(type,name) LITERAL_LIB_EXPORT_METHOD type CPROC name
#endif
#define MAINPROC(type,name)  type WINAPI name
#define WINPROC(type,name)   type WINAPI name
#define CALLBACKPROC(type,name) type CALLBACK name
#if defined( __WATCOMC__ )
#define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(TARGETNAME) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#define LIBMAIN_END() }
#else
#ifdef TARGETNAME
#define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(TARGETNAME) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#else
#define LIBMAIN()   TARGETNAME_NOT_DEFINED
#endif
#define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#define LIBMAIN_END() }
#endif
#define PACKED
#endif
#if defined( __GNUC__ )
#  ifndef STDPROC
#    define STDPROC
#  endif
#  ifndef STDCALL
 // for IsBadCodePtr which isn't a linux function...
#    define STDCALL
#  endif
#  ifndef WINAPI
#    ifdef __LINUX__
#       define WINAPI
#    else
#       define WINAPI __stdcall
#    endif
#  endif
#  ifndef PASCAL
//#define PASCAL
#  endif
#  define WINPROC(type,name)   type WINAPI name
#  define CALLBACKPROC( type, name ) type name
#  define PUBLIC(type,name) EXPORT_METHOD type CPROC name
#  define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(TARGETNAME) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#  define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#  define LIBMAIN_END()  }
/* Portability Macro for porting legacy code forward. */
#  define FAR
#  define NEAR
//#define HUGE
#  define far
#  define near
#  define huge
#  define PACKED __attribute__((packed))
#endif
#if defined( BCC32 )
#define far
#define huge
/* define obsolete keyword for porting purposes */
/* defined for porting from 16 bit environments */
#define near
/* portability macro for legacy 16 bit applications. */
#define _far
#define _huge
#define _near
/* portability type for porting to compilers that don't inline. */
/* portability macro for legacy 16 bit applications. */
#define __inline__
#define MAINPROC(type,name)     type _pascal name
// winproc is intended for use at libmain/wep/winmain...
#define WINPROC(type,name)      EXPORT_METHOD type _pascal name
// callbackproc is for things like timers, dlgprocs, wndprocs...
#define CALLBACKPROC(type,name) EXPORT_METHOD type _stdcall name
#define STDCALL _stdcall
#define PUBLIC(type,name)        type STDPROC name
#ifdef __STATIC__
			/*Log( "Library Enter" );*/
#define LIBMAIN() static WINPROC(int, LibMain)(HINSTANCE hInstance, DWORD dwReason, void *unused )		 { if( dwReason == DLL_PROCESS_ATTACH ) {
 /* end if */
#define LIBEXIT() } if( dwReason == DLL_PROCESS_DETACH ) {
#define LIBMAIN_END()  } return 1; }
#else
			/*Log( "Library Enter" );*/
#define LIBMAIN() WINPROC(int, LibMain)(HINSTANCE hInstance, DWORD dwReason, void *unused )		 { if( dwReason == DLL_PROCESS_ATTACH ) {
 /* end if */
#define LIBEXIT() } if( dwReason == DLL_PROCESS_DETACH ) {
#define LIBMAIN_END()  } return 1; }
#endif
// should use this define for all local defines...
// this will allow one place to modify ALL _pascal or not to _pascal decls.
#define STDPROC _pascal
#define PACKED
#endif
#define TOCHR(n) #n[0]
#define TOSTR(n) #n
#define STRSYM(n) TOSTR(n)
#define _WIDE__FILE__(n) n
#define WIDE__FILE__ _WIDE__FILE__(__FILE__)
/* a constant text string that represents the current source
   filename and line... fourmated as "source.c(11) :"        */
#define FILELINE  TEXT(__FILE__) "(" TEXT(STRSYM(__LINE__))" : ")
#if defined( _MSC_VER ) || defined( __PPCCPP__ )
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnote(msg) message( FILELINE msg )
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnoteonly(msg) message( msg )
#else
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnote(msg) msg
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnoteonly(msg) msg
#endif
/* specify a consistant macro to pass current file and line information.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_SRC         , __FILE__, __LINE__
/* specify a consistant macro to pass current file and line information, to functions which void param lists.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDSRC     __FILE__, __LINE__
//#define FILELINE_LEADSRC     __FILE__, __LINE__,
/* specify a consistant macro to define file and line parameters, to functions with otherwise void param lists.  This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDPASS    CTEXTSTR pFile, uint32_t nLine
//#define FILELINE_LEADPASS    CTEXTSTR pFile, uint32_t nLine,
/* specify a consistant macro to define file and line parameters.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_PASS        , CTEXTSTR pFile, uint32_t nLine
/* specify a consistant macro to forward file and line parameters.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_RELAY       , pFile, nLine
/* specify a consistant macro to forward file and line parameters.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_NULL        , NULL, 0
/* specify a consistant macro to forward file and line parameters, to functions which have void parameter lists without this information.  This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDRELAY   pFile, nLine
/* specify a consistant macro to format file and line information for printf formated strings. */
#define FILELINE_FILELINEFMT "%s(%" _32f "): "
#define FILELINE_FILELINEFMT_MIN "%s(%" _32f ")"
#define FILELINE_NULL        , NULL, 0
#define FILELINE_VOIDNULL    NULL, 0
/* define static parameters which are the declaration's current file and line, for stubbing in where debugging is being stripped.
  usage
    FILELINE_VARSRC: // declare pFile and nLine variables.
	*/
#define FILELINE_VARSRC       CTEXTSTR pFile = __FILE__; uint32_t nLine = __LINE__
// this is for passing FILE, LINE information to allocate
// useful during DEBUG phases only...
// drop out these debug relay paramters for managed code...
// we're going to have the full call frame managed and known...
#if !defined( _DEBUG ) && !defined( _DEBUG_INFO )
#  if defined( __LINUX__ ) && !defined( __PPCCPP__ )
//#warning "Setting DBG_PASS and DBG_FORWARD to be ignored."
#  else
//#pragma pragnoteonly("Setting DBG_PASS and DBG_FORWARD to be ignored"  )
#  endif
#define DBG_AVAILABLE   0
/* in NDEBUG mode, pass nothing */
#define DBG_SRC
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_VOIDSRC
/* <combine sack::DBG_PASS>
   \#define DBG_LEADSRC in NDEBUG mode, declare (void) */
/* <combine sack::DBG_PASS>
   \ \                      */
#define DBG_VOIDPASS    void
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_PASS
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_RELAY
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_NULL */
#define DBG_NULL
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_VOIDRELAY
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_FILELINEFMT
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_FILELINEFMT_MIN
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing
   Example
   printf( DBG_FILELINEFMT ": extra message" DBG_PASS ); */
#define DBG_VARSRC
#else
	// these DBG_ formats are commented out from duplication in sharemem.h
#  if defined( __LINUX__ ) && !defined( __PPCCPP__ )
//#warning "Setting DBG_PASS and DBG_FORWARD to work."
#  else
//#pragma pragnoteonly("Setting DBG_PASS and DBG_FORWARD to work"  )
#  endif
// used to specify whether debug information is being passed - can be referenced in compiled code
#define DBG_AVAILABLE   1
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_SRC */
#define DBG_SRC         FILELINE_SRC
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDSRC */
#define DBG_VOIDSRC     FILELINE_VOIDSRC
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDPASS */
#define DBG_VOIDPASS    FILELINE_VOIDPASS
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
/* Example
   This example shows forwarding debug information through a
   chain of routines.
   <code lang="c++">
   void ReportFunction( int sum DBG_PASS )
   {
       printf( "%s(%d):started this whole mess\\n" DBG_RELAY );
   }
   void TrackingFunction( int a, int b DBG_PASS )
   {
       ReportFunction( a+b, DBG_RELAY );
   }
   void CallTrack( void )
   {
       TrackingFunction( 1, 2 DBG_SRC );
   }
   </code>
   In this example, the debug information is passed to the
   logging system. This allows logging to blame the user
   application for allocations, releases, locks, etc...
   <code lang="c++">
   void MyAlloc( int size DBG_PASS )
   {
       _lprintf( DBG_RELAY )( ": alloc %d\\n", size );
   }
   void g( void )
   {
       lprintf( "Will Allocate %d\\n", 32 );
       MyAlloc( 32 DBG_SRC );
   }
   </code>
   This example uses the void argument macros
   <code>
   void SimpleFunction( DBG_VOIDPASS )
   {
       // this function usually has (void) parameters.
   }
   void f( void )
   {
       SimpleFunction( DBG_VOIDSRC );
   }
   </code>
   Description
   in NDEBUG mode, pass nothing.
   This function allows specification of DBG_RELAY or DBG_SRC
   under debug compilation. Otherwise, the simple AddLink macro
   should be used. DBG_RELAY can be used to forward file and
   line information which has been passed via DBG_PASS
   declaration in the function parameters.
   This is a part of a set of macros which allow additional
   logging information to be passed.
   These 3 are the most commonly used.
   DBG_SRC - this passes the current __FILE__, __LINE__
   \parameters.
   DBG_PASS - this is used on a function declaration, is a
   filename and line number from DBG_SRC or DBG_RELAY.
   DBG_RELAY - this passes the file and line passed to this
   function to another function with DBG_PASS defined on it.
   DBG_VOIDPASS - used when the argument list is ( void )
   without debugging information.
   DBG_VOIDSRC - used to call a function who's argument list is
   ( void ) without debugging information.
   DBG_VOIDRELAY - pass file and line information forward to
   another function, who's argument list is ( void ) without
   debugging information.
   Remarks
   The SACK library is highly instrumented with this sort of
   information. Very commonly the only difference between a
   specific function called 'MyFunctionName' and
   'MyFunctionNameEx' is the addition of debug information
   tracking.
   The following code blocks show the evolution added to add
   instrumentation...
   <code lang="c++">
   int MyFunction( int param )
   {
       // do stuff
   }
   int CallingFunction( void )
   {
       return MyFunction();
   }
   </code>
   Pretty simple code, a function that takes a parameter, and a
   function that calls it.
   The first thing is to extend the called function.
   <code>
   int MyFunctionEx( int param DBG_PASS )
   {
       // do stuff
   }
   </code>
   And provide a macro for everyone else calling the function to
   automatically pass their file and line information
   <code lang="c++">
   \#define MyFunction(param)  MyFunctionEx(param DBG_SRC)
   </code>
   Then all-together
   <code>
   \#define MyFunction(param)  MyFunctionEx(param DBG_SRC)
   int MyFunctionEx( int param DBG_PASS )
   {
       // do stuff
   }
   int CallingFunction( void )
   {
       // and this person calling doesn't matter
       // does require a recompile of source.
       return MyFunction( 3 );
   }
   </code>
   But then... what if CallingFunction decided wasn't really the
   one at fault, or responsible for the allocation, or other
   issue being tracked, then she could be extended....
   <code>
   int CallingFunctionEx( DBG_VOIDPASS )
   \#define CallingFunction() CallingFunction( DBG_VOIDSRC )
   {
       // and this person calling doesn't matter
       // does require a recompile of source.
       return MyFunction( 1 DBG_RELAY );
   }
   </code>
   Now, calling function will pass it's callers information to
   MyFunction....
   Why?
   Now, when you call CreateList, your code callng the list
   creation method is marked as the one who allocates the space.
   Or on a DeleteList, rather than some internal library code
   being blamed, the actual culprit can be tracked and
   identified, because it's surely not the fault of CreateList
   that the reference to the memory for the list wasn't managed
   correctly.
   Note
   It is important to note, every usage of these macros does not
   have a ',' before them. This allows non-debug code to
   eliminate these extra parameters cleanly. If the ',' was
   outside of the macro, then it would remain on the line, and
   an extra parameter would have be be passed that was unused.
   This is also why DBG_VOIDPASS exists, because in release mode
   this is substituted with 'void'.
   In Release mode, DBG_VOIDRELAY becomes nothing, but when in
   debug mode, DBG_RELAY has a ',' in the macro, so without a
   paramter f( DBG_RELAY ) would fail; on expansion this would
   be f( , pFile, nLine ); (note the extra comma, with no
   parameter would be a syntax error.                            */
#define DBG_PASS        FILELINE_PASS
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_RELAY */
#define DBG_RELAY       FILELINE_RELAY
/* <combine sack::DBG_PASS>
	  in _DEBUG mode, pass FILELINE_NULL */
#define DBG_NULL        FILELINE_NULL
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDRELAY */
#define DBG_VOIDRELAY   FILELINE_VOIDRELAY
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_FILELINEFMT */
#define DBG_FILELINEFMT FILELINE_FILELINEFMT
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_FILELINEFMT_MIN */
#define DBG_FILELINEFMT_MIN FILELINE_FILELINEFMT_MIN
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VARSRC */
#define DBG_VARSRC      FILELINE_VARSRC
#endif
// cannot declare _0 since that overloads the
// vector library definition for origin (0,0,0,0,...)
//typedef void             _0; // totally unusable to declare 0 size things.
/* the only type other than when used in a function declaration that void is valid is as a pointer to void. no _0 type exists
	 (it does, but it's in vectlib, and is an origin vector)*/
typedef void             *P_0;
/*
 * several compilers are rather picky about the types of data
 * used for bit field declaration, therefore this type
 * should be used instead of uint32_t (DWORD)
 */
typedef unsigned int  BIT_FIELD;
/*
 * several compilers are rather picky about the types of data
 * used for bit field declaration, therefore this type
 * should be used instead of int32_t (LONG)
 */
typedef int  SBIT_FIELD;
// have to do this on a per structure basis - otherwise
// any included headers with structures to use will get
// padded as normal; this is appended to a strcture
// and is ued on GCC comiplers for __attribute__((packed))
#ifndef PACKED
#  define PACKED
#endif
/* An pointer to a volatile unsigned integer type that is 64 bits long. */
//typedef volatile uint64_t  *volatile int64_t*;
/* An pointer to a volatile pointer size type that is as long as a pointer. */
typedef volatile uintptr_t        *PVPTRSZVAL;
/* an unsigned type meant to index arrays.  (By convention, arrays are not indexed negatively.)  An index which is not valid is INVALID_INDEX, which equates to 0xFFFFFFFFUL or negative one cast as an INDEX... ((INDEX)-1). */
typedef size_t         INDEX;
/* An index which is not valid; equates to 0xFFFFFFFFUL or negative one cast as an INDEX... ((INDEX)-1). */
#define INVALID_INDEX ((INDEX)-1)
// constant text string content
typedef const char     *CTEXTSTR;
/* A non constant array of TEXTCHAR. A pointer to TEXTCHAR. A
   pointer to non-constant characters. (A non-static string
   probably)                                                  */
typedef char           *TEXTSTR;
#if defined( __LINUX__ ) && defined( __cplusplus )
// pointer to constant text string content
typedef TEXTSTR const  *PCTEXTSTR;
#else
// char const *const *
typedef CTEXTSTR const *PCTEXTSTR;
#endif
/* a text 8 bit character  */
typedef char            TEXTCHAR;
/* a character rune.  Strings should be interpreted as UTF-8 or 16 depending on UNICODE compile option.
   GetUtfChar() from strings.  */
typedef uint32_t             TEXTRUNE;
/* Used to handle returned values that are invalid runes; past end or beginning of string for instance */
#define INVALID_RUNE  0x80000000
//typedef enum { FALSE, TRUE } LOGICAL; // smallest information
#ifndef FALSE
#define FALSE 0
/* Define TRUE when not previously defined in the platform. TRUE
   is (!FALSE) so anything not 0 is true.                        */
#define TRUE (!FALSE)
#endif
/* Meant to hold boolean and only boolean values. Should be
   implemented per-platform as appropriate for the bool type the
   compiler provides.                                            */
typedef uint32_t LOGICAL;
/* This is a pointer. It is a void*. It is meant to point to a
   single thing, and cannot be used to reference arrays of bytes
   without recasting.                                            */
typedef P_0 POINTER;
/* This is a pointer to constant data. void const *. Compatible
   with things like char const *.                               */
typedef const void *CPOINTER;
SACK_NAMESPACE_END
//------------------------------------------------------
// formatting macro defintions for [vsf]printf output of the above types
#if !defined( _MSC_VER ) || ( _MSC_VER >= 1900 )
#define __STDC_FORMAT_MACROS
#include <inttypes.h>
#endif
SACK_NAMESPACE
/* 16 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16f   "u"
/* 16 bit hex output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16fx   "x"
/* 16 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16fX   "X"
/* 16 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\>               */
#define _16fs   "d"
/* 8 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8f   "u"
/* 8 bit hex output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8fx   "x"
/* 8 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8fX   "X"
/* 8 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\>               */
#define _8fs   "d"
#if defined( __STDC_FORMAT_MACROS )
#  define _32f   PRIu32
#  define _32fx    PRIx32
#  define _32fX    PRIX32
#  define _32fs    PRId32
#  define _64f    PRIu64
#  define _64fx   PRIx64
#  define _64fX   PRIX64
#  define _64fs   PRId64
#  define _64f    PRIu64
#  define _64fx   PRIx64
#  define _64fX   PRIX64
#  define _64fs   PRId64
// non-unicode strings
#  define c_32f    PRIu32
#  define c_32fx   PRIx32
#  define c_32fX   PRIX32
#  define c_32fs   PRId32
#  define c_64f    PRIu64
#  define c_64fx   PRIx64
#  define c_64fX   PRIX64
#  define c_64fs   PRId64
#else
#  define _32f   "u"
#  define _32fx   "x"
#  define _32fX   "X"
#  define _32fs   "d"
#  define c_32f   "u"
#  define c_32fx  "x"
#  define c_32fX  "X"
#  define c_32fs  "d"
#  define c_64f    "llu"
#  define c_64fx   "llx"
#  define c_64fX   "llX"
#  define c_64fs   "lld"
#endif
#  define _cstring_f "s"
#  define _string_f "s"
#  define _ustring_f "S"
#if defined( __64__ )
#  if defined( __STDC_FORMAT_MACROS )
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f     PRIu64
#      define _size_fx    PRIx64
#      define _size_fX    PRIX64
#      define _size_fs    PRId64
#      define c_size_f    PRIu64
#      define c_size_fx   PRIx64
#      define c_size_fX   PRIX64
#      define c_size_fs   PRId64
#    else
#      define _size_f    "zu"
#      define _size_fx   "zx"
#      define _size_fX   "zX"
#      define _size_fs   "zd"
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs  PRIuPTR
#    define _PTRSZVALfx  PRIxPTR
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  else
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f    _64f
#      define _size_fx   _64fx
#      define _size_fX   _64fX
#      define _size_fs   _64fs
#      define c_size_f   c_64f
#      define c_size_fx  c_64fx
#      define c_size_fX  c_64fX
#      define c_size_fs  c_64fs
#    else
#      define _size_f    "zu"
#      define _size_fx   "zx"
#      define _size_fX   "zX"
#      define _size_fs   "zd"
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs  PRIuPTR
#    define _PTRSZVALfx  PRIxPTR
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  endif
#else
#  if defined( __STDC_FORMAT_MACROS )
      // this HAS been fixed in UCRT - 2015!  but it'll take 5 years before everyone has that...
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f     PRIu32
#      define _size_fx    PRIx32
#      define _size_fX    PRIX32
#      define _size_fs    PRId32
#      define c_size_f    PRIu32
#      define c_size_fx   PRIx32
#      define c_size_fX   PRIX32
#      define c_size_fs   PRId32
#    else
#      define _size_f    "zu"
#      define _size_fx   "zx"
#      define _size_fX   "zX"
#      define _size_fs   "zd"
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs  PRIuPTR
#    define _PTRSZVALfx  PRIxPTR
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  else
      // this HAS been fixed in UCRT - 2015!  but it'll take 5 years before everyone has that...
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f    _32f
#      define _size_fx   _32fx
#      define _size_fX   _32fX
#      define _size_fs   _32fs
#      define c_size_f    c_32f
#      define c_size_fx   c_32fx
#      define c_size_fX   c_32fX
#      define c_size_fs   c_32fs
#    else
#      define _size_f    "zu"
#      define _size_fx   "zx"
#      define _size_fX   "zX"
#      define _size_fs   "zd"
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs  PRIuPTR
#    define _PTRSZVALfx  PRIxPTR
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  endif
#endif
#define PTRSZVALf "p"
#define _PTRSZVALf "p"
#if defined( _MSC_VER ) && ( _MSC_VER < 1900 )
/* 64 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIu64              */
#define _64f    "llu"
/* 64 bit hex output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIxFAST64                */
#define _64fx   "llx"
/* 64 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIxFAST64                */
#define _64fX   "llX"
/* 64 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\> as PRIdFAST64               */
#define _64fs   "lld"
#endif
// This should be for several years a
// sufficiently large type to represent
// threads and processes.
typedef uint64_t THREAD_ID;
#define GetMyThreadIDNL GetMyThreadID
#if defined( _WIN32 )
#  define _GetMyThreadID()  ( (( ((uint64_t)GetCurrentProcessId()) << 32 ) | ( (uint64_t)GetCurrentThreadId() ) ) )
#  define GetMyThreadID()  (GetThisThreadID())
#else
// this is now always the case
// it's a safer solution anyhow...
#  ifdef __MAC__
#    define GetMyThreadID()  (( ((uint64_t)getpid()) << 32 ) | ( (uint64_t)( syscall(SYS_thread_selfid) ) ) )
#  else
#    ifndef GETPID_RETURNS_PPID
#      define GETPID_RETURNS_PPID
#    endif
#    ifdef GETPID_RETURNS_PPID
#      ifdef __ANDROID__
#        define GetMyThreadID()  (( ((uint64_t)getpid()) << 32 ) | ( (uint64_t)(gettid()) ) )
#      else
#        if defined( __EMSCRIPTEN__ )
#          define GetMyThreadID()  ( (uint64_t)(pthread_self()) )
#        else
#          define GetMyThreadID()  (( ((uint64_t)getpid()) << 32 ) | ( (uint64_t)(syscall(SYS_gettid)) ) )
#        endif
#      endif
#    else
#      define GetMyThreadID()  (( ((uint64_t)getppid()) << 32 ) | ( (uint64_t)(getpid()|0x40000000)) )
#    endif
#  endif
#  define _GetMyThreadID GetMyThreadID
#endif
//---------------------- Declare Link; 'single and a half'ly-linked lists -----------------------
// Thse macros are for linking and unlininking things in a linked list.
// The list is basically a singly-linked list, but also references the pointer that
// is pointing at the current node.  This simplifies insert/remove operations, because
// the specific list that the node is in, is not required.
// List heads will always be updated correctly.
//
// A few 'tricks' are available, such as
//     0) These are deemed dangerous; and uncomprehendable by anyone but the maintainer.
//        use at your own time and expense required to explain WHY these work.
//     1) when declaring a root node, include another node before it, and it's
//        simple to make this a circularly linked list.
//     2) defining DeclareLink at the start of the strcture, the 'me' pointer
//        also happens to be 'prior', so you can step through the list in both
//        directions.
//
//
//
// struct my_node {
//    DeclareLink( struct my_node );
//    // ...
// };
//
// that declares
//      struct my_node *next;  // the next node in list.
//      struct my_node **me;   // address of the pointer pointing to 'me';
//
//
//  struct my_node *root; // a root of a list of my_node.  It should be initialized to NULL.
//
//  struct my_node *newNode = (struct my_node*)malloc( sizeof( *newNode ) );
//     // does not require next or me to be initiialized.
//  LinkThing( root, newNode );
//     // now newNode is in the list.
//
//  to remove from a list
//
//  struct my_node *someNode; // this should be a pointer to some valid node.
//  UnlinkThing( someNode );
//     The new node is now not in the list.
//
//  To move one node from one list to another
//
//   struct my_node *rootAvail;  // available nodes
//   struct my_node *rootUsed;   // nodes in use
//
//   struct my_node *someNode; // some node in a list
//   someNode = rootAvail; // get first available.
//   if( !someNode ) ; // create a new one or abort
//   RelinkThing( rootUsed, someNode );
//      'someNode' is removed from its existing list, and added to the 'rootUsed' list.
//
// For Declaring the link structure members for lists
#define DeclareLink( type )  type *next; type **me
/* Link a new node into the list.
   Example
   struct mynode
   {
       DeclareLink( struct mynode );
   } *node;
	struct mynode *list;
   // node allocation not shown.
	LinkThing( list_root, node );
*/
#define LinkThing( root, node )		     ((( (node)->next = (root) )?	        (((root)->me) = &((node)->next)):0),	  (((node)->me) = &(root)),	             ((root) = (node)) )
/* Link a node to the end of a list. LinkThing() inserts the new
 node as the new head of the list.
 this has to scan the list to find the end, so it is a O(n) operation.
 All other linked list operations are O(1)
 */
#define LinkLast( root, type, node ) if( node ) do { if( !root )	 { root = node; (node)->me=&root; }	 else { type tmp;	 for( tmp = root; tmp->next; tmp = tmp->next );	 tmp->next = (node);	 (node)->me = &tmp->next;	 } } while (0)
// put 'Thing' after 'node'
// inserts 'node' after Thing
#define LinkThingAfter( node, thing )	 ( ( (thing)&&(node))	   ?(((((thing)->next = (node)->next))?((node)->next->me = &(thing)->next):0)	  ,((thing)->me = &(node)->next), ((node)->next = thing))	  :((node)=(thing)) )
//
// put 'Thing' before 'node'... so (*node->me) = thing
// similar to LinkThingAfter but puts the new 'thing'
// before the 'node' specified.
#define LinkThingBefore( node, thing )	 {  thing->next = (*node->me);	(*node->me) = thing;    thing->me = node->me;       node->me = &thing->next;     }
// move a list from one list to another.
// unlinks node from where it was, inserts at the head of another.
// this can also be use to reproiritize within the same list.
#define RelinkThing( root, node )	   ((( node->me && ( (*node->me)=node->next ) )?	  node->next->me = node->me:0),(node->next = NULL),(node->me = NULL),node),	 ((( node->next = root )?	        (root->me = &node->next):0),	  (node->me = &root),	             (root = node) )
/* Remove a node from a list. Requires only the node. */
#define UnlinkThing( node )	                      ((( (node) && (node)->me && ( (*(node)->me)=(node)->next ) )?	  (node)->next->me = (node)->me:0),((node)->next = NULL),((node)->me = NULL),(node))
// this has two expressions duplicated...
// but in being so safe in this expression,
// the self-circular link needs to be duplicated.
// GrabThing is used for nodes which are circularly bound
#define GrabThing( node )	    ((node)?(((node)->me)?(((*(node)->me)=(node)->next)?	 ((node)->next->me=(node)->me),((node)->me=&(node)->next):NULL):((node)->me=&(node)->next)):NULL)
/* Go to the next node with links declared by DeclareLink
 safe iterator macro that tests if node is valid, which returns
 the next item in the list, else returns NULL
 */
#define NextLink(node) ((node)?(node)->next:NULL)
// everything else is called a thing... should probably migrate to using this...
#define NextThing(node) ((node)?(node)->next:NULL)
//----------- FLAG SETS (single bit fields) -----------------
/* the default type to use for flag sets - flag sets are arrays of bits
 which can be set/read with/as integer values an index.
 All of the fields in a maskset are the same width */
#define FLAGSETTYPE uintmax_t
/* the number of bits a specific type is.
   Example
   int bit_size_int = FLAGTYPEBITS( int ); */
#define FLAGTYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* how many bits to add to make sure we round to the next greater index if even 1 bit overflows */
#define FLAGROUND(t) (FLAGTYPEBITS(t)-1)
/* the index of the FLAGSETTYPE which contains the bit in question */
#define FLAGTYPE_INDEX(t,n)  (((n)+FLAGROUND(t))/FLAGTYPEBITS(t))
/* how big the flag set is in count of FLAGSETTYPEs required in a row ( size of the array of FLAGSETTYPE that contains n bits) */
#define FLAGSETSIZE(t,n) (FLAGTYPE_INDEX(t,n) * sizeof( FLAGSETTYPE ) )
// declare a set of flags...
#define FLAGSET(v,n)   FLAGSETTYPE (v)[((n)+FLAGROUND(FLAGSETTYPE))/FLAGTYPEBITS(FLAGSETTYPE)]
// set a single flag index
#define SETFLAG(v,n)   ( ( (v)[(n)/FLAGTYPEBITS((v)[0])] |= (FLAGSETTYPE)1 << ( (n) & FLAGROUND((v)[0]) )),1)
// clear a single flag index
#define RESETFLAG(v,n) ( ( (v)[(n)/FLAGTYPEBITS((v)[0])] &= ~( (FLAGSETTYPE)1 << ( (n) & FLAGROUND((v)[0]) ) ) ),0)
// test if a flags is set
//  result is 0 or not; the value returned is the bit shifted within the word, and not always '1'
#define TESTFLAG(v,n)  ( (v)[(n)/FLAGTYPEBITS((v)[0])] & ( (FLAGSETTYPE)1 << ( (n) & FLAGROUND((v)[0]) ) ) )
// reverse a flag from 1 to 0 and vice versa
// return value is undefined... and is a whole bunch of flags from some offset...
// if you want ot toggle and flag and test the result, use TESTGOGGLEFLAG() instead.
#define TOGGLEFLAG(v,n)   ( (v)[(n)/FLAGTYPEBITS((v)[0])] ^= (FLAGSETTYPE)1 << ( (n) & FLAGROUND((v)[0]) ))
// Toggle a bit, return the state of the bit after toggling.
#define TESTTOGGLEFLAG(v,n)  ( TOGGLEFLAG(v,n), TESTFLAG(v,n) )
//----------- MASK SETS -----------------
//  MASK Sets are arrays of bit-fields of some bit-width (5, 3, ... )
//  they are set/returned as integer values.
//  They are stored-in/accessed via a uint8_t which gives byte-offset calculations.
// they return their value as uintmax_t from the offset memory address directly;
//   Some platforms(Arm) may SIGBUS because of wide offset accesses spanning word boundaries.
//   This issue may be fixed by rounding, grabbing the word aligned values and shifting manually
// Declarataion/Instantiation of a mask set is done with MASKSET macro below
// 32 bits max for range on mask
#define MASK_MAX_LENGTH (sizeof(MASKSET_READTYPE)*CHAR_BIT)
/* gives a 32 bit mask possible from flagset..
 - updated; return max int possible; but only the low N bits will be set
 - mask sets are meant for small values, but could be used for like 21 bit fields. (another form of unicode encoding I suppose)
 */
#define MASKSET_READTYPE uintmax_t
// gives byte index...
#define MASKSETTYPE uint8_t
/* how many bits the type specified can hold
   Parameters
   t :  data type to measure (int, uint32_t, ... ) */
#define MASKTYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* the maximum number of bits storable in a type */
#define MASK_MAX_TYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* round up to the next count of types that fits 1 bit - used as a cieling round factor */
#define MASKROUND(t) (MASKTYPEBITS(t)-1)
/* define MAX_MAX_ROUND factor based on MASKSET_READTYPE - how to read it... */
#define MASK_MAX_ROUND() (MASK_MAX_TYPEBITS(MASKSET_READTYPE)-1)
/* byte index of the start of the mask
   Parameters
   t :  type to measure with
   n :  mask index                     */
#define MASKTYPE_INDEX(t,n)  (((n)+MASKROUND(t))/MASKTYPEBITS(t))
/* The number of bytes the set would be.
   Parameters
   t :  the given type to measure with
   n :  the count of masks to fit.       */
#define MASKSETSIZE(t,n) (MASKTYPE_INDEX(t,(n+1)))
// declare a set of flags...
#define MASK_TOP_MASK_VAL(length,val) ((val)&( ((MASKSET_READTYPE)-1) >> ((sizeof(MASKSET_READTYPE) * CHAR_BIT)-(length)) ))
/* the mask in the dword resulting from shift-right.   (gets a mask of X bits in length) */
#define MASK_TOP_MASK(length) ( ((MASKSET_READTYPE)-1) >> ((sizeof(MASKSET_READTYPE) * CHAR_BIT)-(length)) )
/* the mast in the dword shifted to the left to overlap the field in the word */
#define MASK_MASK(n,length)   (MASK_TOP_MASK(length) << (((n)*(length)) & (sizeof(MASKSET_READTYPE) - 1) ) )
// masks value with the mask size, then applies that mask back to the correct word indexing
#define MASK_MASK_VAL(n,length,val)   (MASK_TOP_MASK_VAL(length,val) << (((n)*(length))&0x7) )
/* declare a mask set.
 MASKSET( maskVariableName
        , 32 //number of items
		  , 5 // number of bits per field
		  );
   declares
	uint8_t maskVariableName[ (32*5 +(CHAR_BIT-1))/CHAR_BIT ];  //data array used for storage.
   const int askVariableName_mask_size = 5;  // used aautomatically by macros
*/
#define MASKSET(v,n,r)  MASKSETTYPE  (v)[(((n)*(r))+MASK_MAX_ROUND())/MASKTYPEBITS(MASKSETTYPE)]; const int v##_mask_size = r;
/* set a field index to a value
    SETMASK( askVariableName, 3, 13 );  // set set member 3 to the value '13'
 */
#define SETMASK(v,n,val)    (((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS((v)[0])))[0] =    ( ((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS(uint8_t)))[0]                                  & (~(MASK_MASK(n,v##_mask_size))) )	                                                                           | MASK_MASK_VAL(n,v##_mask_size,val) )
/* get the value of a field
     GETMASK( maskVariableName, 3 );   // returns '13' given the SETMASK() example code.
 */
#define GETMASK(v,n)  ( ( ((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS((v)[0])))[0]         & MASK_MASK(n,v##_mask_size) )	                                                                           >> (((n)*(v##_mask_size))&0x7))
/* This type stores data, it has a self-contained length in
   bytes of the data stored.  Length is in characters       */
_CONTAINER_NAMESPACE
/* LIST is a slab array of pointers, each pointer may be
   assigned to point to any user data.
   Remarks
   When the list is filled to the capacity of Cnt elements, the
   list is reallocated to be larger.
   Cannot add NULL pointer to list, empty elements in the list
   are represented with NULL, and may be filled by any non-NULL
   value.                                                       */
_LINKLIST_NAMESPACE
/* <combine sack::containers::list::LinkBlock>
   \ \                                         */
typedef struct LinkBlock
{
	/* How many pointers the list can contain now. */
	INDEX     Cnt;
	/* \ \  */
	POINTER pNode[1];
} LIST, *PLIST;
_LINKLIST_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::containers::list;
#endif
_DATALIST_NAMESPACE
/* a list of data structures... a slab array of N members of X size */
typedef struct DataBlock  DATALIST;
/* A typedef of a pointer to a DATALIST struct DataList. */
typedef struct DataBlock *PDATALIST;
/* Data Blocks are like LinkBlocks, and store blocks of data in
   slab format. If the count of elements exceeds available, the
   structure is grown, to always contain a continuous array of
   structures of Size size.
   Remarks
   When blocks are deleted, all subsequent blocks are shifted
   down in the array. So the free blocks are always at the end. */
struct DataBlock
{
	/* How many elements are used. */
	INDEX     Cnt;
	/* How many elements are available in his array. */
	INDEX     Avail;
	/* A simple exchange lock on the data for insert and delete. For
	   thread safety.                                                */
	//volatile uint32_t     Lock;
	/* How big each element of the array is. */
	INDEX     Size;
	/* The physical array. */
	uint8_t      data[1];
};
_DATALIST_NAMESPACE_END
/* This is a stack that contains pointers to user objects.
   Remarks
   This is a stack 'by reference'. When extended, the stack will
   occupy different memory, care must be taken to not duplicate
   pointers to this stack.                                       */
typedef struct LinkStack
{
	/* This is the index of the next pointer to be pushed or popped.
	   If top == 0, the stack is empty, until a pointer is added and
	   top is incremented.                                           */
	INDEX     Top;
	/* How many pointers the stack can contain. */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore. For
	                  thread safety.                                            */
	//volatile uint32_t     Lock;
	/*  a defined maximum capacity of stacked values... values beyond this are lost from the bottom  */
	uint32_t     Max;
	/* Reserved data portion that stores the pointers. */
	POINTER pNode[1];
} LINKSTACK, *PLINKSTACK;
/* A Stack that stores information in an array of structures of
   known size.
   Remarks
   The size of each element must be known at stack creation
   time. Structures are literally copied to and from this stack.
   This is a stack 'by value'. When extended, the stack will
   occupy different memory, care must be taken to not duplicate
   pointers to this stack.                                       */
typedef struct DataListStack
{
	volatile INDEX     Top;
 /* enable logging the program executable (probably the same for
	                all messages, unless they are network)
	                                                                             */
 // How many elements are on the stack.
	INDEX     Cnt;
	//volatile uint32_t     Lock;  /* thread interlock using InterlockedExchange semaphore. For
	//                  thread safety.                                            */
	INDEX     Size;
	INDEX     Max;
	uint8_t      data[1];
} DATASTACK, *PDATASTACK;
/* A queue which contains pointers to user objects. If the queue
   is filled to capacity and new queue is allocated, and all
   existing pointers are transferred.                            */
typedef struct LinkQueue
{
	/* This is the index of the next pointer to be added to the
	   queue. If Top==Bottom, then the queue is empty, until a
	   pointer is added to the queue, and Top is incremented.   */
	volatile INDEX     Top;
	/* This is the index of the next element to leave the queue. */
	volatile INDEX     Bottom;
	/* This is the current count of pointers that can be stored in
	   the queue.                                                  */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore. For
	   thread safety.                                            */
#if USE_CUSTOM_ALLOCER
	volatile uint32_t     Lock;
#endif
 // need two to have distinct empty/full conditions
	POINTER pNode[2];
} LINKQUEUE, *PLINKQUEUE;
/* A queue of structure elements.
   Remarks
   The size of each element must be known at stack creation
   time. Structures are literally copied to and from this stack.
   This is a stack 'by value'. When extended, the stack will
   occupy different memory, care must be taken to not duplicate
   pointers to this stack.                                       */
typedef struct DataQueue
{
	/* This is the next index to be added to. If Top==Bottom, the
	   queue is empty, until an entry is added at Top, and Top
	   increments.                                                */
	volatile INDEX     Top;
	/* The current bottom index. This is the next one to be
	   returned.                                            */
	volatile INDEX     Bottom;
	/* How many elements the queue can hold. If a queue has more
	   elements added to it than it has count, it will be expanded,
	   and a new queue returned.                                    */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore */
	//volatile uint32_t     Lock;
	/* How big each element in the queue is. */
	INDEX     Size;
	/* How many elements to expand the queue by, when its capacity
	   is reached.                                                 */
	INDEX     ExpandBy;
	/* The data area of the queue. */
	uint8_t      data[1];
} DATAQUEUE, *PDATAQUEUE;
/* A mostly obsolete function, but can return the status of
   whether all initially scheduled startups are completed. (Or
   maybe whether we are not complete, and are processing
   startups)                                                   */
_CONTAINER_NAMESPACE_END
SACK_NAMESPACE_END
/* This contains the methods to use the base container types
   defined in sack_types.h.                                  */
#ifndef LINKSTUFF
#define LINKSTUFF
	SACK_NAMESPACE
	_CONTAINER_NAMESPACE
#    define TYPELIB_CALLTYPE
#  if defined( _TYPELIBRARY_SOURCE_STEAL )
#    define TYPELIB_PROC extern
#  elif defined( NO_EXPORTS )
#    if defined( _TYPELIBRARY_SOURCE )
#      define TYPELIB_PROC
#    else
#      define TYPELIB_PROC extern
#    endif
#  elif defined( _TYPELIBRARY_SOURCE )
#    define TYPELIB_PROC EXPORT_METHOD
#  else
#    define TYPELIB_PROC IMPORT_METHOD
#  endif
_LINKLIST_NAMESPACE
//--------------------------------------------------------
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        CreateListEx   ( DBG_VOIDPASS );
/* Destroy a PLIST. */
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        DeleteListEx   ( PLIST *plist DBG_PASS );
/* See <link AddLink>.
   See <link DBG_PASS>. */
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        AddLinkEx      ( PLIST *pList, POINTER p DBG_PASS );
/* Sets the value of a link at the specified index.
   Parameters
   pList :     address of a PLIST
   idx :       index of the element to set
   p :         new link value to be set at the specified index
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        SetLinkEx      ( PLIST *pList, INDEX idx, POINTER p DBG_PASS );
/* Gets the link at the specified index.
   Parameters
   pList :  address of a PLIST pointer.
   idx :    index to get the link from.  */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      GetLink        ( PLIST *pList, INDEX idx );
/* Gets the address of the link node in the PLIST.
   Parameters
   pList :  address of a PLIST to get the node address
   idx :    index of the node to get the adddress of
   Example
   <code lang="c++">
   PLIST list = NULL; // don't have to use CreateList();
   POINTER *a;
   POINTER b;
   POINTER *result;
   a = &amp;b;
   AddLink( &amp;list, a );
   \result = GetLinkAddress( &amp;list, 0 );
    ( (*result) == b )
   </code>                                               */
TYPELIB_PROC  POINTER* TYPELIB_CALLTYPE     GetLinkAddress ( PLIST *pList, INDEX idx );
/* Locate a pointer in a PLIST. Return the index.
   Parameters
   pList :  address of a list pointer to locate link
   value :  link to find in the list
   Return Value List
   INVALID_INDEX :  Not found in the list
   0\-n :           Index of the first occurance of the link in the
                    list.                                           */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        FindLink       ( PLIST *pList, POINTER value );
/* return the count of used members in a PLIST
    pList : the list to count
	Return Value
	   number of things in the list.
*/
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        GetLinkCount   ( PLIST pList );
/* Uses FindLink on the list for the value to delete, and then
   sets the index of the found link to NULL.
   Parameters
   pList :  Address of a PLIST pointer
   value :  the link to find and remove from the list.
   Example
   <code lang="c++">
   PLIST list = NULL;
	POINTER a = &#47;*some address*&#47;;
   </code>
   <code>
   AddLink( &amp;list, a );
   DeleteLink( &amp;list, a );
   </code>                                                     */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      DeleteLink     ( PLIST *pList, CPOINTER value );
/* Remove all links from a PLIST. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyList      ( PLIST *pList );
#ifdef __cplusplus
/* This was a basic attempt to make list into a C++ class. I
   gave up doing this sort of thing afterwards after realizing
   the methods of a library and these static methods for a class
   aren't much different.                                        */
#  if defined( INCLUDE_SAMPLE_CPLUSPLUS_WRAPPERS )
typedef class iList
{
public:
	PLIST list;
	INDEX idx;
	inline iList() { list = CreateListEx( DBG_VOIDSRC ); }
	inline ~iList() { DeleteListEx( &list DBG_SRC ); }
	inline iList &operator+=( POINTER &p ){ AddLinkEx( &list, p DBG_SRC ); return *this; }
	inline void add( POINTER p ) { AddLinkEx( &list, p DBG_SRC ); }
	inline void remove( POINTER p ) { DeleteLink( &list, p ); }
	inline POINTER first( void ) { POINTER p; for( idx = 0, p = NULL;list && (idx < list->Cnt) && (( p = GetLink( &list, idx ) )==0); )idx++; return p; }
	inline POINTER next( void ) { POINTER p; for( idx++;list && (( p = GetLink( &list, idx ) )==0) && idx < list->Cnt; )idx++; return p; }
	inline POINTER get(INDEX index) { return GetLink( &list, index ); }
} *piList;
#  endif
#endif
// address of the thing...
typedef uintptr_t (CPROC *ForProc)( uintptr_t user, INDEX idx, POINTER *item );
// if the callback function returns non 0 - then the looping is aborted,
// and the value is returned... the user value is passed to the callback.
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE     ForAllLinks    ( PLIST *pList, ForProc func, uintptr_t user );
/* This is a iterator which can be used to check each member in
   a PLIST.
   Parameters
   list :     List to iterate through
   index :    variable to use to index the list
   type :     type of the elements stored in the list (for C++)
   pointer :  variable used to get the current member of the
              list.
   Example
   <code lang="c++">
   POINTER p;  // the pointer to receive the list member pointer (should be a user type)
   INDEX idx; // indexer
   PLIST pList; // some list.
   LIST_FORALL( pList, idx, POINTER, p )
   {
       // p will never be NULL here.
       // each link stored in the list is set to p here..
       // this is a way to remove this item from the list...
       SetLink( &amp;pList, idx, NULL );
       if( some condition )
          break;
   }
   </code>
   Another example that uses data and searches..
   <code lang="c++">
   PLIST pList = NULL;
   INDEX idx;
   CTEXTSTR string;
   AddLink( &amp;pList, (POINTER)"hello" );
   </code>
   <code>
   AddLink( &amp;pList, (POINTER)"world" );
   LITS_FORALL( pList, idx, CTEXTSTR, string )
   {
       if( strcmp( string, "hello" ) == 0 )
           break;
   }
   // here 'string' will be NULL if not found, else will be what was found
   </code>
   Remarks
   This initializes the parameters passed to the macro so that
   if the list is NULL or empty, then p will be set to NULL. If
   there are no non-nulll members in the list, p will be set to
   NULL. If you break in the loop, like in the case of searching
   the list for something, then p will be non-null at the end of
   the loop.
                                                                                         */
#define LIST_FORALL( l, i, t, v )  if(((v)=(t)NULL),(l))                                                        for( ((i)=0); ((i) < ((l)->Cnt))?                                         (((v)=(t)(uintptr_t)((l)->pNode[i])),1):(((v)=(t)NULL),0); (i)++ )  if( v )
/* This can be used to continue iterating through a list after a
   LIST_FORALL has been interrupted.
   Parameters
   list :     \Description
   index :    index variable for stepping through the list
   type :     type of the members in the list.
   pointer :  variable name to use to store the the current list
              element.
   Example
   <code lang="c++">
   PLIST pList = NULL;
   CTEXTSTR p;
   INDEX idx;
   </code>
   <code>
   AddLink( &amp;pList, "this" );
   AddLink( &amp;pList, "is" );
   AddLink( &amp;pList, "a" );
   AddLink( &amp;pList, "test" );
   LIST_FORALL( pList, idx, CTEXTSTR, p )
   {
       if( strcmp( p, "is" ) == 0 )
           break;
   }
   LIST_NEXTALL( pList, idx, CTEXTSTR, p )
   {
       printf( "remaining element : %s", p );
   }
   </code>
   <code lang="c++">
   j
   </code>                                                       */
#define LIST_NEXTALL( l, i, t, v )  if(l)                for( ++(i),((v)=(t)NULL); ((i) < ((l)->Cnt))?     (((v)=(t)(l)->pNode[i]),1):(((v)=(t)NULL),0); (i)++ )  if( v )
/* <combine sack::containers::list::CreateListEx@DBG_VOIDPASS>
   \ \                                                         */
#define CreateList()       ( CreateListEx( DBG_VOIDSRC ) )
/* <combine sack::containers::list::DeleteListEx@PLIST *plist>
   \ \                                                         */
#ifndef FIX_RELEASE_COM_COLLISION
#  define DeleteList(p)      ( DeleteListEx( (p) DBG_SRC ) )
#endif
/* Adds a pointer to a user object to a list.
   Example
   <code lang="c++">
   // the list can be initialized to NULL,
   // it does not have to be assigned the result of a CreateList().
   // this allows the list to only be allocated if it is used.
   PLIST list = NULL;
   AddLink( &amp;list, (POINTER)user_pointer );
   {
       POINTER p; // this should be USER_DATA_TYPE *p;
       INDEX idx; // just a generic counter.
       LIST_FORALL( list, idx, POINTER, p )
       {
           // for each item in the list, p will be not null.
           if( p-\>something == some_other_thing )
               break;
       }
       // p will be NULL if the list is empty
       // p will be NULL if the LIST_FORALL loop completes to termination.
       // p will be not NULL if the LIST_FORALL loop executed a 'break;'
   }
   </code>                                                                 */
#define AddLink(p,v)       ( AddLinkEx( (p),((POINTER)(v)) DBG_SRC ) )
/* <combine sack::containers::list::SetLinkEx@PLIST *@INDEX@POINTER p>
   \ \                                                                 */
#define SetLink(p,i,v)     ( SetLinkEx( (p),(i),((POINTER)(v)) DBG_SRC ) )
#ifdef __cplusplus
 //		namespace list;
	}
#endif
//--------------------------------------------------------
_DATALIST_NAMESPACE
/* Creates a data list which hold data elements of the specified
   size.
                                                                 */
TYPELIB_PROC  PDATALIST TYPELIB_CALLTYPE  CreateDataListEx ( uintptr_t nSize DBG_PASS );
/* <combine sack::containers::data_list::DeleteDataList>
   \ \                                                   */
TYPELIB_PROC  void TYPELIB_CALLTYPE       DeleteDataListEx ( PDATALIST *ppdl DBG_PASS );
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    SetDataItemEx ( PDATALIST *ppdl, INDEX idx, POINTER data DBG_PASS );
/* Adds an item to a DataList.
   Example
   <code lang="c++">
   PDATALIST datalist = CreateDataList();
   struct my_struct {
       uint32_t my_data;
   }
   struct my_struct my_item;
   my_item.my_data = 0;
   AddDataItem( &amp;datalist, &amp;my_item );
   </code>                                     */
#define AddDataItem(list,data) (((list)&&(*(list)))?SetDataItemEx((list),(*list)->Cnt,data DBG_SRC ):NULL)
/* Sets the item at a specific nodes to the new data.
   Parameters
   ppdl :      address of a PDATALIST.
   idx :       index of element in list to set
   data :      POINTER to data to set element to
   DBG_PASS :  optional debug file/line information
   Example
   <code lang="c++">
      PDATALIST pdl;
      int oldval = 3;
      int newval = 5;
      pdl = CreateDataList( sizeof( int ) ); // store int's as data
      AddDataItem( &amp;pdl, &amp;oldval );
      SetDataItem( &amp;pdl, 0, &amp;newval );
   </code>                                                          */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    SetDataItemEx ( PDATALIST *ppdl, INDEX idx, POINTER data DBG_PASS );
/* \Returns a pointer to the data at a specified index.
   Parameters
   \ \
   ppdl :  address of a PDATALIST
   idx :   index of element to get                      */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    GetDataItem ( PDATALIST *ppdl, INDEX idx );
/* Removes a data element from the list (moves all other
   elements down over it since there is no used indicator.
   Parameters
   ppdl :  address of a PDATALIST.
   idx :   index of element to delete                      */
TYPELIB_PROC  void TYPELIB_CALLTYPE       DeleteDataItem ( PDATALIST *ppdl, INDEX idx );
/* Empties a PDATALIST of all content.
   Parameters
   ppdl :  address of a PDATALIST
   Example
   <code lang="c++">
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) ); // store int's as data
   EmptyDataList( &amp;pdl );
   </code>                                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE       EmptyDataList ( PDATALIST *ppdl );
/* For loop to iterate through all items in a PDATALIST.
   <code lang="c++">
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) );
   {
      INDEX index;
      int *value;
      DATA_FORALL( pdl, index, int, value )
      {
      }
   }
   </code>                                               */
#define DATA_FORALL( l, i, t, v )  if(((v)=(t)NULL),(l)&&((l)->Cnt != INVALID_INDEX))	   for( ((i)=0);	                         (((i) < (l)->Cnt)                                             ?(((v)=(t)((l)->data + (uintptr_t)(((l)->Size) * (i)))),1)	         :(((v)=(t)NULL),0))&&(v); (i)++ )
/* <code>
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) );
   {
      INDEX index;
      int *value;
      DATA_FORALL( pdl, index, int, value )
      {
          // abort loop early
      }
      DATA_NEXTALL( pdl, index, int, value )
      {
      }
   }
   </code>                                   */
#define DATA_NEXTALL( l, i, t, v )  if(((v)=(t)NULL),(l))	   for( ((i)++);	                         ((i) < (l)->Cnt)                                             ?((v)=(t)((l)->data + (((l)->Size) * (i))))	         :(((v)=(t)NULL),0); (i)++ )
/* <combine sack::containers::data_list::CreateDataListEx@uintptr_t nSize>
   Creates a DataList specifying just the size. Uses the current
   source and line for debugging parameter.                               */
#define CreateDataList(sz) ( CreateDataListEx( (sz) DBG_SRC ) )
/* Destroy a DataList.
   Example
   <code>
   PDATALIST datalist = CreateDataList( 4 );
   DeleteDataList( &amp;datalist );
   </code>
   Parameters
   ppDataList :  pointer to the PDATALIST.   */
#define DeleteDataList(p)  ( DeleteDataListEx( (p) DBG_SRC ) )
/* <combine sack::containers::data_list::SetDataItemEx@PDATALIST *@INDEX@POINTER data>
   \ \                                                                                 */
#define SetDataItem(p,i,v) ( SetDataItemEx( (p),(i),(v) DBG_SRC ) )
   _DATALIST_NAMESPACE_END
//--------------------------------------------------------
#ifdef __cplusplus
		namespace link_stack {
#endif
/* Creates a new stack for links (POINTERS).
   Parameters
   DBG_PASS :  Debug file and line information to use for the
               allocation of the stack.
   Returns
   Pointer to a new link stack.                               */
TYPELIB_PROC  PLINKSTACK TYPELIB_CALLTYPE   CreateLinkStackEx( DBG_VOIDPASS );
/* Creates a new stack for links (POINTERS).  Link stack has a limited number of entries.
    When the stack fills, the oldest item on the stack is removed automatically.
	 Parameters
	 max_entries : maximum depth of the stack.
   DBG_PASS :  Debug file and line information to use for the
               allocation of the stack.
   Returns
   Pointer to a new link stack.                               */
         // creates a link stack with maximum entries - any extra entries are pushed off the bottom into NULL
TYPELIB_PROC  PLINKSTACK TYPELIB_CALLTYPE      CreateLinkStackLimitedEx        ( int max_entries  DBG_PASS );
/* <combine sack::containers::link_stack::CreateLinkStackLimitedEx@int max_entries>
   Macro to pass default debug file and line information.                           */
#define CreateLinkStackLimited(n) CreateLinkStackLimitedEx(n DBG_SRC)
/* Destroy a link stack. Sets the pointer to the stack to NULL
   on deletion.
   Parameters
   pls :       address of a link stack pointer
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteLinkStackEx( PLINKSTACK *pls DBG_PASS);
/* Pushes a new link on the stack.
   Parameters
   pls :       address of a link stack pointer
   p :         new pointer to push on the stack
   DBG_PASS :  debug source file and line information.
   Returns
   New link stack pointer if the stack was reallocated to have
   more space. Since the address of the pointer is passed, the
   pointer is already updated, and the return value is
   unimportant.                                                */
TYPELIB_PROC  PLINKSTACK TYPELIB_CALLTYPE   PushLinkEx       ( PLINKSTACK *pls, POINTER p DBG_PASS);
/* Reads the top value of the stack and returns it, removes top
   link on the stack.
   Parameters
   pls :  address of a link stack pointer
   Return Value List
   NULL :      Stack was empty
   not NULL :  Link that was on the top of the stack.           */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopLink          ( PLINKSTACK *pls );
/* Look at the top link on the stack.
   Parameters
   pls :  address of a link stack pointer
   Return Value List
   NULL :      Nothing on stack.
   not NULL :  link on the top of the stack. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekLink         ( PLINKSTACK *pls );
/* Look at links in the stack.
   Parameters
	pls :  address of a link stack pointer
	n : index of the element from the top to look at
   Return Value List
   NULL :      Nothing on stack at the position specified.
   not NULL :  link on the top of the stack. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekLinkEx         ( PLINKSTACK *pls, INDEX n );
// thought about adding these, but decided on creating a limited stack instead.
//TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      StackLength      ( PLINKSTACK *pls );
//TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopLinkEx        ( PLINKSTACK *pls, int position );
/* <combine sack::containers::link_stack::CreateLinkStackEx@DBG_VOIDPASS>
   Macro to pass default file and line information.                       */
#define CreateLinkStack()  CreateLinkStackEx( DBG_VOIDSRC )
/* <combine sack::containers::link_stack::DeleteLinkStackEx@PLINKSTACK *pls>
   Macro to pass default file and line information.                          */
#define DeleteLinkStack(p) DeleteLinkStackEx((p) DBG_SRC)
/* <combine sack::containers::link_stack::PushLinkEx@PLINKSTACK *@POINTER p>
   Macro to pass default debug file and line information.                    */
#define PushLink(p, v)     PushLinkEx((p),(v) DBG_SRC)
#ifdef __cplusplus
 //		namespace link_stack {
		}
#endif
//--------------------------------------------------------
#ifdef __cplusplus
		namespace data_stack {
#endif
/* Creates a data stack for data element of the specified size.
   Parameters
   size :       size of elements in the stack
   DBG_PASS :  debug file and line information.                 */
TYPELIB_PROC  PDATASTACK TYPELIB_CALLTYPE   CreateDataStackEx( size_t size DBG_PASS );
/* Creates a data stack for data element of the specified size.
   Parameters
   size :       size of items in the stack
   count :      max items in stack (oldest gets deleted)
   DBG_PASS :  debug file and line information.                 */
TYPELIB_PROC  PDATASTACK TYPELIB_CALLTYPE   CreateDataStackLimitedEx( size_t size, INDEX count DBG_PASS );
/* Destroys a data stack.
   Parameters
   pds :       address of a data stack pointer. The pointer will
               be set to NULL when the queue is destroyed.
   DBG_PASS :  Debug file and line information.                  */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteDataStackEx( PDATASTACK *pds DBG_PASS);
/* Push a data element onto the stack. The size of the element
   is known at the stack creation time.
   Parameters
   pds :       address of a data stack pointer
   p :         pointer to data to push on stack
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC  PDATASTACK TYPELIB_CALLTYPE   PushDataEx     ( PDATASTACK *pds, POINTER pdata DBG_PASS );
/* \Returns an allocated buffer containing the data on the
   stack. Removes item from the stack.
   Parameters
   pds :  address of a data stack to get data from         */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopData        ( PDATASTACK *pds );
/* Clear all data stored in the stack.
   Parameters
   pds :  address of a data stack pointer. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyDataStack ( PDATASTACK *pds );
/* Look at top item in the stack without removing it.
   Parameters
   pds :  address of a data stack to look at          */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekData       ( PDATASTACK *pds );
// Incrementing Item moves progressivly down the stack
// final(invalid) stack, and/or empty stack will return NULL;
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekDataEx     ( PDATASTACK *pds, INDEX Item );
 /* keeps data on stack (can be used)
                                                                                      Parameters
                                                                                      pds :   address of a data stack pointer
                                                                                      Item :  Item to peek at; 0 is the top, 1 is just below it...
                                                                                              (maybe \-1 is last and further up)
                                                                                      Returns
                                                                                      \returns the address of the data item in the data stack.     */
/* <combine sack::containers::data_stack::CreateDataStackEx@INDEX size>
   Macro to pass default file and line information.                     */
#define CreateDataStack(size) CreateDataStackEx( size DBG_SRC )
/* <combine sack::containers::data_stack::CreateDataStackEx@INDEX size>
   Macro to pass default file and line information.                     */
#define CreateDataStackLimited(size,items) CreateDataStackLimitedEx( size,items DBG_SRC )
/* <combine sack::containers::data_stack::DeleteDataStackEx@PDATASTACK *pds>
   Macro to pass default file and line information.                          */
#define DeleteDataStack(p) DeleteDataStackEx((p) DBG_SRC)
/* <combine sack::containers::data_stack::PushDataEx@PDATASTACK *@POINTER pdata>
   Macro to pass default file and line information.                              */
#define PushData(pds,p) PushDataEx(pds,p DBG_SRC )
#ifdef __cplusplus
 //		namespace data_stack {
		}
#endif
/* Queue container - can enque (at tail) deque (from head) and preque (at head). Can also browse the queue with peekqueue. */
#ifdef __cplusplus
		namespace queue {
#endif
/* Creates a <link sack::containers::PLINKQUEUE, LinkQueue>. In
   debug mode, gets passed the current source and file so it can
   blame the user for the allocation.                            */
TYPELIB_PROC  PLINKQUEUE TYPELIB_CALLTYPE   CreateLinkQueueEx( DBG_VOIDPASS );
/* Delete a link queue. Pass the address of the pointer to the
   queue to delete, this function sets the pointer to NULL if
   the queue is actually deleted.                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteLinkQueueEx( PLINKQUEUE *pplq DBG_PASS );
/* Enque a link to the queue.  */
TYPELIB_PROC  PLINKQUEUE TYPELIB_CALLTYPE   EnqueLinkEx      ( PLINKQUEUE *pplq, POINTER link DBG_PASS );
TYPELIB_PROC  void TYPELIB_CALLTYPE   EnqueLinkNLEx( PLINKQUEUE *pplq, POINTER link DBG_PASS );
/* EnqueLink adds the new item at the end of the list. PrequeueLink
   puts the new item at the head of the queue (so it's the next
   one to be retrieved).                                            */
TYPELIB_PROC  PLINKQUEUE TYPELIB_CALLTYPE   PrequeLinkEx      ( PLINKQUEUE *pplq, POINTER link DBG_PASS );
/* If the queue is not empty, returns the address of the next
   element in the queue and removes the element from the queue.
                                                                */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      DequeLink        ( PLINKQUEUE *pplq );
TYPELIB_PROC POINTER  TYPELIB_CALLTYPE      DequeLinkNL      ( PLINKQUEUE *pplq );
/* Return TRUE/FALSE if the queue is empty or not. */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      IsQueueEmpty     ( PLINKQUEUE *pplq );
/* Gets the number of elements current in the queue. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        GetQueueLength   ( PLINKQUEUE plq );
// get a PLINKQUEUE element at index
//  If idx < 0 then count from the end of the queue, otherwise count from the start of the queue
// start of the queue is the next element to be dequeue, end of the queue is the last element added to the queue.
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekQueueEx    ( PLINKQUEUE plq, int idx );
/* Can be used to look at the next element in the queue without
   removing it from the queue. PeekQueueEx allows you to specify
   an index of an item in the queue to get.                      */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekQueue    ( PLINKQUEUE plq );
/* <combinewith sack::containers::queue::CreateLinkQueueEx@DBG_VOIDPASS>
   \ \                                                                   */
#define     CreateLinkQueue()     CreateLinkQueueEx( DBG_VOIDSRC )
/* <combine sack::containers::queue::PrequeLinkEx@PLINKQUEUE *@POINTER link>
   \ \                                                                       */
#define     PrequeLink(pplq,link) PrequeLinkEx( pplq, link DBG_SRC )
/* <combine sack::containers::queue::DeleteLinkQueueEx@PLINKQUEUE *pplq>
   \ \                                                                   */
#define     DeleteLinkQueue(pplq) DeleteLinkQueueEx( pplq DBG_SRC )
/* <combine sack::containers::queue::EnqueLinkEx@PLINKQUEUE *@POINTER link>
   \ \                                                                      */
#define     EnqueLink(pplq, link) EnqueLinkEx( pplq, link DBG_SRC )
#define     EnqueLinkNL(pplq, link) EnqueLinkNLEx( pplq, link DBG_SRC )
#ifdef __cplusplus
//		namespace queue {
		}
#endif
/* Functions related to PDATAQUEUE container. DataQueue stores
   literal data elements in the list instead of just a pointer. (could
   be used for optimized vertex arrays for instance).
   int data = 3;
   int result;
   PDATAQUEUE pdq = CreateDataQueue( sizeof( int ) );
   EnqueData( &amp;pdq, &amp;data );
   DequeData( &amp;pdq, &amp;result );
   DestroyDataQueue( &amp;pdq );                                       */
#ifdef __cplusplus
		namespace data_queue {
#endif
/* Creates a PDATAQUEUE. Can pass DBG_FILELINE information to
   blame other code for the allocation.                       */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   CreateDataQueueEx( INDEX size DBG_PASS );
/* Creates a PDATAQUEUE that has an overridden expand-by amount
   and initial amount of entries in the queue. (expecting
   something like 1000 to start and expand by 500, instead of
   the default 0, and expand by 1.                              */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   CreateLargeDataQueueEx( INDEX size, INDEX entries, INDEX expand DBG_PASS );
/* Destroys a data queue. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteDataQueueEx( PDATAQUEUE *pplq DBG_PASS );
/* Add a data element into the queue. */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   EnqueDataEx      ( PDATAQUEUE *pplq, POINTER Data DBG_PASS );
/* Enque data at the head of the queue instead of the tail. (Normally
   add at tail, take from head).                                      */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   PrequeDataEx      ( PDATAQUEUE *pplq, POINTER Data DBG_PASS );
/* Removes data from a queue, resulting with the data in the
   specified buffer, and result TRUE if there was an element
   else FALSE, and the buffer is not modified.               */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      DequeData        ( PDATAQUEUE *pplq, POINTER Data );
/* Removes the last element in the queue. (takes from the tail). */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      UnqueData        ( PDATAQUEUE *pplq, POINTER Data );
/* Checks if the queue is empty, result TRUE if nothing in it,
   else FALSE.                                                 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      IsDataQueueEmpty ( PDATAQUEUE *pplq );
/* Empty a dataqueue of all data. (Sets head=tail). */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyDataQueue ( PDATAQUEUE *pplq );
/*
 * get a PDATAQUEUE element at index
 * result buffer is a pointer to the type of structure expected to be
 * stored within this.  The buffer result is a copy of the data stored in the queue.
 * This enforces that data stored in the list is immutable.
 * Also on the basic DequeData function, after resulting, if the pointer to the
 * data within the queue were returned, it could become invalid immediatly after
 * returning by having another enque happen which overwrites that position in the buffer.
 * One could, in theory, set a flag in the queue that a deque was done, and not update the
 * bottom until that flag is encountered while within DequeData again...
 * the pointer to the data in the queue may also not be returned because the queue may be
 * reallocated and moved.
 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  PeekDataQueueEx    ( PDATAQUEUE *pplq, POINTER ResultBuffer, INDEX idx );
/* <combine sack::containers::data_queue::PeekDataQueueEx@PDATAQUEUE *@POINTER@INDEX>
   \ \                                                                                */
#define PeekDataQueueEx( q, type, result, idx ) PeekDataQueueEx( q, (POINTER)result, idx )
/*
 * Result buffer is filled with the last element, and the result is true, otherwise the return
 * value is FALSE, and the data was not filled in.
 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  PeekDataQueue    ( PDATAQUEUE *pplq, POINTER ResultBuffer );
/* <combine sack::containers::data_queue::PeekDataQueue@PDATAQUEUE *@POINTER>
   \ \                                                                        */
#define PeekDataQueue( q, type, result ) PeekDataQueue( q, (POINTER)result )
/* <combine sack::containers::data_queue::CreateDataQueueEx@INDEX size>
   \ \                                                                  */
#define     CreateDataQueue(size)     CreateDataQueueEx( size DBG_SRC )
/* <combine sack::containers::data_queue::CreateLargeDataQueueEx@INDEX@INDEX@INDEX expand>
   \ \                                                                                     */
#define     CreateLargeDataQueue(size,entries)     CreateLargeDataQueueEx( size,entries, 0 DBG_SRC )
/* <combine sack::containers::data_queue::DeleteDataQueueEx@PDATAQUEUE *pplq>
   \ \                                                                        */
#define     DeleteDataQueue(pplq) DeleteDataQueueEx( pplq DBG_SRC )
/* <combine sack::containers::data_queue::EnqueDataEx@PDATAQUEUE *@POINTER Data>
   \ \                                                                           */
#define     EnqueData(pplq, Data) EnqueDataEx( pplq, Data DBG_SRC )
/* <combine sack::containers::data_queue::PrequeDataEx@PDATAQUEUE *@POINTER Data>
   \ \                                                                            */
#define     PrequeData(pplq, Data) PrequeDataEx( pplq, Data DBG_SRC )
#ifdef __cplusplus
//		namespace data_queue {
		}
#endif
//---------------------------------------------------------------------------
#ifdef __cplusplus
namespace message {
#endif
/* handle to a message queue. */
typedef struct MsgDataHandle *PMSGHANDLE;
//typedef struct MsgDataQueue *PMSGQUEUE;
// messages sent - the first dword of them must be
// a message ID.
typedef void (CPROC *MsgQueueReadCallback)( uintptr_t psv, CPOINTER p, uintptr_t sz );
/* Create a named shared memory message queue.
   Parameters
   name :     name of the queue to create
   size :     size of the queue.
   Read :     read callback, called when a message is received on
              the queue.
   psvRead :  user data associated with the queue. Passed to the
              read callback.                                      */
TYPELIB_PROC  PMSGHANDLE TYPELIB_CALLTYPE  SackCreateMsgQueue ( CTEXTSTR name, size_t size
                                                      , MsgQueueReadCallback Read
                                                      , uintptr_t psvRead );
/* Open a message queue. Opens if it exists, does not create.
   Parameters
   name :     name of the queue.
   Read :     read callback called when a message is received.
   psvRead :  user data associated with this queue, and passed to
              the read callback.                                  */
TYPELIB_PROC  PMSGHANDLE TYPELIB_CALLTYPE  SackOpenMsgQueue ( CTEXTSTR name
													 , MsgQueueReadCallback Read
													 , uintptr_t psvRead );
/* Destroys a message queue.
   Parameters
   ppmh :  address of the message queue handle to close (sets
           pointer to NULL when deleted)                      */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteMsgQueue ( PMSGHANDLE **ppmh );
 // if enque, fail send, return immediate on fail
#define MSGQUE_NOWAIT 0x0001
                             // if deque, fail no msg ready to get...
 // read any msg BUT MsgID
#define MSGQUE_EXCEPT 0x0002
 // enque this message... it is a task ID which is waiting.
#define MSGQUE_WAIT_ID 0x0004
/* Error result if there is no message to read. (GetLastError()
   after peekmsg or readmsg returns -1)                         */
#define MSGQUE_ERROR_NOMSG 1
/* Error result if the message to read is bigger than the buffer
   passed to read the message.                                   */
#define MSGQUE_ERROR_E2BIG 2
/* Error result. Unexpected error (queue head/tail out of
   bounds)                                                */
#define MSGQUE_ERROR_EABORT 5
// result is the size of the message, or 0 if no message.
// -1 if some other error?
TYPELIB_PROC  int TYPELIB_CALLTYPE  DequeMsgEx ( PMSGHANDLE pmh, long *MsgID, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Receives a message from the message queue.
   Parameters
   Message Queue :  PMSGHANDLE to read from
   Message ID * :   a Pointer to the message ID to read. Updated
                    with the message ID from the queue.
   buffer :         buffer to read message into
   buffer length :  length of the buffer to read
   options :        extra options for the read
   Return Value List
   \-1 :  Error
   0 :    No Message to read
   \>0 :  size of message read.
   Returns
   \ \                                                           */
#define DequeMsg(q,b,s,i,o) DequeMsgEx(q,b,s,i,o DBG_SRC )
/* <combine sack::containers::message::PeekMsg>
   \ \                                          */
TYPELIB_PROC  int TYPELIB_CALLTYPE  PeekMsgEx ( PMSGHANDLE pmh, long MsgID, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Just peek at the next message.
   Parameters
   queue :        The PMSGHANDLE queue to read.
   MsgID :        what message to read. 0 is read any message.
   buffer :       where to read the message data into.
   buffer_size :  the length of the message buffer.
   options :      Options controlling the read
   Returns
   \-1 on error
   0 if no message
   length of the message read                                  */
#define PeekMsg(q,b,s,i,o) PeekMsgEx(q,b,s,i,o DBG_SRC )
/* <combine sack::containers::message::EnqueMsg>
   \ \                                          */
TYPELIB_PROC  int TYPELIB_CALLTYPE  EnqueMsgEx ( PMSGHANDLE pmh, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Add a message to the queue.
   Parameters
   Message Queue :  PMSGQUEUE to write to.
   Buffer :         pointer to the message to send. THe MSgID is
                    the first part of the message buffer.
   Buffer Length :  how long the message to send is
   Options :        Extra options for send
   Return Value List
   \-1 :  Error
   \>0 :  bytes of message sent                                  */
#define EnqueMsg(q,b,s,o) EnqueMsgEx(q,b,s,o DBG_SRC )
/* Check if the message queue is empty.
   Parameters
   pmh :  queue to check if it's empty. */
TYPELIB_PROC  int TYPELIB_CALLTYPE  IsMsgQueueEmpty ( PMSGHANDLE pmh );
#ifdef __cplusplus
 //namespace message {
}
#endif
/* Routines to deal with SLAB allocated blocks of structures.
   Each slab has multiple elements of a type in it, and the
   blocks are tracked as a linked list. Each block also has a
   bitmask of allocated elements in the set.
   \---------------------------------------------------------------------------
   Set type
   Usage:
   typedef struct name_tag { } \<name\>;
   \#define MAX\<name\>SPERSET
   DeclareSet( \<name\> );
   Should alias GetFromset, DeleteFromSet, CountUsedInSet,
   GetLinearSetArray
   etc so that the type name is reflected there
   another good place where #define defining defines is good.
   \---------------------------------------------------------------------------
                                                                                */
_SETS_NAMESPACE
//---------------------------------------------------------------------------
// Set type
//   Usage:
//      typedef struct name_tag { } <name>;
//      #define MAX<name>SPERSET
//      DeclareSet( <name> );
//    Should alias GetFromset, DeleteFromSet, CountUsedInSet, GetLinearSetArray
//       etc so that the type name is reflected there
//       another good place where #define defining defines is good.
//---------------------------------------------------------------------------
/* Hard coded 32 bit division for getting word index. (x\>\>5) */
#define UNIT_USED_IDX(n)   ((n) >> 5)
/* Hard coded 32 bit division for getting bit index. (x &amp;
   0x1f)                                                      */
#define UNIT_USED_MASK(n)  (1 << ((n) &0x1f))
/* A macro for use by internal code that marks a member of a set
   as used.
   Parameters
   set :    pointer to a genericset
   index :  item to mark used.                                   */
#define SetUsed(set,n)   ((((set)->bUsed[UNIT_USED_IDX(n)]) |= UNIT_USED_MASK(n)), (++(set)->nUsed) )
/* A macro for use by internal code that marks a member of a set
   as available.
   Parameters
   set :    pointer to a genericset
   index :  item to mark available.                              */
#define ClearUsed(set,n) ((((set)->bUsed[UNIT_USED_IDX(n)]) &= ~UNIT_USED_MASK(n)), (--(set)->nUsed) )
/* A macro for use by internal code that tests a whole set of
   bits for used. (32 bits, can check to see if any in 32 is
   free)
   Parameters
   set :    pointer to a genericset
   index :  index of an one in the set of 32 being tested.
   Returns
   0 if not all are used.
   1 if all in this block of bits are used.                   */
#define AllUsed(set,n)   (((set)->bUsed[UNIT_USED_IDX(n)]) == 0xFFFFFFFF )
/* A macro for use by internal code that tests a member of a set
   as used.
   Parameters
   set :    pointer to a genericset
   index :  item to test used.
   Returns
   not zero if is used, otherwise is free.                       */
#define IsUsed(set,n)    (((set)->bUsed[UNIT_USED_IDX(n)]) & UNIT_USED_MASK(n) )
#ifdef __cplusplus
#define CPP_(n)
/* A macro which is used to emit code in C++ mode... */
#else
#define CPP_(n)
#endif
// requires a symbol of MAX<insert name>SPERSET to declare max size...
 //ndef __cplusplus
#if 1
#define SizeOfSet(size,count)  (sizeof(POINTER)*2+sizeof(int)+sizeof( uint32_t[((count)+31)/32] ) + ((size)*(count)))
#define DeclareSet( name )  typedef struct name##set_tag {	   struct name##set_tag *next, *prior;	                      uint32_t nUsed;	                                               uint32_t nBias;	                                               uint32_t bUsed[(MAX##name##SPERSET + 31 ) / 32];	              name p[MAX##name##SPERSET];	                           CPP_(int forall(uintptr_t(CPROC*f)(void*,uintptr_t),uintptr_t psv) {if( this ) return _ForAllInSet( (struct genericset_tag*)this, sizeof(name), MAX##name##SPERSET, f, psv ); else return 0; })	 CPP_(name##set_tag() { next = NULL;prior = NULL;nUsed = 0; nBias = 0; MemSet( bUsed, 0, sizeof( bUsed ) ); MemSet( p, 0, sizeof( p ) );} )	} name##SET, *P##name##SET
#define DeclareClassSet( name ) typedef struct name##set_tag {	   struct name##set_tag *next, *prior;	                      uint32_t nUsed;	                                               uint32_t nBias;	                                               uint32_t bUsed[(MAX##name##SPERSET + 31 ) / 32];	              class name p[MAX##name##SPERSET];	                        CPP_(int forall(uintptr_t(CPROC*)(void*f,uintptr_t),uintptr_t psv) {if( this ) return _ForAllInSet( (struct genericset_tag*)this, sizeof(class name), MAX##name##SPERSET, f, psv ); else return 0; })	 } name##SET, *P##name##SET
#endif
/* This represents the basic generic set structure. Addtional
   data is allocated at the end of this strcture to fit the bit
   array that maps usage of the set, and for the set size of
   elements.
   Remarks
   \ \
   Summary
   Generic sets are good for tracking lots of tiny structures.
   They track slabs of X structures at a time. They allocate a
   slab of X structures with an array of X bits indicating
   whether a node is used or not. The structure overall has how
   many are used, so once full, a block can be quickly checked
   whether there is anything free. Then when checking a block
   that might have room, the availablility is checked 32 bits at
   a time, until a free spot is found.
   Sets of 1024 members of x,y coordinates for example are good
   for this sort of storage. the points are often static, once
   loaded they all exist until none of them do. This storage has
   gross deletion methods too, quickly evaporate all allocated
   chunks. Storing tiny chunks in a slab is more efficient
   because every allocation method has some sort of tracking
   associated with it - an overhead of having it. Plus, when
   operating on sets of data, a single solid slab of exatly the
   structures you are working with is more efficient to cache.
   Example
   <code lang="c++">
   struct treenode_tag {
       uint32_t treenode_data;  // abitrary structure data
   };
   typedef struct treenode_tag TREENODE;
   \#define MAXTREENODESPERSET 256
   DeclareSet( TREENODE );
   </code>
   The important part of the prior code is the last two lines.
   \#define MAX\<your type name\>SPERSET \<how many\>
   This defines how many of your structure are kept per set
   block.
   The DeclareSet( type ) declares a typedefed structure called
   'struct type##set_tag', 'name##SET', and '*P##name##SET'; in
   the above case, it would be 'struct TREENODEset_tag',
   'TREENODESET', and 'PTREENODESET'.
   Then to actually use the set...
   <code lang="c#">
   // declare a set pointer with one of the magic names.
   PTREENODESET nodeset = NULL;
   // get a node from the set.
   TREENODE *node = GetFromSet( TREENODE, nodeset );
   </code>
   Notice there is no CreateSet, getting a set member will
   create the set as required. Many operations may expend the
   set, except for GetUsedSetMember which will only result with
   \members that are definatly in the set. Accesses to the set
   are all prefixed by the type name the set was created with,
   'TREENODE' in this example.
   <code lang="c++">
   DeleteFromSet( TREENODE, nodeset, node );
   node = GetFromSet( TREENODE, nodeset );
   {
      int index = GetMemberIndex( TREENODE, nodeset, node );
   }
   </code>
   The accessor macros take care of expanding several parameters
   that require sizeof structure expansion.                      */
typedef struct genericset_tag {
	// wow might be nice to have some flags...
	// first flag - bSetSet - meaning that this is a set of sets of
	// the type specified...
	struct genericset_tag *next;
	/* This is the pointer that's pointing at the pointer pointing
	   to me. (did you get that?) See <link DeclareLink>.          */
	struct genericset_tag **me;
	/* number of spots in this set block that are used. */
	uint32_t nUsed;
 // hmm if I change this here? we're hozed... so.. we'll do it anyhow :) evil - recompile please
	uint32_t nBias;
 // after this p * unit must be computed
	uint32_t bUsed[1];
} GENERICSET, *PGENERICSET;
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetFromSetEx( GENERICSET **pSet, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetFromSetEx@GENERICSET **@int@int@int maxcnt>
   \ \                                                                             */
#define GetFromSeta(ps, ss, us, max) GetFromSetPoolEx( NULL, 0, 0, 0, (ps), (ss), (us), (max) DBG_SRC )
/* <combine sack::containers::sets::GetFromSetEx@GENERICSET **@int@int@int maxcnt>
   \ \
   Parameters
   name :  name of type the set contains.
   pSet :  pointer to a set to get an element from.                                */
#define GetFromSet( name, pset ) (name*)GetFromSeta( (GENERICSET**)(pset), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET )
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  PGENERICSET  TYPELIB_CALLTYPE GetFromSetPoolEx( GENERICSET **pSetSet
													 , int setsetsize, int setunitsize, int setmaxcnt
													 , GENERICSET **pSet
													 , int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetFromSetPoolEx@GENERICSET **@int@int@int@GENERICSET **@int@int@int maxcnt>
   \ \                                                                                                           */
#define GetFromSetPoola(pl, sss, sus, smax, ps, ss, us, max) GetFromSetPoolEx( (pl), (sss), (sus), (smax), (ps), (ss), (us), (max) DBG_SRC )
/* <combine sack::containers::sets::GetFromSetPoolEx@GENERICSET **@int@int@int@GENERICSET **@int@int@int maxcnt>
   \ \                                                                                                           */
#define GetFromSetPool( name, pool, pset ) (name*)GetFromSetPoola( (GENERICSET**)(pool)	    , sizeof( name##SETSET ), sizeof( name##SET ), MAX##name##SETSPERSET	, (GENERICSET**)(pset), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET )
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                     */
#define GetSetMembera(ps, member, ss, us, max) (GetSetMemberEx( (ps), (member), (ss), (us), (max) DBG_SRC ))
/* <combine sack::containers::sets::GetSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                     */
#define GetSetMember( name, pset, member ) ((name*)GetSetMembera( (GENERICSET**)(pset), (member), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET ))
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetUsedSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetUsedSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                         */
#define GetUsedSetMembera(ps, member, ss, us, max) (GetUsedSetMemberEx( (ps), (member), (ss), (us), (max) DBG_SRC ))
/* <combine sack::containers::sets::GetUsedSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                         */
#define GetUsedSetMember( name, pset, member ) ((name*)GetUsedSetMembera( (GENERICSET**)(pset), (member), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET ))
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetMemberIndex(GENERICSET **set, POINTER unit, int unitsize, int max );
/* Gets the index of a member passed as a pointer.
   Parameters
   set :       pointer to the set the member is in
   unit :      pointer to the member in the set to get the index
               of.
   unitsize :  size of each member in the set
   max :       count of members in each set block.
   Returns
   \Returns the index of the member passed in as a pointer.      */
#define GetMemberIndex(name,set,member) GetMemberIndex( (GENERICSET**)set, member, sizeof( name ), MAX##name##SPERSET )
/* <combine sack::containers::sets::GetMemberIndex>
   \ \                                              */
#define GetIndexFromSet( name, pset ) GetMemberIndex( name, pset, GetFromSet( name, pset ) )
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteFromSetExx( GENERICSET *set, POINTER unit, int unitsize, int max DBG_PASS );
/* <combine sack::containers::sets::DeleteFromSetExx@GENERICSET *@POINTER@int@int max>
   \ \                                                                                 */
#define DeleteFromSetEx( name, set, member, xx ) DeleteFromSetExx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET DBG_SRC )
/* <combine sack::containers::sets::DeleteFromSetExx@GENERICSET *@POINTER@int@int max>
   \ \                                                                                 */
#define DeleteFromSet( name, set, member ) DeleteFromSetExx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET DBG_SRC )
/* Marks a member in a set as usable.
   Parameters
   set :       pointer to a genericset pointer
   iMember :   index of member to delete
   unitsize :  (filled by macro) size of element in set
   max :       (filled by macro) size of a block of elements. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteSetMemberEx( GENERICSET *set, INDEX iMember, uintptr_t unitsize, INDEX max );
/* <combine sack::containers::sets::DeleteSetMemberEx@GENERICSET *@INDEX@uintptr_t@INDEX>
   \ \                                                                                   */
#define DeleteSetMember( name, set, member ) DeleteSetMemberEx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET )
/* This function can check to see if a pointer is a valid
   element from a set.
   Parameters
   set :       pointer to a set to check
   unit :      pointer to an element from the set
   unitsize :  size of element structures in the set.
   max :       count of structures per set block
   Returns
   TRUE if unit is in the set, else FALSE.                */
TYPELIB_PROC  int TYPELIB_CALLTYPE  MemberValidInSetEx( GENERICSET *set, POINTER unit, int unitsize, int max );
/* <combine sack::containers::sets::MemberValidInSetEx@GENERICSET *@POINTER@int@int>
   \ \                                                                               */
#define MemberValidInSet( name, set, member ) MemberValidInSetEx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET )
TYPELIB_PROC  int TYPELIB_CALLTYPE  CountUsedInSetEx( GENERICSET *set, int max );
/* Count number of elements that are allocated in the set.
   Parameters
   set :  The set to check
   max :  max items per set (may be unused, since this is stored
          internally now)
   Returns
   The number of items in the step.                              */
#define CountUsedInSet( name, set ) CountUsedInSetEx( (GENERICSET*)set, MAX##name##SPERSET )
TYPELIB_PROC  POINTER * TYPELIB_CALLTYPE GetLinearSetArrayEx( GENERICSET *pSet, int *pCount, int unitsize, int max );
/* Converts a set into a copy of the objects in the set
   organized in a flat array.
   Parameters
   pSet :      set to convert to an array
   pCount :    address of an integer to receive the count of
               elements put in the array.
   unitsize :  size of each element in the set
   max :       count of elements per set block
   Returns
   Pointer to an array that are a copy of the objects in the
   set.                                                      */
#define GetLinearSetArray( name, set, pCount ) GetLinearSetArrayEx( (GENERICSET*)set, pCount, sizeof( name ), MAX##name##SPERSET )
/* Returned the index of an item in a linear array returned from
   a set.
   Parameters
   pArray :      pointer to an array which has been returned from
                 the set
   nArraySize :  size fo the array
   unit :        pointer to an element in the array
   Returns
   Index of the unit in the array, INVALID_INDEX if not in the
   array.                                                         */
TYPELIB_PROC  int TYPELIB_CALLTYPE  FindInArray( POINTER *pArray, int nArraySize, POINTER unit );
/* Delete all allocated slabs.
   Parameters
   ppSet :  pointer to a generic set pointer to delete. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteSet( GENERICSET **ppSet );
/* <combine sack::containers::sets::DeleteSet@GENERICSET **>
   \ \                                                       */
#define DeleteSetEx( name, ppset ) { name##SET **delete_me = ppset; DeleteSet( (GENERICSET**)delete_me ); }
/* <combine sack::containers::sets::ForAllInSet>
   ForAllinSet Callback - callback fucntion used with
   ForAllInSet                                        */
typedef uintptr_t (CPROC *FAISCallback)(void*,uintptr_t);
/* \ \
   Parameters
   pSet :      poiner to a set
   unitsize :  size of elements in the array
   max :       count of elements per set block
   f :         user callback function to call for each element in
               the set
   psv :       user data passed to the user callback when it is
               invoked for a member of the set.
   Returns
   If the user callback returns 0, the loop continues. If the
   user callback returns non zero then the looping through the
   set ends, and that result is returned.                         */
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE  _ForAllInSet( GENERICSET *pSet, int unitsize, int max, FAISCallback f, uintptr_t psv );
/* <combine sack::containers::sets::ForEachSetMember>
   ForEachSetMember Callback function - for the function '
   ForEachSetMember'                                       */
typedef uintptr_t (CPROC *FESMCallback)(INDEX,uintptr_t);
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE  ForEachSetMember ( GENERICSET *pSet, int unitsize, int max, FESMCallback f, uintptr_t psv );
 //def __cplusplus
#if 0
#define DeclareSet(name)	                                struct name##set_tag {	               uint32_t set_size;	                             uint32_t element_size;	                         uint32_t element_cnt;	                          PGENERICSET pool;	                        name##set_tag() {	                        element_size = sizeof( name );	             element_cnt = MAX##name##SPERSET;	          set_size = (element_size * element_cnt )+ ((((element_cnt + 31 )/ 32 )- 1 ) * 4) + sizeof( GENERICSET );	 pool = NULL;	                               }	    ~name##set_tag() { DeleteSet( &pool ); }	 name* grab() { return (name*)GetFromSetEx( &pool, set_size, element_size, element_cnt DBG_SRC ); }	 name* grab(INDEX member) { return (name*)GetSetMemberEx( &pool, member, set_size, element_size, element_cnt DBG_SRC ); }	 name* get(INDEX member) { return (this)?(name*)GetUsedSetMemberEx( &pool, member, set_size, element_size, element_cnt DBG_SRC ):(NULL); }	 void drop( name* member ) { DeleteFromSetEx( pool, (POINTER)member, element_size, element_cnt ); }	 int valid( name* member ) { return MemberValidInSetEx( pool, (POINTER)member, element_size, element_cnt ); }	 uintptr_t forall( FAISCallback f, uintptr_t psv ) { if( this ) return _ForAllInSet( pool, element_size, element_cnt, f, psv ); else return 0; }	 };	       typedef struct name##set_tag *P##name##SET, name##SET;
#define ForAllInSet(name, pset,f,psv) _ForAllInSet( (GENERICSET*)(pset), sizeof( name ), MAX##name##SPERSET, (f), (psv) )
#else
/* <combine sack::containers::sets::_ForAllInSet@GENERICSET *@int@int@FAISCallback@uintptr_t>
   \ \                                                                                       */
#define ForAllInSet(name, pset,f,psv) _ForAllInSet( (GENERICSET*)(pset), sizeof( name ), MAX##name##SPERSET, (f), (psv) )
/* Performs an iteration over each allocated set member. Calls
   the user provided callback routine with each element in the
   set.
   Parameters
   pSet :      pointer to the set to iterate
   unitsize :  size of each element
   max :       max count of elements per set block
   f :         function to call ( uintptr_t (*)(INDEX,uintptr_t) )
   psv :       user data value to pass to function as uintptr_t
   Returns
   uintptr_t - this value is the return of the user function if
   the function does not return 0. A non zero return from the
   user callback stops iteration.                                */
#define ForEachSetMember(name,pset,f,psv) ForEachSetMember( (GENERICSET*)(pset),sizeof(name),MAX##name##SPERSET, (f), (psv) )
#endif
//---------------------------------------------------------------------------
_SETS_NAMESPACE_END
_TEXT_NAMESPACE
// this defines more esoteric formatting notions...
// these data blocks will be zero sized, and ahve the TF_FORMATEX
// bit set.
//#define DEFAULT_COLOR 0xF7
//#define PRIOR_COLOR 0xF6 // this does not change the color....
// these enumerated ops put in the foreground field of a format
// with a flag of TF_FORMATEX will cause the specified operation
// to be carried out on a display (not files) or generated into
// the appropriate sequence (ansi out encode)
// -- correction
//  this is encoded into its own field for the format
// size, due to machine optimization, 16 bits were free
// this was expanded and used for all information
// a segment may contain extended op, color, attributes,
// and text, everything short of a font for it...
//  - not sure how to address that issue... there's
// certainly modifications to current font... italic for
// instance..
	enum FORMAT_OPS {
      /* this segment clears to the end of the line.  Its content is then added to the output */
		FORMAT_OP_CLEAR_END_OF_LINE = 1
        ,FORMAT_OP_CLEAR_START_OF_LINE
                   ,
						  FORMAT_OP_CLEAR_LINE
						 ,
						  FORMAT_OP_CLEAR_END_OF_PAGE
                   ,
						  FORMAT_OP_CLEAR_START_OF_PAGE
						 ,
/* clear the entire vieable page (pushes all content to history)
                    set cursor home ;6*/
						  FORMAT_OP_CLEAR_PAGE
						 ,
						  FORMAT_OP_CONCEAL
                   ,
						  FORMAT_OP_DELETE_CHARS
                   ,
						  FORMAT_OP_SET_SCROLL_REGION
                   ,
						  FORMAT_OP_GET_CURSOR
						 ,
						  FORMAT_OP_SET_CURSOR
						 ,
						  FORMAT_OP_PAGE_BREAK
						 ,
/* break between paragraphs - kinda same as lines...
						  since lines are as long as possible... ;13 */
						 FORMAT_OP_PARAGRAPH_BREAK
						 ,
/* Justify line(s if wrapped) to the right
						   This attribute should be passed through to renderer;14*/
                   FORMAT_OP_JUSTIFY_RIGHT
						 ,
/* Justify line(s if wrapped) to the center
						 This attribute should be passed through to renderer;15*/
                   FORMAT_OP_JUSTIFY_CENTER
};
//typedef struct text_color_tag { uint32_t color: 8; } TEXTCOLOR;
// this was a 32 bit structure, but 8 fore, 8 back
// 8 x, 8 y failed for positioning...
// extended position, added more information
// reduced color, 16 colors is really all that there
// are... 4 bits... added bits for extended formatting
// like blink, bold, wide, high
// foreground/background  values will be
// sufficient... they retain full informaiton
//
typedef struct format_info_tag
{
   /* bit-packed flags indicating the type of format information that is applied to this segment.*/
	struct {
		// extended operation from enumeration above...
		// might shrink if more attributes are desired...
		// if many more are needed, one might consider
      // adding FONT!
     /* this segment uses the prior foreground, not its own. */
		BIT_FIELD prior_foreground : 1;
     /* this segment uses the prior background, not its own. */
		BIT_FIELD prior_background : 1;
     /* this segment uses the default foreground, not its own. */
		BIT_FIELD default_foreground : 1;
      /* this segment uses the default background, not its own. */
		BIT_FIELD default_background : 1;
      /* the foreground color of this segment (0-16 standard console text [ANSI text]) */
		BIT_FIELD foreground : 4;
      /* the background color of this segment (0-16 standard console text [ANSI text]) */
		BIT_FIELD background : 4;
      /* a bit indicating the text should blink if supported */
		BIT_FIELD blink : 1;
      /* a bit indicating the foreground and background color should be reversed */
		BIT_FIELD reverse : 1;
		// usually highly is bolder, perhaps it's
      // a highlighter effect and changes the background
		BIT_FIELD highlight : 1;
		// this is double height modifications to the font...
		BIT_FIELD tall : 1;
      // this is thicker characters...
		BIT_FIELD bold : 1;
      // draw a line under the text...
		BIT_FIELD underline : 1;
		// strike through - if able, draw a line right
		// through the middle of the text... maybe
		// it's a wiggly scribble line?  maybe that
      // could be extended again?
		BIT_FIELD strike : 1;
      // text is drawn wide (printer kinda font?)
		BIT_FIELD wide : 1;
       // this is pretty common......
		BIT_FIELD italic : 1;
		// --
		// these flags are free, but since we already have text segments
		// and I'm bringing in consoles, perhaps we should consider using
		// this to describe captions, but provide the api layer for CTEXTSTR
		// --
		// position data remains constant.
		// text is mounted at the top/left of the
		// first character... (unless center, then
		// the position specifies the middle of the text
		// draw vertical instead of horizontal
		BIT_FIELD bVertical:1;
		// draw opposite/upside down from normal
		// vertical/down, right/left upside down if not centered
		// if centered, the text pivots around position.
		BIT_FIELD bInvert:1;
		// 0 = default alignment 1 = left, 2 = center 3 = right
		// 0 is not set, the flag set in the lower 32 bit flags
		// is not needed any longer.... anything non zero
		// is that operation to apply.
		BIT_FIELD bAlign:2;
      /* format op indicates one of the enum FORMAT_OPS applies to this segment */
		BIT_FIELD format_op : 7;
	} flags;
	// if x,y are valid segment will have TF_POSFORMAT set...
	union {
		/* Coordinate information attached to a text segment. */
		/* Positioning specification of this text segment. with
		   basically 0 format options, position is used.
		   Position represents the distance from this segment to the
		   prior segment in count of tabs and spaces.
		   coords specifies an x,y coordinate location for the segment.
		   Usage of this union is dependant on <link text::format_info_tag::flags@1::format_op, format_op>. */
		struct {
         // Signed coordinate of this segment on a text display.  May be relative depending on format_op.
			int16_t x;
         // Signed coordinate of this segment on a text display.  May be relative depending on format_op.
			int16_t y;
		} coords;
		/* Defines the distance from the prior segment in count of tabs
		   and spaces (mostly count of spaces).                         */
		struct {
   // tabs preceed spaces....
			uint16_t tabs;
 // not sure what else to put with this...
			uint16_t spaces;
		} offset;
	} position;
} FORMAT, *PFORMAT;
 // special coordinate which is NO coordinate
#define IGNORE_CURSOR_POS -16384
/* test flag, format has position data */
#define TF_FORMATPOS (TF_FORMATABS|TF_FORMATREL|TF_FORMATEX)
/* these flags are used in PTEXT.flags member
 applications may use these flags to group expressions
 will affect the BuildLine but is not generated by library.
( TF_QUOTE, TF_SQUOTE, TF_BRACKET, TF_BRACE, TF_PAREN, and TF_TAG).
*/
enum TextFlags {
   // declared in program data.... do NOT release
 TF_STATIC    = 0x00000001,
   // double quoted string segment " "
 TF_QUOTE     = 0x00000002,
   // single quoted string ' '
 TF_SQUOTE    = 0x00000004,
   // bracketed expression []
 TF_BRACKET   = 0x00000008,
   // braced expression {}
 TF_BRACE     = 0x00000010,
   // parenthised expression ()
 TF_PAREN     = 0x00000020,
   // HTML tag like expression &lt;&gt;
 TF_TAG       = 0x00000040,
   // foreground is FORMAT_OP
 TF_FORMATEX  = 0x00000080,
   // x,y position used (relative)
 TF_FORMATREL = 0x00000100,
   // size field extually points at PTEXT
 TF_INDIRECT  = 0x00000200,
   // format position is x/y - else space count
 TF_FORMATABS = 0x00000800,
   // set during burst for last segment...
 TF_COMPLETE  = 0x00001000,
   // set for non-text variable
 TF_BINARY    = 0x00002000,
   // on release release indrect also...
 TF_DEEP      = 0x00004000,
   // set on first segment to send to omit lead \r\n
 TF_NORETURN  = 0x00008000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
// Low bound of value...
  TF_LOWER     = 0x00010000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
  // Upper bound of a value...
  TF_UPPER     = 0x00020000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
// boundry may be ON this value...
 TF_EQUAL     = 0x00040000,
   // this segment is not a permanent part (SubstToken)
 TF_TEMP      = 0x00080000,
  // this is something special do not treat as text indirect.
 TF_APPLICATION = 0x00100000,
};
//--------------------------------------------------------------------------
// flag combinatoin which represents actual data is present even with 0 size
// extended format operations (position, ops) are also considered data.
#define IS_DATA_FLAGS (TF_QUOTE|TF_SQUOTE|TF_BRACKET|TF_BRACE|                              TF_PAREN|TF_TAG|TF_FORMATEX|TF_FORMATABS|TF_FORMATREL)
// this THis defines/initializes the data part of a PTEXT/TEXT structure.
// used with DECLTEXTSZTYPE
#define DECLDATA(name,length) struct {size_t size; TEXTCHAR data[length];} name
#define DECLTEXTSZTYPE( name, size ) struct {    uint32_t flags;    struct text_segment_tag *Next, *Prior;    FORMAT format;    DECLDATA(data, size); } name
/* A macro to declare a structure which is the same physically
   as a PTEXT, (for declaring static buffers). Has to be cast to
   (PTEXT) is used. Is defined as a size, but no string content.
   Parameters
   name :  name of the variable to create
   size :  size of the static text element. (0 content)          */
#define DECLTEXTSZ( name, size ) DECLTEXTSZTYPE( name,(size) )	 = { TF_STATIC, NULL, NULL, {{1,1  ,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}} }
/* Defines an initializer block which can be used to satisfy a
   TEXT elemnt of a structure
   Parameters
   str :  string content of the TEXT
   Example
   <code lang="c++">
   TEXT something = DEFTEXT( "abc" );
   </code>                                                     */
#define DEFTEXT(str) {TF_STATIC,NULL,NULL,{{1,1}},{(sizeof(str)/sizeof(str[0]))-1,str}}
/* A macro to declare a structure which is the same physically
   as a PTEXT, (for declaring constant static strings
   basically). Has to be cast to (PTEXT) is used.
   Parameters
   name :   name of the variable to create
   value :  static string constant to initialize variable to.  */
#define DECLTEXT(name, str) static DECLTEXTSZTYPE( name, (sizeof(str)/sizeof(str[0])) ) = DEFTEXT(str)
/* Description
   A Text segment, it is based on DataBlock that has a length
   and an addtional region at the end of the structure which
   contains the text of the segment. Segments may have
   formatting attributes. Segments may be linked to other
   segments in a NEXTLINE/PRIORLINE. Segments may have indirect
   content, which may represent phrases. Sets of segments may
   represent sentence diagrams. A Pointer to a <link text::TEXT, TEXT>
   type.
   TEXT is a type I created to provide a variety of functions.
   One particular application was a common language processor,
   and I created the TEXT structure to store elements which are
   described by language. Sentences are words, and phases. A
   phrase is a set of words, but sometimes a word is a phrase.
   (sentence) = ( word ) ... (phrase ) ...
   (phrase) = (word)...
   hmm.. how to describe this.
   <code lang="c++">
   PTEXT phrase = NULL;
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   </code>
   <code>
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   </code>
   PTEXT segments point at other segments. A list of segments is
   a sentence. Segments can have information encoded on them
   that remove text from them. For instance, \< and \> tags
   might be removed around a phrase and stored as an attribute
   of the segment. A segment with such an attribute could be an
   indirect segment that points at a list of words which are the
   phrases in the tag.
   <code lang="c++">
   a map of two segments, and their content...
       (segment with TF_TAG) -\> (segment with TF_TAG)
             |                        |
             \+ - ("html")             + - (body) -\> (background="#000000")
   would actually expand to
      \<html\>\<body background="#000000"\>
   </code>
   See Also
   SegCreate
   burst
   TextParse
   SegAppend
   SegSubst
   SegSplit
   SegGrab
   SegDelete
   LineRelease
   BuildLine
   and also.....
   PVARTEXT                                                                  */
typedef struct text_segment_tag
{
	// then here I could overlap with pEnt .bshadow, bmacro, btext ?
   uint32_t flags;
	/* This points to the next segment in the sentence or phrase. NULL
	   if at the end of the line.                                      */
		struct text_segment_tag *Next;
	/* This points to the prior segment in the sentence or phrase. (NULL
	   if at the first segment)                                          */
		struct text_segment_tag *Prior;
	/* format is 64 bits.
      it's two 32 bit bitfields (position, expression)
	 valid if TF_FORMAT is set... */
	FORMAT format;
   /* A description of the data stored here.  It is compatible with a DATABLOCk.... */
   struct {
	   /* unsigned size; size is sometimes a pointer value...
                  this means bad thing when we change platforms... Or not, since we went to uintptr_t which is big enough for a pointer. */
		uintptr_t size;
		/* the data of the test segment
		 beginning of var data - this is created size+sizeof(TEXT) */
		   TEXTCHAR  data[1];
	} data;
} TEXT, *PTEXT;
//
// PTEXT DumpText( PTEXT somestring )
//    PTExT (single data segment with full description \r in text)
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  DumpText ( PTEXT text );
//SegCreateFromText( ".." );
// Burst, SegAppend, SegGrab
// segments are ment to be lines, the meaninful tag "TF_NORETURN" means it's part of the prior line.
//--------------------------------------------------------------------------
#define HAS_WHITESPACE(pText) ( pText && ( (pText)->format.position.offset.spaces || (pText)->format.position.offset.tabs ) )
/* A convenient macro to go from one segment in a line of text
   to the next segment.                                        */
#define NEXTLINE(line)   ((PTEXT)(((PTEXT)line)?(((PTEXT)line)->Next):(NULL)))
/* A convenient macro to go from one segment in a line of text
   to the prior segment.                                       */
#define PRIORLINE(line)  ((PTEXT)(((PTEXT)line)?(((PTEXT)line)->Prior):(NULL)))
/* Link one PTEXT segment to another. Sets one half of the links
   appropriate for usage.
   Example
   This example sets the prior pointer of 'word' to 'line'.
   <code>
   PTEXT line;
   PTEXT word;
   SETPRIORLINE( word, line );
   </code>                                                       */
#define SETPRIORLINE(line,p) ((line)?(((line)->Prior) = (PTEXT)(p)):0)
/* Link one PTEXT segment to another. Sets one half of the links
   appropriate for usage.
   Example
   This example sets the next pointer of 'line' to 'word'.
   <code lang="c#">
   PTEXT line;
   PTEXT word;
   SETNEXTLINE( line, word );
   </code>                                                       */
#define SETNEXTLINE(line,p)  ((line)?(((line)->Next ) = (PTEXT)(p)):0)
/* Sets a pointer to PTEXT to the first text segment in the
   list.                                                    */
#define SetStart(line)     for(; line && PRIORLINE(line);line=PRIORLINE(line))
/* Sets a PTEXT to the last segment that it points to.
   Parameters
   line :  segment in the line to move to the end of.
   Remarks
   Updates the variable passed to point to the last segment. */
#define SetEnd(line)      for(; line && NEXTLINE(line); line=NEXTLINE(line))
// might also check to see if pseg is an indirect - setting this size would be BAD
#define SetTextSize(pseg, sz ) ((pseg)?((pseg)->data.size = (sz )):0)
/* gets the indect segment content (if any) from a PTEXT
   segment.                                              */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GetIndirect(PTEXT segment );
/* Get the format flags of a PTEXT.
                                    */
TYPELIB_PROC  uint32_t TYPELIB_CALLTYPE  GetTextFlags( PTEXT segment );
/* Gets the text segment length. */
TYPELIB_PROC  size_t TYPELIB_CALLTYPE  GetTextSize( PTEXT segment );
/* Gets the text of a PTEXT segment. (convert to a CTEXTSTR)
   Parameters
   segment :  segment to get the string content from         */
TYPELIB_PROC  TEXTSTR TYPELIB_CALLTYPE  GetText( PTEXT segment );
// by registering for TF_APPLICTION is set on the segment
// and flags anded with the segment flags match, the
// function is called.... the result is the actual
// segment of this - since a TF_APPLICATION is also
// TF_INDIRECT - using the size to point to some application
// defined structure instead of a PTEXT structure.
TYPELIB_PROC  void TYPELIB_CALLTYPE  RegisterTextExtension ( uint32_t flags, PTEXT(CPROC*)(uintptr_t,POINTER), uintptr_t );
// similar to GetIndirect - but results in the literal pointer
// instead of the text that the application may have registered to result with.
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE  GetApplicationPointer ( PTEXT text );
/* Used to set the content of a segment to some application
   defined value. This allows a users application to store
   chunks of data in lists of text. These external chunks are
   handled like other words.
   Parameters
   text :  this is the text segment to set application data on
   p :     this is a pointer to application data               */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetApplicationPointer ( PTEXT text, POINTER p);
/* Set segment's indirect data.
   Parameters
   segment :  pointer to a TEXT segment to set the indirect content
              of.
   data :     pointer to a PTEXT to be referenced indirectly.       */
#define SetIndirect(Seg,Where)  ( (Seg)->data.size = ((uintptr_t)(Where)-(uintptr_t)NULL) )
		/* these return 1 for more(l1&gt;l2) -1 for (l1&lt;l2) and 0 for match.
       */
TYPELIB_PROC  int TYPELIB_CALLTYPE  SameText ( PTEXT l1, PTEXT l2 );
/* A test if one PTEXT is similar to another PTEXT.
   Parameters
   l1 :  PTEXT segment one
   l2 :  PTEXT segment two
   Return Value List
   \<0 :  l1 with case insensitive comparison is less then l2
   0 :    Texts compare case insenitive match
   \>0 :  l1 with case insensitive comparison is more than l2 */
TYPELIB_PROC  int TYPELIB_CALLTYPE  LikeText ( PTEXT l1, PTEXT l2 );
/* Compares if text is like a C string. Case Sensitive.
   <b>Returns</b>
   TRUE if they are alike.
   FALSE if they are different.
   <b>Parameters</b>                                    */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextIs  ( PTEXT pText, CTEXTSTR text );
/* Compares if text is like a C string. Case insensitive (like).
   Returns
   TRUE if they are alike.
   FALSE if they are different.
   Parameters
   pText :  PTEXT segment to compare
   text :   C string buffer to compare against                   */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextLike  ( PTEXT pText, CTEXTSTR text );
/* Compares if text is like a C string. Case insensitive (like). Uses min string length for max match.
   Returns
   TRUE if they are similar (both case insensitive using shorter of the strings for maxlen).
   FALSE if they are different.
   Parameters
   pText :  PTEXT segment to compare
   text :   C string buffer to compare against                   */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextSimilar  ( PTEXT pText, CTEXTSTR text );
//#define SameText( l1, l2 )  ( strcmp( GetText(l1), GetText(l2) ) )
#define textmin(a,b) ( (((a)>0)&&((b)>0))?(((a)<(b))?(a):(b)):(((a)>0)?(a):((b)>0)?(b):0) )
#ifdef __LINUX__
#  include <strings.h>
/* windows went with stricmp() and strnicmp(), whereas linux
 went with strcasecmp() and strncasecmp()                  */
#  define strnicmp strncasecmp
/* windows went with stricmp() and strnicmp(), whereas linux
   went with strcasecmp() and strncasecmp()                  */
#  define stricmp strcasecmp
#endif
/* Copy segment formatting to another segment... */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SegCopyFormat( PTEXT to_this, PTEXT copy_this );
/* Create a text segment of sepecified size; inclues one more character for NUL terminator */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateEx( size_t nSize DBG_PASS );
/* Create a PTEXT with specified number of character capacity.
   Example
   <code lang="c#">
   PTEXT text = SegCreate( 10 );
   </code>                                                     */
#define SegCreate(s) SegCreateEx(s DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromText> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromTextEx( CTEXTSTR text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromText( "Around the world in a day." );
   </code>                                                         */
#define SegCreateFromText(t) SegCreateFromTextEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromCharLenEx( const char *text, size_t len DBG_PASS );
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromCharEx( const char *text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromChar( "Around the world in a day." );
   </code>                                                         */
#define SegCreateFromChar(t) SegCreateFromCharEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
#define SegCreateFromCharLen(t,len) SegCreateFromCharLenEx((t),(len) DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromWideLenEx( const wchar_t *text, size_t len DBG_PASS );
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromWideEx( const wchar_t *text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromWideLen( L"Around the world in a day.", 26 );
   </code>                                                         */
#define SegCreateFromWideLen(t,len) SegCreateFromWideLenEx((t),(len) DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
#define SegCreateFromWide(t) SegCreateFromWideEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateIndirect> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateIndirectEx( PTEXT pText DBG_PASS );
/* Creates a text segment that refers to the parameter
   indirectly. The new segment is not really a clone, but a
   reference of the original PTEXT.
   Example
   <code lang="c#">
   PTEXT phrase = SegCreateIndirect( SegAppend( SegCreateFromText( "Hello" )
                                              , SegCreateFromText( "World" ) ) );
   </code>
   The resulting phrase is a single segment with no prior or
   next, but its content is "HelloWorld" if it was passed to
   buildline... it's go the content of the two text segments
   linked together, but not in its buffer. It is actually a 0
   length buffer for a TEXT segment.
                                                                                  */
#define SegCreateIndirect(t) SegCreateIndirectEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegDuplicate> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegDuplicateEx( PTEXT pText DBG_PASS);
/* This duplicates a specific segment. It duplicates the first
   segment of a string. If the segment has indirect data, then
   the first segment of the indirect data is duplicated.       */
#define SegDuplicate(pt) SegDuplicateEx( pt DBG_SRC )
/* Duplicates a linked list of segments.
   Duplicates the structure of a line. The resulting line is an
   exact duplicate of the input line. All segments linked in
   exactly the same sorts of ways.
   Parameters
   line :  list of segments to duplicate                        */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  LineDuplicateEx( PTEXT pText DBG_PASS );
/* <combine sack::containers::text::LineDuplicateEx@PTEXT pText>
   \ \                                                           */
#define LineDuplicate(pt) LineDuplicateEx(pt DBG_SRC )
/* \ \
   See Also
   <link DBG_PASS>
   <link TextDuplicate> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  TextDuplicateEx( PTEXT pText, int bSingle DBG_PASS );
/* Duplicate the whole string of text to another string with
   exactly the same content.                                 */
#define TextDuplicate(pt,s) TextDuplicateEx(pt,s DBG_SRC )
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromInt> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromIntEx( int value DBG_PASS );
/* Creates a text segment from a 64 bit integer.
   Example
   <code>
   PTEXT number = SegCreateFromInt( 3314 );
   </code>                                       */
#define SegCreateFromInt(v) SegCreateFromIntEx( v DBG_SRC )
/* Converts an integer to a PTEXT segment.
   Parameters
   _64bit_value :  integer value to convert to a PTEXT segment. */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFrom_64Ex( int64_t value DBG_PASS );
/* Create a text segment from a uint64_t bit value. (long long int) */
#define SegCreateFrom_64(v) SegCreateFrom_64Ex( v DBG_SRC )
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromFloat> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromFloatEx( float value DBG_PASS );
/* Creates a text segment from a floating point value. Probably
   uses something like '%g' to format output. Fairly limited.
   Example
   <code lang="c++">
   PTEXT short_PI = SegCreateFromFloat( 3.14 );
   </code>                                                      */
#define SegCreateFromFloat(v) SegCreateFromFloatEx( v DBG_SRC )
/* Appends a list of segments to an existing list of segments. This
   assumes that the additional segment is referncing the head of
   the segment list.
   Parameters
   source :  source list to add to
   other :   additional segments to add to source.                  */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegAppend   ( PTEXT source, PTEXT other );
/* Inserts a segment before another segment.
   Parameters
   what :    what to insert into the list
   before :  insert the segments before this segment
   Returns
   The parameter 'what'.                             */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegInsert   ( PTEXT what, PTEXT before );
/* This expands a segment by a number of characters.
   Parameters
   PTEXT :  the segment to expand
   int :    count of character to expand by
   Returns
   A pointer to a new segment that is bigger, but has the same
   existing content.                                           */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegExpandEx (PTEXT source, INDEX nSize DBG_PASS );
/* <combine sack::containers::text::SegExpandEx@PTEXT@INDEX nSize>
   \ \                                                             */
#define SegExpand(s,n) SegExpandEx( s,n DBG_SRC )
/* Release a linked list of PTEXT segments.
   Parameters
   segments :  a segment in a list of segments to delete, first
               this routine goes to the start of the segment
               list, and then deletes all segments in the list.
   DBG_PASS :  debug file and line information                  */
TYPELIB_PROC  void TYPELIB_CALLTYPE   LineReleaseEx (PTEXT line DBG_PASS );
/* Release a line of text.
   A line may be a single segment.
   This is the proper way to dispose of PTEXT segments.
   Any segment in the line may be passed, the first segment is
   found, and then all segments in the line are deleted.       */
#define LineRelease(l) LineReleaseEx(l DBG_SRC )
/* \ \
   <b>See Also</b>
   <link DBG_PASS>
   <link SegRelease> */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SegReleaseEx( PTEXT seg DBG_PASS );
/* Release a single segment. UNSAFE. Does not respect that it is
   in a list.
   See Also
   <link LineRelease>                                            */
#define SegRelease(l) SegReleaseEx(l DBG_SRC )
/* Adds a part of input to the segment list of output.
   Parameters
   output\ :   the segment list to append to.
   input\ :    the input buffer to append from
   offset :    starting offset in 'input' to start from
   length :    how much from 'offset' in input to append as a new
               segment to output.
   DBG_PASS :  \file and line debugging information               */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegConcatEx   (PTEXT output,PTEXT input,int32_t offset,size_t length DBG_PASS);
/* <combine sack::containers::text::SegConcatEx@PTEXT@PTEXT@int32_t@size_t length>
   looks like it takes a piece of one segment and appends it to
   another....
   Needs More research to document correctly and exemplify.                     */
#define SegConcat(out,in,ofs,len) SegConcatEx(out,in,ofs,len DBG_SRC)
/* Removes a segment from a list of segments. Links what was
   prior and what was after together. Sets both next and prior
   of the segment unlinked to NULL.
   Example
   <code lang="c++">
   SegUnlink( segment );
   </code>
   Returns
   The segment passed.                                         */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegUnlink   (PTEXT segment);
/* Breaks a list of PTEXT segments at the specified segment and
   \returns a segment that was before the specified.
   Parameters
   segment :  segment to break the chain at
   Returns
   Any existing segment before the segment to break at.
   Example
   <code lang="c++">
   {
      PTEXT segs;
      PTEXT breakat;
      PTEXT leftover;
		&#47;* ... segs gets populated with some segments ... *&#47;
      breakat = NEXTLINE( segs );
   </code>
   <code>
      breakat = NEXTLINE( segs );
      leftover = segbreak( breakat );
      // now breakat begins a new chain of segments
      // leftover is the segment that was just before breakat
      SegStart( leftover );  // leftover would be equal to segs...
   }
   </code>                                                         */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegBreak    (PTEXT segment);
/* Removes a segment from a list. It also releases the segment.
    Example
    <code lang="c#">
    SegDelete( segment );
    </code>
    the result is NULL;                                          */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegDelete   (PTEXT segment);
/* removes segment from any list it might be in, returns
   segment.                                              */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegGrab     (PTEXT segment);
/* Substitute one PTEXT segment for another in a list of PTEXT
   segments.
   Parameters
   _this :  This is the segment to remove
   that :   This is the segment to subustitute with. This may be
            a list of segments, and it is linked in from the
            first segment to the prior to '_this' and the last to
            the next after '_this'
   Returns
   \Returns the '_this' that was substituted.                     */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegSubst    ( PTEXT _this, PTEXT that );
/* \ \
   See Also
   <link DBG_PASS>
   <link SegSplit> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegSplitEx( PTEXT *pLine, INDEX nPos DBG_PASS);
/* Split a PTEXT segment.
   Example
   \ \
   <code lang="c++">
   PTEXT result = SegSplit( &amp;old_string, 5 );
   </code>
   Returns
   PTEXT new_string;
   Remarks
   the old string segment is split at the position indicated. The
   pointer to the old segment is modified to point to now two
   segments linked dynamically, each part of the segment after
   the split. If the index is beyond the bounds of the segment,
   the segment remains unmodified.                                */
#define SegSplit(line,pos) SegSplitEx( line, pos DBG_SRC )
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  FlattenLine ( PTEXT pLine );
/* Create a highest precision signed integer from a PTEXT. */
TYPELIB_PROC  int64_t TYPELIB_CALLTYPE  IntCreateFromSeg( PTEXT pText );
/* Converts a text to the longest precision signed integer
   value.
     allows +/- leadin ([-*]|[+*])*
     supports 0x### (hex), 0b#### (binary), 0o#### (octal), 0### (octal)
	 decimal 1-9[0-9]*
	 buggy implementation supports +/- inline continue number and are either ignored(+)
	 or changes the overall sign of the number(-).  A Decimal definatly ends the number.
	 And octal/binary digits aren't checked for range, so 8/9 will over-flow in octal,
	 and 2-9 overflow to upper bits in octal...
	    0b901090 // would be like   0b 10100110    0b1001 +  010 + 1001<<3 + 0
   */
TYPELIB_PROC  int64_t TYPELIB_CALLTYPE  IntCreateFromText( CTEXTSTR p );
/* Converts a text to the longest precision signed integer
   value.  Does the work of IntCreateFromText.
   IntCreateFromTextRef updates the pointer passed by reference so
   the pointer ends at the first character after the returned number.
   */
TYPELIB_PROC  int64_t TYPELIB_CALLTYPE  IntCreateFromTextRef( CTEXTSTR *p_ );
/* Create a high precision floating point value from PTEXT
   segment.                                                */
TYPELIB_PROC  double TYPELIB_CALLTYPE  FloatCreateFromSeg( PTEXT pText );
/* Create a high precision floating point value from text
   string.                                                */
TYPELIB_PROC  double TYPELIB_CALLTYPE  FloatCreateFromText( CTEXTSTR p, CTEXTSTR *pp );
//
// IsSegAnyNumber returns 0 if no, 1 if is int, 2 if is float
//   if pfNumber or piNumber are available then the text pointer
//   will be updated to the next segment after what was used to resolve
//   the number.
//   bUseAllSegs is for testing pTexts which are indirect, such that
//      only all segments within the indirect segment will result valid.
//   pfNumber and piNumber may be passed as NULL, and the function can still
// be used to determine ifnumber
//   the number resulting in the values pointed to will be filled in
//    with (*pfNumber)=FltCreateFromSeg(p) (or Int as appropriate)
//
//#define IsNumber(p) IsSegAnyNumberEx( &(p), NULL, NULL, NULL, 0 )
#define IsIntNumber(p, pint) IsSegAnyNumberEx( &(p), NULL, pint, NULL, 0 )
/* Tests a PTEXT segment to see if it might be a floating point
   number.                                                      */
#define IsFltNumber(p, pflt) IsSegAnyNumberEx( &(p), pflt, NULL, NULL, 0 )
/* Tests the content of a PTEXT to see if it might be a number.
   Parameters
   ppText :       pointer to PTEXT to check
   pfNumber :     pointer to double to get result of number it's
                  a float
   piNumber :     pointer to a signed 64 bit value to get the
                  \result if it's not a float.
   pbIsInt :      point to a integer \- receives boolean result
                  if the segment was an integer is TRUE else it's
                  a double.
   bUseAllSegs :  if TRUE, use all the segments starting with the
                  first, and update the pointer to the next
                  stgment. If false, use only the first segment. if
                  uses all segments, it must also use ALL
                  segments to get the number.
   Returns
   0 if not a number or fails.
   1 if a valid conversion took place.                              */
TYPELIB_PROC  int TYPELIB_CALLTYPE  IsSegAnyNumberEx ( PTEXT *ppText, double *pfNumber, int64_t *piNumber, int *pbIsInt, int bUseAllSegs );
/* <combine sack::containers::text::IsSegAnyNumberEx@PTEXT *@double *@int64_t *@int *@int>
   \ \                                                                                  */
#define IsSegAnyNumber(pptext, pfNum, piNum, pbIsInt) IsSegAnyNumberEx( pptext, pfNum, piNum, pbIsInt, 0 )
/* \Returns the amount of space required to store this segment,
   and all indirect statements it contains.
   Parameters
   segment :   segment to measure
   position :  starting position in the segment to measure from
   nTabSize :  how big tabs are supposed to be
   tabs :      list of tab positions (for arbitrary tab
               positioning\- table column alignment?)           */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentSpaceEx ( PTEXT segment, INDEX position, int nTabs, INDEX *tabs);
/* \Returns the amount of space required to store this segment,
   and all indirect statements it contains.
   Parameters
   segment :   segment to measure
   position :  starting position in the segment to measure
               from
   nTabSize :  how big tabs are supposed to be                  */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentSpace ( PTEXT segment, INDEX position, int nTabSize );
/* Simlar to getsegment space... */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentLengthEx ( PTEXT segment, INDEX position, int nTabs, INDEX *tabs );
/* \Returns the length of a single PTEXT segment.
   Parameters
   segment :   segment to measure
   position :  string position in the string to measure
   nTabSize :  how many characters a tab is supposed to be. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentLength ( PTEXT segment, INDEX position, int nTabSize );
/* Measure the length of a list of segments (combined length of
   all linked segments)                                         */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  LineLengthExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL );
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  LineLengthExx( PTEXT pt, LOGICAL bSingle,PTEXT pEOL );
/* <combine sack::containers::text::LineLengthExEx@PTEXT@LOGICAL@int@PTEXT>
   \ \                                                                      */
#define LineLengthExx(pt,single,eol) LineLengthExEx( pt,single,8,eol)
/* \ \
   Parameters
   Text segment :  PTEXT line or segment to get the length of
   single :        boolean, if set then only a single segment is
                   measured, otherwise all segments from this to
                   the end are measured.                         */
#define LineLengthEx(pt,single) LineLengthExx( pt,single,NULL)
/* Computes the length of characters in a line, if all segments
   in the line are flattened into a single word.                */
#define LineLength(pt) LineLengthEx( pt, FALSE )
/* Collapses an indirect segment or a while list of segments
   into a single segment with content expanded. When passed to
   things like TextParse and Burst, segments have their
   positioning encoded to counters for tabs and spaces; the
   segment itself contains only text without whitespace. Buildline
   expands these segments into their plain text representation.
   Parameters
   pt :        pointer to a PTEXT segment.
   bSingle :   if TRUE, build only the first segment. If the
               segment is indirect, builds entire content of
               indirect.
   nTabsize :  how wide tabs are. When written into a line, tabs
               are written as spaces. (maybe if 0, tabs are
               emitted directly?)
   pEOL :      the segment to use to represent an end of line. Often
               this is a SegCreate(0) segment.                       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  BuildLineExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL DBG_PASS );
/* Collapses an indirect segment or a while list of segments
into a single segment with content expanded. When passed to
things like TextParse and Burst, segments have their
positioning encoded to counters for tabs and spaces; the
segment itself contains only text without whitespace. Buildline
expands these segments into their plain text representation.
Parameters
pt :        pointer to a PTEXT segment.
bSingle :   if TRUE, build only the first segment. If the
segment is indirect, builds entire content of
indirect.
pEOL :      the segment to use to represent an end of line. Often
this is a SegCreate(0) segment.                       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  BuildLineExx( PTEXT pt, LOGICAL bSingle, PTEXT pEOL DBG_PASS );
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
\ \                                                                          */
#define BuildLineExx(from,single,eol) BuildLineExEx( from,single,8,NULL DBG_SRC )
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
   \ \                                                                          */
#define BuildLineEx(from,single) BuildLineExEx( from,single,8,NULL DBG_SRC )
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
   \ \
    Flattens all segments in a line to a single segment result.
*/
#define BuildLine(from) BuildLineExEx( from, FALSE,8,NULL DBG_SRC )
//
// text parse - more generic flavor of burst.
//
//static CTEXTSTR normal_punctuation=WIDE("\'\"\\({[<>]}):@%/,;!?=*&$^~#`");
// filter_to_space " \t"
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  TextParse ( PTEXT input, CTEXTSTR punctuation, CTEXTSTR filter_tospace, int bTabs, int bSpaces  DBG_PASS );
/* normal_punctuation=WIDE("'"\\({[\<\>]}):@%/,;!?=*&amp;$^~#`");
   Process a line of PTEXT into another line of PTEXT, but with
   words parsed as appropriate for common language.
   Parameters
   input\ :  pointer to a list of PTEXT segments to parse.
   Remarks
   Burst is a simple method of breaking a sentence into its word
   and phrase parts. It collapses space and tabs before words
   into the word. Any space representation is space preceeding
   the word. Sentences are also broken on any punctuation.
   "({[\<\>]})'";;.,/?\\!@#$%^&amp;*=" for instances. + and - are
   treated specially if they prefix numbers, otherwise they are
   also punctuation. Also groups of '.' like '...' are kept
   together. if the '.' is in a number, it is stored as part of
   the number. Otherwise a '.' used in an abbreviation like P.S.
   will be a '.' with 0 spaces followed by a segment also with 0
   spaces. (unless it's the lsat one)
   so initials are encoded badly.
   Bugs
   There is an exploit in the parser such that . followed by a
   number will cause fail to break into seperate words. This is
   used by configuration scripts to write binary blocks, and
   read them back in, having the block parsed into a segment
   correctly.
   See Also
   <link sack::containers::text::TextParse@PTEXT@CTEXTSTR@CTEXTSTR@int@int bSpaces, TextParse> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  burstEx( PTEXT input DBG_PASS);
/* <combine sack::containers::text::burstEx@PTEXT input>
   \ \                                                   */
#define burst( input ) burstEx( (input) DBG_SRC )
/* Compares a couple lists of text segments.
   Parameters
   pt1 :      pointer to a phrase
   single1 :  use only the first word, not the whole phrase
   pt2 :      pointer to a phrase
   single2 :  use only the first segment, not the whole phrase
   bExact :   if FALSE, match case insensitive, otherwise match
              exact case.                                       */
TYPELIB_PROC  int TYPELIB_CALLTYPE  CompareStrings( PTEXT pt1, int single1
                            , PTEXT pt2, int single2
                            , int bExact );
/* This removes indirect segments, replacing them with their
   indirect content.
   Parameters
   pLine :  pointer to a PTEXT segment list to flatten.      */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  FlattenLine ( PTEXT pLine );
/* Steps through a linked list of segments, just a convenient
   for loop wrapper.                                          */
#define FORALLTEXT(start,var)  for(var=start;var; var=NEXTLINE(var))
/* returns number of characters filled into output.  Output needs to be at maximum 6 chars */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF8( char *output, TEXTRUNE rune );
/* returns number of characters filled into output.  Output needs to be at maximum 6 chars;  if overlong is set
   characters are deliberatly padded to be overlong */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF8Ex( char *output, TEXTRUNE rune, LOGICAL overlong );
/* returns number of wchar filled into output.  Output needs to be at maximum 2 wchar. */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF16( wchar_t *output, TEXTRUNE rune );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfChar( const char **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharIndexed( const char *from, size_t *index, size_t length );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfChar( const char *start, const char **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharIndexed( const char *from, size_t *index );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharW( const wchar_t **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharIndexedW( const wchar_t *from, size_t *index );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharW( const wchar_t *start, const wchar_t **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharIndexedW( const wchar_t *from, size_t *index );
TYPELIB_PROC size_t TYPELIB_CALLTYPE GetDisplayableCharacterCount( const char *string, size_t max_bytes );
TYPELIB_PROC CTEXTSTR TYPELIB_CALLTYPE GetDisplayableCharactersAtCount( const char *string, size_t character_index );
TYPELIB_PROC size_t TYPELIB_CALLTYPE  GetDisplayableCharacterBytes( const char *string, size_t character_count );
/* You Must Deallocate the result */
TYPELIB_PROC char * TYPELIB_CALLTYPE WcharConvert_v2 ( const wchar_t *wch, size_t len, size_t *outlen DBG_PASS );
/* You Must Deallocate the result */
TYPELIB_PROC  char * TYPELIB_CALLTYPE  WcharConvertExx ( const wchar_t *wch, size_t len DBG_PASS );
/* You Must Deallocate the result */
TYPELIB_PROC  char * TYPELIB_CALLTYPE  WcharConvertEx ( const wchar_t *wch DBG_PASS );
/* <combine sack::containers::text::WcharConvertExx@wchar_t *@size_t len>
   \ \                                                                    */
#define WcharConvertLen(s,len) WcharConvertExx(s, len DBG_SRC )
/* <combine sack::containers::text::WcharConvertExx@wchar_t *@size_t len>
   \ \                                                                    */
#define WcharConvert(s) WcharConvertEx(s DBG_SRC )
/* You Must Deallocate the result */
TYPELIB_PROC wchar_t * TYPELIB_CALLTYPE CharWConvertExx ( const char *wch, size_t len DBG_PASS );
/* Convert wchar_t strings to char strings.
   Parameters
   string :    wchar_t string to convert
   DBG_PASS :  debug file and line information
   Returns
   A char * string. This string must be Release()'ed or
   Deallocate()'ed by the user.                         */
TYPELIB_PROC wchar_t * TYPELIB_CALLTYPE CharWConvertEx ( const char *wch DBG_PASS );
/* <combine sack::containers::text::CharWConvertExx@char *@size_t len>
   \ \                                                                 */
#define CharWConvertLen(s,len) CharWConvertExx(s,len DBG_SRC )
/* <combine sack::containers::text::CharWConvertExx@char *@size_t len>
   \ \                                                                 */
#define CharWConvert(s) CharWConvertEx(s DBG_SRC )
//--------------------------------------------------------------------------
/* This is a string collector type.  It has an interface to be able to vtprintf( vartext, "format string", ... ); which appends the specified string to the collected text.
  Example
   PVARTEXT pvt = VarTextCreate();
   vtprintf( pvt, "hello world!" );
   {
      PTEXT text = VarTextGet( pvt );
	  printf( "Text is : %s(%d)", GetText( text ), GetTextSize( text ) );
	  LineRelease( text );
   }
   VarTextDestroy( &pvt );
   */
typedef struct vartext_tag *PVARTEXT;
/* Creates a variable text collector. Allows specification of
   initial size and amount to expand by. SQL Command line sample
   utility uses this and allocates like 10,000 initial and sets
   expand as 40,000, because it expects to build very large
   strings, and expansion of 32 at a time is ludicrous; if the
   space required is more than the expansion factor, then it is
   expanded by the amount required plus the expansion factor.
   Parameters
   initial :   amount of initial buffer
   exand_by :  how much to expand the buffer by when more room
               is needed
   DBG_PASS :  debug file and line parameters.                   */
TYPELIB_PROC  PVARTEXT TYPELIB_CALLTYPE  VarTextCreateExEx ( uint32_t initial, uint32_t expand DBG_PASS );
/* <combine sack::containers::text::VarTextCreateExEx@uint32_t@uint32_t expand>
   \ \                                                                */
#define VarTextCreateExx(i,e) VarTextCreateExEx(i,e DBG_SRC )
/* <combine sack::containers::text::VarTextCreateExEx@uint32_t@uint32_t expand>
   Creates a variable text collector. Default initial size and
   expansion is 0 and 32.
                                                                      */
TYPELIB_PROC  PVARTEXT TYPELIB_CALLTYPE  VarTextCreateEx ( DBG_VOIDPASS );
/* The simplest, most general way to create a PVARTEXT
   collector. The most extended vartext creator allows
   specification of how long the initial buffer is, and how much
   the buffer expands by when required. This was added to
   optimize building HUGE SQL queries, working withing 100k
   buffers that expanded by 50k at a time was a lot less
   operations than expanding 32 bytes or something at a time.    */
#define VarTextCreate() VarTextCreateEx( DBG_VOIDSRC )
/* Empties and destroys all resources associated with the
   variable text collector.
   Parameters
   pvt * :     address of a PVARTEXT reference to destroy. Sets
               the pointer to NULL when it's destroyed.
   DBG_PASS :  debugging file and line parameters
   Example
   <code lang="c++">
   {
      PVARTEXT pvt = VarTextCreate();
      VarTextDestroy( &amp;pvt );
   }
   void Function( int something DBG_PASS )
   {
      pvt = VarTextCreateEx( DBG_RELAY );
      VarTextDestroyEx( &amp;pvt DBG_RELAY );
   }
   </code>
   C++ Syntax
   \ \                                                          */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextDestroyEx ( PVARTEXT* DBG_PASS );
/* Destroy a VarText collector. */
#define VarTextDestroy(pvt) VarTextDestroyEx( pvt DBG_SRC )
/* \Internal function - used to initialize a VARTEXT structure. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextInitEx( PVARTEXT pvt DBG_PASS);
/* Probably should not be exported. Initializes a VARTEXT
   structure to prepare it for subsequent VarText operations. */
#define VarTextInit(pvt) VarTextInitEx( (pvt) DBG_SRC )
/* Empties a PVARTEXT structure.
   Parameters
   pvt :  PVARTEXT to empty.     */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextEmptyEx( PVARTEXT pvt DBG_PASS);
/* <combine sack::containers::text::VarTextEmptyEx@PVARTEXT pvt>
   \ \                                                           */
#define VarTextEmpty(pvt) VarTextEmptyEx( (pvt) DBG_SRC )
/* Add a single character to a vartext collector.
   Note
   \ \
   Parameters
   pvt :       PVARTEXT to add character to
   c :         character to add
   DBG_PASS :  optional debug information         */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddCharacterEx( PVARTEXT pvt, TEXTCHAR c DBG_PASS );
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddRuneEx( PVARTEXT pvt, TEXTRUNE c, LOGICAL overlong DBG_PASS );
/* Adds a single character to a PVARTEXT collector.
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddCharacter( pvt, 'a' );
   </code>                                          */
#define VarTextAddCharacter(pvt,c) VarTextAddCharacterEx( (pvt),(c) DBG_SRC )
/* Adds a single rune to a PVARTEXT collector. (may be multiple characters convert to UTF8)
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddRune( pvt, 'a' );
   </code>                                          */
#define VarTextAddRune(pvt,c) VarTextAddRuneEx( (pvt),(c), FALSE DBG_SRC )
/* Adds a length of data to the vartext. This allows strings
   with nuls included to be added.
   Parameters
   pvt :       PVARTEXT to add data to
   block :     pointer to data to add
   size :      length of data block to add
	DBG_PASS :  optional file and line parameters             */
#define VARTEXT_ADD_DATA_NULTERM ((size_t)0xFF000000)
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddDataEx( PVARTEXT pvt, CTEXTSTR block, size_t length DBG_PASS );
/* Adds a single character to a PVARTEXT collector.
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddData( pvt, "test one", 8 );
   </code>                                          */
#define VarTextAddData(pvt,block,length) VarTextAddDataEx( (pvt),(block),(length) DBG_SRC )
/* Commits the currently collected text to segment, and adds the
   segment to the internal line accumulator.
		 returns true if any data was added...
       move any collected text to commit... */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  VarTextEndEx( PVARTEXT pvt DBG_PASS );
/* <combine sack::containers::text::VarTextEndEx@PVARTEXT pvt>
   \ \                                                         */
#define VarTextEnd(pvt) VarTextEndEx( (pvt) DBG_SRC )
/* Gets the length of the current collection in the VARTEXT.
   Parameters
   pvt :  PVARTEXT collector to get the length.              */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  VarTextLength( PVARTEXT pvt );
/* Gets the text segment built in the VarText. The PVARTEXT is
   set to empty. Clears the collector.
   Parameters
   pvt :  PVARTEXT to get text from.                           */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  VarTextGetEx( PVARTEXT pvt DBG_PASS );
/* <combine sack::containers::text::VarTextGetEx@PVARTEXT pvt>
   \ \                                                         */
#define VarTextGet(pvt) VarTextGetEx( (pvt) DBG_SRC )
/* Used to look at the vartext collector and get the current
   collection. Does not clear the collector.
   Parameters
   pvt :       PVARTEXT collector to peek at
   DBG_PASS :  debugging file and line parameters
   Return Value List
   NULL :      No data
   not NULL :  text segment which is in the collector.       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  VarTextPeekEx ( PVARTEXT pvt DBG_PASS );
/* \Returns the PTEXT that is currently in a PVARTEXT. It does
   not alter the contents of the PVARTEXT. Do not LineRelease
   this peeked value.                                          */
#define VarTextPeek(pvt) VarTextPeekEx( (pvt) DBG_SRC )
/* Increases the internal storage size of the variable text
   collector.
   Parameters
   pvt :       the var text collector to expand
   amount :    amount of size to expand the collector
   DBG_PASS :  debugging file and line parameters           */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextExpandEx( PVARTEXT pvt, INDEX size DBG_PASS );
/* Add a specified number of characters to the amount of space
   in the VARTEXT collector.                                   */
#define VarTextExpand(pvt, sz) VarTextExpandEx( (pvt), (sz) DBG_SRC )
//TYPELIB_PROC  int vtprintfEx( PVARTEXT pvt DBG_PASS TYPELIB_CALLTYPE  CTEXTSTR format, ... ;
// note - don't include format - MUST have at least one parameter passed to ...
//#define vtprintf(pvt, ...) vtprintfEx( (pvt) DBG_SRC, __VA_ARGS__ )
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  vtprintfEx( PVARTEXT pvt, CTEXTSTR format, ... );
/* <combine sack::containers::text::vtprintfEx@PVARTEXT@CTEXTSTR@...>
   Note                                                               */
#define vtprintf vtprintfEx
/* variable argument VARTEXT printf. Is passed a PVARTEXT to
   collect the formatted output using printf sort of formatting. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  vvtprintf( PVARTEXT pvt, CTEXTSTR format, va_list args );
/* encode binary buffer into base64 encoding.
   outsize is updated with the length of the buffer.
 */
TYPELIB_PROC  TEXTCHAR * TYPELIB_CALLTYPE  EncodeBase64Ex( const uint8_t* buf, size_t length, size_t *outsize, const char *encoding );
/* decode base64 buffer into binary buffer
   outsize is updated with the length of the buffer.
   result should be Release()'d
 */
TYPELIB_PROC  uint8_t * TYPELIB_CALLTYPE  DecodeBase64Ex( const char* buf, size_t length, size_t *outsize, const char *encoding );
/* xor a base64 encoded string over a utf8 string, keeping the utf8 characters in the same length...
   although technically this can result in invalid character encoding where upper bits get zeroed
   result should be Release()'d
*/
TYPELIB_PROC  char * TYPELIB_CALLTYPE  u8xor( const char *a, size_t alen, const char *b, size_t blen, int *ofs );
/* xor two base64 encoded strings, resulting in a base64 string
   result should be Release()'d
*/
TYPELIB_PROC  char * TYPELIB_CALLTYPE  b64xor( const char *a, const char *b );
//--------------------------------------------------------------------------
// extended command entry stuff... handles editing buffers with insert/overwrite/copy/paste/etc...
typedef struct user_input_buffer_tag {
	// -------------------- custom cmd buffer extension
  // position counter for pulling history; negative indexes are recalled commands.
	int nHistory;
  // a link queue which contains the prior lines of text entered for commands.
	PLINKQUEUE InputHistory;
 // set to TRUE when nHistory has wrapped...
	int   bRecallBegin;
   /* A exchange-lock variable for controlling access to the
      \history (so things aren't being read from it while it is
      scrolling old data out).                                  */
	uint32_t   CollectionBufferLock;
  // used to store index.. for insert type operations...
	INDEX CollectionIndex;
 // flag for whether we are inserting or overwriting
	int   CollectionInsert;
 // flag for whether we are inserting or overwriting
	int   storeCR;
 // used to store partial from GatherLine
	PTEXT CollectionBuffer;
 // called when a buffer is complete.
	void (CPROC*CollectedEvent)( uintptr_t psv, PTEXT text );
  // passed to the event callback when a line is completed
	uintptr_t psvCollectedEvent;
} USER_INPUT_BUFFER, *PUSER_INPUT_BUFFER;
/* Creates a buffer structure which behaves like the command
   line command recall queue.
                                                             */
TYPELIB_PROC  PUSER_INPUT_BUFFER TYPELIB_CALLTYPE  CreateUserInputBuffer ( void );
/* Destroy a created user input buffer. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DestroyUserInputBuffer ( PUSER_INPUT_BUFFER *pci );
// negative with SEEK_SET is SEEK_END -nPos
enum CommandPositionOps {
	// defined that the x,y position in the segment should be used for absolute positioning.
   // can also be SEEK_SET
 COMMAND_POS_SET = 0,
 // defined that the x,y position in the segment should be used for relative positioning.
 // can also be SEEK_CUR
 COMMAND_POS_CUR = 1
};
/* Updates the current input position, for things like input,
   etc. Some external process indicates where in the line to set
   the cursor position.                                          */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  SetUserInputPosition ( PUSER_INPUT_BUFFER pci, int nPos, int whence );
// bInsert < 0 toggle insert.  bInsert == 0 clear isnert(set overwrite) else
// set insert (clear overwrite )
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetUserInputInsert ( PUSER_INPUT_BUFFER pci, int bInsert );
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetUserInputSaveCR( PUSER_INPUT_BUFFER pci, int bSaveCR );
/* Get the next command in the queue in the speicifed direction
   Parameters
   pci :  pointer to command input buffer
   bUp :  if TRUE \- get older command; else get the newer
          command.                                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RecallUserInput ( PUSER_INPUT_BUFFER pci, int bUp );
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GetUserInputLine( PUSER_INPUT_BUFFER pOutput );
/* Add a buffer to the history buffer.
                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  EnqueUserInputHistory ( PUSER_INPUT_BUFFER pci, PTEXT pHistory );
/* Arbitrary PTEXT blocks are fed to the user input queue with
   this.
   Parameters
   pci :     pointer to command buffer
   stroke :  the stroke to add to the buffer (may be a whole
             String or linked list of segments). or NULL if
             getting existing input...
   Return Value List
   NULL :      There is no command available \- no text followed
               by a newline.
   not NULL :  A command line collected from the input text. There
               may be multiple commands in a single 'stroke'
               buffer.
   Example
   This may be used something like .... to add the storke to the
   \input buffer, and while there is a result, get the result
   from the buffer.
   <code lang="c++">
   {
       PUSER_INPUT_BUFFER pci = CreateUserInputBuffer();
       PTEXT result;
       for( result = GatherUserInput( pci, new_stroke ); result; result = GatherUserInput( pci, NULL ) )
       {
       }
   }
   </code>                                                                                               */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GatherUserInput ( PUSER_INPUT_BUFFER pci, PTEXT stroke );
/* delete 1 character at current user input index */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteUserInput( PUSER_INPUT_BUFFER pci );
/* Converts ascii character set to ebcidc. */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE  ConvertAsciiEbdic( TEXTSTR text, INDEX length );
/* Routine to convert from ebcdic character set to ascii. */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE  ConvertEbcdicAscii( TEXTSTR text, INDEX length );
/* Converts ascii 85 to ascii */
TYPELIB_PROC TEXTSTR FtnATA( TEXTSTR buf );
/* Converts ascii character set to ascii 85  */
TYPELIB_PROC TEXTSTR ATFtnA( TEXTSTR buf );
/* Expand characters which are outside of standard ascii to URI
   compatible escapes.
   Parameters
   text :        Text to convert
   length :      max length of text to convert
   skip_slash :  if TRUE, keep slash characters as literal,
                 otherwise they get converted.                  */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE ConvertTextURI( CTEXTSTR text, INDEX length, int skip_slash );
/* Converts URI escape characters like %3B to the appropriate
   ascii characters. The resulting string must be released by
   the application.
   Parameters
   text :    TEXTCHAR * string to convert.
   length :  max length of text to convert.
   Example
   <code lang="c++">
   TEXTCHAR *sample = WIDE( "https://www.google.com/#hl=en&amp;sugexp=eqn&amp;cp=11&amp;gs_id=1a&amp;xhr=t&amp;q=%3B+%5C+%2B+:+";
   TEXTCHAR *result;
   \result = ConvertURIText( sample, StrLen( sample ) );
   \result == https://www.google.com/#hl=en&amp;sugexp=eqn&amp;cp=11&amp;gs_id=1a&amp;xhr=t&amp;q=;+\\+++:+
   </code>                                                                                                                        */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE ConvertURIText( CTEXTSTR text, INDEX length );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE ParseStringVector( CTEXTSTR data, CTEXTSTR **pData, int *nData );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE ParseIntVector( CTEXTSTR data, int **pData, int *nData );
#ifdef __cplusplus
 //namespace text {
}
#endif
//--------------------------------------------------------------------------
#ifdef __cplusplus
	namespace BinaryTree {
#endif
/* This type defines a specific node in the tree. It is entirely
   private, and is a useless definition.                         */
typedef struct treenode_tag *PTREENODE;
/* Defines a Binary Tree.
   See Also
   <link CreateBinaryTree> */
typedef struct treeroot_tag *PTREEROOT;
/* This option may be passed to extended CreateBinaryTree
   methods to disallow adding of duplicates. Otherwise
   duplicates will be added; they will be added to the side of
   the node with the same value that has less children. Trees
   are created by default without this option, allowing the
   addition of duplicates.
   Example
   <code lang="c++">
   PTREEROOT = <link CreateBinaryTreeExtended>( BT_OPT_NODUPLICATES, NULL, NULL DBG_SRC );
   </code>                                                                                 */
#define BT_OPT_NODUPLICATES 1
/* Generic Compare is the type declaration for the callback routine for user custom comparisons.
  This routine should return -1 if new is less than old, it should return 1 if new is more than old, and it
  should return 0 if new and old are the same key. */
typedef int (CPROC *GenericCompare)( uintptr_t oldnode,uintptr_t newnode );
/* Signature for the user callback passed to CreateBinaryTreeEx
   that will be called for each node removed from the binary
   list.                                                        */
typedef void (CPROC *GenericDestroy)( CPOINTER user, uintptr_t key);
/* when adding a node if Compare is NULL the default method of a
   basic unsigned integer compare on the key value is done. if
   Compare is specified the specified key value of the orginal
   node (old) and of the new node (new) is added. Result of
   compare should be ( \<0 (lesser)) ( 0 (equal)) ( \>0
   (greater))
   Example
   <code lang="c++">
   int CPROC MyGenericCompare( uintptr_t oldnode,uintptr_t newnode )
   {
   </code>
   <code>
      if(oldnode\>newnode)
          return 1;
      else if(oldnode\<newnode)
          return -1;
      else return 0;
   </code>
   <code lang="c++">
      return (oldnode\>newnode)? 1
             \:(oldnode\<newnode)? -1
             \:0;
   }
   void CPROC MyGenericDestroy(POINTER user, uintptr_t key)
   {
      // do something custom with your user data and or key value
   }
   PTREEROOT tree = CreateBinaryTreeExtended( 0 // BT_OPT_NODUPLICATES
                                            , MyGenericCompare
                                            , MyGenericDestroy
                                            <link DBG_PASS, DBG_SRC> );
   </code>
   See Also
   <link CreateBinaryTreeExx>
   <link CreateBinaryTreeEx>
   <link CreateBinaryTree>                                               */
TYPELIB_PROC  PTREEROOT TYPELIB_CALLTYPE  CreateBinaryTreeExtended( uint32_t flags
															, GenericCompare Compare
															, GenericDestroy Destroy DBG_PASS);
/* This is the simpler case of <link CreateBinaryTreeExtended>,
   which does not make you pass DBG_SRC.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTreeExx( BT_OPT_NODUPLICATES, NULL, NULL );
   </code>                                                                  */
#define CreateBinaryTreeExx(flags,compare,destroy) CreateBinaryTreeExtended(flags,compare,destroy DBG_SRC)
/* Creates a binary tree, allowing specification of comparison
   and destruction routines.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTreeEx( <link CreateBinaryTreeExtended, MyGenericCompare>, <link CreateBinaryTreeExtended, MyGenericDestroy> );
   </code>                                                                                                                                      */
#define CreateBinaryTreeEx(compare,destroy) CreateBinaryTreeExx( 0, compare, destroy )
/* This is the simplest way to create a binary tree.
   The default compare routine treats 'key' as an integer value
   that is compared against other for lesser/greater condition.
   This tree also allows duplicates to be added.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   </code>                                                      */
#define CreateBinaryTree() CreateBinaryTreeEx( NULL, NULL )
/* \ \
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   DestroyBinaryTree( tree );
   tree = NULL;
   </code>                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DestroyBinaryTree( PTREEROOT root );
/* Drops all the nodes in a tree so it becomes empty...
   \ \
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   ResetBinaryTree( tree );
   tree = NULL;
   </code>                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  ResetBinaryTree( PTREEROOT root );
/* Balances a binary tree. If data is added to a binary list in
   a linear way (from least to most), the tree can become
   unbalanced, and all be on the left or right side of data. This
   routine can analyze branches and perform rotations so that
   the tree can be discretely rebalanced.
   Example
   <code lang="c++">
   <link PTREEROOT> tree;
   // <link AddBinaryNode>...
   BalanceBinaryTree( tree );
   </code>                                                        */
TYPELIB_PROC  void TYPELIB_CALLTYPE  BalanceBinaryTree( PTREEROOT root );
/* \ \
   See Also
   <link AddBinaryNode>
   <link DBG_PASS>
                        */
TYPELIB_PROC  int TYPELIB_CALLTYPE  AddBinaryNodeEx( PTREEROOT root
                                                   , CPOINTER userdata
                                                   , uintptr_t key DBG_PASS );
/* Adds a user pointer identified by key to a binary list.
   See Also
   <link BinaryTree::CreateBinaryTree, CreateBinaryTree>
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   uintptr_t key = 1;
   POINTER data = NewArray( TEXTCHAR, 32 );
   AddBinaryNode( tree, data, key );
   </code>
   Parameters
   root :  PTREEROOT binary tree instance.
   data :  POINTER to some user object.
   key :   uintptr_t a integer type which can be used to identify
           the data. (used to compare in the tree).<p /><p />If
           the user has specified a custom comparison routine in
           an extended CreateBinaryTree(), then this value might
           be a pointer to some other data. Often the thing used
           to key into a binary tree is a <link CTEXTSTR>.
   Returns
   The tree may be created with <link BT_OPT_NODUPLICATES>, in
   which case this will result FALSE if the key is found
   duplicated in the list. Otherwise this returns TRUE. if the
   root parameter is NULL, the result is FALSE.                  */
#define AddBinaryNode(r,u,k) AddBinaryNodeEx((r),(u),(k) DBG_SRC )
//TYPELIB_PROC  int TYPELIB_CALLTYPE  AddBinaryNode( PTREEROOT root
//                                    , POINTER userdata
//                                    , uintptr_t key );
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveBinaryNode( PTREEROOT root, POINTER use, uintptr_t key );
/* Search in a binary tree for the specified key.
   Returns
   user data POINTER if found, else NULL.
   Example
   <code lang="c++">
   PTREEROOT tree;
   void f( void )
   {
      CPOINTER mydata = FindInBinaryTree( tree, 5 );
      if( mydata )
      {
          // found '5' as the key in the tree
      }
   }
   </code>                                          */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  FindInBinaryTree( PTREEROOT root, uintptr_t key );
// result of fuzzy routine is 0 = match.  100 = inexact match
// 1 = no match, actual may be larger
// -1 = no match, actual may be lesser
// 100 = inexact match- checks nodes near for better match.
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  LocateInBinaryTree( PTREEROOT root, uintptr_t key
														, int (CPROC*fuzzy)( uintptr_t psv, uintptr_t node_key ) );
/* During FindInBinaryTree and LocateInBinaryTree, the last
   found result is stored. This function allows deletion of that
   node.
   Example
   <code lang="c++">
   FindInBinaryTree( tree, 5 );
   RemoveLastFoundNode( tree );
   </code>                                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveLastFoundNode(PTREEROOT root );
/* Removes the currently browsed node from the tree.
   See Also
   <link GetChildNode>                               */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveCurrentNode(PTREEROOT root );
/* Basically this is meant to dump to a log, if the print
   function is passed as NULL, then the tree's contents are
   dumped to the log. It dumps a very cryptic log of how all
   nodes in the tree are arranged. But by allowing the user to
   provide a method to log his data and key, the logging is more
   meaningful based on the application. The basic code for
   managing trees and nodes works....
   Example
   <code>
   int ForEachNode( POINTER user, uintptr_t key )
   {
       // return not 1 to dump to log the internal tree structure
       return 0; // probably did own logging here, so don't log tree internal
   }
   <link PTREEROOT> tree;
   void f( void )
   {
       DumpTree( tree, ForEachNode );
   }
   </code>                                                                    */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DumpTree( PTREEROOT root
                          , int (*Dump)( CPOINTER user, uintptr_t key ) );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLeastNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLeastNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreatestNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreatestNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLesserNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLesserNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreaterNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreaterNode( PTREEROOT root );
/* \Returns the node that is set as 'current' in the tree. There
   is a cursor within the tree that can be used for browsing.
   See Also
   <link GetChildNode>                                           */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetCurrentNodeEx( PTREEROOT root, POINTER *cursor );
/* \Returns the node that is set as 'current' in the tree. There
   is a cursor within the tree that can be used for browsing.
   See Also
   <link GetChildNode>                                           */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetCurrentNode( PTREEROOT root );
/* This sets the current node cursor to the root of the node.
   See Also
   <link GetChildNode>                                        */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetRootNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetParentNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetParentNode( PTREEROOT root );
/* While browsing the tree after a find operation move to the
   next child node, direction 0 is lesser direction !0 is
   greater.
   Binary Trees have a 'current' cursor. These operations may be
   used to browse the tree.
   Example
   \ \
   <code>
   // this assumes you have a tree, and it's fairly populated, then this demonstrates
   // all steps of browsing.
   POINTER my_data;
   // go to the 'leftmost' least node. (as determined by the compare callback)
   my_data = GetLeastNode( tree );
   // go to the 'rightmost' greatest node. (as determined by the compare callback)
   my_data = GetGreatestNode( tree );
   // move to the node that is less than the current node.  (move to the 'left')
   my_data = GetLesserNode( tree );
   // move to the node that is greater than the current node.  (move to the 'right')
   my_data = GetGreaterNode( tree );
   // follow the tree to the left down from here
   my_data = GetChildNode( tree, 0 );
   // follow the tree to the right down from here
   my_data = GetChildNode( tree, 1 );
   // follow the tree up to the node above the current one.
   //  (the one who's lesser or greater points at this)
   my_data = GetParentNode( tree );
   // this is probably the least useful, but someone clever might find a trick for it
   // Move back to the node we were just at.
   //  (makes the current the prior, and moves to what the prior was,
   //     but then it's just back and forth between the last two; it's not a stack ).
   my_data = GetPriorNode( tree );
   </code>
   A more practical example...
   <code lang="c++">
   POINTER my_data;
   for( my_data = GetLeastNode( tree );
        my_data;
        my_data = GetGreaterNode( tree ) )
   {
        // browse the tree from least to most.
   }
   </code>                                                                            */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetChildNode( PTREEROOT root, int direction );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetChildNodeEx( PTREEROOT root, POINTER *cursor, int direction );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetPriorNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetPriorNode( PTREEROOT root );
/* \Returns the total number of nodes in the tree.
   Example
   <code lang="c++">
   int total_nodes = GetNodeCount(tree);
   </code>                                         */
TYPELIB_PROC  int TYPELIB_CALLTYPE  GetNodeCount ( PTREEROOT root );
 // returns a shadow of the original.
TYPELIB_PROC  PTREEROOT TYPELIB_CALLTYPE  ShadowBinaryTree( PTREEROOT root );
#ifdef __cplusplus
 //namespace BinaryTree {
	}
#endif
//--------------------------------------------------------------------------
#ifdef __cplusplus
namespace family {
#endif
/* A family tree structure, for tracking elements that have
   multiple children.
                                                            */
typedef struct familyroot_tag *PFAMILYTREE;
typedef struct familynode_tag *PFAMILYNODE;
/* <unfinished>
   Incomplete Work in progress (maybe) */
TYPELIB_PROC  PFAMILYTREE TYPELIB_CALLTYPE  CreateFamilyTree ( int (CPROC *Compare)(uintptr_t key1, uintptr_t key2)
															, void (CPROC *Destroy)(POINTER user, uintptr_t key) );
/* <unfinished>
   Incomplete, Family tree was never completed. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE  FamilyTreeFindChild ( PFAMILYTREE root
														  , uintptr_t psvKey );
/* <unfinished>
   Incomplete, Family tree was never completed. */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE FamilyTreeFindChildEx ( PFAMILYTREE root, PFAMILYNODE root_node
													 , uintptr_t psvKey );
/* Resets the search cursors in the tree... */
TYPELIB_PROC  void TYPELIB_CALLTYPE  FamilyTreeReset ( PFAMILYTREE *option_tree );
/* Resets the content of the tree (should call destroy methods, at this time it does not) */
TYPELIB_PROC  void TYPELIB_CALLTYPE  FamilyTreeClear ( PFAMILYTREE option_tree );
/* <unfinished>
   Incomplete Work in progress (maybe) */
TYPELIB_PROC  PFAMILYNODE TYPELIB_CALLTYPE  FamilyTreeAddChild ( PFAMILYTREE *root, PFAMILYNODE parent, POINTER userdata, uintptr_t key );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE FamilyTreeForEachChild( PFAMILYTREE root, PFAMILYNODE node
			, LOGICAL (CPROC *ProcessNode)( uintptr_t psvForeach, uintptr_t psvNodeData )
			, uintptr_t psvUserData );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE FamilyTreeForEach( PFAMILYTREE root, PFAMILYNODE node
			, LOGICAL (CPROC *ProcessNode)( uintptr_t psvForeach, uintptr_t psvNodeData, int level )
			, uintptr_t psvUserData );
#ifdef __cplusplus
 //namespace family {
}
#endif
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
#ifdef __cplusplus
//} // extern "c"
 // namespace containers
}
 // namespace sack
}
using namespace sack::containers::link_stack;
using namespace sack::containers::data_stack;
using namespace sack::containers::data_list;
using namespace sack::containers::data_queue;
using namespace sack::containers::queue;
using namespace sack::containers::BinaryTree;
using namespace sack::containers::text;
using namespace sack::containers::message;
using namespace sack::containers::sets;
using namespace sack::containers::family;
using namespace sack::containers;
#else
// should 'class'ify these things....
#endif
#ifndef _TYPELIBRARY_SOURCE
//#undef TYPELIB_PROC // we don't need this symbol after having built the right prototypes
#endif
#endif
// $Log: sack_typelib.h,v $
// Revision 1.99  2005/07/10 23:56:25  d3x0r
// Fix types for C++...
//
//
// Revision 1.39  2003/03/25 08:38:11  panther
// Add logging
//
SACK_NAMESPACE
#ifndef IS_DEADSTART
// this is always statically linked with libraries, so they may contact their
// core executable to know when it's done loading everyone else also...
#  ifdef __cplusplus
extern "C"
#  endif
#  if defined( WIN32 ) && !defined( __STATIC__ ) && !defined( __ANDROID__ )
#    ifdef __NO_WIN32API__
// DllImportAttribute ?
#    else
__declspec(dllimport)
#    endif
#  else
#ifndef __cplusplus
extern
#endif
#  endif
/* a function true/false which indicates whether the root
   deadstart has been invoked already. If not, one should call
   InvokeDeadstart and MarkDeadstartComplete.
   <code lang="c++">
   int main( )
   {
       if( !is_deadstart_complete() )
       {
           InvokeDeadstart();
           MarkDeadstartComplete()
       }
       ... your code here ....
       return 0;  // or some other appropriate return.
   }
   </code>
   sack::app::deadstart                                        */
LOGICAL
#  if defined( __WATCOMC__ )
__cdecl
#  endif
is_deadstart_complete( void );
#endif
/* Define a routine to call for exit().  This triggers specific code to handle shutdown event registration */
#ifndef NO_EXPORTS
#  ifdef SACK_BAG_CORE_EXPORTS
EXPORT_METHOD
#  else
IMPORT_METHOD
#  endif
#else
#  ifndef SACK_BAG_CORE_EXPORTS
	extern
#  endif
#endif
		void CPROC BAG_Exit( int code );
#ifndef NO_SACK_EXIT_OVERRIDE
#define exit(n) BAG_Exit(n)
#endif
 // namespace sack {
SACK_NAMESPACE_END
// this should become common to all libraries and programs...
//#include <construct.h> // pronounced 'kahn-struct'
/*
 *  Crafted by James Buckeyne
 *  Part of SACK github.com/d3x0r/SACK
 *
 *   (c) Freedom Collective 2000-2006++, 2016++
 *
 *   created to provide standard logging features
 *   lprintf( format, ... ); simple, basic
 *   if DEBUG, then logs to a file of the same name as the program
 *   if RELEASE most of this logging goes away at compile time.
 *
 *  standardized to never use int.
 */
#ifndef LOGGING_MACROS_DEFINED
#define LOGGING_MACROS_DEFINED
#define SYSLOG_API CPROC
#ifdef SYSLOG_SOURCE
#define SYSLOG_PROC EXPORT_METHOD
#else
#define SYSLOG_PROC IMPORT_METHOD
#endif
#ifdef __cplusplus
#define LOGGING_NAMESPACE namespace sack { namespace logging {
#define LOGGING_NAMESPACE_END } }
#else
#define LOGGING_NAMESPACE
#define LOGGING_NAMESPACE_END
#endif
#ifdef __cplusplus
	namespace sack {
/* Handles log output. Logs can be directed to UDP directed, or
   broadcast, or localhost, or to a file location, and under
   windows the debugging console log.
   lprintf
   SetSystemLog
   SystemLogTime
   there are options, when options code is enabled, which
   control logging output and format. Log file location can be
   specified generically for instance.... see Options.
	This namespace contains the logging functions. The most basic
   thing you can do to start logging is use 'lprintf'.
   <code lang="c++">
   lprintf( "My printf like format %s %d times", "string", 15 );
   </code>
   This function takes a format string and arguments compatible
   with vsnprintf. Internally strings are truncated to 4k
   length. (that is no single logging message can be more than
   4k in length).
   There are functions to control logging behavior.
   See Also
   SetSystemLog
   SystemLogTime
   SystemLogOptions
   lprintf
   _lprintf
   xlprintf
   _xlprintf
                                                                 */
		namespace logging {
#endif
/* \Parameters for SetSystemLog() to specify where the logging
   should go.                                                  */
enum syslog_types {
 // disable any log output.
SYSLOG_NONE     =   -1
,
SYSLOG_UDP      =    0
,
SYSLOG_FILE     =    1
,
 /* Set logging to output to a file. The file passed is a FILE*. This
   may be a FILE* like stdout, stderr, or some file the
   application opens.                                                */
SYSLOG_FILENAME =    2
,
 /* Set logging to go to a file, pass the string text name of the
   \file to open as the second parameter of SetSystemLog.        */
SYSLOG_SYSTEM   =    3
,
 /* Specify that logging should go to system (this actually means
   Windows system debugging channel. OutputDebugString() ).      */
SYSLOG_UDPBROADCAST= 4
// Allow user to specify a void UserCallback( char * )
// which recieves the formatted output.
,
SYSLOG_CALLBACK    = 5
,
 /* Send Logging to a specified user callback to handle. This
   lets logging go anywhere else that's not already thought of. */
SYSLOG_AUTO_FILE = SYSLOG_FILE + 100
 /* Send logging to a file. If the file is not open, open the
   \file. If no logging happens, no log file is created.     */
,
SYSLOG_SOCKET_SYSLOGD
};
#if !defined( NO_LOGGING )
#define DO_LOGGING
#endif
// this was forced, force no_logging off...
#if defined( DO_LOGGING )
#undef NO_LOGGING
#endif
#ifdef __LINUX__
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
SYSLOG_PROC  LOGICAL SYSLOG_API  IsBadReadPtr ( CPOINTER pointer, uintptr_t len );
#endif
SYSLOG_PROC  CTEXTSTR SYSLOG_API  GetPackedTime ( void );
//  returns the millisecond of the day (since UNIX Epoch) * 256 ( << 8 )
// the lowest 8 bits are the timezone / 15.
// The effect of the low [7/]8 bits being the time zone is that within the same millisecond
// UTC +0 sorts first, followed by +1, +2, ... etc until -14, -13, -12,... -1
// the low [7/]8 bits are the signed timezone
// (timezone could have been either be hr*60 + min (ISO TZ format)
// or in minutes (hr*60+mn) this would only take 7 bits
// one would think 8 bit shifts would be slightly more efficient than 7 bits.
// and sign extension for 8 bits already exists.
// - REVISION - timezone with hr*100 does not divide by 15 cleanly.
//     The timezone is ( hour*60 + min ) / 15 which is a range from -56 to 48
//     minimal representation is 7 bits (0 - 127 or -64 - 63)
//     still keeping 8 bits for shifting, so the effective range is only -56 to 48 of -128 to 127
// struct time_of_day {
//    uint64_t epoch_milliseconds : 56;
//    int64_t timezone : 8; divided by 15... hours * 60 / 15
// }
SYSLOG_PROC  int64_t SYSLOG_API GetTimeOfDay( void );
// binary little endian order; somewhat
typedef struct sack_expanded_time_tag
{
	uint16_t ms;
	uint8_t sc,mn,hr,dy,mo;
	uint16_t yr;
	int8_t zhr, zmn;
} SACK_TIME;
typedef struct sack_expanded_time_tag *PSACK_TIME;
// convert a integer time value to an expanded structure.
SYSLOG_PROC void     SYSLOG_API ConvertTickToTime( int64_t, PSACK_TIME st );
// convert a expanded time structure to a integer value.
SYSLOG_PROC int64_t SYSLOG_API ConvertTimeToTick( PSACK_TIME st );
// returns timezone as hours*100 + minutes.
// result is often negated?
SYSLOG_PROC  int SYSLOG_API GetTimeZone(void);
//
typedef void (CPROC*UserLoggingCallback)( CTEXTSTR log_string );
SYSLOG_PROC  void SYSLOG_API  SetSystemLog ( enum syslog_types type, const void *data );
SYSLOG_PROC  void SYSLOG_API  ProtectLoggedFilenames ( LOGICAL bEnable );
SYSLOG_PROC  void SYSLOG_API  SystemLogFL ( CTEXTSTR FILELINE_PASS );
SYSLOG_PROC  void SYSLOG_API  SystemLogEx ( CTEXTSTR DBG_PASS );
SYSLOG_PROC  void SYSLOG_API  SystemLog ( CTEXTSTR );
SYSLOG_PROC  void SYSLOG_API  LogBinaryFL ( const uint8_t* buffer, size_t size FILELINE_PASS );
SYSLOG_PROC  void SYSLOG_API  LogBinaryEx ( const uint8_t* buffer, size_t size DBG_PASS );
SYSLOG_PROC  void SYSLOG_API  LogBinary ( const uint8_t* buffer, size_t size );
// logging level defaults to 1000 which is log everything
SYSLOG_PROC  void SYSLOG_API  SetSystemLoggingLevel ( uint32_t nLevel );
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
/* Log a binary buffer. Logs lines representing 16 bytes of data
   at a time. The hex of each byte in a buffer followed by the
   text is logged.
   Example
   <code lang="c#">
   char sample[] = "sample string";
   LogBinary( sample, sizeof( sample ) );
   </code>
   Results with the following output in the log...
   <code>
    73 61 6D 70 6C 65 20 73 74 72 69 6E 67 00 sample string.
   </code>
   The '.' at the end of 'sample string' is a non printable
   character. characters 0-31 and 127+ are printed as '.'.       */
#define LogBinary(buf,sz) LogBinaryFL((uint8_t*)(buf),sz DBG_SRC )
#define SystemLog(buf)    SystemLogFL(buf DBG_SRC )
#else
// need to include the typecast... binary logging doesn't really care what sort of pointer it gets.
#define LogBinary(buf,sz) LogBinary((uint8_t*)(buf),sz )
//#define LogBinaryEx(buf,sz,...) LogBinaryFL(buf,sz FILELINE_NULL)
//#define SystemLogEx(buf,...) SystemLogFL(buf FILELINE_NULL )
#endif
// int result is useless... but allows this to be
// within expressions, which with this method should be easy.
typedef INDEX (CPROC*RealVLogFunction)(CTEXTSTR format, va_list args )
//#if defined( __GNUC__ )
//	__attribute__ ((__format__ (__vprintf__, 1, 2)))
//#endif
	;
typedef INDEX (CPROC*RealLogFunction)(CTEXTSTR format,...)
#if defined( __GNUC__ )
	__attribute__ ((__format__ (__printf__, 1, 2)))
#endif
	;
SYSLOG_PROC  RealVLogFunction SYSLOG_API  _vxlprintf ( uint32_t level DBG_PASS );
SYSLOG_PROC  RealLogFunction SYSLOG_API  _xlprintf ( uint32_t level DBG_PASS );
// utility function to format a cpu delta into a buffer...
// end-start is always printed... therefore tick_end-0 is
// print absolute time... formats as millisecond.NNN
SYSLOG_PROC  void SYSLOG_API  PrintCPUDelta ( TEXTCHAR *buffer, size_t buflen, uint64_t tick_start, uint64_t tick_end );
// return the current CPU tick
SYSLOG_PROC  uint64_t SYSLOG_API  GetCPUTick ( void );
// result in nano seconds - thousanths of a millisecond...
SYSLOG_PROC  uint32_t SYSLOG_API  ConvertTickToMicrosecond ( uint64_t tick );
SYSLOG_PROC  uint64_t SYSLOG_API  GetCPUFrequency ( void );
SYSLOG_PROC  CTEXTSTR SYSLOG_API  GetTimeEx ( int bUseDay );
SYSLOG_PROC  void SYSLOG_API  SetSyslogOptions ( FLAGSETTYPE *options );
/* When setting options using SetSyslogOptions() these are the
   defines for the bits passed.
   SYSLOG_OPT_OPENAPPEND - the file, when opened, will be opened
   for append.
   SYSLOG_OPT_OPEN_BACKUP - the file, if it exists, will be
   renamed automatically.
   SYSLOG_OPT_LOG_PROGRAM_NAME - enable logging the program
   executable (probably the same for all messages, unless they
   are network)
   SYSLOG_OPT_LOG_THREAD_ID - enables logging the unique process
   and thread ID.
   SYSLOG_OPT_LOG_SOURCE_FILE - enable logging source file
   information. See <link DBG_PASS>
   SYSLOG_OPT_MAX - used for declaring a flagset to pass to
   setoptions.                                                   */
enum system_logging_option_list {
		/* the file, when opened, will be opened for append.
		 */
		SYSLOG_OPT_OPENAPPEND
										  ,
  /* the file, if it exists, will be renamed automatically.
										  */
										  SYSLOG_OPT_OPEN_BACKUP
                                ,
 /* enable logging the program executable (probably the same for
                                   all messages, unless they are network)
                                                                                                */
                                 SYSLOG_OPT_LOG_PROGRAM_NAME
										  ,
 /* enables logging the unique process and thread ID.
										                                                       */
                                 SYSLOG_OPT_LOG_THREAD_ID
                                ,
 /* enable logging source file information. See <link DBG_PASS>
                                                                                               */
										   SYSLOG_OPT_LOG_SOURCE_FILE
										  ,
										  SYSLOG_OPT_MAX
};
// this solution was developed to provide the same
// functionality for compilers that refuse to implement __VA_ARGS__
// this therefore means that the leader of the function is replace
// and that extra parenthesis exist after this... therefore the remaining
// expression must be ignored... thereofre when defining a NULL function
// this will result in other warnings, about ignored, or meaningless expressions
# if defined( DO_LOGGING )
#  define vlprintf      _vxlprintf(LOG_NOISE DBG_SRC)
#  define lprintf       _xlprintf(LOG_NOISE DBG_SRC)
#  define _lprintf(file_line,...)       _xlprintf(LOG_NOISE file_line,##__VA_ARGS__)
#  define xlprintf(level)       _xlprintf(level DBG_SRC)
#  define vxlprintf(level)       _vxlprintf(level DBG_SRC)
# else
#  ifdef _MSC_VER
#   define vlprintf      (1)?(0):
#   define lprintf       (1)?(0):
#   define _lprintf(DBG_VOIDRELAY)       (1)?(0):
#   define xlprintf(level)       (1)?(0):
#   define vxlprintf(level)      (1)?(0):
#  else
#   define vlprintf(f,...)
/* use printf formating to output to the log. (log printf).
   Parameters
   Format :  Just like printf, the format string to print.
   ... :     extra arguments passed as required for the format.
   Example
   <code lang="c++">
      lprintf( "Test Logging %d %d", 13, __LINE__ );
   </code>                                                      */
#   define lprintf(f,...)
#   define  _lprintf(DBG_VOIDRELAY)       lprintf
#   define xlprintf(level) lprintf
#   define vxlprintf(level) lprintf
#  endif
# endif
#undef LOG_WARNING
#undef LOG_ADVISORIES
#undef LOG_INFO
// Defined Logging Levels
enum {
	  // and you are free to use any numerical value,
	  // this is a rough guideline for wide range
	  // to provide a good scaling for levels of logging
 // unless logging is disabled, this will be logged
	LOG_ALWAYS = 1
 // logging level set to 50 or more will cause this to log
	, LOG_ERRORS = 50
	,
 /* Specify a logging level which only ERROR level logging is
	   logged.                                                   */
 // logging level set to 50 or more will cause this to log
	 LOG_ERROR = LOG_ERRORS
	,
 // .......
	 LOG_WARNINGS = 500
	,
 // .......
	 LOG_WARNING = LOG_WARNINGS
   ,
 /* Use to specify that the log message is a warning level
      message.                                               */
    LOG_ADVISORY = 625
   ,
    LOG_ADVISORIES = LOG_ADVISORY
	,
 /* A symbol to specify to log Adviseries, Warnings and Error
	   level messages only.                                      */
	 LOG_INFO = 750
	  ,
 /* A moderate logging level, which is near maximum verbosity of
	     logging.                                                     */
	   LOG_NOISE = 1000
     ,
 /* Define that the message is just noisy - though verbosly
	  informative, it's level is less critical than even INFO.
	  default iS LOG_NOISE which is 1000, an ddefault for disabling most messages
	  is to set log level to 999.  Have to increase to 2000 to see debug, and this name
     has beviously
	  */
      LOG_LEVEL_DEBUG = 2000
	,
 /* Specify the message is of DEBUG importance, which is far
	   above even NOISY. If debug logging is enabled, all logging,
	   ERROR, WARNING, ADVISORY, INFO, NOISY and DEBUG will be
	   logged.                                                     */
 // not quite a negative number, but really big
	 LOG_CUSTOM = 0x40000000
	,
 /* A bit with LOG_CUSTOM might be enabled, and the lower bits
	   under 0x40000000 (all bits 0x3FFFFFFF ) can be used to
	   indicate a logging type. Then SetLoggingLevel can be passed a
	   mask of bits to filter types of messages.                     */
 // not quite a negative number, but really big
	 LOG_CUSTOM_DISABLE = 0x20000000
	// bits may be user specified or'ed with this value
	// such that ...
	// Example 1:SetSystemLoggingLevel( LOG_CUSTOM | 1 ) will
	// enable custom logging messages which have the '1' bit on... a logical
	// and is used to test the low bits of this value.
	// example 2:SetSystemLogging( LOG_CUSTOM_DISABLE | 1 ) will disable logging
	// of messages with the 1 bit set.
  // mask of bits which may be used to enable and disable custom logging
#define LOG_CUSTOM_BITS 0xFFFFFF
};
 // this is a flag set consisting of 0 or more or'ed symbols
enum SyslogTimeSpecifications {
 // disable time logging
 SYSLOG_TIME_DISABLE = 0,
 // enable is anything not zero.
 SYSLOG_TIME_ENABLE  = 1,
 // specify to log milliseconds
 SYSLOG_TIME_HIGH    = 2,
 // log the year/month/day also
 SYSLOG_TIME_LOG_DAY = 4,
 // log the difference in time instead of the absolute time
 SYSLOG_TIME_DELTA   = 8,
 // logs cpu ticks... implied delta
 SYSLOG_TIME_CPU     =16
};
/* Specify how time is logged. */
SYSLOG_PROC void SYSLOG_API SystemLogTime( uint32_t enable );
#ifndef NO_LOGGING
#define OutputLogString(s) SystemLog(s)
/* Depricated. Logs a format string that takes 0 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log(s)                                   SystemLog( s )
#else
#define OutputLogString(s)
/* Depricated. Logs a format string that takes 0 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log(s)
#endif
/* Depricated. Logs a format string that takes 1 parameter.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log1(s,p1)                               lprintf( s, p1 )
/* Depricated. Logs a format string that takes 2 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log2(s,p1,p2)                            lprintf( s, p1, p2 )
/* Depricated. Logs a format string that takes 3 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log3(s,p1,p2,p3)                         lprintf( s, p1, p2, p3 )
/* Depricated. Logs a format string that takes 4 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log4(s,p1,p2,p3,p4)                      lprintf( s, p1, p2, p3,p4)
/* Depricated. Logs a format string that takes 5 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log5(s,p1,p2,p3,p4,p5)                   lprintf( s, p1, p2, p3,p4,p5)
/* Depricated. Logs a format string that takes 6 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log6(s,p1,p2,p3,p4,p5,p6)                lprintf( s, p1, p2, p3,p4,p5,p6)
/* Depricated. Logs a format string that takes 7 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log7(s,p1,p2,p3,p4,p5,p6,p7)             lprintf( s, p1, p2, p3,p4,p5,p6,p7 )
/* Depricated. Logs a format string that takes 8 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log8(s,p1,p2,p3,p4,p5,p6,p7,p8)          lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8 )
/* Depricated. Logs a format string that takes 9 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log9(s,p1,p2,p3,p4,p5,p6,p7,p8,p9)       lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8,p9 )
/* Depricated. Logs a format string that takes 10 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log10(s,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10)  lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8,p9,p10 )
LOGGING_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::logging;
#endif
#endif
#if defined( _MSC_VER ) || (1)
// huh, apparently all compiles are messed the hell up.
#  define COMPILER_THROWS_SIGNED_UNSIGNED_MISMATCH
#endif
#ifdef COMPILER_THROWS_SIGNED_UNSIGNED_MISMATCH
#  define SUS_GT(a,at,b,bt)   (((a)<0)?0:(((bt)a)>(b)))
#  define USS_GT(a,at,b,bt)   (((b)<0)?1:((a)>((at)b)))
#  define SUS_LT(a,at,b,bt)   (((a)<0)?1:(((bt)a)<(b)))
#  define USS_LT(a,at,b,bt)   (((b)<0)?0:((a)<((at)b)))
#  define SUS_GTE(a,at,b,bt)  (((a)<0)?0:(((bt)a)>=(b)))
#  define USS_GTE(a,at,b,bt)  (((b)<0)?1:((a)>=((at)b)))
#  define SUS_LTE(a,at,b,bt)  (((a)<0)?1:(((bt)a)<=(b)))
#  define USS_LTE(a,at,b,bt)  (((b)<0)?0:((a)<=((at)b)))
#else
#  define SUS_GT(a,at,b,bt)   ((a)>(b))
#  define USS_GT(a,at,b,bt)   ((a)>(b))
#  define SUS_LT(a,at,b,bt)   ((a)<(b))
#  define USS_LT(a,at,b,bt)   ((a)<(b))
#  define SUS_GTE(a,at,b,bt)  ((a)>=(b))
#  define USS_GTE(a,at,b,bt)  ((a)>=(b))
#  define SUS_LTE(a,at,b,bt)  ((a)<=(b))
#  define USS_LTE(a,at,b,bt)  ((a)<=(b))
#endif
#ifdef __cplusplus
using namespace sack;
using namespace sack::containers;
#endif
#endif
#endif
// incldue this first so we avoid a conflict.
// hopefully this comes from sack system?
/*
 *  Created by Jim Buckeyne
 *
 *  Purpose
 *    Generalization of system routines which began in
 *   dekware development.
 *   - Process control (load,start,stop)
 *   - Library runtime link control (load, unload)
 *
 */
#ifndef SYSTEM_LIBRARY_DEFINED
#define SYSTEM_LIBRARY_DEFINED
#ifdef SYSTEM_SOURCE
#define SYSTEM_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SYSTEM_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __LINUX__
// Hmm I thought that dlopen resulted in an int...
// but this doc says void * (redhat9)
//typedef void *HLIBRARY;
#else
//typedef HMODULE HLIBRARY;
#endif
#ifdef __cplusplus
#define _SYSTEM_NAMESPACE namespace system {
#define _SYSTEM_NAMESPACE_END }
#else
#define _SYSTEM_NAMESPACE
#define _SYSTEM_NAMESPACE_END
#endif
#define SACK_SYSTEM_NAMESPACE SACK_NAMESPACE _SYSTEM_NAMESPACE
#define SACK_SYSTEM_NAMESPACE_END _SYSTEM_NAMESPACE_END SACK_NAMESPACE_END
#ifndef UNDER_CE
#define HAVE_ENVIRONMENT
#endif
SACK_NAMESPACE
	_SYSTEM_NAMESPACE
typedef struct task_info_tag *PTASK_INFO;
typedef void (CPROC*TaskEnd)(uintptr_t, PTASK_INFO task_ended);
typedef void (CPROC*TaskOutput)(uintptr_t, PTASK_INFO task, CTEXTSTR buffer, size_t size );
// Run a program completely detached from the current process
// it runs independantly.  Program does not suspend until it completes.
// Use GetTaskExitCode() to get the return code of the process
#define LPP_OPTION_DO_NOT_HIDE           1
// for services to launch normal processes (never got it to work; used to work in XP/NT?)
#define LPP_OPTION_IMPERSONATE_EXPLORER  2
#define LPP_OPTION_FIRST_ARG_IS_ARG      4
#define LPP_OPTION_NEW_GROUP             8
#define LPP_OPTION_NEW_CONSOLE          16
#define LPP_OPTION_SUSPEND              32
#define LPP_OPTION_ELEVATE              64
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgramExx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
                                               , int flags
                                               , TaskOutput OutputHandler
                                               , TaskEnd EndNotice
                                               , uintptr_t psv
                                                DBG_PASS
                                               );
SYSTEM_PROC( PTASK_INFO, LaunchProgramEx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args, TaskEnd EndNotice, uintptr_t psv );
// launch a process, program name (including leading path), a optional path to start in (defaults to
// current process' current working directory.  And a array of character pointers to args
// args should be the NULL.
SYSTEM_PROC( PTASK_INFO, LaunchProgram )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR  args );
// abort task, no kill signal, sigabort basically.  Use StopProgram for a more graceful terminate.
// if (!StopProgram(task)) TerminateProgram(task) would be appropriate.
SYSTEM_PROC( uintptr_t, TerminateProgram )( PTASK_INFO task );
SYSTEM_PROC( void, ResumeProgram )( PTASK_INFO task );
// get first address of program startup code(?) Maybe first byte of program code?
SYSTEM_PROC( uintptr_t, GetProgramAddress )( PTASK_INFO task );
// before luanchProgramEx, there was no userdata...
SYSTEM_PROC( void, SetProgramUserData )( PTASK_INFO task, uintptr_t psv );
// attempt to implement a method on windows that allows a service to launch a user process
// current systems don't have such methods
SYSTEM_PROC( void, ImpersonateInteractiveUser )( void );
// after launching a process should revert to a protected state.
SYSTEM_PROC( void, EndImpersonation )( void );
// generate a Ctrl-C to the task.
// maybe also signal systray icon
// maybe also signal process.lock region
// maybe end process?
// maybe then terminate process?
SYSTEM_PROC( LOGICAL, StopProgram )( PTASK_INFO task );
// ctextstr as its own type is a pointer so a
//  PcTextStr is a pointer to strings -
//   char ** - returns a quoted string if args have spaces (and escape quotes in args?)
SYSTEM_PROC( TEXTSTR, GetArgsString )( PCTEXTSTR pArgs );
// after a task has exited, this can return its code.
// undefined if task has not exited (probably 0)
SYSTEM_PROC( uint32_t, GetTaskExitCode )( PTASK_INFO task );
// returns the name of the executable that is this process (without last . extension   .exe for instance)
SYSTEM_PROC( CTEXTSTR, GetProgramName )( void );
// returns the path of the executable that is this process
SYSTEM_PROC( CTEXTSTR, GetProgramPath )( void );
// returns the path that was the working directory when the program started
SYSTEM_PROC( CTEXTSTR, GetStartupPath )( void );
// returns the path of the current sack library.
SYSTEM_PROC( CTEXTSTR, GetLibraryPath )( void );
// on windows, queries an event that indicates the system is rebooting.
SYSTEM_PROC( LOGICAL, IsSystemShuttingDown )( void );
// HandlePeerOutput is called whenever a peer task has generated output on stdout or stderr
//   - someday evolution may require processing stdout and stderr with different event handlers
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgramEx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
                                              , TaskOutput HandlePeerOutput
                                              , TaskEnd EndNotice
                                              , uintptr_t psv
                                               DBG_PASS
                                              );
#define LaunchPeerProgram(prog,path,args,out,end,psv) LaunchPeerProgramEx(prog,path,args,out,end,psv DBG_SRC)
SYSTEM_PROC( PTASK_INFO, SystemEx )( CTEXTSTR command_line
                                   , TaskOutput OutputHandler
                                   , uintptr_t psv
                                   DBG_PASS
                                   );
#define System(command_line,output_handler,user_data) SystemEx( command_line, output_handler, user_data DBG_SRC )
// generate output to a task... read by peer task on standard input pipe
// if a task has been opened with an output handler, than IO is trapped, and this is a method of
// sending output to a task.
SYSTEM_PROC( int, pprintf )( PTASK_INFO task, CTEXTSTR format, ... );
// if a task has been opened with an otuput handler, than IO is trapped, and this is a method of
// sending output to a task.
SYSTEM_PROC( int, vpprintf )( PTASK_INFO task, CTEXTSTR format, va_list args );
typedef void (CPROC*generic_function)(void);
SYSTEM_PROC( generic_function, LoadFunctionExx )( CTEXTSTR library, CTEXTSTR function, LOGICAL bPrivate DBG_PASS);
SYSTEM_PROC( generic_function, LoadFunctionEx )( CTEXTSTR library, CTEXTSTR function DBG_PASS);
SYSTEM_PROC( void *, GetPrivateModuleHandle )( CTEXTSTR libname );
/*
  Add a custom loaded library; attach a name to the DLL space; this should allow
  getcustomsybmol to resolve these
  */
SYSTEM_PROC( void, AddMappedLibrary )( CTEXTSTR libname, POINTER image_memory );
SYSTEM_PROC( LOGICAL, IsMappedLibrary )( CTEXTSTR libname );
SYSTEM_PROC( void, DeAttachThreadToLibraries )( LOGICAL attach );
#define LoadFunction(l,f) LoadFunctionEx(l,f DBG_SRC )
SYSTEM_PROC( generic_function, LoadPrivateFunctionEx )( CTEXTSTR libname, CTEXTSTR funcname DBG_PASS );
#define LoadPrivateFunction(l,f) LoadPrivateFunctionEx(l,f DBG_SRC )
#define OnLibraryLoad(name)	  DefineRegistryMethod("SACK",_OnLibraryLoad,"system/library","load_event",name "_LoadEvent",void,(void), __LINE__)
// the callback passed will be called during LoadLibrary to allow an external
// handler to download or extract the library; the resulting library should also
// be loaded by the callback using the standard 'LoadFunction' methods
SYSTEM_PROC( void, SetExternalLoadLibrary )( LOGICAL (CPROC*f)(const char *) );
// please Release or Deallocate the reutrn value
// the callback should search for the file specified, if required, download or extract it
// and then return with a Release'able utf-8 char *.
SYSTEM_PROC( void, SetExternalFindProgram )( char * (CPROC*f)(const char *) );
// override the default program name.
// Certain program wrappers might use this to change log location, configuration, etc other defaults.
SYSTEM_PROC( void, SetProgramName )( CTEXTSTR filename );
// this is a pointer pointer - being that generic_fucntion is
// a pointer...
SYSTEM_PROC( int, UnloadFunctionEx )( generic_function* DBG_PASS );
#ifdef HAVE_ENVIRONMENT
SYSTEM_PROC( CTEXTSTR, OSALOT_GetEnvironmentVariable )(CTEXTSTR name);
SYSTEM_PROC( void, OSALOT_SetEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
SYSTEM_PROC( void, OSALOT_AppendEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
SYSTEM_PROC( void, OSALOT_PrependEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
#endif
/* this needs to have 'GetCommandLine()' passed to it.
 * Otherwise, the command line needs to have the program name, and arguments passed in the string
 * the parameter to winmain has the program name skipped
 */
SYSTEM_PROC( void, ParseIntoArgs )( TEXTCHAR *lpCmdLine, int *pArgc, TEXTCHAR ***pArgv );
#define UnloadFunction(p) UnloadFunctionEx(p DBG_SRC )
/*
   Check if task spawning is allowed...
*/
SYSTEM_PROC( LOGICAL, sack_system_allow_spawn )( void );
/*
   Disallow task spawning.
*/
SYSTEM_PROC( void, sack_system_disallow_spawn )( void );
SACK_SYSTEM_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::system;
#endif
#endif
//----------------------------------------------------------------------
// $Log: system.h,v $
// Revision 1.14  2005/07/06 00:33:55  jim
// Fixes for all sorts of mangilng with the system.h header.
//
//
// Revision 1.2  2003/10/24 14:59:21  panther
// Added Load/Unload Function for system shared library abstraction
//
// Revision 1.1  2003/10/24 13:22:06  panther
// Initial commit
//
//
#if defined( _MSC_VER )|| defined(__LCC__) || defined( __WATCOMC__ ) || defined( __GNUC__ )
/* Includes networking as appropriate for the target platform. Providing
   compatibility definitions as are lacking between platforms...
   or perhaps appropriate name aliasing to the correct types.            */
#ifndef INCLUDED_SOCKET_LIBRARY
#define INCLUDED_SOCKET_LIBRARY
#if defined( _WIN32 ) || defined( __CYGWIN__ )
//#ifndef __cplusplus_cli
#ifdef UNDER_CE
#define USE_WSA_EVENTS
#endif
#include <winsock2.h>
#include <ws2tcpip.h>
#if defined( MINGW_SUX ) && ( __GNUC__ < 5 )
/* Address information */
typedef struct addrinfoA {
    int             ai_flags;
    int             ai_family;
    int             ai_socktype;
    int             ai_protocol;
    size_t          ai_addrlen;
    char            *ai_canonname;
    struct sockaddr *ai_addr;
    struct addrinfoA *ai_next;
} ADDRINFOA;
typedef ADDRINFOA   *PADDRINFOA;
typedef struct addrinfoW {
    int                 ai_flags;
    int                 ai_family;
    int                 ai_socktype;
    int                 ai_protocol;
    size_t              ai_addrlen;
    PWSTR               ai_canonname;
    struct sockaddr     *ai_addr;
    struct addrinfoW    *ai_next;
} ADDRINFOW;
typedef ADDRINFOW   *PADDRINFOW;
typedef ADDRINFOA   ADDRINFOT;
typedef ADDRINFOA   *PADDRINFOT;
typedef ADDRINFOA   ADDRINFO;
typedef ADDRINFOA   *LPADDRINFO;
#endif
#ifdef __CYGWIN__
// just need this simple symbol
typedef int socklen_t;
#endif
//#endif
#elif defined( __LINUX__ )
#if defined( FBSD )
#endif
 // INADDR_ANY/NONE
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#if !defined( _PNACL )
#  include <net/if.h>
#endif
#define SOCKET int
#define SOCKADDR struct sockaddr
#define SOCKET_ERROR -1
//#define HWND int // unused params...
#define WSAEWOULDBLOCK EAGAIN
#define INVALID_SOCKET -1
#define WSAAsynchSelect( a,b,c,d ) (0)
#define WSAGetLastError()  (errno)
#define closesocket(s) close(s)
typedef struct hostent *PHOSTENT;
#ifndef __LINUX__
#define INADDR_ANY (-1)
#define INADDR_NONE (0)
#endif
struct win_in_addr {
	union {
		struct { uint8_t s_b1,s_b2,s_b3,s_b4; } S_un_b;
		struct { uint16_t s_w1,s_w2; } S_un_w;
		uint32_t S_addr;
	} S_un;
#ifndef __ANDROID__
#define s_addr  S_un.S_addr
/* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
	/* host on imp */
#define s_net   S_un.S_un_b.s_b1
	/* network */
#define s_imp   S_un.S_un_w.s_w2
	/* imp */
#define s_impno S_un.S_un_b.s_b4
	/* imp # */
#define s_lh    S_un.S_un_b.s_b3
	/* logical host */
#endif
};
struct win_sockaddr_in {
#ifdef __MAC__
	uint8_t sa_len;
	uint8_t sin_family;
#else
	short   sin_family;
#endif
	uint16_t sin_port;
	struct  win_in_addr sin_addr;
	char    sin_zero[8];
};
typedef struct win_sockaddr_in SOCKADDR_IN;
#endif
#endif
// $Log: loadsock.h,v $
// Revision 1.7  2005/01/27 08:09:25  panther
// Linux cleaned.
//
// Revision 1.6  2003/06/04 11:38:01  panther
// Define PACKED
//
// Revision 1.5  2003/03/25 08:38:11  panther
// Add logging
//
#  if defined( __MAC__ )
#  else
               // _heapmin() included here
#    include <malloc.h>
#  endif
#else
//#include "loadsock.h"
#endif
//#include <stdlib.h>
#ifdef __CYGWIN__
 // provided by -lgcc
// lots of things end up including 'setjmp.h' which lacks sigset_t defined here.
// lots of things end up including 'setjmp.h' which lacks sigset_t defined here.
#  include <sys/signal.h>
#endif
// GetTickCount() and Sleep(n) Are typically considered to be defined by including stdhdrs...
/*
 *  Crafted by Jim Buckeyne
 *
 *  (c)2001-2006++ Freedom Collective
 *
 *  Provide API interface for timers, critical sections
 *  and other thread things.
 *
 */
#ifndef TIMERS_DEFINED
/* timers.h mutliple inclusion protection symbol. */
#define TIMERS_DEFINED
#if defined( _WIN32 )
// on windows, we add a function that returns HANDLE
#endif
#ifndef SHARED_MEM_DEFINED
/* Multiple inclusion protection symbol. */
#define SHARED_MEM_DEFINED
#if defined (_WIN32)
//#define USE_NATIVE_CRITICAL_SECTION
#endif
#if defined( _SHLWAPI_H ) || defined( _INC_SHLWAPI )
#undef StrChr
#undef StrCpy
#undef StrDup
#undef StrRChr
#undef StrStr
#endif
#if defined( __MAC__ )
#  define strdup(s) StrDup(s)
#  define strdup_free(s) Release(s)
#else
#  define strdup_free(s) free(s)
#endif
#ifdef __cplusplus
#define SACK_MEMORY_NAMESPACE SACK_NAMESPACE namespace memory {
#define SACK_MEMORY_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define SACK_MEMORY_NAMESPACE
#define SACK_MEMORY_NAMESPACE_END
#endif
/* A declaration of the call type for memory library routines. */
#define MEM_API CPROC
#    ifdef MEM_LIBRARY_SOURCE
#      define MEM_PROC EXPORT_METHOD
#    else
/* Defines library linkage specification. */
#      define MEM_PROC IMPORT_METHOD
#    endif
#ifndef TIMER_NAMESPACE
#ifdef __cplusplus
#define _TIMER_NAMESPACE namespace timers {
/* define a timer library namespace in C++. */
#define TIMER_NAMESPACE SACK_NAMESPACE namespace timers {
/* define a timer library namespace in C++ end. */
#define TIMER_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define TIMER_NAMESPACE
#define TIMER_NAMESPACE_END
#endif
#endif
	TIMER_NAMESPACE
   // enables file/line monitoring of sections and a lot of debuglogging
//#define DEBUG_CRITICAL_SECTIONS
   /* this symbol controls the logging in timers.c... (higher level interface to NoWait primatives)*/
//#define LOG_DEBUG_CRITICAL_SECTIONS
/* A custom implementation of windows CRITICAL_SECTION api.
   Provides same capability for Linux type systems. Can be
   checked as a study in how to implement safe locks.
   See Also
   InitCriticalSec
   EnterCriticalSec
   LeaveCriticalSec
   Example
   <c>For purposes of this example this is declared in global
   memory, known to initialize to all 0.</c>
   <code lang="c++">
   CRITICALSECTION cs_lock_test;
   </code>
   In some bit of code that can be executed by several
   threads...
   <code lang="c++">
   {
      EnterCriticalSec( &amp;cs_lock_test );
      // the code in here will only be run by a single thread
      LeaveCriticalSec( &amp;cs_lock_test );
   }
   </code>
   Remarks
   The __Ex versions of functions passes source file and line
   information in debug mode. This can be used if critical
   section debugging is turned on, or if critical section
   logging is turned on. (See ... ) This allows applications to
   find deadlocks by tracking who is entering critical sections
   and probably failing to leave them.                          */
struct critical_section_tag {
 // this is set when entering or leaving (updating)...
	uint32_t dwUpdating;
  // count of locks entered.  (only low 24 bits may count for 16M entries, upper bits indicate internal statuses.
	uint32_t dwLocks;
 // windows upper 16 is process ID, lower is thread ID
	THREAD_ID dwThreadID;
 // ID of thread waiting for this..
	THREAD_ID dwThreadWaiting;
#ifdef DEBUG_CRITICAL_SECTIONS
	// these are not included without a special compile flag
	// only required by low level deveopers who may be against
   // undefined behavior.
#define MAX_SECTION_LOG_QUEUE 16
	uint32_t bCollisions ;
	CTEXTSTR pFile[16];
	uint32_t  nLine[16];
	uint32_t  nLineCS[16];
 // windows upper 16 is process ID, lower is thread ID
	THREAD_ID dwThreadPrior[16];
 // windows upper 16 is process ID, lower is thread ID
	uint8_t isLock[16];
	int nPrior;
#endif
};
#if !defined( _WIN32 )
#undef USE_NATIVE_CRITICAL_SECTION
#endif
/* <combine sack::timers::critical_section_tag>
   \ \                                          */
#if defined( USE_NATIVE_CRITICAL_SECTION )
#define CRITICALSECTION CRITICAL_SECTION
#else
typedef struct critical_section_tag CRITICALSECTION;
#endif
/* <combine sack::timers::critical_section_tag>
   defines a pointer to a CRITICALSECTION type  */
#if defined( USE_NATIVE_CRITICAL_SECTION )
#define PCRITICALSECTION LPCRITICAL_SECTION
#else
#define InitializeCriticalSection InitializeCriticalSec
typedef struct critical_section_tag *PCRITICALSECTION;
#endif
/* attempts to enter the critical section, and does not block.
   Returns
   If it enters the return is 1, else the return is 0.
   Parameters
   pcs :    pointer to a critical section
   prior :  if not NULL, prior will be set to the current thread
            ID of the owning thread.                             */
#ifndef USE_NATIVE_CRITICAL_SECTION
MEM_PROC  int32_t MEM_API  EnterCriticalSecNoWaitEx ( PCRITICALSECTION pcs, THREAD_ID *prior DBG_PASS );
#define EnterCriticalSecNoWait( pcs,prior ) EnterCriticalSecNoWaitEx( pcs, prior DBG_SRC )
#else
#define EnterCriticalSecNoWait( pcs,prior ) TryEnterCriticalSection( (pcs) )
#endif
/* <combine sack::timers::EnterCriticalSecNoWaitEx@PCRITICALSECTION@THREAD_ID *prior>
   \ \                                                                                */
//#define EnterCriticalSecNoWait( pcs,prior ) EnterCriticalSecNoWaitEx( (pcs),(prior) DBG_SRC )
/* clears all members of a CRITICALSECTION.  Same as memset( pcs, 0, sizeof( CRITICALSECTION ) ); */
#ifndef USE_NATIVE_CRITICAL_SECTION
MEM_PROC  void MEM_API  InitializeCriticalSec ( PCRITICALSECTION pcs );
#else
#define InitializeCriticalSec(pcs)  InitializeCriticalSection(pcs)
#endif
/* Get a count of how many times a critical section is locked */
//MEM_PROC  uint32_t MEM_API  CriticalSecOwners ( PCRITICALSECTION pcs );
/* Namespace of all memory related functions for allocating and
   releasing memory.                                            */
#ifdef __cplusplus
 // namespace timers
}
 // namespace sack
}
using namespace sack::timers;
#endif
#ifdef __cplusplus
namespace sack {
/* Memory namespace contains functions for allocating and
   releasing memory. Also contains methods for accessing shared
   memory (if available on the target platform).
   Allocate
   Release
   Hold
   OpenSpace                                                    */
namespace memory {
#endif
typedef struct memory_block_tag* PMEM;
// what is an abstract name for the memory mapping handle...
// where is a filename for the filebacking of the shared memory
// DigSpace( "Picture Memory", "Picture.mem", 100000 );
/* <combinewith sack::memory::OpenSpaceExx@CTEXTSTR@CTEXTSTR@uintptr_t@uintptr_t *@uint32_t*>
   \ \                                                                                 */
MEM_PROC  POINTER MEM_API  OpenSpace ( CTEXTSTR pWhat, CTEXTSTR pWhere, size_t *dwSize );
/* <unfinished>
   Open a shared memory region. The region may be named with a
   text string (this does not work under linux platforms, and
   the name of the file to back the shared region is the sharing
   point). The region may be backed with a file (and must be if
   it is to be shared on linux.
   If the region exists by name, the region is opened, and a
   pointer to that region is returned.
   If the file exists, the file is opened, and mapped into
   memory, and a pointer to the file backed memory is returned.
   if the file does not exist, and the size parameter passed is
   not 0, then the file is created, and expanded to the size
   requested. The bCreate flag is set to true.
   If NULL is passed for pWhat and pWhere, then a block of
   memory is allocated in system memory, backed by pagefile.
   if dwSize is 0, then the region is specified for open only,
   and will not create.
   Parameters
   pWhat :     String to a named shared memory region. NULL is
               unnamed.
   pWhere :    Filename to back the shared memory with. The file
               name itself may also be used to share the memory.
   address :   A base address to map the memory at. If 0,
               specifies do not care.
   dwSize :    pointer to a uintptr_t that defines the size to
               create. If 0, then the region is only opened. The
               size of the region opened is set back into this
               value after it is opened.
   bCreated :  pointer to a boolean to indicate whether the space
               was created or not.
   Returns
   Pointer to region requested to be opened. NULL on failure.
   Example
   Many examples of this are appropriate.
   1) Open or create a file backed shared space.
   2) Open a file for direct memory access, the file is loaded
   into memory by system paging routines and not any API.         */
MEM_PROC  POINTER MEM_API  OpenSpaceExx ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t address
	, size_t *dwSize, uint32_t* bCreated );
/* <combine sack::memory::OpenSpaceExx@CTEXTSTR@CTEXTSTR@uintptr_t@uintptr_t *@uint32_t*>
   \ \                                                                             */
#define OpenSpaceEx( what,where,address,psize) OpenSpaceExx( what,where,address,psize,NULL )
/* Closes a shared memory region. Calls CloseSpaceEx() with
   bFinal set TRUE.
   Parameters
   pMem :  pointer to a memory region opened by OpenSpace.  */
MEM_PROC  void MEM_API  CloseSpace ( POINTER pMem );
/* Closes a memory region. Release can also be used to close
   opened spaces.
   Parameters
   pMem :    pointer to a memory region opened with OpenSpace()
   bFinal :  If final is set, the file used for backing the shared
             region is deleted.                                    */
MEM_PROC  void MEM_API  CloseSpaceEx ( POINTER pMem, int bFinal );
/* This can give the size back of a memory space.
   Returns
   The size of the memory block.
   Parameters
   pMem :  pointer to a block of memory that was opened with
           OpenSpace().                                      */
MEM_PROC  uintptr_t MEM_API  GetSpaceSize ( POINTER pMem );
/* even if pMem is just a POINTER returned from OpenSpace this
   will create a valid heap pointer.
   will result TRUE if a valid heap is present will result FALSE
   if heap is not able to init (has content)
   Parameters
   pMem :    pointer to a memory space to setup as a heap.
   dwSize :  size of the memory space pointed at by pMem.        */
MEM_PROC  int MEM_API  InitHeap( PMEM pMem, size_t dwSize );
/* Dumps all blocks into the log.
   Parameters
   pHeap :     Heap to dump. If NULL or unspecified, dump the
               default heap.
   bVerbose :  Specify to dump each block's information,
               otherwise only summary information is generated. */
MEM_PROC  void MEM_API  DebugDumpHeapMemEx ( PMEM pHeap, LOGICAL bVerbose );
/* <combine sack::memory::DebugDumpHeapMemEx@PMEM@LOGICAL>
   Logs all of the blocks tracked in a specific heap.
   Parameters
   Heap :  Heap to dump the memory blocks of.              */
#define DebugDumpHeapMem(h)     DebugDumpMemEx( (h), TRUE )
/* <combine sack::memory::DebugDumpHeapMemEx@PMEM@LOGICAL>
   \ \                                                     */
MEM_PROC  void MEM_API  DebugDumpMemEx ( LOGICAL bVerbose );
/* Dumps all tracked heaps.
   Parameters
   None.                    */
#define DebugDumpMem()     DebugDumpMemEx( TRUE )
/* Dumps a heap to a specific file.
   Parameters
   pHeap :      Heap. If NULL or unspecified, dumps default heap.
   pFilename :  name of the file to write output to.              */
MEM_PROC  void MEM_API  DebugDumpHeapMemFile ( PMEM pHeap, CTEXTSTR pFilename );
/* <combine sack::memory::DebugDumpHeapMemFile@PMEM@CTEXTSTR>
   \ \                                                        */
MEM_PROC  void MEM_API  DebugDumpMemFile ( CTEXTSTR pFilename );
#ifdef __GNUC__
MEM_PROC  POINTER MEM_API  HeapAllocateAlignedEx ( PMEM pHeap, size_t dwSize, uint16_t alignment DBG_PASS ) __attribute__( (malloc) );
MEM_PROC  POINTER MEM_API  HeapAllocateEx ( PMEM pHeap, uintptr_t nSize DBG_PASS ) __attribute__((malloc));
MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS ) __attribute__((malloc));
#else
/* \ \
   Parameters
   pHeap :  pointer to a heap which was initialized with
            InitHeap()
   Size :   Size of block to allocate                    */
MEM_PROC  POINTER MEM_API  HeapAllocateEx ( PMEM pHeap, uintptr_t nSize DBG_PASS );
/* \ Parameters
pHeap :  pointer to a heap which was initialized with
InitHeap()
Size :   Size of block to allocate
Alignment : count of bytes to return block on (1,2,4,8,16,32)  */
MEM_PROC  POINTER MEM_API  HeapAllocateAlignedEx( PMEM pHeap, uintptr_t nSize, uint16_t alignment DBG_PASS );
/* Allocates a block of memory of specific size. Debugging
   information if passed is recorded on the block.
   Parameters
   size :  size of the memory block to create              */
MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS );
#endif
/* A simple macro to allocate a new single unit of a structure. Adds
   a typecast automatically to be (type*) so C++ compilation is
   clean. Does not burden the user with extra typecasts. This,
   being in definition use means that all other things that are
   typecast are potentially error prone. Memory is considered
   uninitialized.
   Parameters
   type :  type to allocate
   Example
   <code lang="c++">
   int *p_int = New( int );
   </code>                                                           */
#define New(type) ((type*)HeapAllocate(0,sizeof(type)))
/* Reallocates an array of type.
   Parameters
   type :  type to use for sizeof(type) * sz for resulting size.
   p :     pointer to realloc
   sz :    count of elements in the array                        */
#define Renew(type,p,sz) ((type*)HeapReallocate(0,p, sizeof(type)*sz))
/* an advantage of C, can define extra space at end of structure
   which is allowed to carry extra data, which is unknown by
   other code room for exploits rock.
   Parameters
   type :   passed to sizeof()
   extra :  Number of additional bytes to allocate beyond the
            sizeof( type )
   Example
   Create a text segment plus 18 characters of data. (This
   should not be done, use SegCreate instead)
   <code lang="c#">
   PTEXT text = NewPlus( TEXT, 18 );
   </code>                                                       */
#define NewPlus(type,extra) ((type*)HeapAllocate(0,sizeof(type)+(extra)))
/* Allocate a new array of type.
   Parameters
   type :   type to determine size of array element to allocate.
   count :  count of elements to allocate in the array.
   Returns
   A pointer to type. (this is important, since in C++ it's cast
   correctly to the destination type).                           */
#define NewArray(type,count) ((type*)HeapAllocate(0,(uintptr_t)(sizeof(type)*(count))))
/* Allocate sizeof(type). Will invoke some sort of registered
   initializer
   Parameters
   type :  type to allocate for. Passes the name of the type so
           the allocator can do a registered procedure lookup and
           invok an initializer for the type.                     */
//#define NewObject(type) ((type*)FancyAllocate(sizeof(type),#type DBG_SRC))
#ifdef __cplusplus
/* A 'safe' release macro. casts the block to the type to
   release. Makes sure the pointer being released is the type
   specified.
   Parameters
   type :   type of the variable
   thing :  the thing to actually release.                    */
#  ifdef _DEBUG
#    define Deallocate(type,thing) for(type _zzqz_tmp=thing;ReleaseEx((POINTER)(_zzqz_tmp)DBG_SRC),0;)
#  else
#    define Deallocate(type,thing) ReleaseEx((POINTER)(thing)DBG_SRC)
#  endif
#else
#  define Deallocate(type,thing) (ReleaseEx((POINTER)(thing)DBG_SRC))
#endif
/* <combine sack::memory::HeapAllocateEx@PMEM@uintptr_t nSize>
   \ \                                                        */
#define HeapAllocate(heap, n) HeapAllocateEx( (heap), (n) DBG_SRC )
   /* <combine sack::memory::HeapAllocateAlignedEx@PMEM@uintptr_t@uint32_t>
   \ \                                                        */
#define HeapAllocateAligned(heap, n, m) HeapAllocateAlignedEx( (heap), (n), m DBG_SRC )
   /* <combine sack::memory::AllocateEx@uintptr_t nSize>
   \ \                                               */
#ifdef FIX_RELEASE_COM_COLLISION
#else
#define Allocate( n ) HeapAllocateEx( (PMEM)0, (n) DBG_SRC )
#endif
//MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS );
//#define Allocate(n) AllocateEx(n DBG_SRC )
MEM_PROC  POINTER MEM_API  GetFirstUsedBlock ( PMEM pHeap );
/* Releases an allocated block. Memory becomes free to allocate
   again. If debugging information is passed, the releasing
   source and line is recorded in the block. (can be used to
   find code deallocating memory it shouldn't).
   This also works with Hold(), and decrements the hold counter.
   If there are no more holds on the block, then the block is
   released.
   Parameters
   p :  pointer to allocated block to release.                   */
MEM_PROC  POINTER MEM_API  ReleaseEx ( POINTER pData DBG_PASS ) ;
/* <combine sack::memory::ReleaseEx@POINTER pData>
   \ \                                             */
#ifdef FIX_RELEASE_COM_COLLISION
#else
/* <combine sack::memory::ReleaseEx@POINTER pData>
   \ \                                             */
#define Release(p) ReleaseEx( (p) DBG_SRC )
#endif
/* Adds a usage count to a block of memory. For each count
   added, an additional release must be used. This can be used
   to keep a copy of the block, even if some other code
   automatically releases it.
   Parameters
   pointer :  pointer to a block of memory that was Allocate()'d.
   Example
   Allocate a block of memory, and release it properly. But we
   passed it to some function. That function wanted to keep a
   copy of the block, so it can apply a hold. It needs to later
   do a Release again to actually free the memory.
   <code lang="c++">
   POINTER p = Allocate( 32 );
   call_some_function( p );
   Release( p );
   void call_some_function( POINTER p )
   {
      static POINTER my_p_copy;
      my_p_copy = p;
      Hold( p );
   }
   </code>                                                        */
MEM_PROC  POINTER MEM_API  HoldEx ( POINTER pData DBG_PASS  );
/* <combine sack::memory::HoldEx@POINTER pData>
   \ \                                          */
#define Hold(p) HoldEx(p DBG_SRC )
/* This can be used to add additional space after the end of a
   memory block.
   Parameters
   pHeap :   If NULL or not specified, uses the common memory heap.
   source :  pointer to the block to pre\-allocate. If NULL, a new
             memory block will be allocated that is filled with 0.
   size :    the new size of the block.
   Returns
   A pointer to a new block of memory that is the new size.
   Remarks
   If the size specified for the new block is larger than the
   previous size of the block, the curernt data is copied to the
   beginning of the new block, and the memory after the existing
   content is cleared to 0.
   If the size specified for the new block is smaller than the
   previous size, the end of the original block is not copied to
   the new block.
   If NULL is passed as the source block, then a new block
   filled with 0 is created.                                        */
MEM_PROC  POINTER MEM_API  HeapReallocateAlignedEx ( PMEM pHeap, POINTER source, uintptr_t size, uint16_t alignment DBG_PASS );
MEM_PROC  POINTER MEM_API  HeapReallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::HeapReallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                 */
#define HeapReallocateAligned(heap,p,sz,al) HeapReallocateEx( (heap),(p),(sz),(al) DBG_SRC )
#define HeapReallocate(heap,p,sz) HeapReallocateEx( (heap),(p),(sz) DBG_SRC )
/* <combine sack::memory::HeapReallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                 */
MEM_PROC  POINTER MEM_API  ReallocateEx ( POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::ReallocateEx@POINTER@uintptr_t size>
   \ \                                                        */
#ifdef FIX_RELEASE_COM_COLLISION
#else
#define Reallocate(p,sz) ReallocateEx( (p),(sz) DBG_SRC )
#endif
/* This can be used to add additional space before the beginning
   of a memory block.
   Parameters
   pHeap :   If NULL or not specified, uses the common memory heap.
   source :  pointer to the block to pre\-allocate. If NULL, a new
             memory block will be allocated that is filled with 0.
   size :    the new size of the block.
   Returns
   A pointer to a new block of memory that is the new size.
   Remarks
   If the size specified for the new block is larger than the
   previous size of the block, the content data is copied to the
   end of the new block, and the memory leading up to the block
   is cleared to 0.
   If the size specified for the new block is smaller than the
   previous size, the end of the original block is not copied to
   the new block.
   If NULL is passed as the source block, then a new block
   filled with 0 is created.                                        */
MEM_PROC  POINTER MEM_API  HeapPreallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::HeapPreallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                  */
#define HeapPreallocate(heap,p,sz) HeapPreallocateEx( (heap),(p),(sz) DBG_SRC )
/* <combine sack::memory::HeapPreallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                  */
MEM_PROC  POINTER MEM_API  PreallocateAlignedEx ( POINTER source, uintptr_t size, uint16_t alignment DBG_PASS );
MEM_PROC  POINTER MEM_API  PreallocateEx ( POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::PreallocateEx@POINTER@uintptr_t size>
   \ \                                                         */
#define PreallocateAligned(p,sz,al) PreallocateAlignedEx( (p),(sz),(al) DBG_SRC )
#define Preallocate(p,sz) PreallocateEx( (p),(sz) DBG_SRC )
/* Moves a block of memory from one heap to another.
   Parameters
   pNewHeap :  heap target to move the block to.
   source :    source block to move \- pointer to the data in the
               block.
   Remarks
   Since each block remembers its own size, it is possible to
   move a block from one heap to another. A heap might be a
   memory mapped file at a specific address for instance.         */
MEM_PROC  POINTER MEM_API  HeapMoveEx ( PMEM pNewHeap, POINTER source DBG_PASS );
/* <combine sack::memory::HeapMoveEx@PMEM@POINTER source>
   \ \                                                    */
#define HeapMove(h,s) HeapMoveEx( (h), (s) DBG_SRC )
/* \returns the size of a memory block which was Allocate()'d.
   Parameters
   pData :  pointer to a allocated memory block.
   Returns
   The size of the block that was specified by the Allocate(). */
MEM_PROC uintptr_t MEM_API  SizeOfMemBlock ( CPOINTER pData );
/* \returns the allocation alignment of a memory block which was Allocate()'d.
Parameters
pData :  pointer to a allocated memory block.
Returns
The alignment of the block that was specified from Allocate(). */
MEM_PROC uint16_t  AlignOfMemBlock( CPOINTER pData );
/* not so much of a fragment as a consolidation. Finds a free
   spot earlier in the heap and attempts to move the block
   there. This can help alleviate heap fragmentation.
   Parameters
   ppMemory :  pointer to a pointer to memory which might move */
MEM_PROC  LOGICAL MEM_API  Defragment ( POINTER *ppMemory );
/* \ \
   Parameters
   pHeap :        pointer to a heap
   pFree :        pointer to a 32 bit value to receive the size
                  of free space
   pUsed :        pointer to a 32 bit value to receive the size
                  of used space
   pChunks :      pointer to a 32 bit value to receive the total
                  count of chunks.
   pFreeChunks :  pointer to a 32 bit value to receive the total
                  count of free chunks.
   Remarks
   It looks like DBG_PASS parameter isn't used... not sure why
   it would here, there is no allocate or delete.
   The count of allocated chunks can be gotten by subtracting
   FreeChunks from Chunks.
   Example
   <code lang="c++">
   uint32_t free;
   uint32_t used;
   uint32_t chunks;
   uint32_t free_chunks;
   GetHeapMemStatsEx( NULL, &amp;free, &amp;used, &amp;chunks, &amp;free_chunks );
   </code>                                                                         */
MEM_PROC  void MEM_API  GetHeapMemStatsEx ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks DBG_PASS );
/* <combine sack::memory::GetHeapMemStatsEx@PMEM@uint32_t *@uint32_t *@uint32_t *@uint32_t *pFreeChunks>
   \ \                                                                               */
#define GetHeapMemStats(h,f,u,c,fc) GetHeapMemStatsEx( h,f,u,c,fc DBG_SRC )
//MEM_PROC  void MEM_API  GetHeapMemStats ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks );
MEM_PROC  void MEM_API  GetMemStats ( uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks );
/* Sets whether to log allocations or not.
   \returns the prior state of logging...
   Parameters
   bTrueFalse :  if TRUE, allocation logging is turned on. Enables
                 logging when each block is Allocated, Released,
                 or Held.                                          */
MEM_PROC  int MEM_API  SetAllocateLogging ( LOGICAL bTrueFalse );
/* disables storing file/line, also disables auto GetMemStats
   checking
   Parameters
   bDisable :  set to TRUE to disable allocate debug logging. */
MEM_PROC  int MEM_API  SetAllocateDebug ( LOGICAL bDisable );
/* disables auto GemMemStats on every allocate/release/Hold
   GetMemStats will evaluate each and every block allocated in
   memory and inspect it for corruption.
   Parameters
   bDisable :  set to TRUE to disable auto mem check.          */
MEM_PROC  int MEM_API  SetManualAllocateCheck ( LOGICAL bDisable );
/* Sets whether to log critical sections or not.
   \returns the prior state of logging...
   Parameters
   bTrueFalse :  if TRUE, critical section logging is turned on. Logs
                 when each thread enters or leaves a
                 CRITICIALSECTION.                                    */
MEM_PROC  int MEM_API  SetCriticalLogging ( LOGICAL bTrueFalse );
/* Sets the minimum size to allocate. If a block size less than
   this is allocated, then this much is actually allocated.
   Parameters
   nSize :  Specify the minimum allocation size                 */
MEM_PROC  void MEM_API  SetMinAllocate ( size_t nSize );
/* Sets how much a heap is expanded by when it is out of space. Default
   is like 512k.
   Parameters
   dwSize :  the new size to expand heaps by.
   Remarks
   Probably internally, this is rounded up to the next 4k
   boundary.                                                            */
MEM_PROC  void MEM_API  SetHeapUnit ( size_t dwSize );
/* Multi-processor safe exchange operation. Returns the prior
   value at the pointer.
   Parameters
   p :    pointer to a volatile 64 bit value.
   val :  a new 64 bit value to put at (*p)
   Example
   <code lang="c#">
   uint64_t value = 13;
   uint64_t oldvalue = LockedExchange64( &amp;value, 15 );
   // old value will be 13
   // value will be 15
   </code>                                                    */
MEM_PROC  uint64_t MEM_API  LockedExchange64 ( volatile uint64_t* p, uint64_t val );
/* A multi-processor safe increment of a variable.
   Parameters
   p :  pointer to a 32 bit value to increment.    */
MEM_PROC  uint32_t MEM_API  LockedIncrement ( volatile uint32_t* p );
/* Does a multi-processor safe decrement on a variable.
   Parameters
   p :  pointer to a 32 bit value to decrement.         */
MEM_PROC  uint32_t MEM_API  LockedDecrement ( volatile uint32_t* p );
#ifdef __cplusplus
// like also __if_assembly__
//extern "C" {
#endif
#ifdef __64__
#define LockedExchangePtrSzVal(a,b) LockedExchange64((volatile uint64_t*)(a),b)
#else
#define LockedExchangePtrSzVal(a,b) LockedExchange((volatile uint32_t*)(a),b)
#endif
/* Multiprocessor safe swap of the contents of a variable with a
   new value, and result with the old variable.
   Parameters
   p :    pointer to a 32 bit value to exchange
   val :  value to set into the variable
   Returns
   The prior value in p.
   Example
   <code>
   uint32_t variable = 0;
   uint32_t oldvalue = LockedExchange( &amp;variable, 1 );
   </code>                                                       */
MEM_PROC  uint32_t MEM_API  LockedExchange ( volatile uint32_t* p, uint32_t val );
/* Sets a 32 bit value into memory. If the length to set is not
   a whole number of 32 bit words, the last bytes may contain
   the low 16 bits of the value and the low 8 bits.
   Parameters
   p :   pointer to memory to set
   n :   32 bit value to set memory with
   sz :  length to set
   Remarks
   Writes as many 32 it values as will fit in sz.
   If (sz &amp; 2), the low 16 bits of n are written at the end.
   then if ( sz &amp; 1 ) the low 8 bits of n are written at the
   end.                                                          */
MEM_PROC  void MEM_API  MemSet ( POINTER p, uintptr_t n, size_t sz );
//#define _memset_ MemSet
/* memory copy operation. not safe when buffers overlap. Performs
   platform-native memory stream operation to copy from one
   place in memory to another. (32 or 64 bit operations as
   possible).
   Parameters
   pTo :    Memory to copy to
   pFrom :  memory to copy from
   sz :     size of block of memory to copy                       */
MEM_PROC  void MEM_API  MemCpy ( POINTER pTo, CPOINTER pFrom, size_t sz );
//#define _memcpy_ MemCpy
/* Binary byte comparison of one block of memory to another. Results
   \-1 if less, 1 if more and 0 if equal.
   Parameters
   pOne :  pointer to memory one
   pTwo :  pointer to some other memory
   sz :    count of bytes to compare
   Returns
   0 if equal
   \-1 if the first different byte in pOne is less than pTwo.
   1 if the first different byte in pOne is more than pTwo.          */
MEM_PROC  int MEM_API  MemCmp ( CPOINTER pOne, CPOINTER pTwo, size_t sz );
	/* nothing.
   does nothing, returns nothing. */
//#define memnop(mem,sz,comment)
/* Compares two strings. Must match exactly.
   Parameters
   s1 :  string to compare
   s2 :  string to compare
   Returns
   0 if equal.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
	if s1 and s2 are NULL return is 0.              */
#ifdef StrCmp
#undef StrCmp
 // StrCmp
#endif
MEM_PROC  int MEM_API  StrCmp ( CTEXTSTR pOne, CTEXTSTR pTwo );
/* Compares two strings, case insensitively.
   Parameters
   s1 :  string to compare
   s2 :  string to compare
   Returns
   0 if equal.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
   if s1 and s2 are NULL return is 0.              */
MEM_PROC  int MEM_API  StrCaseCmp ( CTEXTSTR s1, CTEXTSTR s2 );
/* String insensitive case comparison with maximum length
   specified.
   Parameters
   s1 :      string to compare
   s2 :      string to compare
   maxlen :  maximum character required to match
   Returns
   0 if equal up to the number of characters.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
   if s1 and s2 are NULL return is 0.                     */
MEM_PROC  int MEM_API  StrCaseCmpEx ( CTEXTSTR s1, CTEXTSTR s2, size_t maxlen );
/* This searches a string for the first character that matches
   some specified character.
   A custom strchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This flavor is the only one on C where operator overloading
   cannot switch between CTEXTSTR and TEXTSTR parameters, to
   \result with the correct type. If a CTEXTSTR is passed to
   this it should result with a CTEXTSTR, but if that's the only
   choice, then the result of this is never modifiable, even if
	it is a pointer to a non-const TEXTSTR.                       */
MEM_PROC  CTEXTSTR MEM_API  StrChr ( CTEXTSTR s1, TEXTCHAR c );
/* copy S2 to S1, with a maximum of N characters.
   The last byte of S1 will always be a 'nul'. If S2 was longer
   than S1, then it will be truncated to fit within S1. Perferred
   method over this is SaveText or StrDup.
   Parameters
   s1 :      desitnation TEXTCHAR buffer
   s2 :      source string
   length :  the maximum number of characters that S1 can hold. (this
             is not a size, but is a character count)                 */
MEM_PROC  TEXTSTR MEM_API  StrCpyEx ( TEXTSTR s1, CTEXTSTR s2, size_t n );
/* copy S2 to S1. This is 'unsafe', since neither paramter's
   size is known. Prefer StrCpyEx which passes the maximum
   length for S1.
   Parameters
   s1 :  desitnation TEXTCHAR buffer
   s2 :  source string                                       */
MEM_PROC  TEXTSTR MEM_API  StrCpy ( TEXTSTR s1, CTEXTSTR s2 );
/* \Returns the count of characters in a string.
   Parameters
   s :  string to measure
   Returns
   length of string.                             */
MEM_PROC  size_t MEM_API  StrLen ( CTEXTSTR s );
/* Get the length of a string in C chars.
   Parameters
   s :  char * to count.
   Returns
   the length of s. If s is NULL, return 0. */
MEM_PROC  size_t MEM_API  CStrLen ( char const*s );
/* Finds the last instance of a character in a string.
   Parameters
   s1 :  String to search in
   c :   character to find
   Returns
   NULL if character is not in the string.
   a pointer to the last character in s1 that matches c. */
MEM_PROC  CTEXTSTR MEM_API  StrRChr ( CTEXTSTR s1, TEXTCHAR c );
#ifdef __cplusplus
/* This searches a string for the first character that matches
   some specified character.
   A custom strchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This second flavor is only available on C++ where operator
   overloading will switch between CTEXTSTR and TEXTSTR
   \parameters, to result with the correct type. If a CTEXTSTR
   is passed to this it should result with a CTEXTSTR, but if
   that's the only choice, then the result of this is never
   modifiable, even if it is a pointer to a non-const TEXTSTR.  */
MEM_PROC  TEXTSTR MEM_API  StrChr ( TEXTSTR s1, TEXTCHAR c );
/* This searches a string for the last character that matches
   some specified character.
   A custom strrchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This second flavor is only available on C++ where operator
   overloading will switch between CTEXTSTR and TEXTSTR
   \parameters, to result with the correct type. If a CTEXTSTR
   is passed to this it should result with a CTEXTSTR, but if
   that's the only choice, then the result of this is never
   modifiable, even if it is a pointer to a non-const TEXTSTR.  */
MEM_PROC  TEXTSTR MEM_API  StrRChr ( TEXTSTR s1, TEXTCHAR c );
/* <combine sack::memory::StrCmp@CTEXTSTR@CTEXTSTR>
   \ \                                              */
MEM_PROC  int MEM_API  StrCmp ( const char * s1, CTEXTSTR s2 );
#endif
/* <combine sack::memory::StrCmp@char *@CTEXTSTR>
   \ \                                            */
MEM_PROC  int MEM_API  StrCmpEx ( CTEXTSTR s1, CTEXTSTR s2, INDEX maxlen );
/* Finds an instance of a string in another string.
   Custom implementation because strstr is declared unsafe, and
   to handle switching between unicode and char.
   Parameters
   s1 :  the string to search in
   s2 :  the string to locate
   Returns
   NULL if s2 is not in s1.
   The beginning of the string in s1 that matches s2.
   Example
   <code lang="c++">
   TEXTCHAR const *found = StrStr( "look in this string", "in" );
                                               ^returns a pointer to here.
   </code>                                                                        */
MEM_PROC  CTEXTSTR MEM_API  StrStr ( CTEXTSTR s1, CTEXTSTR s2 );
#ifdef __cplusplus
/* Finds an instance of a string in another string.
   Custom implementation because strstr is declared unsafe, and
   to handle switching between unicode and char.
   Parameters
   s1 :  the string to search in
   s2 :  the string to locate
   Returns
   NULL if s2 is not in s1.
   The beginning of the string in s1 that matches s2.
   Example
   <code>
   TEXTCHAR *writable_string = StrDup( "look in this string" );
   TEXTCHAR *found = StrStr( writable_string, "in" );
   // returns a pointer to 'in' in the writable string, which can then be modified.
   </code>                                                                          */
MEM_PROC  TEXTSTR MEM_API  StrStr ( TEXTSTR s1, CTEXTSTR s2 );
#endif
/* Searches for one string in another. Compares case
   insensitively.
   Parameters
   s1 :  string to search in
   s2 :  string to locate
   See Also
   <link sack::memory::StrStr@CTEXTSTR@CTEXTSTR, StrStr> */
MEM_PROC  CTEXTSTR MEM_API  StrCaseStr ( CTEXTSTR s1, CTEXTSTR s2 );
/* This duplicates a block of memory.
   Parameters
   p :  pointer to a block of memory that was allocated.
   Returns
   a pointer to a new block of memory that has the same content
   as the original.                                             */
MEM_PROC  POINTER MEM_API  MemDupEx ( CPOINTER thing DBG_PASS );
/* <combine sack::memory::MemDupEx@CPOINTER thing>
   \ \                                             */
#define MemDup(thing) MemDupEx(thing DBG_SRC )
/* Duplicates a string, and returns a pointer to the copy.
   Parameters
   original :  string to duplicate                         */
MEM_PROC  TEXTSTR MEM_API  StrDupEx ( CTEXTSTR original DBG_PASS );
/* Translates from a TEXTCHAR string to a char string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  char *  MEM_API  CStrDupEx ( CTEXTSTR original DBG_PASS );
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  wchar_t *  MEM_API  DupTextToWideEx( CTEXTSTR original DBG_PASS );
#define DupTextToWide(s) DupTextToWideEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  char *     MEM_API  DupTextToCharEx( CTEXTSTR original DBG_PASS );
#define DupTextToChar(s) DupTextToCharEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC TEXTSTR     MEM_API  DupWideToTextEx( const wchar_t *original DBG_PASS );
#define DupWideToText(s) DupWideToTextEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC TEXTSTR     MEM_API  DupCharToTextEx( const char *original DBG_PASS );
#define DupCharToText(s) DupCharToTextEx( s DBG_SRC )
/* Converts from 8 bit char to 16 bit wchar (or no-op if not
   UNICODE compiled)
   Parameters
   original :  original string of C char.
   Returns
   a pointer to a wide character string.                     */
MEM_PROC  TEXTSTR MEM_API  DupCStrEx ( const char * original DBG_PASS );
/* Converts from 8 bit char to 16 bit wchar (or no-op if not
UNICODE compiled)
Parameters
original :  original string of C char.
Returns
a pointer to a wide character string.                     */
MEM_PROC  TEXTSTR MEM_API  DupCStrLenEx( const char * original, size_t chars DBG_PASS );
/* <combine sack::memory::StrDupEx@CTEXTSTR original>
   \ \                                                */
#define StrDup(o) StrDupEx( (o) DBG_SRC )
/* <combine sack::memory::CStrDupEx@CTEXTSTR original>
   \ \                                                 */
#define CStrDup(o) CStrDupEx( (o) DBG_SRC )
/* <combine sack::memory::DupCStrEx@char * original>
   \ \                                               */
#define DupCStr(o) DupCStrEx( (o) DBG_SRC )
/* <combine sack::memory::DupCStrLenEx@char * original@size_t chars>
   \ \                                               */
#define DupCStrLen(o,l) DupCStrLenEx( (o),(l) DBG_SRC )
//------------------------------------------------------------------------
#if 0
// this code was going to provide network oriented shared memory.
#ifndef TRANSPORT_STRUCTURE_DEFINED
typedef uintptr_t PTRANSPORT_QUEUE;
struct transport_queue_tag { uint8_t private_data_here; };
#endif
MEM_PROC  struct transport_queue_tag * MEM_API  CreateQueue ( int size );
MEM_PROC  int MEM_API  EnqueMessage ( struct transport_queue_tag *queue, POINTER msg, int size );
MEM_PROC  int MEM_API  DequeMessage ( struct transport_queue_tag *queue, POINTER msg, int *size );
MEM_PROC  int MEM_API  PequeMessage ( struct transport_queue_tag *queue, POINTER *msg, int *size );
#endif
//------------------------------------------------------------------------
#ifdef __cplusplus
 // namespace memory
}
 // namespace sack
}
using namespace sack::memory;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
/*
inline void operator delete( void * p )
{ Release( p ); }
#ifdef DELETE_HANDLES_OPTIONAL_ARGS
inline void operator delete (void * p DBG_PASS )
{ ReleaseEx( p DBG_RELAY ); }
#define delete delete( DBG_VOIDSRC )
#endif
//#define deleteEx(file,line) delete(file,line)
#ifdef USE_SACK_ALLOCER
inline void * operator new( size_t size DBG_PASS )
{ return AllocateEx( (uintptr_t)size DBG_RELAY ); }
static void * operator new[]( size_t size DBG_PASS )
{ return AllocateEx( (uintptr_t)size DBG_RELAY ); }
#define new new( DBG_VOIDSRC )
#define newEx(file,line) new(file,line)
#endif
*/
// common names - sometimes in conflict when declaring
// other functions... AND - release is a common
// component of iComObject
//#undef Allocate
//#undef Release
// Hmm wonder where this conflicted....
//#undef LineDuplicate
#else
#ifdef USE_SACK_ALLOCER
inline void * operator new(size_t size)
{ return AllocateEx( size ); }
inline void operator delete (void * p)
{ ReleaseEx( p ); }
#endif
#endif
#endif
#endif
#ifdef __LINUX__
#endif
#ifndef _TIMER_NAMESPACE
#ifdef __cplusplus
#define _TIMER_NAMESPACE namespace timers {
/* define a timer library namespace in C++. */
#define TIMER_NAMESPACE SACK_NAMESPACE namespace timers {
/* define a timer library namespace in C++ end. */
#define TIMER_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define _TIMER_NAMESPACE
#define TIMER_NAMESPACE
#define TIMER_NAMESPACE_END
#endif
#endif
// this is a method replacement to use PIPEs instead of SEMAPHORES
// replacement code only affects linux.
#if defined( __QNX__ ) || defined( __MAC__) || defined( __LINUX__ )
#  if defined( __ANDROID__ ) || defined( EMSCRIPTEN ) || defined( __MAC__ )
// android > 21 can use pthread_mutex_timedop
#    define USE_PIPE_SEMS
#  else
//   Default behavior is to use pthread_mutex_timedlock for wakeable sleeps.
// no semtimedop; no semctl, etc
//#    include <sys/sem.h>
//originally used semctl; but that consumes system resources that are not
//cleaned up when the process exits.
#endif
#endif
#ifdef USE_PIPE_SEMS
#  define _NO_SEMTIMEDOP_
#endif
SACK_NAMESPACE
/* This namespace contains methods for working with timers and
   threads. Since timers are implemented in an asynchronous
   thread, the thread creation and control can be exposed here
   also.
   ThreadTo
   WakeThread
   WakeableSleep [Example]
   AddTimer
   RemoveTimer
   RescheduleTimer
   EnterCriticalSec see Also
 EnterCriticalSecNoWait
   LeaveCriticalSec                                            */
_TIMER_NAMESPACE
#ifdef TIMER_SOURCE
#define TIMER_PROC(type,name) EXPORT_METHOD type CPROC name
#else
/* Defines import export and call method for timers. Looks like
   timers are native calltype by default instead of CPROC.      */
#define TIMER_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#if defined( __LINUX__ ) || defined( __ANDROID__ )
TIMER_PROC( uint32_t, timeGetTime )( void );
TIMER_PROC( uint32_t, GetTickCount )( void );
TIMER_PROC( void, Sleep )( uint32_t ms );
#endif
/* Function signature for user callbacks passed to AddTimer. */
typedef void (CPROC *TimerCallbackProc)( uintptr_t psv );
/* Adds a new periodic timer. From now, until the timer is
   removed with RemoveTimer, it will call the timer procedure at
   the specified frequency of milliseconds. The delay until the
   first time the timer fires can be specified independant of
   frequency. If it is not specified, the first time the timer
   will get invoked is at +1 frequency from now.
   Parameters
   start :      how long in milliseconds until the timer starts. Can
                be 0 and timer will fire at the next opportunity.
   frequency :  how long the delay is between event invocations,
                in milliseconds.
   callback :   user routine to call when the timer's delay
                expires.
   user :       user data to pass to the callback when it is
                invoked.
   Returns
   a 32 bit ID that identifies the timer for this application.
   Example
   First some setup valid for all timer creations...
   <code lang="c++">
   void CPROC TimerProc( uintptr_t user_data )
   {
       // user_data of the timer is the 'user' parameter passed to AddTimer(Exx)
   }
   </code>
   you might want to save this for something like
   RescheduleTimer
   <code>
   uint32_t timer_id;
   </code>
   Create a simple timer, it will fire at 250 milliseconds from
   now, and again every 250 milliseconds from the time it
   starts.
   <code lang="c++">
   timer_id = AddTimer( 250, TimerProc, 0 );
   </code>
   Create a timer that fires immediately, and 732 milliseconds
   after, passing some value 1234 as user data...
   <code lang="c++">
   timer_id = AddTimerEx( 0, 732, TimerProc, 1234 );
	</code>
	Remarks
	if a timer is dispatched and needs to wait - please link with idlelib, and call Idle.
	this will allow other timers to fire on schedule.  The timer that is waiting is not
	in the list of timers to process.
	*/
TIMER_PROC( uint32_t, AddTimerExx )( uint32_t start, uint32_t frequency
					, TimerCallbackProc callback
					, uintptr_t user DBG_PASS);
/* <combine sack::timers::AddTimerExx@uint32_t@uint32_t@TimerCallbackProc@uintptr_t user>
   \ \                                                                         */
#define AddTimerEx( s,f,c,u ) AddTimerExx( (s),(f),(c),(u) DBG_SRC )
/* <combine sack::timers::AddTimerExx@uint32_t@uint32_t@TimerCallbackProc@uintptr_t user>
   \ \                                                                         */
#define AddTimer( f, c, u ) AddTimerExx( (f), (f), (c), (u) DBG_SRC)
/* Stops a timer. The next time this timer would run, it will be
   removed. If it is currently dispatched, it is safe to remove
   from within the timer itself.
   Parameters
   timer :  32 bit timer ID from AddTimer.                       */
TIMER_PROC( void, RemoveTimer )( uint32_t timer );
/* Reschedule when a timer can fire. The delay can be 0 to make
   wake the timer.
   Parameters
   timer :  32 bit timer identifier from AddTimer.
   delay :  How long before the timer should run now.<p />If 0,
            will issue timer immediately.<p />If not specified,
            using the macro, the default delay is the timer's
            frequency. (can prevent the timer from firing until
            it's frequency from now.)                           */
TIMER_PROC( void, RescheduleTimerEx )( uint32_t timer, uint32_t delay );
/* <combine sack::timers::RescheduleTimerEx@uint32_t@uint32_t>
   \ \                                               */
TIMER_PROC( void, RescheduleTimer )( uint32_t timer );
/* Changes the frequency of a timer. Reschedule timer only
   changes the next time it fires, this can adjust the
   frequency. The simple ChangeTimer macro is sufficient.
   Parameters
   ID :         32 bit ID of the time created by AddTimer.
   initial :    initial delay of the timer. (Might matter if the
                timer hasn't fired the first time)
   frequency :  new delay between timer callback invokations.    */
TIMER_PROC( void, ChangeTimerEx )( uint32_t ID, uint32_t initial, uint32_t frequency );
/* <combine sack::timers::ChangeTimerEx@uint32_t@uint32_t@uint32_t>
   \ \                                               */
#define ChangeTimer( ID, Freq ) ChangeTimerEx( ID, Freq, Freq )
/* This is the type returned by MakeThread, and passed to
   ThreadTo. This is a private structure, and no definition is
   publicly available, this should be treated like a handle.   */
typedef struct threads_tag *PTHREAD;
/* Function signature for a thread entry point passed to
   ThreadTo.                                             */
typedef uintptr_t (CPROC*ThreadStartProc)( PTHREAD );
/* Function signature for a thread entry point passed to
   ThreadToSimple.                                             */
typedef uintptr_t (*ThreadSimpleStartProc)( POINTER );
/*
  OnThreadCreate allows registering a procedure to run
  when a thread is created.  (Or an existing thread becomes
  tracked within this library, via MakeThread() ).
  It is called once per thread, for each thread created
  after registering the callback.
*/
TIMER_PROC( void, OnThreadCreate )( void ( *v )( void ) );
/* Create a separate thread that starts in the routine
   specified. The uintptr_t value (something that might be a
   pointer), is passed in the PTHREAD structure. (See
   GetThreadParam)
   Parameters
   proc :       starting routine for the thread
   user_data :  some value that can be stored in the number of
                bits that a pointer is. This is passed to the
                proc when the thread starts.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( PTHREAD, ThreadToEx )( ThreadStartProc proc, uintptr_t param DBG_PASS );
/* <combine sack::timers::ThreadToEx@ThreadStartProc@uintptr_t param>
   \ \                                                               */
#define ThreadTo(proc,param) ThreadToEx( proc,param DBG_SRC )
/* Create a separate thread that starts in the routine
   specified. The uintptr_t value (something that might be a
   pointer), is passed in the PTHREAD structure. (See
   GetThreadParam)
   Parameters
   proc :       starting routine for the thread
   user_data :  some value that can be stored in the number of
                bits that a pointer is. This is passed to the
                proc when the thread starts.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( PTHREAD, ThreadToSimpleEx )( ThreadSimpleStartProc proc, POINTER param DBG_PASS );
/* <combine sack::timers::ThreadToEx@ThreadStartProc@uintptr_t param>
   \ \                                                               */
#define ThreadToSimple(proc,param) ThreadToSimpleEx( proc,param DBG_SRC )
/* \Returns a PTHREAD that represents the current thread. This
   can be used to create a PTHREAD identifier for the main
   thread.
   Parameters
   None.
   Returns
   a pointer to a thread structure that identifies the current
   thread. If this thread already has this structure created,
   the same one results on subsequent MakeThread calls.        */
TIMER_PROC( PTHREAD, MakeThread )( void );
/* This returns the parameter passed as user data to ThreadTo.
   Parameters
   thread :  thread to get the parameter from.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( uintptr_t, GetThreadParam )( PTHREAD thread );
/* \returns the numeric THREAD_ID from a PTHREAD.
   Parameters
   thread :  thread to get the system wide unique ID of. */
TIMER_PROC( THREAD_ID, GetThreadID )( PTHREAD thread );
/* \returns the numeric THREAD_ID from a PTHREAD.
   Parameters
   thread :  thread to get the system wide unique ID of. */
TIMER_PROC( THREAD_ID, GetThisThreadID )( void );
/* Symbol defined to pass to Wakeable_Sleep to sleep until
   someone calls WakeThread.                               */
#define SLEEP_FOREVER 0xFFFFFFFF
/* Sleeps a number of milliseconds or until the thread is passed
   to WakeThread.
   Parameters
   dwMilliseconds :  How long to sleep. Can be indefinite if
                     value is SLEEP_FOREVER.
   Example
   <code lang="c++">
   PTHREAD main_thread;
   uintptr_t CPROC WakeMeThread( PTHREAD thread )
   {
      // get the value passed to ThreadTo as user_data.
      uintptr_t user_data = GetThreadParam( thread );
      // let the main thread sleep a little wile
       WakeableSleep( 250 );
      // then wake it up
       WakeThread( main_thread );
       return 0;
   }
   int main( void )
   {
       // save my PTHREAD globally.
       main_thread = MakeThread();
       // create a thread that can wake us
       ThreadTo( WakeMeThread, 0 );
       // demonstrate sleeping
       WakableSleep( SLEEP_FOREVER );
       return 0;
   }
   </code>                                                       */
TIMER_PROC( void, WakeableSleepEx )( uint32_t milliseconds DBG_PASS );
TIMER_PROC( void, WakeableSleep )( uint32_t milliseconds );
TIMER_PROC( void, WakeableNamedSleepEx )( CTEXTSTR name, uint32_t n DBG_PASS );
#define WakeableNamedSleep( name, n )   WakeableNamedSleepEx( name, n DBG_SRC )
TIMER_PROC( void, WakeNamedSleeperEx )( CTEXTSTR name DBG_PASS );
#define WakeNamedSleeper( name )   WakeNamedSleeperEx( name DBG_SRC )
TIMER_PROC( void, WakeableNamedThreadSleepEx )( CTEXTSTR name, uint32_t n DBG_PASS );
#define WakeableNamedThreadSleep( name, n )   WakeableNamedThreadSleepEx( name, n DBG_SRC )
TIMER_PROC( void, WakeNamedThreadSleeperEx )( CTEXTSTR name, THREAD_ID therad DBG_PASS );
#define WakeNamedThreadSleeper( name, thread )   WakeNamedThreadSleeperEx( name, thread DBG_SRC )
#ifdef USE_PIPE_SEMS
TIMER_PROC( int, GetThreadSleeper )( PTHREAD thread );
#endif
/* <combine sack::timers::WakeableSleepEx@uint32_t milliseconds>
   \ \                                                      */
#define WakeableSleep(n) WakeableSleepEx(n DBG_SRC )
/* Wake a thread by ID, if the pThread is not available. Can be
   used cross-process for instance. Although someone could add a
   method to provide a PTHREAD wrapper around THREAD_ID for
   threads in remote processes, this may not be a best practice.
   Parameters
   thread_id :  THREAD_ID from GetMyThreadID, which is a macro
                appropriate for a platform.                      */
TIMER_PROC( void, WakeThreadIDEx )( THREAD_ID thread DBG_PASS );
/* Wake a thread.
   Example
   See WakeableSleepEx.
   Parameters
   pThread :  thread to wake up from a WakeableSleep. */
TIMER_PROC( void, WakeThreadEx )( PTHREAD thread DBG_PASS );
/* <combine sack::timers::WakeThreadIDEx@THREAD_ID thread>
   \ \                                                     */
#define WakeThreadID(thread) WakeThreadIDEx( thread DBG_SRC )
/* <combine sack::timers::WakeThreadEx@PTHREAD thread>
   \ \                                                 */
#define WakeThread(t) WakeThreadEx(t DBG_SRC )
/* This can be checked to see if the THREAD_ID to wake still has
   an event. Sometimes threads end.
   Parameters
   thread :  thread identifier to check to see if it exists/can be
             woken.
   Returns
   TRUE if the thread can be signaled to wake up.
   FALSE if the thread cannot be found or cannot be woken up.      */
TIMER_PROC( int, TestWakeThreadID )( THREAD_ID thread );
/* This can be checked to see if the PTHREAD to wake still has
   an event. Sometimes threads call UnmakeThread(). This is a
   more practical test using a THREAD_ID instead. See
   TestWakeThreadID.
   Returns
   TRUE if the thread can be signaled to wake up.
   FALSE if the thread cannot be found or cannot be woken up.  */
TIMER_PROC( int, TestWakeThread )( PTHREAD thread );
//TIMER_PROC( void, WakeThread )( PTHREAD thread );
TIMER_PROC( void, EndThread )( PTHREAD thread );
/* This tests to see if a pointer to a thread references the
   current thread.
   Parameters
   thread :  thread to check to see if it is the current thread.
   Returns
   TRUE if this thread is the same as the PTHREAD passed.
   otherwise FALSE.
   Example
   <code lang="c++">
   PTHREAD main_thread;
   LOGICAL thread_finished_check;
   uintptr_t CPROC ThreadProc( PTHREAD thread )
   {
       if( IsThisThread( main_thread ) )
            printf( "This thread is not the main thread.\\n" );
       else
            printf( "This is the main thread - cannot happen :)\\n" );
   </code>
   <code>
       // mark that this thread is complete
       thread_finished_check = TRUE;
   </code>
   <code lang="c++">
       // hmm - for some reason, just pass the uintptr_t that was passed to ThreadTo as the result.
       return GetThreadParam( thread );
   }
   int main( void )
   {
        main_thread = MakeThread();
        ThreadTo( ThreadProc, 0 );
        // wait for the thread to finish its thread identity check.
        while( !thread_finished_check )
            Relinquish();
        return 0;
   }
   </code>                                                                                         */
TIMER_PROC( int, IsThisThreadEx )( PTHREAD pThreadTest DBG_PASS );
/* <combine sack::timers::IsThisThreadEx@PTHREAD pThreadTest>
   \ \                                                        */
#define IsThisThread(thread) IsThisThreadEx(thread DBG_SRC)
/* Enter a critical section. Only a single thread may be in a
   critical section, if a second thread attempts to enter the
   section while another thread is in it will block until the
   original thread leaves the section. The same thread may enter
   a critical section multiple times. For each time a critical
   section is entered, the thread must also leave the critical
   section (See LeaveCriticalSection).
   Parameters
   pcs :  pointer to a critical section to enter                 */
TIMER_PROC( LOGICAL, EnterCriticalSecEx )( PCRITICALSECTION pcs DBG_PASS );
/* Leaves a critical section. See EnterCriticalSecEx.
   Parameters
   pcs :  pointer to a critical section.              */
TIMER_PROC( LOGICAL, LeaveCriticalSecEx )( PCRITICALSECTION pcs DBG_PASS );
/* Does nothing. There are no extra resources required for
   critical sections, and the memory is allocated by the
   application.
   Parameters
   pcs :  pointer to critical section to do nothing with.  */
TIMER_PROC( void, DeleteCriticalSec )( PCRITICALSECTION pcs );
#ifdef _WIN32
	TIMER_PROC( HANDLE, GetWakeEvent )( void );
	TIMER_PROC( HANDLE, GetThreadHandle )( PTHREAD thread );
#endif
#ifdef __LINUX__
	TIMER_PROC( pthread_t, GetThreadHandle )(PTHREAD thread);
#endif
#ifdef USE_NATIVE_CRITICAL_SECTION
#define EnterCriticalSec(pcs) EnterCriticalSection( pcs )
#define LeaveCriticalSec(pcs) LeaveCriticalSection( pcs )
#else
/* <combine sack::timers::EnterCriticalSecEx@PCRITICALSECTION pcs>
   \ \                                                             */
#define EnterCriticalSec( pcs ) EnterCriticalSecEx( (pcs) DBG_SRC )
/* <combine sack::timers::LeaveCriticalSecEx@PCRITICALSECTION pcs>
   \ \                                                             */
#define LeaveCriticalSec( pcs ) LeaveCriticalSecEx( (pcs) DBG_SRC )
#endif
TIMER_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::timers;
#endif
#endif
// $Log: timers.h,v $
// Revision 1.37  2005/05/16 19:06:58  jim
// Extend wakeable sleep to know the originator of the sleep.
//
// Revision 1.36  2004/09/29 16:42:51  d3x0r
// fixed queues a bit - added a test wait function for timers/threads
//
// Revision 1.35  2004/07/07 15:33:54  d3x0r
// Cleaned c++ warnings, bad headers, fixed make system, fixed reallocate...
//
// Revision 1.34  2004/05/02 02:04:16  d3x0r
// Begin border exclusive option, define PushMethod explicitly, fix LaunchProgram in timers.h
//
// Revision 1.33  2003/12/10 15:38:25  panther
// Move Sleep and GetTickCount to real code
//
// Revision 1.32  2003/11/02 00:31:47  panther
// Added debuginfo pass to wakethread
//
// Revision 1.31  2003/10/24 14:59:21  panther
// Added Load/Unload Function for system shared library abstraction
//
// Revision 1.30  2003/10/17 00:56:04  panther
// Rework critical sections.
// Moved most of heart of these sections to timers.
// When waiting, sleep forever is used, waking only when
// released... This is preferred rather than continuous
// polling of section with a Relinquish.
// Things to test, event wakeup order uner linxu and windows.
// Even see if the wake ever happens.
// Wake should be able to occur across processes.
// Also begin implmeenting MessageQueue in containers....
// These work out of a common shared memory so multiple
// processes have access to this region.
//
// Revision 1.29  2003/09/21 04:03:30  panther
// Build thread ID with pthread_self and getgid
//
// Revision 1.28  2003/07/29 10:41:25  panther
// Predefine struct threads_tag to avoid warning
//
// Revision 1.27  2003/07/24 22:49:20  panther
// Define callback procs as CDECL
//
// Revision 1.26  2003/07/24 16:56:41  panther
// Updates to expliclity define C procedure model for callbacks and assembly modules - incomplete
//
// Revision 1.25  2003/07/22 15:33:19  panther
// Added comment about idle()
//
// Revision 1.24  2003/04/03 10:10:20  panther
// Add file/line debugging to addtimer
//
// Revision 1.23  2003/03/27 13:47:14  panther
// Immplement a EndThread
//
// Revision 1.22  2003/03/25 08:38:11  panther
// Add logging
//
#ifndef MAXPATH
// windef.h has MAX_PATH
#  define MAXPATH MAX_PATH
#  if (!MAXPATH)
#    undef MAXPATH
#    define MAXPATH 256
#  endif
#endif
#ifndef PATH_MAX
// sometimes PATH_MAX is what's used, well it's should be MAXPATH which is MAX_PATH
# define PATH_MAX MAXPATH
#endif
#ifdef _WIN32
#  ifdef CONSOLE_SHELL
 // in order to get wide characters from the commandline we have to use the GetCommandLineW function, convert it to utf8 for internal usage.
#    define SaneWinMain(a,b) int main( int a, char **argv_real ) { char *tmp; TEXTCHAR **b; ParseIntoArgs( tmp = WcharConvert( GetCommandLineW() ), &a, &b ); Deallocate( char*, tmp ); {
#    define EndSaneWinMain() } }
#  else
#    define SaneWinMain(a,b) int APIENTRY WinMain( HINSTANCE hInst, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow ) { int a; char *tmp; TEXTCHAR **b; ParseIntoArgs( tmp = WcharConvert( GetCommandLineW() ), &a, &b ); {
#    define EndSaneWinMain() } }
#  endif
#else
#  if defined( __ANDROID__ ) && !defined( ANDROID_CONSOLE_UTIL )
#    define SaneWinMain(a,b) int SACK_Main( int a, char **b )
#    define EndSaneWinMain()
#  else
#    define SaneWinMain(a,b) int main( int a, char **b ) { char **argv_real = b; {
#    define EndSaneWinMain() } }
#  endif
#endif
//  these are rude defines overloading otherwise very practical types
// but - they have to be dispatched after all standard headers.
#ifndef FINAL_TYPES
#define FINAL_TYPES
#  ifdef __WATCOMC__
 //__WATCOMC__
#  endif
#  ifdef _WIN32
#    include <basetsd.h>
  // this redefines lprintf sprintf etc... and strsafe is preferred
 // more things that need override by strsafe.h
#    include <tchar.h>
 // added for mingw64 actually
#    ifdef __GNUC__
#      undef __CRT__NO_INLINE
#    endif
#    ifndef MINGW_SUX
#      include <strsafe.h>
#    else
#      define STRSAFE_E_INSUFFICIENT_BUFFER  0x8007007AL
#    endif
#  else
#  endif
// may consider changing this to uint16_t* for unicode...
#ifdef UNICODE
#  ifndef NO_UNICODE_C
#    define strrchr          wcsrchr
#    define strchr           wcschr
#    define strncpy          wcsncpy
#    ifdef strcpy
#      undef strcpy
#    endif
#    define strcpy           wcscpy
#    define strcmp           wcscmp
#    ifndef __LINUX__
// linux also translates 'i' to 'case' in sack_typelib.h
#      define stricmp          wcsicmp
#      define strnicmp         wcsnicmp
//#  define strlen           mbrlen
#    endif
#    define strlen           wcslen
#    ifdef WIN32
#      define stat(a,b)        _wstat(a,b)
#    else
#    endif
#    define printf           wprintf
#    define fprintf          fwprintf
#    define fputs            fputws
#    define fgets            fgetws
#    define atoi             _wtoi
#    ifdef __WATCOMC__
#      undef atof
#    endif
//#    define atof             _wtof
#    ifdef _MSC_VER
#      ifndef __cplusplus_cli
#        define fprintf   fwprintf
#        define atoi      _wtoi
// define sprintf here.
#      endif
#    endif
#    if defined( _ARM_ ) && defined( WIN32 )
// len should be passed as character count. this was the wrongw ay to default this.
#      define snprintf StringCbPrintf
//#define snprintf StringCbPrintf
#    endif
#  else
//#    define atoi             wtoi
#  endif
 // not unicode...
#else
#endif
#  ifdef _MSC_VER
#    define snprintf _snprintf
#    define vsnprintf _vsnprintf
#    if defined( _UNICODE )
#      define tnprintf _snwprintf
#      define vtnprintf _vsnwprintf
#    else
#      define tnprintf _snprintf
#      define vtnprintf _vsnprintf
#    endif
#    define snwprintf _snwprintf
#    if defined( _UNICODE ) && !defined( NO_UNICODE_C )
#    define tscanf swscanf_s
#    else
#    define tscanf sscanf_s
#    endif
#    define scanf sscanf_s
#    define swcanf swscanf_s
 // _MSC_VER
#  endif
#  ifdef  __GNUC__
#      if defined( _UNICODE )
#        define VSNPRINTF_FAILS_RETURN_SIZE
#        define tnprintf  swprintf
#        define vtnprintf vswprintf
#        if !defined( NO_UNICODE_C )
#           define snprintf   swprintf
#           define vsnprintf  vswprintf
//#           define sscanf     swscanf
#        else
#        endif
#      else
#        define tnprintf snprintf
#        define vtnprintf vsnprintf
//#        define snprintf snprintf
//#        define vsnprintf vsnprintf
#    if defined( _UNICODE ) && !defined( NO_UNICODE_C )
#    define tscanf swscanf
#    else
#    define tscanf sscanf
#    endif
#      endif
 // __GNUC__
#  endif
#  ifdef __WATCOMC__
#      if defined( _UNICODE )
#        define tnprintf  _snwprintf
#        define vtnprintf _vsnwprintf
#        if !defined( NO_UNICODE_C )
#           define snprintf  _snwprintf
#           define vsnprintf _vsnwprintf
#           define sscanf     swscanf
#        else
#        endif
#      else
#         define tnprintf  snprintf
#         define vtnprintf vsnprintf
//#        define snprintf snprintf
//#        define vsnprintf vsnprintf
#      endif
#        define snwprintf  _snwprintf
 // __WATCOMC__
#  endif
#endif
#endif
#ifndef SQL_OPTIONS_DEFINED
#define SQL_OPTIONS_DEFINED
/* more documentation at end */
/*
 *
 *   Creator: Panther   #implemented in Dekware
 *   Modified by: Jim Buckeyne #ported to service SQL via proxy.
 *   Returned to sack by: Jim Buckeyne
 *                  # stripped application specific
 *                  # features, returned to SACK.
 *
 *  Provides a simple, intuitive interface to SQL.  Used sensibly,
 *  provides garbage collection of resources.
 *
 *  Commands without an ODBC specifier are the perferred method to
 *  use this interface.  This allows the internal system to maintain
 *  a primary and a redundant backup connection to provide transparent
 *  reliability to the application.
 *
 *  Provides some slick table creation routines
 *     - check for existance, and drop  (CTO_DROP)
 *     - check for existance, and match (CTO_MATCH)
 *     - check for existance, and merge (CTO_MERGE)
 *     - create table if not exist.
 *
 *  Latest additions provide ...RecordQuery... functions which
 *  result with a const CTEXTSTR * of results;  (ie, result[0] = (CTEXTSTR)result1 )
 *  also available are the column names from the query.
 *  I strongly recommend passing NULL always to the field names, and
 *  using sensible enumerators that follow the query definition.
 *
 *  (c)Freedom Collective (Jim Buckeyne 2000-2016)
 *
 */
#ifndef PSSQL_STUB_DEFINED
/* multiple inclusion protection symbol */
#define PSSQL_STUB_DEFINED
#if defined( SQLSTUB_SOURCE ) || defined( SQLPROXY_LIBRARY_SOURCE )
#define PSSQL_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define PSSQL_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
#define _SQL_NAMESPACE   namespace sql {
#define _SQL_NAMESPACE_END   }
#define SQL_NAMESPACE   namespace sack { namespace sql {
#define SQL_NAMESPACE_END } }
#else
#define _SQL_NAMESPACE
#define _SQL_NAMESPACE_END
#define SQL_NAMESPACE
#define SQL_NAMESPACE_END
#endif
SACK_NAMESPACE
/* SQL access library. This provides a simple access to ODBC
   connections, and to sqlite. If no database is specified,
   there is an internal database that can be used. These methods
   on the PODBC connection are NOT thread safe. Multiple threads
   shall never use the same PODBC; they can use seperate PODBC
   connections. Under linux this links to unixODBC.
   DoSQLCommandf
   DoSQLRecordQueryf
   GetSQLRecord
   ConnectToDatabase
   DoSQLCommandf
   DoSQLRecordQueryf
   FetchSQLRecord
   There is a configuration file for the default SQL connection,
   this is kept in a file 'sql.config' which is processed with
   ProcessConfigurationFile(); If this file does not exist, it
   will be automatically created with default values.
   (Need to describe this sql.config file)                       */
_SQL_NAMESPACE
/* <combine PSSQL_PROC>
   \ \                    */
#define SQLPROXY_PROC PSSQL_PROC
/* This is the connection object that provides interface to the
   database. Can be NULL to specify the default connection
   interface. See namespace <link sack::sql, sql>.
   An ODBC connection handles commands as a stack. Each command
   is done as a temporary entry on the stack. A query is done as
   an entry on the stack, but the entry remains on the stack
   until the final result is retrieved or an early PopODBC is
   called.
   The structure of this is such that if a command is slow to a
   database, it would be possible to stack commands that are
   temporary and pending until the database connection is
   restored.
   Example
   <code lang="c++">
   int f( void )
   {
       // results from the query
       CTEXTSTR *results;
       // connect.
       PODBC odbc = ConnectToDatabase( "system_dsn_name" );
       // do a command, does a temporary entry on the stack, unless the database is slow
       SQLCommandf( odbc, "create temporary table my_test_table( ID int, value int )" );
       // start a new entry on the command stack.
       SQLRecordQueryf( odbc, NULL, &amp;results, NULL, "select 1+1" );
       // when this command is done, it is stacked on the query.
       SQLCommandf( odbc, "insert into my_test_table (value) values(%d)", 1234 );
       // at this point there is technically 2 entries on the command stack until the next
       // FetchSQLResult( odbc, &amp;results );
   }
	</code>                                                                                 */
#if !defined( __GNUC__ ) || !defined( SQLSTUB_SOURCE )
   // GCC doesn't identify this as exactly the same declaration
	typedef struct odbc_handle_tag *PODBC;
#endif
typedef struct odbc_handle_tag ODBC;
// recently added {} container braces for structure element
#define FIELDS(n) {( sizeof( n ) / sizeof( FIELD ) ), n}
/* a field definition can be a rename, and contain prior names,
   so that the rename can be tracked and migrated appropraitely.
   Unfortuntaly this sort of operation only affects this code,
   and not all auxiliary code.                                   */
#define MAX_PREVIOUS_FIELD_NAMES 4
/* <combine sack::sql::required_field_tag>
   <code lang="c++">
     FIELD fields[] = { { "ID", "int" }, ... };
   </code>                                            */
typedef struct required_field_tag
{
	/* This is the name of the column described in this table. */
	CTEXTSTR name;
	/* pointer to a string describing the type of this column.  */
	CTEXTSTR type;
	/* extra information about the field... grab all addtional
	   information like 'NOT NULL' "default 'zxa'" to describe a
	   field. Sometimes target databases don't understand extra
	   \parameters, and these can be translated as required or
	   ignored.                                                  */
	CTEXTSTR extra;
	// if you have renamed this column more than 1
	// times - you really need to stop messing around
	// and get a life.
	CTEXTSTR previous_names[MAX_PREVIOUS_FIELD_NAMES];
} FIELD, *PFIELD;
#if !defined( _MSC_VER ) || ( _MSC_VER >= 800 )
/* A macro to append a NULL automatically to a list of strings.
   Example
   <code lang="c++">
   CTEXTSTR strings[] = { KEY_COLUMNS( "one", "two", "three" ) };
   </code>
   strings will be set to 4 elements with the 3 strings listed
   in KEY_COLUMNS plus a NULL string.                             */
#define KEY_COLUMNS(...) { __VA_ARGS__, NULL }
#endif
/* sets the count and the array of a statically declared
   required_table_tag.
   Example
   <code lang="c++">
   </code>
   <code>
   FIELD fields[5];
   DB_KEY_DEF keys[3];
   TABLE table = { "table_name", FIELDS( fields ), TABLE_KEYS( keys ) };
   </code>
   This creates a static table definition with the name
   "table_name" and 5 fields with 3 keys. fields[] = { } is
   usally the declartion. Also DB_KEY_DEF keys[] = { ... }; for
   keys.
                                                                         */
#define TABLE_KEYS(n) {( sizeof( n ) / sizeof( DB_KEY_DEF ) ), n}
/* maximum columns that can be specified for a multicolumn index
   in required_key_def.                                          */
#define MAX_KEY_COLUMNS 8
/* <combine sack::sql::required_key_def>
   \ \                                   */
typedef struct required_key_def  DB_KEY_DEF;
enum uniqueResolutions {
  // no on conflict specification.
	UNIQRES_UNSET = 0,
	UNIQRES_REPLACE,
	UNIQRES_IGNORE,
	UNIQRES_FAIL,
	UNIQRES_ABORT,
	UNIQRES_ROLLBACK
};
/* <combine sack::sql::required_key_def>
   \ \                                   */
typedef struct required_key_def  *PDB_KEY_DEF;
struct required_key_def
{
	/* Flags describing attributes of this key */
	/* <combine sack::sql::required_key_def::flags@1>
	   \ \                                            */
	struct {
		/* this defines the primary key for the table */
		BIT_FIELD bPrimary : 1;
		/* the key is meant to be unique. */
		BIT_FIELD bUnique : 1;
		BIT_FIELD uniqueResolution : 3;
	} flags;
	/* Name of the key column. Can be NULL if primary. */
	CTEXTSTR name;
 // uhm up to 5 colnames...
	CTEXTSTR colnames[MAX_KEY_COLUMNS];
 // if not null, broken structure...
	CTEXTSTR null;
#ifdef __cplusplus
   /* <combine sack::sql::required_key_def>
      This is used when actually building C++ for providing an
      initializer to this structure.                           */
   required_key_def( int bPrimary, int bUnique, CTEXTSTR _name, CTEXTSTR colname1 ) { flags.bPrimary = bPrimary; flags.bUnique = bUnique; name = _name; colnames[0] = colname1; colnames[1] = NULL; }
   /* <combine sack::sql::required_key_def>
      This is used when actually building C++ for providing an
      initializer to this structure.                           */
   required_key_def( int bPrimary, int bUnique, CTEXTSTR _name, CTEXTSTR colname1, CTEXTSTR colname2 ) { flags.bPrimary = bPrimary; flags.bUnique = bUnique; name = _name; colnames[0] = colname1; colnames[1] = colname2; colnames[2] = 0; }
	/* Just another required_key_def constructor. */
	required_key_def( int bPrimary, int bUnique, CTEXTSTR _name, CTEXTSTR colname1, CTEXTSTR colname2, CTEXTSTR colname3 ) { flags.bPrimary = bPrimary; flags.bUnique = bUnique; name = _name; colnames[0] = colname1; colnames[1] = colname2; colnames[2] = colname3; colnames[3] = 0; }
#else
#define required_key_def( a,b,c,...) { {a,b}, c, {__VA_ARGS__} }
#endif
};
 /* Describes a key column of a table.
      <code lang="c++">
      DB_KEY_DEF keys[] = { { "lockey", KEY_COLUMNS("hall_id","charity_id") } };
      </code>                                                                    */
/* <combine sack::sql::required_constraint_def>
   \ \                                   */
typedef struct required_constraint_def  DB_CONSTRAINT_DEF;
/* <combine sack::sql::required_constraint_def>
   \ \                                   */
typedef struct required_constraint_def  *PDB_CONSTRAINT_DEF;
struct required_constraint_def
{
	struct {
		BIT_FIELD cascade_on_delete : 1;
		BIT_FIELD cascade_on_update : 1;
		BIT_FIELD restrict_on_delete : 1;
		BIT_FIELD restrict_on_update : 1;
		BIT_FIELD noaction_on_delete : 1;
		BIT_FIELD noaction_on_update : 1;
		BIT_FIELD setnull_on_delete : 1;
		BIT_FIELD setnull_on_update : 1;
		BIT_FIELD setdefault_on_delete : 1;
		BIT_FIELD setdefault_on_update : 1;
		BIT_FIELD foreign_key : 1;
	} flags;
	CTEXTSTR name;
 // uhm up to 5 colnames...
	CTEXTSTR colnames[MAX_KEY_COLUMNS];
	CTEXTSTR references;
 // uhm up to 5 colnames...
	CTEXTSTR foriegn_colnames[MAX_KEY_COLUMNS];
 // if not null, broken structure...
	CTEXTSTR null;
 // Describes a constraint clause
};
/* Example
   By default, CreateTable( CTEXTSTR tablename, CTEXTSTR
   filename ) which reads a 'create table' statement from a file
   to create a table, this now parses the create table structure
   into an internal structure TABLE which has FIELDs and
   DB_KEY_DEFs. This structure is now passed to CheckODBCTable
   which is able to compare the structure with the table
   definition available from the database via DESCRIBE TABLE,
   and then update the table in the database to match the TABLE
   definition.
   One can use the table structure to define tables instead of
   maintaining external files... and without having to create a
   temporary external file which could then contain a create
   table statement to create the table.
   <code>
   // declare some fields...
   FIELD some_table_field_array_name[] = { { "field one", "int", NULL }
   , { "field two", "varchar(100)", NULL }
   , { "ID field", "int", "auto_increment" }
   , { "some other field", "int", "NOT NULL default '8'" }
   };
   // define some keys...
   DB_KEY_DEF some_table_key_array_name[] = { { .flags = { .bPrimary = 1 }, NULL, {"ID Field"} }
   , { {0}, "namekey", { "field two", NULL } }
   };
   </code>
   // the structure for DB_KEY_DEF takes an array of column
   names used to define the key, there should be a NULL to end
   the list. The value after the array of field names is called
   'null' which should always be set to NULL. If these are
   declared in global data space, then any unset value will be
   initialized to zero.
   <code>
   TABLE some_table_var_name = { "table name", FIELDS( some_table_field_array_name ), TABLE_KEYS( some_table_key_array_name ), 1 );
    LOGICAL CheckODBCTable( PODBC odbc, PTABLE table, uint32_t options )
        PODBC odbc - may be left NULL to use the default database connection.
        PTABLE table - a pointer to a TABLE structure which has been initialized.
        uint32_t options - zero or more of  the following symbols or'ed together.
                   \#define CTO_MATCH 4  // attempt to figure out alter statements to drop or add columns to exact match definition
                   \#define CTO_MERGE 8  // attempt to figure out alter statements to add missing columns, do not drop.  Rename?
   </code>
   Then some routine later
   <code>
   {
      ...
      CheckODBCTable( NULL, &amp;some_table_var_name, CTO_MERGE );
      ..
   }
   </code>
   * ---------------------------------------------------------- *
   alternatively tables may be checked and updated using the
   following code, given an internal constant text string that
   is the create table statement, this may be parsed into a
   PTABLE structure which the resulting table can be used in
   CheckODBCTable();
   <code>
   static CTEXTSTR create_player_info = "CREATE TABLE `players_info` ("
         "  `player_id` int(11) NOT NULL auto_increment,           "
         "  PRIMARY KEY  (`player_id`),                            "
         ")                               ";
   PTABLE table = GetFieldsInSQL( create_player_info, FALSE );
   CheckODBCTable( NULL, table, CTO_MERGE );
   DestroySQLTable( table );
   </code>                                                                                                                          */
struct required_table_tag
{
	/* This is the name of the table. */
	CTEXTSTR name;
	/* describes the columns (fields) in a table. */
	struct pssql_table_fields {
		/* number of fields in the array pointed at by field. */
		int count;
		/* pointer to an array of FIELD. */
		PFIELD field;
	} fields;
	/* Describes the keys on the table.  */
	/* <combine sack::sql::required_table_tag::keys@1>
	   \ \                                             */
	struct pssql_table_key {
		/* number of keys pointed at by key. */
		int count;
      /* pointer to an array of DB_REQ_KEY. */
      PDB_KEY_DEF key;
	} keys;
	struct pssql_table_constraint {
		int count;
		PDB_CONSTRAINT_DEF constraint;
	} constraints;
	/* <combine sack::sql::required_table_tag::flags@1>
	   \ \                                              */
	/* flags controlling the table. */
		struct pssql_table_flags {
         // set this if defined dynamically (from getfields in SQL)
		BIT_FIELD bDynamic : 1;
		/* This is a table that is allocated in memory, static table
		   definitions should leave this 0.                          */
		BIT_FIELD bTemporary : 1;
		/* Issue the create statement always, but include 'if not
		   exists'. Don't try and compare the table structure.    */
		BIT_FIELD bIfNotExist : 1;
	} flags;
   /* name of another table that already exists. Creates this table
      using that table's description.                               */
   CTEXTSTR create_like_table_name;
   /* name of the database that contains this table. */
   CTEXTSTR database;
   /* an additional field that can specify the database storage
      engine to use. (Hmm maybe use this to specify sqlite target?) */
   CTEXTSTR type;
   /* This is an additional field to add as a description to the
      database if supported by the target database.              */
   CTEXTSTR comment;
};
/* <combine sack::sql::required_table_tag>
   \ \                                     */
typedef struct required_table_tag TABLE;
/* <combine sack::sql::required_table_tag>
   \ \                                     */
typedef struct required_table_tag *PTABLE;
/* Checks a table in a database to see if it exists, and that
   all the columns in the table definition passed exist as
   column in the database. Will generate alter statements to the
   table as appropriate.
   Parameters
   odbc :     connection to check the table on
   table :    a table which was created with GetFieldsInSQL, or
              created by filling in a structure.
   options :  Options from CreateTableOptions.                   */
PSSQL_PROC( LOGICAL, CheckODBCTableEx)( PODBC odbc, PTABLE table, uint32_t options DBG_PASS );
/* Checks a table in a database to see if it exists, and that
   all the columns in the table definition passed exist as
   column in the database. Will generate alter statements to the
   table as appropriate.
   Parameters
   odbc :     connection to check the table on
   table :    a table which was created with GetFieldsInSQL, or
              created by filling in a structure.
   options :  Options from CreateTableOptions.                   */
PSSQL_PROC( LOGICAL, CheckODBCTable)( PODBC odbc, PTABLE table, uint32_t options );
/* <combine sack::sql::CheckODBCTableEx@PODBC@PTABLE@uint32_t options>
   \ \                                                            */
#define CheckODBCTable(odbc,t,opt) CheckODBCTableEx(odbc,t,opt DBG_SRC )
/* Enable or disable logging SQL to the sql.log file and to the
   application's log.
   Parameters
   odbc :      connection to disable logging on
   bDisable :  if TRUE disables logging, else restores logging. */
PSSQL_PROC( void, SetSQLLoggingDisable )( PODBC odbc, LOGICAL bDisable );
#ifndef SQLPROXY_INCLUDE
// result is FALSE on error
// result is TRUE on success
PSSQL_PROC( int, DoSQLCommandEx )( CTEXTSTR command DBG_PASS);
#endif
/* <combine sack::sql::DoSQLCommandEx@CTEXTSTR command>
   \ \                                                  */
#define DoSQLCommand(c) DoSQLCommandEx(c DBG_SRC )
/* Generate a commit for any outstanding transactions. Commit
   syntax is variable depending on the connection. Connections
   also have the feature to auto generate begin transaction, and
   flush after a period of idle.
   Parameters
   odbc :  connection to database to commit                      */
PSSQL_PROC( void, SQLCommit )( PODBC odbc );
/* generates the begin transaction for a commection.
   Parameters
   odbc :  connection to database to start a transaction        */
PSSQL_PROC( void, SQLBeginTransact )( PODBC odbc );
// parameters to this are pairs of "name", type, "value"
//  type == 0 - value is text, do not quote
//  type == 1 - value is text, add quotes appropriate for database
//  type == 2 - value is an integer, do not quote
// the last pair's name is NULL, and value does not matter.
// insert values into said table.
PSSQL_PROC( int, DoSQLInsert )( CTEXTSTR table, ... );
#ifndef SQLPROXY_INCLUDE
/* This opens or re-opens a database connection. Mostly an
   \internal function(?)
   Parameters
   odbc :  connection to open.                             */
PSSQL_PROC( int, OpenSQLConnection )( PODBC );
#endif
/* This opens or re-opens a database connection. Mostly an
   \internal function(?)
   Parameters
   odbc :  connection to open.                             */
PSSQL_PROC( int, OpenSQLConnectionEx )( PODBC DBG_PASS );
/* <combine sack::sql::OpenSQLConnectionEx@PODBC>
   \ \                                            */
#define OpenSQLConnect(o) OpenSQLConnectionEx( o DBG_SRC )
// should pass to this a &(CTEXTSTR) which starts as NULL for result.
// result is FALSE on error
// result is TRUE on success, and **result is updated to
// contain the resulting data.
PSSQL_PROC( int, DoSQLQueryEx )( CTEXTSTR query, CTEXTSTR *result DBG_PASS);
/* <combine sack::sql::DoSQLQueryEx@CTEXTSTR@CTEXTSTR *result>
   \ \                                                         */
#define DoSQLQuery(q,r) DoSQLQueryEx( q,r DBG_SRC )
/* <combine sack::sql::DoSQLRecordQueryf@int *@CTEXTSTR **@CTEXTSTR **@CTEXTSTR@...>
   \ \                                                                               */
#define DoSQLRecordQuery(q,r,c,f) SQLRecordQueryEx( NULL,q,r,c,f DBG_SRC )
/* <combine sack::sql::SQLRecordQueryEx@PODBC@CTEXTSTR@int *@CTEXTSTR **@CTEXTSTR **fields>
   \ \                                                                                      */
#define DoSQLQueryRecord(q,r,c)   DoSQLRecordQuery(q,r,c,NULL)
/* <combine sack::sql::SQLRecordQueryEx@PODBC@CTEXTSTR@int *@CTEXTSTR **@CTEXTSTR **fields>
   \ \                                                                                      */
#define SQLQueryRecord(o,q,r,c)   SQLRecordQuery(o,q,r,c,NULL)
/* <combine sack::sql::GetSQLRecord@CTEXTSTR **>
   \ \                                           */
#define GetSQLResultRecord(r,c)   GetSQLRecord(c)
/* <combine sack::sql::FetchSQLResult@PODBC@CTEXTSTR *>
   \ \                                                  */
PSSQL_PROC( int, GetSQLResult )( CTEXTSTR *result );
/* <combine sack::sql::FetchSQLRecord@PODBC@CTEXTSTR **>
   \ \                                                   */
PSSQL_PROC( int, GetSQLRecord )( CTEXTSTR **result );
/* Gets the last result on the default ODBC connection.
   Parameters
   result\ :  address of a string pointer to get set to the error
              string.
   Example
   <code>
   {
      CTEXTSTR error;
      GetSQLError( &amp;error );
      printf( "Error: %s", error );
   }
   </code>                                                        */
PSSQL_PROC( int, GetSQLError )( CTEXTSTR *result );
/* This is a test command that tests to see if the default
   database connection is able to work.                    */
PSSQL_PROC( int, IsSQLReady )( void );
/* <combine sack::sql::PushSQLQueryExEx@PODBC>
   \ \                                         */
PSSQL_PROC( int, PushSQLQuery )( void );
/* <combine sack::sql::PopODBCEx@PODBC>
   \ \                                  */
PSSQL_PROC( void, PopODBC )( void );
#ifndef SQLPROXY_INCLUDE
/* Clear the top non temporary sql statement from the PODBC
   stack.
   Parameters
   odbc :  connection to remove the statement from.
   Remarks
   A SQLCommand is temporary, a SQLQuery or a PushODBC is not. Pop
   MAY be used to clear a query early, but it is recommended to
   read to the end of it instead.                                  */
PSSQL_PROC( void, PopODBCExx )( PODBC, LOGICAL DBG_PASS );
PSSQL_PROC( void, PopODBCEx )( PODBC );
/* <combine sack::sql::PopODBCExx@PODBC@LOGICAL>
   \ \                                           */
#define PopODBCEx(o) PopODBCExx(o,FALSE DBG_SRC)
/* <combine sack::sql::PopODBCEx>
   \ \                            */
#define PopODBC() PopODBCExx(NULL,FALSE DBG_SRC)
#endif
/* This terminates a query on the PODBC stack. (It was mentioned
   in pop odbc that it could be used to terminate a query, but
   that will log that a pop is being done without a push. This
   is the proper way to prematurely end a query.)
   Parameters
   odbc :  connection to end a query on.                         */
PSSQL_PROC( void, SQLEndQuery )( PODBC odbc );
// release any open queries on the database... all result
// sets are now invalid... uhmm what about things like fields?
// could be messy...
PSSQL_PROC( void, ReleaseODBC )( PODBC odbc );
// does a query responce kinda thing returning types.
// if( GetSQLTypes() ) while( GetSQLResult( &result ) && result )
PSSQL_PROC( int, GetSQLTypes )( void );
#ifndef SQLPROXY_INCLUDE
/* parse the string passed as a date/time as returned from a
   MySQL database.
   Parameters
   date :    string to parse
   year :    pointer to an int that will receive the year portion
             of the date
   month :   pointer to an int that will receive the month
             portion of the date
   day :     pointer to an int that will receive the day portion
             of the date
   hour :    pointer to an int that will receive the hours
             portion of the date
   minute :  pointer to an int that will receive the minutes
             portion of the date
   second :  pointer to an int that will receive the second
             portion of the date
   msec :    pointer to an int that will receive the milli\-second
             portion of the date
   nsec :    pointer to an int that will receive the nano second portion
             of the date                                                 */
PSSQL_PROC( void, ConvertSQLDateEx )( CTEXTSTR date
												  , int *year, int *month, int *day
												  , int *hour, int *minute, int *second
												  , int *msec, int32_t *nsec
												  , int *zone_hr, int *zone_mn
												  );
#endif
/* <combine sack::sql::ConvertSQLDateEx@CTEXTSTR@int *@int *@int *@int *@int *@int *@int *@int32_t *>
   \ \                                                                                             */
#define ConvertSQLDate( date, y,m,d) ConvertSQLDateEx( date,y,m,d,NULL,NULL,NULL,NULL,NULL)
/* <combine sack::sql::ConvertSQLDateEx@CTEXTSTR@int *@int *@int *@int *@int *@int *@int *@int32_t *>
   \ \                                                                                             */
#define ConvertSQLDateTime( date, y,mo,d,h,mn,s) ConvertSQLDateEx( date,y,mo,d,h,mn,s,NULL,NULL)
//------------------------------
// this set of functions will auto create a suitable name table
// providing table_name_id and table_name_name as the columns to query by standard
// previous defaults where "id" and "name" which results in inability to use natural join
//
PSSQL_PROC( INDEX, FetchSQLNameID )( PODBC odbc, CTEXTSTR table_name, CTEXTSTR name );
/* A specialized function which takes a name, looks in a SQL
   table on the default database connection for in column
   'name', and returns the value in the 'ID' column. This
   function may create a table with the required fields. This
   table is very bad, if you have 3 tables all with the same
   'name' column reverse engineering and natural join clauses
   fail.
   Parameters
   table_name :  name of the table to get the name's ID from.
   name :        name to lookup its ID for.
   Returns
   the ID of the name or INVALID_INDEX if not found.          */
PSSQL_PROC( INDEX, GetSQLNameID )( CTEXTSTR table_name, CTEXTSTR name );
/* Still a bad function to use.... just don't.
   Parameters
   odbc :        _nt_
   table_name :  _nt_
   iName :       _nt_                          */
PSSQL_PROC( CTEXTSTR, FetchSQLName )( PODBC odbc, CTEXTSTR table_name, INDEX iName );
/* A specialized function which takes an ID, looks in a SQL
   table on the default database connection for in column 'ID',
   and returns the value in the 'name' column. This function may
   create a table with the required fields. This table is very
   bad, if you have 3 tables all with the same 'name' column
   reverse engineering and natural join clauses fail.
   Parameters
   table_name :  name of the database table to read from
   iName :       ID of the name to get                           */
PSSQL_PROC( CTEXTSTR, GetSQLName )( CTEXTSTR table_name, INDEX iName );
/* <combine sack::sql::SQLReadNameTableExEx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \
   Note
   If database connection is not specified or is NULL, uses the
   default SQL connection.                                                                         */
PSSQL_PROC( INDEX, ReadNameTableExEx)( CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS );
/* <combine sack::sql::ReadNameTableExEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                    */
#define ReadNameTableExx( name,table,col,namecol,bCreate) ReadNameTableExEx( name,table,col,namecol,bCreate DBG_SRC )
//column name if NOT specified will be 'ID'
PSSQL_PROC( INDEX, ReadNameTableEx)( CTEXTSTR name, CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::ReadNameTableExEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                    */
#define ReadNameTable(n,t,c) ReadNameTableExEx( n,t,c, "name",TRUE DBG_SRC )
/* <combine sack::sql::ReadFromNameTableExEx@INDEX@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR *result>
   \ \                                                                                          */
PSSQL_PROC( int, ReadFromNameTableEx )( INDEX id, CTEXTSTR table, CTEXTSTR id_colname, CTEXTSTR name_colname, CTEXTSTR *result DBG_PASS);
/* TRUE if name in result... again if !colname colname = 'ID'
   Parameters
   odbc :       connection to use
   id :         ID of the name to read
   table :      table to read from
   id_column :  name of the column that contains the ID
   colname :    name of the column that is where the name is
   result\ :    pointer to a CTEXTSTR which will be filled with
                the name in the table                           */
PSSQL_PROC( int, ReadFromNameTableExEx )( INDEX id, CTEXTSTR table, CTEXTSTR id_column, CTEXTSTR colname, CTEXTSTR *result DBG_PASS);
/* <combine sack::sql::ReadFromNameTableExEx@INDEX@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR *result>
   \ \                                                                                          */
#define ReadFromNameTableExx(id,t,ic,nc,r) ReadFromNameTableExEx(id,t,ic,nc,r DBG_SRC )
/* <combine sack::sql::ReadFromNameTableEx@INDEX@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR *result>
   \ \                                                                                        */
#define ReadFromNameTable(id,t,c,r) ReadFromNameTableEx(id,t,c,"name",r DBG_SRC )
/* This is a better name resolution function. It will also
   create a table that contains the required columns, but the
   column names may be more intelligent than 'ID' and 'name'.
   Parameters
   odbc :     database connection to read from
   name :     the name to lookup the ID for
   table :    table the name column is in
   col :      name of the key column(s) to read.
   namecol :  name of column containing the name to lookup.
   bCreate :  if TRUE, will insert the name into the table, and
              return the resulting columns.                     */
PSSQL_PROC( TEXTSTR, SQLReadNameTableKeyExEx)( PODBC odbc, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS );
/* This is a better name resolution function. It will also
   create a table that contains the required columns, but the
   column names may be more intelligent than 'ID' and 'name'.
   Parameters
   odbc :     database connection to read from
   name :     the name to lookup the ID for
   table :    table the name column is in
   col :      name of the key column(s) to read.
   namecol :  name of column containing the name to lookup.
   bCreate :  if TRUE, will insert the name into the table, and
              return the resulting columns.                     */
PSSQL_PROC( INDEX, SQLReadNameTableExEx)( PODBC odbc, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS );
/* <combine sack::sql::SQLReadNameTableExEx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                             */
#define SQLReadNameTableExx( odbc,name,table,col,namecol,bCreate) SQLReadNameTableExEx( odbc,name,table,col,namecol,bCreate DBG_SRC )
/* <combine sack::sql::SQLReadNameTableExEx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                             */
#define SQLReadNameTable(o,n,t,c) SQLReadNameTableExEx( o,n,t,c,"name",TRUE DBG_SRC )
/* Reads a table that's assumed to be a primary key ID and a
   name sort of dictionary table. This also maintains an
   \internal cache of names queried, since it is assumed words
   in a dictionary don't move or change.
   Parameters
   odbc :      odbc connection to use
   name :      name to get the index of
   table :     table to get the index from
   col :       column name of the ID columns (macros allow this to
               be defaulted)
   namecol :   column name of the name column (macros allow this to
               be defaulted)
   bCreate :   If the name doesn't exist, setting this to TRUE will
               insert the new name, else return will be
               INVALID_INDEX.
   bQuote :    Indicates if the name should be quoted (else use no
               quotes)
   DBG_PASS :  _nt_                                                 */
PSSQL_PROC( INDEX, GetNameIndexExtended)( PODBC odbc, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate, int bQuote DBG_PASS );
/* <combine sack::sql::GetNameIndexExtended@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int@int bQuote>
   \ \                                                                                                */
PSSQL_PROC( INDEX, GetNameIndexExx)( PODBC odbc, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS );
/* <combine sack::sql::GetNameIndexExx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                        */
#define GetNameIndexEx( odbc,name,table,col,namecol,bCreate) GetNameIndexExx( odbc,name,table,col,namecol,bCreate DBG_SRC )
/* <combine sack::sql::GetNameIndexExx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                        */
#define GetNameIndex(o,n,t,c) GetNameIndexExx( o,n,t,c,"name",TRUE DBG_SRC )
// table and col are not used if a MySQL backend is used...
// they are needed to get the last ID from a postgresql backend.
PSSQL_PROC( INDEX, GetLastInsertIDEx)( CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::GetLastInsertIDEx@CTEXTSTR@CTEXTSTR col>
   \ \                                                          */
#define GetLastInsertID(t,c) GetLastInsertIDEx(t,c DBG_SRC )
/* Gets the ID of the primary key from the prior insert. This
   value can be used in subsequent inserts to relate detail
   records to a master.
   Parameters
   odbc :    database connection
   table :   if NULL, just get's the connection's last insert
             into whatever table. PostgreSQL requires a table
             name and column name to get the last insert for. So,
             proper portability for certain databases may use
             this parameter.
   column :  if NULL, just get's the connection's last insert id
             from the auto increment primary key. PostgreSQL
             requires a table name and column name to get the
             last insert for. So, proper portability for certain
             databases may use this parameter.
   Returns
   a 64 bit row identifier.                                       */
PSSQL_PROC( INDEX, FetchLastInsertIDEx)( PODBC odbc, CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::FetchLastInsertIDEx@PODBC@CTEXTSTR@CTEXTSTR col>
   \ \                                                                  */
#define FetchLastInsertID(o,t,c) FetchLastInsertIDEx(o,t,c DBG_SRC )
/* <combine sack::sql::FetchLastInsertIDEx@PODBC@CTEXTSTR@CTEXTSTR col>
   \ \                                                                  */
#define FetchLastInsertKey(o,t,c) FetchLastInsertKeyEx(o,t,c DBG_SRC )
/* <combine sack::sql::FetchLastInsertIDEx@PODBC@CTEXTSTR@CTEXTSTR col>
   \ \                                                                  */
PSSQL_PROC( CTEXTSTR, FetchLastInsertKeyEx)( PODBC odbc, CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::GetLastInsertIDEx@CTEXTSTR@CTEXTSTR col>
   \ \                                                          */
PSSQL_PROC( CTEXTSTR, GetLastInsertKeyEx)( CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::GetLastInsertIDEx@CTEXTSTR@CTEXTSTR col>
   \ \                                                          */
#define GetLastInsertKey(t,c) GetLastInsertKeyEx(t,c DBG_SRC )
// CreateTable Options (CTO_)
enum CreateTableOptions {
   // drop old table before create.
 CTO_DROP  = 1,
  // attempt to figure out alter statements to drop or add columns to exact match definition
 CTO_MATCH = 4,
  // attempt to figure out alter statements to add missing columns, do not drop.  Rename?
 CTO_MERGE = 8,
 // log changes to "changes.sql"
		CTO_LOG_CHANGES = 16
};
/* \ \
   Parameters
   odbc :          database connection to check table in
   filename :      name of file containing sql CREATE TABLE
                   statements.
   templatename :  name of the table specified by the CREATE
                   TABLE statement.
   tablename :     table name to use when actually creating this.
                   May be different from template table name.
   options :       Options from CreateTableOptions.               */
PSSQL_PROC( int, SQLCreateTableEx )(PODBC odbc, CTEXTSTR filename, CTEXTSTR templatename, CTEXTSTR tablename, uint32_t options );
/* <combine sack::sql::SQLCreateTableEx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@uint32_t>
   \ \                                                                        */
#define SQLCreateTable( odbc, file, table ) SQLCreateTableEx(odbc,file,table,table,0)
/* Creates a table in a database by reading an external file
   containing the table definition. It can also perform
   iterative updates to table structure if the template
   definition adds or deletes columns.
   Parameters
   filename :      filename to read the template from
   templatename :  name of the table in the create table template
                   statement.
   tablename :     the name of the table to create (may be
                   different than template)
   options :       Options from CreateTableOptions.
   Returns
   TRUE if success.
   FALSE if failure. (No further information)                     */
PSSQL_PROC( int, CreateTableEx )( CTEXTSTR filename, CTEXTSTR templatename, CTEXTSTR tablename, uint32_t options );
/* <combine sack::sql::CreateTableEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@uint32_t>
   \ \                                                               */
#define CreateTable( file, table ) CreateTableEx(file,table,table,0)
// results in a static buffer with escapes filled in for characterws
// which would otherwise conflict with string punctuators.
PSSQL_PROC( TEXTSTR ,EscapeStringEx )( CTEXTSTR name DBG_PASS );
/* <combine sack::sql::EscapeStringEx@CTEXTSTR name>
   \ \                                               */
#define EscapeString(s) EscapeStringEx( s DBG_SRC )
/* <combine sack::sql::EscapeStringEx@CTEXTSTR name>
   \ \                                               */
#define EscapeStringOpt(s,q) EscapeSQLBinaryExx( NULL,s,StrLen(s),NULL, q DBG_SRC )
/* \ \
   Parameters
   odbc :  connection to escape the string appropriately for. Different
           database engines require different string escapes.
   name :  string to escape
   Returns
   a TEXTSTR that is the content of the string passed properly
   escaped.
   it is appropriate to Release( result );
   Example
   This is difficult to describe coorectly, since in C, you have
   to do escaping on the parameters anyhow....
   <code lang="c++">
   {
       TEXTSTR result = EscapeSQLString( "\\"test \\'escape\\'" );
       printf( "original : %s\\n"
               "result   : %s\\n"
             , "\\"test \\'escape\\'"
             , \result );
   }
   </code>
   \Output
   <code lang="c++">
   original : "test 'escape'
   \result   : \\"test \\'escape\\'
   </code>                                                              */
PSSQL_PROC( TEXTCHAR *,EscapeSQLStringEx )( PODBC odbc, CTEXTSTR name DBG_PASS );
/* <combine sack::sql::EscapeSQLStringEx@PODBC@CTEXTSTR name>
   \ \                                                        */
#define EscapeSQLString(odbc, s) EscapeSQLStringEx( odbc, s DBG_SRC )
// the following functions return an allcoated buffer which the application must Release()
PSSQL_PROC( TEXTSTR ,EscapeBinaryEx )( CTEXTSTR blob, uintptr_t bloblen DBG_PASS );
/* <combine sack::sql::EscapeBinaryEx@CTEXTSTR@uintptr_t bloblen>
   \ \                                                           */
#define EscapeBinary(b,bl) EscapeBinaryEx(b,bl DBG_SRC )
/* <combine sack::sql::EscapeBinaryEx@CTEXTSTR@uintptr_t bloblen>
   \ \                                                           */
#define EscapeBinaryOpt(b,bl,q) EscapeSQLBinaryExx(NULL,b,bl,NULL,q DBG_SRC )
/* <combine sack::sql::EscapeBinaryEx@CTEXTSTR@uintptr_t bloblen>
   \ \                                                           */
PSSQL_PROC( TEXTSTR,EscapeSQLBinaryExx )( PODBC odbc, CTEXTSTR blob, size_t bloblen, size_t *resultLen, LOGICAL bQuote DBG_PASS );
/* <combine sack::sql::EscapeBinaryEx@CTEXTSTR@uintptr_t bloblen>
   \ \                                                           */
//PSSQL_PROC( TEXTSTR,EscapeSQLBinaryEx )( PODBC odbc, CTEXTSTR blob, uintptr_t bloblen DBG_PASS );
/* <combine sack::sql::EscapeSQLBinaryEx@PODBC@CTEXTSTR@uintptr_t bloblen>
   \ \                                                                    */
#define EscapeSQLBinary(odbc,blob,len) EscapeSQLBinaryExx( odbc,blob,len, NULL, FALSE DBG_SRC )
/* <combine sack::sql::EscapeSQLBinaryEx@PODBC@CTEXTSTR@uintptr_t bloblen>
   \ \                                                                    */
#define EscapeSQLBinaryOpt(odbc,blob,len,q) EscapeSQLBinaryExx( odbc,blob,len,NULL,q DBG_SRC )
#define EscapeSQLBinaryLen(odbc,blob,len,resLen,q) EscapeSQLBinaryExx( odbc,blob,len,resLen, q DBG_SRC )
/* Remove escape sequences which are inserted into a text
   string. (for things like quotes and binary characters?)
   Parameters
   name :  string to remove string escapes from
   Returns
   a copy of the string without quotes. This result should be
   freed with Release when user is done with it.              */
PSSQL_PROC( TEXTSTR ,RevertEscapeString )( CTEXTSTR name );
/* Remove escape sequences which are inserted into a binary
   string.
   Parameters
   blob :     pointer to data to remove binary escape sequences
              from
   bloblen :  length of the data block to handle
   Returns
   a pointer to the string without escapes. (Even though it says
   binary, it's still to and from text?) This result should be
   freed with Release when user is done with it.                 */
PSSQL_PROC( TEXTSTR ,RevertEscapeBinary )( CTEXTSTR blob, size_t *bloblen );
/* Parse a Blob string stored as hex... that is text character
   0-9 and A-F.
   Parameters
   blob :    pointer to the string containing the blob string
   buffer :  target buffer for data
   buflen :  length of target buffer                           */
PSSQL_PROC( TEXTSTR , DeblobifyString )( CTEXTSTR blob, TEXTSTR buffer, size_t buflen );
/* parse the string passed as a date/time as returned from a
   MySQL database.
   Parameters
   timestring :     string to parse
   endtimestring :  pointer to a pointer to a string to receive
                    the position of the character after the
                    timestring.
   year :           pointer to an int that will receive the year
                    portion of the date
   month :          pointer to an int that will receive the month
                    portion of the date
   day :            pointer to an int that will receive the day
                    portion of the date
   hour :           pointer to an int that will receive the hours
                    portion of the date
   minute :         pointer to an int that will receive the
                    minutes portion of the date
   second :         pointer to an int that will receive the
                    second portion of the date
   Returns
   A true/false status whether the string passed was a valid
   time string (?).                                               */
PSSQL_PROC( int, ConvertDBTimeString )( CTEXTSTR timestring
                                      , CTEXTSTR *endtimestring
                                      , int *pyr, int *pmo, int *pdy
                                      , int *phr, int *pmn, int *psc );
#ifndef SQLPROXY_INCLUDE
/* Issue a command to a SQL database. Things like Update and
   Insert are commands.
   Parameters
   odbc :     database connection to perform the command on. If
              NULL uses the default global connection.
   command :  text string to send to the database to execute.
   Returns
   TRUE if the statement succeeds.
   FALSE if the statement fails. See FetchSQLError.             */
PSSQL_PROC( int, SQLCommandEx )( PODBC odbc, CTEXTSTR command DBG_PASS);
#endif
PSSQL_PROC( int, SQLCommandExx )(PODBC odbc, CTEXTSTR command, size_t commandLen DBG_PASS);
/* <combine sack::sql::SQLCommandEx@PODBC@CTEXTSTR command>
   \ \                                                      */
#define SQLCommand(o,c) SQLCommandEx(o,c DBG_SRC )
#define SQLCommandLen(o,c,len) SQLCommandExx(o,c,len DBG_SRC )
   /* Begin collecting insert statements for batch output.
   Parameters
   odbc :  database connection to start collecting inserts for */
PSSQL_PROC( int, SQLInsertBegin )( PODBC odbc );
/* Generate a SQL insert statement from a variable parameter
   list.
   Parameters
   odbc :   connection to generate an insert on
   table :  table to insert into
   args :   a list of fields.
   Remarks
   args each column is a set of 3 parameters; the first
   parameter is the name of the column to insert into, the
   second is a value 0 or 1 whether to quote the value or not,
   and a string pointer.
   Inserts may be batched together and flushed as a whole to the
   database connection.                                          */
PSSQL_PROC( int, vSQLInsert )( PODBC odbc, CTEXTSTR table, va_list args );
/* Generate an insert to the database. Inserts to a single table
   can be cached internally and flushed.
   Parameters
   odbc :   database connection to use
   table :  name of table to insert into
   ... :    sets of column paramters.                            */
PSSQL_PROC( int, SQLInsert )( PODBC odbc, CTEXTSTR table, ... );
PSSQL_PROC( int, DoSQLInsert )( CTEXTSTR table, ... );
/* Flushes all cached inserts collected on a database
   connection.
   Parameters
   odbc :  database connection to flush inserts       */
PSSQL_PROC( int, SQLInsertFlush )( PODBC odbc );
/* This was the original implementation, it returned the results
   as a comma separated list, with quotes around results that
   had commas in them, and quotes around empty strings to
   distinguish NULL result which is just ',,'.
   Parameters
   odbc :     database connection to do the query
   query :    the string query to do
   result\ :  address of a CTEXTSTR to get a comma seperated
              \result of the query in.
   Returns
   TRUE if the query succeeded
   FALSE if the query was in error. See FetchSQLError.
   Example
   <code lang="c++">
   PODBC odbc = NULL; // just use the default connection...
   CTEXTSTR result;
   DoSQLQuery( odbc, "select 1,2,3", &amp;result );
   printf( "result : %s" );
   </code>
   \Output
   <code lang="c++">
   \result : 1,2,3
   </code>
   See Also
   SQLRecordQuery                                                */
PSSQL_PROC( int, SQLQueryEx )( PODBC odbc, CTEXTSTR query, CTEXTSTR *result DBG_PASS);
/* <combine sack::sql::SQLQueryEx@PODBC@CTEXTSTR@CTEXTSTR *result>
   \ \                                                             */
#define SQLQuery(o,q,r) SQLQueryEx( o,q,r DBG_SRC )
/* <combine sack::sql::DoSQLRecordQueryf@int *@CTEXTSTR **@CTEXTSTR **@CTEXTSTR@...>
   \ \                                                                               */
PSSQL_PROC( int, SQLRecordQueryEx )( PODBC odbc
                                   , CTEXTSTR query
                                   , int *pnResult
                                   , CTEXTSTR **result
                                   , CTEXTSTR **fields DBG_PASS);
/* Do a SQL query on the default odbc connection. The first
   record results immediately if there are any records. Returns
   the results as an array of strings. If you know the select
   you are using .... "select a,b,c from xyz" then you know that
   this will have 3 columns resulting.
   Parameters
   odbc :     connection to do the query on.
   query :    query to execute.
   queryLength : actual length of the query (allows embedded NUL characters)
   PDATALIST* :  pointer to datalist pointer which will contain struct jsox_value_container.
			 for each result in this list until VALUE_UNDEFINED is used.
		.name is the field name (constant)
		.string is the text, value_type is the value type (so numbers can stay numbers)
	pdlParams : parameters to bind to the query.  (struct json_value_container types)
   Example
   See SQLRecordQueryf, but omit the database parameter.         */
PSSQL_PROC( int, SQLRecordQuery_js )( PODBC odbc
	, CTEXTSTR query
	, size_t queryLen
	, PDATALIST *pdlResults
	, PDATALIST pdlParams
	DBG_PASS );
/* Do a SQL query on the default odbc connection. The first
   record results immediately if there are any records. Returns
   the results as an array of strings. If you know the select
   you are using .... "select a,b,c from xyz" then you know that
   this will have 3 columns resulting.
   Parameters
   odbc :     connection to do the query on.
   query :    query to execute.
   queryLength : actual length of the query (allows embedded NUL characters)
   columns :  pointer to an int to receive the number of columns
              in the result. (the user will know this based on
              the query issued usually, so it can be NULL to
              ignore parameter)
   result\ :  pointer to a pointer to strings... see example
   resultLengths : pointer to a size_t* that will contain an array of
              lengths of the result values.
   fields :   address of a pointer to strings which will get the
              field names
   Example
   See SQLRecordQueryf, but omit the database parameter.         */
PSSQL_PROC( int, SQLRecordQuery_v4 )( PODBC odbc
                                   , CTEXTSTR query
                                   , size_t queryLength
                                   , int *pnResult
                                   , CTEXTSTR **result
                                   , size_t **resultLengths
                                   , CTEXTSTR **fields
                                   , PDATALIST pdlParameters
                                   DBG_PASS);
/* <combine sack::sql::SQLRecordQueryEx@PODBC@CTEXTSTR@int *@CTEXTSTR **@CTEXTSTR **fields>
   \ \                                                                                      */
#define SQLRecordQuery(o,q,prn,r,f) SQLRecordQueryEx( o,q,prn,r,f DBG_SRC )
/* <combine sack::sql::SQLRecordQueryExx@PODBC@CTEXTSTR@size_t@int *@CTEXTSTR **@size_t *@CTEXTSTR **fields>
   \ \                                                                                      */
#if defined _DEBUG || defined _DEBUG_INFO
#  define SQLRecordQueryLen(o,q,ql,prn,r,rl,f) SQLRecordQueryExx( o,q,ql,prn,r,rl,f, __FILE__,__LINE__ )
#  define SQLRecordQueryExx(o,q,ql,ppr,res,reslen,fields ,file,line )  SQLRecordQuery_v4(o,q,ql,ppr,res,reslen,fields,NULL ,file,line )
#else
#  define SQLRecordQueryLen(o,q,ql,prn,r,rl,f) SQLRecordQueryExx( o,q,ql,prn,r,rl,f  )
#  define SQLRecordQueryExx(o,q,ql,ppr,res,reslen,fields )  SQLRecordQuery_v4(o,q,ql,ppr,res,reslen,fields,NULL )
#endif
   /* Gets the next result from a query.
   Parameters
   odbc :     database connection that the query was executed on
   result\ :  address of the result variable.
   Example
   See SQLRecordQueryf.                                          */
PSSQL_PROC( int, FetchSQLResult )( PODBC, CTEXTSTR *result );
/* Gets the next record result from the connection.
   Parameters
   odbc :     connection to get the result from; if NULL, uses
              \internal static connection.
   result\ :  address of a CTEXTSTR *; to set to an array of
              CTEXTSTR results.
   Remarks
   Values received are invalid after the next FetchSQLRecord or
   possibly other query.                                        */
PSSQL_PROC( int, FetchSQLRecord )( PODBC, CTEXTSTR **result );
/* Gets the next record result from the connection.
   Parameters
   odbc :     connection to get the result from; if NULL, uses
			  \internal static connection.
   result\ :  (unchanged; is same list as original)
   Remarks
   Values received are invalid after the next FetchSQLRecord or
   possibly other query.                                        */
PSSQL_PROC( int, FetchSQLRecordJS )(PODBC odbc, PDATALIST *ppdlRecord);
/* Gets the last result on the specified ODBC connection.
   Parameters
   odbc :     connection to get the last error of
   result\ :  address of a string pointer to receive the error
              \result.
   Example
   <code lang="c++">
   {
      CTEXTSTR error;
      FetchSQLError( NULL, &amp;error );
   </code>
   <code>
      printf( "Error: %s", error );
   </code>
   <code lang="c++">
   }
   </code>                                                     */
PSSQL_PROC( int, FetchSQLError )( PODBC, CTEXTSTR *result );
#ifndef SQLPROXY_INCLUDE
/* Test if a database connection is open
   Parameters
   odbc :  database connection to check
   Returns
   TRUE if the connection is open and works.
   FALSE if the connection would not work because it is not
   connected.                                               */
PSSQL_PROC( int, IsSQLOpenEx )( PODBC DBG_PASS );
/* Test if a database connection is open
   Parameters
   odbc :  database connection to check
   Returns
   TRUE if the connection is open and works.
   FALSE if the connection would not work because it is not
   connected.                                               */
PSSQL_PROC( int, IsSQLOpen )( PODBC );
/* <combine sack::sql::IsSQLOpenEx@PODBC>
   \ \                                    */
#define IsSQLOpen(odbc) IsSQLOpenEx(odbc DBG_SRC )
/* An PODBC connection handles commands as a stack, this saves
   the current query state (that you want to still get results
   from), so you can start a new query within the outer query.
   Parameters
   odbc :  database connection to save the current query state. */
PSSQL_PROC( int, PushSQLQueryExEx )(PODBC DBG_PASS);
PSSQL_PROC( int, PushSQLQueryEx )(PODBC);
/* <combine sack::sql::PushSQLQueryExEx@PODBC>
   \ \                                         */
#define PushSQLQueryEx(odbc) PushSQLQueryExEx(odbc DBG_SRC )
// no application support for username/password, sorry, trust thy odbc layer, please
PSSQL_PROC( PODBC, ConnectToDatabase )( CTEXTSTR dsn );
PSSQL_PROC( PODBC, SQLGetODBC )( CTEXTSTR dsn );
PSSQL_PROC( PODBC, SQLGetODBCEx )( CTEXTSTR dsn, CTEXTSTR user, CTEXTSTR pass );
PSSQL_PROC( void, SQLDropODBC )( PODBC odbc );
PSSQL_PROC( void, SQLDropAndCloseODBC )( CTEXTSTR dsn );
#endif
// default parameter to require is the global flag RequireConnection from sql.config....
PSSQL_PROC( PODBC, ConnectToDatabaseExx )( CTEXTSTR DSN, LOGICAL bRequireConnection DBG_PASS );
PSSQL_PROC( PODBC, ConnectToDatabaseEx )( CTEXTSTR DSN, LOGICAL bRequireConnection );
#define ConnectToDatabaseEx( dsn, required ) ConnectToDatabaseExx( dsn, required DBG_SRC )
#define ConnectToDatabase( dsn ) ConnectToDatabaseExx( dsn, FALSE DBG_SRC )
/* Close a database connection. Releases all resources
   associated with the odbc connection.
   Parameters
   odbc :  connection to database to close. Should not be NULL.  */
PSSQL_PROC( void, CloseDatabase)(PODBC odbc );
// does a query responce kinda thing returning types.
// if( GetSQLTypes() ) while( GetSQLResult( &result ) && result )
PSSQL_PROC( int, GetSQLTypes )( void );
/* ODBC only (sqlite no support?). Gets the types of data that
   the ODBC connection supports.
   Parameters
   odbc :  database connection to get the types from.
   Example
   <code>
   PODBC odbc = NULL; // or do a ConnectToDatabsae
   CTEXTSTR result; // the singular line result
   if( FetchSQLTypes(odbc) )
       while( FetchSQLResult( &amp;result ) &amp;&amp; result )
       {
           printf( "Supported Type: %s\\n", result );
       }
   </code>
   <code lang="c++">
   if( GetSQLTypes() )
       while( GetSQLResult( &amp;result ) &amp;&amp; result )
   </code>
   <code>
       {
           printf( "Supported Type: %s\\n", result );
       }
   </code>                                                      */
PSSQL_PROC( int, FetchSQLTypes )( PODBC );
#define PSSQL_VARARG_PROC(a,b,c)  PSSQL_PROC(a,b)c; typedef a(CPROC * __f_##b)c; PSSQL_PROC( __f_##b, __##b )(DBG_VOIDPASS)
/* Do a SQL query on the default odbc connection. The first
   record results immediately if there are any records. Returns
   the results as an array of strings. If you know the select
   you are using .... "select a,b,c from xyz" then you know that
   this will have 3 columns resulting.
   Parameters
   columns :  pointer to an int to receive the number of columns
              in the result. (the user will know this based on
              the query issued usually, so it can be NULL to
              ignore parameter)
   result\ :  pointer to a pointer to strings... see example
   fields :   address of a pointer to strings which will get the
              field names
   fmt :      format string as is appropriate for vsnprintf
   .... :     extra arguments to pass to format string
   Example
   See SQLRecordQueryf, but omit the database parameter.         */
PSSQL_VARARG_PROC( int, DoSQLRecordQueryf ,( int *columns, CTEXTSTR **result, CTEXTSTR **fields, CTEXTSTR fmt, ... ) );
#define DoSQLRecordQueryf   (__DoSQLRecordQueryf( DBG_VOIDSRC ))
/* <combine sack::sql::SQLQueryf@PODBC@CTEXTSTR *@CTEXTSTR@...>
   \ \                                                          */
PSSQL_VARARG_PROC( int, DoSQLQueryf, ( CTEXTSTR *result, CTEXTSTR fmt, ... ) );
#define DoSQLQueryf   (__DoSQLQueryf( DBG_VOIDSRC ))
/* This does a command to the database as a formatted command.
   This allows the user to simply specify the command and
   \parameters, and not also maintain a buffer to build the
   string into before passing the string to the ODBC connection
   as a command.
   Parameters
   fmt :  format string appropriate for vsnprintf. ... \: extra
          \parameters to fill the format string.
   See Also
   SQLCommandf
   Returns
   TRUE if command success, else FALSE.
   if FALSE, can get the error from GetSQLError.
	*/
PSSQL_VARARG_PROC( int, DoSQLCommandf, ( CTEXTSTR fmt, ... ) );
#define DoSQLCommandf   (__DoSQLCommandf( DBG_VOIDSRC ))
/* Do a SQL query on the default odbc connection. The first
   record results immediately if there are any records. Returns
   the results as an array of strings. If you know the select
   you are using .... "select a,b,c from xyz" then you know that
   this will have 3 columns resulting.
   Parameters
   odbc :     database connection to perform the query on
   columns :  pointer to an int to receive the number of columns
              in the result. (the user will know this based on
              the query issued usually, so it can be NULL to
              ignore parameter)
   result\ :  pointer to a pointer to strings... see example
   fields :   address of a pointer to strings which will get the
              field names. May be ommited if you don't want to
              know the names. (is less work internally if this is
              not built).
   fmt :      format string as is appropriate for vsnprintf
   .... :     extra arguments to pass to format string
   Example
   <code lang="c++">
   PODBC odbc = ConnectToDatabase( "MySQL" );
   CTEXTSTR *results;
   CTEXTSTR *column_names;
   int columns;
   for( SQLRecordQueryf( odbc, &amp;columns, &amp;results, &amp;column_names
                       , "select a,b,c from %s where %s=%s"
                       , "table_name"
                       , "column_name"
                       , "'value'"
                       );
        results;
        FetchSQLRecord( odbc, &amp;results ) )
   {
      int n;
       // draw a seperator between rows returned
      printf( " ----- record data ----- \\n" );
      for( n = 0; n \< columns; n++ )
      {
         printf( "Result column '%s' = '%s'\\n", column_name[n], results[n] );
      }
   }
   CloseDatabase( odbc );
   </code>
   If the default connection is used, odbc can be NULL in the
   prior example, or the for staement could be
   <code>
   for( DoSQLRecordQueryf( &amp;columns, &amp;results, &amp;column_names
                         , "select a,b,c from %s where %s=%s"
                         , "table_name"
                         , "column_name"
                         , "'value'"
                         );
        results;
        GetSQLRecord( &amp;results ) )
   {
   }
   </code>                                                                     */
//PSSQL_PROC( int, SQLRecordQueryf )( PODBC odbc, int *columns, CTEXTSTR **result, CTEXTSTR **fields, CTEXTSTR fmt, ... );
PSSQL_VARARG_PROC( int, SQLRecordQueryf, ( PODBC odbc, int *columns, CTEXTSTR **result, CTEXTSTR **fields, CTEXTSTR fmt, ... ) );
#define SQLRecordQueryf   (__SQLRecordQueryf( DBG_VOIDSRC ))
PSSQL_VARARG_PROC( int, SQLRecordQueryf_v2, ( PODBC odbc, int *nResults, CTEXTSTR **result, size_t **resultLengths, CTEXTSTR **fields, CTEXTSTR fmt, ... ) );
#define SQLRecordQueryf_v2   (__SQLRecordQueryf_v2( DBG_VOIDSRC ))
/* This was the original implementation, it returned the results
   as a comma separated list, with quotes around results that
   had commas in them, and quotes around empty strings to
   distinguish NULL result which is just ',,'.
   Parameters
   odbc :     database connection to do the query
   result\ :  address of a CTEXTSTR to get a comma seperated
              \result of the query in.
   query :    the string query to do
   ... :      extra parameters for the query format string
   Returns
   TRUE if the query succeeded
   FALSE if the query was in error. See FetchSQLError.
   Example
   <code>
   PODBC odbc = NULL; // just use the default connection...
   CTEXTSTR result;
   DoSQLQueryf( odbc, &amp;result, "select %d,%d,%d", 1, 2, 3 );
   printf( "result : %s" );
   </code>
   \Output
   <code>
   \result : 1,2,3
   </code>
   See Also
   SQLRecordQueryf                                               */
PSSQL_VARARG_PROC( int, SQLQueryf ,( PODBC odbc, CTEXTSTR *result, CTEXTSTR fmt, ... ) );
#define SQLQueryf   (__SQLQueryf( DBG_VOIDSRC ))
/* This performs a command on a SQL connection.
   Parameters
   odbc :  database connection to do the command on
   fmt :   format string as appropriate for vsnprintf
   ... :   extra arguments as required by the format string
   Returns
   TRUE if command success, else FALSE.
   if FALSE, can get the error from FetchSQLError.
                                                            */
PSSQL_VARARG_PROC( int, SQLCommandf, ( PODBC odbc, CTEXTSTR fmt, ... ) );
#define SQLCommandf   (__SQLCommandf( DBG_VOIDSRC ))
/* Function signature for the callback when the SQL layer can
   log a status about a database connection (connection,
   disconnected, failed...) See SQLSetFeedbackHandler.        */
typedef void (CPROC *HandleSQLFeedback)(CTEXTSTR message);
// register a feedback message for startup messages
//  allows external bannering of status... perhaps this can handle failures
//  and disconnects also...
PSSQL_PROC( void, SQLSetFeedbackHandler )( HandleSQLFeedback handler );
/* Parses a CREATE TABLE statement and builds a PTABLE from it.
   Parameters
   cmd :         a CREATE TABLE sql command. It is a little
                 sqlite/mysql centric, and may fail on column
                 types for SQL Server.
   writestate :  if writestate is TRUE, a file called
                 'sparse.txt' will be generated with a C
                 structure of the Create Table statement passed. This
                 \file could then be used to copy into code, and
                 have a code\-static definition instead of going
                 from the create table statement.
   Returns
   a PTABLE which represents the create table statement.              */
PSSQL_PROC( PTABLE, GetFieldsInSQLEx )( CTEXTSTR cmd, int writestate DBG_PASS );
/* <combine sack::sql::GetFieldsInSQLEx@CTEXTSTR@int writestate>
   \ \                                                           */
#define GetFieldsInSQL(c,w) GetFieldsInSQLEx( c, w DBG_SRC )
//PSSQL_PROC( PTABLE, GetFieldsInSQL )( CTEXTSTR cmd, int writestate);
// this is used to destroy the table returned by GetFieldsInSQL
PSSQL_PROC( void, DestroySQLTable )( PTABLE table );
// allow setting and getting of a bit of user data associated with the PODBC...
// though this can result in memory losses at the moment, cause there is no notification
// that the PODBC has gone away, and that the user needs to remove his data...
PSSQL_PROC( uintptr_t, SQLGetUserData )( PODBC odbc );
/* A PODBC may have a user data assigned to it.
   Parameters
   odbc :  connection to set the data for; shouldn't be NULL.
   psv :   user data to assign to the database connection.
   See Also
   SQLGetUserData                                             */
PSSQL_PROC( void, SQLSetUserData )( PODBC odbc, uintptr_t );
/* Returns a text string GUID, the guid is saved in psersistant text space and will
   not be released or overwritten.  */
PSSQL_PROC( CTEXTSTR, GetGUID )( void );
/* Returns a text string GUID, This uses UuidCreateSequential  */
PSSQL_PROC( CTEXTSTR, GetSeqGUID )( void );
/* Returns a text string GUID, the guid is saved in psersistant text space and will
   not be released or overwritten.  This tring is the constant 0 guid */
PSSQL_PROC( CTEXTSTR, GuidZero )( void );
/* convert a string GUID to a binary representation of 16 bytes.
   litte_endian will byte-swap the grouped portions of numbers in a guid so they can be printed appropriately*/
PSSQL_PROC( uint8_t*, GetGUIDBinaryEx )( CTEXTSTR guid, LOGICAL litte_endian );
#define GetGUIDBinary(g) GetGUIDBinaryEx(g, TRUE )
struct guid_binary {
	union {
		struct {
			uint8_t bytes[16];
			uint8_t zero[2];
		} b;
		struct {
			uint32_t l1;
			uint16_t w1;
			uint16_t w2;
			uint16_t w3;
			uint64_t ll1;
		} d;
	} u;
};
// snprintf( buf, 256, guid_format, guid_param_pass(&guid_binary) )
// snprintf( buf, 256, guid_format, guid_param_pass(binary_buffer_result) )
#define guid_format "%08" _32fx "-%04" _16fx "-%04" _16fx "-%04" _16fx "-%012" _64fx
#define guid_param_pass(n) ((struct guid_binary*)(n))->u.d.l1,((struct guid_binary*)(n))->u.d.w1,((struct guid_binary*)(n))->u.d.w2,((struct guid_binary*)(n))->u.d.w3,((struct guid_binary*)(n))->u.d.ll1
/* some internal stub-proxy linkage for generating remote
   responders..
   This was work in progress for providing a msgsvr service to
   SQL. One of the implementations of this library was across a
   windows message queue using ATOM types to transport results
   and commands. Was going to implement this on the abstract
   msgqueue interface.                                          */
typedef struct responce_tag
{
	struct {
		BIT_FIELD bSingleLine : 1;
		BIT_FIELD bMultiLine : 1;
		BIT_FIELD bFields : 1;
	} flags;
	PVARTEXT result_single_line;
	int nLines;
	CTEXTSTR *pLines;
	CTEXTSTR *pFields;
} SQL_RESPONCE, *PSQL_RESPONCE;
/* *WORK IN PROGRESS* function call signature for callback method passed to
   RegisterResponceHandler.                              */
typedef void (CPROC *result_responder)( int responce
									  , PSQL_RESPONCE result );
/* *WORK IN PROGRESS*
   result_responder :  callback function to get called with sql
                       global status messages.
   See Also
   <link sack::sql::result_responder, Result Responder Type>    */
PSSQL_PROC( void, RegisterResponceHandler )( result_responder );
/* Thread protect means to use critical sections to protect this
   connection against multiple thread access. Recommended usage
   is to not use a PODBC with more than one thread in the first
   place.
   Parameters
   odbc :     connection to enable; if null, references the
              \internal static connection.
   bEnable :  TRUE to enable, FALSE to disable.                  */
PSSQL_PROC( void, SetSQLThreadProtect )( PODBC odbc, LOGICAL bEnable );
/* Enable using 'BEGIN TRANSACTION' and 'COMMIT' commands automatically
   around commands. If there is a lull of 500ms (1/2 second),
   then the commit automatically fires. SQLCommit can be called
   to trigger this process early.
   Parameters
   odbc :     connection to set auto transact on
   bEnable :  TRUE to enable, FALSE to disable.                         */
PSSQL_PROC( void, SetSQLAutoTransact )( PODBC odbc, LOGICAL bEnable );
/* Enable using 'BEGIN TRANSACTION' and 'COMMIT' commands automatically
   around commands. If there is a lull of 500ms (1/2 second),
   then the commit automatically fires. SQLCommit can be called
	to trigger this process early.
	if Callback is set, automatically enables AutoTransact
   if Callback is NULL, automatically clears AutoTransact
   Parameters
   odbc :     connection to set auto transact on
   callback :  not NULL to enable, NULL to disable.                         */
PSSQL_PROC( void, SetSQLAutoTransactCallback )( PODBC odbc, void (CPROC*callback)(uintptr_t,PODBC), uintptr_t psv );
/* Relevant for SQLite databases. After a certain period of
   inactivity the database is closed (allowing the file to be
   not-in-use during idle). PODBC odject remains valid, and
   connection to database is re-enabled on next usage.
   Parameters
   odbc :     connection to enable auto close behavior on
   bEnable :  TRUE to enable auto close FALSE to disable.     */
PSSQL_PROC( void, SetSQLAutoClose )( PODBC odbc, LOGICAL bEnable );
/* Relevant for SQLite databases. After a certain period of
   inactivity the database is issued a PRAGMA wal_checkpoint
   Parameters
   odbc :     connection to enable auto checkpoint behavior on
   bEnable :  TRUE to enable auto checkpoint FALSE to disable.     */
PSSQL_PROC( void, SetSQLAutoCheckpoint )( PODBC odbc, LOGICAL bEnable );
/* returns the current value of auto checkpoint mode on a conneciton
   Parameters
   odbc :     connection to enable auto checkpoint behavior on */
PSSQL_PROC( LOGICAL, GetSQLAutoCheckpoint )( PODBC odbc );
/* A function to apply a time offset for fiscal time
   calculations; sometimes the day doesn't end at midnight, but
   a shift might last until 5 in the morning.
   Parameters
   odbc :            connection to get the appropriate SQL
                     expression for
   BeginOfDayType :  name of the type of beginning of the day
   default_begin :   the default time when a day begins.
   Note
   default_begin is a format sort of like a time. If this is a
   simple integer 5 then it's 5:00am, if it's more than 100,
   then it's assumed to be hours and minutes so 530 would be
   5:30 in the monring. this is also stored in the option
   databse, so the default value can be overridden; if the SQL
   value has a ':' in it then it is parsed as hours and minutes.
   Negative time may be used to indicate that the day begins
   before the day ends (-2 would be day end at 10pm).            */
PSSQL_PROC( CTEXTSTR, GetSQLOffsetDate )( PODBC odbc, CTEXTSTR BeginOfDayType, int default_begin );
/* Performs a low level backup of one database to another.  This API supports
   sqlite3 connections ONLY.
   Parameters
   source :            original database to copy from
   dest :    database to copy to
   */
PSSQL_PROC( LOGICAL, BackupDatabase )( PODBC source, PODBC dest );
/* return the underlaying native connection handle of the database connection
 */
// deprecated during dev, instead added function hook exports
//PSSQL_PROC( POINTER, GetODBCHandle )( PODBC odbc );
/* set a handler to be triggered when SQLite Database finds corruption type error...
 */
PSSQL_PROC( void, SetSQLCorruptionHandler )( PODBC odbc, void (CPROC*f)(uintptr_t psv, PODBC odbc), uintptr_t psv );
/* Utility function to parse DSN according to sack sqlite vfs rules... */
PSSQL_PROC( void, ParseDSN )( CTEXTSTR dsn, char **vfs, char **vfsInfo, char **dbFile );
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
#ifdef __cplusplus
SQL_NAMESPACE_END
#endif
struct sqlite3_value;
struct sqlite3_context;
#ifdef __cplusplus
SQL_NAMESPACE
#endif
PSSQL_PROC( int, PSSQL_AddSqliteFunction )( PODBC odbc
	, const char *name
	, void( *callUserFunction )( struct sqlite3_context*onwhat, int argc, struct sqlite3_value**argv )
	, void( *callUserDestroy )( void * )
	, int args
	, void *userData );
PSSQL_PROC( int, PSSQL_AddSqliteProcedure )( PODBC odbc
	, const char *name
	, void( *callUserFunction )( struct sqlite3_context*onwhat, int argc, struct sqlite3_value**argv )
	, void( *callUserDestroy )( void * )
	, int args
	, void *userData );
PSSQL_PROC( int, PSSQL_AddSqliteAggregate )( PODBC odbc
	, const char *name
	, void( *callStep )( struct sqlite3_context*onwhat, int argc, struct sqlite3_value**argv )
	, void( *callFinal )( struct sqlite3_context*onwhat )
	, void( *callUserDestroy )( void * )
	, int args
	, void *userData );
PSSQL_PROC( POINTER, PSSQL_GetSqliteFunctionData )( struct sqlite3_context*context );
PSSQL_PROC( void, PSSQL_ResultSqliteText )( struct sqlite3_context*context, const char *data, int dataLen, void (*done)(void*) );
PSSQL_PROC( void, PSSQL_ResultSqliteBlob )( struct sqlite3_context*context, const char *data, int dataLen, void (*done)(void*) );
PSSQL_PROC( void, PSSQL_ResultSqliteDouble )( struct sqlite3_context*context, double val );
PSSQL_PROC( void, PSSQL_ResultSqliteInt )( struct sqlite3_context*context, int val );
PSSQL_PROC( void, PSSQL_ResultSqliteInt64 )( struct sqlite3_context*context, int64_t val );
PSSQL_PROC( void, PSSQL_ResultSqliteNull )( struct sqlite3_context*context );
enum sqlite_data_types {
	PSSQL_TYPE_INTEGER= 1,
	PSSQL_TYPE_FLOAT= 2,
	PSSQL_TYPE_TEXT = 3,
	PSSQL_TYPE_BLOB  = 4,
	PSSQL_TYPE_NULL = 5,
};
PSSQL_PROC( enum sqlite_data_types, PSSQL_GetSqliteValueType )( struct sqlite3_value *val );
PSSQL_PROC( void, PSSQL_GetSqliteValueText )( struct sqlite3_value *val, const char **text, int *textLen );
PSSQL_PROC( void, PSSQL_GetSqliteValueBlob )( struct sqlite3_value *val, const char **text, int *textLen );
PSSQL_PROC( void, PSSQL_GetSqliteValueDouble )( struct sqlite3_value *val, double *result );
PSSQL_PROC( void, PSSQL_GetSqliteValueInt )( struct sqlite3_value *val, int *result );
PSSQL_PROC( void, PSSQL_GetSqliteValueInt64 )( struct sqlite3_value *val, int64_t *result );
PSSQL_PROC( const char *, PSSQL_GetColumnTableName )( PODBC odbc, int col );
PSSQL_PROC( const char *, PSSQL_GetColumnTableAliasName )( PODBC odbc, int col );
PSSQL_PROC( void, PSSQL_GetSqliteValue )( struct sqlite3_value *val, const char **text, int *textLen );
#endif
SQL_NAMESPACE_END
#ifdef __cplusplus
	using namespace sack::sql;
#endif
#endif
#if 0
#endif
// sqloptint.h leaves namespace open.
// these headers should really be collapsed.
#ifndef SQL_GET_OPTION_DEFINED
#define SQL_GET_OPTION_DEFINED
/*
 * Create: James Buckeyne
 *
 * Purpose: Provide a general structure to register names of
 *   routines and data structures which may be consulted
 *   for runtime linking.  Aliases and other features make this
 *   a useful library for tracking interface registration...
 *
 *  The namespace may be enumerated.
 */
#ifndef PROCEDURE_REGISTRY_LIBRARY_DEFINED
#define PROCEDURE_REGISTRY_LIBRARY_DEFINED
#ifndef DEADSTART_DEFINED
#define DEADSTART_DEFINED
#ifdef WIN32
//#include <stdhdrs.h>
#endif
 // leach, assuming this will be compiled with this part at least.
#define pastejunk_(a,b) a##b
#define pastejunk(a,b) pastejunk_(a,b)
#ifdef __cplusplus
#define USE_SACK_DEADSTART_NAMESPACE using namespace sack::app::deadstart;
#define SACK_DEADSTART_NAMESPACE   SACK_NAMESPACE namespace app { namespace deadstart {
#define SACK_DEADSTART_NAMESPACE_END    } } SACK_NAMESPACE_END
SACK_NAMESPACE
	namespace app{
/* Application namespace. */
/* These are compiler-platform abstractions to provide a method
   of initialization that allows for creation of threads, and
   transparent (easy to use) method of scheduling routines for
   initialization.
   Example
   This schedules a routine to run at startup. Fill in the
   routine with the code you want, and it will run at
   DEFAULT_PRELOAD_PRIORITY which is the number 69.
   <code lang="c++">
   PRELOAD( MyCustomInit )
   {
       // do something here (do anything here,
       // without limitations that are imposed by DllMain/LibMain.
   }
   </code>
   If you wanted a routine which was guaranteed to run before
   MyCustomInit you might use PRIORITY_PRELOAD whcih allows you
   to specify a priority.
   <code lang="c++">
   PRIORITY_PRELOAD( MyOtherInit, DEFAULT_PRELOAD_PRIORITY-10 )
   {
      // this will run before other things.
   }
   </code>
   Priorities are listed in deadstart.h and exit_priorities.h. The
   priorities are treated backwards, so low number startup
   priorities go first, and higher number shutdown priorities go
   first.
   Remarks
   In some compilers and compile modes this is also fairly easy
   to do. A lot of compilers do not offer priority, and are
   impossible to maintain an order in. Some compilers only
   provide startup priority for C++ mode. This system works as
   \long as there is a way to run a single function at some
   point before main() and after C runtime initializes.
   In Windows, you might think you have this ability with
   DllMain, but there are severe limitations that you would have
   to get around; primary is the inability to create a thread,
   well, you can create it, but it will remain suspended until
   you leave DllMains and all DllMains finish. There is also no
   way to consistantly provide initialization order, like memory
   needs to be initialized before anything else.
                                                                   */
		namespace deadstart {
#else
#define USE_SACK_DEADSTART_NAMESPACE
#define SACK_DEADSTART_NAMESPACE
#define SACK_DEADSTART_NAMESPACE_END
#endif
#ifdef TYPELIB_SOURCE
#define DEADSTART_SOURCE
#endif
/* A macro to specify the call type of schedule routines. This
   can be changed in most projects without affect, it comes into
   play if plugins built by different compilers are used,
   __cdecl is most standard.                                     */
#define DEADSTART_CALLTYPE CPROC
#  if defined( _TYPELIBRARY_SOURCE_STEAL )
#    define DEADSTART_PROC extern
#  elif defined( _TYPELIBRARY_SOURCE )
#    define DEADSTART_PROC EXPORT_METHOD
#  else
/* A definition for how to declare these functions. if the
   source itself is comipling these are _export, otherwise
   external things linking here are _import.               */
#    define DEADSTART_PROC IMPORT_METHOD
#  endif
   /* this is just a global space initializer (shared, named
      region, allows static link plugins to share information)
      Allocates its shared memory global region, so if this library
      is built statically and referenced in multiple plugins
      ConfigScript can share the same symbol tables. This also
      provides sharing between C++ and C.                           */
#define CONFIG_SCRIPT_PRELOAD_PRIORITY    (SQL_PRELOAD_PRIORITY-3)
   // this is just a global space initializer (shared, named region, allows static link plugins to share information)
#define SQL_PRELOAD_PRIORITY    (SYSLOG_PRELOAD_PRIORITY-1)
/* Level at which logging is initialized. Nothing under this
   should be doing logging, if it does, the behavior is not as
   well defined.                                               */
#define SYSLOG_PRELOAD_PRIORITY 35
   // global_init_preload_priority-1 is used by sharemem.. memory needs init before it can register itself
#define GLOBAL_INIT_PRELOAD_PRIORITY 37
 // OS A[bstraction] L[ayer] O[n] T[op] - system lib
#define OSALOT_PRELOAD_PRIORITY (CONFIG_SCRIPT_PRELOAD_PRIORITY-1)
/* Level which names initializes. Names is the process
   registration code. It has a common shared global registered.
   <link sack::app::registry, procreg; aka names.c>             */
#define NAMESPACE_PRELOAD_PRIORITY 39
/* image_preload MUST be after Namespce preload (anything that
   uses RegisterAndCreateGlobal) should init this before vidlib
   (which needs image?)                                         */
#define IMAGE_PRELOAD_PRIORITY  45
/* Level at which the video render library performs its
   initialization; RegisterClass() level code.          */
#define VIDLIB_PRELOAD_PRIORITY 46
/* Initialization level where PSI registers its builtin
   controls.                                            */
#define PSI_PRELOAD_PRIORITY    47
// need to open the queues and threads before the service server can begin...
#define MESSAGE_CLIENT_PRELOAD_PRIORITY 65
/* Level which message core service initializes. During startup
   message services can register themselves also; but not before
   this priority level.                                          */
#define MESSAGE_SERVICE_PRELOAD_PRIORITY 66
/* Routines are scheduled at this priority when the PRELOAD
   function is used.                                        */
#define DEFAULT_PRELOAD_PRIORITY (DEADSTART_PRELOAD_PRIORITY-1)
/* Not sure where this is referenced, this the core routine
   itself is scheduled with this symbol to the compiler if
   appropriate.                                             */
#define DEADSTART_PRELOAD_PRIORITY 70
#define PRIORITY_UNLOAD(proc,priority) PRIORITY_ATEXIT( proc##_unload, priority )
/* Used by PRELOAD and PRIORITY_PRELOAD macros to register a
   startup routine at a specific priority. Lower number
   priorities are scheduled to run before higher number
   priorities*backwards from ATEXIT priorities*. Using this
   scheduling mechanisms, routines which create threads under
   windows are guaranteed to run before main, and are guaranteed
   able to create threads. (They are outside of the loader lock)
   Parameters
   function :  pointer to a function to call at startup.
   name :      text name of the function
   priority :  priority at which to call the function.
   unused :    this is an unused parameter. The macros fill it
               with &amp;ThisRegisteringRoutine, so that the
               routine itself is referenced by code, and helps
               the compile not optimize out this code. The
               functions which perform the registration are prone
               to be optimized because it's hard for the compiler
               to identify that they are refernced by other names
               indirectly.
   file\ :     usually DBG_PASS of the code doing this
               registration.
   line :      usually DBG_PASS of the code doing this
               registration.                                      */
DEADSTART_PROC  void DEADSTART_CALLTYPE  RegisterPriorityStartupProc( void(CPROC*)(void), CTEXTSTR,int,void* unused DBG_PASS);
/* Used by ATEXIT and PRIORITY_ATEXIT macros to register a
   shutdown routine at a specific priority. Higher number
   priorities are scheduled to run before lower number
   priorities. *backwards from PRELOAD priorities* This
   registers functions which are run while the program exits if
   it is at all able to run when exiting. calling exit() or
   BAG_Exit() will invoke these.
   Parameters
   function :  pointer to a function to call at shutdown.
   name :      text name of the function
   priority :  priority at which to call the function.
   unused :    this is an unused parameter. The macros fill it
               with &amp;ThisRegisteringRoutine, so that the
               routine itself is referenced by code, and helps
               the compile not optimize out this code. The
               functions which perform the registration are prone
               to be optimized because it's hard for the compiler
               to identify that they are refernced by other names
               indirectly.
   file\ :     usually DBG_PASS of the code doing this
               registration.
   line :      usually DBG_PASS of the code doing this
               registration.                                      */
DEADSTART_PROC  void DEADSTART_CALLTYPE  RegisterPriorityShutdownProc( void(CPROC*)(void), CTEXTSTR,int,void* unused DBG_PASS);
/* This routine is used internally when LoadFunction is called.
   After MarkDeadstartComplete is called, any call to a
   RegisterPriorityStartupProc will call the startup routine
   immediately instead of waiting. This function disables the
   auto-running of this function, and instead enques the startup
   to the list of startups. When completed, at some later point,
   call ResumeDeadstart() to dispatched all scheduled routines,
   and release the suspend; however, if initial deastart was not
   dispatched, then ResumeDeadstart does not do the invoke, it
   only releases the suspend.                                    */
DEADSTART_PROC  void DEADSTART_CALLTYPE  SuspendDeadstart ( void );
/* Resumes a suspended deadstart. If root deadstart is
   completed, then ResumeDeadstart will call InvokeDeadstarts
   after resuming deadstart.                                  */
DEADSTART_PROC  void DEADSTART_CALLTYPE  ResumeDeadstart ( void );
/* Not usually used by user code, but this invokes all the
   routines which have been scheduled to run for startup. If
   your compiler doesn't have a method of handling deadstart
   code, this can be manually called. It can also be called if
   you loaded a library yourself without using the LoadFunction
   interface, to invoke startups scheduled in the loaded
   library.                                                     */
DEADSTART_PROC  void DEADSTART_CALLTYPE  InvokeDeadstart (void);
/* This just calls the list of shutdown procedures. This should
   not be used usually from user code, since internally this is
   handled by catching atexit() or with a static destructor.    */
DEADSTART_PROC  void DEADSTART_CALLTYPE  InvokeExits (void);
/* This is typically called after the first InvokeDeadstarts
   completes. The code that runs this is usually a routine just
   before main(). So once code in main begins to run, all prior
   initialization has been performed.                           */
DEADSTART_PROC  void DEADSTART_CALLTYPE  MarkRootDeadstartComplete ( void );
/* \returns whether InvokeDeadstarts has been called. */
DEADSTART_PROC  LOGICAL DEADSTART_CALLTYPE  IsRootDeadstartStarted ( void );
/* \returns whether MarkRootDeadstartComplete has been called. */
DEADSTART_PROC  LOGICAL DEADSTART_CALLTYPE  IsRootDeadstartComplete ( void );
#if defined( __LINUX__ )
// call this after a fork().  Otherwise, it will falsely invoke shutdown when it exits.
DEADSTART_PROC  void DEADSTART_CALLTYPE  DispelDeadstart ( void );
#endif
#ifdef DOC_O_MAT
// call this after a fork().  Otherwise, it will falsely invoke shutdown when it exits.
DEADSTART_PROC  void DEADSTART_CALLTYPE  DispelDeadstart ( void );
#endif
#ifdef __cplusplus
/* Defines some code to run at program inialization time. Allows
   specification of a priority. Lower priorities run first. (default
   is 69).
   Example
   <code>
   PRIORITY_PRELOAD( MyOtherInit, 153 )
   {
      // run some code probably after most all other initializtion is done.
   }
   </code>
   See Also
   <link sack::app::deadstart, deadstart Namespace>                         */
#define PRIORITY_PRELOAD(name,priority) static void CPROC name(void);	 namespace { static class pastejunk(schedule_,name) {        public:pastejunk(schedule_,name)() {	    RegisterPriorityStartupProc( name,TOSTR(name),priority,(void*)this DBG_SRC);	  }	  } pastejunk(do_schedule_,name);   }	  static void name(void)
/* This is used once in deadstart_prog.c which is used to invoke
   startups when the program finishes loading.                   */
#define MAGIC_PRIORITY_PRELOAD(name,priority) static void CPROC name(void);	 namespace { static class pastejunk(schedule_,name) {	     public:pastejunk(schedule_,name)() {	  name();	    }	  } pastejunk(do_schedul_,name);   }	  static void name(void)
/* A macro to define some code to run during program shutdown. An
   additional priority may be specified if the order matters. Higher
   numbers are called first.
                                                                     */
#define ATEXIT_PRIORITY(name,priority) static void CPROC name(void);    static class pastejunk(schedule_,name) {        public:pastejunk(schedule_,name)() {	    RegisterPriorityShutdownProc( name,TOSTR(name),priority,(void*)this DBG_SRC );	  }	  } pastejunk(do_schedule_,name);	     static void name(void)
/* Defines some code to run at program shutdown time. Allows
   specification of a priority. Higher priorities are run first.
   Example
   <code>
   PRIORITY_ATEXIT( MyOtherShutdown, 153 )
   {
      // run some code probably before most library code dissolves.
      // last to load, first to unload.
   }
   </code>
   See Also
   <link sack::app::deadstart, deadstart Namespace>                 */
	/*name(); / * call on destructor of static object.*/
#define PRIORITY_ATEXIT(name,priority) static void CPROC name(void);    static class pastejunk(shutdown_,name) {	   public:pastejunk(shutdown_,name)() {       RegisterPriorityShutdownProc( name,TOSTR(name),priority,(void*)this DBG_SRC );	   }	  } do_shutdown_##name;	     void name(void)
/* This is the most basic way to define some code to run
   initialization before main.
   Example
   <code lang="c++">
   PRELOAD( MyInitCode )
   {
      // some code here
   }
   </code>
   See Also
   <link sack::app::deadstart, deadstart Namespace>      */
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
/* Basic way to register a routine to run when the program exits
   gracefully.
   Example
   \    <code>
   ATEXIT( MyExitRoutine )
   {
       // this will be run sometime during program shutdown
   }
   </code>                                                       */
#define ATEXIT(name)      PRIORITY_ATEXIT(name,ATEXIT_PRIORITY_DEFAULT)
/* This is the core atexit. It dispatches all other exit
   routines. This is defined for internal use only...    */
#define ROOT_ATEXIT(name) ATEXIT_PRIORITY(name,ATEXIT_PRIORITY_ROOT)
//------------------------------------------------------------------------------------
// Win32 Watcom
//------------------------------------------------------------------------------------
#elif defined( __WATCOMC__ )
#pragma off (check_stack)
/* code taken from openwatcom/bld/watcom/h/rtinit.h */
typedef unsigned char   __type_rtp;
typedef unsigned short  __type_pad;
typedef void(*__type_rtn ) ( void );
#ifdef __cplusplus
#pragma pack(1)
#else
#pragma pack(1)
#endif
 // structure placed in XI/YI segment
struct rt_init
{
#define DEADSTART_RT_LIST_START 0xFF
 // - near=0/far=1 routine indication
    __type_rtp  rtn_type;
                          //   also used when walking table to flag
                          //   completed entries
 // - priority (0-highest 255-lowest)
    __type_rtp  priority;
      // - routine
    __type_rtn  rtn;
};
#pragma pack()
/* end code taken from openwatcom/bld/watcom/h/rtinit.h */
//------------------------------------------------------------------------------------
// watcom
//------------------------------------------------------------------------------------
//void RegisterStartupProc( void (*proc)(void) );
#define PRIORITY_PRELOAD(name,priority) static void pastejunk(schedule_,name)(void); static void CPROC name(void);	 static struct rt_init __based(__segname("XI")) pastejunk(name,_ctor_label)={0,(DEADSTART_PRELOAD_PRIORITY-1),pastejunk(schedule_,name)};	 static void pastejunk(schedule_,name)(void) {	                 RegisterPriorityStartupProc( name,TOSTR(name),priority,&pastejunk(name,_ctor_label) DBG_SRC );	}	                                       void name(void)
#define ATEXIT_PRIORITY(name,priority) static void pastejunk(schedule_exit_,name)(void); static void CPROC name(void);	 static struct rt_init __based(__segname("XI")) pastejunk(name,_dtor_label)={0,69,pastejunk(schedule_exit_,name)};	 static void pastejunk(schedule_exit_,name)(void) {	                                              RegisterPriorityShutdownProc( name,TOSTR(name),priority,&name##_dtor_label DBG_SRC );	}	                                       void name(void)
// syslog runs preload at priority 65
// message service runs preload priority 66
// deadstart itself tries to run at priority 70 (after all others have registered)
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
// this is a special case macro used in client.c
// perhaps all PRIORITY_ATEXIT routines should use this
// this enables cleaning up things that require threads to be
// active under windows... (message disconnect)
// however this routine is only triggered in windows by calling
// BAG_Exit(nn) which is aliased to replace exit(n) automatically
#define PRIORITY_ATEXIT(name,priority) ATEXIT_PRIORITY( name,priority)
/*
static void name(void); static void name##_x_(void);	static struct rt_init __based(__segname("YI")) name##_dtor_label={0,priority,name##_x_};	 static void name##_x_(void) { char myname[256];myname[0]=*(CTEXTSTR)&name##_dtor_label;GetModuleFileName(NULL,myname,sizeof(myname));name(); }	 static void name(void)
  */
#define ROOT_ATEXIT(name) ATEXIT_PRIORITY(name,ATEXIT_PRIORITY_ROOT)
#define ATEXIT(name)      PRIORITY_ATEXIT(name,ATEXIT_PRIORITY_DEFAULT)
// if priority_atexit is used with priority 0 - the proc is scheduled into
// atexit, and exit() is then invoked.
//#define PRIORITY_ATEXIT(name,priority) ATEXIT_PRIORITY(name,priority )
//------------------------------------------------------------------------------------
// Linux
//------------------------------------------------------------------------------------
#elif defined( __GNUC__ )
/* code taken from openwatcom/bld/watcom/h/rtinit.h */
typedef unsigned char   __type_rtp;
typedef void(*__type_rtn ) ( void );
 // structure placed in XI/YI segment
struct rt_init
{
#define DEADSTART_RT_LIST_START 0xFF
 // - near=0/far=1 routine indication
    __type_rtp  rtn_type;
                          //   also used when walking table to flag
                          //   completed entries
 // has this been scheduled? (0 if no)
    __type_rtp  scheduled;
 // - priority (0-highest 255-lowest)
    __type_rtp  priority;
#if defined( __64__ ) ||defined( __arm__ )||defined( __GNUC__ )
#define INIT_PADDING ,{0}
 // need this otherwise it's 23 bytes and that'll be bad.
	 char padding[1];
#else
#define INIT_PADDING
#endif
 // 32 bits in 64 bits....
	 int line;
// this ends up being nicely aligned for 64 bit platforms
// specially with the packed attributes
      // - routine (rtn)
	 __type_rtn  routine;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
	 CTEXTSTR file;
#endif
	 CTEXTSTR funcname;
	 struct rt_init *junk;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
#if defined( __GNUC__ ) && defined( __64__)
    // this provides padding - inter-object segments are packed
    // to 32 bytes...
	 struct rt_init *junk2[3];
#endif
#endif
} __attribute__((packed));
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
#  if defined( __GNUC__ ) && defined( __64__)
#    define JUNKINIT(name) ,&pastejunk(name,_ctor_label), {0,0}
#  else
#    define JUNKINIT(name) ,&pastejunk(name,_ctor_label)
#  endif
#else
#  define JUNKINIT(name) ,&pastejunk(name,_ctor_label)
#endif
#define RTINIT_STATIC static
#define ATEXIT_PRIORITY PRIORITY_ATEXIT
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
#  define PASS_FILENAME ,WIDE__FILE__
#else
#  define PASS_FILENAME
#endif
#ifdef __MAC__
#  define DEADSTART_SECTION "TEXT,deadstart_list"
#else
#  define DEADSTART_SECTION "deadstart_list"
#endif
#ifdef __MANUAL_PRELOAD__
#define PRIORITY_PRELOAD(name,pr) static void name(void);	 RTINIT_STATIC struct rt_init pastejunk(name,_ctor_label)		__attribute__((section(DEADSTART_SECTION))) __attribute__((used))	 =	 {0,0,pr INIT_PADDING, __LINE__, name PASS_FILENAME	, TOSTR(name) JUNKINIT(name)} ;	 void name(void);	 void pastejunk(registerStartup,name)(void) __attribute__((constructor));	 void pastejunk(registerStartup,name)(void) {	 RegisterPriorityStartupProc(name,TOSTR(name),pr,NULL DBG_SRC); }	 void name(void)
#else
#if defined( _WIN32 ) && defined( __GNUC__ )
#  define HIDDEN_VISIBILITY
#else
#  define HIDDEN_VISIBILITY  __attribute__((visibility("hidden")))
#endif
#define PRIORITY_PRELOAD(name,pr) static void name(void);	         RTINIT_STATIC struct rt_init pastejunk(name,_ctor_label)	         __attribute__((section(DEADSTART_SECTION))) __attribute__((used)) HIDDEN_VISIBILITY	 ={0,0,pr INIT_PADDING	                                           ,__LINE__,name	                                                 PASS_FILENAME	                                                 ,TOSTR(name)	                                                   JUNKINIT(name)};	                                               static void name(void) __attribute__((used)) HIDDEN_VISIBILITY;	 void name(void)
#endif
typedef void(*atexit_priority_proc)(void (*)(void),CTEXTSTR,int DBG_PASS);
#define PRIORITY_ATEXIT(name,priority) static void name(void);           static void pastejunk(atexit,name)(void) __attribute__((constructor));   void pastejunk(atexit,name)(void)                                        {	                                                                        RegisterPriorityShutdownProc(name,TOSTR(name),priority,NULL DBG_SRC); }                                                                        void name(void)
#define ATEXIT(name) PRIORITY_ATEXIT( name,ATEXIT_PRIORITY_DEFAULT )
#define ROOT_ATEXIT(name) static void name(void) __attribute__((destructor));    static void name(void)
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
//------------------------------------------------------------------------------------
// CYGWIN (-mno-cygwin)
//------------------------------------------------------------------------------------
#elif defined( __CYGWIN__ )
/* code taken from openwatcom/bld/watcom/h/rtinit.h */
typedef unsigned char   __type_rtp;
typedef void(*__type_rtn ) ( void );
 // structure placed in XI/YI segment
struct rt_init
{
#ifdef __cplusplus
	//rt_init( int _rtn_type ) { rt_init::rtn_type = _rtn_type; }
	/*rt_init( int _priority, CTEXTSTR name, __type_rtn rtn, CTEXTSTR _file, int _line )
	{
		rtn_type = 0;
		scheduled = 0;
		priority = priority;
		file = _file;
		line = _line;
      routine = rtn;
		}
      */
#endif
#define DEADSTART_RT_LIST_START 0xFF
 // - near=0/far=1 routine indication
    __type_rtp  rtn_type;
                          //   also used when walking table to flag
                          //   completed entries
 // has this been scheduled? (0 if no)
    __type_rtp  scheduled;
 // - priority (0-highest 255-lowest)
    __type_rtp  priority;
#if defined( __GNUC__ ) || defined( __64__ ) || defined( __arm__ ) || defined( __CYGWIN__ )
#define INIT_PADDING ,{0}
 // need this otherwise it's 23 bytes and that'll be bad.
	 char padding[1];
#else
#define INIT_PADDING
#endif
 // 32 bits in 64 bits....
	 int line;
// this ends up being nicely aligned for 64 bit platforms
// specially with the packed attributes
      // - routine (rtn)
	 __type_rtn  routine;
	 CTEXTSTR file;
	 CTEXTSTR funcname;
	 struct rt_init *junk;
#if defined( __GNUC__ ) && defined( __64__ )
    // this provides padding - inter-object segments are packed
    // to 32 bytes...
	 struct rt_init *junk2[3];
#endif
} __attribute__((packed));
#define JUNKINIT(name) ,&pastejunk(name,_ctor_label)
#ifdef __cplusplus
#define RTINIT_STATIC
#else
#define RTINIT_STATIC static
#endif
typedef void(*atexit_priority_proc)(void (*)(void),CTEXTSTR,int DBG_PASS);
#define ATEXIT_PRIORITY(name,priority) static void name(void); static void atexit##name(void) __attribute__((constructor));	  void atexit_failed##name(void(*f)(void),int i,CTEXTSTR s1,CTEXTSTR s2,int n) { lprintf( "Failed to load atexit_priority registerar from core program." );} void atexit##name(void)                                                  {	                                                                        static char myname[256];HMODULE mod;if(myname[0])return;myname[0]='a';GetModuleFileName( NULL, myname, sizeof( myname ) );	mod=LoadLibrary(myname);if(mod){   typedef void (*x)(void);void(*rsp)( x,const CTEXTSTR,int,const CTEXTSTR,int);	 if((rsp=((void(*)(void(*)(void),const CTEXTSTR,int,const CTEXTSTR,int))(GetProcAddress( mod, "RegisterPriorityShutdownProc")))))	 {rsp( name,TOSTR(name),priority DBG_SRC);}	 else atexit_failed##name(name,priority,TOSTR(name) DBG_SRC);	        }     FreeLibrary( mod);	 }             void name( void)
#ifdef _DEBUG
#  define PASS_FILENAME ,WIDE__FILE__
#else
#  define PASS_FILENAME
#endif
#define PRIORITY_PRELOAD(name,pr) static void name(void);	 RTINIT_STATIC struct pastejunk(rt_init name,_ctor_label)	   __attribute__((section("deadstart_list")))	 ={0,0,pr INIT_PADDING	     ,__LINE__,name	          PASS_FILENAME	        ,TOSTR(name)	        JUNKINIT(name)};	 static void name(void)
#define ATEXIT(name)      ATEXIT_PRIORITY(name,ATEXIT_PRIORITY_DEFAULT)
#define PRIORITY_ATEXIT ATEXIT_PRIORITY
#define ROOT_ATEXIT(name) static void name(void) __attribute__((destructor));    static void name(void)
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
//------------------------------------------------------------------------------------
// WIN32 MSVC
//------------------------------------------------------------------------------------
#elif defined( _MSC_VER ) && defined( _WIN32 )
//#define PRELOAD(name) __declspec(allocate(".CRT$XCAA")) void CPROC name(void)
//#pragma section(".CRT$XCA",long,read)
//#pragma section(".CRT$XCZ",long,read)
// put init in both C startup and C++ startup list...
// looks like only one or the other is invoked, not both?
/////// also the variables to be put into these segments
#if defined( __cplusplus_cli )
#define LOG_ERROR(n) System::Console::WriteLine( gcnew System::String(n) + gcnew System::String( myname) ) )
#else
#define LOG_ERROR(n) SystemLog( n )
// since we get linked first, then the runtime is added, we have to link against the last indicator of section,
// so we get put between start to end.
#define _STARTSEG_ ".CRT$XIM"
#define _STARTSEG2_ ".CRT$XCY"
#define _ENDSEG_ ".CRT$XTM"
//#pragma data_seg(".CRT$XIA")
#pragma data_seg(".CRT$XIM")
#pragma section(".CRT$XIM",long,read)
#pragma data_seg(".CRT$XCY")
#pragma section(".CRT$XCY",long,read)
//#pragma data_seg(".CRT$XIZ")
//#pragma data_seg(".CRT$YCZ")
#pragma data_seg(".CRT$XTM")
#pragma section(".CRT$XTM",long,read)
#pragma data_seg()
	                                       /*static __declspec(allocate(_STARTSEG_)) void (CPROC*pointer_##name)(void) = pastejunk(schedule_,name);*/
#define PRIORITY_PRELOAD(name,priority) static void CPROC name(void);    static int CPROC pastejunk(schedule_,name)(void);	   __declspec(allocate(_STARTSEG_)) int (CPROC*pastejunk(TARGET_LABEL,pastejunk( pastejunk(x_,name),__LINE__)))(void) = pastejunk(schedule_,name);	 int CPROC pastejunk(schedule_,name)(void) {	                 RegisterPriorityStartupProc( name,TOSTR(name),priority,pastejunk(TARGET_LABEL,pastejunk( pastejunk(x_,name),__LINE__)) DBG_SRC );	return 0;	 }	 static void CPROC name(void)
#define ROOT_ATEXIT(name) static void name(void);	 __declspec(allocate(_ENDSEG_)) static void (*f##name)(void)=name;    static void name(void)
#define ATEXIT(name) PRIORITY_ATEXIT(name,ATEXIT_PRIORITY_DEFAULT)
typedef void(*atexit_priority_proc)(void (*)(void),int,CTEXTSTR DBG_PASS);
#define PRIORITY_ATEXIT(name,priority) static void CPROC name(void);    static int schedule_atexit_##name(void);	   __declspec(allocate(_STARTSEG_)) void (CPROC*pastejunk(TARGET_LABEL,pastejunk( x_##name,__LINE__)))(void) = (void(CPROC*)(void))schedule_atexit_##name;	 static int schedule_atexit_##name(void) {	                 RegisterPriorityShutdownProc( name,TOSTR(name),priority,pastejunk(TARGET_LABEL,pastejunk( x_##name,__LINE__)) DBG_SRC );	return 0;	 }	                                       static void CPROC name(void)
#define ATEXIT_PRIORITY(name,priority) PRIORITY_ATEXIT(name,priority)
#endif
#ifdef __cplusplus_cli
#define InvokeDeadstart() do {	                                              TEXTCHAR myname[256];HMODULE mod;	 mod=LoadLibrary("sack_bag.dll");if(mod){           void(*rsp)(void);	 if((rsp=((void(*)(void))(GetProcAddress( mod, "RunDeadstart"))))){rsp();}else{lprintf( "Hey failed to get proc %d", GetLastError() );}	FreeLibrary( mod); }} while(0)
#else
#endif
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
//extern uint32_t deadstart_complete;
//#define DEADSTART_LINK uint32_t *deadstart_link_couple = &deadstart_complete; // make sure we reference this symbol
//#pragma data_seg(".CRT$XCAA")
//extern void __cdecl __security_init_cookie(void);
//static _CRTALLOC(".CRT$XCAA") _PVFV init_cookie = __security_init_cookie;
//#pragma data_seg()
//------------------------------------------------------------------------------------
// UNDEFINED
//------------------------------------------------------------------------------------
#else
#error "there's nothing I can do to wrap PRELOAD() or ATEXIT()!"
/* This is the most basic way to define some startup code that
   runs at some point before the program starts. This code is
   declared as static, so the same preload initialization name
   can be used in multiple files.
   <link sack::app::deadstart, See Also.>                      */
#define PRELOAD(name)
#endif
// the higher the number the earlier it is run
#define ATEXIT_PRIORITY_SHAREMEM  1
#define ATEXIT_PRIORITY_THREAD_SEMS ATEXIT_PRIORITY_SYSLOG-1
#define ATEXIT_PRIORITY_SYSLOG    35
#define ATEXIT_PRIORITY_MSGCLIENT 85
#define ATEXIT_PRIORITY_DEFAULT   90
#define ATEXIT_PRIORITY_TIMERS   (ATEXIT_PRIORITY_DEFAULT+1)
// this is the first exit to be run.
// under linux it is __attribute__((destructor))
// under all it is registered during preload as atexit()
// only the runexits in deadstart should use ROOT_ATEXIT
#ifdef __WATCOMC__
#define ATEXIT_PRIORITY_ROOT 255
#else
#define ATEXIT_PRIORITY_ROOT 101
#endif
SACK_DEADSTART_NAMESPACE_END
USE_SACK_DEADSTART_NAMESPACE
#endif
#ifdef PROCREG_SOURCE
#define PROCREG_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define PROCREG_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
#ifdef __cplusplus_cli
//using namespace System;
#endif
#   define _INTERFACE_NAMESPACE namespace Interface {
#   define _INTERFACE_NAMESPACE_END }
#define PROCREG_NAMESPACE namespace sack { namespace app { namespace registry {
#define _PROCREG_NAMESPACE namespace registry {
#define _APP_NAMESPACE namespace app {
#define PROCREG_NAMESPACE_END }}}
//extern "C"  {
#else
#   define _INTERFACE_NAMESPACE
#   define _INTERFACE_NAMESPACE_END
#define _PROCREG_NAMESPACE
#define _APP_NAMESPACE
#define PROCREG_NAMESPACE
#define PROCREG_NAMESPACE_END
#endif
SACK_NAMESPACE
/* Deadstart is support which differs per compiler, but allows
   applications access a C++ feature - static classes with
   constructors that initialize at loadtime, but, have the
   feature that you can create threads. Deadstart code is run
   after the DLL load lock under windows that prevents creation
   of threads; however, deadstart is run before main. Deadstart
   routines can have a priority. Certain features require others
   to be present always. This allows explicit control of
   priority unlink using classes with static constructors, which
   requires ordering of objects to provide linking order. Also
   provides a similar registration mechanism for atexit, but
   extending with priority. Deadstop registrations are done
   sometime during normal C atexit() handling, but may be
   triggered first by calling BAG_Exit.
   Registry offers support to register functions, and data under
   a hierarchy of names. Names are kept in a string cache, which
   applications can take benefit of. Strings will exist only a
   single time. This table could be saved, and a look-aside
   table for language translation purposes. Registry is the
   support that the latest PSI relies on for registering event
   callbacks for controls. The registry was always used, but,
   the access to it was encapsulated by DoRegisterControl
   registering the appropriate methods.                          */
	_APP_NAMESPACE
   /* Contains methods dealing with registering routines and values
      in memory. Provisions are available to save the configuration
      state, but the best that can be offered here would be a
      translation tool for text strings. The namespace is savable,
      but most of the content of the registration space are short
      term pointers. Namespace containing registry namespace.
      old notes - very discongruant probably should delete them.
      Process name registry
      it's a tree of names.
      there are paths, and entries
      paths are represented as class_name
      PCLASSROOT is also a suitable class name
      PCLASSROOT is defined as a valid CTEXTSTR.
      there is (apparently) a name that is not valid as a path name
      that is TREE
      guess.
      POINTER in these two are equal to (void(*)(void)) but -
      that's rarely the most useful thing... so
      name class is a tree of keys... /\<...\>
      psi/control/## might contain procs Init Destroy Move
      RegAlias( "psi/control/3", "psi/control/button"
      ); psi/control/button and psi/control/3 might reference the
      same routines
      psi/frame Init Destroy Move memlib Alloc Free
      network/tcp
      I guess name class trees are somewhat shallow at the moment
      not going beyond 1-3 layers
      names may eventually be registered and reference out of body
      services, even out of box...
      the values passed as returntype and parms/args need not be
      real genuine types, but do need to be consistant between the
      registrant and the requestor... this provides for full name
      dressing, return type and paramter type may both cause
      overridden functions to occur...                              */
_PROCREG_NAMESPACE
#ifndef REGISTRY_STRUCTURE_DEFINED
	// make these a CTEXTSTR to be compatible with name_class...
#ifdef __cplusplus
	// because of name mangling and stronger type casting
	// it becomes difficult to pass a tree_def_tag * as a CTEXTSTR classname
	// as valid as this is.
	typedef struct tree_def_tag const * PCLASSROOT;
#else
	typedef CTEXTSTR PCLASSROOT;
#endif
	typedef void (CPROC *PROCEDURE)(void);
#ifdef __cplusplus_cli
	typedef void (__stdcall *STDPROCEDURE)(array<System::Object^>^);
#endif
#else
	typedef struct tree_def_tag const * PCLASSROOT;
	typedef void (CPROC *PROCEDURE)(void);
#ifdef __cplusplus_cli
	typedef void (__stdcall *STDPROCEDURE)(array<System::Object^>^);
#endif
#endif
/* CheckClassRoot reads for a path of names, but does not create
   it if it does not exist.                                      */
PROCREG_PROC( PCLASSROOT, CheckClassRoot )( CTEXTSTR class_name );
/* \Returns a PCLASSROOT of a specified path. The path may be
   either a PCLASSROOT or a text string indicating the path. the
   Ex versions allow passing a base PCLASSROOT path and an
   additional subpath to get. GetClassRoot will always create
   the path if it did not exist before, and will always result
   with a root.
   Remarks
   a CTEXTSTR (plain text string, probably wide character if
   compiled unicode) and a PCLASSROOT are always
   interchangeable. Though you may need a forced type cast, I
   have defined both CTEXTSTR and PCLASSROOT function overloads
   for c++ compiled code, and C isn't so unkind about the
   conversion. I think problem might lie that CTEXTSTR has a
   const qualifier and PCLASSROOT doesn't (but should).
   Example
   <code lang="c++">
   PCLASSROOT root = GetClassRoot( "psi/resource" );
   // returns the root of all resource names.
   </code>
   <code>
   PCLASSROOT root2 = GetClassRootEx( "psi/resource", "buttons" );
   </code>                                                         */
PROCREG_PROC( PCLASSROOT, GetClassRoot )( CTEXTSTR class_name );
/* <combine sack::app::registry::GetClassRoot@CTEXTSTR>
   \ \                                                  */
PROCREG_PROC( PCLASSROOT, GetClassRootEx )( PCLASSROOT root, CTEXTSTR name_class );
#ifdef __cplusplus
/* <combine sack::app::registry::GetClassRoot@CTEXTSTR>
   \ \                                                  */
PROCREG_PROC( PCLASSROOT, GetClassRoot )( PCLASSROOT class_name );
/* <combine sack::app::registry::GetClassRoot@CTEXTSTR>
   \ \                                                  */
PROCREG_PROC( PCLASSROOT, GetClassRootEx )( PCLASSROOT root, PCLASSROOT name_class );
#endif
/* Fills a string with the path name to the specified node */
PROCREG_PROC( int, GetClassPath )( TEXTSTR out, size_t len, PCLASSROOT root );
PROCREG_PROC( void, SetInterfaceConfigFile )( TEXTCHAR *filename );
/* Get[First/Next]RegisteredName( "classname", &amp;data );
   these operations are not threadsafe and multiple thread
   accesses will cause mis-stepping
   These functions as passed the address of a POINTER. this
   POINTER is for the use of the browse routines and should is
   meaningless to he calling application.
   Parameters
   root :       The root to search from
   classname :  A sub\-path from the root to search from
   data :       the address of a pointer that keeps track of
                information about the search. (opaque to user)
   Example
   Usage:
   <code lang="c++">
   CTEXTSTR result;
   POINTER data = NULL;
   for( result = GetFirstRegisteredName( "some/class/path", &amp;data );
        \result;
        \result = GetNextRegisteredName( &amp;data ) )
   {
        // result is a string name of the current node.
        // can use that name and GetRegistered____ (function/int/value)
        if( NameHasBranches( &amp;data ) ) // for consitancy in syntax
        {
            // consider recursing through tree, name becomes a valid classname for GetFirstRegisteredName()
        }
   }
   </code>                                                                                                  */
PROCREG_PROC( CTEXTSTR, GetFirstRegisteredNameEx )( PCLASSROOT root, CTEXTSTR classname, PCLASSROOT *data );
#ifdef __cplusplus
/* <combine sack::app::registry::GetFirstRegisteredNameEx@PCLASSROOT@CTEXTSTR@PCLASSROOT *>
   \ \                                                                                      */
	PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( PCLASSROOT classname, PCLASSROOT *data );
#endif
/* <combine sack::app::registry::GetFirstRegisteredNameEx@PCLASSROOT@CTEXTSTR@PCLASSROOT *>
   \ \                                                                                      */
PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( CTEXTSTR classname, PCLASSROOT *data );
/* Steps to the next registered name being browsed. Is passed
   only the pointer to data. See GetFirstRegisteredName for
   usage.
   See Also
   <link sack::app::registry::GetFirstRegisteredNameEx@PCLASSROOT@CTEXTSTR@PCLASSROOT *, sack::app::registry::GetFirstRegisteredNameEx Function> */
PROCREG_PROC( CTEXTSTR, GetNextRegisteredName )( PCLASSROOT *data );
/* When using GetFirstRegisteredName and GetNextRegisteredName
   to browse through names, this function is able to get the
   current PCLASSROOT of the current node, usually you end up
   with just the content of that registered name.
   \result with the current node ( useful for pulling registered
   subvalues like description, or file and line )
                                                                 */
PROCREG_PROC( PCLASSROOT, GetCurrentRegisteredTree )( PCLASSROOT *data );
#ifdef __cplusplus
//PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( CTEXTSTR classname, POINTER *data );
//PROCREG_PROC( CTEXTSTR, GetNextRegisteredName )( POINTER *data );
#endif
// while doing a scan for registered procedures, allow applications to check for branches
//PROCREG_PROC( int, NameHasBranches )( POINTER *data );
PROCREG_PROC( int, NameHasBranches )( PCLASSROOT *data );
// while doing a scan for registered procedures, allow applications to ignore aliases...
PROCREG_PROC( int, NameIsAlias )( PCLASSROOT *data );
/*
 * RegisterProcedureExx(
 *
 */
 // root name or PCLASSROOT of base path
PROCREG_PROC( int, RegisterProcedureExx )( PCLASSROOT root
 // an additional path on root
													  , CTEXTSTR name_class
 // the name of the value entry saved in the tree
													  , CTEXTSTR public_name
 // the text return type of this function - may be checked to validate during GetRegisteredProcedure
													  , CTEXTSTR returntype
 // name of the library this symbol is in - may be checked to validate during GetRegisteredProcedure
													  , CTEXTSTR library
 // actual C function name in library - may be checked to validate during GetRegisteredProcedure
													  , CTEXTSTR name
 // preferably the raw argument string of types and no variable references "([type][,type]...)"
													  , CTEXTSTR args
 // file and line of the calling application.  May be no parameter in release mode.
													  DBG_PASS
													  );
/*
 * RegisterProcedureEx( root       // root path
 *                    , name_class // additional name
 *                    , nice_name  // nice name
 *                    , return type not in quotes  'void'
 *                    , function_name in quotes '"Function"'
 *                    , args not in quotes '(int,char,float,UserType*)'
 */
#define RegisterProcedureEx(root,nc,n,rtype,proc,args)  RegisterProcedureExx( (root),(nc),(n),#rtype,TARGETNAME,(proc), #args DBG_SRC)
/*
 * RegisterProcedure( name_class // additional name
 *                    , nice_name  // nice name
 *                    , return type not in quotes  'void'
 *                    , function_name in quotes '"Function"'
 *                    , args not in quotes '(int,char,float,UserType*)'
 */
#define RegisterProcedure(nc,n,rtype,proc,args)  RegisterProcedureExx( NULL, (nc),(n),#rtype,TARGETNAME,(proc), #args DBG_SRC)
/*
 * Branches on the tree may be aliased together to form a single branch
 *
 */
				// RegisterClassAlias( "psi/control/button", "psi/control/3" );
				// then the same set of values can be referenced both ways with
				// really only a single modified value.
/* parameters to RegisterClassAliasEx are the original name, and the new alias name for the origianl branch*/
PROCREG_PROC( PCLASSROOT, RegisterClassAliasEx )( PCLASSROOT root, CTEXTSTR original, CTEXTSTR alias );
/* <combine sack::app::registry::RegisterClassAliasEx@PCLASSROOT@CTEXTSTR@CTEXTSTR>
   \ \                                                                              */
PROCREG_PROC( PCLASSROOT, RegisterClassAlias )( CTEXTSTR original, CTEXTSTR newalias );
// root, return, public, args, address
PROCREG_PROC( PROCEDURE, ReadRegisteredProcedureEx )( PCLASSROOT root
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR parms
																  );
#define ReadRegisteredProcedure( root,rt,a) ((rt(CPROC*)a)ReadRegisteredProcedureEx(root,#rt,#a))
/* Gets a function that has been registered. */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( PCLASSROOT root
																	 , PCLASSROOT name_class
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR name
																	 , CTEXTSTR parms
																	 );
#define GetRegisteredProcedureExx(root,nc,rt,n,a) ((rt (CPROC*)a)GetRegisteredProcedureExxx(root,nc,#rt,n,#a))
#define GetRegisteredProcedure2(nc,rtype,name,args) (rtype (CPROC*)args)GetRegisteredProcedureEx((nc),#rtype, name, #args )
#define GetRegisteredProcedureNonCPROC(nc,rtype,name,args) (rtype (*)args)GetRegisteredProcedureEx((nc),#rtype, name, #args )
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureEx )( PCLASSROOT name_class
																	, CTEXTSTR returntype
																	, CTEXTSTR name
																	, CTEXTSTR parms
																	);
PROCREG_PROC( LOGICAL, RegisterFunctionExx )( PCLASSROOT root
													, PCLASSROOT name_class
													, CTEXTSTR public_name
													, CTEXTSTR returntype
													, PROCEDURE proc
													 , CTEXTSTR args
													 , CTEXTSTR library
													 , CTEXTSTR real_name
													  DBG_PASS
														  );
#ifdef __cplusplus
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( CTEXTSTR root
																	 , CTEXTSTR name_class
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR name
																	 , CTEXTSTR parms
																	 );
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( CTEXTSTR root
																	 , PCLASSROOT name_class
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR name
																	 , CTEXTSTR parms
																	 );
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( PCLASSROOT root
																	 , CTEXTSTR name_class
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR name
																	 , CTEXTSTR parms
																	 );
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureEx )( CTEXTSTR name_class
																	, CTEXTSTR returntype
																	, CTEXTSTR name
																	, CTEXTSTR parms
																	);
PROCREG_PROC( LOGICAL, RegisterFunctionExx )( CTEXTSTR root
													, CTEXTSTR name_class
													, CTEXTSTR public_name
													, CTEXTSTR returntype
                                       , PROCEDURE proc
													 , CTEXTSTR args
													 , CTEXTSTR library
													 , CTEXTSTR real_name
													  DBG_PASS
														  );
#endif
//#define RegisterFunctionExx( r,nc,p,rt,proc,ar ) RegisterFunctionExx( r,nc,p,rt,proc,ar,TARGETNAME,NULL DBG_SRC )
//#define RegisterFunctionEx(r,nc,pn,rt,proc,args,lib,rn) RegisterFunctionExx(r,nc,pn,rt,proc,args,lib,rn DBG_SRC)
#define RegisterFunctionEx( root,proc,rt,pn,a) RegisterFunctionExx( root,NULL,pn,rt,(PROCEDURE)(proc),a,NULL,NULL DBG_SRC )
#define RegisterFunction( nc,proc,rt,pn,a) RegisterFunctionExx( (PCLASSROOT)NULL,nc,pn,rt,(PROCEDURE)(proc),a,TARGETNAME,NULL DBG_SRC )
#define SimpleRegisterMethod(r,proc,rt,name,args) RegisterFunctionExx(r,NULL,name,rt,(PROCEDURE)proc,args,NULL,NULL DBG_SRC )
#define GetRegisteredProcedure(nc,rtype,name,args) (rtype (CPROC*)args)GetRegisteredProcedureEx((nc),#rtype, #name, #args )
PROCREG_PROC( int, RegisterIntValueEx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, uintptr_t value );
PROCREG_PROC( int, RegisterIntValue )( CTEXTSTR name_class, CTEXTSTR name, uintptr_t value );
PROCREG_PROC( int, RegisterValueExx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal, CTEXTSTR value );
PROCREG_PROC( int, RegisterValueEx )( CTEXTSTR name_class, CTEXTSTR name, int bIntVal, CTEXTSTR value );
PROCREG_PROC( int, RegisterValue )( CTEXTSTR name_class, CTEXTSTR name, CTEXTSTR value );
/* \ \
   Parameters
   root :        Root class to start searching from
   name_class :  An additional sub\-path to get the name from
   name :        the name within the path specified
   bIntVal :     a true/false whether to get the string or
                 integer value from the specified node.
   Returns
   A pointer to a string if bIntVal is not set. (NULL if there
   was no string).
   Otherwise will be an int shorter than or equal to the size of
   a pointer, which should be cast to an int if bIntVal is set,
   and there is a value registered there. Probably 0 if no
   value, so registered 0 value and no value is
   indistinguisable.                                             */
PROCREG_PROC( CTEXTSTR, GetRegisteredValueExx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal );
/* <combine sack::app::registry::GetRegisteredValueExx@PCLASSROOT@CTEXTSTR@CTEXTSTR@int>
   \ \                                                                                   */
PROCREG_PROC( CTEXTSTR, GetRegisteredValueEx )( CTEXTSTR name_class, CTEXTSTR name, int bIntVal );
/* <combine sack::app::registry::GetRegisteredValueExx@PCLASSROOT@CTEXTSTR@CTEXTSTR@int>
   \ \                                                                                   */
PROCREG_PROC( CTEXTSTR, GetRegisteredValue )( CTEXTSTR name_class, CTEXTSTR name );
#ifdef __cplusplus
/* <combine sack::app::registry::GetRegisteredValueExx@PCLASSROOT@CTEXTSTR@CTEXTSTR@int>
   \ \                                                                                   */
PROCREG_PROC( CTEXTSTR, GetRegisteredValueExx )( CTEXTSTR root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal );
PROCREG_PROC( int, RegisterIntValueEx )( CTEXTSTR root, CTEXTSTR name_class, CTEXTSTR name, uintptr_t value );
#endif
/* This is like GetRegisteredValue, but takes the address of the
   type to return into instead of having to cast the final
   \result.
   if bIntValue, result should be passed as an (&amp;int)        */
PROCREG_PROC( int, GetRegisteredStaticValue )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name
															, CTEXTSTR *result
															, int bIntVal );
#define GetRegisteredStaticIntValue(r,nc,name,result) GetRegisteredStaticValue(r,nc,name,(CTEXTSTR*)result,TRUE )
/* <combine sack::app::registry::GetRegisteredValueExx@PCLASSROOT@CTEXTSTR@CTEXTSTR@int>
   \ \                                                                                   */
PROCREG_PROC( int, GetRegisteredIntValueEx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name );
/* <combine sack::app::registry::GetRegisteredIntValueEx@PCLASSROOT@CTEXTSTR@CTEXTSTR>
   \ \                                                                                 */
PROCREG_PROC( int, GetRegisteredIntValue )( CTEXTSTR name_class, CTEXTSTR name );
#ifdef __cplusplus
/* <combine sack::app::registry::GetRegisteredIntValueEx@PCLASSROOT@CTEXTSTR@CTEXTSTR>
   \ \                                                                                 */
PROCREG_PROC( int, GetRegisteredIntValue )( PCLASSROOT name_class, CTEXTSTR name );
#endif
typedef void (CPROC*OpenCloseNotification)( POINTER, uintptr_t );
#define PUBLIC_DATA( public, struct, open, close )	    PRELOAD( Data_##open##_##close ) {	 RegisterDataType( "system/data/structs"	        , public, sizeof(struct)	    , (OpenCloseNotification)open, (OpenCloseNotification)close ); }
#define PUBLIC_DATA_EX( public, struct, open, update, close )	    PRELOAD( Data_##open##_##close ) {	 RegisterDataTypeEx( "system/data/structs"	        , public, sizeof(struct)	    , (OpenCloseNotification)open, (OpenCloseNotification)update, (OpenCloseNotification)close ); }
#define GET_PUBLIC_DATA( public, type, instname )    (type*)CreateRegisteredDataType( "system/data/structs", public, instname )
PROCREG_PROC( uintptr_t, RegisterDataType )( CTEXTSTR classname
												 , CTEXTSTR name
												 , uintptr_t size
												 , OpenCloseNotification open
												 , OpenCloseNotification close );
/* Registers a structure as creatable in shared memory by name.
   So a single name of the structure can be used to retrieve a
   pointer to one created.
   Example
   \ \
   <code lang="c++">
   POINTER p = CreateRegisteredDataType( "My types", "my_registered_type", "my instance" );
   // p will result to a region of type 'my_registered_type' called 'my_instance'
   // if it did not exist, it will be created, otherwise the one existing is returned.
   </code>
   Parameters
   root :          optional root name (ex version uses this)
   classname :     path to the type
   name :          name of the type to create an instance of
   instancename :  a name for the instance created.                                         */
PROCREG_PROC( uintptr_t, CreateRegisteredDataType)( CTEXTSTR classname
																 , CTEXTSTR name
																 , CTEXTSTR instancename );
PROCREG_PROC( uintptr_t, RegisterDataTypeEx )( PCLASSROOT root
													, CTEXTSTR classname
													, CTEXTSTR name
													, uintptr_t size
													, OpenCloseNotification Open
													, OpenCloseNotification Close );
/* <combine sack::app::registry::CreateRegisteredDataType@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                */
PROCREG_PROC( uintptr_t, CreateRegisteredDataTypeEx)( PCLASSROOT root
																	, CTEXTSTR classname
																	, CTEXTSTR name
																	, CTEXTSTR instancename );
/* Outputs through syslog a tree dump of all names registered. */
PROCREG_PROC( void, DumpRegisteredNames )( void );
/* Dumps through syslog all names registered from the specified
   root point. (instead of dumping the whole tree)              */
PROCREG_PROC( void, DumpRegisteredNamesFrom )( PCLASSROOT root );
PROCREG_PROC( int, SaveTree )( void );
PROCREG_PROC( int, LoadTree )( void );
#define METHOD_PTR(type,name) type (CPROC *_##name)
#define DMETHOD_PTR(type,name) type (CPROC **_##name)
#define METHOD_ALIAS(i,name) ((i)->_##name)
#define PDMETHOD_ALIAS(i,name) (*(i)->_##name)
/* Releases an interface. When interfaces are registered, they
   register with a OnGetInterface and an OnDropInterface
   callback so that it may do additional work to cleanup from
   giving you a copy of the interface.
   Example
   <code lang="c++">
   POINTER p = GetInterface( "image" );
   DropInterface( p );
   </code>                                                     */
PROCREG_PROC( void, DropInterface )( CTEXTSTR pServiceName, POINTER interface_x );
PROCREG_PROC( POINTER, GetInterface_v4 )( CTEXTSTR pServiceName, LOGICAL ReadConfig, int quietFail DBG_PASS );
#define GetInterfaceV4( a, b )  GetInterface_v4( a, FALSE, b DBG_SRC )
/* \Returns the pointer to a registered interface. This is
   typically a structure that contains pointer to functions. Takes
   a text string to an interface. Interfaces are registered at a
   known location in the registry tree.                            */
PROCREG_PROC( POINTER, GetInterfaceDbg )( CTEXTSTR pServiceName DBG_PASS );
#define GetInterface(n) GetInterfaceDbg( n DBG_SRC )
#define GetRegisteredInterface(name) GetInterface(name)
PROCREG_PROC( LOGICAL, RegisterInterfaceEx )( CTEXTSTR name, POINTER(CPROC*load)(void), void(CPROC*unload)(POINTER) DBG_PASS );
//PROCREG_PROC( LOGICAL, RegisterInterface )(CTEXTSTR name, POINTER( CPROC*load )(void), void(CPROC*unload)(POINTER));
#define RegisterInterface(n,l,u) RegisterInterfaceEx( n,l,u DBG_SRC )
// unregister a function, should be smart and do full return type
// and parameters..... but for now this only references name, this indicates
// that this has not been properly(fully) extended, and should be layered
// in such a way as to allow this function work in it's minimal form.
PROCREG_PROC( int, ReleaseRegisteredFunctionEx )( PCLASSROOT root
													, CTEXTSTR name_class
													, CTEXTSTR public_name
													  );
#define ReleaseRegisteredFunction(nc,pn) ReleaseRegisteredFunctionEx(NULL,nc,pn)
/* This is a macro used to paste two symbols together. */
#define paste_(a,b) a##b
#define paste(a,b) paste_(a,b)
#define preproc_symbol(a)  a
#ifdef __cplusplus
#define EXTRA_PRELOAD_SYMBOL _
#else
#define EXTRA_PRELOAD_SYMBOL
#endif
#define DefineRegistryMethod2_i(task,name,classtype,methodname,desc,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRIORITY_PRELOAD( paste(paste(paste(paste(Register,name),Method),preproc_symbol(EXTRA_PRELOAD_SYMBOL)),line), SQL_PRELOAD_PRIORITY ) {	  SimpleRegisterMethod( task "/" classtype, paste(name,line)	  , #returntype, methodname, #argtypes );    RegisterValue( task "/" classtype "/" methodname, "Description", desc ); }	                                                                          static returntype CPROC paste(name,line)
#define DefineRegistryMethod2(task,name,classtype,methodname,desc,returntype,argtypes,line)	   DefineRegistryMethod2_i(task,name,classtype,methodname,desc,returntype,argtypes,line)
/* Dekware uses this macro.
     passes preload priority override.
	 so it can register new internal commands before initial macros are run.
*/
#define DefineRegistryMethod2P_i(priority,task,name,classtype,methodname,desc,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRIORITY_PRELOAD( paste(paste(paste(paste(Register,name),Method),preproc_symbol(EXTRA_PRELOAD_SYMBOL)),line), priority ) {	  SimpleRegisterMethod( task "/" classtype, paste(name,line)	  , #returntype, methodname, #argtypes );    RegisterValue( task "/" classtype "/" methodname, "Description", desc ); }	                                                                          static returntype CPROC paste(name,line)
/* This macro indirection is to resolve inner macros like "" around text.  */
#define DefineRegistryMethod2P(priority,task,name,classtype,methodname,desc,returntype,argtypes,line)	   DefineRegistryMethod2P_i(priority,task,name,classtype,methodname,desc,returntype,argtypes,line)
/*
    This method is used by PSI/Intershell.
	no description
*/
#define DefineRegistryMethod_i(task,name,classtype,classbase,methodname,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRELOAD( paste(paste(Register##name##Button,preproc_symbol(EXTRA_PRELOAD_SYMBOL)),line) ) {	  SimpleRegisterMethod( task "/" classtype "/" classbase, paste(name,line)	  , #returntype, methodname, #argtypes ); }	                                                                          static returntype CPROC paste(name,line)
#define DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,line)	   DefineRegistryMethod_i(task,name,classtype,classbase,methodname,returntype,argtypes,line)
/*
#define _0_DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,line)	   static returntype _1__DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,line)
#define DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes)	  _1__DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,__LINE__)
*/
// this macro is used for ___DefineRegistryMethodP. Because this is used with complex names
// an extra define wrapper of priority_preload must be used to fully resolve paramters.
/*
#define DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRIOR_PRELOAD( paste(paset(Register##name##Button,preproc_symbol(EXTRA_PRELOAD_SYMBOL),line), priority ) {	  SimpleRegisterMethod( task "/" classtype "/" classbase, paste(name,line)	  , #returntype, methodname, #argtypes ); }	                                                                          static returntype CPROC paste(name,line)
*/
/* <combine sack::app::registry::SimpleRegisterMethod>
   General form to build a registered procedure. Used by simple
   macros to create PRELOAD'ed registered functions. This flavor
   requires the user to provide 'static' and a return type that
   matches the return type specified in the macro. This makes
   usage most C-like, and convenient to know what the return
   value of a function should be (if any).
   Parameters
   priority :    The preload priority to load at.
   task :        process level name registry. This would be
                 "Intershell" or "psi" or some other base prefix.
                 The prefix can contain a path longer than 1
                 level.
   name :        This is the function name to build. (Can be used
                 for link debugging sometimes)
   classtype :   class of the name being registered
   methodname :  name of the routine to register
   returntype :  the literal type of the return type of this
                 function (void, int, PStruct* )
   argtypes :    Argument signature of the routine in parenthesis
   line :        this is usually filled with __LINE__ so that the
                 same function name (name) will be different in
                 different files (even in the same file)
   Remarks
   This registers a routine at the specified preload priority.
   Registers under [task]/[classname]/methodname. The name of
   the registered routine from a C perspective is [name][line]. This
   function is not called directly, but will only be referenced
   from the registered name.
   Example
   See <link sack::app::registry::GetFirstRegisteredNameEx@PCLASSROOT@CTEXTSTR@PCLASSROOT *, GetFirstRegisteredNameEx> */
/*
#define _1__DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)	   _2___DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)
#define _0_DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)	   _1__DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)
#define DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes)	  _0_DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,__LINE__)
*/
#define DefineRegistrySubMethod_i(task,name,classtype,classbase,methodname,subname,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRELOAD( paste(paste(Register##name##Button,preproc_symbol(EXTRA_PRELOAD_SYMBOL)),line) ) {	  SimpleRegisterMethod( task "/" classtype "/" classbase "/" methodname, paste(name,line)	  , #returntype, subname, #argtypes ); }	                                                                          static returntype CPROC paste(name,line)
#define DefineRegistrySubMethod(task,name,classtype,classbase,methodname,subname,returntype,argtypes)	  DefineRegistrySubMethod_i(task,name,classtype,classbase,methodname,subname,returntype,argtypes,__LINE__)
/* attempts to use dynamic linking functions to resolve passed
   global name if that fails, then a type is registered for this
   global, and an instance created, so that that instance may be
   reloaded again, otherwise the data in the main application is
   used... actually we should deprecate the dynamic loading
   part, and just register the type.
   SimpleRegisterAndCreateGlobal Simply registers the type as a
   global variable type. Allows creation of the global space
   later.
   Parameters
   name :         name of the pointer to global type to create.<p />text
                  string to register this created global as.
   ppGlobal :     address of the pointer to global memory.
   global_size :  size of the global area to create
   Example
   <code lang="c++">
   typedef struct {
      int data;
   } my_global;
   my_global *global;
   PRELOAD( Init )
   {
       SimpleRegisterAndCreateGlobal( global );
   }
   </code>                                                               */
PROCREG_PROC( void, RegisterAndCreateGlobal )( POINTER *ppGlobal, uintptr_t global_size, CTEXTSTR name );
/* <combine sack::app::registry::RegisterAndCreateGlobal@POINTER *@uintptr_t@CTEXTSTR>
   \ \                                                                                   */
#define SimpleRegisterAndCreateGlobal( name )	 RegisterAndCreateGlobal( (POINTER*)&name, sizeof( *name ), #name )
/* Init routine is called, otherwise a 0 filled space is
   returned. Init routine is passed the pointer to the global
   and the size of the global block the global data block is
   zero initialized.
   Parameters
   ppGlobal :     Address of the pointer to the global region
   global_size :  size of the global region to create
   name :         name of the global region to register (so
                  future users get back the same data area)
   Init :         function to call to initialize the region when
                  created. (doesn't have to be a global. Could be
                  used to implement types that have class
                  constructors \- or not, since there's only one
                  instance of a global \- this is more for
                  singletons).
   Example
   <code>
   typedef struct {
      int data;
   } my_global;
   my_global *global;
   </code>
   <code lang="c++">
   void __cdecl InitRegion( POINTER region, uintptr_t region_size )
   {
       // do something to initialize 'region'
   }
   PRELOAD( InitGlobal )
   {
       SimpleRegisterAndCreateGlobalWithInit( global, InitRegion );
   }
   </code>                                                          */
PROCREG_PROC( void, RegisterAndCreateGlobalWithInit )( POINTER *ppGlobal, uintptr_t global_size, CTEXTSTR name, void (CPROC*Init)(POINTER,uintptr_t) );
/* <combine sack::app::registry::RegisterAndCreateGlobalWithInit@POINTER *@uintptr_t@CTEXTSTR@void __cdecl*InitPOINTER\,uintptr_t>
   \ \                                                                                                                              */
#define SimpleRegisterAndCreateGlobalWithInit( name,init )	 RegisterAndCreateGlobalWithInit( (POINTER*)&name, sizeof( *name ), #name, init )
/* a tree dump will result with dictionary names that may translate automatically. */
/* This has been exported as a courtesy for StrDup.
 * this routine MAY result with a translated string.
 * this routine MAY result with the same pointer.
 * this routine MAY need to be improved if MANY more strdups are replaced
 * Add a binary tree search index when large.
 * Add a transaltion tree index at the same time.
 */
PROCREG_PROC( CTEXTSTR, SaveNameConcatN )( CTEXTSTR name1, ... );
// no space stripping, saves literal text
PROCREG_PROC( CTEXTSTR, SaveText )( CTEXTSTR text );
PROCREG_NAMESPACE_END
#ifdef __cplusplus
	using namespace sack::app::registry;
#endif
#endif
#ifdef __cplusplus
#define _OPTION_NAMESPACE namespace options {
#define _OPTION_NAMESPACE_END }
#define USE_OPTION_NAMESPACE	 using namespace sack::sql::options;
#else
#define _OPTION_NAMESPACE
#define _OPTION_NAMESPACE_END
#define USE_OPTION_NAMESPACE
#endif
SACK_NAMESPACE
   _SQL_NAMESPACE
	/* Contains methods for saving and recovering options from a
	   database. If enabled, will use a local option.db sqlite
	   database. Use EditOptions application to modify options. Can
	   use any database connection, but sql.config file will specify
	   'option.db' to start.                                         */
	_OPTION_NAMESPACE
#define SACK_OPTION_NAMESPACE SACK_NAMESPACE _SQL_NAMESPACE _OPTION_NAMESPACE
#define SACK_OPTION_NAMESPACE_END _OPTION_NAMESPACE_END _SQL_NAMESPACE_END SACK_NAMESPACE_END
#ifdef SQLGETOPTION_SOURCE
#define SQLGETOPTION_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SQLGETOPTION_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifndef __NO_INTERFACES__
   _INTERFACE_NAMESPACE
/* Defines a set of functions that can be registered as an
   interface, and the interface can be used for saving options. Module
   ideas might be to save into the windows registry system or
   into INI files.                                                     */
typedef struct option_interface_tag
{
   // these provide simple section, key, value queries.
	METHOD_PTR( size_t, GetPrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTSTR pBuffer, size_t nBuffer, CTEXTSTR pININame );
	METHOD_PTR( int32_t, GetPrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame );
	METHOD_PTR( size_t, GetProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTSTR pBuffer, size_t nBuffer );
	METHOD_PTR( int32_t, GetProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval );
   // these provide an additional level of abstraction - the ini file
	METHOD_PTR( LOGICAL, WritePrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile );
	METHOD_PTR( int32_t, WritePrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, CTEXTSTR pINIFile );
	METHOD_PTR( LOGICAL, WriteProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue );
	METHOD_PTR( int32_t, WriteProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value );
   // these offer(expose) the option to be quiet
	METHOD_PTR( size_t, GetPrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTSTR pBuffer, size_t nBuffer, CTEXTSTR pININame, LOGICAL bQuiet );
	METHOD_PTR( int32_t, GetPrivateProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame, LOGICAL bQuiet );
	METHOD_PTR( size_t, GetProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTSTR pBuffer, size_t nBuffer, LOGICAL bQuiet );
	METHOD_PTR( int32_t, GetProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval, LOGICAL bQuiet );
	METHOD_PTR( LOGICAL, WriteProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL flush );
	METHOD_PTR( LOGICAL, WritePrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL commit );
} *POPTION_INTERFACE;
#define GetOptionInterface() ((POPTION_INTERFACE)GetInterface( "options" ))
//POPTION_INTERFACE GetOptionInterface( void );
//void DropOptionInterface( POPTION_INTERFACE );
#ifndef DEFAULT_OPTION_INTERFACE
#define DEFAULT_OPTION_INTERFACE ((!pOptionInterface)?(pOptionInterface=GetOptionInterface()):pOptionInterface)
#ifdef USES_OPTION_INTERFACE
static POPTION_INTERFACE pOptionInterface;
#ifdef __WATCOMC__
static void UseInterface( void )
{
	// use the value of this function and set pOptionInterface with it
	// makes pOptionInterface marked as used so is UseInterface.
	// Visual Studio pucked on this because converting a function pointer to data pointer
   // but this function should never be called.
   pOptionInterface = (POPTION_INTERFACE)UseInterface;
}
#endif
#endif
#endif
   _INTERFACE_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::sql::options::Interface;
#endif
#endif
#define OptGetPrivateProfileString   METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetPrivateProfileString)
#define OptGetPrivateProfileInt      METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetPrivateProfileInt)
#define OptGetProfileString          METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetProfileString)
#define OptGetProfileInt             METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetProfileInt)
#define OptWritePrivateProfileString METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WritePrivateProfileString)
#define OptWritePrivateProfileInt    METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WritePrivateProfileInt)
#define OptWriteProfileString        METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WriteProfileString)
#define OptWriteProfileInt           METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WriteProfileInt)
#define OptGetPrivateProfileStringEx   METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetPrivateProfileStringEx)
#define OptGetPrivateProfileIntEx      METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetPrivateProfileIntEx)
#define OptGetProfileStringEx          METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetProfileStringEx)
#define OptGetProfileIntEx             METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetProfileIntEx)
#define OptWritePrivateProfileStringEx     METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WritePrivateProfileStringEx)
#define OptWriteProfileStringEx     METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WriteProfileStringEx)
SACK_OPTION_NAMESPACE_END
#endif
SACK_OPTION_NAMESPACE
typedef struct sack_option_tree_family_node *POPTION_TREE_NODE;
typedef struct sack_option_tree_family *POPTION_TREE;
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( size_t, SACK_GetPrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer, CTEXTSTR pININame );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int32_t, SACK_GetPrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( size_t, SACK_GetProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int, SACK_GetProfileBlob )( CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR **pBuffer, size_t *pnBuffer );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int, SACK_GetProfileBlobOdbc )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR **pBuffer, size_t *pnBuffer );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int32_t, SACK_GetProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval );
/* All gets eventually end up here. This function gets a value
   from a database. Functions which return an 'int' use this
   function, but has extra processing to convert the text into a
   number; also if the text is 'Y', or 'y' then the option's int
   value is 1.
   Parameters
   pSection :     Path of the option to retrieve.
   pOptname :     Actual option name to retrieve.
   pDefaultbuf :  Default value if the option doesn't exist
                  already.
   pBuffer :      Pointer to the buffer to get the result
   nBuffer :      size of the result buffer in characters (not
                  bytes).
   pININame :     This is the upper level name. If a function
                  does not have a pININame, then the name
                  "DEFAULT' is used. (pass NULL here for
                  non\-private)
   bQuiet :       Boolean, if configured to prompt the user for
                  option values, this overrides the default to
                  disable prompting.                             */
SQLGETOPTION_PROC( size_t, SACK_GetPrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer, CTEXTSTR pININame, LOGICAL bQuiet );
SQLGETOPTION_PROC( LOGICAL, SACK_WritePrivateOptionStringEx )(PODBC odbc, CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL flush);
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int32_t, SACK_GetPrivateProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame, LOGICAL bQuiet );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( size_t, SACK_GetProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer, LOGICAL bQuiet );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int32_t, SACK_GetProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval, LOGICAL bQuiet );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int32_t, SACK_WritePrivateProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, CTEXTSTR pINIFile, LOGICAL bQuiet );
SQLGETOPTION_PROC( LOGICAL, SACK_WritePrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL bFlush );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( LOGICAL, SACK_WriteProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIfile, LOGICAL flush );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int32_t, SACK_WriteProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, LOGICAL bQuiet );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( LOGICAL, SACK_WritePrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int32_t, SACK_WritePrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, CTEXTSTR pINIFile );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( LOGICAL, SACK_WriteProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( LOGICAL, SACK_WriteOptionString )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int, SACK_WriteProfileBlob )( CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int, SACK_WriteProfileBlobOdbc )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   returns boolean true/false whether the write worked or not.
   \ \                                                                                                            */
SQLGETOPTION_PROC( int, SACK_WritePrivateProfileBlob )( CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer, CTEXTSTR app );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   returns boolean true/false whether the write worked or not.
   \ \                                                                                                            */
SQLGETOPTION_PROC( int, SACK_WritePrivateProfileBlobOdbc )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer,  CTEXTSTR app);
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   returns boolean true/false whether the write worked or not.
   \ \                                                                                                            */
SQLGETOPTION_PROC( int32_t, SACK_WriteProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( size_t, SACK_GetPrivateProfileStringExxx )( PODBC odbc
																				, CTEXTSTR pSection
																				, CTEXTSTR pOptname
																				, CTEXTSTR pDefaultbuf
																				, TEXTCHAR *pBuffer
																				, size_t nBuffer
																				, CTEXTSTR pININame
																				, LOGICAL bQuiet
																				 DBG_PASS
																				);
#ifdef __NO_OPTIONS__
#define SACK_GetProfileInt( s,e,d ) (d)
#define SACK_GetProfileString( s,e,d,b,n ) ((d)?StrCpyEx( b,d,n ):0)
#endif
#define SACK_GetPrivateOptionString( odbc, section, option, default_buf, buf, buf_size, ini_name )	   SACK_GetPrivateProfileStringExxx( odbc, section, option, default_buf, buf, buf_size, ini_name, FALSE DBG_SRC )
#define SACK_GetPrivateOptionStringEx( odbc, section, option, default_buf, buf, buf_size, ini_name, quiet )      SACK_GetPrivateProfileStringExxx( odbc, section, option, default_buf, buf, buf_size, ini_name, quiet DBG_SRC )
#define SACK_GetOptionString( odbc, section, option, default_buf, buf, buf_size )      SACK_GetPrivateProfileStringExxx( odbc, section, option, default_buf, buf, buf_size, NULL, FALSE DBG_SRC )
#define SACK_GetOptionStringEx( odbc, section, option, default_buf, buf, buf_size, quiet )      SACK_GetPrivateProfileStringExxx( odbc, section, option, default_buf, buf, buf_size, NULL, quiet DBG_SRC )
SQLGETOPTION_PROC( int32_t, SACK_GetPrivateProfileIntExx )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame, LOGICAL bQuiet DBG_PASS );
#define SACK_GetPrivateOptionInt( odbc, section, option, default_val, ini_name )	   SACK_GetPrivateProfileIntExx( odbc, section, option, default_val, ini_name, FALSE DBG_SRC )
#define SACK_GetPrivateOptionIntEx( odbc, section, option, default_val, ini_name, quiet )      SACK_GetPrivateProfileIntExx( odbc, section, option, default_val, ini_name, quiet DBG_SRC )
#define SACK_GetOptionInt( odbc, section, option, default_val )      SACK_GetPrivateProfileIntExx( odbc, section, option, default_val, NULL, FALSE DBG_SRC )
#define SACK_GetOptionIntEx( odbc, section, option, default_val, quiet )      SACK_GetPrivateProfileIntExx( odbc, section, option, default_val, NULL, quiet DBG_SRC )
SQLGETOPTION_PROC( CTEXTSTR, GetSystemID )( void );
SQLGETOPTION_PROC( void, EnumOptions )( POPTION_TREE_NODE parent
					 , int (CPROC *Process)(uintptr_t psv, CTEXTSTR name, POPTION_TREE_NODE ID, int flags )
                , uintptr_t psvUser );
SQLGETOPTION_PROC( void, EnumOptionsEx )( PODBC odbc, POPTION_TREE_NODE parent
					 , int (CPROC *Process)(uintptr_t psv, CTEXTSTR name, POPTION_TREE_NODE ID, int flags )
                , uintptr_t psvUser );
SQLGETOPTION_PROC( POPTION_TREE, GetOptionTreeExxx )( PODBC odbc, PFAMILYTREE existing_tree DBG_PASS );
/* Sets the option database to use (does not prevent
   preload/deadstart code from using the old database) but this
   can be used for comparison utilities.
   Parameters
   odbc :  The PODBC connection to use.
   See Also
   PODBC                                                        */
SQLGETOPTION_PROC( POPTION_TREE, SetOptionDatabase )( PODBC odbc );
SQLGETOPTION_PROC( CTEXTSTR, GetDefaultOptionDatabaseDSN )( void );
SQLGETOPTION_PROC( void, SetOptionDatabaseOption )( PODBC odbc );
SQLGETOPTION_PROC( void, BeginBatchUpdate )( void );
SQLGETOPTION_PROC( void, EndBatchUpdate )( void );
SQLGETOPTION_PROC( POPTION_TREE_NODE, GetOptionIndexEx )( POPTION_TREE_NODE parent, const TEXTCHAR *file, const TEXTCHAR *pBranch, const TEXTCHAR *pValue, int bCreate, int bBypassParsing DBG_PASS );
SQLGETOPTION_PROC( POPTION_TREE_NODE, GetOptionIndexExx )( PODBC odbc, POPTION_TREE_NODE parent, CTEXTSTR program, const TEXTCHAR *file, const TEXTCHAR *pBranch, const TEXTCHAR *pValue, int bCreate, int bBypassParsing DBG_PASS );
#define GetOptionIndex(p,f,b,v) GetOptionIndexEx( p,f,b,v,FALSE,FALSE DBG_SRC )
SQLGETOPTION_PROC( size_t, GetOptionStringValueEx )( PODBC odbc, POPTION_TREE_NODE optval, TEXTCHAR **buffer, size_t *len DBG_PASS );
SQLGETOPTION_PROC( void,SetOptionStringValueEx )( PODBC odbc, POPTION_TREE_NODE node, CTEXTSTR value );
SQLGETOPTION_PROC( size_t, GetOptionStringValue )( POPTION_TREE_NODE optval, TEXTCHAR **buffer, size_t *len );
SQLGETOPTION_PROC( LOGICAL, SetOptionStringValue )( POPTION_TREE tree, POPTION_TREE_NODE optval, CTEXTSTR pValue );
SQLGETOPTION_PROC( void, DeleteOption )( POPTION_TREE_NODE iRoot );
SQLGETOPTION_PROC( void, DuplicateOption )( POPTION_TREE_NODE iRoot, CTEXTSTR pNewName );
 // flush the map cache.
SQLGETOPTION_PROC( void, ResetOptionMap )( PODBC odbc );
SQLGETOPTION_PROC( PODBC, GetOptionODBCEx )( CTEXTSTR dsn DBG_PASS );
SQLGETOPTION_PROC( void, DropOptionODBCEx )( PODBC odbc DBG_PASS );
SQLGETOPTION_PROC( PODBC, GetOptionODBC )( CTEXTSTR dsn );
SQLGETOPTION_PROC( void, DropOptionODBC )( PODBC odbc );
#define GetOptionODBC( b) GetOptionODBCEx( b DBG_SRC )
#define DropOptionODBC(a) DropOptionODBCEx( a DBG_SRC )
SQLGETOPTION_PROC( void, FindOptions )( PODBC odbc, PLIST *result_list, CTEXTSTR name );
_OPTION_NAMESPACE_END _SQL_NAMESPACE_END SACK_NAMESPACE_END
	USE_OPTION_NAMESPACE
#endif
#ifndef IDLE_FUNCTIONS_DEFINED
#define IDLE_FUNCTIONS_DEFINED
# ifdef IDLE_SOURCE
#  define IDLE_PROC(type,name) EXPORT_METHOD type CPROC name
# else
#  define IDLE_PROC(type,name) IMPORT_METHOD type CPROC name
# endif
#ifdef __cplusplus
namespace sack {
	namespace timers {
#endif
// return -1 if not the correct thread
// return 0 if no events processed
// return 1 if events were processed
typedef int (CPROC *IdleProc)(uintptr_t);
IDLE_PROC( void, AddIdleProc )( IdleProc Proc, uintptr_t psvUser );
IDLE_PROC( int, RemoveIdleProc )( IdleProc Proc );
IDLE_PROC( int, Idle )( void );
IDLE_PROC( int, IdleFor )( uint32_t dwMilliseconds );
#ifdef __cplusplus
//	namespace timers {
	}
//namespace sack {
}
using namespace sack::timers;
#endif
#endif
/*
 *  Created By Jim Buckeyne
 *
 *  Purpose:
 *    Provides some cross platform/library functionatlity for
 *  filesystem activities.
 *  - File dates, times, stuff like that
 *  - make paths, change paths
 *  - path parsing (like strchr, strrchr, but looking for closest / or \)
 *  - scan a directory for a set of files... using a recursive callback method
 */
#ifndef FILESYSTEM_UTILS_DEFINED
/* Header multiple inclusion protection symbol. */
#define FILESYSTEM_UTILS_DEFINED
#if _MSC_VER >= 1600
#include <share.h>
#endif
#if !defined( UNDER_CE )
#include <fcntl.h>
#if !defined( __LINUX__ )
#include <io.h>
#else
#define LPFILETIME uint64_t*
#define FILETIME uint64_t
#endif
#endif
/* uhmm in legacy usage this was not CPROC, but was unspecified */
#define FILESYS_API CPROC
// DOM-IGNORE-BEGIN
#ifdef FILESYSTEM_LIBRARY_SOURCE
#  define FILESYS_PROC EXPORT_METHOD
#else
#  define FILESYS_PROC IMPORT_METHOD
#endif
// DOM-IGNORE-END
#ifdef __cplusplus
/* defined the file system partial namespace (under
   SACK_NAMESPACE probably)                         */
#define _FILESYS_NAMESPACE  namespace filesys {
/* Define the ending symbol for file system namespace. */
#define _FILESYS_NAMESPACE_END }
/* Defined the namespace of file montior utilities. File monitor
   provides event notification based on file system changes.     */
#define _FILEMON_NAMESPACE  namespace monitor {
/* Define the end symbol for file monitor namespace. */
#define _FILEMON_NAMESPACE_END }
#else
#define _FILESYS_NAMESPACE
#define _FILESYS_NAMESPACE_END
#define _FILEMON_NAMESPACE
#define _FILEMON_NAMESPACE_END
#endif
/* define the file system namespace end. */
#define FILESYS_NAMESPACE_END _FILESYS_NAMESPACE_END SACK_NAMESPACE_END
/* define the file system namespace. */
#define FILESYS_NAMESPACE SACK_NAMESPACE _FILESYS_NAMESPACE
/* Define end file monitor namespace. */
#define FILEMON_NAMESPACE_END _FILEMON_NAMESPACE_END _FILESYS_NAMESPACE_END SACK_NAMESPACE_END
/* Defines the file montior namespace when compiling C++. */
#define FILEMON_NAMESPACE SACK_NAMESPACE _FILESYS_NAMESPACE _FILEMON_NAMESPACE
SACK_NAMESPACE
/* \File system abstractions. A few things like get current path
   may or may not exist on a function.
   Primarily this defines functions 'pathchr' and 'pathrchr'
   which resemble 'strchr' and 'strrchr' but search a string for
   a path character. A path character is either a / or a \\.
   Also in this area is file monitoring functions which support
   methods on windows and linux to get event notifications when
   directories and, by filtering, files that have changed.
                                                                 */
_FILESYS_NAMESPACE
	enum ScanFileFlags {
SFF_DEFAULT = 0,
 // go into subdirectories
SFF_SUBCURSE    = 1,
 // return directory names also
SFF_DIRECTORIES = 2,
 // don't concatenate base with filename to result.
SFF_NAMEONLY    = 4,
 // when matching filename - do not match case.
SFF_IGNORECASE  = 8,
 // don't concatenate base with filename to result, but do build path relative to root specified
SFF_SUBPATHONLY    = 16,
	};
 // flags sent to Process when called with a matching name
enum ScanFileProcessFlags{
 // is a directory...
SFF_DIRECTORY  = 1,
 // this is a drive...
		SFF_DRIVE      = 2,
};
struct file_system_mounted_interface;
/* Extended external file system interface to be able to use external file systems */
struct file_system_interface {
                                                  //filename
	void* (CPROC *open)(uintptr_t psvInstance, const char *, const char *);
                                                 //file *
	int (CPROC *_close)(void *);
                    //file *, buffer, length (to read)
	size_t (CPROC *_read)(void *,void *, size_t);
                    //file *, buffer, length (to write)
	size_t (CPROC *_write)(void*,const void *, size_t);
	size_t (CPROC *seek)( void *, size_t, int whence);
	void  (CPROC *truncate)( void *);
	int (CPROC *_unlink)( uintptr_t psvInstance, const char *);
 // get file size
	size_t (CPROC *size)( void *);
 // get file current position
	size_t (CPROC *tell)( void *);
	int (CPROC *flush )(void *kp);
	int (CPROC *exists)( uintptr_t psvInstance, const char *file );
	LOGICAL (CPROC*copy_write_buffer)(void );
	struct find_cursor *(CPROC *find_create_cursor )( uintptr_t psvInstance, const char *root, const char *filemask );
	int (CPROC *find_first)( struct find_cursor *cursor );
	int (CPROC *find_close)( struct find_cursor *cursor );
	int (CPROC *find_next)( struct find_cursor *cursor );
	char * (CPROC *find_get_name)( struct find_cursor *cursor );
	size_t (CPROC *find_get_size)( struct find_cursor *cursor );
	LOGICAL (CPROC *find_is_directory)( struct find_cursor *cursor );
	LOGICAL (CPROC *is_directory)( uintptr_t psvInstance, const char *cursor );
	LOGICAL (CPROC *rename )( uintptr_t psvInstance, const char *original_name, const char *new_name );
	uintptr_t (CPROC *ioctl)( uintptr_t psvInstance, uintptr_t opCode, va_list args );
	uintptr_t (CPROC *fs_ioctl)(uintptr_t psvInstance, uintptr_t opCode, va_list args);
	uint64_t( CPROC *find_get_ctime )(struct find_cursor *cursor);
	uint64_t( CPROC *find_get_wtime )(struct find_cursor *cursor);
	int ( CPROC* _mkdir )( uintptr_t psvInstance, const char* );
	int ( CPROC* _rmdir )( uintptr_t psvInstance, const char* );
};
/* \ \
   Parameters
   mask :      This is the mask used to compare
   name :      this is the name to compare against using the mask.
   keepcase :  if TRUE, must match case also.
   Returns
   TRUE if name is matched by mask. Otherwise returns FALSE.
   Example
   <code lang="c++">
   if( CompareMask( "*.exe", "program.exe", FALSE ) )
   {
       // then program.exe is matched by the mask.
   }
   </code>
   Remarks
   The mask support standard 'globbing' characters.
   ? matches one character
   \* matches 0 or more characters
   otherwise the literal character must match, unless comparing
   case insensitive, in which case 'A' == 'a' also.                */
FILESYS_PROC  int FILESYS_API  CompareMask ( CTEXTSTR mask, CTEXTSTR name, int keepcase );
// ScanFiles usage:
//   base - base path to scan
//   mask - file mask to process if NULL or "*" is everything "*.*" must contain a .
//   pInfo is a pointer to a void* - this pointer is used to maintain
//        internal information...
//   Process is called with the full name of any matching files
//   subcurse is a flag - set to go into all subdirectories looking for files.
// There is no way to abort the scan...
FILESYS_PROC  int FILESYS_API  ScanFilesEx ( CTEXTSTR base
           , CTEXTSTR mask
           , void **pInfo
           , void CPROC Process( uintptr_t psvUser, CTEXTSTR name, enum ScanFileProcessFlags flags )
           , enum ScanFileFlags flags
		   , uintptr_t psvUser, LOGICAL begin_sub_path, struct file_system_mounted_interface *mount );
FILESYS_PROC  int FILESYS_API  ScanFiles ( CTEXTSTR base
           , CTEXTSTR mask
           , void **pInfo
           , void CPROC Process( uintptr_t psvUser, CTEXTSTR name, enum ScanFileProcessFlags flags )
           , enum ScanFileFlags flags
           , uintptr_t psvUser );
FILESYS_PROC  void FILESYS_API  ScanDrives ( void (CPROC *Process)(uintptr_t user, CTEXTSTR letter, int flags)
										  , uintptr_t user );
// pass the pointer (pInfo) from aobve; get find_cursor.
FILESYS_PROC struct find_cursor * FILESYS_API GetScanFileCursor( void *pInfo );
// result is length of name filled into pResult if pResult == NULL && nResult = 0
// the result will the be length of the name matching the file.
FILESYS_PROC  int FILESYS_API  GetMatchingFileName ( CTEXTSTR filemask, enum ScanFileFlags flags, TEXTSTR pResult, int nResult );
// searches a path for the last '/' or '\'
FILESYS_PROC  CTEXTSTR FILESYS_API  pathrchr ( CTEXTSTR path );
#ifdef __cplusplus
FILESYS_PROC  TEXTSTR FILESYS_API  pathrchr ( TEXTSTR path );
#endif
// searches a path for the first '/' or '\'
FILESYS_PROC  CTEXTSTR FILESYS_API  pathchr ( CTEXTSTR path );
// returns pointer passed (if it worked?)
FILESYS_PROC  TEXTSTR FILESYS_API  GetCurrentPath ( TEXTSTR path, int buffer_len );
FILESYS_PROC  int FILESYS_API  SetCurrentPath ( CTEXTSTR path );
/* Creates a directory. If parent pieces of the directory do not
   exist, those parts are created also.
   Example
   <code lang="c#">
   MakePath( "c:\\where\\I'm/going/to/store/data" );
   </code>                                                       */
FILESYS_PROC  int FILESYS_API  MakePath ( CTEXTSTR path );
/* A boolean result function whether a specified name is a
   directory or not. (if not, assumes it's a file).
   Example
   <code lang="c#">
   if( IsPath( "c:/windows" ) )
   {
       // if yes, then c:\\windows is a directory.
   }
   </code>                                                 */
FILESYS_PROC LOGICAL  FILESYS_API  IsPath ( CTEXTSTR path );
FILESYS_PROC LOGICAL  FILESYS_API  IsAbsolutePath( CTEXTSTR path );
FILESYS_PROC  uint64_t     FILESYS_API  GetFileWriteTime ( CTEXTSTR name );
FILESYS_PROC  uint64_t     FILESYS_API  GetTimeAsFileTime ( void );
FILESYS_PROC  LOGICAL FILESYS_API  SetFileWriteTime( CTEXTSTR name, uint64_t filetime );
FILESYS_PROC  LOGICAL FILESYS_API  SetFileTimes( CTEXTSTR name
  // last modification time.
															  , uint64_t filetime_create
 // last modification time.
															  , uint64_t filetime_modify
  // last modification time.
															  , uint64_t filetime_access
															  );
FILESYS_PROC  void    FILESYS_API  SetDefaultFilePath ( CTEXTSTR path );
FILESYS_PROC  INDEX   FILESYS_API  SetGroupFilePath ( CTEXTSTR group, CTEXTSTR path );
FILESYS_PROC  TEXTSTR FILESYS_API  sack_prepend_path ( INDEX group, CTEXTSTR filename );
/* This is a new feature added for supporting systems without a
   current file location. This gets an integer ID of a group of
   files by name.
   the name 'default' is used to specify files to go into the
   'current working directory'
	There are some special symbols.
	. = use CurrentPath
	@ = use program path base
   ^ = use program startup path (may not be current)
   Parameters
   groupname :     name of the group
   default_path :  the path of the group, if the name is not
                   found.
   Returns
   the ID of a file group.
   Example
   <code lang="c++">
   int group = GetFileGroup( "fonts", "./fonts" );
   </code>                                                      */
FILESYS_PROC INDEX FILESYS_API  GetFileGroup ( CTEXTSTR groupname, CTEXTSTR default_path );
FILESYS_PROC TEXTSTR FILESYS_API GetFileGroupText ( INDEX group, TEXTSTR path, int path_chars );
FILESYS_PROC TEXTSTR FILESYS_API ExpandPathEx( CTEXTSTR path, struct file_system_interface *fsi );
FILESYS_PROC TEXTSTR FILESYS_API ExpandPath( CTEXTSTR path );
FILESYS_PROC LOGICAL FILESYS_API SetFileLength( CTEXTSTR path, size_t length );
/* \Returns the size of the file.
   Parameters
   name :  name of the file to get information about
   Returns
   \Returns the size of the file. or -1 if the file did not
   exist.                                                   */
FILESYS_PROC  size_t FILESYS_API  GetSizeofFile ( TEXTCHAR *name, uint32_t* unused );
#ifndef __ANDROID__
/* An extended function, which returns a uint64_t bit time
   appropriate for the current platform. This is meant to
   replace 'stat'. It can get all commonly checked attributes of
   a file.
   Parameters
   name :              name of the file to get information about
   lpCreationTime :    pointer to a FILETIME type to get creation
                       time. can be NULL.
   lpLastAccessTime :  pointer to a FILETIME type to get access
                       time. can be NULL.
   lpLastWriteTime :   pointer to a FILETIME type to get write
                       time. can be NULL.
   IsDirectory :       pointer to a LOGICAL to receive indicator
                       whether the file was a directory. can be
                       NULL.
   Returns
   \Returns the size of the file. or -1 if the file did not
	exist.                                                         */
FILESYS_PROC  uint32_t FILESYS_API  GetFileTimeAndSize ( CTEXTSTR name
													, LPFILETIME lpCreationTime
													,  LPFILETIME lpLastAccessTime
													,  LPFILETIME lpLastWriteTime
													, int *IsDirectory
													);
FILESYS_PROC void FILESYS_API ConvertFileIntToFileTime( uint64_t int_filetime, FILETIME *filetime );
FILESYS_PROC uint64_t FILESYS_API ConvertFileTimeToInt( const FILETIME *filetime );
#endif
// can use 0 as filegroup default - single 'current working directory'
#ifndef NEED_OLDNAMES
#define _NO_OLDNAMES
#endif
//#ifdef UNDER_CE
# ifndef O_RDONLY
#define O_RDONLY       0x0000
#define O_WRONLY       0x0001
#define O_RDWR         0x0002
#define O_APPEND       0x0008
#define O_CREAT        0x0100
#define O_TRUNC        0x0200
#define O_EXCL         0x0400
#endif
#ifndef __ANDROID__
#  ifndef S_IRUSR
#    define S_IRUSR 1
#    define S_IWUSR 2
#  endif
#endif
//# endif
#ifndef __LINUX__
FILESYS_PROC  HANDLE FILESYS_API  sack_open ( INDEX group, CTEXTSTR filename, int opts, ... );
FILESYS_PROC  LOGICAL FILESYS_API  sack_set_eof ( HANDLE file_handle );
FILESYS_PROC  long  FILESYS_API   sack_tell( INDEX file_handle );
FILESYS_PROC  HANDLE FILESYS_API  sack_openfile ( INDEX group, CTEXTSTR filename, OFSTRUCT *of, int flags );
FILESYS_PROC  HANDLE FILESYS_API  sack_creat ( INDEX group, CTEXTSTR file, int opts, ... );
FILESYS_PROC  int FILESYS_API  sack_close ( HANDLE file_handle );
FILESYS_PROC  int FILESYS_API  sack_lseek ( HANDLE file_handle, int pos, int whence );
FILESYS_PROC  int FILESYS_API  sack_read ( HANDLE file_handle, POINTER buffer, int size );
FILESYS_PROC  int FILESYS_API  sack_write ( HANDLE file_handle, CPOINTER buffer, int size );
#endif
FILESYS_PROC  INDEX FILESYS_API  sack_iopen ( INDEX group, CTEXTSTR filename, int opts, ... );
FILESYS_PROC  INDEX FILESYS_API  sack_iopenfile ( INDEX group, CTEXTSTR filename, int opts, int flags );
FILESYS_PROC  INDEX FILESYS_API  sack_icreat ( INDEX group, CTEXTSTR file, int opts, ... );
FILESYS_PROC  LOGICAL FILESYS_API  sack_iset_eof ( INDEX file_handle );
FILESYS_PROC  int FILESYS_API  sack_iclose ( INDEX file_handle );
FILESYS_PROC  int FILESYS_API  sack_ilseek ( INDEX file_handle, size_t pos, int whence );
FILESYS_PROC  int FILESYS_API  sack_iread ( INDEX file_handle, POINTER buffer, int size );
FILESYS_PROC  int FILESYS_API  sack_iwrite ( INDEX file_handle, CPOINTER buffer, int size );
/*
	Enable per-thread mounts.
	once you do this, you will have to provide the thread with some mounts.
*/
FILESYS_PROC void FILESYS_API sack_filesys_enable_thread_mounts( void );
/* internal (c library) file system is registered as prority 1000.... lower priorities are checked first for things like
  ScanFiles(), fopen( ..., "r" ), ... exists(), */
FILESYS_PROC struct file_system_mounted_interface * FILESYS_API sack_mount_filesystem( const char *name, struct file_system_interface *, int priority, uintptr_t psvInstance, LOGICAL writable );
FILESYS_PROC void FILESYS_API sack_unmount_filesystem( struct file_system_mounted_interface *mount );
// get a mounted filesystem by name
FILESYS_PROC struct file_system_mounted_interface * FILESYS_API sack_get_mounted_filesystem( const char *name );
// returrn inteface used on the mounted filesystem.
FILESYS_PROC struct file_system_interface * FILESYS_API sack_get_mounted_filesystem_interface( struct file_system_mounted_interface * );
FILESYS_PROC uintptr_t FILESYS_API sack_get_mounted_filesystem_instance( struct file_system_mounted_interface *mount );
/* sometimes you want scanfiles to only scan external files...
  so this is how to get that mount */
FILESYS_PROC struct file_system_mounted_interface * FILESYS_API sack_get_default_mount( void );
/* specify a mounted system to open... multiple volumes of the same type need a different handle */
FILESYS_PROC  FILE* FILESYS_API  sack_fopenEx( INDEX group, CTEXTSTR filename, CTEXTSTR opts, struct file_system_mounted_interface *fsi );
/* if mode is read, all mounted file systems are attempted... */
FILESYS_PROC  FILE* FILESYS_API  sack_fopen ( INDEX group, CTEXTSTR filename, CTEXTSTR opts );
/* specify a mounted system to open... multiple volumes of the same type need a different handle */
FILESYS_PROC  FILE* FILESYS_API  sack_fsopenEx ( INDEX group, CTEXTSTR filename, CTEXTSTR opts, int share_mode, struct file_system_mounted_interface *fsi );
/* if mode is read, all mounted file systems are attempted...
   if mode is write/create only the first writable file system is used...
*/
FILESYS_PROC  FILE* FILESYS_API  sack_fsopen ( INDEX group, CTEXTSTR filename, CTEXTSTR opts, int share_mode );
FILESYS_PROC  struct file_system_interface * FILESYS_API sack_get_filesystem_interface( CTEXTSTR name );
FILESYS_PROC  void FILESYS_API sack_set_default_filesystem_interface( struct file_system_interface *fsi );
FILESYS_PROC  void FILESYS_API sack_register_filesystem_interface( CTEXTSTR name, struct file_system_interface *fsi );
FILESYS_PROC  int FILESYS_API  sack_fclose ( FILE *file_file );
FILESYS_PROC  size_t FILESYS_API  sack_fseekEx ( FILE *file_file, size_t pos, int whence, struct file_system_mounted_interface *mount );
FILESYS_PROC  size_t FILESYS_API  sack_fseek ( FILE *file_file, size_t pos, int whence );
FILESYS_PROC  size_t FILESYS_API  sack_ftell ( FILE *file_file );
FILESYS_PROC  size_t FILESYS_API  sack_fsize ( FILE *file_file );
FILESYS_PROC  LOGICAL FILESYS_API  sack_existsEx ( const char * filename, struct file_system_mounted_interface *mount );
FILESYS_PROC  LOGICAL FILESYS_API  sack_exists ( const char *file_file );
// tests if the text passed is a directory or path to a file... for a specific mount.
FILESYS_PROC  LOGICAL FILESYS_API  sack_isPathEx ( const char *filename, struct file_system_mounted_interface *fsi );
// tests if the text passed is a directory or path to a file... for all mounts
FILESYS_PROC  LOGICAL FILESYS_API  sack_isPath( const char * filename );
FILESYS_PROC  size_t FILESYS_API  sack_fread ( POINTER buffer, size_t size, int count,FILE *file_file );
FILESYS_PROC  size_t FILESYS_API  sack_fwrite ( CPOINTER buffer, size_t size, int count,FILE *file_file );
FILESYS_PROC  TEXTSTR FILESYS_API  sack_fgets ( TEXTSTR  buffer, size_t size,FILE *file_file );
FILESYS_PROC  int FILESYS_API  sack_fflush ( FILE *file );
FILESYS_PROC  int FILESYS_API  sack_ftruncate ( FILE *file );
FILESYS_PROC int FILESYS_API sack_vfprintf( FILE *file_handle, const char *format, va_list args );
FILESYS_PROC int FILESYS_API sack_fprintf( FILE *file, const char *format, ... );
FILESYS_PROC int FILESYS_API sack_fputs( const char *format, FILE *file );
FILESYS_PROC  int FILESYS_API  sack_unlinkEx ( INDEX group, CTEXTSTR filename, struct file_system_mounted_interface *mount );
FILESYS_PROC  int FILESYS_API  sack_unlink ( INDEX group, CTEXTSTR filename );
FILESYS_PROC  int FILESYS_API  sack_rmdir( INDEX group, CTEXTSTR filename );
FILESYS_PROC  int FILESYS_API  sack_mkdir( INDEX group, CTEXTSTR filename );
FILESYS_PROC  int FILESYS_API  sack_renameEx ( CTEXTSTR file_source, CTEXTSTR new_name, struct file_system_mounted_interface *mount );
FILESYS_PROC  int FILESYS_API  sack_rename ( CTEXTSTR file_source, CTEXTSTR new_name );
FILESYS_PROC  void FILESYS_API sack_set_common_data_application( CTEXTSTR name );
FILESYS_PROC  void FILESYS_API sack_set_common_data_producer( CTEXTSTR name );
FILESYS_PROC  uintptr_t FILESYS_API  sack_ioctl( FILE *file, uintptr_t opCode, ... );
FILESYS_PROC  uintptr_t FILESYS_API  sack_fs_ioctl( struct file_system_mounted_interface *mount, uintptr_t opCode, ... );
#ifndef NO_FILEOP_ALIAS
#  ifndef NO_OPEN_MACRO
# define open(a,...) sack_iopen(0,a,##__VA_ARGS__)
# define set_eof(a)  sack_iset_eof(a)
#  endif
#ifdef WIN32
#if !defined( SACK_BAG_EXPORTS ) && !defined( BAG_EXTERNALS ) && !defined( FILESYSTEM_LIBRARY_SOURCE )
# define _lopen(a,...) sack_open(0,a,##__VA_ARGS__)
# define tell(a)      sack_tell(a)
# define lseek(a,b,c) sack_ilseek(a,b,c)
# define _llseek(a,b,c) sack_lseek(a,b,c)
# define HFILE HANDLE
# undef HFILE_ERROR
# define HFILE_ERROR INVALID_HANDLE_VALUE
# define creat(a,...)  sack_icreat( 0,a,##__VA_ARGS__ )
# define close(a)  sack_iclose(a)
# define OpenFile(a,b,c) sack_openfile(0,a,b,c)
# define _lclose(a)  sack_close(a)
# define read(a,b,c) sack_iread(a,b,c)
# define write(a,b,c) sack_iwrite(a,b,c)
# define _lread(a,b,c) sack_read(a,b,c)
# define _lwrite(a,b,c) sack_write(a,b,c)
# define _lcreat(a,b) sack_creat(0,a,b)
# define remove(a)   sack_unlink(0,a)
# define unlink(a)   sack_unlink(0,a)
# define rmdir(a)   sack_rmdir(0,a)
# define mkdir(a)   sack_mkdir(0,a)
#endif
#endif
 //NO_FILEOP_ALIAS
#endif
#ifdef __LINUX__
#define SYSPATHCHAR "/"
#else
#define SYSPATHCHAR "\\"
#endif
FILESYS_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::filesys;
#endif
#endif
/* Defines a simple FRACTION type. Fractions are useful for
   scaling one value to another. These operations are handles
   continously. so iterating a fraction like 13 denominations of
   100 will be smooth.                                           */
#ifndef FRACTIONS_DEFINED
/* Multiple inclusion protection symbol. */
#define FRACTIONS_DEFINED
#ifdef __cplusplus
#  define _FRACTION_NAMESPACE namespace fraction {
#  define _FRACTION_NAMESPACE_END }
#  ifndef _MATH_NAMESPACE
#    define _MATH_NAMESPACE namespace math {
#  endif
#  define	 SACK_MATH_FRACTION_NAMESPACE_END } } }
#else
#  define _FRACTION_NAMESPACE
#  define _FRACTION_NAMESPACE_END
#  ifndef _MATH_NAMESPACE
#    define _MATH_NAMESPACE
#  endif
#  define	 SACK_MATH_FRACTION_NAMESPACE_END
#endif
SACK_NAMESPACE
	/* Namespace of custom math routines.  Contains operators
	 for Vectors and fractions. */
	_MATH_NAMESPACE
	/* Fraction namespace contains a PFRACTION type which is used to
   store integer fraction values. Provides for ration and
   proportion scaling. Can also represent fractions that contain
   a whole part and a fractional part (5 2/3 : five and
	two-thirds).                                                  */
	_FRACTION_NAMESPACE
/* Define the call type of the function. */
#define FRACTION_API CPROC
#  ifdef FRACTION_SOURCE
#    define FRACTION_PROC EXPORT_METHOD
#  else
/* Define the library linkage for a these functions. */
#    define FRACTION_PROC IMPORT_METHOD
#  endif
/* The faction type. Stores a fraction as integer
   numerator/denominator instead of a floating point scalar. */
/* Pointer to a <link sack::math::fraction::FRACTION, FRACTION>. */
/* The faction type. Stores a fraction as integer
   numerator/denominator instead of a floating point scalar. */
typedef struct fraction_tag {
	/* Numerator of the fraction. (This is the number on top of a
	   fraction.)                                                 */
	int numerator;
	/* Denominator of the fraction. (This is the number on bottom of
	   a fraction.) This specifies the denominations.                */
	int denominator;
} FRACTION, *PFRACTION;
#ifdef HAVE_ANONYMOUS_STRUCTURES
typedef struct coordpair_tag {
	union {
		FRACTION x;
		FRACTION width;
	};
	union {
		FRACTION y;
		FRACTION height;
	};
} COORDPAIR, *PCOORDPAIR;
#else
/* A coordinate pair is a 2 dimensional fraction expression. can
   be regarded as x, y or width,height. Each coordiante is a
   Fraction type.                                                */
typedef struct coordpair_tag {
	       /* The x part of the coordpair. */
	       FRACTION x;
	       /* The y part of the coordpair. */
	       FRACTION y;
} COORDPAIR, *PCOORDPAIR;
#endif
/* \ \
   Parameters
   fraction :     the fraction to set
   numerator :    numerator of the fraction
   demoninator :  denominator of the fraction */
#define SetFraction(f,n,d) ((((f).numerator=((int)(n)) ),((f).denominator=((int)(d)))),(f))
/* Sets the value of a FRACTION. This is passed as the whole
   number and the fraction.
   Parameters
   fraction :  the fraction to set
   w :         this is the whole number to set
   n :         numerator of remainder to set
   d :         denominator of fraction to set.
   Example
   Fraction f = 3 1/2;
   <code lang="c++">
   FRACTION f;
   SetFractionV( f, 3, 1, 2 );
   // the resulting fraction will be 7/2
   </code>                                                   */
#define SetFractionV(f,w,n,d) (  (d)?	 ((((f).numerator=((int)((n)*(w))) )	  ,((f).denominator=((int)(d)))),(f))	  :	 ((((f).numerator=((int)((w))) )	  ,((f).denominator=((int)(1)))),(f))  )
/* \ \
   Parameters
   base :    origin point (content is modified by adding offset
             to it)
   offset :  offset point                                       */
FRACTION_PROC  void FRACTION_API  AddCoords ( PCOORDPAIR base, PCOORDPAIR offset );
/* Add one fraction to another.
   Parameters
   base :    This is the starting value, and recevies the result
             of (base+offset)
   offset :  This is the fraction to add to base.
   Returns
   base                                                          */
FRACTION_PROC  PFRACTION FRACTION_API  AddFractions ( PFRACTION base, PFRACTION offset );
/* Add one fraction to another.
   Parameters
   base :    This is the starting value, and recevies the result
             of (base+offset)
   offset :  This is the fraction to add to base.
   Returns
   base                                                          */
FRACTION_PROC  PFRACTION FRACTION_API  SubtractFractions ( PFRACTION base, PFRACTION offset );
/* NOT IMPLEMENTED */
FRACTION_PROC  PFRACTION FRACTION_API  MulFractions ( PFRACTION f, PFRACTION x );
/* Log a fraction into a string. */
FRACTION_PROC  int FRACTION_API  sLogFraction ( TEXTCHAR *string, PFRACTION x );
/* Unsafe log of a coordinate pair's value into a string. The
   string should be at least 69 characters long.
   Parameters
   string :  the string to print the fraction into
   pcp :     the coordinate pair to print                     */
FRACTION_PROC  int FRACTION_API  sLogCoords ( TEXTCHAR *string, PCOORDPAIR pcp );
/* Log coordpair to logfile. */
FRACTION_PROC  void FRACTION_API  LogCoords ( PCOORDPAIR pcp );
/* scales a fraction by a signed integer value.
   Parameters
   result\ :  pointer to a FRACTION to receive the result
   value :    the amount to be scaled
   f :        the fraction to multiply the value by
   Returns
   \result; the pointer the fraction to receive the result. */
FRACTION_PROC  PFRACTION FRACTION_API  ScaleFraction ( PFRACTION result, int32_t value, PFRACTION f );
/* Results in the integer part of the fraction. If the faction
   was 330/10 then the result would be 33.                     */
FRACTION_PROC  int32_t FRACTION_API  ReduceFraction ( PFRACTION f );
/* Scales a 32 bit integer value by a fraction. The result is
   the scaled value result.
   Parameters
   f :      pointer to the faction to multiply value by
   value :  the value to scale
   Returns
   The (value * f) integer value of.                          */
FRACTION_PROC  uint32_t FRACTION_API  ScaleValue ( PFRACTION f, int32_t value );
/* \ \
   Parameters
   f :      The fraction to scale the value by
   value :  the value to scale by (1/f)
   Returns
   the value of ( value * 1/ f )               */
FRACTION_PROC  uint32_t FRACTION_API  InverseScaleValue ( PFRACTION f, int32_t value );
	SACK_MATH_FRACTION_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::math::fraction;
#endif
#endif
//---------------------------------------------------------------------------
// $Log: fractions.h,v $
// Revision 1.6  2004/09/03 14:43:40  d3x0r
// flexible frame reactions to font changes...
//
// Revision 1.5  2003/03/25 08:38:11  panther
// Add logging
//
// Revision 1.4  2003/01/27 09:45:03  panther
// Fix lack of anonymous structures
//
// Revision 1.3  2002/10/09 13:16:02  panther
// Support for linux shared memory mapping.
// Support for better linux compilation of configuration scripts...
// Timers library is now Threads AND Timers.
//
//
// find and replace INTERFACE with desired header name...
#ifndef INTERFACE_DEFINED
#define INTERFACE_DEFINED
#if defined( INTERFACE_SOURCE )
#define INTERFACE_PROC(type,name) EXPORT_METHOD type CPROC name
#define INTERFACE_PROC_PTR(type,name) EXPORT_METHOD type (*CPROC name)
#else
#define INTERFACE_PROC(type,name) __declspec(dllimport) type CPROC name
#define INTERFACE_PROC_PTR(type,name) __declspec(dllimport) type (*CPROC name)
#endif
#define METHOD_PTR(type,name) type (CPROC *_##name)
#define DMETHOD_PTR(type,name) type (CPROC **_##name)
#define METHOD_ALIAS(i,name) ((i)->_##name)
#define PDMETHOD_ALIAS(i,name) (*(i)->_##name)
//#define AliasedMethod METHOD_ALIAS(default,AliasedMethod)
//INTERFACE_PROC( POINTER, GetInterface )( char *service );
//INTERFACE_PROC( void, DropInterface )( char *service, POINTER );
#endif
#define CONTROL_BASE
#define LOCK_TEST 0
// this is a FUN flag! this turns on
// background state capture for all controls...
// builds in the required function of get/restore
// background image before dispatching draw events.
//#define DEFAULT_CONTROLS_TRANSPARENT
//#define DEBUG_FOCUS_STUFF
/* this flag is defined in controlstruc.h...
 *
 * #define DEBUG_BORDER_DRAWING
 *
 */
//#define DEBUG_CREATE
//#define DEBUG_SCALING
// this symbol is also used in XML_Load code.
//#define DEBUG_RESOURCE_NAME_LOOKUP
//#define DEBUG_TRANSPARENCY_SURFACE_SAVE_RESTORE
#define DEBUG_UPDAATE_DRAW 4
// defined to use the new interface manager.
// otherwise this library had to do twisted steps
// to load what it thinks it wants for interfaces,
// and was not externally configurable.
#ifndef FORCE_NO_INTERFACE
#define USE_INTERFACES
#endif
/* this might be defined on Linux, and or on non vista platforms? */
//#ifdef __LINUX__
/* this is an important option to leave ON.  with current generation (2007-06-06) code,
 * the control's surface is what is mostly what is concentrated on for refresh.
 * border drawing was minimized a hair too far... but without this, borders are draw and redrawn
 * hundreds of time that are unnessecary.  But, this cures some of those artirfacts...
 * it should someday not be required... as the frame's surface should be a static state
 */
//#define SMUDGE_ON_VIDEO_UPDATE
//#endif
//#define BLAT_COLOR_UPDATE_PORTION
/*
 *
 * (4) most logging (so far) this has a level really noisy messages are #if DEBUG_UPDATE > 3
 * (3) has control update path, not only just when updates occur
 *
 */
#ifndef CONTROL_SOURCE
#define CONTROL_SOURCE
#ifndef PSI_GLOBAL_STRUCTURE_DEFINED
#define PSI_GLOBAL_STRUCTURE_DEFINED
//DOM-IGNORE-BEGIN
#define g global_psi_structure
//DOM-IGNORE-END
#ifndef PSI_SERVICE
#  ifndef FORCE_NO_INTERFACE
 // some people including this may have already defined this
#    ifndef USE_IMAGE_INTERFACE
#define USE_IMAGE_INTERFACE global_psi_structure.MyImageInterface
#    endif
#  endif
#endif
/* Crafted by Jim Buckeyne (c)1999-2006++ Freedom Collective
   Image building tracking, and simple manipulations.        */
// if the library is to have it's own idea of what
// an image is - then it should have included
// the definition for 'SFTFont', and 'Image' before
// including this... otherwise, it is assumed to
// be a client, and therefore does not need the information
// if a custom structure is used - then it MUST define
// it's ACTUAL x,y,width,height as the first 4 int32_t bit values.
#ifndef IMAGE_H
// multiple inclusion protection symbol
#define IMAGE_H
#if defined( _MSC_VER ) && defined( SACK_BAG_EXPORTS ) && 0
#define HAS_ASSEMBLY
#endif
/* Define COLOR type. Basically the image library regards color
   as 32 bits of data. User applications end up needing to
   specify colors in the correct method for the platform they
   are working on. This provides aliases to rearrange colors.
   For instance the colors on windows and the colors for OpenGL
   are not exactly the same. If the OpenGL driver is specified
   as the output device, the entire code would need to be
   rebuilt for specifying colors correctly for opengl. While
   otherwise they are both 32 bits, and pieces work, they get
   very ugly colors output.
   See Also
   <link Colors>                                                */
#ifndef COLOR_STRUCTURE_DEFINED
/* An exclusion symbol for defining CDATA and color operations. */
#define COLOR_STRUCTURE_DEFINED
#ifdef __cplusplus
SACK_NAMESPACE
	namespace image {
#endif
		// byte index values for colors on the video buffer...
		enum color_byte_index {
 I_BLUE  = 0,
 I_GREEN = 1,
 I_RED   = 2,
 I_ALPHA = 3
		};
#if defined( __ANDROID__ ) || defined( _OPENGL_DRIVER )
#  define USE_OPENGL_COMPAT_COLORS
#endif
#if ( !defined( IMAGE_LIBRARY_SOURCE_MAIN ) && ( !defined( FORCE_NO_INTERFACE ) || defined( ALLOW_IMAGE_INTERFACE ) ) )      && !defined( FORCE_COLOR_MACROS )
#define Color( r,g,b ) MakeColor(r,g,b)
#define AColor( r,g,b,a ) MakeAlphaColor(r,g,b,a)
#define SetAlpha( rgb, a ) SetAlphaValue( rgb, a )
#define SetGreen( rgb, g ) SetGreeValue(rgb,g )
#define AlphaVal(color) GetAlphaValue( color )
#define RedVal(color)   GetRedValue(color)
#define GreenVal(color) GetGreenValue(color)
#define BlueVal(color)  GetBlueValue(color)
#else
#if defined( _OPENGL_DRIVER ) || defined( USE_OPENGL_COMPAT_COLORS )
#  define Color( r,g,b ) (((uint32_t)( ((uint8_t)(r))|((uint16_t)((uint8_t)(g))<<8))|(((uint32_t)((uint8_t)(b))<<16)))|0xFF000000)
#  define AColor( r,g,b,a ) (((uint32_t)( ((uint8_t)(r))|((uint16_t)((uint8_t)(g))<<8))|(((uint32_t)((uint8_t)(b))<<16)))|((a)<<24))
#  define SetAlpha( rgb, a ) ( ((rgb)&0x00FFFFFF) | ( (a)<<24 ) )
#  define SetGreen( rgb, g ) ( ((rgb)&0xFFFF00FF) | ( ((g)&0xFF)<<8 ) )
#  define SetBlue( rgb, b )  ( ((rgb)&0xFF00FFFF) | ( ((b)&0xFF)<<16 ) )
#  define SetRed( rgb, r )   ( ((rgb)&0xFFFFFF00) | ( ((r)&0xFF)<<0 ) )
#  define GLColor( c )  (c)
#  define AlphaVal(color) ((color&0xFF000000) >> 24)
#  define RedVal(color)   ((color&0x000000FF) >> 0)
#  define GreenVal(color) ((color&0x0000FF00) >> 8)
#  define BlueVal(color)  ((color&0x00FF0000) >> 16)
#else
#  ifdef _WIN64
#    define AND_FF &0xFF
#  else
/* This is a macro to cure a 64bit warning in visual studio. */
#    define AND_FF
#  endif
/* A macro to create a solid color from R G B coordinates.
   Example
   <code lang="c++">
   CDATA color1 = Color( 255,0,0 ); // Red only, so this is bright red
   CDATA color2 = Color( 0,255,0); // green only, this is bright green
   CDATA color3 = Color( 0,0,255); // blue only, this is birght blue
   CDATA color4 = Color(93,93,32); // this is probably a goldish grey
   </code>                                                             */
#define Color( r,g,b ) (((uint32_t)( ((uint8_t)((b)AND_FF))|((uint16_t)((uint8_t)((g))AND_FF)<<8))|(((uint32_t)((uint8_t)((r))AND_FF)<<16)))|0xFF000000)
/* Build a color with alpha specified. */
#define AColor( r,g,b,a ) (((uint32_t)( ((uint8_t)((b)AND_FF))|((uint16_t)((uint8_t)((g))AND_FF)<<8))|(((uint32_t)((uint8_t)((r))AND_FF)<<16)))|(((a)AND_FF)<<24))
/* Sets the alpha part of a color. (0-255 value, 0 being
   transparent, and 255 solid(opaque))
   Example
   <code lang="c++">
   CDATA color = BASE_COLOR_RED;
   CDATA hazy_color = SetAlpha( color, 128 );
   </code>
 */
#define SetAlpha( rgb, a ) ( ((rgb)&0x00FFFFFF) | ( (a)<<24 ) )
/* Sets the green channel of a color. Expects a value 0-255.  */
#define SetGreen( rgb, g ) ( ((rgb)&0xFFFF00FF) | ( ((g)&0x0000FF)<<8 ) )
/* Sets the blue channel of a color. Expects a value 0-255.  */
#define SetBlue( rgb, b ) ( ((rgb)&0xFFFFFF00) | ( ((b)&0x0000FF)<<0 ) )
/* Sets the red channel of a color. Expects a value 0-255.  */
#define SetRed( rgb, r ) ( ((rgb)&0xFF00FFFF) | ( ((r)&0x0000FF)<<16 ) )
/* Return a CDATA that is meant for output to OpenGL. */
#define GLColor( c )  (((c)&0xFF00FF00)|(((c)&0xFF0000)>>16)|(((c)&0x0000FF)<<16))
/* Get the alpha value of a color. This is a 0-255 unsigned
   byte.                                                    */
#define AlphaVal(color) (((color) >> 24) & 0xFF)
/* Get the red value of a color. This is a 0-255 unsigned byte. */
#define RedVal(color)   (((color) >> 16) & 0xFF)
/* Get the green value of a color. This is a 0-255 unsigned
   byte.                                                    */
#define GreenVal(color) (((color) >> 8) & 0xFF)
/* Get the blue value of a color. This is a 0-255 unsigned byte. */
#define BlueVal(color)  (((color)) & 0xFF)
#endif
 // IMAGE_LIBRARY_SOURCE
#endif
		/* a definition for a single color channel - for function replacements for ___Val macros*/
		typedef unsigned char COLOR_CHANNEL;
        /* a 4 byte array of color (not really used, we mostly went with CDATA and PCDATA instead of COLOR and PCOLOR */
		typedef COLOR_CHANNEL COLOR[4];
		// color data raw...
		typedef uint32_t CDATA;
		/* pointer to an array of 32 bit colors */
		typedef uint32_t *PCDATA;
		/* A Pointer to <link COLOR>. Probably an array of color (a
		 block of pixels for instance)                            */
		typedef COLOR *PCOLOR;
//-----------------------------------------------
// common color definitions....
//-----------------------------------------------
// both yellows need to be fixed.
#define BASE_COLOR_BLACK         Color( 0,0,0 )
#define BASE_COLOR_BLUE          Color( 0, 0, 128 )
#define BASE_COLOR_DARKBLUE          Color( 0, 0, 42 )
/* An opaque Green.
   See Also
   <link Colors>    */
#define BASE_COLOR_GREEN         Color( 0, 128, 0 )
/* An opaque cyan - kind of a light sky like blue.
   See Also
   <link Colors>                                   */
#define BASE_COLOR_CYAN          Color( 0, 128, 128 )
/* An opaque red.
   See Also
   <link Colors>  */
#define BASE_COLOR_RED           Color( 192, 32, 32 )
/* An opaque BROWN. Brown is dark yellow... so this might be
   more like a gold sort of color instead.
   See Also
   <link Colors>                                             */
#define BASE_COLOR_BROWN         Color( 140, 140, 0 )
#define BASE_COLOR_LIGHTBROWN         Color( 221, 221, 85 )
#define BASE_COLOR_MAGENTA       Color( 160, 0, 160 )
#define BASE_COLOR_LIGHTGREY     Color( 192, 192, 192 )
/* An opaque darker grey (gray?).
   See Also
   <link Colors>                  */
#define BASE_COLOR_DARKGREY      Color( 128, 128, 128 )
/* An opaque a bight or light color blue.
   See Also
   <link Colors>                          */
#define BASE_COLOR_LIGHTBLUE     Color( 0, 0, 255 )
/* An opaque lighter, brighter green color.
   See Also
   <link Colors>                            */
#define BASE_COLOR_LIGHTGREEN    Color( 0, 255, 0 )
/* An opaque a lighter, more bight cyan color.
   See Also
   <link Colors>                               */
#define BASE_COLOR_LIGHTCYAN     Color( 0, 255, 255 )
/* An opaque bright red.
   See Also
   <link Colors>         */
#define BASE_COLOR_LIGHTRED      Color( 255, 0, 0 )
/* An opaque Lighter pink sort of red-blue color.
   See Also
   <link Colors>                                  */
#define BASE_COLOR_LIGHTMAGENTA  Color( 255, 0, 255 )
/* An opaque bright yellow.
   See Also
   <link Colors>            */
#define BASE_COLOR_YELLOW        Color( 255, 255, 0 )
/* An opaque White.
   See Also
   <link Colors>    */
#define BASE_COLOR_WHITE         Color( 255, 255, 255 )
#define BASE_COLOR_ORANGE        Color( 204,96,7 )
#define BASE_COLOR_NICE_ORANGE   Color( 0xE9, 0x7D, 0x26 )
#define BASE_COLOR_PURPLE        Color( 0x7A, 0x11, 0x7C )
#ifdef __cplusplus
 //	 namespace image {
}
SACK_NAMESPACE_END
using namespace sack::image;
#endif
#endif
// $Log: colordef.h,v $
// Revision 1.4  2003/04/24 00:03:49  panther
// Added ColorAverage to image... Fixed a couple macros
//
// Revision 1.3  2003/03/25 08:38:11  panther
// Add logging
//
#ifndef __NO_INTERFACES__
#endif
# ifndef SECOND_IMAGE_LEVEL
#  define SECOND_IMAGE_LEVEL _2
/* This is a macro used for building name changes for
   interfaces.                                        */
#  define PASTE(sym,name) name
# else
#  define PASTE2(sym,name) sym##name
#  define PASTE(sym,name) PASTE2(sym,name)
# endif
/* Macro to do symbol concatenation. */
#define _PASTE2(sym,name) sym##name
/* A second level paste macro so macro substitution is done on
   \parameters.                                                */
#define _PASTE(sym,name) _PASTE2(sym,name)
/* Define the default call type of image routines. CPROC is
   __cdecl.                                                 */
#define IMAGE_API CPROC
#     ifdef IMAGE_LIBRARY_SOURCE
#        define IMAGE_PROC  EXPORT_METHOD
// this sometimes needs an extra 'extern'
//#           ifdef IMAGE_MAIN
//#        define IMAGE_PROC_D EXPORT_METHOD
//#           else
//#        define IMAGE_PROC_D extern EXPORT_METHOD
//#           endif
#     else
/* Define the linkage type of the routine... probably
   __declspec(dllimport) if not building the library. */
#        define IMAGE_PROC IMPORT_METHOD
// this sometimes needs an extra 'extern'
//#        define IMAGE_PROC_D  IMPORT_METHOD
#     endif
#if defined( _WIN32 ) && !defined( _OPENGL_DRIVER ) && !defined( _D3D_DRIVER ) && !defined( _D3D10_DRIVER ) && !defined( _D3D11_DRIVER )
#define _INVERT_IMAGE
#endif
#ifdef __cplusplus
/* Define the namespace of image routines, when building under
   C++.                                                        */
#ifdef _D3D_DRIVER
#  define IMAGE_NAMESPACE namespace sack { namespace image { namespace d3d {
#  define _IMAGE_NAMESPACE namespace image { namespace d3d {
#  define BASE_IMAGE_NAMESPACE namespace image {
/* Define the namespace of image routines, when building under
   C++. This ends a namespace.                                 */
#  define IMAGE_NAMESPACE_END }}}
#elif defined( _D3D10_DRIVER )
#  define IMAGE_NAMESPACE namespace sack { namespace image { namespace d3d10 {
#  define _IMAGE_NAMESPACE namespace image { namespace d3d10 {
#  define BASE_IMAGE_NAMESPACE namespace image {
/* Define the namespace of image routines, when building under
   C++. This ends a namespace.                                 */
#  define IMAGE_NAMESPACE_END }}}
#elif defined( _D3D11_DRIVER )
#  define IMAGE_NAMESPACE namespace sack { namespace image { namespace d3d11 {
#  define _IMAGE_NAMESPACE namespace image { namespace d3d11 {
#  define BASE_IMAGE_NAMESPACE namespace image {
/* Define the namespace of image routines, when building under
   C++. This ends a namespace.                                 */
#  define IMAGE_NAMESPACE_END }}}
#else
#  define BASE_IMAGE_NAMESPACE namespace image {
#  define IMAGE_NAMESPACE namespace sack { namespace image {
#  define _IMAGE_NAMESPACE namespace image {
/* Define the namespace of image routines, when building under
   C++. This ends a namespace.                                 */
#  define IMAGE_NAMESPACE_END }}
#endif
/* Define the namespace of image routines, when building under
   C++. This ends the namespace. Assembly routines only have the
   ability to export C names, so extern"c" { } is used instead
   of namespace ___ { }.                                         */
#define ASM_IMAGE_NAMESPACE extern "C" {
/* Define the namespace of image routines, when building under
   C++. This ends the namespace. Assembly routines only have the
   ability to export C names, so extern"c" { } is used instead
   of namespace ___ { }.                                         */
#define ASM_IMAGE_NAMESPACE_END }
#else
#define BASE_IMAGE_NAMESPACE
#define IMAGE_NAMESPACE
#define _IMAGE_NAMESPACE
#define IMAGE_NAMESPACE_END
#define ASM_IMAGE_NAMESPACE
 /* Defined Image API.
   See Also
   <link sack::image::Image, Image>
   <link sack::image::SFTFont, SFTFont>
   <link Colors>
                                    */
#define ASM_IMAGE_NAMESPACE_END
#endif
#ifdef USE_API_ALIAS_PREFIX
#  define IMGVER__(a,b) a##b
#  define IMGVER_(a,b) IMGVER__(a,b)
#  define IMGVER(n)   IMGVER_(USE_API_ALIAS_PREFIX,n)
#else
#  define IMGVER(n)   n
#endif
SACK_NAMESPACE
/* Deals with images and image processing.
   Image is the primary type of this.
   SFTFont is a secondary type for putting text on images.
   render namespace is contained in image, because without
   image, there could be no render. see PRENDERER.         */
	_IMAGE_NAMESPACE
/* A fixed point decimal number (for freetype font rendering) */
typedef int64_t fixed;
//#ifndef IMAGE_STRUCTURE_DEFINED
//#define IMAGE_STRUCTURE_DEFINED
// consider minimal size - +/- 32000 should be enough for display purposes.
// print... well that's another matter.
   typedef int32_t IMAGE_COORDINATE;
   /* Represents the width and height of an image (unsigned values) */
   typedef uint32_t  IMAGE_SIZE_COORDINATE;
   /* An array of 2 IMAGE_COORDINATES - [0] = x, [1] = y */
   typedef IMAGE_COORDINATE IMAGE_POINT[2];
   /* An unsigned value coordinate pair to track the size of
      images.                                                */
   typedef IMAGE_SIZE_COORDINATE IMAGE_EXTENT[2];
   /* Pointer to an <link sack::image::IMAGE_POINT, IMAGE_POINT> */
   typedef IMAGE_COORDINATE *P_IMAGE_POINT;
   /* Pointer to a <link sack::image::IMAGE_EXTENT, IMAGE_EXTENT> */
   typedef IMAGE_SIZE_COORDINATE *P_IMAGE_EXTENT;
#ifdef HAVE_ANONYMOUS_STRUCTURES
typedef struct boundry_rectangle_tag
{
   union {
      IMAGE_POINT position;
      struct {
         IMAGE_COORDINATE x, y;
      };
   };
   union {
      IMAGE_EXTENT size;
      struct {
         IMAGE_SIZE_COORDINATE width, height;
      };
   };
} IMAGE_RECTANGLE, *P_IMAGE_RECTANGLE;
#else
/* Defines the coordinates of a rectangle. */
/* Pointer to an image rectangle.  */
typedef struct boundry_rectangle_tag
{
   /* anonymous union containing position information. */
   union {
      /* An anonymous structure containing x,y and width,height of a
         rectangle.                                                  */
      struct {
         /* the left coordinate of a rectangle. */
         /* the top coordinate of a rectangle */
         IMAGE_COORDINATE x, y;
         /* The Y span of the rectangle */
         /* the X Span of the rectangle */
         IMAGE_SIZE_COORDINATE width, height;
      };
      /* Anonymous structure containing position (x,y) and size
         (width,height).                                        */
      struct {
         /* The location of a rectangle (upper left x, y) */
         IMAGE_POINT position;
         /* the size of a rectangle (width and height) */
         IMAGE_EXTENT size;
      };
   };
} IMAGE_RECTANGLE, *P_IMAGE_RECTANGLE;
#endif
/* A macro for accessing vertical (Y) information of an <link sack::image::IMAGE_POINT, IMAGE_POINT>. */
#define IMAGE_POINT_H(ImagePoint) ((ImagePoint)[0])
/* A macro for accessing vertical (Y) information of an <link sack::image::IMAGE_POINT, IMAGE_POINT>. */
#define IMAGE_POINT_V(ImagePoint) ((ImagePoint)[1])
// the image at exactly this position and size
// is the one being referenced, the actual size and position
// may vary depending on use (a sub-image outside the
// boundry of its parent).
#define ImageData union {                                 struct {                                               IMAGE_COORDINATE x, y;                              IMAGE_SIZE_COORDINATE width, height;             };                                                  struct {                                               IMAGE_POINT position;                               IMAGE_EXTENT size;                               };                                               }
/* One of the two primary types that the image library works
   with.
   Example
   <code lang="c++">
   void LoadImage( char *name )
   {
       Image image = LoadImageFile( name );
       if( image )
       {
          // the image file loaded successfully.
       }
   }
   </code>                                                   */
typedef struct ImageFile_tag *Image;
typedef struct SlicedImageFile *SlicedImage;
#if defined( IMAGE_STRUCTURE_DEFINED )
#if defined(__cplusplus_cli ) && !defined( IMAGE_SOURCE )
IMAGE_PROC  PCDATA IMAGE_API ImageAddress( Image image, int32_t x, int32_t y );
#define IMG_ADDRESS(i,x,y) ImageAddress( i,x,y )
#endif
#endif
#if defined( __cplusplus )
IMAGE_NAMESPACE_END
#endif
#ifndef IMAGE_STRUCTURE_DEFINED
#ifdef _D3D_DRIVER
#include <d3d9.h>
#endif
#ifdef _D3D10_DRIVER
#include <D3D10_1.h>
#include <D3D10.h>
#endif
#ifdef _D3D11_DRIVER
#include <D3D11.h>
#endif
#ifdef _VULKAN_DRIVER
#  ifdef _WIN32
#    define VK_USE_PLATFORM_WIN32_KHR
#  else
#    define VK_USE_PLATFORM_XCB_KHR
#  endif
#  include <vulkan/vulkan.h>
#endif
// one day I'd like to make a multidimensional library
// but for now - 3D is sufficient - it can handle everything
// under 2D ignoring the Z axis... although it would be more
// efficient to do 2D implementation alone...
// but without function overloading the names of all the functions
// become much too complex.. well perhaps - maybe I can
// make all the required functions with a suffix - and
// supply defines to choose the default based on the dimension number
#ifndef ROTATE_DECLARATION
// vector multiple inclusion protection
#define ROTATE_DECLARATION
#if !defined(__STATIC__) && !defined(__LINUX__)
#  ifdef VECTOR_LIBRARY_SOURCE
#    define MATHLIB_EXPORT EXPORT_METHOD
#    if defined( __WATCOMC__ ) || defined( _MSC_VER )
// data requires an extra extern to generate the correct code *boggle*
#      define MATHLIB_DEXPORT extern EXPORT_METHOD
#    else
#      define MATHLIB_DEXPORT EXPORT_METHOD
#    endif
#  else
#    define MATHLIB_EXPORT IMPORT_METHOD
#    if ( defined( __WATCOMC__ ) || defined( _MSC_VER ) || defined( __GNUC__ ) ) && !defined( __ANDROID__ )
// data requires an extra extern to generate the correct code *boggle*
#      ifndef __cplusplus_cli
#        define MATHLIB_DEXPORT extern IMPORT_METHOD
#      else
#        define MATHLIB_DEXPORT extern IMPORT_METHOD
#      endif
#    else
#      define MATHLIB_DEXPORT IMPORT_METHOD
#    endif
#  endif
#else
#ifndef VECTOR_LIBRARY_SOURCE
#define MATHLIB_EXPORT extern
#define MATHLIB_DEXPORT extern
#else
#define MATHLIB_EXPORT
#define MATHLIB_DEXPORT
#endif
#endif
#define DIMENSIONS 3
#if( DIMENSIONS > 0 )
   #define vRight   0
   #define _1D(exp)  exp
   #if( DIMENSIONS > 1 )
      #define vUp      1
      #define _2D(exp)  exp
      #if( DIMENSIONS > 2 )
         #define vForward 2
         #define _3D(exp)  exp
         #if( DIMENSIONS > 3 )
  // 4th dimension 'IN'/'OUT' since projection is scaled 3d...
            #define vIn      3
            #define _4D(exp)  exp
         #else
            #define _4D(exp)
         #endif
      #else
         #define _3D(exp)
         #define _4D(exp)
      #endif
   #else
      #define _2D(exp)
      #define _3D(exp)
      #define _4D(exp)
   #endif
#else
   // print out a compiler message can't perform zero-D transformations...
#endif
#if defined( _D3D_DRIVER ) || defined( _D3D10_DRIVER )
#  ifndef MAKE_RCOORD_SINGLE
#    define MAKE_RCOORD_SINGLE
#  endif
#endif
#ifdef __cplusplus
#  ifndef MAKE_RCOORD_SINGLE
#    define VECTOR_NAMESPACE SACK_NAMESPACE namespace math { namespace vector { namespace Double {
#    define _MATH_VECTOR_NAMESPACE namespace math { namespace vector { namespace Double {
#    define _VECTOR_NAMESPACE namespace vector { namespace Double {
#    define USE_VECTOR_NAMESPACE using namespace sack::math::vector::Double;
#  else
#    define VECTOR_NAMESPACE SACK_NAMESPACE namespace math { namespace vector { namespace Float {
#    define _MATH_VECTOR_NAMESPACE namespace math { namespace vector { Float {
#    define _VECTOR_NAMESPACE namespace vector { namespace Float {
#    define USE_VECTOR_NAMESPACE using namespace sack::math::vector::Float;
#  endif
#  define _MATH_NAMESPACE namespace math {
#  define VECTOR_NAMESPACE_END } } } SACK_NAMESPACE_END
#else
#  define VECTOR_NAMESPACE
#  define _MATH_VECTOR_NAMESPACE
#  define _MATH_NAMESPACE
#  define _VECTOR_NAMESPACE
#  define VECTOR_NAMESPACE_END
#  define USE_VECTOR_NAMESPACE
#endif
#undef EXTERNAL_NAME
#undef VECTOR_METHOD
#ifdef MAKE_RCOORD_SINGLE
#  define VECTOR_METHOD(r,n,args) MATHLIB_EXPORT r n##f args
#  define EXTERNAL_NAME(n)  n##f
#else
#  define VECTOR_METHOD(r,n,args) MATHLIB_EXPORT r n##d args
#  define EXTERNAL_NAME(n)  n##d
#endif
#ifndef VECTOR_TYPES_DEFINED
#define VECTOR_TYPES_DEFINED
// this file merely defines the basic calculation unit...
// more types are defined in VECTLIB.H which has the number
// of dimensions defined...
#include <math.h>
#include <float.h>
SACK_NAMESPACE
	_MATH_NAMESPACE
   _VECTOR_NAMESPACE
   // requires C++ to make RCOORD single - otherwise it is a double.
#ifndef MAKE_RCOORD_SINGLE
/* Define that an RCOORD is represented by the basic type
   'double' for platforms with smaller fast floating point
   types, this could be float.                             */
#define RCOORD_IS_DOUBLE 1
	/* basic type that Vectlib is based on.
	 This specifies a 'real' (aka float) coordinate.
	 Combinations of coordinates create vectors and points.  */
typedef double RCOORD;
/* <combine sack::math::vector::double::RCOORD>
   \ \                                  */
	typedef double *PRCOORD;
#else
	/* basic type that Vectlib is based on.
	 This specifies a 'real' (aka float) coordinate.
	 Combinations of coordinates create vectors and points.  */
typedef float RCOORD;
/* <combine sack::math::vector::float::RCOORD>
   \ \                                  */
typedef float *PRCOORD;
#endif
// these SHOULD be dimension relative, but we lack much code for that...
typedef RCOORD MATRIX[4][4];
typedef MATRIX *PMatrix;
/* Describes the rotation matrix for a PTRANSFORM. */
typedef RCOORD PMATRIX[][4];
typedef RCOORD RQUATERNION[4];
typedef RCOORD PRQUATERNION[4];
#ifdef RCOORD_IS_DOUBLE
#define RCOORDBITS(v)  (*(uint64_t*)&(v))
#else
/* A macro to get the literal bits into an unsigned value of the
   same size. Shift and binary operators do not apply to
   floating point values, but floating point values are fields
   of bits that represent fractional parts of integers. This
   gets the bits so the fields can be tested.                    */
#define RCOORDBITS(v)  (*(uint32_t*)&(v))
#endif
/* a symbol which is effectively the largest negative value of
   the space, anything less than this is untrackable, and is the
   same as infinity.                                             */
#define NEG_INFINITY ((RCOORD)-9999999999.0)
/* a symbol which is effectively the largest value of the space,
   anything more than this is untrackable, and is the same as
   infinity.                                                     */
#define POS_INFINITY ((RCOORD)9999999999.0)
/* This is 'epsilon' that is used with by NearZero comparison
   macro.                                                     */
#define e1 (0.00001)
/* Checks to see if a coordinate is 0 or near 0. */
#define NearZero( n ) (fabs(n)<e1)
#ifndef __cplusplus
#endif
#ifdef RCOORD_IS_DOUBLE
// THRESHOLD may be any number more than 1.
// eveything 0 or more makes pretty much every number
// which is anything like another number equal...
// threshold is in count of bits...
// therefore for 1millionth digit accuracy that would be 20 bits.
// 10 bits is thousanths different are near
// 0 bits is if the same magnitude of number... but may be
//   quite different
// -10 bits is thousands different are near
// 1 == 1.5
// 1 == 1.01
#define THRESHOLD 16
#ifdef _MSC_VER
#define EXPON(f) ((int)(( RCOORDBITS(f) & 0x4000000000000000I64 ) ?                       (( RCOORDBITS(f) &  0x3FF0000000000000I64 ) >> (20+32)) :                        ((( RCOORDBITS(f) & 0x3FF0000000000000I64 ) >> (20+32)) - 1024)))
#else
#define EXPON(f) ((int)(( RCOORDBITS(f) & 0x4000000000000000LL ) ?                       (( RCOORDBITS(f) &  0x3FF0000000000000LL ) >> (20+32)) :                        ((( RCOORDBITS(f) & 0x3FF0000000000000LL ) >> (20+32)) - 1024)))
#endif
#else
// THRESHOLD may be any number more than 1.
// eveything 0 or more makes pretty much every number
// which is anything like another number equal...
// threshold is in count of bits...
// therefore for 1millionth digit accuracy that would be 20 bits.
// 10 bits is thousanths different are near
// 0 bits is if the same magnitude of number... but may be
//   quite different
// -10 bits is thousands different are near
// 1 == 1.5
// 1 == 1.01
#define THRESHOLD 10
/* Macro to extract the exponent part of a RCOORD.
                                                   */
#define EXPON(f) ((int)(( RCOORDBITS(f) & 0x40000000L ) ?                       (( RCOORDBITS(f) & 0x3F800000L ) >> 23) :                        ((( RCOORDBITS(f) & 0x3F800000L ) >> 23) - 128)))
#endif
#ifdef NEED_VECTLIB_COMPARE
//cpg26Dec2006 c:\work\sack\include\vectypes.h(75): Warning! W202: Symbol 'COMPARE' has been defined, but not referenced
static int COMPARE( RCOORD n1, RCOORD n2 )
{
	RCOORD tmp1, tmp2;
	int compare_result;
	tmp1=n1-n2;
	//lprintf( "exponents %ld %ld", EXPON( n1 ), EXPON( n2 ) );
	 //lprintf("%9.9g-%9.9g=%9.9g %s %s %ld %ld %ld"
	//		 , (n1),(n2),(tmp1)
	//		 ,!RCOORDBITS(n1)?"zero":"    ",!RCOORDBITS(n2)?"zero":"    "
	  //	 ,EXPON(n1)-THRESHOLD
	//	    ,EXPON(n2)-THRESHOLD
	//		 ,EXPON(tmp1) );
	tmp2=n2-n1;
	//lprintf("%9.9g-%9.9g=%9.9g %s %s %ld %ld %ld"
	//		 , (n2),(n1),(tmp2)
	//		 ,!RCOORDBITS(n2)?"zero":"    ",!RCOORDBITS(n1)?"zero":"    "
	//		 ,EXPON(n2)-THRESHOLD,EXPON(n1)-THRESHOLD,EXPON(tmp2));
	compare_result = ( ( !RCOORDBITS(n1) )?( (n2) <  0.0000001 &&
														 (n2) > -0.0000001 )?1:0
							:( !RCOORDBITS(n2) )?( (n1) <  0.0000001 &&
														 (n1) > -0.0000001 )?1:0
							:( (n1) == (n2) )?1
							:( ( EXPON(n1) - THRESHOLD ) >=
							  ( EXPON( tmp1 ) ) ) &&
							( ( EXPON(n2) - THRESHOLD ) >=
							 ( EXPON( tmp2) ) ) ? 1 : 0
						  );
	return compare_result;
}
/*
static RCOORD CompareTemp1, CompareTemp2;
#define COMPARE( n1, n2 ) ( RCOORDBITS(n1)                                            ? ( CompareTemp1 = (n1)+(n1),                                 CompareTemp2 = (n1)+(n2),                   (RCOORDBITS(CompareTemp1)&0xFFFFFFF0)==                                     (RCOORDBITS(CompareTemp2)&0xFFFFFFF0) )                                         : RCOORDBITS(n2)                                              ? ( CompareTemp1 = (n2)+(n1),                                   CompareTemp2 = (n2)+(n2),                                  (RCOORDBITS(CompareTemp1)&0xFFFFFFF0)==                                   (RCOORDBITS(CompareTemp2)&0xFFFFFFF0) )                                                  : 1 )
*/
/*
                           ( ( ( RCOORDBITS(n1) & 0x80000000 ) !=                                      ( RCOORDBITS(n2) & 0x80000000 ) )                                       ? ( NearZero(n1)                                                           && ( ( RCOORDBITS(n1)&0x7FFFFFF0 ) ==                                        ( RCOORDBITS(n2)&0x7FFFFFF0 ) ) )                               : ( ( RCOORDBITS(n1)&0xFFFFFFF0 ) ==                                        ( RCOORDBITS(n2)&0xFFFFFFF0 ) ) )
*/
#if 1
#else
inline int COMPARE( RCOORD n1, RCOORD n2 )
{
	RCOORD CompareTemp1, CompareTemp2;
   return  RCOORDBITS(n1)                                            ? ( CompareTemp1 = (n1)+(n1),                                 CompareTemp2 = (n1)+(n2),                   (RCOORDBITS(CompareTemp1)&0xFFFFFFF0)==                                     (RCOORDBITS(CompareTemp2)&0xFFFFFFF0) )                                         : RCOORDBITS(n2)                                              ? ( CompareTemp1 = (n2)+(n1),                                   CompareTemp2 = (n2)+(n2),                                  (RCOORDBITS(CompareTemp1)&0xFFFFFFF0)==                                   (RCOORDBITS(CompareTemp2)&0xFFFFFFF0) )                                                  : 1;
}
#endif
#endif
VECTOR_NAMESPACE_END
#endif
// $Log: vectypes.h,v $
// Revision 1.12  2005/01/27 08:21:39  panther
// Linux cleaned.
//
// Revision 1.11  2004/02/08 05:42:29  d3x0r
// associate comparetemp1, 2 with routine which needs it.
//
// Revision 1.10  2003/11/28 00:10:39  panther
// fix compare function...
//
// Revision 1.9  2003/11/23 08:42:41  panther
// Toying with the nearness floating point operator
//
// Revision 1.8  2003/09/01 20:04:37  panther
// Added OpenGL Interface to windows video lib, Modified RCOORD comparison
//
// Revision 1.7  2003/08/29 10:26:17  panther
// Checkpoint - converted vectlib to be native double
//
// Revision 1.6  2003/08/29 02:07:41  panther
// Fixed logging, and nearness comparison
//
// Revision 1.5  2003/08/27 07:56:40  panther
// Replace COMPARE macro with one that works a little better
//
// Revision 1.4  2003/03/25 08:38:11  panther
// Add logging
//
SACK_NAMESPACE
	_MATH_NAMESPACE
	/* Vector namespace contains methods for operating on vectors. Vectors
	   are multi-dimensional scalar quantities, often used to
	   represent coordinates and directions in space.                      */
   _VECTOR_NAMESPACE
//#include "../src/vectlib/vecstruc.h"
typedef RCOORD _POINT4[4];
typedef RCOORD _POINT[DIMENSIONS];
/* pointer to a point. */
typedef RCOORD *P_POINT;
/* pointer to a constant point. */
typedef const RCOORD *PC_POINT;
/* A vector type. Contains 3 values by default, library can
   handle 4 dimensional transformations(?)                  */
typedef _POINT VECTOR;
/* pointer to a vector. */
typedef P_POINT PVECTOR;
/* pointer to a constant vector. */
typedef PC_POINT PCVECTOR;
/* <combine sack::math::vector::RAY@1>
   \ \                                 */
typedef struct vectlib_ray_type *PRAY;
/* <combine sack::math::vector::RAY@1>
   \ \                                 */
typedef struct vectlib_ray_type RAY;
/* A ray is a type that has an origin and a direction. (It is a
   pair of vectors actually)                                    */
struct vectlib_ray_type {
 // origin
   _POINT o;
 // normal
   _POINT n;
};
/* <combinewith sack::math::vector::lineseg_tag>
   \ \                                           */
typedef struct lineseg_tag  LINESEG;
/* <combine sack::math::vector::lineseg_tag>
   \ \                                       */
typedef struct lineseg_tag *PLINESEG;
/* This is a pure abstraction of a Line. It is used in the basis
   of 3d graphics.                                               */
struct lineseg_tag {
   /* a ray type that is the origin and slope of the line. */
	RAY r;
	/* scalar along direction vector that indicates where the line
	   segment ends. (origin + (direction * dTo) ) = end           */
	/* scalar along direction vector that indicates where the line
	   segment ends. (origin + (direction * dTo) ) = start         */
	RCOORD dFrom, dTo;
};
/* <combine sack::math::vector::orthoarea_tag>
   \ \                                         */
typedef struct orthoarea_tag ORTHOAREA;
/* <combine sack::math::vector::orthoarea_tag>
   \ \                                         */
typedef struct orthoarea_tag *PORTHOAREA;
/* A representation of a rectangular 2 dimensional area. */
struct orthoarea_tag {
    /* x coorindate of a rectangular area. */
    /* y coordinate of a rectangular area. */
    RCOORD x, y;
    /* height (y + h = area end). height may be negative. */
    /* with (x + w = area end). with may be negative. */
    RCOORD w, h;
} ;
// relics from fixed point math dayz....
#define ZERO (0.0f)
/* Special symbol that is the unit quantity. */
#define ONE  (1.0f)
#ifndef M_PI
/* symbol to define a double precision value for PI if it
   doesn't exist in the compiler.                         */
#ifdef MAKE_RCOORD_SINGLE
#  define M_PI (3.1415926535f)
#else
#  define M_PI (3.1415926535)
#endif
#endif
/* a hard coded define that represents a 5 degree angle in
   radians.                                                */
#define _5  (RCOORD)((5.0/180.0)*M_PI )
/* a hard coded define that represents a 15 degree angle in
   radians.                                                 */
#define _15 (RCOORD)((15.0/180.0)*M_PI )
/* a hard coded define that represents a 30 degree angle in
   radians.                                                 */
#define _30 (RCOORD)((30.0/180.0)*M_PI )
/* a hard coded define that represents a 45 degree angle in
   radians.                                                 */
#define _45 (RCOORD)((45.0/180.0)*M_PI )
#define SetPoint( d, s ) ( (d)[0] = (s)[0], (d)[1]=(s)[1], (d)[2]=(s)[2] )
#define SetPoint4( d, s ) ( (d)[0] = (s)[0], (d)[1]=(s)[1], (d)[2]=(s)[2], (d)[3]=(s)[3] )
/* Inverts a vector. that is vector * -1. (a,b,c) = (-a,-b,-c)
   <b>Parameters</b>
                                                               */
VECTOR_METHOD( P_POINT, Invert, ( P_POINT a ) );
/* Macro which can be used to make a vector's direction be
   exactly opposite of what it is now.                     */
#define InvertVector( a ) ( a[0] = -a[0], a[1]=-a[1], a[2]=-a[2] )
/* Logs the vector and leader to log. the leader is called
   lpName, cause it was inteded to be used by just the vector
   name.
   Parameters
   lpName :  text leader to print before the vector.
   v :       vector to log
   Example
   <code lang="c++">
   PrintVector( _X );
   // expands to
   PrintVectorEx( "_X", _X DBG_SRC );
   </code>                                                    */
VECTOR_METHOD( void, PrintVectorEx, ( CTEXTSTR lpName, PCVECTOR v DBG_PASS ) );
/* <combine sack::math::vector::PrintVectorEx@CTEXTSTR@PCVECTOR v>
   \ \                                                               */
#define PrintVector(v) PrintVectorEx( #v, v DBG_SRC )
/* Same as PrintVectorEx, but prints to standard output using
   printf.                                                    */
VECTOR_METHOD( void, PrintVectorStdEx, ( CTEXTSTR lpName, VECTOR v DBG_PASS ) );
/* <combine sack::math::vector::PrintVectorStdEx@CTEXTSTR@VECTOR v>
   \ \                                                                */
#define PrintVectorStd(v) PrintVectorStd( #v, v DBG_SRC )
/* Dumps to syslog a current matrix. Shows both matrix content,
   and the cross products between the matrix that cross1 should
   be row 0, cross2 should be row 1 and cross3 should be row2.
   Pass a text name to identify this matrix from others.
   Parameters
   lpName :    Name to write into the log.
   m :         the matrix to dump.
   DBG_PASS :  standard debug paramters
   Remarks
   A PTRANSFORM is not a MATRIX; there is a matrix in a
   transform, and is the first member, so a ptransform can be
   cast to a matrix and logged with this function.              */
VECTOR_METHOD( void, PrintMatrixEx, ( CTEXTSTR lpName, MATRIX m DBG_PASS ) );
/* <combine sack::math::vector::PrintMatrixEx@CTEXTSTR@MATRIX m>
   \ \                                                             */
#define PrintMatrix(m) PrintMatrixEx( #m, m DBG_SRC )
/* <combine sack::math::vector::TransformationMatrix>
   \ \                                                */
typedef struct transform_tag *PTRANSFORM;
/* <combine sack::math::vector::TransformationMatrix>
   \ \                                                */
typedef struct transform_tag	 TRANSFORM;
/* Pointer to a constant transform. */
typedef const TRANSFORM *PCTRANSFORM;
/* Constant pointer to a constant transform. For things like _I
   transformation which is the identity translation.            */
typedef const PCTRANSFORM *CPCTRANSFORM;
#define VectorConst_0 EXTERNAL_NAME(VectorConst_0)
#define VectorConst_X EXTERNAL_NAME(VectorConst_X)
#define VectorConst_Y EXTERNAL_NAME(VectorConst_Y)
#define VectorConst_Z EXTERNAL_NAME(VectorConst_Z)
#define VectorConst_I EXTERNAL_NAME(VectorConst_I)
#ifdef __cplusplus
#define VECTLIBCONST
#else
#define VECTLIBCONST const
#endif
//------ Constants for origin(0,0,0), and axii
#if !defined( VECTOR_LIBRARY_SOURCE ) || defined( VECTOR_LIBRARY_IS_EXTERNAL )
MATHLIB_DEXPORT VECTLIBCONST PC_POINT VectorConst_0;
/* Specifies the coordinate system's X axis direction. static
   constant.                                                  */
MATHLIB_DEXPORT VECTLIBCONST PC_POINT VectorConst_X;
/* Specifies the coordinate system's Y axis direction. static
   constant.                                                  */
MATHLIB_DEXPORT VECTLIBCONST PC_POINT VectorConst_Y;
/* Specifies the coordinate system's Z axis direction. static
   constant.                                                  */
MATHLIB_DEXPORT VECTLIBCONST PC_POINT VectorConst_Z;
/* This is a static constant identity matrix, which can be used
   to initialize a matrix transform (internally).               */
MATHLIB_DEXPORT VECTLIBCONST PCTRANSFORM VectorConst_I;
#define _0 ((PC_POINT)VectorConst_0)
#  ifndef _X
#    define _X ((PC_POINT)VectorConst_X)
#  else
#  endif
#define _Y ((PC_POINT)VectorConst_Y)
#define _Z ((PC_POINT)VectorConst_Z)
#define _I ((PC_POINT)VectorConst_I)
#endif
/* compares two vectors to see if they are near each other. Boundary
   \conditions exist around 0, when the values are on opposite
   sides, but it's pretty good.                                      */
#define Near( a, b ) ( COMPARE(a[0],b[0]) && COMPARE( a[1], b[1] ) && COMPARE( a[2], b[2] ) )
/* Add two vectors together. (a1,b1,c1) + (a2,b2,c2) =
   (a1+a2,b1+b2,c1+c2)
   Remarks
   The result vector may be the same as one of the source
   vectors.                                               */
VECTOR_METHOD( P_POINT, add, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2 ) );
/* subtracts two vectors and stores the result in another
   vector.
   Remarks
   The result vector may be the same as one of the source
   vectors.                                               */
VECTOR_METHOD( P_POINT, sub, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2 ) );
/* Scales a vector by a scalar
   Parameters
   pr :   \result vector
   pv1 :  vector to scale
   k :    constant scalar to apply to vector
   Example
   <code lang="c#">
   VECTOR result;
   VECTOR start;
   SetPoint( start, _X );
   scale( result, start, 3 );
   </code>                                   */
VECTOR_METHOD( P_POINT, scale, ( P_POINT pr, PC_POINT pv1, RCOORD k ) );
/* Adds a vector scaled by a scalar to another vector, results
   in a third vector.
   Parameters
   pr :   pointer to a result vector
   pv1 :  pointer to vector 1
   pv2 :  pointer to vector 2
   k :    scalar quantity to apply to vector 2 when adding to
          vector 1.
   Remarks
   The pointer to the result vector may be the same vector as
   vector 1 or vector 2.
   Example
   <code lang="c++">
   _POINT result;
   P_POINT v1 = _X;
   P_POINT v2 = _Y;
   RCOORD k = 1.414;
   addscaled( result, v1, v2, k );
   // result is ( 1, 1.414, 0 )
   </code>                                                     */
VECTOR_METHOD( P_POINT, addscaled, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2, RCOORD k ) );
/* Normalizes a non-zero vector. That is the resulting length of
   the vector is 1.0. Modifies the vector in place.              */
VECTOR_METHOD( void, normalize, ( P_POINT pv ) );
VECTOR_METHOD( void, crossproduct, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2 ) );
/* \Returns the sin of the angle between two vectors.
   Parameters
   pv1 :  one vector
   pv2 :  another vector
   Remarks
   If the length of either vector is 0, then a divide by zero
   exception will happen.                                     */
VECTOR_METHOD( RCOORD, SinAngle, ( PC_POINT pv1, PC_POINT pv2 ) );
/* \Returns the cos (cosine) of the angle between two vectors.
   Parameters
   pv1 :  one vector
   pv2 :  another vector
   Remarks
   If the length of either vector is 0, then a divide by zero
   exception will happen.                                      */
VECTOR_METHOD( RCOORD, CosAngle, ( PC_POINT pv1, PC_POINT pv2 ) );
VECTOR_METHOD( RCOORD, dotproduct, ( PC_POINT pv1, PC_POINT pv2 ) );
// result is the projection of project onto onto
VECTOR_METHOD( P_POINT, project, ( P_POINT pr, PC_POINT onto, PC_POINT project ) );
/* \Returns the scalar length of a vector. */
VECTOR_METHOD( RCOORD, Length, ( PC_POINT pv ) );
/* \Returns the distance between two points.
   Parameters
   v1 :  some point
   v2 :  another point
   Returns
   The distance between the two points.      */
VECTOR_METHOD( RCOORD, Distance, ( PC_POINT v1, PC_POINT v2 ) );
/* \Returns the distance a point is as projected on another
   vector. The result is the distance along that vector from the
   origin.
   Parameters
   pvOn :  Vector to project on
   pvOf :  vector to get projection length of.                   */
VECTOR_METHOD( RCOORD, DirectedDistance, ( PC_POINT pvOn, PC_POINT pvOf ) );
/* copies the value of a ray into another ray
   Parameters
   ray to set :   target value
   ray to copy :  value to copy.
   Example
   <code>
   RAY ray;
   RAY ray2;
   // set ray to ray2
   SetRay( ray, ray2 );
   </code>                                    */
#define SetRay( pr1, pr2 ) { SetPoint( (pr1)->o, (pr2)->o ),                               SetPoint( (pr1)->n, (pr2)->n ); }
		/* Allocates and initializes a new transform for the user.
		 if name is NULL, allocates an unnamed transform; otherwise
       the transform is created in a known namespace that can be browsed.
		 */
VECTOR_METHOD( PTRANSFORM, CreateNamedTransform, ( CTEXTSTR name ) );
#define CreateTransform() CreateNamedTransform( NULL )
VECTOR_METHOD( PTRANSFORM, CreateTransformMotion, ( PTRANSFORM pt ) );
VECTOR_METHOD( PTRANSFORM, CreateTransformMotionEx, ( PTRANSFORM pt, int rocket ) );
VECTOR_METHOD( void, DestroyTransform     , ( PTRANSFORM pt ) );
/* Resets a transform back to initial conitions. */
VECTOR_METHOD( void, ClearTransform       , ( PTRANSFORM pt ) );
/* Badly named function.
   InvertTransform turns a transform sideways, that is takes
   axis-normal transforms and turns them for sending to other
   graphic systems.
   <code lang="c++">
     \+-         -+
     | 0   1   2 |
     | 3   4   5 |
     | 6   7   8 |
     \+-         -+
   becomes
     \+-         -+
     | 0   3   6 |
     | 1   4   7 |
     | 2   5   8 |
     \+-         -+
   Not entirely useful at all :)
   </code>                                                    */
VECTOR_METHOD( void, InvertTransform        , ( PTRANSFORM pt ) );
VECTOR_METHOD( void, Scale                 , ( PTRANSFORM pt, RCOORD sx, RCOORD sy, RCOORD sz ) );
VECTOR_METHOD( void, Translate             , ( PTRANSFORM pt, RCOORD tx, RCOORD ty, RCOORD tz ) );
VECTOR_METHOD( void, TranslateV            , ( PTRANSFORM pt, PC_POINT t ) );
VECTOR_METHOD( void, TranslateRel          , ( PTRANSFORM pt, RCOORD tx, RCOORD ty, RCOORD tz ) );
VECTOR_METHOD( void, TranslateRelV         , ( PTRANSFORM pt, PC_POINT t ) );
VECTOR_METHOD( void, RotateAbs, ( PTRANSFORM pt, RCOORD rx, RCOORD ry, RCOORD rz ) );
VECTOR_METHOD( void, RotateAbsV, ( PTRANSFORM pt, PC_POINT ) );
/* Updates the current rotation matrix of a transform by a
   relative amount. Amounts to rotate about the x, y and z axii
   are given in radians.
   Parameters
   pt :  transform to rotate
   rx :  amount around the x axis to rotate (pitch)(positive is
         clockwise looking at the object from the right, axis up is
         moved towards forward )
   ry :  amount around the y axis to rotate (yaw) (positive is
         counter clockwise, moves right to forward)
   rz :  amount around the z axis to rotate (roll) (positive is
         clockwise, moves up towards right )
   See Also
   RotateRelV                                                       */
VECTOR_METHOD( void, RotateRel, ( PTRANSFORM pt, RCOORD rx, RCOORD ry, RCOORD rz ) );
/* Update a transformation matrix by relative degress about the
   x axix, y axis and z axis.
   Parameters
   pt :  transform to update
   v :   vector containing x,y and z relative roll coordinate.  */
VECTOR_METHOD( void, RotateRelV, ( PTRANSFORM pt, PC_POINT ) );
/* Rotates a transform around some arbitrary axis. (any line may
   be used to rotate the transformation's rotation matrix)
   Parameters
   pt :      transform to update
   p :       P defines an axis around which the rotation portion
             of the matrix is rotated by an amount. Can be any
             arbitrary axis.
   amount :  an amount to rotate by.
   Note
   coded from
   http://www.mines.edu/~gmurray/ArbitraryAxisRotation/ArbitraryAxisRotation.html
   and
   http://www.siggraph.org/education/materials/HyperGraph/modeling/mod_tran/3drota.htm
   and http://astronomy.swin.edu.au/~pbourke/geometry/rotate/.
                                                                                       */
VECTOR_METHOD( void, RotateAround, ( PTRANSFORM pt, PC_POINT p, RCOORD amount ) );
/* Sets the current 'up' axis of a transformation. The forward
   axis is adjusted so that it remains perpendicular to the mast
   axis vs the right axis. After the forward axis is updated,
   the right axis is adjusted to be perpendicular to up and
   forward.
   Parameters
   pt :   transform to set the up direction of
   vup :  new direction for 'up'
   Remarks
   RotateMast is based on the idea that your current frame is
   something like a boat. As the boat moves along a surface,
   it's version of 'up' may change depending on the landscape. This
   keeps up up. (Actually, the computation was used for an
   object running along the interior of a sphere, and this
   normalizes their 'up' to the center of the sphere.               */
VECTOR_METHOD( void, RotateMast, ( PTRANSFORM pt, PCVECTOR vup ) );
/* Rotates around the 'up' of the current rotation matrix. Same
   as a yaw rotation.
   Parameters
   pt :     transformation to rotate
   angle :  angle to rotate \- positive should be clockwise,
            looking from top down.                              */
VECTOR_METHOD( void, RotateAroundMast, ( PTRANSFORM pt, RCOORD angle ) );
/* Recovers a transformation state from a file.
   Parameters
   pt :        transform to read into
   filename :  filename with the transform in it. */
VECTOR_METHOD( void, LoadTransform, ( PTRANSFORM pt, CTEXTSTR filename ) );
/* Provides a way to save a matrix ( direct binary file dump)
   Parameters
   pt :        transform matrix to save
   filename :  \file to save the transformation in.           */
VECTOR_METHOD( void, SaveTransform, ( PTRANSFORM pt, CTEXTSTR filename ) );
VECTOR_METHOD( void, RotateTo, ( PTRANSFORM pt, PCVECTOR vforward, PCVECTOR vright ) );
VECTOR_METHOD( void, RotateRight, ( PTRANSFORM pt, int A1, int A2 ) );
VECTOR_METHOD( void, Apply           , ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyR          , ( PCTRANSFORM pt, PRAY dest, PRAY src ) );
VECTOR_METHOD( void, ApplyT          , ( PCTRANSFORM pt, PTRANSFORM dest, PCTRANSFORM src ) );
// I know this was a result - unsure how it was implented...
//void ApplyT              (PTRANFORM pt, PTRANSFORM pt1, PTRANSFORM pt2 );
VECTOR_METHOD( void, ApplyInverse    , ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyInverseR   , ( PCTRANSFORM pt, PRAY dest, PRAY src ) );
VECTOR_METHOD( void, ApplyInverseT   , ( PCTRANSFORM pt, PTRANSFORM dest, PCTRANSFORM src ) );
// again note there was a void ApplyInverseT
VECTOR_METHOD( void, ApplyRotation        , ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyRotationT       , ( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts ) );
VECTOR_METHOD( void, ApplyInverseRotation , ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyInverseRotationT, ( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts ) );
VECTOR_METHOD( void, ApplyTranslation     , ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyTranslationT    , ( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts ) );
VECTOR_METHOD( void, ApplyInverseTranslation, ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyInverseTranslationT, ( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts ) );
// after Move() these callbacks are invoked.
typedef void (*MotionCallback)( uintptr_t, PTRANSFORM );
/* When Move is called on the transform, these callbacks are
   invoked so user code can get even update for motion.
   Parameters
   pt :        PTRANSFORM transform matrix to hook to
   callback :  user callback routine
   psv :       pointer size value data to be passed to user
               callback routine.                             */
VECTOR_METHOD( void, AddTransformCallback, ( PTRANSFORM pt, MotionCallback callback, uintptr_t psv ) );
/* Set the speed vector used when Move is applied to a
   PTRANSFORM.
   Parameters
   pt :  transform to set the current speed of.
   s :   the speed vector to set.                      */
VECTOR_METHOD( PC_POINT, SetSpeed, ( PTRANSFORM pt, PC_POINT s ) );
VECTOR_METHOD( P_POINT, GetSpeed, ( PTRANSFORM pt, P_POINT s ) );
/* Sets the acceleration applied to the speed when Move is
   called.                                                 */
VECTOR_METHOD( PC_POINT, SetAccel, ( PTRANSFORM pt, PC_POINT s ) );
VECTOR_METHOD( P_POINT, GetAccel, ( PTRANSFORM pt, P_POINT s ) );
/* Sets the forward direction speed in a PTRANSFORM.
   Parameters
   pt :        Transform to set the right speed of.
   distance :  How far it should go in the next time interval. */
VECTOR_METHOD( void, Forward, ( PTRANSFORM pt, RCOORD distance ) );
VECTOR_METHOD( void, MoveForward, ( PTRANSFORM pt, RCOORD distance ) );
VECTOR_METHOD( void, MoveRight, ( PTRANSFORM pt, RCOORD distance ) );
VECTOR_METHOD( void, MoveUp, ( PTRANSFORM pt, RCOORD distance ) );
/* Sets the up direction speed in a PTRANSFORM.
   Parameters
   pt :        Transform to set the right speed of.
   distance :  How far it should go in the next time interval. */
VECTOR_METHOD( void, Up, ( PTRANSFORM pt, RCOORD distance ) );
/* Sets the right direction speed in a PTRANSFORM.
   Parameters
   pt :        Transform to set the right speed of.
   distance :  How far it should go in the next time interval. */
VECTOR_METHOD( void, Right, ( PTRANSFORM pt, RCOORD distance ) );
VECTOR_METHOD( PC_POINT, SetRotation, ( PTRANSFORM pt, PC_POINT r ) );
VECTOR_METHOD( P_POINT, GetRotation, ( PTRANSFORM pt, P_POINT r ) );
VECTOR_METHOD( PC_POINT, SetRotationAccel, ( PTRANSFORM pt, PC_POINT r ) );
/* Set how long it takes, in milliseconds, to move 1 unit of
   speed vector or rotate 1 unit of rotation vector when Move is
   called. Each matrix maintains a last tick. If many thousands
   of matrixes were used, probably a batch move could be
   implemented that would maintain tick counts for a group of
   matrixes... don't know how long it takes to compute move, but
   timeGetTime will slow it down a lot.
   Parameters
   pt :                 transform to set the time interval on.
   speed_interval :     what the time interval should be for
                        speed.
   rotation_interval :  what the time interval should be for
                        rotation.
   Remarks
   A default interval of 1000 is used. So it will take 1000
   milliseconds to move one unit of speed. This could be set to
   3600000 and then it would take one hour to move one unit of
   speed. (miles per hour)
   Rotation has its own interval that affects rotation the same
   way; If your rotation was set to roll 2*pi radians, then it
   would revolve one full rotation in the said time.
                                                                 */
VECTOR_METHOD( void, SetTimeInterval, ( PTRANSFORM pt, RCOORD speed_interval, RCOORD rotation_interval ) );
/* Updates a transform by it's current speed and rotation
   assuming speed and rotation are specified in x per 1 second.
   Applies the fraction of time between now and the prior time
   move was called and scales speed and rotation by that when
   applying it.
   Parameters
   pt :  Pointer to a transform to update.
   See Also
   <link sack::math::vector::SetTimeInterval@PTRANSFORM@RCOORD@RCOORD, SetTimeInterval> */
VECTOR_METHOD( LOGICAL, Move, ( PTRANSFORM pt ) );
#if 0
	VECTOR_METHOD( void, Unmove, ( PTRANSFORM pt ) );
#endif
VECTOR_METHOD( void, showstdEx, ( PTRANSFORM pt, char *header ) );
VECTOR_METHOD( void, ShowTransformEx, ( PTRANSFORM pt, char *header DBG_PASS ) );
/* <combine sack::math::vector::ShowTransformEx@PTRANSFORM@char *header>
   \ \                                                                   */
#define ShowTransform( n ) ShowTransformEx( n, #n DBG_SRC )
VECTOR_METHOD( void, showstd, ( PTRANSFORM pt, char *header ) );
VECTOR_METHOD( void, GetOriginV, ( PTRANSFORM pt, P_POINT o ) );
VECTOR_METHOD( PC_POINT, GetOrigin, ( PTRANSFORM pt ) );
VECTOR_METHOD( void, GetAxisV, ( PTRANSFORM pt, P_POINT a, int n ) );
VECTOR_METHOD( PC_POINT, GetAxis, ( PTRANSFORM pt, int n ) );
VECTOR_METHOD( void, SetAxis, ( PTRANSFORM pt, RCOORD a, RCOORD b, RCOORD c, int n ) );
VECTOR_METHOD( void, SetAxisV, ( PTRANSFORM pt, PC_POINT a, int n ) );
// matrix is suitable to set as the first matrix for opengl rendering.
// it is an inverse application that uses the transform's origin as camera origin
// and the rotation matrix as what to look at.
VECTOR_METHOD( void, GetGLCameraMatrix, ( PTRANSFORM pt, PMATRIX out ) );
VECTOR_METHOD( void, GetGLMatrix, ( PTRANSFORM pt, PMATRIX out ) );
VECTOR_METHOD( void, SetGLMatrix, ( PMATRIX in, PTRANSFORM pt ) );
VECTOR_METHOD( void, SetRotationMatrix, ( PTRANSFORM pt, RCOORD *quat ) );
VECTOR_METHOD( void, GetRotationMatrix, ( PTRANSFORM pt, RCOORD *quat ) );
  // line m, b
VECTOR_METHOD( RCOORD, IntersectLineWithPlane, (PCVECTOR Slope, PCVECTOR Origin,
  // plane n, o
	PCVECTOR n, PCVECTOR o,
	RCOORD *time) );
VECTOR_METHOD( RCOORD, PointToPlaneT, (PCVECTOR n, PCVECTOR o, PCVECTOR p) );
#if ( !defined( VECTOR_LIBRARY_SOURCE ) && !defined( NO_AUTO_VECTLIB_NAMES ) ) || defined( NEED_VECTLIB_ALIASES )
#define add EXTERNAL_NAME(add)
#define sub EXTERNAL_NAME(sub)
#define scale EXTERNAL_NAME(scale)
#define Scale EXTERNAL_NAME(Scale)
#define Invert EXTERNAL_NAME(Invert)
#define GetOrigin EXTERNAL_NAME(GetOrigin)
#define GetOriginV EXTERNAL_NAME(GetOriginV)
#define GetAxis EXTERNAL_NAME(GetAxis)
#define GetAxisV EXTERNAL_NAME(GetAxisV)
#define GetGLCameraMatrix EXTERNAL_NAME(GetGLCameraMatrix)
#define ApplyInverse EXTERNAL_NAME(ApplyInverse)
#define Move EXTERNAL_NAME(Move)
#define MoveForward EXTERNAL_NAME(MoveForward)
#define MoveRight EXTERNAL_NAME(MoveRight)
#define MoveUp EXTERNAL_NAME(MoveUp)
#define Forward EXTERNAL_NAME(Forward)
#define Right EXTERNAL_NAME(Right)
#define Up EXTERNAL_NAME(Up)
#define PrintVectorEx EXTERNAL_NAME(PrintVectorEx)
#define PrintMatrixEx EXTERNAL_NAME(PrintMatrixEx)
#define ShowTransformEx EXTERNAL_NAME(ShowTransformEx)
#define addscaled EXTERNAL_NAME(addscaled)
#define Length EXTERNAL_NAME(Length)
#define PointToPlaneT EXTERNAL_NAME(PointToPlaneT)
#define normalize EXTERNAL_NAME(normalize)
#define Translate EXTERNAL_NAME(Translate)
#define TranslateV EXTERNAL_NAME(TranslateV)
#define Apply EXTERNAL_NAME(Apply)
#define ApplyR EXTERNAL_NAME(ApplyR)
#define ApplyT EXTERNAL_NAME(ApplyT)
#define ApplyTranslation EXTERNAL_NAME(ApplyTranslation)
#define ApplyTranslationR EXTERNAL_NAME(ApplyTranslationR)
#define ApplyTranslationT EXTERNAL_NAME(ApplyTranslationT)
#define ApplyInverseRotation EXTERNAL_NAME(ApplyInverseRotation)
#define ApplyInverseR EXTERNAL_NAME(ApplyInverseR)
#define ApplyRotation EXTERNAL_NAME(ApplyRotation)
#define ApplyRotationT EXTERNAL_NAME(ApplyRotationT)
#define RotateAround EXTERNAL_NAME(RotateAround)
#define RotateRel EXTERNAL_NAME(RotateRel)
#define SetRotation EXTERNAL_NAME(SetRotation)
#define GetRotation EXTERNAL_NAME(GetRotation)
#define SetRotationAccel EXTERNAL_NAME(SetRotationAccel)
#define RotateRight EXTERNAL_NAME(RotateRight)
#define dotproduct EXTERNAL_NAME(dotproduct)
#define DestroyTransform EXTERNAL_NAME(DestroyTransform)
#define SinAngle EXTERNAL_NAME(SinAngle)
#define CosAngle EXTERNAL_NAME(CosAngle)
#define crossproduct EXTERNAL_NAME(crossproduct)
#define CreateTransformMotion EXTERNAL_NAME(CreateTransformMotion)
#define CreateTransformMotionEx EXTERNAL_NAME(CreateTransformMotionEx)
#define CreateNamedTransform EXTERNAL_NAME(CreateNamedTransform)
#define ClearTransform EXTERNAL_NAME(ClearTransform)
#define RotateTo EXTERNAL_NAME(RotateTo)
#define SetSpeed EXTERNAL_NAME(SetSpeed)
#define SetAccel EXTERNAL_NAME(SetAccel)
#define TranslateRel EXTERNAL_NAME( TranslateRel )
#define TranslateRelV EXTERNAL_NAME( TranslateRelV )
#define RotateAbs EXTERNAL_NAME(RotateAbs)
#define RotateAbsV EXTERNAL_NAME(RotateAbsV)
#define GetRotationMatrix EXTERNAL_NAME(GetRotationMatrix)
#define SetRotationMatrix EXTERNAL_NAME(SetRotationMatrix)
#endif
#ifdef __cplusplus
VECTOR_NAMESPACE_END
USE_VECTOR_NAMESPACE
#endif
#endif
// $Log: vectlib.h,v $
// Revision 1.13  2004/08/22 09:56:41  d3x0r
// checkpoint...
//
// Revision 1.12  2004/02/02 22:43:35  d3x0r
// Add lineseg type and orthoarea (min/max box)
//
// Revision 1.11  2004/01/11 23:24:15  panther
// Fix type warnings, conflicts, fix const issues
//
// Revision 1.10  2004/01/11 23:11:49  panther
// Fix const typings
//
// Revision 1.9  2004/01/11 23:10:38  panther
// Include keyboard to avoid windows errors
//
// Revision 1.8  2004/01/04 20:54:18  panther
// Use PCTRANSFORM for prototypes
//
// Revision 1.7  2003/12/29 08:10:18  panther
// Added more functions for applying transforms
//
// Revision 1.6  2003/11/22 23:27:11  panther
// Fix type passed to printvector
//
// Revision 1.5  2003/09/01 20:04:37  panther
// Added OpenGL Interface to windows video lib, Modified RCOORD comparison
//
// Revision 1.4  2003/03/25 08:38:11  panther
// Add logging
//
#if defined( _WIN32 ) && !defined( _INVERT_IMAGE ) && !defined( _OPENGL_DRIVER ) && !defined( _D3D_DRIVER )
#define _INVERT_IMAGE
#endif
#define WILL_DEFINE_IMAGE_STRUCTURE
#define IMAGE_STRUCTURE_DEFINED
IMAGE_NAMESPACE
#ifdef __cplusplus
	namespace Interface
{
	struct image_interface_tag;
}
#ifdef _D3D_DRIVER
	using namespace sack::image::d3d::Interface;
#elif defined( _D3D10_DRIVER )
	using namespace sack::image::d3d10::Interface;
#elif defined( _D3D11_DRIVER )
	using namespace sack::image::d3d11::Interface;
#else
	using namespace sack::image::Interface;
#endif
#endif
#ifndef PSPRITE_METHOD
#define PSPRITE_METHOD PSPRITE_METHOD
/* pointer to a structure defining a sprite draw method this should be defined in render namespace...*/
	typedef struct sprite_method_tag *PSPRITE_METHOD;
#endif
	/* Flags which may be combined in <link sack::image::ImageFile_tag::flags, Image.flags> */
	enum ImageFlags {
 // this has been freed - but contains sub images
IF_FLAG_FREE   =0x00001,
 // moved beyond parent image's bound
IF_FLAG_HIDDEN =0x00002,
 // built with a *image from external sources
IF_FLAG_EXTERN_COLORS =0x00004,
 // pay attention to (clips) array.
IF_FLAG_HAS_CLIPS     =0x00008,
// with no _X_STRING flag - characters are shown as literal character glyph.
 // strings on this use 'c' processing
IF_FLAG_C_STRING       = 0x00010,
 // strings on this use menu processing ( &underline )
IF_FLAG_MENU_STRING    = 0x00020,
 // strings use control chars (newline, tab)
IF_FLAG_CONTROL_STRING = 0x00040,
 // this has been freed - but contains sub images
IF_FLAG_OWN_DATA       = 0x00080,
  // image is inverted (standard under windows, but this allows images to be configured dynamically - a hack to match SDL lameness )
IF_FLAG_INVERTED       = 0x00100,
// DisplayLib uses this flag - indicates panel root
 // please #define user flag to this
IF_FLAG_USER1          = 0x10000,
// DisplayLib uses this flag - indicates is part of a displayed panel
IF_FLAG_USER2          = 0x20000,
IF_FLAG_USER3          = 0x40000,
 // output should render to opengl target (with transform); also used with proxy
IF_FLAG_FINAL_RENDER   = 0x00200,
 // set when a operation has changed the surface of a local image; requires update to remote device(s)
IF_FLAG_UPDATED        = 0x00400,
 // set when a operation has changed the surface of a local image; requires update to remote device(s)
IF_FLAG_HAS_PUTSTRING  = 0x00800,
 // is an in-memory image; that is the surface can be written to directly with pixel ops (putstring)
IF_FLAG_IN_MEMORY      = 0x01000,
	};
//#define _DRAWPOINT_X 0
//#define _DRAWPOINT_Y 1
struct ImageFile_tag
{
#if defined( IMAGE_LIBRARY_SOURCE ) || defined( NEED_REAL_IMAGE_STRUCTURE )
	int real_x;
	int real_y;
   // desired height and width may not be actual cause of
	int real_width;
  // resizing of parent image....
	int real_height;
# ifdef HAVE_ANONYMOUS_STRUCTURES
	IMAGE_RECTANGLE;
# else
 // need this for sub images - otherwise is irrelavent
	int x;
	int y;
  /// Width of image.
	int width;
 /// Height of image.
	int height;
# endif
#else
	/* X coordinate of the image within another image. */
	int x;
	/* Y coordinate of an image within another image. */
	int y;
   // desired height and width may not be actual cause of
	int width;
  // resizing of parent image....
	int height;
 // need this for sub images - otherwise is irrelavent
	int actual_x;
	int actual_y;
  // Width of image.
	int actual_width;
 // Height of image.
	int actual_height;
#endif
 // width of real physical layer
	int pwidth;
	// The image data.
	PCOLOR image;
	/* a combination of <link ImageFlags, IF_FLAG_> (ImageFile Flag)
	   which apply to this image.                                    */
	int flags;
	/* This points to a peer image that existed before this one. If
	   NULL, there is no elder, otherwise, contains the next peer
	   image in the same parent image.                              */
	/* Points to the parent image of a sub-image. (The parent image
	   contains this image)                                         */
	/* Pointer to the youngest child sub-image. If there are no sub
	   images pChild will be NULL. Otherwise, pchild points at the
	   first of one or more sub images. Other sub images in this one
	   are found by following the pElder link of the pChild.         */
	/* This points at a more recently created sub-image. (another
	   sub image within the same parent, but younger)             */
	struct ImageFile_tag *pParent, *pChild, *pElder, *pYounger;
	   // effective x - clipped by reality real coordinate.
	           // (often eff_x = -real_x )
	int eff_x;
	/* this is used internally for knowing what the effective y of
	   the image is. If the sub-image spans a boundry of a parent
	   image, then the effective Y that will be worked with is only
	   a part of the subimage.                                      */
	int eff_y;
		// effective max - maximum coordinate...
	int eff_maxx;
		// effective maximum Y
	int eff_maxy;
		/* An extra rectangle that can be used to carry additional
		 information like update region.                         */
	IMAGE_RECTANGLE auxrect;
	// fonts need a way to output the font character subimages to the real image...
	// or for 3D; to reverse scale appropriately
	struct image_interface_tag  *reverse_interface;
 // what the interface thinks this is...
	POINTER reverse_interface_instance;
	void (*extra_close)( struct ImageFile_tag *);
//DOM-IGNORE-BEGIN
#if defined( __3D__ )
	PTRANSFORM transform;
#endif
#ifdef _OPENGL_DRIVER
	/* gl context? */
	LOGICAL depthTest;
	PLIST glSurface;
 // most things will still use this, since reload image is called first, reload will set active
	int glActiveSurface;
  // updated with SetTransformRelation, otherwise defaults to image size.
	VECTOR coords[4];
#endif
#ifdef _D3D10_DRIVER
	PLIST Surfaces;
	ID3D10Texture2D *pActiveSurface;
#endif
#ifdef _D3D11_DRIVER
	PLIST Surfaces;
	ID3D11Texture2D *pActiveSurface;
#endif
#ifdef _D3D_DRIVER
	/* gl context? */
	PLIST Surfaces;
	IDirect3DBaseTexture9 *pActiveSurface;
#endif
#ifdef _VULKAN_DRIVER
	LOGICAL depthTest;
	PLIST vkSurface;
 // most things will still use this, since reload image is called first, reload will set active
	int vkActiveSurface;
  // updated with SetTransformRelation, otherwise defaults to image size.
	VECTOR coords[4];
	VkCommandBuffer* commandBuffers;
#endif
#ifdef __cplusplus
 // watcom limits protections in structs to protected and public
#ifndef __WATCOMC__
private:
#endif
#endif
//DOM-IGNORE-END
};
enum SlicedImageSection {
	SLICED_IMAGE_TOP_LEFT,
	SLICED_IMAGE_TOP,
	SLICED_IMAGE_TOP_RIGHT,
	SLICED_IMAGE_LEFT,
	SLICED_IMAGE_CENTER,
	SLICED_IMAGE_RIGHT,
	SLICED_IMAGE_BOTTOM_LEFT,
	SLICED_IMAGE_BOTTOM,
	SLICED_IMAGE_BOTTOM_RIGHT,
};
struct SlicedImageFile {
	struct ImageFile_tag *image;
	struct ImageFile_tag *slices[9];
	uint32_t left, right, top, bottom;
	uint32_t center_w, center_h;
	uint32_t right_w;
	uint32_t bottom_h;
	LOGICAL output_center;
	LOGICAL extended_slice;
};
/* The basic structure. This is referenced by applications as '<link sack::image::Image, Image>'
	This is the primary type that the image library works with.
	This is the internal definition.
	This is a actual data content, Image is (ImageFile *).                                        */
typedef struct ImageFile_tag ImageFile;
/* A simple wrapper to add dynamic changing position and
	orientation to an image. Sprites can be output at any angle. */
struct sprite_tag
{
	/* Current location of the sprite's origin. */
	/* Current location of the sprite's origin. */
  // current x and current y for placement on image.
	int32_t curx, cury;
  // int of bitmap hotspot... centers cur on hot
	int32_t hotx, hoty;
	Image image;
	// curx,y are kept for moving the sprite independantly
	fixed scalex, scaley;
	// radians from 0 -> 2*pi.  there is no negative...
 // radians for now... (used internally, set by blot rotated sprite)
	float angle;
	// should consider keeping the angle of rotation
	// and also should cosider keeping velocity/acceleration
	// but then limits would have to be kept also... so perhaps
	// the game module should keep such silly factors... but then couldn't
	// it also keep curx, cury ?  though hotx hoty is the actual
	// origin to rotate this image about, and to draw ON curx 0 cury 0
	// int orgx, orgy;  // rotated origin of bitmap.
	// after being drawn the min(x,y) and max(x,y) are set.
 // after draw, these are the extent of the sprite.
	int32_t minx, maxx;
 // after draw, these are the extent of the sprite.
	int32_t miny, maxy;
	PSPRITE_METHOD pSpriteMethod;
};
/* A Sprite type. Adds position and rotation and motion factors
	to an image. Hooks into the render system to get an update to
	draw on a temporary layer after the base rendering is done.   */
typedef struct sprite_tag SPRITE;
#ifdef _INVERT_IMAGE
// inversion does not account for eff_y - only eff_maxy
// eff maxy - eff_minY???
/*+((i)->eff_y)*/
#define INVERTY(i,y)     ( (((i)->eff_maxy) - (y)))
#else
/* This is a macro is used when image data is inverted on a
	platform. (Windows images, the first row of data is the
	bottom of the image, all Image operations are specified from
	the top-left as 0,0)                                         */
#define INVERTY(i,y)     ((y) - (i)->eff_y)
#endif
/*+((i)->eff_y)*/
#define INVERTY_INVERTED(i,y)     ( (((i)->eff_maxy) - (y)))
#define INVERTY_NON_INVERTED(i,y)     ((y) - (i)->eff_y)
#if defined(__cplusplus_cli ) && !defined( IMAGE_SOURCE )
//IMAGE_PROC( PCDATA, ImageAddress )( Image image, int32_t x, int32_t y );
//#define IMG_ADDRESS(i,x,y) ImageAddress( i,x,y )
#else
#define IMG_ADDRESS(i,x,y)    ((CDATA*)	                             ((i)->image + (( (x) - (i)->eff_x )	 +(((i)->flags&IF_FLAG_INVERTED)?(INVERTY_INVERTED( (i), (y) ) * (i)->pwidth ):(INVERTY_NON_INVERTED( (i), (y) ) * (i)->pwidth ))	                             ))										   )
#endif
#if 0
#if defined( __arm__ ) && defined( IMAGE_LIBRARY_SOURCE ) && !defined( DISPLAY_SOURCE )
extern unsigned char AlphaTable[256][256];
static CDATA DOALPHA( CDATA over, CDATA in, uint8_t a )
{
	int r, g, b, aout;
	if( !a )
		return over;
	if( a > 255 )
		a = 255;
	if( a == 255 )
 // force alpha full on.
		return (in | 0xFF000000);
	aout = AlphaTable[a][AlphaVal( over )] << 24;
	r = ((((RedVal(in))  *(a+1)) + ((RedVal(over))  *(256-(a)))) >> 8 );
	if( r > (255) ) r = (255);
	g = (((GreenVal(in))*(a+1)) + ((GreenVal(over))*(256-(a)))) >> 8;
	if( g > (255) ) g = (255);
	b = ((((BlueVal(in)) *(a+1)) + ((BlueVal(over)) *(256-(a)))) >> 8 );
	if( b > 255 ) b = 255;
	return aout|(r<<16)|(g<<8)|b;
	//return AColor( r, g, b, aout );
}
#endif
#endif
IMAGE_NAMESPACE_END
// end if_not_included
#endif
// $Log: imagestruct.h,v $
// Revision 1.2  2005/04/05 11:56:04  panther
// Adding sprite support - might have added an extra draw callback...
//
// Revision 1.1  2004/06/21 07:38:39  d3x0r
// Move structures into common...
//
// Revision 1.20  2003/10/14 20:48:55  panther
// Tweak mmx a bit - no improvement visible but shorter
//
// Revision 1.19  2003/10/14 16:36:45  panther
// Oops doalpha was outside of known inclusion frame
//
// Revision 1.18  2003/10/14 00:43:03  panther
// Arm optimizations.  Looks like I'm about maxed.
//
// Revision 1.17  2003/09/15 17:06:37  panther
// Fixed to image, display, controls, support user defined clipping , nearly clearing correct portions of frame when clearing hotspots...
//
// Revision 1.16  2003/04/25 08:33:09  panther
// Okay move the -1's back out of IMG_ADDRESS
//
// Revision 1.15  2003/04/21 23:33:09  panther
// fix certain image ops - should check blot direct...
//
// Revision 1.14  2003/03/30 18:39:03  panther
// Update image blotters to use IMG_ADDRESS
//
// Revision 1.13  2003/03/30 16:11:03  panther
// Clipping images works now... blat image untested
//
// Revision 1.12  2003/03/30 06:24:56  panther
// Turns out I had badly implemented clipping...
//
// Revision 1.11  2003/03/25 08:45:51  panther
// Added CVS logging tag
//
#if defined( __cplusplus )
IMAGE_NAMESPACE
#endif
/* pointer to a sprite type. */
typedef struct sprite_tag *PSPRITE;
//#endif
// at some point, it may be VERY useful
// to have this structure also have a public member.
//
#ifndef NO_FONT
typedef struct simple_font_tag {
 // all characters same height
   uint16_t height;
 // number of characters in the set
   uint16_t characters;
 // open ended array size characters...
   uint8_t char_width[1];
} FontData;
/* Contains information about a font for drawing and rendering
   from a font file.                                           */
typedef struct font_tag *SFTFont;
#endif
/* A definition of a block structure to transport font and image
   data across message queues.                                   */
/* Type of buffer used to transfer data across message queues. */
typedef struct data_transfer_state_tag {
   /* size of this block of data. */
   uint32_t size;
   /* offset of the data in the total message. Have to break up
      large buffers into smaller chunks for transfer.           */
   uint32_t offset;
   /* buffer containing the data to transfer. */
   CDATA buffer;
} *DataState;
//-----------------------------------------------------
enum string_behavior {
   // every character assumed to have a glyph-including '\0'
   STRING_PRINT_RAW
 // control characters perform 'typical' actions - newline, tab, backspace...
   ,STRING_PRINT_CONTROL
  // c style escape characters are handled \n \b \x## - literal text
   ,STRING_PRINT_C
   ,STRING_PRINT_MENU
 /* &amp; performs an underline, also does C style handling. \\&amp;
                         == &amp;                                                         */
};
/* Definitions of symbols to pass to <link SetBlotMethod> to
   specify optimization method.                              */
enum blot_methods {
    /* A Symbol to pass to <link SetBlotMethod> to specify using C
      coded primitives. (for shading and alpha blending).         */
    BLOT_C
   , BLOT_ASM
/* A Symbol to pass to <link SetBlotMethod> to specify using
      primitives with assembly optimization (for shading and alpha
      blending).                                                   */
						,
                  /* A Symbol to pass to <link SetBlotMethod> to specify using
      primitives with MMX optimization (for shading and alpha
      blending).                                                */
    BLOT_MMX
};
// specify the method that pixels are copied from one image to another
enum BlotOperation {
   /* copy the pixels from one image to another with no color transform*/
 BLOT_COPY = 0,
   // copy the pixels from one image to another with no color transform, scaling by a single color
 BLOT_SHADED = 1,
   // copy the pixels from one image to another with no color transform, scaling independant R, G and B color channels to a combination of an R Color, B Color, G Color
 BLOT_MULTISHADE = 2,
   /* copy the pixels from one image to another with simple color inversion transform*/
 BLOT_INVERTED = 3,
 /* orientation blots for fonts to 3D and external displays */
 BLOT_ORIENT_NORMAL = 0x00,
 BLOT_ORIENT_INVERT = 0x04,
 BLOT_ORIENT_VERTICAL = 0x08,
 BLOT_ORIENT_VERTICAL_INVERT = 0x0C,
 BLOT_ORIENTATTION = 0x0C,
};
/* Transparency parameter definition
   0 : no transparency - completely opaque
   1 (TRUE): 0 colors (absolute transparency) only
   2-255 : 0 color transparent, plus transparency factor applied
   to all 2 - mostly almost completely transparent 255 not
   transparent (opaque)
   257-511 : alpha transparency in pixel plus transparency value
   \- 256 0 pixels will be transparent 257 - slightly more
   opaquen than the original 511 - image totally opaque - alpha
   will be totally overriden no addition 511 nearly completely
   transparent 512-767 ; the low byte of this is subtracted from
   the alpha of the image ; this allows images to be more
   transparent than they were originally 512 - no modification
   alpha imge normal 600 - mid range... more transparent 767 -
   totally transparent any value of transparent greater than the
   max will be clipped to max this will make very high values
   opaque totally...                                             */
enum AlphaModifier {
   /* Direct alpha copy - whatever the alpha is is what the output will be.  Adding a value of 0-255 here will increase the base opacity by that much */
	ALPHA_TRANSPARENT = 0x100,
   // Inverse alpha copy - whatever the alpha is is what the output will be.  Adding a value of 0-255 here will decrease the base opacity by that much
ALPHA_TRANSPARENT_INVERT = 0x200,
   // more than this clips to total transparency
	// for line, plot more than 255 will
// be total opaque... this max only
	// applies to blotted images
ALPHA_TRANSPARENT_MAX = 0x2FF
};
/* library global changes. string behavior cannot be tracked per
   image. string behavior should, for all strings, be the same
   usage for an application... so behavior is associated with
   the particular stream and/or image family. does not modify
   character handling behavior - only strings.
   See Also
   <link sack::image::string_behavior, String Behaviors>         */
   IMAGE_PROC  void IMAGE_API  IMGVER(SetStringBehavior)( Image pImage, uint32_t behavior );
   /* Specify the optimized code to draw with. There are 3 levels,
      C - routines coded in C, ASM - assembly optimization (32bit
      NASM), MMX assembly but taking advantage of MMX features.    */
   IMAGE_PROC  void IMAGE_API  IMGVER(SetBlotMethod)    ( uint32_t method );
   /* This routine can be used to generically scale to any point
      between two colors.
      Parameters
      Color 1 :   CDATA color to scale from
      Color 2 :   CDATA color to scale to
      distance :  How from from 0 to max distance to scale.
      max :       How wide the scalar is.
      Remarks
      Max is the scale that distance can go from. Distance 0 is the
      first color, Distance == max is the second color. The
      distance from 0 to max proportionately scaled the color....
      Example
      <code lang="c++">
      CDATA green = BASE_COLOR_GREEN;
      CDATA blue = BASE_COLOR_BLUE;
      CDATA red = BASE_COLOR_RED;
      </code>
      Compute a color that is halfway from blue to green. (if the
      total distance is 100, then 50 is half way).
      <code lang="c++">
      CDATA blue_green = ColorAverage( blue, green, 50, 100 );
      </code>
      Compute a color that's mostly red.
      <code lang="c++">
      CDATA red_blue_green = ColorAverage( blue_green, red, 240, 255 );
      </code>
      Iterate through a whole scaled range...
      <code lang="c++">
      int n;
      for( n = 0; n \< 100; n++ )
      {
          CDATA scaled = ColorAverage( BASE_COLOR_WHITE, BASE_COLOR_BLACK, n, 100 );
          // as n increases, the color slowly goes from WHITE to BLACK.
      }
      </code>                                                                        */
   IMAGE_PROC  CDATA IMGVER(ColorAverage)( CDATA c1, CDATA c2, int d, int max );
   /* Creates an image from user defined parts. The buffer used is
      from the user. This was used by the video library, but
      RemakeImage accomplishes this also.
      Parameters
      pc :      the color buffer to use for the image.
      width :   how wide the color buffer is
      height :  How tall the color buffer is                       */
   IMAGE_PROC  Image IMAGE_API IMGVER(BuildImageFileEx) ( PCOLOR pc, uint32_t width, uint32_t height DBG_PASS);
   /* <combine sack::image::MakeImageFile>
      Adds <link sack::DBG_PASS, DBG_PASS> parameter. */
   /* Creates an Image with a specified width and height. The
      image's color is undefined to start.
      Parameters
      Width :     how wide to make the image. Cannot be negative.
      Height :    how tall to make the image. Cannot be negative.
      DBG_PASS :  _nt_
      Example
      See <link sack::image::Image, Image>                        */
   IMAGE_PROC  Image IMAGE_API IMGVER(MakeImageFileEx  )(uint32_t Width, uint32_t Height DBG_PASS);
   /* Creates a sub image region on an image. Sub-images may be
      used like any other image. There are two uses for this sort
      of thing. OH, the sub image shares the exact data of the
      parent image, and is not a copy.
      Parameters
      pImage :  image to make the sub image in
      x :       signed location of the top side of the sub\-image
      y :       signed location of the left side of the sub\-image
      width :   how wide to make the sub\-image
      height :  how tall to make the sub\-image
      Returns
      NULL if the input image is NULL.
      Otherwise returns an Image.
      Example
      Use 1: An image might contain a grid of symbols or
      characters, each exactly the same size. These may be token
      pieces used in a game or a special graphic font.
      <code lang="c++">
      Image pieces_image = LoadImageFile( "Game Pieces.image" );
      PLIST pieces = NULL;
      int x, y;
      \#define PIECE_WIDTH 32
      \#define PIECE_HEIGHT 32
      for( x = 0; x \< 10; x++ )
         for( y = 0; y \< 2; y++ )
         {
             AddLink( &amp;pieces, MakeSubImage( pieces_image
                                           , x * PIECE_WIDTH, y * PIECE_HEIGHT
                                           , PIECE_WIDTH, PIECE_HEIGHT );
         }
      // at this point there we have a list with all the tokens,
      // which were 32x32 pixels each.
      // Any of these piece images may be output using a scaled or direct blot.
      </code>
      Use 2: Partitioning views on an image for things like
      controls and other clipped regions.
      <code lang="c++">
      Image image = MakeImageFile( 1024, 768 );
      Image clock = MakeSubImage( image, 32, 32, 150, 16 );
      DrawString( clock, 0, 0, BASE_COLOR_WHITE, BASE_COLOR_BLACK, "Current Time..." );
      </code>                                                                           */
   IMAGE_PROC  Image IMAGE_API IMGVER(MakeSubImageEx   )( Image pImage, int32_t x, int32_t y, uint32_t width, uint32_t height DBG_PASS );
   /* Adds an image as a sub-image of another image. The image
      being added as a sub image must not already have a parent.
      Sub-images are like views into the parent, and share the same
      pixel buffer that the parent has.
      Parameters
      pFoster :  This is the parent image to received the new
                 subimage
      pOrphan :  this is the subimage to be added                   */
   IMAGE_PROC  void IMAGE_API IMGVER(AdoptSubImage    )( Image pFoster, Image pOrphan );
   /* Removes a sub-image (child image) from a parent image. The
      sub image my then be moved to another image with
      AdoptSubImage.
      Parameters
      pImage :  the sub\-image to orphan.                        */
   IMAGE_PROC  void IMAGE_API IMGVER(OrphanSubImage   )( Image pImage );
   /* Create or recreate an image using the specified color buffer,
      and size. All sub-images have their color data reference
      updated.
      Example
      <code>
      Image image = NULL;
      POINTER data = NewArray( CDATA, 100* 100 );
      image = RemakeImage( image, data, 100, 100 );
      </code>
      Remarks
      If the source image is NULL, a new image will be built using
      the color buffer and size specified.
      Image.flags has IF_FLAG_EXTERN_COLORS set if made this way,
      since the color buffer is an external resource. This causes
      UnmakeImage() to not attempt to free the color buffer.
      If the original image does exist, its color buffer is swapped
      for the one specified, and coordinates are updated. The video
      system uses this to create an image that has the color data
      surface the surface of the display.
      See Also
      <link sack::image::BuildImageFile, BuildImageFile>
      GetDisplayImage
      Parameters
      data :    Pointer to a buffer of 32 bit color data. ARGB and
                ABGR available via compile option.
      width :   the width of the data in pixels.
      height :  the height of the data in pixels.
      Returns
      \Returns the original image if not NULL, otherwise results
      with an image who's color plane is defined by a user defined
      buffer of width by height size. The user must have allocated
      this buffer appropriately, and is responsible for its
      destruction.                                                  */
   IMAGE_PROC  Image IMAGE_API IMGVER(RemakeImageEx    )( Image pImage, PCOLOR pc, uint32_t width, uint32_t height DBG_PASS);
   /* Load an image file. Today we support PNG, JPG, GIF, BMP.
      Tomorrow consider tapping into that FreeImage project on
      sourceforge, that combines all readers into one.
      Parameters
      name :      Filename to read from. Opens in 'Current Directory'
                  if not an absolute path.
      DBG_PASS :  _nt_
      Example
      See <link sack::image::Image, Image>                            */
	IMAGE_PROC  Image IMAGE_API IMGVER(LoadImageFileEx  )( CTEXTSTR name DBG_PASS );
	/* <combinewith sack::image::LoadImageFileEx@CTEXTSTR name>
	   Extended load image file. This allows specifying a file group
	   to load from. (Groups were added for platforms without
	   support of current working directory).
	   Parameters
	   group :  Group to load the file from
	   _nt_ :   _nt_                                                 */
	IMAGE_PROC Image  IMAGE_API IMGVER(LoadImageFileFromGroupEx )( INDEX group, CTEXTSTR filename DBG_PASS );
   /* Decodes a block of memory into an image. This is used
      internally so, LoadImageFile() opens the file and reads it
      into a buffer, which it then passes to DecodeMemoryToImage().
      Images stored in custom user structures may be passed for
      decoding also.
      Parameters
      buf :   Pointer to bytes of data to decode
      size :  the size of the buffer to decode
      Returns
      NULL is returned if the data does not decode as an image.
      an Image is returned otherwise.
      Example
      This pretends that you have a FILE* open to some image
      already, and that the image is tiny (less than 4k bytes).
      <code lang="c#">
      char buffer[4096];
      int length;
      length = fread( buffer, 1, 4096, some_file );
      Image image = DecodeMemoryToImage( buffer, length );
      if( image )
      {
         // buffer decoded okay.
      }
      </code>                                                       */
			IMAGE_PROC  Image IMAGE_API IMGVER(DecodeMemoryToImage )( uint8_t* buf, size_t size );
#ifdef __cplusplus
		namespace loader{
#endif
	IMAGE_PROC  LOGICAL IMAGE_API IMGVER(PngImageFile )( Image image, uint8_t* *buf, size_t *size );
	IMAGE_PROC  LOGICAL IMAGE_API IMGVER(JpgImageFile )( Image image, uint8_t* *buf, size_t *size, int Q );
#ifdef __cplusplus
		}
#endif
      /* direct hack for processing clipboard data... probably does some massaging of the databefore calling DecodeMemoryToImage */
   IMAGE_PROC  Image IMAGE_API IMGVER(ImageRawBMPFile )(uint8_t* ptr, uint32_t filesize);
	/* Releases an image, has extra debug parameters.
	   Parameters
	   Image :     the Image to release.
	   DBG_PASS :  Adds <link sack::DBG_PASS, DBG_PASS> parameter for
	               the release memory tracking.                       */
	IMAGE_PROC  void IMAGE_API IMGVER(UnmakeImageFileEx )( Image pif DBG_PASS );
   /* Sets the active image rectangle to the bounding rectangle
      specified. This can be used to limit artificially drawing
      onto an image. (It is easier to track to create a subimage in
      the location to draw instead of masking with a bound rect,
      which has problems restoring back to initial conditions)
      Parameters
      pImage :  Image to set the drawing clipping rectangle.
      bound :   a pointer to an IMAGE_RECTANGLE to set the image
                boundaries to.                                      */
   IMAGE_PROC  void  IMAGE_API IMGVER(SetImageBound    )( Image pImage, P_IMAGE_RECTANGLE bound );
// reset clip rectangle to the full image (subimage part )
// Some operations (move, resize) will also reset the bound rect,
// this must be re-set afterwards.
// ALSO - one SHOULD be nice and reset the rectangle when done,
// otherwise other people may not have checked this.
/* Change the size of an image, reallocating the color buffer as
   necessary.
   <b>Parameters</b>
   <b>Remarks</b>
   If the image is a sub image (located within a parent), the
   subimage view on the parent image is updated to the new width
   and height. The color buffer remains the parent's buffer.
   If the image is a parent, a new buffer is allocated. If the
   previous buffer was specified by the user in RemakeImage,
   that buffer is not freed, but a new buffer is still created.
   <b>Bugs</b>
   If the image is a parent image, the child images are not
   updated to the newly allocated buffer. Resize works really
   well for subimages though.                                    */
   IMAGE_PROC  void IMAGE_API IMGVER(ResizeImageEx     )( Image pImage, int32_t width, int32_t height DBG_PASS);
   /* Moves an image within a parent image. Top level images and
      images which have a user color buffer do not move.
      Parameters
      pImage :  The image to move.
      x :       the new X coordinate of the image.
      y :       the new Y coordinate of the image.               */
   IMAGE_PROC  void IMAGE_API IMGVER(MoveImage         )( Image pImage, int32_t x, int32_t y );
//-----------------------------------------------------
   IMAGE_PROC  void IMAGE_API IMGVER(BlatColor         )( Image pifDest, int32_t x, int32_t y, uint32_t w, uint32_t h, CDATA color );
   /* Blat is the sound a trumpet makes when it spews forth
      noise... so Blat color is just fill a rectangle with a color,
      quickly. Apply alpha transparency of the color specified.
      Parameters
      pifDest :  The destination image to fill the rectangle on
      x :        left coordinate of the rectangle
      y :        right coordinate of the rectangle
      w :        width of the rectangle
      h :        height of the rectangle
      color :    color to fill the rectangle with. The alpha of this
                 color will be applied.                              */
   IMAGE_PROC  void IMAGE_API IMGVER(BlatColorAlpha    )( Image pifDest, int32_t x, int32_t y, uint32_t w, uint32_t h, CDATA color );
   /* \ \
      Parameters
      pDest :         destination image (the one to copy to)
      pIF :           source image
      x :             destination top coordinate
      y :             destination left coordinate
      nTransparent :  <link sack::image::AlphaModifier, Alpha Operation>
      method :        <link sack::image::blot_methods, Blot Method>
      _nt_ :          _nt_                                               */
   IMAGE_PROC  void IMAGE_API IMGVER(BlotImageEx       )( Image pDest, Image pIF, int32_t x, int32_t y, uint32_t nTransparent, uint32_t method, ... );
   /* Copies an image from one image onto another. The copy is done
      directly and no scaling is applied. If a width or height
      larget than the image to copy is specified, only the amount
      of the image that is valid is copied.
      Parameters
      pDest :         Destination image
      pIF :           Image file to copy
      x :             X position to put copy at
      y :             Y position to put copy at
      xs :            X position to copy from.
      ys :            Y position to copy from.
      wd :            how much of the image horizontally to copy
      ht :            how much of the image vertically to copy
      nTransparent :  <link sack::image::AlphaModifier, Alpha Transparency method>
      method :        <link sack::image::blot_methods, BlotMethods>
      <b>Method == BLOT_SHADED extra parameters</b>
      red :    Color to use the red channel to output the scale from
               black to color
      green :  Color to use the red channel to output the scale from
               black to color
      blue :   Color to use the red channel to output the scale from
               black to color
      <b>Method == BLOT_SHADED extra parameters</b>
      shade :  _nt_
      See Also                                                                     */
   IMAGE_PROC  void IMAGE_API IMGVER(BlotImageSizedEx  )( Image pDest, Image pIF, int32_t x, int32_t y, int32_t xs, int32_t ys, uint32_t wd, uint32_t ht, uint32_t nTransparent, uint32_t method, ... );
   /* Copies some or all of an image to a destination image of
      specified width and height. This does linear interpolation
      scaling.
      There are simple forms of this function as macros, since
      commonly you want to output the entire image, a macro which
      automatically sets (0,0),(width,height) as the source
      \parameters to output the whole image exists.
      Parameters
      \ \
      pifDest :       Destination image
      pifSrc :        image to copy from
      xd :            destination x coordinate
      yd :            destination y coordinate
      wd :            destination width (source image width will be
                      scaled to this)
      hd :            destination height (source image height will
                      be scaled to this)
      xs :            source x coordinate (where to copy from)
      ys :            source y coordinate (where to copy from)
      ws :            source width (how much of the image to copy)
      hs :            source height (how much of the image to copy)
      nTransparent :  Alpha method...
      method :        specifies how the source color data is
                      transformed if at all. See BlotMethods
      ... :           possible extra parameters depending on method
      <b>Method == BLOT_MULTISHADE extra parameters</b>
      red :    Color to use the red channel to output the scale from
               black to color
      green :  Color to use the red channel to output the scale from
               black to color
      blue :   Color to use the red channel to output the scale from
               black to color
      <b>Method == BLOT_SHADED extra parameters</b>
      shade :  _nt_
      See Also
      <link sack::image::AlphaModifier, Alpha Methods>
      <link sack::image::blot_methods, Blot Methods>
      <link sack::image::BlotScaledImage, BlotScaledImage>
      <link sack::image::BlotScaledImageShaded, BlotScaledImageShaded>
      <link sack::image::BlotScaledImageShadedAlpha, BlotScaledImageShadedAlpha>
                                                                                 */
   IMAGE_PROC  void IMAGE_API IMGVER(BlotScaledImageSizedEx)( Image pifDest, Image pifSrc
                                   , int32_t xd, int32_t yd
                                   , uint32_t wd, uint32_t hd
                                   , int32_t xs, int32_t ys
                                   , uint32_t ws, uint32_t hs
                                   , uint32_t nTransparent
                                   , uint32_t method, ... );
/* Your basic PLOT functions (Image.C, plotasm.asm)
   A function pointer to the function which sets a pixel in an
   image at a specified x, y coordinate.
   Parameters
   Image :  The image to get the pixel from
   X :      x coordinate to get pixel color
   Y :      y coordinate to get pixel color
   Color :  color to put at the coordinate. image will be set
            exactly to this color, and whatever the alpha of the
            color is.                                            */
   IMAGE_PROC  void plot       ( Image pi, int32_t x, int32_t y, CDATA c );
   /* A function pointer to the function which sets a pixel in an
      image at a specified x, y coordinate.
      Parameters
      Image :  The image to get the pixel from
      X :      x coordinate to get pixel color
      Y :      y coordinate to get pixel color
      Color :  color to put at the coordinate. Alpha blending will be
               done.                                                  */
   IMAGE_PROC  void plotalpha  ( Image pi, int32_t x, int32_t y, CDATA c );
   /* A function pointer to the function which gets a pixel from an
      image at a specified x, y coordinate.
      Parameters
      Image :  The image to get the pixel from
      X :      x coordinate to get pixel color
      Y :      y coordinate to get pixel color
      Returns
      CDATA color in the Image at the specified coordinate.         */
   IMAGE_PROC  CDATA getpixel  ( Image pi, int32_t x, int32_t y );
//-------------------------------
// Line functions  (lineasm.asm) // should include a line.c ... for now core was assembly...
//-------------------------------
  // d is color data...
   IMAGE_PROC  void do_line      ( Image pBuffer, int32_t x, int32_t y, int32_t xto, int32_t yto, CDATA color );
  // d is color data...
   IMAGE_PROC  void do_lineAlpha ( Image pBuffer, int32_t x, int32_t y, int32_t xto, int32_t yto, CDATA color);
   /* This is a function pointer that references a function to do
      optimized horizontal lines. The function pointer is updated
      when SetBlotMethod() is called.
      Parameters
      Image :   the image to draw to
      Y :       the y coordinate of the line (how far down from top to
                draw it)
      x_from :  X coordinate to draw from
      x_to :    X coordinate to draw to
      color :   the color of the line. This color will be set to the
                surface, the alpha result will be the alpha of this
                color.                                                 */
   IMAGE_PROC  void do_hline      ( Image pImage, int32_t y, int32_t xfrom, int32_t xto, CDATA color );
   /* This is a function pointer that references a function to do
      optimized vertical lines. The function pointer is updated
      when SetBlotMethod() is called.
      Parameters
      Image :   the image to draw to
      X :       the x coordinate of the line (how far over to draw
                it)
      y_from :  Y coordinate to draw from
      y_to :    Y coordinate to draw to
      color :   the color of the line. This color will be set to the
                surface, the alpha result will be the alpha of this
                color.                                               */
   IMAGE_PROC  void do_vline      ( Image pImage, int32_t x, int32_t yfrom, int32_t yto, CDATA color );
   /* This is a function pointer that references a function to do
      optimized horizontal lines with alpha blending. The function
      pointer is updated when SetBlotMethod() is called.
      Parameters
      Image :   the image to draw to
      Y :       the Y coordinate of the line (how far down from top
                of image to draw it)
      x_from :  X coordinate to draw from
      x_to :    X coordinate to draw to
      color :   the color of the line (alpha component of the color
                will be applied)                                    */
   IMAGE_PROC  void do_hlineAlpha ( Image pImage, int32_t y, int32_t xfrom, int32_t xto, CDATA color );
   /* This is a function pointer that references a function to do
      optimized vertical lines with alpha blending. The function
      pointer is updated when SetBlotMethod() is called.
      Parameters
      Image :   the image to draw to
      X :       the x coordinate of the line (how far over to draw
                it)
      y_from :  Y coordinate to draw from
      y_to :    Y coordinate to draw to
      color :   the color of the line (alpha component of the color
                will be applied)                                    */
   IMAGE_PROC  void do_vlineAlpha ( Image pImage, int32_t x, int32_t yfrom, int32_t yto, CDATA color );
	/* routine which iterates through the points along a lone from
	   x,y to xto,yto, calling a user function at each point.
	   Parameters
	   Image :  the image to pretend to draw on
	   x :      draw from this x coordinate
	   y :      draw from this y coordinate
	   xto :    draw to this x coordinate
	   yto :    draw to this y coordinate
	   d :      userdata (color data)
	   func :   user callback function to a function of type...<p />void
	            func( Image pif, int32_t x, int32_t y, int d ) ;
	   Remarks
	   The Image passed does not HAVE to be an Image, it can be any
	   user POINTER.
	   The data passed is limited to 32 bits, and will not hold a
	   pointer if built for 64 bit platform.
	   Example
	   <code lang="c++">
	   Image image;
	   void MyPlotter( Image image, int32_t x, int32_t y, CDATA color )
	   {
	       // do something with the image at x,y
	   }
	   void UseMyPlotter( Image image )
	   {
	       do_lineExV( image, 10, 10, 80, 80, BASE_COLOR_BLACK, MyPlotter );
	   }
	   </code>                                                               */
	IMAGE_PROC  void do_lineExV    ( Image pImage, int32_t x, int32_t y
									, int32_t xto, int32_t yto, uintptr_t color
		                            , void (*func)( Image pif, int32_t x, int32_t y, uintptr_t d ) );
   /* \Returns the correct SFTFont pointer to the default font. In all
      font functions, NULL may be used as the font, and this is the
      font that will be used.
      Parameters
      None.
      Example
      <code lang="c++">
      SFTFont font = GetDefaultFont();
      </code>                                                       */
   IMAGE_PROC  SFTFont IMAGE_API IMGVER(GetDefaultFont )( void );
   /* \Returns the height of a font for purposes of spacing between
      lines. Characters may render outside of this height.
      Parameters
      SFTFont :  SFTFont to get the height of. if NULL returns an internal
              font's height.
      Returns
      the height of the font.                                        */
   IMAGE_PROC  uint32_t  IMAGE_API IMGVER(GetFontHeight  )( SFTFont );
   /* \Returns the approximate rectangle that would be used for a
      string. It only counts using the line measurement. Newlines
      in strings count to wrap text to subsequent lines and start
      recounting the width, returning the maximum length of string
      horizontally.
      Parameters
      pString :  The string to measure
      len :      the length of characters to count in string
      width :    a pointer to a uint32_t to receive the width of the
                 string
      height :   a pointer to a uint32_t to receive the height of the
                 string
      UseFont :  A SFTFont to use.
      Returns
      \Returns the width parameter. If NULL are passed for width
      and height, this is OK. One of the simple macros just passes
      the string and gets the return - this is for how wide the
      string would be.                                             */
   IMAGE_PROC  uint32_t  IMAGE_API IMGVER(GetStringSizeFontEx)( CTEXTSTR pString, size_t len, uint32_t *width, uint32_t *height, SFTFont UseFont );
   /* Fill the width and height with the actual size of the string
      as it is drawn. (may be above or below the original
      rectangle)
      Parameters
      pString :     the string to measure
      nLen :        the number of characters in the string
      width :       a pointer to a 32 bit value to get resulting
                    width
      height :      a pointer to a 32 bit value to get resulting
                    height
      charheight :  the actual height of the characters (as reports
                    by line)
      UseFont :     a SFTFont to use. If NULL use a default internal
                    font.                                           */
   IMAGE_PROC  uint32_t IMAGE_API IMGVER(GetStringRenderSizeFontEx )( CTEXTSTR pString, size_t nLen, uint32_t *width, uint32_t *height, uint32_t *charheight, SFTFont UseFont );
// background of color 0,0,0 is transparent - alpha component does not
// matter....
   IMAGE_PROC  void IMAGE_API IMGVER(PutCharacterFont              )( Image pImage
                                                  , int32_t x, int32_t y
                                                  , CDATA color, CDATA background,
                                                   TEXTCHAR c, SFTFont font );
   /* Outputs a string in the specified font, from the specified
      point, text is drawn from the point up, with the characters
      aligned with the top to the left; it goes up from the point.
      the point becomes the bottom left of the rectangle output.
      Parameters
      pImage :      image to draw string into
      x :           x position of the string
      y :           y position of the string
      color :       color of the data drawn in the font
      background :  color of the data not drawn in the font
      c :           the character to output
      font :        the font to use. NULL use an internal default
                    font.                                          */
   IMAGE_PROC  void IMAGE_API IMGVER(PutCharacterVerticalFont      )( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
   /* Outputs a string in the specified font, from the specified
      point, text is drawn from the point to the left, with the
      characters aligned with the top to the left; it goes up from
      the point. the point becomes the bottom left of the rectangle
      \output.
      Parameters
      pImage :      image to draw string into
      x :           x position of the string
      y :           y position of the string
      color :       color of the data drawn in the font
      background :  color of the data not drawn in the font
      pc :          pointer to constant text
      nLen :        length of text to output
      font :        the font to use. NULL use an internal default
                    font.                                           */
   IMAGE_PROC  void IMAGE_API IMGVER(PutCharacterInvertFont        )( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
   /* Outputs a character in the specified font, from the specified
      point, text is drawn from the point up, with the characters
      aligned with the top to the left; it goes up from the point. the
      point becomes the bottom left of the rectangle output.
      Parameters
                                                                       */
   IMAGE_PROC  void IMAGE_API IMGVER(PutCharacterVerticalInvertFont)( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
   /* Outputs a string in the specified font, from the specified
      point, text is drawn right side up and godes from left to
      right. The point becomes the top left of the rectangle
      \output.
      Parameters
      pImage :      image to draw string into
      x :           x position of the string
      y :           y position of the string
      color :       color of the data drawn in the font
      background :  color of the data not drawn in the font
      pc :          pointer to constant text
      nLen :        length of text to output
      font :        the font to use. NULL use an internal default
                    font.                                         */
   IMAGE_PROC  void IMAGE_API IMGVER(PutStringFontEx              )( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
   /* justification 0 is left, 1 is right, 2 is center */
   IMAGE_PROC  void IMAGE_API IMGVER(PutStringFontExx              )( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font, int justication, uint32_t _width );
   /* Outputs a string in the specified font, from the specified
      point, text is drawn from the point down, with the characters
      aligned with the top to the right; it goes down from the
      point. the point becomes the top right of the rectangle
      \output.
      Parameters
      pImage :      image to draw string into
      x :           x position of the string
      y :           y position of the string
      color :       color of the data drawn in the font
      background :  color of the data not drawn in the font
      pc :          pointer to constant text
      nLen :        length of text to output
      font :        the font to use. NULL use an internal default
                    font.                                           */
   IMAGE_PROC  void IMAGE_API IMGVER(PutStringVerticalFontEx      )( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
   /* Outputs a string in the specified font, from the specified
      point, text is drawn upside down, and goes to the left from
      the point. the point becomes the bottom right of the
      rectangle output.
      Parameters
      pImage :      image to draw string into
      x :           x position of the string
      y :           y position of the string
      color :       color of the data drawn in the font
      background :  color of the data not drawn in the font
      pc :          pointer to constant text
      nLen :        length of text to output
      font :        the font to use. NULL use an internal default
                    font.                                         */
   IMAGE_PROC  void IMAGE_API IMGVER(PutStringInvertFontEx        )( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
   /* Outputs a string in the specified font, from the specified
      point, text is drawn from the point up, with the characters
      aligned with the top to the left; it goes up from the point. the
      point becomes the bottom left of the rectangle output.
      Parameters
      pImage :      image to draw string into
      x :           x position of the string
      y :           y position of the string
      color :       color of the data drawn in the font
      background :  color of the data not drawn in the font
      pc :          pointer to constant text
      nLen :        length of text to output
      font :        the font to use. NULL use an internal default
                    font.                                              */
   IMAGE_PROC  void IMAGE_API IMGVER(PutStringInvertVerticalFontEx)( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
   //uint32_t (*PutMenuStringFontEx)            ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, uint32_t nLen, SFTFont font );
   //uint32_t (*PutCStringFontEx)               ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, uint32_t nLen, SFTFont font );
   IMAGE_PROC  uint32_t IMAGE_API IMGVER(GetMaxStringLengthFont  )( uint32_t width, SFTFont UseFont );
   /* Used as a proper accessor method to get an image's width and
      height. Decided to allow the image structure to be mostly
      public, so the first 4 members are the images x,y, width and
      height, and are immediately accessable by the Image pointer.
      Parameters
      pImage :  image to get the size of
      width :   pointer to a 32 bit unsigned value to result with the
                width, if NULL ignored.
      height :  pointer to a 32 bit unsigned value to result with the
                height, if NULL ignored.                              */
   IMAGE_PROC  void IMAGE_API IMGVER(GetImageSize            )( Image pImage, uint32_t *width, uint32_t *height );
   /* \Returns the pointer to the color buffer currently used
      \internal to the image.
      Parameters
      pImage :  Image to get the surface of.
      Example
      <code lang="c#">
      Image image = MakeImageFile( 100, 100 );
      PCDATA pointer_color_data = GetImageSurface( image );
      </code>
      Note
      This might be used to do an optimized output routine. Drawing
      to the image with plot and line are not necessarily the best
      for things like circles. Provides ability for user to output
      directly to the color buffer.                                 */
   IMAGE_PROC  PCDATA IMAGE_API IMGVER(GetImageSurface        )( Image pImage );
   // would seem silly to load fonts - but for server implementations
   // the handle received is not the same as the font sent.
   IMAGE_PROC  SFTFont IMAGE_API IMGVER(LoadFont                )( SFTFont font );
   /* Destroys a font, releasing all resources associated with
      character data and font rendering.                       */
   IMAGE_PROC  void IMAGE_API IMGVER(UnloadFont              )( SFTFont font );
	/* This is a function used to synchronize image operations when
	   the image interface is across a message server.              */
	IMAGE_PROC  void IMAGE_API IMGVER(SyncImage                  )( void );
	// intersect rectangle, results with the overlapping portion of R1 and R2
   // into R ...
   IMAGE_PROC  int IMAGE_API IMGVER(IntersectRectangle )( IMAGE_RECTANGLE *r, IMAGE_RECTANGLE *r1, IMAGE_RECTANGLE *r2 );
   /* Merges two image rectangles. The resulting rectangle is a
      rectangle that includes both rectangles.
      Parameters
      r :   Pointer to an IMAGE_RECTANGLE for the result.
      r1 :  PIMAGE_RECTANGLE one rectangle.
      r2 :  PIMAGE_RECTANGLE the other rectangle.               */
   IMAGE_PROC  int IMAGE_API IMGVER(MergeRectangle )( IMAGE_RECTANGLE *r, IMAGE_RECTANGLE *r1, IMAGE_RECTANGLE *r2 );
   /* User applications may use an aux rect attatched to an image. The
      'Display' render library used this itself however, making
      this mostly an internal feature.
      Parameters
      pImage :  image to get the aux rect of.
      pRect :   pointer to an IMAGE_RECTANGLE to get the aux
                rectangle data in.                                     */
   IMAGE_PROC  void IMAGE_API IMGVER(GetImageAuxRect    )( Image pImage, P_IMAGE_RECTANGLE pRect );
   /* User applications may use an aux rect attatched to an image.
      The 'Display' render library used this itself however, making
      this mostly an internal feature.
      Parameters
      pImage :  image to set the aux rect of.
      pRect :   pointer to an IMAGE_RECTANGLE to set the aux
                rectangle to.                                       */
   IMAGE_PROC  void IMAGE_API IMGVER(SetImageAuxRect    )( Image pImage, P_IMAGE_RECTANGLE pRect );
	/* \ \
	   Parameters
	   Filename :  \file name of image to load. Converts image into
	               sprite automatically, resulting with a sprite.
	   DBG_PASS :  See <link sack::DBG_PASS, DBG_PASS>              */
		IMAGE_PROC  PSPRITE IMAGE_API IMGVER(MakeSpriteImageFileEx )( CTEXTSTR fname DBG_PASS );
      /* create a sprite from an Image */
	IMAGE_PROC  PSPRITE IMAGE_API IMGVER(MakeSpriteImageEx )( Image image DBG_PASS );
	/* Release a Sprite. */
	IMAGE_PROC  void IMAGE_API IMGVER(UnmakeSprite )( PSPRITE sprite, int bForceImageAlso );
	// angle is a fixed scaled integer with 0x1 0000 0000 being the full circle.
	IMAGE_PROC  void IMAGE_API IMGVER(rotate_scaled_sprite )(Image bmp, PSPRITE sprite, fixed angle, fixed scale_width, fixed scale_height );
   /* output a rotated sprite to destination image, using and angle specified.  The angle is represented as 0x1 0000 0000 is 360 degrees */
	IMAGE_PROC  void IMAGE_API IMGVER(rotate_sprite )(Image bmp, PSPRITE sprite, fixed angle);
   /* output a sprite at its current location */
	IMAGE_PROC  void IMAGE_API IMGVER(BlotSprite )( Image pdest, PSPRITE ps );
/* Sets the point on a sprite which is the 'hotspot' the hotspot
   is the point that is drawn at the specified coordinate when
   outputting a sprite.
   Parameters
   sprite :  The PSPRITE to set the hotspot of.
   x :       x coordinate in the sprite's image that becomes the
             hotspot.
   y :       y coordinate in the sprite's image that becomes the
             hotspot.                                            */
IMAGE_PROC  PSPRITE IMAGE_API IMGVER(SetSpriteHotspot )( PSPRITE sprite, int32_t x, int32_t y );
/* This function sets the current location of a sprite. When
   asked to render, the sprite will draw itself here.
   Parameters
   sprite :  the sprite to move
   x :       the new x coordinate of the parent image to draw at
   y :       the new y coordinate of the parent image to draw at */
IMAGE_PROC  PSPRITE IMAGE_API IMGVER(SetSpritePosition )( PSPRITE sprite, int32_t x, int32_t y );
/* Use a font file to get a font that can be used for outputting
   characters and strings.
   Parameters
   file\ :    Filename of a font to render.
   nWidth :   desired width in pixels to render the font.
   nHeight :  desired height in pixels to render the font.
   flags :    0 = render mono. 2=render 2 bits, 3=render 8 bit.  */
IMAGE_PROC  SFTFont IMAGE_API IMGVER(InternalRenderFontFile )( CTEXTSTR file
																		, int32_t nWidth
																		, int32_t nHeight
																		, PFRACTION width_scale
																		, PFRACTION height_scale
																		, uint32_t flags
																		);
/* Rerender the current font with a new size. */
IMAGE_PROC void IMAGE_API IMGVER(RerenderFont)( SFTFont font, int32_t width, int32_t height, PFRACTION width_scale, PFRACTION height_scale );
	/* Dumps the whole cache to log file, shows family, style, path and filename.
    Is the same sort of dump that OpenFontFile uses.
	 */
IMAGE_PROC void IMAGE_API IMGVER(DumpFontCache)( void );
#ifndef INTERNAL_DUMP_FONT_FILE
/* takes a font and dumps a header-file formatted file; then the font can be
 statically built into code. */
IMAGE_PROC void IMAGE_API IMGVER(DumpFontFile)( CTEXTSTR name, SFTFont font_to_dump );
#endif
/* Creates a font based on indexes from the internal font cache.
   This is used by the FontPicker dialog to choose a font. The
   data the dialog used to render the font is available to the
   application, and may be passed back for rendering a font
   without knowing specifically what the values mean.
   Parameters
   nFamily :  The number of the family in the cache.
   nStyle :   The number of the style in the cache.
   nFile :    The number of the file in the cache.
   nWidth :   the width to use for rendering characters (in
              pixels)
   nHeight :  the height to use for rendering characters (in
              pixels)
   flags :    0 = render mono. 2=render 2 bits, 3=render 8 bit.
   Returns
   A SFTFont which can be used to output. If the file exists. NULL
   on failure.
   Example
   Used internally for FontPicker dialog, see <link sack::image::InternalRenderFontFile@CTEXTSTR@int32_t@int32_t@uint32_t, InternalRenderFontFile> */
IMAGE_PROC  SFTFont IMAGE_API IMGVER(InternalRenderFont )( uint32_t nFamily
																  , uint32_t nStyle
																  , uint32_t nFile
																  , int32_t nWidth
																  , int32_t nHeight
																  , PFRACTION width_scale
																  , PFRACTION height_scale
																  , uint32_t flags
																  );
/* Releases all resources for a SFTFont.  */
IMAGE_PROC  void IMAGE_API IMGVER(DestroyFont)( SFTFont *font );
/* Get the global font data structure. This is an internal
   structure, and it's definition may not be exported. Currently
   the definition is in documentation.
   See Also
   <link sack::image::FONT_GLOBAL, SFTFont Global>                  */
IMAGE_PROC  struct font_global_tag * IMAGE_API IMGVER(GetGlobalFonts)( void );
// types of data which may result...
typedef struct font_data_tag *PFONTDATA;
/* Information to render a font from a file to memory. */
typedef struct render_font_data_tag *PRENDER_FONTDATA;
/* Recreates a SFTFont based on saved FontData. The resulting font
   may be scaled from its original size.
   Parameters
   pfd :           pointer to font data.
   width_scale :   FRACTION to scale the original font height
                   \description by. if NULL uses the original
                   font's size.
   height_scale :  FRACTION to scale the original font height
                   \description by.  if NULL uses the original
                   font's size.
   Example
   <code lang="c++">
   POINTER some_loaded_data; // pretend it is initialized to something valid
   SFTFont font = RenderScaledFontData( some_loaded_data, NULL, NULL );
   PutStringFont( image, 0, 0, BASE_COLOR_WHITE, 0, "Hello World", font );
   </code>
   Or, maybe your original designed screen was 1024x768, and
   it's now showing on 1600x1200, for the text to remain the
   same...
   <code lang="c++">
   FRACTION width_scale;
   FRACTION height_scale;
   uint32_t w, h;
   GetDisplaySize( &amp;w, &amp;h );
   SetFraction( width_scale, w, 1024 );
   SetFraction( height_scale, h, 768 );
   SFTFont font2 = RenderScaledFontData( some_loaded_data, &amp;width_scale, &amp;height_scale );
   PutStringFont( image, 0, 0, BASE_COLOR_WHITE, 0, "Hello World", font2 );
   </code>                                                                                     */
IMAGE_PROC  SFTFont IMAGE_API IMGVER(RenderScaledFontData)( PFONTDATA pfd, PFRACTION width_scale, PFRACTION height_scale );
/* <combine sack::image::RenderScaledFontData@PFONTDATA@PFRACTION@PFRACTION>
   \ \                                                                       */
#define RenderFontData(pfd) RenderScaledFontData( pfd,NULL,NULL )
#define ogl_RenderFontData(pfd) ogl_RenderScaledFontData( pfd,NULL,NULL )
/* <combinewith sack::image::RenderScaledFontEx@CTEXTSTR@uint32_t@uint32_t@PFRACTION@PFRACTION@uint32_t@size_t *@POINTER *, sack::image::RenderScaledFontData@PFONTDATA@PFRACTION@PFRACTION>
   \ \                                                                                                                                                                        */
IMAGE_PROC SFTFont IMAGE_API IMGVER(RenderScaledFontEx)( CTEXTSTR name, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags, size_t *pnFontDataSize, POINTER *pFontData );
/* Renders a font with a FRACTION scalar for the X and Y sizes.
   Parameters
   name :          Name of the font (file).
   width :         Original width (in pels) to make the font.
   height :        Original height (in pels) to make the font.
   width_scale :   scalar to apply to the width
   height_scale :  scalar to apply to the height
   flags :         Flags specifying how many bits to render the
                   font with (and other info?) See enum
                   FontFlags.                                   */
IMAGE_PROC SFTFont IMAGE_API IMGVER(RenderScaledFont)( CTEXTSTR name, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags );
#define RenderScaledFont(n,w,h,ws,hs) RenderScaledFontEx(n,w,h,ws,hs,NULL,NULL)
/* Renders a font file and returns a SFTFont. The font can then be
   used in string output functions to images.
   Parameters
   file\ :           \File name of a font to render. Any font
                     that freetype supports.
   width :           width of characters to render in.
   height :          height of characters to render.
   flags :           if( ( flags &amp; 3 ) == 3 )<p /> font\-\>flags
                     = FONT_FLAG_8BIT;<p /> else if( ( flags &amp;
                     3 ) == 2 )<p /> font\-\>flags =
                     FONT_FLAG_2BIT;<p /> else<p /> font\-\>flags
                     = FONT_FLAG_MONO;<p />
   pnFontDataSize :  optional pointer to a 32 bit value to
                     receive the size of rendered data.
   pFontData :       The render data. This data can be used to
                     recreate this font.                             */
IMAGE_PROC  SFTFont IMAGE_API IMGVER(RenderFontFileScaledEx )( CTEXTSTR file, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags, size_t *pnFontDataSize, POINTER *pFontData );
/* <combine sack::image::RenderFontFileEx@CTEXTSTR@uint32_t@uint32_t@uint32_t@uint32_t*@POINTER *>
   \ \                                                                         */
#define RenderFontFile(file,w,h,flags) RenderFontFileScaledEx(file,w,h,NULL,NULL,flags,NULL,NULL)
#define RenderFontFileEx(file,w,h,flags,a,b) RenderFontFileScaledEx(file,w,h,NULL,NULL,flags,a,b )
		/* This can be used to get the internal description of a font,
		   which the user may then save, and use later to recreate the
		   font the same way.
		   Parameters
		   font :         SFTFont to get the render description from.
		   fontdata :     a pointer to a pointer which will be filled
		                  with a pointer buffer that has the font data.
		   fontdatalen :  a pointer to 32 bit value to receive the length
		                  of data.                                        */
		IMAGE_PROC  int IMAGE_API IMGVER(GetFontRenderData )( SFTFont font, POINTER *fontdata, size_t *fontdatalen );
// exported for the PSI font chooser to set the data for the font
// to be retreived later when only the font handle remains.
IMAGE_PROC  void IMAGE_API IMGVER(SetFontRendererData )( SFTFont font, POINTER pResult, size_t size );
#ifndef PSPRITE_METHOD
/* <combine sack::image::PSPRITE_METHOD>
   \ \                                   */
#define PSPRITE_METHOD PSPRITE_METHOD
	typedef struct sprite_method_tag *PSPRITE_METHOD;
#endif
	// provided for display rendering portion to define this method for sprites to use.
   // deliberately out of namespace... please do not move this up.
IMAGE_PROC  void IMAGE_API IMGVER(SetSavePortion )( void (CPROC*_SavePortion )( PSPRITE_METHOD psm, uint32_t x, uint32_t y, uint32_t w, uint32_t h ) );
/* \Returns the red channel of the color
   Parameters
   color :  Color to get the red channel of.
   Returns
   The COLOR_CHANNEL (byte) of the red channel in the color. */
IMAGE_PROC COLOR_CHANNEL IMAGE_API IMGVER(GetRedValue)( CDATA color ) ;
/* \Returns the green channel of the color
   Parameters
   color :  Color to get the green channel of.
   Returns
   The COLOR_CHANNEL (byte) of the green channel in the color. */
IMAGE_PROC COLOR_CHANNEL IMAGE_API IMGVER(GetGreenValue)( CDATA color );
/* \Returns the blue channel of the color
   Parameters
   color :  Color to get the blue channel of.
   Returns
   The COLOR_CHANNEL (byte) of the blue channel in the color. */
IMAGE_PROC COLOR_CHANNEL IMAGE_API IMGVER(GetBlueValue)( CDATA color );
/* \Returns the alpha channel of the color
   Parameters
   color :  Color to get the alpha channel of.
   Returns
   The COLOR_CHANNEL (byte) of the alpha channel in the color. */
IMAGE_PROC COLOR_CHANNEL IMAGE_API IMGVER(GetAlphaValue)( CDATA color );
/* Sets the red channel in a color value.
   Parameters
   color :  Original color to modify
   b :      new red channel value         */
IMAGE_PROC CDATA IMAGE_API IMGVER(SetRedValue)( CDATA color, COLOR_CHANNEL r ) ;
/* Sets the green channel in a color value.
   Parameters
   color :  Original color to modify
   g :      new green channel value         */
IMAGE_PROC CDATA IMAGE_API IMGVER(SetGreenValue)( CDATA color, COLOR_CHANNEL green );
/* Sets the blue channel in a color value.
   Parameters
   color :  Original color to modify
   b :      new blue channel value         */
IMAGE_PROC CDATA IMAGE_API IMGVER(SetBlueValue)( CDATA color, COLOR_CHANNEL b );
/* Sets the alpha channel in a color value.
   Parameters
   color :  Original color to modify
   a :      new alpha channel value         */
IMAGE_PROC CDATA IMAGE_API IMGVER(SetAlphaValue)( CDATA color, COLOR_CHANNEL a );
/* Makes a CDATA color from the RGB components. Sets the alpha
   as 100% opaque.
   Parameters
   r :      red channel of new color
   green :  green channel of new color
   b :      blue channel of new color                          */
IMAGE_PROC CDATA IMAGE_API IMGVER(MakeColor)( COLOR_CHANNEL r, COLOR_CHANNEL green, COLOR_CHANNEL b );
/* Create a CDATA color from components.
   Parameters
   r :      Red channel value
   green :  green channel value
   b :      blue channel value
   a :      alpha channel value
   Returns
   A CDATA representing the color specified. */
IMAGE_PROC CDATA IMAGE_API IMGVER(MakeAlphaColor)( COLOR_CHANNEL r, COLOR_CHANNEL green, COLOR_CHANNEL b, COLOR_CHANNEL a );
/* With 3d renderer, images have a transformation matrix. This
   function allows you to get the transformation matrix.
   Parameters
   pImage :  image to get the transformation matrix of.        */
IMAGE_PROC  PTRANSFORM IMAGE_API IMGVER(GetImageTransformation)( Image pImage );
enum image_translation_relation
{
   IMAGE_TRANSFORM_RELATIVE_CENTER = 0,
   IMAGE_TRANSFORM_RELATIVE_LEFT,
   IMAGE_TRANSFORM_RELATIVE_RIGHT,
   IMAGE_TRANSFORM_RELATIVE_TOP,
   IMAGE_TRANSFORM_RELATIVE_BOTTOM,
   IMAGE_TRANSFORM_RELATIVE_TOP_LEFT,
   IMAGE_TRANSFORM_RELATIVE_TOP_RIGHT,
   IMAGE_TRANSFORM_RELATIVE_BOTTOM_LEFT,
   IMAGE_TRANSFORM_RELATIVE_BOTTOM_RIGHT,
 // only mode that uses the 'aux' parameter of SetImageTransformRelation
   IMAGE_TRANSFORM_RELATIVE_OTHER
};
/*
 This sets flags on the image, so when it's called for rendering to the screen
 this is how
    */
IMAGE_PROC  void IMAGE_API IMGVER(SetImageTransformRelation)( Image pImage, enum image_translation_relation relation, PRCOORD aux );
/*
 This just draws the image into the current 3d context.
 This is a point-sprite engine too....
 It does not setup anything about rendering this, just generates the texture at the right coords.
 Parameters
 render_pixel_scaled : when drawing, reverse compute from the angle of the view, and the depth of the thing to scale orthagonal, but at depth.  (help 3d vision)
 */
IMAGE_PROC  void IMAGE_API IMGVER(Render3dImage)( Image pImage, PCVECTOR o, LOGICAL render_pixel_scaled );
IMAGE_PROC  void IMAGE_API IMGVER(Render3dText)( CTEXTSTR string, int characters, CDATA color, SFTFont font, PCVECTOR o, LOGICAL render_pixel_scaled );
/*
  Utilized by fonts with images with reverse_interface set to transfer child images;
  may be generally useful; but had to be exposed through interface
  Might be a shallow move....
 */
IMAGE_PROC  void IMAGE_API IMGVER(TransferSubImages)( Image pImageTo, Image pImageFrom );
IMAGE_PROC  LOGICAL IMAGE_API IMGVER(IsImageTargetFinal)( Image image );
/* These flags are used in SetImageRotation and RotateImageAbout
   functions - these are part of the 3D driver interface
   extension. They allow for controlling how the rotation is
   performed.                                                    */
enum image_rotation_flags {
 // relative to center of image (center if not left, right, top or bottom )
	IMAGE_ROTATE_FLAG_CENTER = 0,
 // relative to top edge (center if not left or right)
   IMAGE_ROTATE_FLAG_TOP,
 // relative to left edge (center if not top or bottom)
   IMAGE_ROTATE_FLAG_LEFT,
 // relative to right edge (center if not top or bottom)
   IMAGE_ROTATE_FLAG_RIGHT,
 // relative to bottom edge (center if not left or right )
   IMAGE_ROTATE_FLAG_BOTTOM,
 // use the offset relative to the image orientation
	IMAGE_ROTATE_FLAG_ADD_CUSTOM_OFFSET
};
/* Sets the rotation matrix of an image to an arbitrary
   yaw/pitch/roll coordinate.
   Parameters
   pImage :     Image to rotate
   edge_flag :  what edge the rotation is relative to
   offset_x :   offset from the edge to get the center
   offset_y :   offset from the edge to get the center
   rx :         rotation about x axis (horizontal)
   ry :         rotation about y axis (vertical)
   rz :         rotation about z axis (into screen)     */
IMAGE_PROC void IMAGE_API IMGVER(SetImageRotation)( Image pImage, int edge_flag, RCOORD offset_x, RCOORD offset_y, RCOORD rx, RCOORD ry, RCOORD rz );
/* Allows arbitrary rotation of an image in 3d render mode.
   Parameters
   pImage :     image to rotate
   edge_flag :  see enum image_rotation_flags
   offset_x :   offset from top left of image to center the
                rotation
   offset_y :   offset from top left of image to center the
                rotation
   vAxis :      axis to rotate around, can be any arbitrary
                direction
   angle :      angle of rotation around the axis.
   Remarks
   \See Also <link sack::image::image_rotation_flags, image_rotation_flags Enumeration> */
IMAGE_PROC void IMAGE_API IMGVER(RotateImageAbout)( Image pImage, int edge_flag, RCOORD offset_x, RCOORD offset_y, PVECTOR vAxis, RCOORD angle );
IMAGE_PROC void IMAGE_API IMGVER(MarkImageDirty)( Image pImage );
_INTERFACE_NAMESPACE
/* Defines a pointer member of the interface structure. */
#define IMAGE_PROC_PTR(type,name) type (CPROC*_##name)
/* Macro to build function pointer entries in the image
   interface.                                           */
//#define DIMAGE_PROC_PTR(type,name) type (CPROC**_##name)
/* This defines the interface call table. each function
   available in the API is reflected in this interface. It
   provdes a function table so applications don't have to be
   directly linked to the image API. This allows replacing the
   image API.                                                  */
typedef struct image_interface_tag
{
/* <combine sack::image::SetStringBehavior@Image@uint32_t>
   Internal
   Interface index 4                                  */
 IMAGE_PROC_PTR( void, SetStringBehavior) ( Image pImage, uint32_t behavior );
/* <combine sack::image::SetBlotMethod@uint32_t>
   \ \
   Internal
   Interface index 5                        */
 IMAGE_PROC_PTR( void, SetBlotMethod)     ( uint32_t method );
/*
   Internal
   Interface index 6*/
   IMAGE_PROC_PTR( Image,BuildImageFileEx) ( PCOLOR pc, uint32_t width, uint32_t height DBG_PASS);
/* <combine sack::image::MakeImageFileEx@uint32_t@uint32_t Height>
   Internal
   Interface index 7*/
  IMAGE_PROC_PTR( Image,MakeImageFileEx)  (uint32_t Width, uint32_t Height DBG_PASS);
/* <combine sack::image::MakeSubImageEx@Image@int32_t@int32_t@uint32_t@uint32_t height>
   Internal
   Interface index 8                                                                    */
   IMAGE_PROC_PTR( Image,MakeSubImageEx)   ( Image pImage, int32_t x, int32_t y, uint32_t width, uint32_t height DBG_PASS );
/* <combine sack::image::RemakeImageEx@Image@PCOLOR@uint32_t@uint32_t height>
   \ \
   <b>Internal</b>
   Interface index 9                                                */
   IMAGE_PROC_PTR( Image,RemakeImageEx)    ( Image pImage, PCOLOR pc, uint32_t width, uint32_t height DBG_PASS);
/* <combine sack::image::LoadImageFileEx@CTEXTSTR name>
   Internal
   Interface index 10                                                   */
  IMAGE_PROC_PTR( Image,LoadImageFileEx)  ( CTEXTSTR name DBG_PASS );
/* <combine sack::image::UnmakeImageFileEx@Image pif>
   Internal
   Interface index 11                                                 */
  IMAGE_PROC_PTR( void,UnmakeImageFileEx) ( Image pif DBG_PASS );
//-----------------------------------------------------
/* <combine sack::image::ResizeImageEx@Image@int32_t@int32_t height>
   Internal
   Interface index 14                                                          */
  IMAGE_PROC_PTR( void,ResizeImageEx)     ( Image pImage, int32_t width, int32_t height DBG_PASS);
/* <combine sack::image::MoveImage@Image@int32_t@int32_t>
   Internal
   Interface index 15                                               */
   IMAGE_PROC_PTR( void,MoveImage)         ( Image pImage, int32_t x, int32_t y );
//-----------------------------------------------------
/* <combine sack::image::BlatColor@Image@int32_t@int32_t@uint32_t@uint32_t@CDATA>
   Internal
   Interface index 16                                                             */
   IMAGE_PROC_PTR( void,BlatColor)     ( Image pifDest, int32_t x, int32_t y, uint32_t w, uint32_t h, CDATA color );
/* <combine sack::image::BlatColorAlpha@Image@int32_t@int32_t@uint32_t@uint32_t@CDATA>
   Internal
   Interface index 17                                                                  */
   IMAGE_PROC_PTR( void,BlatColorAlpha)( Image pifDest, int32_t x, int32_t y, uint32_t w, uint32_t h, CDATA color );
/* <combine sack::image::BlotImageEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@...>
   Internal
	Interface index 18*/
   IMAGE_PROC_PTR( void,BlotImageEx)     ( Image pDest, Image pIF, int32_t x, int32_t y, uint32_t nTransparent, uint32_t method, ... );
 /* <combine sack::image::BlotImageSizedEx@Image@Image@int32_t@int32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   Internal
	Interface index 19*/
   IMAGE_PROC_PTR( void,BlotImageSizedEx)( Image pDest, Image pIF, int32_t x, int32_t y, int32_t xs, int32_t ys, uint32_t wd, uint32_t ht, uint32_t nTransparent, uint32_t method, ... );
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
  Internal
   Interface index  20                                                                                                        */
   IMAGE_PROC_PTR( void,BlotScaledImageSizedEx)( Image pifDest, Image pifSrc
                                   , int32_t xd, int32_t yd
                                   , uint32_t wd, uint32_t hd
                                   , int32_t xs, int32_t ys
                                   , uint32_t ws, uint32_t hs
                                   , uint32_t nTransparent
                                   , uint32_t method, ... );
/*Internal
   Interface index 21*/
   IMAGE_PROC_PTR( void,plot)      ( Image pi, int32_t x, int32_t y, CDATA c );
/*Internal
   Interface index 22*/
   IMAGE_PROC_PTR( void,plotalpha) ( Image pi, int32_t x, int32_t y, CDATA c );
/*Internal
   Interface index 23*/
   IMAGE_PROC_PTR( CDATA,getpixel) ( Image pi, int32_t x, int32_t y );
/*Internal
   Interface index 24*/
  // d is color data...
   IMAGE_PROC_PTR( void,do_line)     ( Image pBuffer, int32_t x, int32_t y, int32_t xto, int32_t yto, CDATA color );
/*Internal
   Interface index 25*/
  // d is color data...
   IMAGE_PROC_PTR( void,do_lineAlpha)( Image pBuffer, int32_t x, int32_t y, int32_t xto, int32_t yto, CDATA color);
/*Internal
   Interface index 26*/
   IMAGE_PROC_PTR( void,do_hline)     ( Image pImage, int32_t y, int32_t xfrom, int32_t xto, CDATA color );
/*Internal
   Interface index 27*/
   IMAGE_PROC_PTR( void,do_vline)     ( Image pImage, int32_t x, int32_t yfrom, int32_t yto, CDATA color );
/*Internal
   Interface index 28*/
   IMAGE_PROC_PTR( void,do_hlineAlpha)( Image pImage, int32_t y, int32_t xfrom, int32_t xto, CDATA color );
/*Internal
   Interface index 29*/
   IMAGE_PROC_PTR( void,do_vlineAlpha)( Image pImage, int32_t x, int32_t yfrom, int32_t yto, CDATA color );
/* <combine sack::image::GetDefaultFont>
   Internal
   Interface index 30                    */
   IMAGE_PROC_PTR( SFTFont,GetDefaultFont) ( void );
/* <combine sack::image::GetFontHeight@SFTFont>
   Internal
   Interface index 31                                        */
   IMAGE_PROC_PTR( uint32_t ,GetFontHeight)  ( SFTFont );
/* <combine sack::image::GetStringSizeFontEx@CTEXTSTR@size_t@uint32_t *@uint32_t *@SFTFont>
   Internal
   Interface index 32                                                          */
   IMAGE_PROC_PTR( uint32_t ,GetStringSizeFontEx)( CTEXTSTR pString, size_t len, uint32_t *width, uint32_t *height, SFTFont UseFont );
/* <combine sack::image::PutCharacterFont@Image@int32_t@int32_t@CDATA@CDATA@uint32_t@SFTFont>
   Internal
   Interface index 33                                                           */
   IMAGE_PROC_PTR( void,PutCharacterFont)              ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
/* <combine sack::image::PutCharacterVerticalFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   Internal
   Interface index 34                                                                                        */
   IMAGE_PROC_PTR( void,PutCharacterVerticalFont)      ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
/* <combine sack::image::PutCharacterInvertFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   Internal
   Interface index 35                                                                                      */
   IMAGE_PROC_PTR( void,PutCharacterInvertFont)        ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
/* <combine sack::image::PutCharacterVerticalInvertFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   Internal
   Interface index 36                                                                                              */
   IMAGE_PROC_PTR( void,PutCharacterVerticalInvertFont)( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
/* <combine sack::image::PutStringFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   Internal
   Interface index 37                                                                                   */
   IMAGE_PROC_PTR( void,PutStringFontEx)              ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
/* <combine sack::image::PutStringVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   Internal
   Interface index 38                                                                                           */
   IMAGE_PROC_PTR( void,PutStringVerticalFontEx)      ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
/* <combine sack::image::PutStringInvertFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   Internal
   Interface index 39                                                                                         */
   IMAGE_PROC_PTR( void,PutStringInvertFontEx)        ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
/* <combine sack::image::PutStringInvertVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   Internal
   Interface index 40                                                                                                 */
   IMAGE_PROC_PTR( void,PutStringInvertVerticalFontEx)( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
/* <combine sack::image::GetMaxStringLengthFont@uint32_t@SFTFont>
   Internal
   Interface index 41                                     */
   IMAGE_PROC_PTR( uint32_t, GetMaxStringLengthFont )( uint32_t width, SFTFont UseFont );
/* <combine sack::image::GetImageSize@Image@uint32_t *@uint32_t *>
   Internal
   Interface index 42                                                    */
   IMAGE_PROC_PTR( void, GetImageSize)                ( Image pImage, uint32_t *width, uint32_t *height );
/* <combine sack::image::LoadFont@SFTFont>
   Internal
   Interface index 43                                   */
   IMAGE_PROC_PTR( SFTFont, LoadFont )                   ( SFTFont font );
         /* <combine sack::image::UnloadFont@SFTFont>
            \ \                                    */
         IMAGE_PROC_PTR( void, UnloadFont )                 ( SFTFont font );
/* Internal
   Interface index 44
   This is used by internal methods to transfer image and font
   data to the render agent.                                   */
   IMAGE_PROC_PTR( DataState, BeginTransferData )    ( uint32_t total_size, uint32_t segsize, CDATA data );
/* Internal
   Interface index 45
   Used internally to transfer data to render agent. */
   IMAGE_PROC_PTR( void, ContinueTransferData )      ( DataState state, uint32_t segsize, CDATA data );
/* Internal
   Interface index 46
   Command issues at end of data transfer to decode the data
   into an image.                                            */
   IMAGE_PROC_PTR( Image, DecodeTransferredImage )    ( DataState state );
/* After a data transfer decode the information as a font.
   Internal
   Interface index 47                                      */
   IMAGE_PROC_PTR( SFTFont, AcceptTransferredFont )     ( DataState state );
/*Internal
   Interface index 48*/
   IMAGE_PROC_PTR( CDATA, ColorAverage )( CDATA c1, CDATA c2
                                              , int d, int max );
/* <combine sack::image::SyncImage>
   Internal
   Interface index 49               */
   IMAGE_PROC_PTR( void, SyncImage )                 ( void );
         /* <combine sack::image::GetImageSurface@Image>
            \ \                                          */
         IMAGE_PROC_PTR( PCDATA, GetImageSurface )       ( Image pImage );
         /* <combine sack::image::IntersectRectangle@IMAGE_RECTANGLE *@IMAGE_RECTANGLE *@IMAGE_RECTANGLE *>
            \ \                                                                                             */
         IMAGE_PROC_PTR( int, IntersectRectangle )      ( IMAGE_RECTANGLE *r, IMAGE_RECTANGLE *r1, IMAGE_RECTANGLE *r2 );
   /* <combine sack::image::MergeRectangle@IMAGE_RECTANGLE *@IMAGE_RECTANGLE *@IMAGE_RECTANGLE *>
      \ \                                                                                         */
   IMAGE_PROC_PTR( int, MergeRectangle )( IMAGE_RECTANGLE *r, IMAGE_RECTANGLE *r1, IMAGE_RECTANGLE *r2 );
   /* <combine sack::image::GetImageAuxRect@Image@P_IMAGE_RECTANGLE>
      \ \                                                            */
   IMAGE_PROC_PTR( void, GetImageAuxRect )   ( Image pImage, P_IMAGE_RECTANGLE pRect );
   /* <combine sack::image::SetImageAuxRect@Image@P_IMAGE_RECTANGLE>
      \ \                                                            */
   IMAGE_PROC_PTR( void, SetImageAuxRect )   ( Image pImage, P_IMAGE_RECTANGLE pRect );
   /* <combine sack::image::OrphanSubImage@Image>
      \ \                                         */
   IMAGE_PROC_PTR( void, OrphanSubImage )  ( Image pImage );
   /* <combine sack::image::AdoptSubImage@Image@Image>
      \ \                                              */
   IMAGE_PROC_PTR( void, AdoptSubImage )   ( Image pFoster, Image pOrphan );
	/* <combine sack::image::MakeSpriteImageFileEx@CTEXTSTR fname>
	   \ \                                                         */
	IMAGE_PROC_PTR( PSPRITE, MakeSpriteImageFileEx )( CTEXTSTR fname DBG_PASS );
	/* <combine sack::image::MakeSpriteImageEx@Image image>
	   \ \                                                  */
	IMAGE_PROC_PTR( PSPRITE, MakeSpriteImageEx )( Image image DBG_PASS );
	/* <combine sack::image::rotate_scaled_sprite@Image@PSPRITE@fixed@fixed@fixed>
	   \ \                                                                         */
	IMAGE_PROC_PTR( void   , rotate_scaled_sprite )(Image bmp, PSPRITE sprite, fixed angle, fixed scale_width, fixed scale_height);
	/* <combine sack::image::rotate_sprite@Image@PSPRITE@fixed>
	   \ \                                                      */
	IMAGE_PROC_PTR( void   , rotate_sprite )(Image bmp, PSPRITE sprite, fixed angle);
 /* <combine sack::image::BlotSprite@Image@PSPRITE>
	 Internal
   Interface index 61                                              */
		IMAGE_PROC_PTR( void   , BlotSprite )( Image pdest, PSPRITE ps );
    /* <combine sack::image::DecodeMemoryToImage@uint8_t*@uint32_t>
       \ \                                                */
    IMAGE_PROC_PTR( Image, DecodeMemoryToImage )( uint8_t* buf, size_t size );
   /* <combine sack::image::InternalRenderFontFile@CTEXTSTR@int32_t@int32_t@uint32_t>
      \returns a SFTFont                                                      */
	IMAGE_PROC_PTR( SFTFont, InternalRenderFontFile )( CTEXTSTR file
																 , int32_t nWidth
																 , int32_t nHeight
																		, PFRACTION width_scale
																		, PFRACTION height_scale
																 , uint32_t flags
																 );
   /* <combine sack::image::InternalRenderFont@uint32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t>
      requires knowing the font cache....                                 */
	IMAGE_PROC_PTR( SFTFont, InternalRenderFont )( uint32_t nFamily
															, uint32_t nStyle
															, uint32_t nFile
															, int32_t nWidth
															, int32_t nHeight
																		, PFRACTION width_scale
																		, PFRACTION height_scale
															, uint32_t flags
															);
/* <combine sack::image::RenderScaledFontData@PFONTDATA@PFRACTION@PFRACTION>
   \ \                                                                       */
IMAGE_PROC_PTR( SFTFont, RenderScaledFontData)( PFONTDATA pfd, PFRACTION width_scale, PFRACTION height_scale );
/* <combine sack::image::RenderFontFileEx@CTEXTSTR@uint32_t@uint32_t@uint32_t@uint32_t*@POINTER *>
   \ \                                                                         */
IMAGE_PROC_PTR( SFTFont, RenderFontFileScaledEx )( CTEXTSTR file, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags, size_t *size, POINTER *pFontData );
/* <combine sack::image::DestroyFont@SFTFont *>
   \ \                                       */
IMAGE_PROC_PTR( void, DestroyFont)( SFTFont *font );
/* <combine sack::image::GetGlobalFonts>
   global_font_data in interface is really a global font data. Don't
   have to call GetGlobalFont to get this.                           */
struct font_global_tag *_global_font_data;
/* <combine sack::image::GetFontRenderData@SFTFont@POINTER *@uint32_t *>
   \ \                                                           */
IMAGE_PROC_PTR( int, GetFontRenderData )( SFTFont font, POINTER *fontdata, size_t *fontdatalen );
/* <combine sack::image::SetFontRendererData@SFTFont@POINTER@uint32_t>
   \ \                                                         */
IMAGE_PROC_PTR( void, SetFontRendererData )( SFTFont font, POINTER pResult, size_t size );
/* <combine sack::image::SetSpriteHotspot@PSPRITE@int32_t@int32_t>
   \ \                                                       */
IMAGE_PROC_PTR( PSPRITE, SetSpriteHotspot )( PSPRITE sprite, int32_t x, int32_t y );
/* <combine sack::image::SetSpritePosition@PSPRITE@int32_t@int32_t>
   \ \                                                        */
IMAGE_PROC_PTR( PSPRITE, SetSpritePosition )( PSPRITE sprite, int32_t x, int32_t y );
	/* <combine sack::image::UnmakeImageFileEx@Image pif>
	   \ \                                                */
	IMAGE_PROC_PTR( void, UnmakeSprite )( PSPRITE sprite, int bForceImageAlso );
/* <combine sack::image::GetGlobalFonts>
   \ \                                   */
IMAGE_PROC_PTR( struct font_global_tag *, GetGlobalFonts)( void );
/* <combinewith sack::image::GetStringRenderSizeFontEx@CTEXTSTR@uint32_t@uint32_t *@uint32_t *@uint32_t *@SFTFont, sack::image::GetStringRenderSizeFontEx@CTEXTSTR@size_t@uint32_t *@uint32_t *@uint32_t *@SFTFont>
   \ \                                                                                                                                                                     */
IMAGE_PROC_PTR( uint32_t, GetStringRenderSizeFontEx )( CTEXTSTR pString, size_t nLen, uint32_t *width, uint32_t *height, uint32_t *charheight, SFTFont UseFont );
IMAGE_PROC_PTR( Image, LoadImageFileFromGroupEx )( INDEX group, CTEXTSTR filename DBG_PASS );
IMAGE_PROC_PTR( SFTFont, RenderScaledFont )( CTEXTSTR name, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags );
IMAGE_PROC_PTR( SFTFont, RenderScaledFontEx )( CTEXTSTR name, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags, size_t *pnFontDataSize, POINTER *pFontData );
IMAGE_PROC_PTR( COLOR_CHANNEL, GetRedValue )( CDATA color ) ;
IMAGE_PROC_PTR( COLOR_CHANNEL, GetGreenValue )( CDATA color );
IMAGE_PROC_PTR( COLOR_CHANNEL, GetBlueValue )( CDATA color );
IMAGE_PROC_PTR( COLOR_CHANNEL, GetAlphaValue )( CDATA color );
IMAGE_PROC_PTR( CDATA, SetRedValue )( CDATA color, COLOR_CHANNEL r ) ;
IMAGE_PROC_PTR( CDATA, SetGreenValue )( CDATA color, COLOR_CHANNEL green );
IMAGE_PROC_PTR( CDATA, SetBlueValue )( CDATA color, COLOR_CHANNEL b );
IMAGE_PROC_PTR( CDATA, SetAlphaValue )( CDATA color, COLOR_CHANNEL a );
IMAGE_PROC_PTR( CDATA, MakeColor )( COLOR_CHANNEL r, COLOR_CHANNEL green, COLOR_CHANNEL b );
IMAGE_PROC_PTR( CDATA, MakeAlphaColor )( COLOR_CHANNEL r, COLOR_CHANNEL green, COLOR_CHANNEL b, COLOR_CHANNEL a );
IMAGE_PROC_PTR( PTRANSFORM, GetImageTransformation )( Image pImage );
IMAGE_PROC_PTR( void, SetImageRotation )( Image pImage, int edge_flag, RCOORD offset_x, RCOORD offset_y, RCOORD rx, RCOORD ry, RCOORD rz );
IMAGE_PROC_PTR( void, RotateImageAbout )( Image pImage, int edge_flag, RCOORD offset_x, RCOORD offset_y, PVECTOR vAxis, RCOORD angle );
IMAGE_PROC_PTR( void, MarkImageDirty )( Image pImage );
IMAGE_PROC_PTR( void, DumpFontCache )( void );
IMAGE_PROC_PTR( void, RerenderFont )( SFTFont font, int32_t width, int32_t height, PFRACTION width_scale, PFRACTION height_scale );
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
IMAGE_PROC_PTR( int, ReloadTexture )( Image child_image, int option );
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
IMAGE_PROC_PTR( int, ReloadShadedTexture )( Image child_image, int option, CDATA color );
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
IMAGE_PROC_PTR( int, ReloadMultiShadedTexture )( Image child_image, int option, CDATA red, CDATA green, CDATA blue );
IMAGE_PROC_PTR( void, SetImageTransformRelation )( Image pImage, enum image_translation_relation relation, PRCOORD aux );
IMAGE_PROC_PTR( void, Render3dImage )( Image pImage, PCVECTOR o, LOGICAL render_pixel_scaled );
IMAGE_PROC_PTR( void, DumpFontFile )( CTEXTSTR name, SFTFont font_to_dump );
IMAGE_PROC_PTR( void, Render3dText )( CTEXTSTR string, int characters, CDATA color, SFTFont font, PCVECTOR o, LOGICAL render_pixel_scaled );
// transfer all sub images to new image using appropriate methods
// extension for internal fonts to be utilized by external plugins...
IMAGE_PROC_PTR( void, TransferSubImages )( Image pImageTo, Image pImageFrom );
// when using reverse interfaces, need a way to get the real image
// from the fake image (proxy image)
IMAGE_PROC_PTR( Image, GetNativeImage )( Image pImageTo );
// low level support for proxy; this exposes some image_common.c routines
IMAGE_PROC_PTR( Image, GetTintedImage )( Image child_image, CDATA color );
IMAGE_PROC_PTR( Image, GetShadedImage )( Image child_image, CDATA red, CDATA green, CDATA blue );
// test for IF_FLAG_FINAL_RENDER (non physical surface/prevent local copy-restore)
IMAGE_PROC_PTR( LOGICAL, IsImageTargetFinal )( Image image );
// use image data to create a clone of the image for the new application instance...
// this is used when a common image resource is used for all application instances
// it should be triggered during onconnect.
// it is a new image instance that should be used for future app references...
IMAGE_PROC_PTR( Image, ReuseImage )( Image image );
IMAGE_PROC_PTR( void, PutStringFontExx )( Image pImage
											 , int32_t x, int32_t y
											 , CDATA color, CDATA background
											 , CTEXTSTR pc, size_t nLen, SFTFont font, int justification, uint32_t _width );
// sometimes it's not possible to use blatcolor to clear an imate...
// sometimes its parent is not redrawn?
IMAGE_PROC_PTR( void, ResetImageBuffers )( Image image, LOGICAL image_only );
	IMAGE_PROC_PTR(  LOGICAL, PngImageFile )( Image image, uint8_t* *buf, size_t *size );
	IMAGE_PROC_PTR(  LOGICAL, JpgImageFile )( Image image, uint8_t* *buf, size_t *size, int Q );
	IMAGE_PROC_PTR(  void, SetFontBias )( SFTFont font, int32_t x, int32_t y );
	IMAGE_PROC_PTR( SlicedImage, MakeSlicedImage )( Image source, uint32_t left, uint32_t right, uint32_t top, uint32_t bottom, LOGICAL output_center );
	IMAGE_PROC_PTR( SlicedImage, MakeSlicedImageComplex )( Image source
										, uint32_t top_left_x, uint32_t top_left_y, uint32_t top_left_width, uint32_t top_left_height
										, uint32_t top_x, uint32_t top_y, uint32_t top_width, uint32_t top_height
										, uint32_t top_right_x, uint32_t top_right_y, uint32_t top_right_width, uint32_t top_right_height
										, uint32_t left_x, uint32_t left_y, uint32_t left_width, uint32_t left_height
										, uint32_t center_x, uint32_t center_y, uint32_t center_width, uint32_t center_height
										, uint32_t right_x, uint32_t right_y, uint32_t right_width, uint32_t right_height
										, uint32_t bottom_left_x, uint32_t bottom_left_y, uint32_t bottom_left_width, uint32_t bottom_left_height
										, uint32_t bottom_x, uint32_t bottom_y, uint32_t bottom_width, uint32_t bottom_height
										, uint32_t bottom_right_x, uint32_t bottom_right_y, uint32_t bottom_right_width, uint32_t bottom_right_height
										, LOGICAL output_center );
	IMAGE_PROC_PTR( void, UnmakeSlicedImage )( SlicedImage image );
	IMAGE_PROC_PTR( void, BlotSlicedImageEx )( Image dest, SlicedImage source, int32_t x, int32_t y, uint32_t width, uint32_t height, int alpha, enum BlotOperation op, ... );
	IMAGE_PROC_PTR( void, SetSavePortion )( void (CPROC*_SavePortion )( PSPRITE_METHOD psm, uint32_t x, uint32_t y, uint32_t w, uint32_t h ) );
} IMAGE_INTERFACE, *PIMAGE_INTERFACE;
/* Method to define automatic name translation from standard
   names Like BlatColorAlphaEx to the interface the user has
   specified to be using.                                    */
#define PROC_ALIAS(name) ((USE_IMAGE_INTERFACE)->_##name)
/* Method to define automatic name translation from standard
   names Like BlatColorAlphaEx to the interface the user has
   specified to be using. For function pointers.             */
#define PPROC_ALIAS(name) (*(USE_IMAGE_INTERFACE)->_##name)
#ifdef DEFINE_DEFAULT_IMAGE_INTERFACE
//static PIMAGE_INTERFACE always_defined_interface_that_makes_this_efficient;
#  define USE_IMAGE_INTERFACE GetImageInterface()
#endif
#if defined( FORCE_NO_INTERFACE ) && !defined( ALLOW_IMAGE_INTERFACES )
#  undef USE_IMAGE_INTERFACE
#else
#  define GetImageInterface() (PIMAGE_INTERFACE)GetInterface( "image" )
/* <combine sack::image::DropImageInterface@PIMAGE_INTERFACE>
   \ \                                                        */
#  define DropImageInterface(x) DropInterface( "image", NULL )
#endif
#ifdef USE_IMAGE_INTERFACE
#define GetRedValue                          PROC_ALIAS(GetRedValue )
#define GetBlueValue                          PROC_ALIAS(GetBlueValue )
#define GetGreenValue                          PROC_ALIAS(GetGreenValue )
#define GetAlphaValue                          PROC_ALIAS(GetAlphaValue )
#define SetRedValue                          PROC_ALIAS(SetRedValue )
#define SetBlueValue                          PROC_ALIAS(SetBlueValue )
#define SetGreenValue                          PROC_ALIAS(SetGreenValue )
#define SetAlphaValue                          PROC_ALIAS(SetAlphaValue )
#define MakeColor                          PROC_ALIAS(MakeColor )
#define MakeAlphaColor                          PROC_ALIAS(MakeAlphaColor )
#define MarkImageDirty                    PROC_ALIAS(MarkImageDirty)
#define GetStringRenderSizeFontEx          PROC_ALIAS(GetStringRenderSizeFontEx )
#define LoadImageFileFromGroupEx          PROC_ALIAS(LoadImageFileFromGroupEx )
#define SetStringBehavior                  PROC_ALIAS(SetStringBehavior )
                      //PROC_ALIAS(SetBlotMethod )
#define SetBlotMethod
#define BuildImageFileEx                   PROC_ALIAS(BuildImageFileEx )
#define MakeImageFileEx                    PROC_ALIAS(MakeImageFileEx )
/* <combine sack::image::MakeImageFileEx@uint32_t@uint32_t>
   \ \                                                   */
#define MakeImageFile(w,h)                 PROC_ALIAS(MakeImageFileEx)( w,h DBG_SRC )
#define MakeSubImageEx                     PROC_ALIAS(MakeSubImageEx )
/* <combine sack::image::MakeSubImageEx@Image@int32_t@int32_t@uint32_t@uint32_t>
   \ \                                                                  */
#define MakeSubImage( image, x, y, w, h )  PROC_ALIAS(MakeSubImageEx)( image, x, y, w, h DBG_SRC )
#define RemakeImageEx                      PROC_ALIAS(RemakeImageEx )
#define ResizeImageEx                      PROC_ALIAS(ResizeImageEx )
#define MoveImage                          PROC_ALIAS(MoveImage )
#define LoadImageFileEx                    PROC_ALIAS(LoadImageFileEx )
#define DecodeMemoryToImage                PROC_ALIAS(DecodeMemoryToImage )
/* <combine sack::image::UnmakeImageFileEx@Image pif>
   Destroys an image. Does not automatically destroy child
   images created on the image.
   Parameters
   Image :  an image to destroy
   Example
   <code lang="c++">
   Image image = MakeImageFile( 100, 100 );
   UnmakeImageFile( image );
   </code>                                                 */
#define UnmakeImageFile(pif)               PROC_ALIAS(UnmakeImageFileEx )( pif DBG_SRC )
#define UnmakeImageFileEx                  PROC_ALIAS(UnmakeImageFileEx )
#define BlatColor                          PROC_ALIAS(BlatColor )
#define BlatColorAlpha                     PROC_ALIAS(BlatColorAlpha )
#define BlotImageSizedEx                   PROC_ALIAS(BlotImageSizedEx )
#define BlotImageEx                        PROC_ALIAS(BlotImageEx )
#define BlotScaledImageSizedEx             PROC_ALIAS(BlotScaledImageSizedEx )
#define plot                               PPROC_ALIAS(plot )
#define plotalpha                          PPROC_ALIAS(plotalpha )
#define getpixel                           PPROC_ALIAS(getpixel )
#define do_line                            PPROC_ALIAS(do_line )
#define do_lineAlpha                       PPROC_ALIAS(do_lineAlpha )
#define do_hline                           PPROC_ALIAS(do_hline )
#define do_vline                           PPROC_ALIAS(do_vline )
#define do_hlineAlpha                      PPROC_ALIAS(do_hlineAlpha )
#define do_vlineAlpha                      PPROC_ALIAS(do_vlineAlpha )
#define GetDefaultFont                     PROC_ALIAS(GetDefaultFont )
#define GetFontHeight                      PROC_ALIAS(GetFontHeight )
#define GetStringSizeFontEx                PROC_ALIAS(GetStringSizeFontEx )
#define PutCharacterFont                   PROC_ALIAS(PutCharacterFont )
#define PutCharacterVerticalFont           PROC_ALIAS(PutCharacterVerticalFont )
#define PutCharacterInvertFont             PROC_ALIAS(PutCharacterInvertFont )
#define PutCharacterVerticalInvertFont     PROC_ALIAS(PutCharacterVerticalInvertFont )
#define PutStringFontExx                   PROC_ALIAS(PutStringFontExx)
#define PutStringFontEx                    PROC_ALIAS(PutStringFontEx )
#define PutStringVerticalFontEx            PROC_ALIAS(PutStringVerticalFontEx )
#define PutStringInvertFontEx              PROC_ALIAS(PutStringInvertFontEx )
#define PutStringInvertVerticalFontEx      PROC_ALIAS(PutStringInvertVerticalFontEx )
#define GetMaxStringLengthFont             PROC_ALIAS(GetMaxStringLengthFont )
#define GetImageSize                       PROC_ALIAS(GetImageSize )
#define LoadFont                           PROC_ALIAS(LoadFont )
#define UnloadFont                         PROC_ALIAS(UnloadFont )
#define ColorAverage                       PPROC_ALIAS(ColorAverage)
#define TransferSubImages                  PROC_ALIAS(TransferSubImages)
#define SyncImage                          PROC_ALIAS(SyncImage )
#define IntersectRectangle                 PROC_ALIAS(IntersectRectangle)
#define MergeRectangle                     PROC_ALIAS(MergeRectangle)
#define GetImageSurface                    PROC_ALIAS(GetImageSurface)
#define SetImageAuxRect                    PROC_ALIAS(SetImageAuxRect)
#define GetImageAuxRect                    PROC_ALIAS(GetImageAuxRect)
#define OrphanSubImage                     PROC_ALIAS(OrphanSubImage)
#define GetGlobalFonts                     PROC_ALIAS(GetGlobalFonts)
#define GetTintedImage                     PROC_ALIAS(GetTintedImage)
#define GetShadedImage                     PROC_ALIAS(GetShadedImage)
#define AdoptSubImage                      PROC_ALIAS(AdoptSubImage)
#define MakeSpriteImageFileEx   PROC_ALIAS(MakeSpriteImageFileEx)
#define MakeSpriteImageEx       PROC_ALIAS(MakeSpriteImageEx)
#define UnmakeSprite            PROC_ALIAS(UnmakeSprite )
#define rotate_scaled_sprite    PROC_ALIAS(rotate_scaled_sprite)
#define rotate_sprite           PROC_ALIAS(rotate_sprite)
#define BlotSprite              PROC_ALIAS(BlotSprite)
#define SetSpritePosition  PROC_ALIAS(  SetSpritePosition )
#define SetSpriteHotspot  PROC_ALIAS(  SetSpriteHotspot )
#define InternalRenderFont          PROC_ALIAS(InternalRenderFont)
#define InternalRenderFontFile      PROC_ALIAS(InternalRenderFontFile)
#define RenderScaledFontData              PROC_ALIAS(RenderScaledFontData)
//#define RenderScaledFont              PROC_ALIAS(RenderScaledFont)
#define RenderScaledFontEx              PROC_ALIAS(RenderScaledFontEx)
#define DumpFontCache              PROC_ALIAS(DumpFontCache)
#define RerenderFont              PROC_ALIAS(RerenderFont)
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
#define ReloadTexture              PROC_ALIAS(ReloadTexture)
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
#define ReloadShadedTexture              PROC_ALIAS(ReloadShadedTexture)
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
#define ReloadMultiShadedTexture              PROC_ALIAS(ReloadMultiShadedTexture)
#define DestroyFont              PROC_ALIAS(DestroyFont)
#define GetFontRenderData              PROC_ALIAS(GetFontRenderData)
#define SetFontRendererData              PROC_ALIAS(SetFontRendererData)
#define RenderFontFileScaledEx              PROC_ALIAS(RenderFontFileScaledEx)
#define GetImageTransformation              PROC_ALIAS(GetImageTransformation)
#define SetImageTransformRelation      PROC_ALIAS( SetImageTransformRelation )
#define Render3dImage                  PROC_ALIAS( Render3dImage )
#define Render3dText                   PROC_ALIAS( Render3dText )
#define DumpFontFile                   PROC_ALIAS( DumpFontFile )
#define IsImageTargetFinal                   PROC_ALIAS( IsImageTargetFinal )
#define ReuseImage                      if((USE_IMAGE_INTERFACE)->_ReuseImage) PROC_ALIAS( ReuseImage )
#define ResetImageBuffers                      if((USE_IMAGE_INTERFACE)->_ResetImageBuffers) PROC_ALIAS( ResetImageBuffers )
#define PngImageFile                    PROC_ALIAS( PngImageFile )
#define JpgImageFile                    PROC_ALIAS( JpgImageFile )
#define SetFontBias                     PROC_ALIAS( SetFontBias )
#define MakeSlicedImage                 PROC_ALIAS( MakeSlicedImage )
#define MakeSlicedImageComplex          PROC_ALIAS( MakeSlicedImageComplex )
#define UnmakeSlicedImage                 PROC_ALIAS( UnmakeSlicedImage )
#define BlotSlicedImageEx               PROC_ALIAS( BlotSlicedImageEx )
#define SetSavePortion                          PROC_ALIAS(SetSavePortion )
//#define global_font_data         (*PROC_ALIAS(global_font_data))
#endif
/* <combine sack::image::GetMaxStringLengthFont@uint32_t@SFTFont>
   \ \                                                    */
#define GetMaxStringLength(w) GetMaxStringLengthFont(w, NULL )
#ifdef DEFINE_IMAGE_PROTOCOL
//#include <msgprotocol.h>
// need to define BASE_IMAGE_MESSAGE_ID before hand to determine what the base message is.
//#define MSG_ID(method)  ( ( offsetof( struct image_interface_tag, _##method ) / sizeof( void(*)(void) ) ) + BASE_IMAGE_MESSAGE_ID + MSG_EventUser )
#define MSG_SetStringBehavior                  MSG_ID( SetStringBehavior )
#define MSG_SetBlotMethod                      MSG_ID( SetBlotMethod )
#define MSG_BuildImageFileEx                   MSG_ID( BuildImageFileEx )
#define MSG_MakeImageFileEx                    MSG_ID( MakeImageFileEx )
#define MSG_MakeSubImageEx                     MSG_ID( MakeSubImageEx )
#define MSG_RemakeImageEx                      MSG_ID( RemakeImageEx )
#define MSG_UnmakeImageFileEx                  MSG_ID( UnmakeImageFileEx )
#define MSG_ResizeImageEx                      MSG_ID( ResizeImageEx )
#define DecodeMemoryToImage                    MSG_ID( DecodeMemoryToImage )
#define MSG_MoveImage                          MSG_ID( MoveImage )
#define MSG_BlatColor                          MSG_ID( BlatColor )
#define MSG_BlatColorAlpha                     MSG_ID( BlatColorAlpha )
#define MSG_BlotImageSizedEx                   MSG_ID( BlotImageSizedEx )
#define MSG_BlotImageEx                        MSG_ID( BlotImageEx )
#define MSG_BlotScaledImageSizedEx             MSG_ID( BlotScaledImageSizedEx )
#define MSG_plot                               MSG_ID( plot )
#define MSG_plotalpha                          MSG_ID( plotalpha )
#define MSG_getpixel                           MSG_ID( getpixel )
#define MSG_do_line                            MSG_ID( do_line )
#define MSG_do_lineAlpha                       MSG_ID( do_lineAlpha )
#define MSG_do_hline                           MSG_ID( do_hline )
#define MSG_do_vline                           MSG_ID( do_vline )
#define MSG_do_hlineAlpha                      MSG_ID( do_hlineAlpha )
#define MSG_do_vlineAlpha                      MSG_ID( do_vlineAlpha )
#define MSG_GetDefaultFont                     MSG_ID( GetDefaultFont )
#define MSG_GetFontHeight                      MSG_ID( GetFontHeight )
#define MSG_GetStringSizeFontEx                MSG_ID( GetStringSizeFontEx )
#define MSG_PutCharacterFont                   MSG_ID( PutCharacterFont )
#define MSG_PutCharacterVerticalFont           MSG_ID( PutCharacterVerticalFont )
#define MSG_PutCharacterInvertFont             MSG_ID( PutCharacterInvertFont )
#define MSG_PutCharacterVerticalInvertFont     MSG_ID( PutCharacterVerticalInvertFont )
#define MSG_PutStringFontEx                    MSG_ID( PutStringFontEx )
#define MSG_PutStringVerticalFontEx            MSG_ID( PutStringVerticalFontEx )
#define MSG_PutStringInvertFontEx              MSG_ID( PutStringInvertFontEx )
#define MSG_PutStringInvertVerticalFontEx      MSG_ID( PutStringInvertVerticalFontEx )
#define MSG_GetMaxStringLengthFont             MSG_ID( GetMaxStringLengthFont )
#define MSG_GetImageSize                       MSG_ID( GetImageSize )
#define MSG_ColorAverage                       MSG_IC( ColorAverage )
// these messages follow all others... and are present to handle
// LoadImageFile
// #define MSG_LoadImageFile (no message)
// #define MSG_LoadFont      (no message)
#define MSG_UnloadFont                         MSG_ID( UnloadFont )
#define MSG_BeginTransferData                  MSG_ID( BeginTransferData )
#define MSG_ContinueTransferData               MSG_ID( ContinueTransferData )
#define MSG_DecodeTransferredImage             MSG_ID( DecodeTransferredImage )
#define MSG_AcceptTransferredFont              MSG_ID( AcceptTransferredFont )
#define MSG_SyncImage                          MSG_ID( SyncImage )
#define MSG_IntersectRectangle                 MSG_ID( IntersectRectangle )
#define MSG_MergeRectangle                     MSG_ID( MergeRectangle)
#define MSG_GetImageSurface                    MSG_ID( GetImageSurface )
#define MSG_SetImageAuxRect                    MSG_ID(SetImageAuxRect)
#define MSG_GetImageAuxRect                    MSG_ID(GetImageAuxRect)
#define MSG_OrphanSubImage                     MSG_ID(OrphanSubImage)
#define MSG_GetGlobalFonts                     MSG_ID(GetGlobalFonts)
#define MSG_AdoptSubImage                      MSG_ID(AdoptSubImage)
#define MSG_MakeSpriteImageFileEx   MSG_ID(MakeSpriteImageFileEx)
#define MSG_MakeSpriteImageEx       MSG_ID(MakeSpriteImageEx)
#define MSG_UnmakeSprite            MSG_ID(UnmakeSprite )
#define MSG_rotate_scaled_sprite    MSG_ID(rotate_scaled_sprite)
#define MSG_rotate_sprite           MSG_ID(rotate_sprite)
#define MSG_BlotSprite              MSG_ID(BlotSprite)
#define MSG_SetSpritePosition  MSG_ID(  SetSpritePosition )
#define MSG_SetSpriteHotspot  MSG_ID(  SetSpriteHotspot )
#define MSG_InternalRenderFont          MSG_ID(InternalRenderFont)
#define MSG_InternalRenderFontFile      MSG_ID(InternalRenderFontFile)
#define MSG_RenderScaledFontData              MSG_ID(RenderScaledFontData)
#define MSG_RenderScaledFont              MSG_ID(RenderScaledFont)
#define MSG_RenderFontData              MSG_ID(RenderFontData)
#define MSG_DestroyFont              MSG_ID(DestroyFont)
#define MSG_GetFontRenderData              MSG_ID(GetFontRenderData)
#define MSG_SetFontRendererData              MSG_ID(SetFontRendererData)
#endif
#ifdef USE_IMAGE_LEVEL
#define PASTELEVEL(level,name) level##name
#define LEVEL_ALIAS(name)      PASTELEVEL(USE_IMAGE_LEVEL,name)
#  ifdef STUPID_NO_DATA_EXPORTS
#define PLEVEL_ALIAS(name)      (*PASTELEVEL(USE_IMAGE_LEVEL,_PASTE(_,name)))
#  else
#define PLEVEL_ALIAS(name)      (*PASTELEVEL(USE_IMAGE_LEVEL,name))
#  endif
#define SetStringBehavior                  LEVEL_ALIAS(SetStringBehavior )
                      //LEVEL_ALIAS(SetBlotMethod )
#define SetBlotMethod
#define BuildImageFileEx                   LEVEL_ALIAS(BuildImageFileEx )
#define MakeImageFileEx                    LEVEL_ALIAS(MakeImageFileEx )
#define MakeSubImageEx                     LEVEL_ALIAS(MakeSubImageEx )
#define RemakeImageEx                      LEVEL_ALIAS(RemakeImageEx )
#define ResizeImageEx                      LEVEL_ALIAS(ResizeImageEx )
#define MoveImage                          LEVEL_ALIAS(MoveImage )
#define LoadImageFileEx                    LEVEL_ALIAS(LoadImageFileEx )
#define DecodeMemoryToImage                LEVEL_ALIAS(DecodeMemoryToImage )
#define UnmakeImageFileEx                  LEVEL_ALIAS(UnmakeImageFileEx )
#define BlatColor                          LEVEL_ALIAS(BlatColor )
#define BlatColorAlpha                     LEVEL_ALIAS(BlatColorAlpha )
#define BlotImageSizedEx                   LEVEL_ALIAS(BlotImageSizedEx )
#define BlotImageEx                        LEVEL_ALIAS(BlotImageEx )
#define BlotScaledImageSizedEx             LEVEL_ALIAS(BlotScaledImageSizedEx )
#define plot                               LEVEL_ALIAS(plot )
#define plotalpha                          LEVEL_ALIAS(plotalpha )
#error 566
#define getpixel                           LEVEL_ALIAS(getpixel )
#define do_line                            LEVEL_ALIAS(do_line )
#define do_lineAlpha                       LEVEL_ALIAS(do_lineAlpha )
#define do_hline                           LEVEL_ALIAS(do_hline )
#define do_vline                           LEVEL_ALIAS(do_vline )
#define do_hlineAlpha                      LEVEL_ALIAS(do_hlineAlpha )
#define do_vlineAlpha                      LEVEL_ALIAS(do_vlineAlpha )
#define GetDefaultFont                     LEVEL_ALIAS(GetDefaultFont )
#define GetFontHeight                      LEVEL_ALIAS(GetFontHeight )
#define GetStringSizeFontEx                LEVEL_ALIAS(GetStringSizeFontEx )
#define PutCharacterFont                   LEVEL_ALIAS(PutCharacterFont )
#define PutCharacterVerticalFont           LEVEL_ALIAS(PutCharacterVerticalFont )
#define PutCharacterInvertFont             LEVEL_ALIAS(PutCharacterInvertFont )
#define PutCharacterVerticalInvertFont     LEVEL_ALIAS(PutCharacterVerticalInvertFont )
#define PutStringFontEx                    LEVEL_ALIAS(PutStringFontEx )
#define PutStringVerticalFontEx            LEVEL_ALIAS(PutStringVerticalFontEx )
#define PutStringInvertFontEx              LEVEL_ALIAS(PutStringInvertFontEx )
#define PutStringInvertVerticalFontEx      LEVEL_ALIAS(PutStringInvertVerticalFontEx )
#define GetMaxStringLengthFont             LEVEL_ALIAS(GetMaxStringLengthFont )
#define GetImageSize                       LEVEL_ALIAS(GetImageSize )
#define LoadFont                           LEVEL_ALIAS(LoadFont )
#define UnloadFont                         LEVEL_ALIAS(UnloadFont )
#define ColorAverage                       LEVEL_ALIAS(ColorAverage)
#define SyncImage                          LEVEL_ALIAS(SyncImage )
#define IntersectRectangle                 LEVEL_ALIAS( IntersectRectangle )
#define MergeRectangle                     LEVEL_ALIAS(MergeRectangle)
#define GetImageSurface                    LEVEL_ALIAS(GetImageSurface)
#define SetImageAuxRect                    LEVEL_ALIAS(SetImageAuxRect)
#define GetImageAuxRect                    LEVEL_ALIAS(GetImageAuxRect)
#define OrphanSubImage                     LEVEL_ALIAS(OrphanSubImage)
#define GetGlobalFonts                     LEVEL_ALIAS(GetGlobalFonts)
#define AdoptSubImage                      LEVEL_ALIAS(AdoptSubImage)
#define InternalRenderFont          LEVEL_ALIAS(InternalRenderFont)
#define InternalRenderFontFile      LEVEL_ALIAS(InternalRenderFontFile)
#define RenderScaledFontData              LEVEL_ALIAS(RenderScaledFontData)
#define RenderFontData              LEVEL_ALIAS(RenderFontData)
#define RenderFontFileScaledEx              LEVEL_ALIAS(RenderFontFileScaledEx)
#endif
_INTERFACE_NAMESPACE_END
#ifdef __cplusplus
#ifdef _D3D_DRIVER
	using namespace sack::image::d3d::Interface;
#elif defined( _D3D10_DRIVER )
	using namespace sack::image::d3d10::Interface;
#elif defined( _D3D11_DRIVER )
	using namespace sack::image::d3d11::Interface;
#else
	using namespace sack::image::Interface;
#endif
#endif
// these macros provide common extensions for
// commonly used shorthands of the above routines.
// no worry - one way or another, the extra data is
// created, and the base function called, it's a sad
// truth of life, that one codebase is easier to maintain
// than a duplicate copy for each minor case.
// although - special forwards - such as DBG_SRC will just dissappear
// in certain compilation modes (NON_DEBUG)
/* <combine sack::image::BuildImageFileEx@PCOLOR@uint32_t@uint32_t>
   \ \                                                           */
#define BuildImageFile(p,w,h) BuildImageFileEx( p,w,h DBG_SRC )
/* <combine sack::image::RemakeImageEx@Image@PCOLOR@uint32_t@uint32_t>
   \ \                                                              */
#define RemakeImage(p,pc,w,h) RemakeImageEx(p,pc,w,h DBG_SRC)
/* <combine sack::image::ResizeImageEx@Image@uint32_t@uint32_t>
   \ \                                                              */
#define ResizeImage( p,w,h) ResizeImageEx( p,w,h DBG_SRC )
/* <combine sack::image::MakeSpriteImageEx@Image image>
   \ \                                                  */
#define MakeSpriteImage(image) MakeSpriteImageEx(image DBG_SRC)
/* <combine sack::image::MakeSpriteImageFileEx@CTEXTSTR fname>
   \ \                                                         */
#define MakeSpriteImageFile(file) MakeSpriteImageFileEx( image DBG_SRC )
/* This function flips an image top to bottom. This if for
   building windows compatible images. Internally images are
   kept in platform-native direction. If an image is created
   from another source, this might be a method to flip the image
   top-to-bottom if required.
   Parameters
   pImage :                           Image to flip.
   <link sack::DBG_PASS, DBG_PASS> :  _nt_
   Note
   There has been a warning around flip image for a while, it
   does its job right now (reversing jpeg images on windows),
   but not necessarily suited for the masses.                    */
IMAGE_PROC  void IMAGE_API IMGVER(FlipImageEx )( Image pif DBG_PASS );
/* <combine sack::image::FlipImageEx@Image pif>
   \ \                                          */
#define FlipImage(pif) FlipImageEx( pif DBG_SRC )
/* <combine sack::image::LoadImageFileEx@CTEXTSTR name>
   \ \                                                  */
#define LoadImageFile(file) LoadImageFileEx( file DBG_SRC )
/* <combine sack::image::LoadImageFileEx@CTEXTSTR name>
   \ \                                                  */
#define LoadImageFileFromGroup(group,file) LoadImageFileFromGroupEx( group, file DBG_SRC )
/* <combine sack::image::BlatColor@Image@int32_t@int32_t@uint32_t@uint32_t@CDATA>
   \ \                                                            */
#define ClearImageTo(img,color) BlatColor(img,0,0,(img)->width,(img)->height, color )
#define ogl_ClearImageTo(img,color) ogl_BlatColor(img,0,0,(img)->width,(img)->height, color )
/* <combine sack::image::BlatColor@Image@int32_t@int32_t@uint32_t@uint32_t@CDATA>
   \ \                                                            */
#define ClearImage(img) BlatColor(img,0,0,(img)->width,(img)->height, 0 )
#define ogl_ClearImage(img) ogl_BlatColor(img,0,0,(img)->width,(img)->height, 0 )
/* Copy one image to another. Copies the source from 0,0 to the
   destination 0,0 of the minimum width and height of the
   smaller of the source or destination.
   Parameters
   pifDest :  Image to copy to
   pifSrc :   Image to copy from
   X :        left coordinate to copy image to
   Y :        upper coordinate to copy image to
   Example
   This creates an image to write to, creates an image to copy
   (a 64 by 64 square that is filled with 50% green color). And
   copies the image to the output buffer.
   <code>
   Image output = MakeImageFile( 1024, 768 );
   Image source = MakeImageFile( 64, 64 );
   // 50% transparent
   ClearImageTo( source, SetAlpha( BASE_COLOR_GREEN, 128 ) );
   ClearImage( output );
   BlotImage( output, source, 100, 100 );
   BlotImageAlpha( output, source, 200, 200 );
   </code>                                                      */
#define BlotImage( pd, ps, x, y ) BlotImageEx( pd, ps, x, y, 0, BLOT_COPY )
#define ogl_BlotImage( pd, ps, x, y ) ogl_BlotImageEx( pd, ps, x, y, 0, BLOT_COPY )
/* Output a sliced image to an image surface
  sliced images scale center portions, but copy output corner images
  */
#define BlotSlicedImage( pd, ps, x, y, w, h ) BlotSlicedImageEx( pd, ps, x, y, w, h, ALPHA_TRANSPARENT, BLOT_COPY )
/* Copy one image to another at the specified coordinate in the
   destination.
   Parameters
   Destination :  Image to output to
   Source :       Image to copy
   X :            Location to copy to
   Y :            Location to copy to <link sack::image::AlphaModifier, Alpha>
                  \: Specify how to write the alpha                            */
#define BlotImageAlpha( pd, ps, x, y, a ) BlotImageEx( pd, ps, x, y, a, BLOT_COPY )
/* <combine sack::image::BlotImageSizedEx@Image@Image@int32_t@int32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                         */
#define BlotImageSized( pd, ps, x, y, w, h ) BlotImageSizedEx( pd, ps, x, y, 0, 0, w, h, TRUE, BLOT_COPY )
#define ogl_BlotImageSized( pd, ps, x, y, w, h ) ogl_BlotImageSizedEx( pd, ps, x, y, 0, 0, w, h, TRUE, BLOT_COPY )
/* <combine sack::image::BlotImageSizedEx@Image@Image@int32_t@int32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                         */
#define BlotImageSizedAlpha( pd, ps, x, y, w, h, a ) BlotImageSizedEx( pd, ps, x, y, 0, 0, w, h, a, BLOT_COPY )
#define ogl_BlotImageSizedAlpha( pd, ps, x, y, w, h, a ) ogl_BlotImageSizedEx( pd, ps, x, y, 0, 0, w, h, a, BLOT_COPY )
/* <combine sack::image::BlotImageSizedEx@Image@Image@int32_t@int32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                         */
#define BlotImageSizedTo( pd, ps, xd, yd, xs, ys, w, h )  BlotImageSizedEx( pd, ps, xd, yd, xs, ys, w, h, TRUE, BLOT_COPY )
#define ogl_BlotImageSizedTo( pd, ps, xd, yd, xs, ys, w, h )  ogl_BlotImageSizedEx( pd, ps, xd, yd, xs, ys, w, h, TRUE, BLOT_COPY )
/* Copy one image to another at the specified coordinate in the
   destination. Shade the image on copy with a color.
   Parameters
   Destination :  Image to output to
   Source :       Image to copy
   X :            Location to copy to
   Y :            Location to copy to
   Color :        color to multiply the source color by to shade
                  on copy.                                       */
#define BlotImageShaded( pd, ps, xd, yd, c ) BlotImageEx( pd, ps, xd, yd, TRUE, BLOT_SHADED, c )
/* <combine sack::image::BlotImageSizedEx@Image@Image@int32_t@int32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                         */
#define BlotImageShadedSized( pd, ps, xd, yd, xs, ys, ws, hs, c ) BlotImageSizedEx( pd, ps, xd, yd, xs, ys, ws, hs, TRUE, BLOT_SHADED, c )
#define ogl_BlotImageShadedSized( pd, ps, xd, yd, xs, ys, ws, hs, c ) ogl_BlotImageSizedEx( pd, ps, xd, yd, xs, ys, ws, hs, TRUE, BLOT_SHADED, c )
/* Copy one image to another at the specified coordinate in the
   destination. Scale RGB channels to specified colors.
   Parameters
   Destination :  Image to output to
   Source :       Image to copy
   X :            Location to copy to
   Y :            Location to copy to
   X_source :     the left coordinate of the image source
   Y_source :     the top coordinate of the image source
   Width :        How wide to copy the image
   Height :       How wide to copy the image
   color :        color mutiplier to shade the image.           */
#define BlotImageMultiShaded( pd, ps, xd, yd, r, g, b ) BlotImageEx( pd, ps, xd, yd, ALPHA_TRANSPARENT, BLOT_MULTISHADE, r, g, b )
/* Copy one image to another at the specified coordinate in the
   destination. Scale RGB channels to specified colors.
   Parameters
   Destination :  Image to output to
   Source :       Image to copy
   X :            Location to copy to
   Y :            Location to copy to
   X_source :     the left coordinate of the image source
   Y_source :     the top coordinate of the image source
   Width :        How wide to copy the image
   Height :       How wide to copy the image
   color :        color mutiplier to shade the image.           */
#define BlotImageMultiShadedSized( pd, ps, xd, yd, xs, ys, ws, hs, r, g, b ) BlotImageSizedEx( pd, ps, xd, yd, xs, ys, ws, hs, TRUE, BLOT_MULTISHADE, r, g, b )
#define ogl_BlotImageMultiShadedSized( pd, ps, xd, yd, xs, ys, ws, hs, r, g, b ) ogl_BlotImageSizedEx( pd, ps, xd, yd, xs, ys, ws, hs, TRUE, BLOT_MULTISHADE, r, g, b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSized( pd, ps, xd, yd, wd, hd, xs, ys, ws, hs ) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, xs, ys, ws, hs, 0, BLOT_COPY )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedMultiShaded( pd, ps, xd, yd, wd, hd, xs, ys, ws, hs,r,g,b ) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, xs, ys, ws, hs, 0, BLOT_MULTISHADE,r,g,b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedTo( pd, ps, xd, yd, wd, hd) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, 0, BLOT_COPY )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedToAlpha( pd, ps, xd, yd, wd, hd, a) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, a, BLOT_COPY )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedToShaded( pd, ps, xd, yd, wd, hd,shade) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, 0,BLOT_SHADED, shade )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedToShadedAlpha( pd, ps, xd, yd, wd, hd,a,shade) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, a, BLOT_SHADED, shade )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedToMultiShaded( pd, ps, xd, yd, wd, hd,r,g,b) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, 0,BLOT_MULTISHADE, r,g,b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedToMultiShadedAlpha( pd, ps, xd, yd, wd, hd,a,r,g,b) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, a,BLOT_MULTISHADE, r,g,b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageAlpha( pd, ps, t ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, t, BLOT_COPY )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageShadedAlpha( pd, ps, t, shade ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, t, BLOT_SHADED, shade )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageMultiShadedAlpha( pd, ps, t, r, g, b ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, t, BLOT_MULTISHADE, r, g, b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImage( pd, ps ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, 0, BLOT_COPY )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageShaded( pd, ps, shade ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, 0, BLOT_SHADED, shade )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageMultiShaded( pd, ps, r, g, b ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, 0, BLOT_MULTISHADE, r, g, b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageTo( pd, ps )  BlotScaledImageToEx( pd, ps, FALSE, BLOT_COPY )
/* now why would we need an inverse line? I don't get it....
   anyhow this would draw from the end to the start... basically
   this accounts for rounding errors on the orward way.          */
#define do_inv_line(pb,x,y,xto,yto,d) do_line( pb,y,x,yto,xto,d)
/* <combine sack::image::PutCharacterFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   \ \                                                                               */
#define PutCharacter(i,x,y,fore,back,c)               PutCharacterFont(i,x,y,fore,back,c,NULL )
/* <combine sack::image::PutCharacterVerticalFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   Passes default font if not specified.                                                     */
#define PutCharacterVertical(i,x,y,fore,back,c)       PutCharacterVerticalFont(i,x,y,fore,back,c,NULL )
/* <combine sack::image::PutCharacterInvertFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   \ \                                                                                     */
#define PutCharacterInvert(i,x,y,fore,back,c)         PutCharacterInvertFont(i,x,y,fore,back,c,NULL )
/* <combine sack::image::PutCharacterVerticalInvertFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   \ \                                                                                             */
#define PutCharacterInvertVertical(i,x,y,fore,back,c) PutCharacterInvertVerticalFont(i,x,y,fore,back,c,NULL )
/* <combine sack::image::PutCharacterVerticalInvertFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   \ \                                                                                             */
#define PutCharacterInvertVerticalFont(i,x,y,fore,back,c,f) PutCharacterVerticalInvertFont(i,x,y,fore,back,c,f )
/* <combine sack::image::PutStringFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                  */
#define PutString(pi,x,y,fore,back,pc) PutStringFontEx( pi, x, y, fore, back, pc, StrLen(pc), NULL )
/* <combine sack::image::PutStringFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                  */
#define PutStringEx(pi,x,y,color,back,pc,len) PutStringFontEx( pi, x, y, color,back,pc,len,NULL )
/* <combine sack::image::PutStringFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                  */
#define PutStringFont(pi,x,y,fore,back,pc,font) PutStringFontEx(pi,x,y,fore,back,pc,StrLen(pc), font )
/* <combine sack::image::PutStringVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                          */
#define PutStringVertical(pi,x,y,fore,back,pc) PutStringVerticalFontEx( pi, x, y, fore, back, pc, StrLen(pc), NULL )
/* <combine sack::image::PutStringVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                          */
#define PutStringVerticalEx(pi,x,y,color,back,pc,len) PutStringVerticalFontEx( pi, x, y, color,back,pc,len,NULL )
/* <combine sack::image::PutStringVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                          */
#define PutStringVerticalFont(pi,x,y,fore,back,pc,font) PutStringVerticalFontEx(pi,x,y,fore,back,pc,StrLen(pc), font )
/* <combine sack::image::PutStringInvertFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                        */
#define PutStringInvert( pi, x, y, fore, back, pc ) PutStringInvertFontEx( pi, x, y, fore, back, pc,StrLen(pc), NULL )
/* <combine sack::image::PutStringInvertFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                        */
#define PutStringInvertEx( pi, x, y, fore, back, pc, nLen ) PutStringInvertFontEx( pi, x, y, fore, back, pc, nLen, NULL )
/* <combine sack::image::PutStringInvertFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   The non Ex Version doesn't pass the string length.                                         */
#define PutStringInvertFont( pi, x, y, fore, back, pc, nLen ) PutStringInvertFontEx( pi, x, y, fore, back, pc, StrLen(pc), font )
/* <combine sack::image::PutStringInvertVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                                */
#define PutStringInvertVertical( pi, x, y, fore, back, pc ) PutStringInvertVerticalFontEx( pi, x, y, fore, back, pc, StrLen(pc), NULL )
/* <combine sack::image::PutStringInvertVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                                */
#define PutStringInvertVerticalEx( pi, x, y, fore, back, pc, nLen ) PutStringInvertVerticalFontEx( pi, x, y, fore, back, pc, nLen, NULL )
/* <combine sack::image::PutStringInvertVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                                */
#define PutStringInvertVerticalFont( pi, x, y, fore, back, pc, font ) PutStringInvertVerticalFontEx( pi, x, y, fore, back, pc, StrLen(pc), font )
//IMG_PROC uint32_t PutMenuStringFontEx        ( ImageFile *pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, uint32_t nLen, PFONT font );
//#define PutMenuStringFont(img,x,y,fore,back,string,font) PutMenuStringFontEx( img,x,y,fore,back,string,StrLen(string),font)
//#define PutMenuString(img,x,y,fore,back,str)           PutMenuStringFont(img,x,y,fore,back,str,NULL)
//
//IMG_PROC uint32_t PutCStringFontEx           ( ImageFile *pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, uint32_t nLen, PFONT font );
//#define PutCStringFont(img,x,y,fore,back,string,font) PutCStringFontEx( img,x,y,fore,back,string,StrLen(string),font)
//#define PutCString( img,x,y,fore,back,string) PutCStringFont(img,x,y,fore,back,string,NULL )
/* <combine sack::image::GetStringSizeFontEx@CTEXTSTR@uint32_t@uint32_t *@uint32_t *@SFTFont>
   \ \                                                                      */
#define GetStringSizeEx(s,len,pw,ph) GetStringSizeFontEx( (s),len,pw,ph,NULL)
/* <combine sack::image::GetStringSizeFontEx@CTEXTSTR@size_t@uint32_t *@uint32_t *@SFTFont>
   \ \                                                                         */
#define GetStringSize(s,pw,ph)       GetStringSizeFontEx( (s),StrLen(s),pw,ph,NULL)
/* <combine sack::image::GetStringSizeFontEx@CTEXTSTR@uint32_t@uint32_t *@uint32_t *@SFTFont>
   \ \                                                                      */
#define GetStringSizeFont(s,pw,ph,f) GetStringSizeFontEx( (s),StrLen(s),pw,ph,f )
#ifdef __cplusplus
IMAGE_NAMESPACE_END
#ifdef _D3D_DRIVER
using namespace sack::image::d3d;
#elif defined( _D3D10_DRIVER )
using namespace sack::image::d3d10;
#elif defined( _D3D11_DRIVER )
using namespace sack::image::d3d11;
#else
using namespace sack::image;
#endif
#endif
#endif
/*   */
#ifdef __cplusplus_cli
//#  undef USE_INTERFACES
#else
#  ifdef FORCE_NO_INTERFACE
#    undef USE_INTERFACES
#  else
#    define USE_INTERFACES
#  endif
#endif
#ifndef PSI_SERVICE
#  ifndef FORCE_NO_INTERFACE
#define USE_RENDER_INTERFACE global_psi_structure.MyDisplayInterface
#  endif
#endif
/* <link sack::image::render::PRENDERER, Render> provides a
   method to display images on a screen. It is the interface
   between memory images and the window desktop or frame buffer
   the user is viewing on a monitor.
   Under windows, this is implemented as an HWND and an HBITMAP
   used to allow the application to draw. Updates are done
   directly from the drawable surface to the HWND as appropriate
   for the type of service. This is implemented with Vidlib.dll.
   Under Linux, this is mounted against SDL. SDL, however, does
   not give multiple display surfaces, so a more direct method
   should be used someday, other than SDL does a good job of
   aliasing frame buffer and X display windows to a consistant
   interface. This is implemented wit DisplayLib (as yet outside
   of the documentation). Display lib can interface either
   directly, or be mounted as a service across from a shared
   memory message service, and host multiple applications on a
   single frame buffer surface.
   TODO
   Implement displays as direct X displays, and allow managment
   there under linux.
   Displaylib was a good project, and although suffers from
   code-rot, it is probably still mostly usable. Message
   services were easily transported across a network, but then
   location services started failing.
   Example
   <code lang="c++">
   // get a render display, just a default window of some size
   // extended features are available for more precision.
   Render render = OpenDisplay(0);
   </code>
   A few methods of using this surface are available. One, you
   may register for events, and be called as required.
   <code lang="c++">
   RedrawCallback MyDraw = DrawHandler;
   MouseCallback MyMouse;
   </code>
   <code>
   KeyProc MyKey;
   CloseCallback MyClose;
   </code>
   <code lang="c++">
   // called when the surface is initially shown, or when its surface changes.
   // otherwise, the image drawn by the application is static, and does
   // not get an update event.
   SetRedrawHandler( render, MyDraw, 0 );
   // This will get an event every time a mouse event happens.
   // If no Key handler is specified, key strokes will also be mouse events.
   SetMouseHandler( render, MyMouse, 0 );
   // If the window was closed, get an event.
   SetCloseHandler( render, MyClose, 0 );
   // specify a handler to get keyboard events...
   SetKeyboardHandler( render, MyKey, 0 );
   </code>
   Or, if you don't really care about any events...
   <code lang="c++">
   // load an image
   Image image = LoadImageFile( "sample.jpg" );
   // get the image target of render
   Image display = GetDisplayImage( render );
   // copy the loaded image to the display image
   BlotImage( display, image );
   // and update the display
   UpdateDisplay( render );
   </code>
   <code lang="c++">
   void CPROC DrawHandler( uintptr_t psvUserData, 31~PRENDERER render )
   {
       Image display = GetDisplayImage( render );
       // the display image may change, because of an external resize
       // update the image to display as desired...
       // when done, the draw handler should call UpdateDisplay or...
       UpdateDisplayPortion( render, 0, 0, 100, 100 );
   }
   </code>
   Oh! And most importantly! Have to call this to put the window
   on the screen.
   <code lang="c++">
   UpdateDisplay( render );
   </code>
   Or maybe can pretend it was hidden
   <code lang="c++">
   RestoreDisplay( render );
   </code>                                                                     */
// this shouldprobably be interlocked with
//  display.h or vidlib.h(video.h)
#ifndef RENDER_INTERFACE_INCLUDED
// multiple inclusion protection symbol.
#define RENDER_INTERFACE_INCLUDED
#ifdef __cplusplus
#ifdef _D3D_DRIVER
#define RENDER_NAMESPACE namespace sack { namespace image { namespace render { namespace d3d {
#define _RENDER_NAMESPACE namespace render { namespace d3d {
#define RENDER_NAMESPACE_END }}}}
#elif defined( _D3D10_DRIVER )
#define RENDER_NAMESPACE namespace sack { namespace image { namespace render { namespace d3d10 {
#define _RENDER_NAMESPACE namespace render { namespace d3d10 {
#define RENDER_NAMESPACE_END }}}}
#elif defined( _D3D11_DRIVER )
#define RENDER_NAMESPACE namespace sack { namespace image { namespace render { namespace d3d11 {
#define _RENDER_NAMESPACE namespace render { namespace d3d11 {
#define RENDER_NAMESPACE_END }}}}
#else
#define RENDER_NAMESPACE namespace sack { namespace image { namespace render {
/* <copy render.h>
   \ \             */
#define _RENDER_NAMESPACE namespace render {
#define RENDER_NAMESPACE_END }}}
#endif
#else
#define RENDER_NAMESPACE
#define _RENDER_NAMESPACE
#define RENDER_NAMESPACE_END
#endif
#ifndef KEYBOARD_DEFINITION
#  define KEYBOARD_DEFINITION
#  ifdef __cplusplus
#    define _RENDER_KEYBOARD_NAMESPACE namespace keyboard {
#    define _RENDER_KEYBOARD_NAMESPACE_END }
#  else
#    define _RENDER_KEYBOARD_NAMESPACE
#    define _RENDER_KEYBOARD_NAMESPACE_END
#  endif
RENDER_NAMESPACE
   _RENDER_KEYBOARD_NAMESPACE
			/* Keyboard state tracking structure... not very optimal...
			   \internal usage might be different.                      */
			enum KeyUpDownState {
KEYISUP   =2,
KEYISDOWN =1
			};
/* <combine sack::image::render::keyboard::keyboard_tag>
   \ \                                                   */
typedef struct keyboard_tag KEYBOARD;
/* <combine sack::image::render::keyboard::keyboard_tag>
   \ \                                                   */
typedef struct keyboard_tag *PKEYBOARD;
struct keyboard_tag
{
#define NUM_KEYS 256
   /* one byte index... more than sufficient
      if character in array is '1' key is down, '2' key is up. */
   char keyupdown[NUM_KEYS];
   /* Indicator that the key is a double-tap, not just a single.
      "!! is different that "!" "!                               */
   char keydouble[NUM_KEYS];
   /* time of the last key event */
   unsigned int  keytime[NUM_KEYS];
   /* I'm not sure, maybe it's the printable key char? */
		unsigned char key[NUM_KEYS];
#if 0
	// void (*Proc)(uintptr_t psv)[NUM_KEYS][8];
#endif
};
_RENDER_KEYBOARD_NAMESPACE_END
RENDER_NAMESPACE_END
#ifdef __cplusplus
#  ifdef _D3D_DRIVER
     using namespace sack::image::render::d3d::keyboard;
#  elif defined( _D3D10_DRIVER )
     using namespace sack::image::render::d3d10::keyboard;
#  elif defined( _D3D11_DRIVER )
     using namespace sack::image::render::d3d11::keyboard;
#  else
     using namespace sack::image::render::keyboard;
#  endif
#endif
//#include "vidlib.h"
	// some common things which are specific to this
   // library, and independant of implementation (so far)
#define KEY_MOD_SHIFT 1
#define KEY_MOD_CTRL  2
#define KEY_MOD_ALT   4
#define KEY_MOD_META  64
// call trigger on release also...
#define KEY_MOD_RELEASE  8
 // application wants both press and release events.
#define KEY_MOD_ALL_CHANGES  16
 // key match must be extended also... (extra arrow keys for instance.. what about SDL)
#define KEY_MOD_EXTENDED 32
#define KEY_PRESSED         0x80000000
#define IsKeyPressed( keycode ) ( (keycode) & 0x80000000 )
#define KEY_ALT_DOWN        0x40000000
#define KEY_CONTROL_DOWN    0x20000000
#define KEY_SHIFT_DOWN      0x10000000
#define KEY_MOD_DOWN (KEY_ALT_DOWN|KEY_CONTROL_DOWN)
#define KEY_ALPHA_LOCK_ON   0x08000000
#define KEY_NUM_LOCK_ON     0x04000000
#define KEY_MOD(key)        ( ( (key) & 0x70000000 ) >> 28 )
#define KEY_REAL_CODE(key)  ( ( (key) & 0x00FF0000 ) >> 16 )
#define KEY_CODE(key)       ( (key) & 0xFF )
#define IsKeyExtended(key)  ( ( (key) & 0x00000100 ) >> 8 )
#if defined( _WIN32 ) || defined( WIN32 ) || defined( __CYGWIN__ ) || defined( USE_WIN32_KEY_DEFINES )
// mirrored KEY_ definitions from allegro.H library....
//#include <windows.h>
#  define BIT_7           0x80
#  define KEY_TAB          9
#  define KEY_CENTER       12
#  define KEY_PAD5         12
#  define KEY_ENTER        13
#  define KEY_LSHIFT       16
#  define KEY_SHIFT        16
#  define KEY_LEFT_SHIFT   0x10
 // maybe?
#  define KEY_RIGHT_SHIFT  0x10
#  define KEY_SHIFT_LEFT KEY_LEFT_SHIFT
#  define KEY_SHIFT_RIGHT KEY_RIGHT_SHIFT
#  define KEY_CTRL         17
#  define KEY_CONTROL      17
#  define KEY_LEFT_CONTROL  17
#  define KEY_RIGHT_CONTROL 17
 // can't get usually under windows?(keyhook!)
#  define KEY_ALT          18
#  define KEY_LEFT_ALT      18
#  define KEY_RIGHT_ALT     18
#  define KEY_CAPS_LOCK    20
#  define KEY_ESC          27
#  define KEY_ESCAPE       27
#  define KEY_PGUP         33
#  define KEY_PAGE_UP     KEY_PGUP
#  define KEY_PGDN         34
#  define KEY_PAGE_DOWN   KEY_PGDN
#  define KEY_END          35
#  define KEY_HOME         36
#  define KEY_LEFT         37
#  define KEY_UP           38
#  define KEY_RIGHT        39
#  define KEY_DOWN         40
#  define KEY_GRAY_UP  38
#  define KEY_GRAY_LEFT   37
#  define KEY_GRAY_RIGHT  39
#  define KEY_GRAY_DOWN    40
//#  define KEY_GRAY_UP      BIT_7+0x48
#  define KEY_GRAY_PGUP   BIT_7+0x49
#  define KEY_GRAY_MINUS  BIT_7+0x4A
//#  define KEY_GRAY_LEFT BIT_7+0x4B
//#  define KEY_GRAY_RIGHT   BIT_7+0x4D
#  define KEY_GRAY_PLUS   BIT_7+0x4E
#  define KEY_GRAY_END    BIT_7+0x4F
#  define KEY_PAD_PLUS   BIT_7+0x4E
//#  define KEY_GRAY_DOWN BIT_7+0x50
#  define KEY_GRAY_PGDN   BIT_7+0x51
#  define KEY_GRAY_INS    BIT_7+0x52
#  define KEY_GRAY_DEL    BIT_7+0x53
#  define KEY_GRAY_DELETE    BIT_7+0x53
#  define KEY_GREY_DELETE    BIT_7+0x53
#  define KEY_INSERT       45
#  define KEY_DEL          46
#  define KEY_DELETE       KEY_DEL
#  define KEY_PRINT_SCREEN1  VK_PRINT
#  define KEY_PRINT_SCREEN2  VK_SNAPSHOT
 // windows keys keys
#  define KEY_WINDOW_2     0x50
 // windows keys keys
#  define KEY_WINDOW_1     0x5c
#  define KEY_GRAY_STAR     0x6a
#  define KEY_PLUS_PAD     0x6b
//#  define KEY_GRAY_MINUS    0x6d
#  define KEY_GRAY_SLASH    VK_OEM_5
//#  define KEY_GRAY_PLUS     107
#  define KEY_NUM_LOCK      VK_NUMLOCK
#  define KEY_SCROLL_LOCK VK_SCROLL
#  define KEY_SLASH        VK_OEM_2
#  define KEY_BACKSPACE   '\b'
#  define KEY_SPACE        ' '
#  define KEY_COMMA      0xBC
 // should be some sort of VK_ definitions....
#  define KEY_STOP       0xBE
#  define KEY_PERIOD     KEY_STOP
#  define KEY_A         'A'
#  define KEY_B         'B'
#  define KEY_C         'C'
#  define KEY_D         'D'
#  define KEY_E         'E'
#  define KEY_F         'F'
#  define KEY_G         'G'
#  define KEY_H         'H'
#  define KEY_I         'I'
#  define KEY_J         'J'
#  define KEY_K         'K'
#  define KEY_L         'L'
#  define KEY_F12  VK_F12
#  define KEY_F11  VK_F11
#  define KEY_F10  VK_F10
#  define KEY_F9  VK_F9
#  define KEY_F8  VK_F8
#  define KEY_F7  VK_F7
#  define KEY_F6  VK_F6
#  define KEY_F5  VK_F5
#  define KEY_F4  VK_F4
#  define KEY_F3  VK_F3
#  define KEY_F2  VK_F2
#  define KEY_F1  VK_F1
#  define KEY_M        77
#  define KEY_N         78
#  define KEY_O         79
#  define KEY_P        80
#  define KEY_Q         'Q'
#  define KEY_R         'R'
#  define KEY_S         'S'
#  define KEY_T         'T'
#  define KEY_U         'U'
#  define KEY_V         'V'
#  define KEY_W         'W'
#  define KEY_X         'X'
#  define KEY_Y         'Y'
#  define KEY_Z         'Z'
#  define KEY_1         '1'
#  define KEY_2         '2'
#  define KEY_3         '3'
#  define KEY_4         '4'
#  define KEY_5         '5'
#  define KEY_6         '6'
#  define KEY_7         '7'
#  define KEY_8         '8'
#  define KEY_9         '9'
#  define KEY_0         '0'
#  define KEY_MINUS    KEY_DASH
#  ifndef VK_OEM_1
// native windows OEM definitions
#    define VK_OEM_1   186
#    define VK_OEM_2   191
#    define VK_OEM_4   219
#    define VK_OEM_5   220
#    define VK_OEM_6   221
#    define VK_OEM_7   222
#    define VK_OEM_MINUS  189
#    define VK_OEM_PLUS    187
#  endif
#  define KEY_SEMICOLON     VK_OEM_1
#  define KEY_QUOTE         VK_OEM_7
#  define KEY_LEFT_BRACKET  VK_OEM_4
#  define KEY_RIGHT_BRACKET VK_OEM_6
#  define KEY_BACKSLASH     VK_OEM_5
//'-'
#  define KEY_DASH     VK_OEM_MINUS
#  define KEY_EQUAL    VK_OEM_PLUS
#  define KEY_EQUALS   KEY_EQUAL
#  define KEY_ACCENT 192
#  define KEY_GRAVE  KEY_ACCENT
#  define KEY_APOSTROPHE  KEY_ACCENT
#  define KEY_F1  VK_F1
#  define KEY_F2  VK_F2
#  define KEY_F3  VK_F3
#  define KEY_F4  VK_F4
#  define KEY_F5  VK_F5
#  define KEY_F6  VK_F6
#  define KEY_F7  VK_F7
#  define KEY_F8  VK_F8
#  define KEY_F9  VK_F9
#  define KEY_F10  VK_F10
#  define KEY_F1  VK_F1
#  define VK_NUMPAD0        0x60
#  define VK_NUMPAD1        0x61
#  define VK_NUMPAD2        0x62
#  define VK_NUMPAD3        0x63
#  define VK_NUMPAD4        0x64
#  define VK_NUMPAD5        0x65
#  define VK_NUMPAD6        0x66
#  define VK_NUMPAD7        0x67
#  define VK_NUMPAD8        0x68
#  define VK_NUMPAD9        0x69
#  define VK_MULTIPLY       0x6A
#  define VK_ADD            0x6B
#  define VK_SEPARATOR      0x6C
#  define VK_SUBTRACT       0x6D
#  define VK_DECIMAL        0x6E
#  define VK_DIVIDE         0x6F
#  define KEY_PAD_MULT VK_MULTIPLY
#  define KEY_PAD_DOT VK_DECIMAL
#  define KEY_PAD_DIV VK_DIVIDE
#  define KEY_PAD_0 VK_NUMPAD0
#  define KEY_GREY_INSERT VK_NUMPAD0
#  define KEY_PAD_1 VK_NUMPAD1
#  define KEY_PAD_2 VK_NUMPAD2
#  define KEY_PAD_3 VK_NUMPAD3
#  define KEY_PAD_4 VK_NUMPAD4
#  define KEY_PAD_5 VK_NUMPAD5
#  define KEY_PAD_6 VK_NUMPAD6
#  define KEY_PAD_7 VK_NUMPAD7
#  define KEY_PAD_8 VK_NUMPAD8
#  define KEY_PAD_9 VK_NUMPAD9
#  define KEY_PAD_ENTER VK_RETURN
#  define KEY_PAD_DELETE VK_SEPARATOR
#  define KEY_PAD_MINUS VK_SUBTRACT
#endif
#if defined( __EMSCRIPTEN__ ) || defined( __EMSCRIPTEN__ )
	  /*   https://w3c.github.io/uievents/#fixed-virtual-key-codes
      // for keyCode
      */
#define KEY_BACKSPACE 8
#define KEY_TAB 9
#define KEY_ENTER 13
#define KEY_SHIFT 16
#define KEY_LEFT_SHIFT 16
#define KEY_RIGHT_SHIFT 16
#define KEY_CTRL 17
#define KEY_CONTROL 17
#define KEY_LEFT_CONTROL 17
#define KEY_RIGHT_CONTROL 17
#define KEY_ALT 18
#define KEY_LEFT_ALT 18
#define KEY_RIGHT_ALT 18
#define KEY_F1  112
#define KEY_F2  113
#define KEY_F3  114
#define KEY_F4  115
#define KEY_F5  116
#define KEY_F6  117
#define KEY_F7  118
#define KEY_F8  119
#define KEY_F9  120
#define KEY_F10  121
#define KEY_F11  122
#define KEY_F12  123
#  undef KEY_SPACE
#  define KEY_SPACE        ' '
#  define KEY_A         'A'
#  define KEY_B         'B'
#  define KEY_C         'C'
#  define KEY_D         'D'
#  define KEY_E         'E'
#  define KEY_F         'F'
#  define KEY_G         'G'
#  define KEY_H         'H'
#  define KEY_I         'I'
#  define KEY_J         'J'
#  define KEY_K         'K'
#  define KEY_L         'L'
#  define KEY_M        77
#  define KEY_N         78
#  define KEY_O         79
#  define KEY_P        80
#  define KEY_Q         'Q'
#  define KEY_R         'R'
#  define KEY_S         'S'
#  define KEY_T         'T'
#  define KEY_U         'U'
#  define KEY_V         'V'
#  define KEY_W         'W'
#  define KEY_X         'X'
#  define KEY_Y         'Y'
#  define KEY_Z         'Z'
#  define KEY_1         '1'
#  define KEY_2         '2'
#  define KEY_3         '3'
#  define KEY_4         '4'
#  define KEY_5         '5'
#  define KEY_6         '6'
#  define KEY_7         '7'
#  define KEY_8         '8'
#  define KEY_9         '9'
#  define KEY_0         '0'
   //';'
#define KEY_SEMICOLON	186
   //':'
#define KEY_COLON	    186
  //'='	//187
#define KEY_EQUAL        187
  //'+'	//187
#define KEY_PLUS	     187
   //','	//188
#define KEY_COMMA	      188
     //'<'		//188
#define KEY_LESS_THAN	188
     //'-'		//189
#define KEY_MINUS	     189
    //'-'       //189
#define KEY_DASH         189
  //'_'		//189
#define KEY_Underscore	189
   //'.'		//190
#define KEY_STOP	     190
   //'.'		//190
#define KEY_PERIOD	     190
   //'>'		//190
#define KEY_GREATER_THAN	190
    //'/'		//191
#define KEY_SLASH	   191
   //'?'		//191
#define KEY_QUESTION	191
 //'`'		//192
#define KEY_ACCENT	     192
 //'~'		//192
#define KEY_TILDE	    192
  //'['		//219
#define KEY_LEFT_BRACKET	219
  //'{'		//219
#define KEY_OPEN_BRACE	219
  //'\\'		//220
#define KEY_BACKSLASH	220
 //'|'		//220
#define KEY_PIPE	     220
//']'		//221
#define KEY_RIGHT_BRACKET	221
//	'}'		//221
#define KEY_CLOSE_BRACE     221
   //'\''		//222
#define KEY_QUOTE	222
//Double quote	'\"'		//222
#  define KEY_ESCAPE       27
#  define KEY_PGUP         33
#  define KEY_PAGE_UP      33
#  define KEY_PGDN         34
#  define KEY_PAGE_DOWN    34
#  define KEY_END          35
#  define KEY_HOME         36
#  define KEY_LEFT         37
#  define KEY_UP           38
#  define KEY_RIGHT        39
#  define KEY_DOWN         40
#  define KEY_GRAY_UP  38
#  define KEY_GRAY_LEFT   37
#  define KEY_GRAY_RIGHT  39
#  define KEY_GRAY_DOWN    40
//#  define KEY_GRAY_UP      0x48
#  define KEY_GRAY_PGUP     33
#  define KEY_GRAY_MINUS    109
//#  define KEY_GRAY_LEFT 0x4B
//#  define KEY_GRAY_RIGHT   0x4D
#  define KEY_GRAY_PLUS   107
#  define KEY_GRAY_END    0x4F
#  define KEY_PAD_PLUS   107
//#  define KEY_GRAY_DOWN 0x50
#  define KEY_GRAY_PGDN   34
#  define KEY_GRAY_INS    45
#  define KEY_GRAY_INSERT    45
#  define KEY_GREY_INSERT   45
#  define KEY_GRAY_DEL       46
#  define KEY_GRAY_DELETE    46
#  define KEY_GREY_DELETE    47
#  define KEY_INSERT       45
#  define KEY_DEL          46
#  define KEY_DELETE       KEY_DEL
#  define KEY_PAD_MULT 106
#  define KEY_PAD_DOT  110
#  define KEY_PAD_DELETE 110
#  define KEY_PAD_DIV 111
#  define KEY_PAD_0 96
#  define KEY_PAD_1 97
#  define KEY_PAD_2 98
#  define KEY_PAD_3 99
#  define KEY_PAD_4 100
#  define KEY_PAD_5 101
#  define KEY_PAD_6 102
#  define KEY_PAD_7 103
#  define KEY_PAD_8 104
#  define KEY_PAD_9 105
#  define KEY_PAD_ENTER KEY_ENTER
#  define KEY_PAD_MINUS 109
#define KEY_NUM_LOCK 144
#undef KEY_SCROLL_LOCK
#define KEY_SCROLL_LOCK 145
     /*   https://w3c.github.io/uievents/#fixed-virtual-key-codes
     Backspace	8
Tab	9
Enter	13
Shift	16
Control	17
Alt	18
CapsLock	20
Escape	27	Esc
Space	32
PageUp	33
PageDown	34
End	35
Home	36
ArrowLeft	37
ArrowUp	38
ArrowRight	39
ArrowDown	40
Delete	46	Del
Semicolon	";"	186
Colon	":"	186
Equals sign	"="	187
Plus	"+"	187
Comma	","	188
Less than sign	"<"	188
Minus	"-"	189
Underscore	"_"	189
Period	"."	190
Greater than sign	">"	190
Forward slash	"/"	191
Question mark	"?"	191
Backtick	"`"	192
Tilde	"~"	192
Opening squace bracket	"["	219
Opening curly brace	"{"	219
Backslash	"\"	220
Pipe	"|"	220
Closing square bracket	"]"	221
Closing curly brace	"}"	221
Single quote	"'"	222
Double quote	"""	222
     */
#  endif
// if any key...
#if !defined( KEY_1 )
#  if defined( __ANDROID__ )
#    include <android/keycodes.h>
#    define KEY_SHIFT        AKEYCODE_SHIFT_LEFT
#    define KEY_LEFT_SHIFT   AKEYCODE_SHIFT_LEFT
 // maybe?
#    define KEY_RIGHT_SHIFT  AKEYCODE_SHIFT_RIGHT
#    ifndef AKEYCODE_CTRL_LEFT
#      define AKEYCODE_CTRL_LEFT 113
#    endif
#    ifndef AKEYCODE_CTRL_RIGHT
#      define AKEYCODE_CTRL_RIGHT 114
#    endif
#    define KEY_CTRL          AKEYCODE_CTRL_LEFT
#    define KEY_CONTROL       AKEYCODE_CTRL_LEFT
#    define KEY_LEFT_CONTROL  AKEYCODE_CTRL_LEFT
#    define KEY_RIGHT_CONTROL AKEYCODE_CTRL_RIGHT
 // can't get usually under windows?(keyhook!)
#    define KEY_ALT           AKEYCODE_ALT_LEFT
#    define KEY_LEFT_ALT      AKEYCODE_ALT_LEFT
#    define KEY_RIGHT_ALT     AKEYCODE_ALT_RIGHT
#    ifndef AKEYCODE_CAPS_LOCK
#      define AKEYCODE_CAPS_LOCK 115
#    endif
#    define KEY_CAPS_LOCK     AKEYCODE_CAPS_LOCK
#    define KEY_NUM_LOCK      0
#    ifndef AKEYCODE_SCROLL_LOCK
#      define AKEYCODE_SCROLL_LOCK 116
#    endif
 // unsure about this
#    define KEY_SCROLL_LOCK   AKEYCODE_SCROLL_LOCK
#    ifndef AKEYCODE_ESCAPE
#      define AKEYCODE_ESCAPE 111
#    endif
#    define KEY_ESC           AKEYCODE_ESCAPE
#    define KEY_ESCAPE        AKEYCODE_ESCAPE
#    ifndef AKEYCODE_MOVE_HOME
#      define AKEYCODE_MOVE_HOME 122
#    endif
#    ifndef AKEYCODE_MOVE_END
#      define AKEYCODE_MOVE_END 123
#    endif
#    define KEY_HOME          AKEYCODE_MOVE_HOME
#    define KEY_PAD_HOME      AKEYCODE_MOVE_HOME
#    define KEY_PAD_7         0
#    define KEY_GREY_HOME     0
#    define KEY_UP            AKEYCODE_DPAD_UP
#    define KEY_PAD_8         0
#    define KEY_PAD_UP        0
#    define KEY_GREY_UP       0
#    define KEY_PGUP          0
#    define KEY_PAD_9         0
#    define KEY_PAD_PGUP      0
#    define KEY_GREY_PGUP     0
#    define KEY_LEFT          AKEYCODE_DPAD_LEFT
#    define KEY_PAD_4         0
#    define KEY_PAD_LEFT      0
#    define KEY_GREY_LEFT     0
#    define KEY_CENTER        AKEYCODE_DPAD_CENTER
#    define KEY_PAD_5         0
#    define KEY_PAD_CENTER    0
#    define KEY_GREY_CENTER   0
#    define KEY_RIGHT         AKEYCODE_DPAD_RIGHT
#    define KEY_PAD_6         0
#    define KEY_PAD_RIGHT     0
#    define KEY_GREY_RIGHT    0
#    define KEY_END           AKEYCODE_MOVE_END
#    define KEY_PAD_1         0
#    define KEY_PAD_END       0
#    define KEY_GREY_END      0
#    define KEY_DOWN          AKEYCODE_DPAD_DOWN
#    define KEY_PAD_2         0
#    define KEY_PAD_DOWN      0
#    define KEY_GREY_DOWN     0
#    define KEY_PGDN          0
#    define KEY_PAD_3         0
#    define KEY_PAD_PGDN      0
#    define KEY_GREY_PGDN     0
#    define KEY_INSERT        0
#    define KEY_PAD_0         0
#    define KEY_PAD_INSERT    0
#    define KEY_GREY_INSERT   0
#    define KEY_DELETE        0
#    define KEY_PAD_DOT       0
#    define KEY_PAD_DELETE    0
#    define KEY_GREY_DELETE   0
#    define KEY_PLUS          0
#    define KEY_PAD_PLUS      0
#    define KEY_GREY_PLUS     0
#    define KEY_MINUS         0
#    define KEY_PAD_MINUS     0
#    define KEY_GREY_MINUS    0
#    define KEY_MULT          0
#    define KEY_PAD_MULT      0
#    define KEY_GREY_MULT     0
#    define KEY_DIV           0
#    define KEY_PAD_DIV       0
#    define KEY_GREY_DIV      0
#    define KEY_ENTER         AKEYCODE_ENTER
#    define KEY_PAD_ENTER     AKEYCODE_ENTER
#    define KEY_NORMAL_ENTER  AKEYCODE_ENTER
 // windows keys keys
#    define KEY_WINDOW_1      0
 // windows keys keys
#    define KEY_WINDOW_2      0
#    define KEY_TAB           AKEYCODE_TAB
#    define KEY_SLASH         AKEYCODE_SLASH
#    define KEY_BACKSPACE     AKEYCODE_DEL
#    define KEY_SPACE         AKEYCODE_SPACE
#    define KEY_COMMA         AKEYCODE_COMMA
 // should be some sort of VK_ definitions....
#    define KEY_STOP          AKEYCODE_PERIOD
#    define KEY_PERIOD        AKEYCODE_PERIOD
#    define KEY_SEMICOLON     AKEYCODE_SEMICOLON
#    define KEY_QUOTE         AKEYCODE_APOSTROPHE
#    define KEY_LEFT_BRACKET  AKEYCODE_LEFT_BRACKET
#    define KEY_RIGHT_BRACKET AKEYCODE_RIGHT_BRACKET
#    define KEY_BACKSLASH     AKEYCODE_BACKSLASH
#    define KEY_DASH          AKEYCODE_MINUS
#    define KEY_EQUAL         AKEYCODE_EQUALS
#    define KEY_ACCENT        AKEYCODE_GRAVE
#    define KEY_1         AKEYCODE_1
#    define KEY_2         AKEYCODE_2
#    define KEY_3         AKEYCODE_3
#    define KEY_4         AKEYCODE_4
#    define KEY_5         AKEYCODE_5
#    define KEY_6         AKEYCODE_6
#    define KEY_7         AKEYCODE_7
#    define KEY_8         AKEYCODE_8
#    define KEY_9         AKEYCODE_9
#    define KEY_0         AKEYCODE_0
#    define KEY_F1        0
#    define KEY_F2        0
#    define KEY_F3        0
#    define KEY_F4        0
#    define KEY_F5        0
#    define KEY_F6        0
#    define KEY_F7        0
#    define KEY_F8        0
#    define KEY_F9        0
#    define KEY_F10       0
#    define KEY_F11       0
#    define KEY_F12       0
#    define KEY_A   AKEYCODE_A
#    define KEY_B   AKEYCODE_B
#    define KEY_C   AKEYCODE_C
#    define KEY_D   AKEYCODE_D
#    define KEY_E   AKEYCODE_E
#    define KEY_F   AKEYCODE_F
#    define KEY_G   AKEYCODE_G
#    define KEY_H   AKEYCODE_H
#    define KEY_I   AKEYCODE_I
#    define KEY_J   AKEYCODE_J
#    define KEY_K   AKEYCODE_K
#    define KEY_L   AKEYCODE_L
#    define KEY_M   AKEYCODE_M
#    define KEY_N   AKEYCODE_N
#    define KEY_O   AKEYCODE_O
#    define KEY_P   AKEYCODE_P
#    define KEY_Q   AKEYCODE_Q
#    define KEY_R   AKEYCODE_R
#    define KEY_S   AKEYCODE_S
#    define KEY_T   AKEYCODE_T
#    define KEY_U   AKEYCODE_U
#    define KEY_V   AKEYCODE_V
#    define KEY_W   AKEYCODE_W
#    define KEY_X   AKEYCODE_X
#    define KEY_Y   AKEYCODE_Y
#    define KEY_Z   AKEYCODE_Z
#  elif defined( __LINUX__ )
	  //#define USE_SDL_KEYSYM
// ug - KEYSYMS are too wide...
// so - we fall back to x scancode tables - and translate sym to these
// since the scancodes which come from X are not the same as from console Raw
// but - perhaps we should re-translate these to REAL scancodes... but in either
// case - these fall to under 256 characters, and can therefore be used...
#    define USE_X_RAW_SCANCODES
#    ifdef USE_X_RAW_SCANCODES
#      define KEY_SHIFT        0xFF
#      define KEY_LEFT_SHIFT   50
 // maybe?
#      define KEY_RIGHT_SHIFT  62
#      define KEY_CTRL          0xFE
#      define KEY_CONTROL       0xFE
#      define KEY_LEFT_CONTROL  37
#      define KEY_RIGHT_CONTROL 109
 // can't get usually under windows?(keyhook!)
#      define KEY_ALT           0xFD
#      define KEY_LEFT_ALT      64
#      define KEY_RIGHT_ALT     113
#      define KEY_CAPS_LOCK     66
#      define KEY_NUM_LOCK      77
 // unsure about this
#      define KEY_SCROLL_LOCK   78
#      define KEY_ESC           9
#      define KEY_ESCAPE        9
#      define KEY_HOME          0xFC
#      define KEY_PAD_HOME      79
#      define KEY_PAD_7         79
#      define KEY_GREY_HOME     97
#      define KEY_UP            0xFB
#      define KEY_PAD_8         80
#      define KEY_PAD_UP        80
#      define KEY_GREY_UP       98
#      define KEY_PGUP          0xFA
#      define KEY_PAGE_UP       KEY_PGUP
#      define KEY_PAD_9         81
#      define KEY_PAD_PGUP      81
#      define KEY_GREY_PGUP     99
#      define KEY_LEFT          0xF9
#      define KEY_PAD_4         83
#      define KEY_PAD_LEFT      83
#      define KEY_GREY_LEFT     100
#      define KEY_CENTER        0xF8
#      define KEY_PAD_5         84
#      define KEY_PAD_CENTER    84
#      define KEY_GREY_CENTER   0
#      define KEY_RIGHT         0xF7
#      define KEY_PAD_6         85
#      define KEY_PAD_RIGHT     85
#      define KEY_GREY_RIGHT    102
#      define KEY_END           0xF6
#      define KEY_PAD_1         87
#      define KEY_PAD_END       87
#      define KEY_GREY_END      103
#      define KEY_DOWN          0xF5
#      define KEY_PAD_2         88
#      define KEY_PAD_DOWN      88
#      define KEY_GREY_DOWN     104
#      define KEY_PGDN          0xF4
#      define KEY_PAGE_DOWN     KEY_PGDN
#      define KEY_PAD_3         89
#      define KEY_PAD_PGDN      89
#      define KEY_GREY_PGDN     105
#      define KEY_INSERT        0xF3
#      define KEY_PAD_0         90
#      define KEY_PAD_INSERT    90
#      define KEY_GREY_INSERT   106
#      define KEY_DELETE        0xF2
#      define KEY_DEL           KEY_DELETE
#      define KEY_PAD_DOT       91
#      define KEY_PAD_DELETE    91
#      define KEY_GREY_DELETE   107
#      define KEY_PLUS          0xF1
#      define KEY_PAD_PLUS      86
#      define KEY_GREY_PLUS     0
#      define KEY_MINUS         0xF0
#      define KEY_PAD_MINUS     82
#      define KEY_GREY_MINUS    0
#      define KEY_MULT          0xEF
#      define KEY_PAD_MULT      63
#      define KEY_GREY_MULT     0
#      define KEY_DIV           0xEE
#      define KEY_PAD_DIV       112
#      define KEY_GREY_DIV      0
#      define KEY_ENTER         0xED
#      define KEY_PAD_ENTER     108
#      define KEY_NORMAL_ENTER  36
 // windows keys keys
#      define KEY_WINDOW_1      115
 // windows keys keys
#      define KEY_WINDOW_2      117
#      define KEY_TAB           23
#      define KEY_SLASH         61
#      define KEY_BACKSPACE     22
#      define KEY_SPACE         65
#      define KEY_COMMA         59
 // should be some sort of VK_ definitions....
#      define KEY_STOP          60
#      define KEY_PERIOD        KEY_STOP
#      define KEY_SEMICOLON     47
#      define KEY_QUOTE         48
#      define KEY_LEFT_BRACKET  34
#      define KEY_RIGHT_BRACKET 35
#      define KEY_BACKSLASH     51
#      define KEY_DASH          20
#      define KEY_EQUAL         21
#      define KEY_EQUALS       KEY_EQUAL
#      define KEY_ACCENT        49
#      define KEY_APOSTROPHE    KEY_QUOTE
#      define KEY_GRAVE        KEY_ACCENT
#      define KEY_SHIFT_LEFT   KEY_LEFT_SHIFT
#      define KEY_SHIFT_RIGHT  KEY_RIGHT_SHIFT
#      define KEY_1         10
#      define KEY_2         11
#      define KEY_3         12
#      define KEY_4         13
#      define KEY_5         14
#      define KEY_6         15
#      define KEY_7         16
#      define KEY_8         17
#      define KEY_9         18
#      define KEY_0         19
#      define KEY_F1        67
#      define KEY_F2        68
#      define KEY_F3        69
#      define KEY_F4        70
#      define KEY_F5        71
#      define KEY_F6        72
#      define KEY_F7        73
#      define KEY_F8        74
#      define KEY_F9        75
#      define KEY_F10       76
#      define KEY_F11       95
#      define KEY_F12       96
#      define KEY_A         38
#      define KEY_B         56
#      define KEY_C         54
#      define KEY_D         40
#      define KEY_E         26
#      define KEY_F         41
#      define KEY_G         42
#      define KEY_H         43
#      define KEY_I         31
#      define KEY_J         44
#      define KEY_K         45
#      define KEY_L         46
#      define KEY_M         58
#      define KEY_N         57
#      define KEY_O         32
#      define KEY_P         33
#      define KEY_Q         24
#      define KEY_R         27
#      define KEY_S         39
#      define KEY_T         28
#      define KEY_U         30
#      define KEY_V         55
#      define KEY_W         25
#      define KEY_X         53
#      define KEY_Y         29
#      define KEY_Z         52
#    elif defined( USE_SDL_KEYSYM )
#      include <SDL.h>
#      define KEY_SHIFT        0xFF
#      define KEY_LEFT_SHIFT   SDLK_LSHIFT
#      define KEY_RIGHT_SHIFT  SDLK_RSHIFT
#      define KEY_CTRL          0xFE
#      define KEY_CONTROL       0xFE
#      define KEY_LEFT_CONTROL  SDLK_LCTRL
#      define KEY_RIGHT_CONTROL SDLK_RCTRL
 // can't get usually under windows?(keyhook!)
#      define KEY_ALT           0xFD
#      define KEY_LEFT_ALT      SDLK_LALT
#      define KEY_RIGHT_ALT     SDLK_RALT
#      define KEY_CAPS_LOCK     SDLK_CAPSLOCK
#      define KEY_NUM_LOCK      SDLK_NUMLOCK
#      define KEY_SCROLL_LOCK   SDLK_SCROLLOCK
#      define KEY_ESC           SDLK_ESCAPE
#      define KEY_ESCAPE        SDLK_ESCAPE
#      define KEY_HOME          0xFC
#      define KEY_PAD_HOME      SDLK_KP7
#      define KEY_PAD_7         SDLK_KP7
#      define KEY_GREY_HOME     SDLK_HOME
#      define KEY_UP            0xFB
#      define KEY_PAD_8         SDLK_KP8
#      define KEY_PAD_UP        SDLK_KP8
#      define KEY_GREY_UP       SDLK_UP
#      define KEY_PGUP          0xFA
#      define KEY_PAD_9         SDLK_KP9
#      define KEY_PAD_PGUP      SDLK_KP9
#      define KEY_GREY_PGUP     SDLK_PAGEUP
#      define KEY_LEFT          0xF9
#      define KEY_PAD_4         SDLK_KP4
#      define KEY_PAD_LEFT      SDLK_KP4
#      define KEY_GREY_LEFT     SDLK_LEFT
#      define KEY_CENTER        0xF8
#      define KEY_PAD_5         SDLK_KP5
#      define KEY_PAD_CENTER    SDLK_KP5
#      define KEY_GREY_CENTER   0
#      define KEY_RIGHT         0xF7
#      define KEY_PAD_6         SDLK_KP6
#      define KEY_PAD_RIGHT     SDLK_KP6
#      define KEY_GREY_RIGHT    SDLK_RIGHT
#      define KEY_END           0xF6
#      define KEY_PAD_1         SDLK_KP1
#      define KEY_PAD_END       SDLK_KP1
#      define KEY_GREY_END      SDLK_END
#      define KEY_DOWN          0xF5
#      define KEY_PAD_2         SDLK_KP2
#      define KEY_PAD_DOWN      SDLK_KP2
#      define KEY_GREY_DOWN     SDLK_DOWN
#      define KEY_PGDN          0xF4
#      define KEY_PAD_3         SDLK_KP3
#      define KEY_PAD_PGDN      SDLK_KP3
#      define KEY_GREY_PGDN     SDLK_PAGEDN
#      define KEY_INSERT        0xF3
#      define KEY_PAD_0         SDLK_KP0
#      define KEY_PAD_INSERT    SDLK_KP0
#      define KEY_GREY_INSERT   SDLK_INSERT
#      define KEY_DELETE        0xF2
#      define KEY_PAD_DOT       SDLK_KP_PERIOD
#      define KEY_PAD_DELETE    SDLK_KP_PERIOD
#      define KEY_GREY_DELETE   SDLK_DELETE
#      define KEY_PLUS          0xF1
#      define KEY_PAD_PLUS      SDLK_KP_PLUS
#      define KEY_GREY_PLUS     0
#      define KEY_MINUS         0xF0
#      define KEY_PAD_MINUS     SDLK_KP_MINUS
#      define KEY_GREY_MINUS    0
#      define KEY_MULT          0xEF
#      define KEY_PAD_MULT      SDLK_KP_MULTIPLY
#      define KEY_GREY_MULT     0
#      define KEY_DIV           0xEE
#      define KEY_PAD_DIV       SDLK_KP_DIVIDE
#      define KEY_GREY_DIV      0
#      define KEY_ENTER         0xED
#      define KEY_PAD_ENTER     SDLK_KP_ENTER
#      define KEY_NORMAL_ENTER  SDLK_RETURN
 // windows keys keys
#      define KEY_WINDOW_1      115
 // windows keys keys
#      define KEY_WINDOW_2      117
#      define KEY_TAB           SDLK_TAB
#      define KEY_SLASH         SDLK_SLASH
#      define KEY_BACKSPACE     SDLK_BACKSPACE
#      define KEY_SPACE         SDLK_SPACE
#      define KEY_COMMA         SDLK_COMMA
 // should be some sort of VK_ definitions....
#      define KEY_STOP          SDLK_PERIOD
#      define KEY_PERIOD        KEY_STOP
#      define KEY_SEMICOLON     SDLK_SEMICOLON
#      define KEY_QUOTE         SDLK_QUOTE
#      define KEY_LEFT_BRACKET  SDLK_LEFTBRACKET
#      define KEY_RIGHT_BRACKET SDLK_RIGHTBRACKET
#      define KEY_BACKSLASH     SDLK_BACKSLASH
#      define KEY_DASH          SDLK_MINUS
#      define KEY_EQUAL         SDLK_EQUALS
 // grave
#      define KEY_ACCENT        SDLK_BACKQUOTE
#      define KEY_1         SDLK_1
#      define KEY_2         SDLK_2
#      define KEY_3         SDLK_3
#      define KEY_4         SDLK_4
#      define KEY_5         SDLK_5
#      define KEY_6         SDLK_6
#      define KEY_7         SDLK_7
#      define KEY_8         SDLK_8
#      define KEY_9         SDLK_9
#      define KEY_0         SDLK_0
#      define KEY_F1        SDLK_F1
#      define KEY_F2        SDLK_F2
#      define KEY_F3        SDLK_F3
#      define KEY_F4        SDLK_F4
#      define KEY_F5        SDLK_F5
#      define KEY_F6        SDLK_F6
#      define KEY_F7        SDLK_F7
#      define KEY_F8        SDLK_F8
#      define KEY_F9        SDLK_F9
#      define KEY_F10       SDLK_F10
#      define KEY_F11       SDLK_F11
#      define KEY_F12       SDLK_F12
#      define KEY_A         SDLK_A
#      define KEY_B         SDLK_B
#      define KEY_C         SDLK_C
#      define KEY_D         SDLK_D
#      define KEY_E         SDLK_E
#      define KEY_F         SDLK_F
#      define KEY_G         SDLK_G
#      define KEY_H         SDLK_H
#      define KEY_I         SDLK_I
#      define KEY_J         SDLK_J
#      define KEY_K         SDLK_K
#      define KEY_L         SDLK_L
#      define KEY_M         SDLK_M
#      define KEY_N         SDLK_N
#      define KEY_O         SDLK_O
#      define KEY_P         SDLK_P
#      define KEY_Q         SDLK_Q
#      define KEY_R         SDLK_R
#      define KEY_S         SDLK_S
#      define KEY_T         SDLK_T
#      define KEY_U         SDLK_U
#      define KEY_V         SDLK_V
#      define KEY_W         SDLK_W
#      define KEY_X         SDLK_X
#      define KEY_Y         SDLK_Y
#      define KEY_Z         SDLK_Z
#    elif defined( USE_RAW_SCANCODE )
#      error RAW_SCANCODES have not been defined yet.
#      define KEY_SHIFT        0xFF
#      define KEY_LEFT_SHIFT   50
 // maybe?
#      define KEY_RIGHT_SHIFT  62
#      define KEY_CTRL          0xFE
#      define KEY_CONTROL       0xFE
#      define KEY_LEFT_CONTROL  37
#      define KEY_RIGHT_CONTROL 109
 // can't get usually under windows?(keyhook!)
#      define KEY_ALT           0xFD
#      define KEY_LEFT_ALT      64
#      define KEY_RIGHT_ALT     113
#      define KEY_CAPS_LOCK     66
#      define KEY_NUM_LOCK      77
 // unsure about this
#      define KEY_SCROLL_LOCK   78
#      define KEY_ESC           9
#      define KEY_ESCAPE        9
#      define KEY_HOME          0xFC
#      define KEY_PAD_HOME      79
#      define KEY_PAD_7         79
#      define KEY_GREY_HOME     97
#      define KEY_UP            0xFB
#      define KEY_PAD_8         80
#      define KEY_PAD_UP        80
#      define KEY_GREY_UP       98
#      define KEY_PGUP          0xFA
#      define KEY_PAD_9         81
#      define KEY_PAD_PGUP      81
#      define KEY_GREY_PGUP     99
#      define KEY_LEFT          0xF9
#      define KEY_PAD_4         83
#      define KEY_PAD_LEFT      83
#      define KEY_GREY_LEFT     100
#      define KEY_CENTER        0xF8
#      define KEY_PAD_5         84
#      define KEY_PAD_CENTER    84
#      define KEY_GREY_CENTER   0
#      define KEY_RIGHT         0xF7
#      define KEY_PAD_6         85
#      define KEY_PAD_RIGHT     85
#      define KEY_GREY_RIGHT    102
#      define KEY_END           0xF6
#      define KEY_PAD_1         87
#      define KEY_PAD_END       87
#      define KEY_GREY_END      103
#      define KEY_DOWN          0xF5
#      define KEY_PAD_2         88
#      define KEY_PAD_DOWN      88
#      define KEY_GREY_DOWN     104
#      define KEY_PGDN          0xF4
#      define KEY_PAD_3         89
#      define KEY_PAD_PGDN      89
#      define KEY_GREY_PGDN     105
#      define KEY_INSERT        0xF3
#      define KEY_PAD_0         90
#      define KEY_PAD_INSERT    90
#      define KEY_GREY_INSERT   106
#      define KEY_DELETE        0xF2
#      define KEY_PAD_DOT       91
#      define KEY_PAD_DELETE    91
#      define KEY_GREY_DELETE   107
#      define KEY_PLUS          0xF1
#      define KEY_PAD_PLUS      86
#      define KEY_GREY_PLUS     0
#      define KEY_MINUS         0xF0
#      define KEY_PAD_MINUS     82
#      define KEY_GREY_MINUS    0
#      define KEY_MULT          0xEF
#      define KEY_PAD_MULT      63
#      define KEY_GREY_MULT     0
#      define KEY_DIV           0xEE
#      define KEY_PAD_DIV       112
#      define KEY_GREY_DIV      0
#      define KEY_ENTER         0xED
#      define KEY_PAD_ENTER     108
#      define KEY_NORMAL_ENTER  36
 // windows keys keys
#      define KEY_WINDOW_1      115
 // windows keys keys
#      define KEY_WINDOW_2      117
#      define KEY_TAB           23
#      define KEY_SLASH         61
#      define KEY_BACKSPACE     22
#      define KEY_SPACE         65
#      define KEY_COMMA         59
 // should be some sort of VK_ definitions....
#      define KEY_STOP          60
#      define KEY_PERIOD        KEY_STOP
#      define KEY_SEMICOLON     47
#      define KEY_QUOTE         48
#      define KEY_LEFT_BRACKET  34
#      define KEY_RIGHT_BRACKET 35
#      define KEY_BACKSLASH     51
#      define KEY_DASH          20
#      define KEY_EQUAL         21
#      define KEY_ACCENT        49
#      define KEY_1         10
#      define KEY_2         11
#      define KEY_3         12
#      define KEY_4         13
#      define KEY_5         14
#      define KEY_6         15
#      define KEY_7         16
#      define KEY_8         17
#      define KEY_9         18
#      define KEY_0         19
#      define KEY_F1        67
#      define KEY_F2        68
#      define KEY_F3        69
#      define KEY_F4        70
#      define KEY_F5        71
#      define KEY_F6        72
#      define KEY_F7        73
#      define KEY_F8        74
#      define KEY_F9        75
#      define KEY_F10       76
#      define KEY_F11       95
#      define KEY_F12       96
#      define KEY_A         38
#      define KEY_B         56
#      define KEY_C         54
#      define KEY_D         40
#      define KEY_E         26
#      define KEY_F         41
#      define KEY_G         42
#      define KEY_H         43
#      define KEY_I         31
#      define KEY_J         44
#      define KEY_K         45
#      define KEY_L         46
#      define KEY_M         58
#      define KEY_N         57
#      define KEY_O         32
#      define KEY_P         33
#      define KEY_Q         24
#      define KEY_R         27
#      define KEY_S         39
#      define KEY_T         28
#      define KEY_U         30
#      define KEY_V         55
#      define KEY_W         25
#      define KEY_X         53
#      define KEY_Y         29
#      define KEY_Z         52
#    endif
#  endif
#endif
#if defined( DEFINE_HARDWARE_SCANCODES )
#  ifndef KBD_HPP
#    define KBD_HPP
#    define KBD_INT            9
#    define KBD_EXTENDED_CODE     0xE0
#    define LOW_ASCII(asc)     (asc&0x7F)
#    define NUM_KEYS        256
#    ifdef WIN32
//#    define KEY_ESC       27
//#    define KEY_LEFT      37
//#    define KEY_CENTER    KB_CENTER
//#    define KEY_RIGHT     39
//#    define KEY_DOWN      40
//#    define KEY_GRAY_UP   38
//#    define KEY_GRAY_LEFT 37
//#    define KEY_GRAY_RIGHT   39
//#    define KEY_GRAY_DOWN    40
//#    define KEY_LEFT_SHIFT   16
//#    define KEY_RIGHT_SHIFT  16
//#    define KEY_GRAY_PGUP 33
//#    define KEY_GRAY_PGDN 34
//#    define KEY_GRAY_INS  45
//#    define KEY_GRAY_DEL  46
//#    define KEY_P         80
//#    define KEY_M         77
#    else
#      define KEY_ESC       0x01
#      define KEY_1         0x02
#      define KEY_2         0x03
#      define KEY_3         0x04
#      define KEY_4         0x05
#      define KEY_5         0x06
#      define KEY_6         0x07
#      define KEY_7         0x08
#      define KEY_8         0x09
#      define KEY_9         0x0A
#      define KEY_0         0x0B
#      define KEY_MINUS     0x0C
#      define KEY_PLUS         0x0D
#      define  KEY_BKSP        0x0E
#      define KEY_TAB       0x0F
#      define KEY_Q         0x10
#      define KEY_W         0x11
#      define KEY_E         0x12
#      define KEY_R         0x13
#      define KEY_T         0x14
#      define KEY_Y         0x15
#      define KEY_U         0x16
#      define KEY_I         0x17
#      define  KEY_O        0x18
#      define KEY_P         0x19
#      define KEY_BRACK_OPEN   0x1A
#      define KEY_BRACK_CLOSE  0x1B
#      define KEY_ENTER     0x1C
#      define KEY_LEFT_CTRL 0x1D
#      define KEY_A         0x1E
#      define KEY_S         0x1F
#      define KEY_D         0x20
#      define KEY_F         0x21
#      define KEY_X         0x2D
#      define KEY_C         0x2E
#      define KEY_V         0x2F
#      define KEY_B         0x30
#      define KEY_N         0x31
#      define KEY_M         0x32
#      define KEY_GRAY_SLASH   0x35
#      define KEY_RIGHT_SHIFT  0x36
#      define KEY_GRAY_STAR 0x37
#      define KEY_LEFT_ALT     0x38
#      define KEY_SPACE     0x39
#      define KEY_CAPS         0x3A
#      define KEY_F1        0x3B
#      define KEY_F2        0x3C
#      define KEY_F3        0x3D
#      define KEY_F4        0x3E
#      define KEY_F5        0x3F
#      define KEY_F6        0x40
#      define KEY_F7        0x41
#      define KEY_F8        0x42
#      define KEY_F9        0x43
#      define KEY_F10       0x44
#      define KEY_UP        0x48
#      define KEY_LEFT      0x4B
#      define KEY_CENTER    0x4C
#      define KEY_RIGHT     0x4D
#      define KEY_DOWN      0x50
#      define KEY_DEL       0x53
#      define KEY_F11       0x57
#      define KEY_F12       0x58
#      define KEY_RIGHT_CTRL   BIT_7+0x1D
#      define KEY_RIGHT_ALT BIT_7+0x38
#      define KEY_GRAY_UP      BIT_7+0x48
#      define KEY_GRAY_PGUP BIT_7+0x49
#      define KEY_GRAY_MINUS   BIT_7+0x4A
#      define KEY_GRAY_LEFT BIT_7+0x4B
#      define KEY_GRAY_RIGHT   BIT_7+0x4D
#      define KEY_GRAY_PLUS BIT_7+0x4E
#      define KEY_GRAY_END     BIT_7+0x4F
#      define KEY_GRAY_DOWN BIT_7+0x50
#      define KEY_GRAY_PGDN BIT_7+0x51
#      define KEY_GRAY_INS     BIT_7+0x52
#      define KEY_GRAY_DEL     BIT_7+0x53
#    endif
#  endif
#endif
#endif
// $Log: keybrd.h,v $
// Revision 1.16  2004/08/11 11:41:06  d3x0r
// Begin seperation of key and render
//
// Revision 1.15  2004/06/01 21:53:43  d3x0r
// Fix PUBLIC dfeinitions from Windoze-centric to system nonspecified
//
// Revision 1.14  2004/04/27 04:58:16  d3x0r
// Forgot to macro a function..
//
// Revision 1.13  2004/04/27 03:06:16  d3x0r
// Define F1-F10
//
// Revision 1.12  2004/03/05 23:33:21  d3x0r
// Missing keydefs - may be wrong.
//
// Revision 1.11  2003/03/25 08:38:11  panther
// Add logging
//
#ifndef __NO_INTERFACES__
   // for interface, can omit if no interfaces
#endif
#ifndef __NO_MSGSVR__
  // for interface across the message service
#ifndef MESSAGE_SERVICE_PROTOCOL
#define MESSAGE_SERVICE_PROTOCOL
#ifdef __cplusplus
using namespace sack;
#endif
#ifdef __cplusplus
#define _MSG_NAMESPACE  namespace msg {
#define _PROTOCOL_NAMESPACE namespace protocol {
#define MSGPROTOCOL_NAMESPACE namespace sack { _MSG_NAMESPACE _PROTOCOL_NAMESPACE
#define MSGPROTOCOL_NAMESPACE_END }} }
#else
#define _MSG_NAMESPACE
#define _PROTOCOL_NAMESPACE
#define MSGPROTOCOL_NAMESPACE
#define MSGPROTOCOL_NAMESPACE_END
#endif
SACK_NAMESPACE
	/* This namespace contains an implmentation of inter process
	   communications using a set of message queues which result
	   from 'msgget' 'msgsnd' and 'msgrcv'. This are services
	   available under a linux kernel. Reimplemented a version to
	   service for windows. This is really a client/service
	   registration and message routing system, it is not the
	   message queue itself. See <link sack::containers::message, message>
	   for the queue implementation (again, under linux, does not
	   use this custom queue).
	   See Also
	   RegisterService
	   LoadService                                                         */
	_MSG_NAMESPACE
/* Defines structures and methods for receiving and sending
	   messages. Also defines some utility macros for referencing
		message ID from a user interface structure.                */
	_PROTOCOL_NAMESPACE
#define MSGQ_ID_BASE "Srvr"
// this is a fun thing, in order to use it,
// undefine MyInterface, and define your own to your
// library's interface structure name (the tag of the structure)
#define MSG_ID(method)  BASE_MESSAGE_ID,( ( offsetof( struct MyInterface, _##method ) / sizeof( void(*)(void) ) ) +  MSG_EventUser )
#define MSG_OFFSET(method)  ( ( offsetof( struct MyInterface, _##method ) / sizeof( void(*)(void) ) ) + MSG_EventUser )
#define INTERFACE_METHOD(type,name) type (CPROC*_##name)
// this is the techincal type of SYSV IPC MSGQueues
#define MSGIDTYPE long
#ifdef __64__
#  ifdef __LINUX__
#    define _MsgID_f  _64fs
#  else
#    define _MsgID_f  _32fs
#  endif
#else
#  define _MsgID_f  _32fs
#endif
// this will determine the length of parameter list
// based on the first and last parameters.
#define ParamLength( first, last ) ( ((uintptr_t)((&(last))+1)) - ((uintptr_t)(&(first))) )
#ifdef _MSC_VER
#pragma pack (push, 1)
#endif
typedef PREFIX_PACKED struct buffer_len_tag {
	CPOINTER buffer;
	size_t len;
} PACKED BUFFER_LENGTH_PAIR;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
// Dispach Pending - particularly display mouse event messages
//                   needed to be accumulated before being dispatched
//                   this event is generated when no more messages
//                   have been received.
#define MSG_EventDispatchPending   0
#define MSG_DispatchPending   MSG_EventDispatchPending
// these are event message definitions.
// server events come through their function table, clients
// register an event handler... these are low numbered since
// they are guaranteed from the client/server respectively.
// Mate ended - for the client, this means that the server
//              has become defunct.  For the server, this
//              means that a client is no longer present.
//              also issued when a client volentarily leaves
//              which in effect is the same as being discovered gone.
//    param[0] = Process ID of client disconnecting
//  result_length = INVALID_INDEX - NO RESULT DATA, PLEASE!
#define MSG_MateEnded         MSG_ServiceUnload
#define MSG_ServiceUnload     0
//#define MSG_ServiceClose    MSG_ServiceUnload
//#define MSG_ServiceUnload        MSG_MateEnded
// finally - needed to define a way for the service
// to actually know when a client connects... so that
// it may validate commands as being froma good source.
// also, a multiple service server may want this to know which
// service is being loaded.
//     params + 0 = text string of the service to load
//  on return result[1] is the number of messages this routine
//  expects.
//     result[0] is the number of events this service may generate
#define MSG_MateStarted      1
#define MSG_ServiceLoad      MSG_MateStarted
// Service is about to be unloaded - here's a final chance to
// cleanup before being yanked from existance.
// Last reference to the service is now gone, going to do the unload.
#define MSG_UndefinedMessage2      2
// no defined mesasage fo this
#define MSG_UndefinedMessage3       3
// Other messages may be filled in here...
// skip a couple messages so we don't have to recompile everything
// very soon...
#define MSG_EventUser       MSG_UserServiceMessages
#define MSG_UserServiceMessages 16
// skip a couple messages so we don't have to recompile everything
// very soon...
#define MSG_EventInternal       MSG_InternalServiceMessages
#define MSG_InternalServiceMessages 4
enum server_event_messages {
	// these messages are sent to client's event channel
	// within the space of core service requests (0-256?)
	// it's on top of client event user - cause the library
	// may also receive client_disconnect/connect messages
   //
	MSG_SERVICE_DATA = MSG_EventInternal
 // end of list - zero or more MSG_SERVICE_DATA mesasges will preceed this.
      , MSG_SERVICE_NOMORE
	, MSG_SERVICE_MAX_ID
};
enum server_failure_messages {
	CLIENT_UNKNOWN
									  , MESSAGE_UNKNOWN
 // sending server(sourced) messages to server
									  , MESSAGE_INVALID
 // could not find a service for the message.
									  , SERVICE_UNKNOWN
									  , UNABLE_TO_LOAD
};
enum service_messages {
 // no message ID 0 ever.
	INVALID_MESSAGE  = 0
 // server responce to clients - failure
							 , SERVER_FAILURE   = 0x80000000
							 // failure may result for the above reasons.
 // server responce to clients - success
							 , SERVER_SUCCESS   = 0x40000000
 // server needs more time to complete...
							 , SERVER_NEED_TIME = 0x20000000
 // server had no method to process the message
							 , SERVER_UNHANDLED = 0x10000000
 // client requests a service (load by name)
							 , CLIENT_LOAD_SERVICE = 1
 // client no longer needs a service (unload msgbase)
							 , CLIENT_UNLOAD_SERVICE
       // new client wants to connect
							 , CLIENT_CONNECT
    // client disconnects (no responce)
							 , CLIENT_DISCONNECT
             // server/client message to other requesting status
							 , RU_ALIVE
             // server/client message to other responding status
							 , IM_ALIVE
 // client register service (name, serivces, callback table.)
							 , CLIENT_REGISTER_SERVICE
 // client requests a list of services (optional param partial filter?)
                      , CLIENT_LIST_SERVICES
   // Service needs more time, and passes back a millisecond delay-reset
                      , IM_TARDY
};
#define LOWEST_BASE_MESSAGE 0x100
typedef struct ServiceRoute_tag SERVICE_ROUTE;
typedef struct ServiceRoute_tag *PSERVICE_ROUTE;
typedef struct ServiceEndPoint_tag SERVICE_ENDPOINT, *PSERVICE_ENDPOINT;
// this is part of the message structure
//
// this structure is avaialble at ((PSERVICE_ROUTE)(((uint32_t*)params)-1)[-1])
// (to explain that, the first uint32_t back is the MsgID... to get JUST the route tag
//  have to go back one Dword then back a service_route struct...
#ifdef _MSC_VER
#pragma pack (push, 1)
#endif
PREFIX_PACKED struct ServiceEndPoint_tag
{
   // remote process ID
	MSGIDTYPE process_id;
   // service (either served or connected as client) remote id
	MSGIDTYPE service_id;
}PACKED;
PREFIX_PACKED struct ServiceRoute_tag
{
   SERVICE_ENDPOINT dest;
	//MSGIDTYPE process_id;   // remote process ID
   //MSGIDTYPE service_id;   // service (either served or connected as client) remote id
   SERVICE_ENDPOINT source;
   //uint32_t source_process_id; // need this defined here anyway; so this can be used in receivers
	//uint32_t source_service_id;  // the service this is connected to, or is a connection for local ID
}PACKED;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
#define GetServiceRoute(data)   ((PSERVICE_ROUTE)(((uint32_t*)data)-1)-1)
// server functions will return TRUE if no failure
// server functions will return FALSE on failure
// FAILURE or SUCCESS will be returned to the client,
//   along with any result data set.
// native mode (unspecified... one would assume
// stack passing, but the world is bizarre and these are
// probably passed by registers.
typedef int (CPROC *server_message_handler)( PSERVICE_ROUTE SourceRouteID, uint32_t MsgID
														 , uint32_t *params, size_t param_length
														 , uint32_t *result, size_t *result_length );
typedef int (CPROC *server_message_handler_ex)( uintptr_t psv
															 , PSERVICE_ROUTE SourceRouteID, uint32_t MsgID
															 , uint32_t *params, size_t param_length
															 , uint32_t *result, size_t *result_length );
// params[-1] == Source Process ID
// params[-2] == Source Route ID
typedef int (CPROC *server_function)( PSERVICE_ROUTE route, uint32_t *params, size_t param_length
										 , uint32_t *result, size_t *result_length );
typedef struct server_function_entry_tag{
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
	CTEXTSTR name;
#endif
	server_function function;
} SERVER_FUNCTION;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
#define ServerFunctionEntry(name) { #name, name }
#else
#define ServerFunctionEntry(name) { name }
#endif
typedef SERVER_FUNCTION *server_function_table;
// MsgID will be < MSG_EventUser if it's a system message...
// MsgID will be service msgBase + Remote ID...
//    so the remote needs to specify a unique base... so ...
//    entries must still be used...
typedef int (CPROC*EventHandlerFunction)( MSGIDTYPE MsgID, uint32_t*params, size_t paramlen);
typedef int (CPROC*EventHandlerFunctionEx)( PSERVICE_ROUTE SourceID, MSGIDTYPE MsgID, uint32_t*params, size_t paramlen);
typedef int (CPROC*EventHandlerFunctionExx)( uintptr_t psv, PSERVICE_ROUTE SourceID, MSGIDTYPE MsgID
														 , uint32_t*params, size_t paramlen);
// result of EventHandlerFunction shall be one fo the following values...
//   EVENT_HANDLED
// 0 - no futher action required
//   EVENT_WAIT_DISPATCH
// 1 - when no further events are available, please send event_dispatched.
//     this Event was handled by an internal queuing for later processing.
enum EventResult {
	EVENT_HANDLED = 0,
	EVENT_WAIT_DISPATCH = 1
};
//------------------- Begin Server Message Structs ----------------
#ifdef _MSC_VER
#pragma pack (push, 1)
#endif
typedef struct MsgSvr_RegisterRequest_msg MsgSvr_RegisterRequest;
PREFIX_PACKED struct MsgSvr_RegisterRequest_msg
{
	MSGIDTYPE RouteID;
  // service_id...
   MSGIDTYPE ClientID;
}PACKED;
typedef struct MsgSrv_ReplyServiceLoad_msg MsgSrv_ReplyServiceLoad;
PREFIX_PACKED struct MsgSrv_ReplyServiceLoad_msg
{
	MSGIDTYPE ServiceID;
 // if this is a local service, it's dispatched this way?
	THREAD_ID thread;
}PACKED;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
MSGPROTOCOL_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::msg::protocol;
#endif
#endif
#endif
#ifndef SECOND_RENDER_LEVEL
#define SECOND_RENDER_LEVEL
#define PASTE(sym,name) name
#else
#define PASTE2(sym,name) sym##name
#define PASTE(sym,name) PASTE2(sym,name)
#endif
#ifdef USE_API_ALIAS_PREFIX
#  define RVER(n)   IMGVER_(USE_API_ALIAS_PREFIX,n)
#else
#  define RVER(n)   n
#endif
#        ifdef RENDER_LIBRARY_SOURCE
#           define RENDER_PROC(type,name) EXPORT_METHOD type CPROC PASTE(SECOND_RENDER_LEVEL,RVER(name))
#        else
#           define RENDER_PROC(type,name) IMPORT_METHOD type CPROC PASTE(SECOND_RENDER_LEVEL,RVER(name))
#        endif
SACK_NAMESPACE
/* <copy render.h>
   \ \             */
BASE_IMAGE_NAMESPACE
/* PRENDERER is the primary object this namespace deals with.
   See Also
   <link render.h>                                            */
_RENDER_NAMESPACE
/* Application layer abstract structure to handle displays. This
 is the type returned by OpenDisplay.                          */
typedef struct HVIDEO_tag *PRENDERER;
typedef struct key_function  KEY_FUNCTION;
typedef struct key_function *PKEY_FUNCTION;
// disable this functionality, it was never fully implemented, and is a lot to document.
#if ACTIVE_MESSAGE_IMPLEMENTED
// Message IDs 0-99 are reserved for
// very core level messages.
// Message IDs 100-999 are for general purpose window input/output
// Message ID 1000+ Usable by applications to transport messages via
//                  the image's default message loop.
enum active_msg_id {
    // Message ID 0 - contains a active image to respond to
   ACTIVE_MSG_PING
    // Message ID 0 - contains a active image to respond to
   , ACTIVE_MSG_PONG
   , ACTIVE_MSG_MOUSE = 100
   , ACTIVE_MSG_GAIN_FOCUS
   , ACTIVE_MSG_LOSE_FOCUS
   , ACTIVE_MSG_DRAG
   , ACTIVE_MSG_KEY
   , ACTIVE_MSG_DRAW
   , ACTIVE_MSG_CREATE
   , ACTIVE_MSG_DESTROY
   , ACTIVE_MSG_USER = 1000
};
typedef struct {
   enum active_msg_id ID;
 // the size of the cargo potion of the message. (mostly data.raw)
   uint32_t  size;
   union {
  //--------------------
      struct {
         PRENDERER respondto;
      } ping;
  //--------------------
      struct {
         int x, y, b;
      } mouse;
  //--------------------
      struct {
         PRENDERER lose;
      } gain_focus;
  //--------------------
      struct {
         PRENDERER gain;
      } lose_focus;
  //--------------------
      struct {
         uint8_t no_informaiton;
      } draw;
  //--------------------
      struct {
         uint8_t no_informaiton;
      } close;
  //--------------------
      struct {
         uint8_t no_informaiton;
      } create;
  //--------------------
      struct {
         uint8_t no_informaiton;
      } destroy;
  //--------------------
      struct {
         uint32_t key;
      } key;
  //--------------------
      uint8_t raw[1];
   } data;
} ACTIVEMESSAGE, *PACTIVEMESSAGE;
#endif
// Event Message ID's CANNOT be 0
// Message Event ID (base+0) is when the
// server teriminates, and ALL client resources
// are lost.
// Message Event ID (base+1) is when the
// final message has been received, and any
// pending events collected should be dispatched.
#ifndef __NO_MSGSVR__
enum {
   /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_CloseMethod = MSG_EventUser,
  /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_RedrawMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_MouseMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_LoseFocusMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_KeyMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_GeneralMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_RedrawFractureMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_ThreadEventPost
};
#endif
#ifdef __WATCOMC__
#if ( __WATCOMC__ < 1291 )
#define NO_TOUCH
#endif
#endif
#ifndef WIN32
#define NO_TOUCH
#endif
#if defined( __LINUX__ )
#define NO_TOUCH
#endif
#if defined( __ANDROID__ )
// definately IS touch
#undef NO_TOUCH
#define MINGW_SUX
#endif
// static void OnBeginShutdown( "Unique Name" )( void ) { /* run shutdown code */ }
#define OnBeginShutdown(name)	 DefineRegistryMethod("SACK",BeginShutdown,"System","Begin Shutdown",name "_begin_shutdown",void,(void),__LINE__)
/* function signature for the close callback  which can be specified to handle events to close the display.  see SetCloseHandler. */
typedef void (CPROC*CloseCallback)( uintptr_t psvUser );
/* function signature to define hide/restore callback, it just gets the user data of the callback... */
typedef void (CPROC*HideAndRestoreCallback)( uintptr_t psvUser );
/* function signature for the redraw callback  which can be specified to handle events to redraw the display.  see SetRedrawHandler. */
typedef void (CPROC*RedrawCallback)( uintptr_t psvUser, PRENDERER self );
/* function signature for the mouse callback  which can be specified to handle events from mouse motion on the display.  see SetMouseHandler.
  would be 'wise' to retun 0 if ignored, 1 if observed (perhaps not used), but NOT ignored.*/
typedef uintptr_t  (CPROC*MouseCallback)( uintptr_t psvUser, int32_t x, int32_t y, uint32_t b );
typedef struct input_point
{
   //
	RCOORD x, y;
	struct {
  // set on first down, clear on subsequent events
		BIT_FIELD new_event : 1;
 // set on first up, clear on first down,
		BIT_FIELD end_event : 1;
	} flags;
} *PINPUT_POINT;
#ifndef NO_TOUCH
#if defined( MINGW_SUX )
/*
 * Touch input mask values (TOUCHINPUT.dwMask)
 */
  // the dwTime field contains a system generated value
#define TOUCHINPUTMASKF_TIMEFROMSYSTEM  0x0001
  // the dwExtraInfo field is valid
#define TOUCHINPUTMASKF_EXTRAINFO       0x0002
  // the cxContact and cyContact fields are valid
#define TOUCHINPUTMASKF_CONTACTAREA     0x0004
#ifndef __ANDROID__
typedef HANDLE HTOUCHINPUT;
#endif
#define WM_TOUCH 0x0240
#define TWF_FINETOUCH 0x00000001
#define TWF_WANTPALM 0x00000002
#endif
 // added to flags as touches are used.  Controls may use some of the touches but not all.
#define TOUCHEVENTF_USED 0x8000
/* function signature for the touch callback  which can be specified to handle events from touching the display.  see SetMouseHandler.
  would be 'wise' to retun 0 if ignored, 1 if observed (perhaps not used), but NOT ignored.  Return 1 if some of the touches are used.
  This will trigger a check to see if there are unused touches to continue sending... oh but on renderer there's only one callback, more
  important as a note of the control touch event handerer.
  */
typedef int  (CPROC*TouchCallback)( uintptr_t psvUser, PINPUT_POINT pTouches, int nTouches );
#endif
/* function signature for the close callback  which can be specified to handle events to redraw the display.  see SetLoseFocusHandler. */
typedef void (CPROC*LoseFocusCallback)( uintptr_t dwUser, PRENDERER pGain );
// without a keyproc, you will still get key notification in the mousecallback
// if KeyProc returns 0 or is NULL, then bound keys are checked... otherwise
// priority is given to controls with focus that handle keys.
typedef int (CPROC*KeyProc)( uintptr_t dwUser, uint32_t keycode );
// without any other proc, you will get a general callback message.
#if ACTIVE_MESSAGE_IMPLEMENTED
typedef void (CPROC*GeneralCallback)( uintptr_t psvUser
                                     , PRENDERER image
												, PACTIVEMESSAGE msg );
#endif
typedef void (CPROC*RenderReadCallback)(uintptr_t psvUser, PRENDERER pRenderer, TEXTSTR buffer, INDEX len );
// called before redraw callback to update the background on the scene...
typedef void (CPROC*_3DUpdateCallback)( uintptr_t psvUser );
// callback type for clipborad event reception.
typedef void (CPROC*ClipboardCallback)(uintptr_t psvUser);
//----------------------------------------------------------
//   Mouse Button definitions
//----------------------------------------------------------
// the prefix of these may either be interpreted as MAKE - as in
// a make/break state of a switch.  Or may be interpreted as
// MouseKey.... such as KB_ once upon a time stood for KeyBoard,
// and not Keebler as some may have suspected.
enum ButtonFlags {
#ifndef MK_LBUTTON
 // left mouse button  MouseKey_ ?
	MK_LBUTTON = 0x01,
#endif
#ifndef MK_MBUTTON
  // right mouse button MouseKey_ ?
	MK_RBUTTON = 0x02,
#endif
#ifndef MK_RBUTTON
  // middle mouse button MouseKey_ ?
	MK_MBUTTON = 0x10,
#endif
#ifndef MK_CONTROL
  // the control key on the keyboard
  MK_CONTROL = 0x08,
#endif
#ifndef MK_ALT
   // the alt key on the keyboard
  MK_ALT = 0x20,
#endif
#ifndef MK_SHIFT
   // the shift key on the keyboard
  MK_SHIFT = 0x40,
#endif
  // scroll wheel click down
  MK_SCROLL_DOWN  = 0x100,
  // scroll wheel click up
  MK_SCROLL_UP    = 0x200,
  // scroll wheel click left
  MK_SCROLL_LEFT  = 0x400,
  // scroll wheel click right
  MK_SCROLL_RIGHT = 0x800,
#ifndef MK_NO_BUTTON
// used to indicate that there is
// no known button information available.  The mouse
// event which triggered this was beyond the realm of
// this mouse handler, but it is entitled to know that
// it now knows nothing.
  MK_NO_BUTTON = 0xFFFFFFFF,
#endif
// this bit will NEVER NEVER NEVER be set
// for ANY reason whatsoever. ( okay except when it's in MK_NO_BUTTON )
  MK_INVALIDBUTTON = 0x80000000,
// One or more other buttons were pressed.  These
// buttons are available by querying the keyboard state.
 // any other button (keyboard)
  MK_OBUTTON = 0x80,
 // any other button (keyboard) went up
  MK_OBUTTON_UP = 0x1000
};
// mask to test to see if some button (physical mouse, not logical)
// is currently pressed...
#define MK_SOMEBUTTON       (MK_LBUTTON|MK_RBUTTON|MK_MBUTTON)
// test to see if any button is clicked */
#define MAKE_SOMEBUTTONS(b)     ((b)&(MK_SOMEBUTTON))
// test to see if a specific button is clicked
#define BUTTON_STILL_DOWN(b,button)     ((b)&(button))
// test a button variable to see if no buttons are currently pressed
// NOBUTTON, NOBUTTONS may be confusing, consider renaming these....
#define MAKE_NOBUTTONS(b)     ( !((b) & MK_SOMEBUTTON ) )
// break of some button
#define BREAK_NEWBUTTON(b,_b) ((((b)^(_b))&(_b))&MK_SOMEBUTTON)
// break a specific button (the last up of the button)
#define BREAK_A_BUTTON(b,_b,button) ((((b)^(_b))&(_b))&(button))
// make of some button (the first down of a button)
#define MAKE_NEWBUTTON(b,_b) ((((b)^(_b))&(b))&MK_SOMEBUTTON)
// make a specific button (the first down of the button)
#define MAKE_A_BUTTON(b,_b,button) ((((b)^(_b))&(b))&(button))
// test current b vs prior _b to see if the  last button pressed is
// now not pressed...
#define BREAK_LASTBUTTON(b,_b)  ( BREAK_NEWBUTTON(b,_b) && MAKE_NOBUTTONS(b) )
// test current b vs prior _b to see if there is now some button pressed
// when previously there were no buttons pressed...
#define MAKE_FIRSTBUTTON(b,_b) ( MAKE_NEWBUTTON(b,_b) && MAKE_NOBUTTONS(_b) )
// these button states may reflect the current
// control, alt, shift key states.  There may be further
// definitions (meta?) And as of the writing of this comment
// these states may not be counted on, if you care about these
// please do validate that the code gives them to you all the way
// from the initial mouse message through all layers to the final
// application handler.
//----------------------------------------------------------
enum DisplayAttributes {
   /* when used by the Display Lib manager, this describes how to manage the subsurface */
  PANEL_ATTRIBUTE_ALPHA    = 0x10000,
   /* when used by the Display Lib manager, this describes how to manage the subsurface */
  PANEL_ATTRIBUTE_HOLEY    = 0x20000,
// when used by the Display Lib manager, this describes how to manage the subsurface
// focus on this window excludes any of it's parent/sibling panels
// from being able to focus.
  PANEL_ATTRIBUTE_EXCLUSIVE = 0x40000,
// when used by the Display Lib manager, this describes how to manage the subsurface
// child attribute affects the child is contained within this parent
  PANEL_ATTRIBUTE_INTERNAL  = 0x88000,
    // open the window as layered - allowing full transparency.
  DISPLAY_ATTRIBUTE_LAYERED = 0x0100,
    // window will not be in alt-tab list
  DISPLAY_ATTRIBUTE_CHILD = 0x0200,
    // set to WS_EX_TRANSPARENT - all mouse is passed, regardless of alpha/shape
  DISPLAY_ATTRIBUTE_NO_MOUSE = 0x0400,
    // when created, the display does not attempt to set itself into focus, otherwise we try to focus self.
  DISPLAY_ATTRIBUTE_NO_AUTO_FOCUS = 0x0800,
  // when created, set topmost as soon as possible
  DISPLAY_ATTRIBUTE_TOPMOST = 0x1000,
};
 // does not HAVE to be called but may
    RENDER_PROC( int , InitDisplay) (void);
	 // this generates a mouse event though the mouse system directly
    // there is no queuing, and the mouse is completed before returning.
    RENDER_PROC( void, GenerateMouseRaw)( int32_t x, int32_t y, uint32_t b );
	 /* Create mouse events to self?
	    Parameters
	    x :  x of the mouse
	    y :  y of the mouse
	    b :  buttons of the mouse    */
	 RENDER_PROC( void, GenerateMouseDeltaRaw )( int32_t x, int32_t y, uint32_t b );
    /* Sets the title of the application window. Once upon a time,
       applications only were able to make a SINGLE window. Internally,
       all windows are mounted against a hidden application window,
       and this appilcation window gets the title.
       Parameters
       title :  Title for the application                               */
    RENDER_PROC( void , SetApplicationTitle) (const TEXTCHAR *title );
    /* Sets the title of the window (shows up in windows when
       alt-tabbing). Also shows up on the task tray icon (if there
       is one)
       Parameters
       render :  display to set the title of
       title :   new text for the title.                           */
    RENDER_PROC( void , SetRendererTitle) ( PRENDERER render, const TEXTCHAR *title );
    /* Sets the icon to show for the application's window.
       Parameters
       Icon :  this really has to be an HICON I think... it's for
               setting the icon on Windows' windows.              */
    RENDER_PROC( void , SetApplicationIcon)  (Image Icon);
    /* Gets the size of the default desktop screen.
       Parameters
       width :   pointer to a 32 value for the display's width.
       height :  pointer to a 32 value for the display's height.
       Example
       <code lang="c++">
       uint32_t w, h;
       GetDisplaySize( &amp;w, &amp;h );
       </code>
       See Also
       <link sack::image::render::GetDisplaySizeEx@int@int32_t *@int32_t *@uint32_t *@uint32_t *, GetDisplaySizeEx> */
    RENDER_PROC( void , GetDisplaySize)      ( uint32_t *width, uint32_t *height );
	 /* \ \
	    Parameters
	    nDisplay :  display to get the coordinates of. 0 is the
	                default display from GetDesktopWindow(). 1\-n are
	                displays for multiple display systems, 1,2,3,4
	                etc..
	    x :         left screen coordinate of this display
	    y :         top screen coordinate of this display
	    width :     how wide this display is
	    height :    how tall this display is
	    Example
	    <code lang="c#">
	    int32_t x, y;
	    uint32_t w, h;
	    GetDisplaySizeEx( 1, &amp;x, &amp;y, &amp;w, &amp;h );
	    </code>                                                       */
	 RENDER_PROC (void, GetDisplaySizeEx) ( int nDisplay
													  , int32_t *x, int32_t *y
													  , uint32_t *width, uint32_t *height);
    /* Sets the first displayed physical window to a certain size. This
       should actually adjust the screen size. Like GetDisplaySize
       \returns the size of the actual display, this should set the
       size of the actual display.
       Parameters
       width :   new width of the screen
       height :  new height of the screen.                              */
    RENDER_PROC( void , SetDisplaySize)      ( uint32_t width, uint32_t height );
#ifdef WIN32
    /* Enable logging when updates happen to the real display.
       Parameters
       bEnable :  TRUE to enable, FALSE to disable.            */
    RENDER_PROC (void, EnableLoggingOutput)( LOGICAL bEnable );
	 /* A method to promote any arbitrary HWND to a PRENDERER. This
	    can be used to put SACK display surfaces in .NET
	    applications.
	    Parameters
	    hWnd :  HWND to make into a renderer.
	    Returns
	    PRENDERER new renderer that uses HWND to update to.         */
	 RENDER_PROC (PRENDERER, MakeDisplayFrom) (HWND hWnd);
#endif
    /* This opens a display for output. It is opened hidden, so the
       application might draw to its surface before it is shown.
       This is not the most capable creation routine, but it is the
       most commonly aliased.
       Parameters
       attributes :  one or more <link sack::image::render::DisplayAttributes, DisplayAttributes>
                     or'ed togeteher.
       width :       width of the display
       height :      height of the display
       x :           x position of left the display
       y :           y position of the top of the display                                         */
    RENDER_PROC( PRENDERER, OpenDisplaySizedAt)     ( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y );
    /* This opens a display for output. It is opened hidden, so the
       application might draw to its surface before it is shown.
       This is not the most capable creation routine, but it is the
       most commonly aliased.
       Parameters
       attributes :  one or more <link sack::image::render::DisplayAttributes, DisplayAttributes>
                     or'ed togeteher.
       width :       width of the display
       height :      height of the display
       x :           x position of left the display
       y :           y position of the top of the display
       above :       display to put this one above.                                               */
    RENDER_PROC( PRENDERER, OpenDisplayAboveSizedAt)( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y, PRENDERER above );
    /* This opens a display for output. It is opened hidden, so the
       application might draw to its surface before it is shown.
       This is not the most capable creation routine, but it is the
       most commonly aliased.
       Parameters
       attributes :  one or more <link sack::image::render::DisplayAttributes, DisplayAttributes>
                     or'ed togeteher.
       width :       width of the display
       height :      height of the display
       x :           x position of left the display
       y :           y position of the top of the display
       above :       display to put this one above.
       below :       display to put this one under. (for building
                     behind a cover window)                                                       */
    RENDER_PROC( PRENDERER, OpenDisplayAboveUnderSizedAt)( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y, PRENDERER above, PRENDERER under );
	 /* Sets the alpha level of the overall display window.
	    Parameters
	    hVideo :  display to set the overall fade level on
	    level :   the level of fade from 0 (transparent) to 255
	              (opaque)
	    Example
	    <code lang="c++">
	    PRENDERER render = OpenDisplay( 0 );
	    int i;
	    UpdateDisplay( render );
	    </code>
	    <code>
	    // the window will slowly fade out
	    for( i = 255; i \> 0; i-- )
	    </code>
	    <code lang="c++">
	        SetDisplayFade( render, i );
	    CloseDisplay( render );  // Hiding the display works too, if it is to be reused.
	    </code>                                                                          */
	 RENDER_PROC( void, SetDisplayFade )( PRENDERER hVideo, int level );
    /* closes a display, releasing all resources assigned to it.
       Parameters
       hDisplay :  Render display to close.                      */
    RENDER_PROC( void         , CloseDisplay) ( PRENDERER );
    /* Updates just a portion of a display window. Minimizing the
       size required for screen output greatly increases efficiency.
       Also on vista+, this will update just a portion of a
       transparent display.
       Parameters
       hVideo :  the display to update
       x :       the left coordinate of the region to update
       y :       the top coordinate of the region to update
       width :   the width of the region to update
       height :  the height of the region to update
       DBG_PASS information is used to track who is doing updates
       when update logging is enabled.                               */
    RENDER_PROC( void , UpdateDisplayPortionEx) ( PRENDERER, int32_t x, int32_t y, uint32_t width, uint32_t height DBG_PASS );
/* <combine sack::image::render::UpdateDisplayPortionEx@PRENDERER@int32_t@int32_t@uint32_t@uint32_t height>
   \ \                                                                                      */
#define UpdateDisplayPortion(r,x,y,w,h) UpdateDisplayPortionEx(r,x,y,w,h DBG_SRC )
	 /* Updates the entire surface of a display.
	    Parameters
	    display :  display to update
	    DBG_PASS information is passed for logging writing to
	    physical display.
	                                                          */
	 RENDER_PROC( void , UpdateDisplayEx)        ( PRENDERER DBG_PASS );
#define UpdateDisplay(r) UpdateDisplayEx(r DBG_SRC)
/* Gets the current location and size of a display.
       Parameters
       hVideo :  display to get the position of
       x :       pointer to a signed 32 bit value to get the left
                 edge of the display.
       y :       pointer to a signed 32 bit value to get the top edge
                 of the display.
       width :   pointer to a unsigned 32 bit value to get the width.
       height :  pointer to a unsigned 32 bit value to get the
                 height.                                              */
    RENDER_PROC( void, GetDisplayPosition)   ( PRENDERER, int32_t *x, int32_t *y, uint32_t *width, uint32_t *height );
    /* Moves a display to an absolute position.
       Parameters
       render :  the display to move
       x :       new X coordinate for the left of the display
       y :       new Y coordinate for the top of the display  */
    RENDER_PROC( void , MoveDisplay)          ( PRENDERER, int32_t x, int32_t y );
    /* Moves a display relative to its current position.
       Parameters
       render :  the display to move
       delx :    a signed amount to add to its X coordiante
       dely :    a signed amount ot add to its Y coordinate. ( bigger
                 values go down the screen )                          */
    RENDER_PROC( void , MoveDisplayRel)       ( PRENDERER, int32_t delx, int32_t dely );
    /* Sets the display's current size. If it is different than
       before, will invoke render's redraw callback.
       Parameters
       display :  the display to set the size of
       w :        new width of the display
       h :        new height of the display                     */
    RENDER_PROC( void , SizeDisplay)          ( PRENDERER, uint32_t w, uint32_t h );
    /* Sets the display's current size relative to what it currently
       is. If it is different than before, will invoke render's
       redraw callback.
       Parameters
       display :  the display to set the size of
       w :        signed value to add to current width
       h :        signed value to add to current height              */
    RENDER_PROC( void , SizeDisplayRel)       ( PRENDERER, int32_t delw, int32_t delh );
   /* Change the position and size of a display.
      Parameters
      hVideo :  display to move and size
      x :       new left coordinate of the display
      y :       new top coordinate of the display
      w :       new width of the display
      h :       new height of the display          */
   RENDER_PROC( void, MoveSizeDisplay )( PRENDERER hVideo
                                        , int32_t x, int32_t y
                                        , int32_t w, int32_t h );
   /* Moves and changes the display size relative to its current
      size. All parameters are relative to current.
      Parameters
      hVideo :  display to move and change the size of
      delx :    amount to modify the left coordinate by
      dely :    amount to modify the top coordinate by
      delw :    amount to change the width by
      delh :    amount to change the height by                   */
   RENDER_PROC( void, MoveSizeDisplayRel )( PRENDERER hVideo
                                        , int32_t delx, int32_t dely
                                        , int32_t delw, int32_t delh );
		/* Put the display above another display. This makes sure that
		   the displays are stacked at least in this order.
		   Parameters
		   this_display :  the display to put above another
		   that_display :  the display that will be on the bottom.     */
		RENDER_PROC( void , PutDisplayAbove)      ( PRENDERER this_display, PRENDERER that_display );
      /* put this in container
	   Parameters
	   hVideo :      Display to put into another display surface
	   hContainer :  The new parent window of the hVideo.
	   Example
	   <code lang="c#">
	   Render render = OpenDisplay( 0 );
	   Render parent = OpenDisplay( 0 );
	   PutDisplayIn( render, parent );
	   </code>                                                   */
	 RENDER_PROC (void, PutDisplayIn) (PRENDERER hVideo, PRENDERER hContainer);
    /* Gets the Image from the Render.
       Parameters
       renderer :  the display window to get the surface of.
       Returns
       Image that is the surface of the window to draw to.   */
    RENDER_PROC( Image , GetDisplayImage)     ( PRENDERER );
    /* Sets the close handler callback. Called when a window is
       closed externally.
       Parameters
       hVideo :     display to set the close handler for
       callback :   close method to call when the display is called
       user_data :  user data passed to close method when invoked.  */
    RENDER_PROC( void , SetCloseHandler)      ( PRENDERER, CloseCallback, uintptr_t );
    /* Specifies the mouse event handler for a display.
       Parameters
       hVideo :     display to set the mouse handler for
       callback :   the routine to call when a mouse event happens.
       user_data :  this value is passed to the callback routine when
                    it is called.                                     */
    RENDER_PROC( void , SetMouseHandler)      ( PRENDERER, MouseCallback, uintptr_t );
    /* Specifies the hide event handler for a display.
       Parameters
       hVideo :     display to set the hide handler for
       callback :   the routine to call when a hide event happens.
       user_data :  this value is passed to the callback routine when
                    it is called.                                     */
    RENDER_PROC( void , SetHideHandler)      ( PRENDERER, HideAndRestoreCallback, uintptr_t );
    /* Specifies the restore event handler for a display.
       Parameters
       hVideo :     display to set the restore handler for
       callback :   the routine to call when a restore event happens.
       user_data :  this value is passed to the callback routine when
                    it is called.                                     */
    RENDER_PROC( void , SetRestoreHandler)      ( PRENDERER, HideAndRestoreCallback, uintptr_t );
#ifndef NO_TOUCH
    /* Specifies the touch event handler for a display.
       Parameters
       hVideo :     display to set the touch handler for
       callback :   the routine to call when a touch event happens.
       user_data :  this value is passed to the callback routine when
                    it is called.                                     */
	   RENDER_PROC( void , SetTouchHandler)      ( PRENDERER, TouchCallback, uintptr_t );
#endif
	 /* Sets the function to call when a redraw event is required.
	    Parameters
	    hVideo :     display to set the handler for
	    callback :   function to call when a redraw is required (or
	                 requested).
	    user_data :  this value is passed to the redraw callback.
	    Example
	    See <link render.h>
	    See Also
	    <link sack::image::render::Redraw@PRENDERER, Redraw>        */
	 RENDER_PROC( void , SetRedrawHandler)     ( PRENDERER, RedrawCallback, uintptr_t );
	 // call this to call the callback registered. as appropriate.  Said callback
    // should never be directly called by application.
    RENDER_PROC( void, Redraw )( PRENDERER hVideo );
    /* Sets the keyboard handler callback for a display
       Parameters
       hVideo :     display to receive key events for.
       callback :   callback invoked when a key event happens.
       user_data :  user data passed to the callback when invoked.
       Remarks
       the keyboard handler may make use of the scan code itself for
       PKEYDEFINE structures. There are also a variety of methods
       for checking the 32 bit key value. The value passed to the
       keyboard handler contains most all of the information about
       the state of the keyboard and specific key.                   */
    RENDER_PROC( void , SetKeyboardHandler)   ( PRENDERER, KeyProc, uintptr_t );
    /* Sets a callback handler called when focus is gained or lost
       by the display.
       Parameters
       hVideo :     display to set the event on
       callback :   the user callback to call when focus is lost or
                    gained.
       user_data :  user data passed to the callback when invoked.
       Note
       When the LoseFocusCallback is called, the renderer is the one
       that is getting the focus. This may be you, may be NULL
       (everyone losing focus) or may be another PRENDERER in your
       application.                                                  */
    RENDER_PROC( void , SetLoseFocusHandler)  ( PRENDERER, LoseFocusCallback, uintptr_t );
    /* Undefined */
    RENDER_PROC( void, SetRenderReadCallback )( PRENDERER pRenderer, RenderReadCallback callback, uintptr_t psv );
#if ACTIVE_MESSAGE_IMPLEMENTED
    RENDER_PROC( void , SetDefaultHandler)    ( PRENDERER, GeneralCallback, uintptr_t );
#endif
    /* Receives the current global mouse state, and position in
       screen coordinates.
       Parameters
       x :  pointer to a signed 32 bit value for the mouse X position.
       y :  pointer to a signed 32 bit value for the mouse Y position.
       b :  current state of mouse buttons. See <link sack::image::render::ButtonFlags, ButtonFlags>. */
    RENDER_PROC( void , GetMouseState )        ( int32_t *x, int32_t *y, uint32_t *b );
    /* Gets the current mouse position in screen coordinates.
       Parameters
       x :  pointer to a signed 32 bit value for the mouse position
       y :  pointer to a signed 32 bit value for the mouse position
       Example
       <code lang="c++">
       int32_t x, y;
       GetMousePosition( &amp;x, &amp;y );
       </code>                                                      */
    RENDER_PROC( void , GetMousePosition)     ( int32_t *x, int32_t *y );
    /* Sets the mouse pointer at the specified display coordinates.
       Parameters
       hDisplay :  display to use to where to position the mouse. Will
                   fault if NULL is passed.
       x :         x relative to the display to set the mouse
       y :         y relative to the display to set the mouse          */
    RENDER_PROC( void , SetMousePosition)     ( PRENDERER, int32_t x, int32_t y );
    /* Test a display to see if it is focused.
       Parameters
       hVideo :  display to check to see if it has focus. (keyboard
                 \input)
       Returns
       TRUE if focused, else FALSE.                                 */
    RENDER_PROC( LOGICAL , HasFocus)          ( PRENDERER );
#if ACTIVE_MESSAGE_IMPLEMENTED
    RENDER_PROC( int, SendActiveMessage)     ( PRENDERER dest, PACTIVEMESSAGE msg );
    RENDER_PROC( PACTIVEMESSAGE , CreateActiveMessage) ( int ID, int size, ... );
#endif
    /* Translates a key's scancode into text. Handles things like
       capslock, shift...
       Parameters
       key :  KEY_ to translate
       Returns
       char that the key represents. (should implement a method to
       get back the UNICODE character).                            */
    RENDER_PROC( const TEXTCHAR *, GetKeyText)             ( int key );
    /* Simple check to see if a key is in a pressed state.
       Parameters
       display :  display to check the key state in
       key :      KEY_ symbol to check.                    */
    RENDER_PROC( uint32_t, IsKeyDown )              ( PRENDERER display, int key );
    /* \ \
       Parameters
       display :  display to test the key status in
       key :      KEY_ symbol to check if the key is pressed
       Returns
       TRUE if the key is down, else FALSE.                  */
    RENDER_PROC( uint32_t, KeyDown )                ( PRENDERER display, int key );
    /* Sometimes displays can be closed by external forces (the
       close button on most windows). This tests to see if a display
       is still valid, or if it has been closed externally.
       Returns
       TRUE if display is still okay. FALSE if the display is no
       longer able to be used.
       Parameters
       display :  the display to check the validity of.              */
    RENDER_PROC( LOGICAL, DisplayIsValid )     ( PRENDERER display );
    /* Assigns all mouse input to a window. This allows the window
       to process messages which are outside of itself normally.
       Parameters
       display :  which window wants to own the mouse
       own :      1 to own, 0 to release ownership.                */
    RENDER_PROC( void, OwnMouseEx )            ( PRENDERER display, uint32_t bOwn DBG_PASS );
    /* Proprietary routine for reading touch screen serial devices
       directly and performing self calibration. Should rely on
       system driver and it's calibration instead.                 */
    RENDER_PROC( int, BeginCalibration )       ( uint32_t points );
    /* Used when display is accessed via a remote message pipe, this
       allows all render operations to be flushed and processed.
       Parameters
       display :  display to flush                                   */
    RENDER_PROC( void, SyncRender )            ( PRENDERER display );
/* Makes a display topmost. There isn't a way to un-topmost a
   window.
   Parameters
   hVideo :  display to make topmost
   Note
   Windows maintains at least two distinct stacks of windows. Normal
   windows in the normal window stack, and a set of windows that
   are above all other windows (except other windows that are
   also topmost).                                                    */
RENDER_PROC( void, MakeTopmost )( PRENDERER hVideo );
/* This makes the display topmost, but more so, any window that
   gets put over it it will attempt put itself over it.
   Parameters
   hVideo :  display to make top top most.                      */
RENDER_PROC (void, MakeAbsoluteTopmost) (PRENDERER hVideo);
/* Tests a display to see if it is set as topmost.
   Parameters
   hVideo :  display to inquire if it's topmost.
   Returns
   TRUE if display is topmost, else FALSE.         */
RENDER_PROC( int, IsTopmost )( PRENDERER hVideo );
/* Hides a display. That is, the content no longer shows on the
   users display.
   Parameters
   hVideo :  the handle of the Render to hide.
   See Also
   <link sack::image::render::RestoreDisplay@PRENDERER, RestoreDisplay> */
RENDER_PROC( void, HideDisplay )( PRENDERER hVideo );
/* Puts a display back on the screen. This is used in
   conjunction with HideDisplay().
   Parameters
   hVideo :  display to restore                       */
RENDER_PROC( void, RestoreDisplay )( PRENDERER hVideo );
	RENDER_PROC( void, RestoreDisplayEx )( PRENDERER hVideo DBG_PASS );
#define RestoreDisplay(n) RestoreDisplayEx( n DBG_SRC )
/* A check to see if HideDisplay has been applied to the
   display.
   Returns
   TRUE if the display is hidden, otherwise FALSE.
   Parameters
   video :  the display to check if hidden               */
RENDER_PROC( LOGICAL, IsDisplayHidden )( PRENDERER video );
// set focus to display, no events are generated if display already
// has the focus.
RENDER_PROC( void, ForceDisplayFocus )( PRENDERER display );
// display set as topmost within it's group (normal/bottommost/topmost)
RENDER_PROC( void, ForceDisplayFront )( PRENDERER display );
// display is force back one layer... or forced to bottom?
// alt-n pushed the display to the back... alt-tab is different...
RENDER_PROC( void, ForceDisplayBack )( PRENDERER display );
/* Not implemented on windows native, is for getting back
   display information over message service abstraction.
   if a readcallback is enabled, then this will be no-wait, and
   one will expect to receive the read data in the callback.
   Otherwise this will return any data which is present already,
   also non wait. Returns length read, INVALID_INDEX if no data
   read.
   If there IS a read callback, return will be 1 if there was no
   previous read queued, and 0 if there was already a read
   pending there may be one and only one read queued (for now)
   In either case if the read could not be queued, it will be
   0..
   If READLINE is true - then the result of the read will be a
   completed line. if there is no line present, and no callback
   defined, this will return INVALID_INDEX characters... 0
   characters is a n only (in line mode) 0 will be returned for
   no characters in non line mode...
   it will not have the end of line terminator (as generated by
   a non-bound enter key) I keep thinking there must be some
   kinda block mode read one can do, but no, uhh no, there's no
   way to get the user to put in X characters exactly....?
   Parameters
   pRenderer :  display to read from
   buffer :     buffer to read into
   maxlen :     maximum length of buffer to read
   bReadLine :  ???                                              */
RENDER_PROC( uint32_t, ReadDisplayEx )( PRENDERER pRenderer, TEXTSTR buffer, uint32_t maxlen, LOGICAL bReadLine );
/* Unused. Incomplete. */
#define ReadDisplay(r,b,len)      ReadDisplayEx(r,b,len,FALSE)
/* Unused. Incomplete. */
#define ReadDisplayLine(r,b,len)  ReadDisplayEx(r,b,len,TRUE)
/* Issues an update to a layered (transparent) window. This does
   the update directly, and does not have to be done within the
   redraw event.
   Parameters
   hVideo :    display to update a part of
   bContent :  TRUE is only the passed rectangle should update
   x :         left coordinate of the region to update to
               physical display
   y :         top coordinate of the region to update to physical
               display
   w :         width of the region to update to physical display
   h :         height of the region to update to physical display */
RENDER_PROC( void, IssueUpdateLayeredEx )( PRENDERER hVideo, LOGICAL bContent, int32_t x, int32_t y, uint32_t w, uint32_t h DBG_PASS );
#ifndef KEY_STRUCTURE_DEFINED
typedef LOGICAL (CPROC*KeyTriggerHandler)(uintptr_t,uint32_t keycode);
typedef struct KeyDefine *PKEYDEFINE;
#endif
/* Can create an external key binder to store key event
   bindings. One of these is available per display.
   Example
   <code lang="c++">
   void Alt_A_Pressed(uintptr_t user_data,uint32_t keycode)
   {
       // do something when alt-a is pressed.
   }
   {
      PKEYDEFINE my_key_events = CreateKeyBinder();
      BindKeyToEventEx( my_key_events, KEY_A, KEY_MOD_ALT, Alt_A_Pressed, 0 );
   }
   // then later, in a KeyProc handler...
   HandleKeyEvents( my_key_events, keycode );
   </code>                                                                     */
RENDER_PROC( PKEYDEFINE, CreateKeyBinder )( void );
/* Destroyes a PKEYDEFINE previously created with
   CreateKeyBinder.
   Parameters
   pKeyDef :  key binder to destroy.              */
RENDER_PROC( void, DestroyKeyBinder )( PKEYDEFINE pKeyDef );
/* Evaluates a key against the key defines to trigger possible
   events.
   Parameters
   KeyDefs :  PKEYDEFINE keystate which has keys bound to it.
   keycode :  the keycode passed to a KeyProc handler.         */
RENDER_PROC( int, HandleKeyEvents )( PKEYDEFINE KeyDefs, uint32_t keycode );
/* Assigns a callback routine to a key event.
   Parameters
   KeyDefs :   pointer to key table to set event in
   scancode :  scancode of the key \- this is a KEY_ code from
               keybrd.h
   modifier :  specific modifiers pressed for this event (control,
               alt, shift)
   trigger :   the trigger function to invoke when the key is
               pressed
   psv :       a uintptr_t user data passed to the trigger function
               when invoked.                                       */
RENDER_PROC( int, BindEventToKeyEx )( PKEYDEFINE KeyDefs, uint32_t scancode, uint32_t modifier, KeyTriggerHandler trigger, uintptr_t psv );
/* Binds a key to a display.
   Parameters
   pRenderer :  display to set the event in (each display has a
                PKEYDEFINE internally. If this is NULL, then the
                event is bound to global events, an applies for
                any display window that gets a key input.
   scancode :   key scancode (a KEY_ identifier from keybrd.h)
   modifier :   key state modifier to apply to match the trigger
                on (control, alt, shift)
   trigger :    callback to invoke when the key combination is
                pressed
   psv :        user data to pass to the trigger when invoked.   */
RENDER_PROC( int, BindEventToKey )( PRENDERER pRenderer, uint32_t scancode, uint32_t modifier, KeyTriggerHandler trigger, uintptr_t psv );
/* Remove a previous binding to a key.
   Parameters
   pRenderer :  renderer to remove the key bind from
   scancode :   key scancode to stop checking
   modifier :   key modifier to stop checking        */
RENDER_PROC( int, UnbindKey )( PRENDERER pRenderer, uint32_t scancode, uint32_t modifier );
/* A way to test to see if the current input device is a touch
   display. This can affect how mouse clicks are handles for
   things like buttons.
   Parameters
   None.
   Returns
   0.                                                          */
RENDER_PROC( int, IsTouchDisplay )( void );
// static void OnInputTouch( "Touch Handler" )(
#define OnSurfaceInput(name)	 DefineRegistryMethod("sack/render",SurfaceInput,"surface input","SurfaceInput",name,void,( int nInputs, PINPUT_POINT pInputs ),__LINE__)
#ifndef PSPRITE_METHOD
/* Unused. Incomplete. */
#define PSPRITE_METHOD PSPRITE_METHOD
RENDER_NAMESPACE_END
IMAGE_NAMESPACE
   /* define sprite draw method structure */
	typedef struct sprite_method_tag *PSPRITE_METHOD;
IMAGE_NAMESPACE_END
RENDER_NAMESPACE
#endif
/* Adds a sprite rendering method to the display. Just before
   updating to the display, the display is saved, and sprite
   update callbacks are issued. then the resulting display is
   \output. Sprite data only exists on the output image just
   before it is put on the physical display.
   Parameters
   render :    the display to attach a sprite render method to
   callback :  callback to draw sprites
   psv :       user data passed to callback when it is called
   Returns
   Pointer to a SpriteMethod that can be used in SavePortion...
   uhmm
   Note
   Has fallen into disrepair, and may need work before sprites
   work this way.                                               */
RENDER_PROC( PSPRITE_METHOD, EnableSpriteMethod )(PRENDERER render, void(CPROC*RenderSprites)(uintptr_t psv, PRENDERER renderer, int32_t x, int32_t y, uint32_t w, uint32_t h ), uintptr_t psv );
/* signature for callback method to pass to
   WinShell_AcceptDroppedFiles.             */
typedef LOGICAL (CPROC*dropped_file_acceptor)(uintptr_t psv, CTEXTSTR filename, int32_t x, int32_t y );
/* Adds a callback to call when a file is dropped. Each callback
   can return 0 that it did not accept the file, or 1 that it
   did. once the file is accepted by a handler, it is not passed
   to any other handlers.
   Parameters
   renderer :  display to handle dropped files for
   f :         callback to acceptor
   psvUser :   user data passed to acceptor when it is invoked   */
RENDER_PROC( void, WinShell_AcceptDroppedFiles )( PRENDERER renderer, dropped_file_acceptor f, uintptr_t psvUser );
/* Enables a timer on the mouse to hide the cursor after a
   second that the mouse is not being moved.
   Parameters
   hVideo :   display to hide the mouse automatically for
   bEnable :  enable automatic hiding. After a few seconds, the
              mouse goes away until it moves(not click).        */
RENDER_PROC (void, DisableMouseOnIdle) (PRENDERER hVideo, LOGICAL bEnable );
/* Sets whether the display wants to get any mouse events at
   all.
   Parameters
   hVideo :    display to set the property for
   bNoMouse :  if 1, disables any mouse events. if 0, enables mouse
               events to the display.                               */
RENDER_PROC( void, SetDisplayNoMouse )( PRENDERER hVideo, int bNoMouse );
#ifdef WIN32
	/* \returns the native handle used to output to. this can be an
	   SDL_Screen or HWND depending on platform.
	   Parameters
	   video :  display to get the native handle for
	   Returns
	   the system handle of the display object being used to output. */
	RENDER_PROC( HWND, GetNativeHandle )( PRENDERER video );
#endif
/* <combine sack::image::render::OwnMouseEx@PRENDERER@uint32_t bOwn>
   \ \                                                          */
#define OwnMouse(d,o) OwnMouseEx( d, o DBG_SRC )
/* <combine sack::image::render::OpenDisplaySizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t>
   \ \                                                                     */
#define OpenDisplay(a)            OpenDisplaySizedAt(a,-1,-1,-1,-1)
/* <combine sack::image::render::OpenDisplaySizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t>
   \ \                                                                     */
#define OpenDisplaySized(a,w,h)   OpenDisplaySizedAt(a,w,h,-1,-1)
/* <combine sack::image::render::OpenDisplayAboveSizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t@PRENDERER>
   \ \                                                                                    */
#define OpenDisplayAbove(p,a)            OpenDisplayAboveSizedAt(p,-1,-1,-1,-1,a)
/* <combine sack::image::render::OpenDisplayAboveSizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t@PRENDERER>
   \ \                                                                                    */
#define OpenDisplayAboveSized(p,a,w,h)   OpenDisplayAboveSizedAt(p,w,h,-1,-1,a)
/* <combine sack::image::render::OpenDisplayAboveUnderSizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t@PRENDERER@PRENDERER>
   \ \                                                                                                   */
#define OpenDisplayUnderSizedAt(p,a,w,h,x,y) OpenDisplayAboveUnderSizedAt(a,w,h,x,y,NULL,p)
/* Lock the renderer for this thread to use. */
RENDER_PROC( void, LockRenderer )( PRENDERER render );
/* Unlock the renderer for other threads to use. */
RENDER_PROC( void, UnlockRenderer )( PRENDERER render );
/* Function to check if the draw mode of the renderer requires
   an ALL update (opengl/direct3d) every frame the whole display
   must be drawn.                                                */
RENDER_PROC( LOGICAL, RequiresDrawAll )( void );
RENDER_PROC( void, MarkDisplayUpdated )( PRENDERER );
#ifndef __NO_INTERFACES__
/* Interface defines the functions that are exported from the
   render library. This interface may be retrieved with
   LoadInterface( "\<appropriate name" ).                     */
_INTERFACE_NAMESPACE
/* Macro to define exports for render.h */
#define RENDER_PROC_PTR(type,name) type  (CPROC*_##name)
/* <combine sack::image::render::render_interface_tag>
	\ \                                                 */
typedef struct render_interface_tag RENDER_INTERFACE;
/* <combine sack::image::render::render_interface_tag>
	\ \                                                 */
typedef struct render_interface_tag *PRENDER_INTERFACE;
/* This is a function table interface to the video library. Allows
   application to not be linked to the video portion directly,
   allowing dynamic replacement.                                   */
struct render_interface_tag
{
      /* <combine sack::image::render::InitDisplay>
         \ \                                        */
       RENDER_PROC_PTR( int , InitDisplay) (void);
       /* <combine sack::image::render::SetApplicationTitle@TEXTCHAR *>
          \ \                                                           */
			 RENDER_PROC_PTR( void , SetApplicationTitle) (const TEXTCHAR *title );
          /* <combine sack::image::render::SetApplicationIcon@Image>
                                                    \ \                                                     */
       RENDER_PROC_PTR( void , SetApplicationIcon)  (Image Icon);
    /* <combine sack::image::render::GetDisplaySize@uint32_t *@uint32_t *>
       \ \                                                       */
    RENDER_PROC_PTR( void , GetDisplaySize)      ( uint32_t *width, uint32_t *height );
    /* <combine sack::image::render::SetDisplaySize@uint32_t@uint32_t>
       \ \                                                   */
    RENDER_PROC_PTR( void , SetDisplaySize)      ( uint32_t width, uint32_t height );
    /* <combine sack::image::render::OpenDisplaySizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t>
       \ \                                                                     */
    RENDER_PROC_PTR( PRENDERER , OpenDisplaySizedAt)     ( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y );
    /* <combine sack::image::render::OpenDisplayAboveSizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t@PRENDERER>
       \ \                                                                                    */
    RENDER_PROC_PTR( PRENDERER , OpenDisplayAboveSizedAt)( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y, PRENDERER above );
    /* <combine sack::image::render::CloseDisplay@PRENDERER>
       \ \                                                   */
    RENDER_PROC_PTR( void        , CloseDisplay) ( PRENDERER );
    /* <combine sack::image::render::UpdateDisplayPortionEx@PRENDERER@int32_t@int32_t@uint32_t@uint32_t height>
       \ \                                                                                      */
    RENDER_PROC_PTR( void, UpdateDisplayPortionEx) ( PRENDERER, int32_t x, int32_t y, uint32_t width, uint32_t height DBG_PASS );
    /* <combine sack::image::render::UpdateDisplayEx@PRENDERER>
       \ \                                                      */
    RENDER_PROC_PTR( void, UpdateDisplayEx)        ( PRENDERER DBG_PASS);
    /* <combine sack::image::render::GetDisplayPosition@PRENDERER@int32_t *@int32_t *@uint32_t *@uint32_t *>
       \ \                                                                                   */
    RENDER_PROC_PTR( void, GetDisplayPosition)   ( PRENDERER, int32_t *x, int32_t *y, uint32_t *width, uint32_t *height );
    /* <combine sack::image::render::MoveDisplay@PRENDERER@int32_t@int32_t>
       \ \                                                            */
    RENDER_PROC_PTR( void, MoveDisplay)          ( PRENDERER, int32_t x, int32_t y );
    /* <combine sack::image::render::MoveDisplayRel@PRENDERER@int32_t@int32_t>
       \ \                                                               */
    RENDER_PROC_PTR( void, MoveDisplayRel)       ( PRENDERER, int32_t delx, int32_t dely );
    /* <combine sack::image::render::SizeDisplay@PRENDERER@uint32_t@uint32_t>
       \ \                                                          */
    RENDER_PROC_PTR( void, SizeDisplay)          ( PRENDERER, uint32_t w, uint32_t h );
    /* <combine sack::image::render::SizeDisplayRel@PRENDERER@int32_t@int32_t>
       \ \                                                               */
    RENDER_PROC_PTR( void, SizeDisplayRel)       ( PRENDERER, int32_t delw, int32_t delh );
    /* <combine sack::image::render::MoveSizeDisplayRel@PRENDERER@int32_t@int32_t@int32_t@int32_t>
       \ \                                                                             */
    RENDER_PROC_PTR( void, MoveSizeDisplayRel )  ( PRENDERER hVideo
                                                 , int32_t delx, int32_t dely
                                                 , int32_t delw, int32_t delh );
    RENDER_PROC_PTR( void, PutDisplayAbove)      ( PRENDERER, PRENDERER );
 /* <combine sack::image::render::PutDisplayAbove@PRENDERER@PRENDERER>
                                                              \ \                                                                */
    /* <combine sack::image::render::GetDisplayImage@PRENDERER>
       \ \                                                      */
    RENDER_PROC_PTR( Image, GetDisplayImage)     ( PRENDERER );
    /* <combine sack::image::render::SetCloseHandler@PRENDERER@CloseCallback@uintptr_t>
       \ \                                                                             */
    RENDER_PROC_PTR( void, SetCloseHandler)      ( PRENDERER, CloseCallback, uintptr_t );
    /* <combine sack::image::render::SetMouseHandler@PRENDERER@MouseCallback@uintptr_t>
       \ \                                                                             */
    RENDER_PROC_PTR( void, SetMouseHandler)      ( PRENDERER, MouseCallback, uintptr_t );
    /* <combine sack::image::render::SetRedrawHandler@PRENDERER@RedrawCallback@uintptr_t>
       \ \                                                                               */
    RENDER_PROC_PTR( void, SetRedrawHandler)     ( PRENDERER, RedrawCallback, uintptr_t );
    /* <combine sack::image::render::SetKeyboardHandler@PRENDERER@KeyProc@uintptr_t>
       \ \                                                                          */
    RENDER_PROC_PTR( void, SetKeyboardHandler)   ( PRENDERER, KeyProc, uintptr_t );
    /* <combine sack::image::render::SetLoseFocusHandler@PRENDERER@LoseFocusCallback@uintptr_t>
       \ \                                                                                     */
    RENDER_PROC_PTR( void, SetLoseFocusHandler)  ( PRENDERER, LoseFocusCallback, uintptr_t );
    /* <combine sack::image::render::SetDefaultHandler@PRENDERER@GeneralCallback@uintptr_t>
       \ \                                                                                 */
#if ACTIVE_MESSAGE_IMPLEMENTED
			 RENDER_PROC_PTR( void, SetDefaultHandler)    ( PRENDERER, GeneralCallback, uintptr_t );
#else
       POINTER junk1;
#endif
    /* <combine sack::image::render::GetMousePosition@int32_t *@int32_t *>
		 \ \                                                           */
    RENDER_PROC_PTR( void, GetMousePosition)     ( int32_t *x, int32_t *y );
    /* <combine sack::image::render::SetMousePosition@PRENDERER@int32_t@int32_t>
       \ \                                                                 */
    RENDER_PROC_PTR( void, SetMousePosition)     ( PRENDERER, int32_t x, int32_t y );
    /* <combine sack::image::render::HasFocus@PRENDERER>
       \ \                                               */
    RENDER_PROC_PTR( LOGICAL, HasFocus)          ( PRENDERER );
    /* <combine sack::image::render::GetKeyText@int>
       \ \                                           */
    RENDER_PROC_PTR( const TEXTCHAR *, GetKeyText)           ( int key );
    /* <combine sack::image::render::IsKeyDown@PRENDERER@int>
       \ \                                                    */
    RENDER_PROC_PTR( uint32_t, IsKeyDown )        ( PRENDERER display, int key );
    /* <combine sack::image::render::KeyDown@PRENDERER@int>
       \ \                                                  */
    RENDER_PROC_PTR( uint32_t, KeyDown )         ( PRENDERER display, int key );
    /* <combine sack::image::render::DisplayIsValid@PRENDERER>
       \ \                                                     */
    RENDER_PROC_PTR( LOGICAL, DisplayIsValid )  ( PRENDERER display );
    /* <combine sack::image::render::OwnMouseEx@PRENDERER@uint32_t bOwn>
       \ \                                                          */
    RENDER_PROC_PTR( void, OwnMouseEx )            ( PRENDERER display, uint32_t Own DBG_PASS);
    /* <combine sack::image::render::BeginCalibration@uint32_t>
       \ \                                                 */
    RENDER_PROC_PTR( int, BeginCalibration )       ( uint32_t points );
    /* <combine sack::image::render::SyncRender@PRENDERER>
       \ \                                                 */
    RENDER_PROC_PTR( void, SyncRender )            ( PRENDERER pDisplay );
    /* DEPRICATED; left in structure for compatibility.  Removed define and export definition. */
	 /* <combine sack::image::render::MoveSizeDisplay@PRENDERER@int32_t@int32_t@int32_t@int32_t>
	    \ \                                                                          */
	 RENDER_PROC_PTR( void, MoveSizeDisplay )( PRENDERER hVideo
                                        , int32_t x, int32_t y
                                        , int32_t w, int32_t h );
   /* <combine sack::image::render::MakeTopmost@PRENDERER>
      \ \                                                  */
   RENDER_PROC_PTR( void, MakeTopmost )    ( PRENDERER hVideo );
   /* <combine sack::image::render::HideDisplay@PRENDERER>
      \ \                                                  */
   RENDER_PROC_PTR( void, HideDisplay )      ( PRENDERER hVideo );
   /* <combine sack::image::render::RestoreDisplay@PRENDERER>
      \ \                                                     */
   RENDER_PROC_PTR( void, RestoreDisplay )   ( PRENDERER hVideo );
	/* <combine sack::image::render::ForceDisplayFocus@PRENDERER>
	   \ \                                                        */
	RENDER_PROC_PTR( void, ForceDisplayFocus )( PRENDERER display );
	/* <combine sack::image::render::ForceDisplayFront@PRENDERER>
	   \ \                                                        */
	RENDER_PROC_PTR( void, ForceDisplayFront )( PRENDERER display );
	/* <combine sack::image::render::ForceDisplayBack@PRENDERER>
	   \ \                                                       */
	RENDER_PROC_PTR( void, ForceDisplayBack )( PRENDERER display );
	/* <combine sack::image::render::BindEventToKey@PRENDERER@uint32_t@uint32_t@KeyTriggerHandler@uintptr_t>
	   \ \                                                                                        */
	RENDER_PROC_PTR( int, BindEventToKey )( PRENDERER pRenderer, uint32_t scancode, uint32_t modifier, KeyTriggerHandler trigger, uintptr_t psv );
	/* <combine sack::image::render::UnbindKey@PRENDERER@uint32_t@uint32_t>
	   \ \                                                        */
	RENDER_PROC_PTR( int, UnbindKey )( PRENDERER pRenderer, uint32_t scancode, uint32_t modifier );
	/* <combine sack::image::render::IsTopmost@PRENDERER>
	   \ \                                                */
	RENDER_PROC_PTR( int, IsTopmost )( PRENDERER hVideo );
	/* Used as a point to sync between applications and the message
	   display server; Makes sure that all draw commands which do
	   not have a response are done.
	   Waits until all commands are processed; which is wait until
	   this command is processed.                                   */
	RENDER_PROC_PTR( void, OkaySyncRender )            ( void );
   /* <combine sack::image::render::IsTouchDisplay>
      \ \                                           */
   RENDER_PROC_PTR( int, IsTouchDisplay )( void );
	/* <combine sack::image::render::GetMouseState@int32_t *@int32_t *@uint32_t *>
	   \ \                                                              */
	RENDER_PROC_PTR( void , GetMouseState )        ( int32_t *x, int32_t *y, uint32_t *b );
	/* <combine sack::image::render::EnableSpriteMethod@PRENDERER@void__cdecl*RenderSpritesPTRSZVAL psv\, PRENDERER renderer\, int32_t x\, int32_t y\, uint32_t w\, uint32_t h@uintptr_t>
	   \ \                                                                                                                                                               */
	RENDER_PROC_PTR ( PSPRITE_METHOD, EnableSpriteMethod )(PRENDERER render, void(CPROC*RenderSprites)(uintptr_t psv, PRENDERER renderer, int32_t x, int32_t y, uint32_t w, uint32_t h ), uintptr_t psv );
	/* <combine sack::image::render::WinShell_AcceptDroppedFiles@PRENDERER@dropped_file_acceptor@uintptr_t>
	   \ \                                                                                                 */
	RENDER_PROC_PTR( void, WinShell_AcceptDroppedFiles )( PRENDERER renderer, dropped_file_acceptor f, uintptr_t psvUser );
	/* <combine sack::image::render::PutDisplayIn@PRENDERER@PRENDERER>
	   \ \                                                             */
	RENDER_PROC_PTR(void, PutDisplayIn) (PRENDERER hVideo, PRENDERER hContainer);
#ifdef WIN32
	/* <combine sack::image::render::MakeDisplayFrom@HWND>
	   \ \                                                 */
			RENDER_PROC_PTR (PRENDERER, MakeDisplayFrom) (HWND hWnd) ;
#else
      POINTER junk4;
#endif
	/* <combine sack::image::render::SetRendererTitle@PRENDERER@TEXTCHAR *>
	   \ \                                                                  */
	RENDER_PROC_PTR( void , SetRendererTitle) ( PRENDERER render, const TEXTCHAR *title );
	/* <combine sack::image::render::DisableMouseOnIdle@PRENDERER@LOGICAL>
	   \ \                                                                 */
	RENDER_PROC_PTR (void, DisableMouseOnIdle) (PRENDERER hVideo, LOGICAL bEnable );
	/* <combine sack::image::render::OpenDisplayAboveUnderSizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t@PRENDERER@PRENDERER>
	   \ \                                                                                                   */
	RENDER_PROC_PTR( PRENDERER, OpenDisplayAboveUnderSizedAt)( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y, PRENDERER above, PRENDERER under );
	/* <combine sack::image::render::SetDisplayNoMouse@PRENDERER@int>
	   \ \                                                            */
	RENDER_PROC_PTR( void, SetDisplayNoMouse )( PRENDERER hVideo, int bNoMouse );
	/* <combine sack::image::render::Redraw@PRENDERER>
	   \ \                                             */
	RENDER_PROC_PTR( void, Redraw )( PRENDERER hVideo );
	/* <combine sack::image::render::MakeAbsoluteTopmost@PRENDERER>
	   \ \                                                          */
	RENDER_PROC_PTR(void, MakeAbsoluteTopmost) (PRENDERER hVideo);
	/* <combine sack::image::render::SetDisplayFade@PRENDERER@int>
	   \ \                                                         */
	RENDER_PROC_PTR( void, SetDisplayFade )( PRENDERER hVideo, int level );
	/* <combine sack::image::render::IsDisplayHidden@PRENDERER>
	   \ \                                                      */
	RENDER_PROC_PTR( LOGICAL, IsDisplayHidden )( PRENDERER video );
#ifdef WIN32
	/* <combine sack::image::render::GetNativeHandle@PRENDERER>
	   \ \                                                      */
	RENDER_PROC_PTR( HWND, GetNativeHandle )( PRENDERER video );
#endif
		 /* <combine sack::image::render::GetDisplaySizeEx@int@int32_t *@int32_t *@uint32_t *@uint32_t *>
		    \ \                                                                           */
		 RENDER_PROC_PTR (void, GetDisplaySizeEx) ( int nDisplay
														  , int32_t *x, int32_t *y
														  , uint32_t *width, uint32_t *height);
	/* Locks a video display. Applications shouldn't be locking
	   this, but if for some reason they require it; use this
	   function.                                                */
	RENDER_PROC_PTR( void, LockRenderer )( PRENDERER render );
	/* Release renderer lock critical section. Applications
	   shouldn't be locking this surface.                   */
	RENDER_PROC_PTR( void, UnlockRenderer )( PRENDERER render );
	/* Provides a way for applications to cause the window to flush
	   to the display (if it's a transparent window)                */
	RENDER_PROC_PTR( void, IssueUpdateLayeredEx )( PRENDERER hVideo, LOGICAL bContent, int32_t x, int32_t y, uint32_t w, uint32_t h DBG_PASS );
	/* Check to see if the render mode is always redraw; changes how
	   smudge works in PSI. If always redrawn, then the redraw isn't
	   done during the smudge, and instead is delayed until a draw
	   is triggered at which time all controls are drawn.
	   Returns
	   TRUE if full screen needs to be drawn during a draw,
	   otherwise partial updates may be done.                        */
	RENDER_PROC_PTR( LOGICAL, RequiresDrawAll )( void );
#ifndef NO_TOUCH
		/* <combine sack::image::render::SetTouchHandler@PRENDERER@fte inc asdfl;kj
		 fteTouchCallback@uintptr_t>
       \ \                                                                             */
			RENDER_PROC_PTR( void, SetTouchHandler)      ( PRENDERER, TouchCallback, uintptr_t );
#endif
    RENDER_PROC_PTR( void, MarkDisplayUpdated )( PRENDERER );
    /* <combine sack::image::render::SetHideHandler@PRENDERER@HideAndRestoreCallback@uintptr_t>
       \ \                                                                             */
    RENDER_PROC_PTR( void, SetHideHandler)      ( PRENDERER, HideAndRestoreCallback, uintptr_t );
    /* <combine sack::image::render::SetRestoreHandler@PRENDERER@HideAndRestoreCallback@uintptr_t>
       \ \                                                                             */
    RENDER_PROC_PTR( void, SetRestoreHandler)      ( PRENDERER, HideAndRestoreCallback, uintptr_t );
		 RENDER_PROC_PTR( void, RestoreDisplayEx )   ( PRENDERER hVideo DBG_PASS );
		 /* added for android extensions; call to enable showing the keyboard in the correct thread
        ; may have applications for windows tablets
		  */
       RENDER_PROC_PTR( void, SACK_Vidlib_ShowInputDevice )( void );
		 /* added for android extensions; call to enable hiding the keyboard in the correct thread
		  ; may have applications for windows tablets */
       RENDER_PROC_PTR( void, SACK_Vidlib_HideInputDevice )( void );
	/* Check to see if the render mode is allows updates from any thread.
	   If supported can simplify updates (requiring less scheduling queues).
	   If it is not supported (such as an X display where only a single thread
	   can write to the server, otherwise the socket state gets confused) then
	   Redraw() should be used to dispatch appriorately.  PSI Implements this
	   internally, so smudge() on a control will behave appriopriately.
	   If RequiresDrawAll() this is irrelavent.
	   Returns
	   TRUE if any thread is allowed to generate UpdateDisplayPortion().
	   otherwise must call Redraw() on the surface to get a event in the
	   correct thread.*/
			 RENDER_PROC_PTR( LOGICAL, AllowsAnyThreadToUpdate )( void );
		/* This method takes the renderer and either A) resizes it to the display
		 and issues a redraw; or it sets the screen to the size of the renderer
		 and scales the image direct to the display.  Pass NULL or another window
		 to clear the current fullscreen app.
		 Second paramter is the display to show full on; 0 is 'default'...
		 1, 2, 3, etc... will be absolute number... if not supported will be same a 0 */
		RENDER_PROC_PTR( void, SetDisplayFullScreen )( PRENDERER renderer, int nDisplay );
		/* like full screen, some applications may want to
       enable owning the screen... (media player) */
      RENDER_PROC_PTR( void, SuspendSystemSleep )( int bool_suspend_enable );
	RENDER_PROC_PTR( LOGICAL, RenderIsInstanced )( void );
	RENDER_PROC_PTR( LOGICAL, VidlibRenderAllowsCopy )( void );
	RENDER_PROC_PTR( void, SetDisplayCursor )( CTEXTSTR nCursor );
	RENDER_PROC_PTR( LOGICAL, IsDisplayRedrawForced )( PRENDERER renderer );
 // only valid during a headless display event....
	RENDER_PROC_PTR( void, ReplyCloseDisplay )( void );
		/* Clipboard Callback */
	RENDER_PROC_PTR( void, SetClipboardEventCallback )(PRENDERER pRenderer, ClipboardCallback callback, uintptr_t psv);
};
#ifdef DEFINE_DEFAULT_RENDER_INTERFACE
#define USE_RENDER_INTERFACE GetDisplayInterface()
#endif
#ifdef FORCE_NO_INTERFACE
#undef USE_RENDER_INTERFACE
#endif
#ifdef FORCE_NO_RENDER_INTERFACE
#undef USE_RENDER_INTERFACE
#endif
#if !defined(FORCE_NO_RENDER_INTERFACE)
/* RENDER_PROC( PRENDER_INTERFACE, GetDisplayInterface )( void
 );
   Gets the interface the proper way - by name.
   Returns
   Pointer to the render interface.                            */
#  define GetDisplayInterface() (PRENDER_INTERFACE)GetInterface( "render" )
/* RENDER_PROC( void, DropDisplayInterface )( PRENDER_INTERFACE interface );
   release the interface (could be cleanup, most are donothing....
   parameters
   interface   - Pointer to the render interface.                            */
#  define DropDisplayInterface(x) DropInterface( "render", x )
#endif
#ifdef USE_RENDER_INTERFACE
typedef int check_this_variable;
// these methods are provided for backwards compatibility
// these should not be used - but rather use the interface defined below
// (the ones not prefixed by ActImage_ - except for ActImage_Init, which
// may(should) be called before any other function.
#define REND_PROC_ALIAS(name) ((USE_RENDER_INTERFACE)->_##name)
#define REND_PROC_ALIAS_VOID(name) if(USE_RENDER_INTERFACE)(USE_RENDER_INTERFACE)->_##name
#define SetApplicationTitle       REND_PROC_ALIAS(SetApplicationTitle)
#define SetRendererTitle       REND_PROC_ALIAS(SetRendererTitle)
#define SetApplicationIcon        REND_PROC_ALIAS(SetApplicationIcon)
#define GetDisplaySize            REND_PROC_ALIAS(GetDisplaySize)
#define GetDisplaySizeEx            REND_PROC_ALIAS(GetDisplaySizeEx)
#define MarkDisplayUpdated            REND_PROC_ALIAS(MarkDisplayUpdated)
#define SetDisplaySize            REND_PROC_ALIAS(SetDisplaySize)
#define GetDisplayPosition        REND_PROC_ALIAS(GetDisplayPosition)
#define IssueUpdateLayeredEx      REND_PROC_ALIAS(IssueUpdateLayeredEx)
#define MakeDisplayFrom        REND_PROC_ALIAS(MakeDisplayFrom)
#define OpenDisplaySizedAt        REND_PROC_ALIAS(OpenDisplaySizedAt)
#define OpenDisplayAboveSizedAt   REND_PROC_ALIAS(OpenDisplayAboveSizedAt)
#define OpenDisplayAboveUnderSizedAt   REND_PROC_ALIAS(OpenDisplayAboveUnderSizedAt)
#define CloseDisplay              REND_PROC_ALIAS(CloseDisplay)
#define UpdateDisplayPortionEx    REND_PROC_ALIAS(UpdateDisplayPortionEx)
#define UpdateDisplayEx             REND_PROC_ALIAS(UpdateDisplayEx)
#define SetMousePosition          REND_PROC_ALIAS(SetMousePosition)
#define GetMousePosition          REND_PROC_ALIAS(GetMousePosition)
#define GetMouseState          REND_PROC_ALIAS(GetMouseState)
#define EnableSpriteMethod          REND_PROC_ALIAS(EnableSpriteMethod)
#define WinShell_AcceptDroppedFiles REND_PROC_ALIAS(WinShell_AcceptDroppedFiles)
#define MoveDisplay               REND_PROC_ALIAS(MoveDisplay)
#define MoveDisplayRel            REND_PROC_ALIAS(MoveDisplayRel)
#define SizeDisplay               REND_PROC_ALIAS(SizeDisplay)
#define Redraw               REND_PROC_ALIAS(Redraw)
#define RequiresDrawAll()        (USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_RequiresDrawAll()):0
#define SizeDisplayRel            REND_PROC_ALIAS(SizeDisplayRel)
#define MoveSizeDisplay        REND_PROC_ALIAS(MoveSizeDisplay)
#define MoveSizeDisplayRel        REND_PROC_ALIAS(MoveSizeDisplayRel)
#define PutDisplayAbove           REND_PROC_ALIAS(PutDisplayAbove)
#define PutDisplayIn           REND_PROC_ALIAS(PutDisplayIn)
#define GetDisplayImage           REND_PROC_ALIAS(GetDisplayImage)
#define LockRenderer              REND_PROC_ALIAS(LockRenderer)
#define UnlockRenderer              REND_PROC_ALIAS(UnlockRenderer)
#define SetCloseHandler           REND_PROC_ALIAS(SetCloseHandler)
#define SetMouseHandler           REND_PROC_ALIAS(SetMouseHandler)
#define SetHideHandler           REND_PROC_ALIAS(SetHideHandler)
#define SetRestoreHandler           REND_PROC_ALIAS(SetRestoreHandler)
#define AllowsAnyThreadToUpdate()          ((USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_AllowsAnyThreadToUpdate)?(USE_RENDER_INTERFACE)->_AllowsAnyThreadToUpdate():1:1)
#define VidlibRenderAllowsCopy()        ((USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_VidlibRenderAllowsCopy)?(USE_RENDER_INTERFACE)->_VidlibRenderAllowsCopy():1:1)
#ifndef __LINUX__
#define SetTouchHandler           REND_PROC_ALIAS(SetTouchHandler)
#endif
#define SetRedrawHandler          REND_PROC_ALIAS(SetRedrawHandler)
#define SetKeyboardHandler        REND_PROC_ALIAS(SetKeyboardHandler)
#define SetLoseFocusHandler       REND_PROC_ALIAS(SetLoseFocusHandler)
#define SetDefaultHandler         REND_PROC_ALIAS(SetDefaultHandler)
#define GetKeyText                REND_PROC_ALIAS(GetKeyText)
#define HasFocus                  REND_PROC_ALIAS(HasFocus)
#define SACK_Vidlib_ShowInputDevice REND_PROC_ALIAS( SACK_Vidlib_ShowInputDevice )
#define SACK_Vidlib_HideInputDevice REND_PROC_ALIAS( SACK_Vidlib_HideInputDevice )
#define CreateMessage             REND_PROC_ALIAS(CreateMessage)
#define SendActiveMessage         REND_PROC_ALIAS(SendActiveMessage)
#define IsKeyDown                 REND_PROC_ALIAS(IsKeyDown)
#define KeyDown                   REND_PROC_ALIAS(KeyDown)
#define DisplayIsValid            REND_PROC_ALIAS(DisplayIsValid)
#define OwnMouseEx                REND_PROC_ALIAS(OwnMouseEx)
#define BeginCalibration          REND_PROC_ALIAS(BeginCalibration)
#define SyncRender                REND_PROC_ALIAS(SyncRender)
#define OkaySyncRender                REND_PROC_ALIAS(OkaySyncRender)
#define HideDisplay               REND_PROC_ALIAS(HideDisplay)
#define IsDisplayHidden               REND_PROC_ALIAS(IsDisplayHidden)
/* <combine sack::image::render::GetNativeHandle@PRENDERER>
   \ \                                                      */
#define GetNativeHandle             REND_PROC_ALIAS(GetNativeHandle)
//#define RestoreDisplay             REND_PROC_ALIAS(RestoreDisplay)
#define RestoreDisplayEx             REND_PROC_ALIAS(RestoreDisplayEx)
#define MakeTopmost               REND_PROC_ALIAS_VOID(MakeTopmost)
#define MakeAbsoluteTopmost               REND_PROC_ALIAS_VOID(MakeAbsoluteTopmost)
#define IsTopmost               REND_PROC_ALIAS(IsTopmost)
#define SetDisplayFade               REND_PROC_ALIAS(SetDisplayFade)
#define ForceDisplayFocus         REND_PROC_ALIAS(ForceDisplayFocus)
#define ForceDisplayFront       REND_PROC_ALIAS(ForceDisplayFront)
#define ForceDisplayBack          REND_PROC_ALIAS(ForceDisplayBack)
#define BindEventToKey          REND_PROC_ALIAS(BindEventToKey)
#define UnbindKey               REND_PROC_ALIAS(UnbindKey)
#define IsTouchDisplay          REND_PROC_ALIAS(IsTouchDisplay)
#define DisableMouseOnIdle      REND_PROC_ALIAS(DisableMouseOnIdle )
#define SetDisplayNoMouse      REND_PROC_ALIAS(SetDisplayNoMouse )
#define SetTouchHandler        REND_PROC_ALIAS(SetTouchHandler)
#define ReplyCloseDisplay      if(USE_RENDER_INTERFACE) if((USE_RENDER_INTERFACE)->_ReplyCloseDisplay) (USE_RENDER_INTERFACE)->_ReplyCloseDisplay
#define SetClipboardEventCallback   REND_PROC_ALIAS( SetClipboardEventCallback )
#define SetDisplayFullScreen    REND_PROC_ALIAS_VOID( SetDisplayFullScreen )
#define SuspendSystemSleep      REND_PROC_ALIAS_VOID( SuspendSystemSleep )
#define RenderIsInstanced()       ((USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_RenderIsInstanced)?(USE_RENDER_INTERFACE)->_RenderIsInstanced():0:0)
#define SetDisplayCursor(n)           {if((USE_RENDER_INTERFACE)&&(USE_RENDER_INTERFACE)->_SetDisplayCursor)REND_PROC_ALIAS(SetDisplayCursor)(n);}
#define IsDisplayRedrawForced(r)    ((USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_IsDisplayRedrawForced)?(USE_RENDER_INTERFACE)->_IsDisplayRedrawForced(r):0:0)
#endif
	_INTERFACE_NAMESPACE_END
#ifdef __cplusplus
#ifdef _D3D_DRIVER
	using namespace sack::image::render::d3d::Interface;
#elif defined( _D3D10_DRIVER )
	using namespace sack::image::render::d3d10::Interface;
#elif defined( _D3D11_DRIVER )
	using namespace sack::image::render::d3d11::Interface;
#else
	using namespace sack::image::render::Interface;
#endif
#endif
#endif
#ifndef __NO_MSGSVR__
#ifdef DEFINE_RENDER_PROTOCOL
  // offsetof
// need to define BASE_RENDER_MESSAGE_ID before including this.
//#define MSG_ID(method)  ( ( offsetof( struct render_interface_tag, _##method ) / sizeof( void(*)(void) ) ) + BASE_RENDER_MESSAGE_ID + MSG_EventUser )
#define MSG_DisplayClientClose        MSG_ID(DisplayClientClose)
#define MSG_SetApplicationTitle       MSG_ID(SetApplicationTitle)
#define MSG_SetRendererTitle       MSG_ID(SetRendererTitle)
#define MSG_SetApplicationIcon        MSG_ID(SetApplicationTitle)
#define MSG_GetDisplaySize            MSG_ID(GetDisplaySize)
#define MSG_SetDisplaySize            MSG_ID(SetDisplaySize)
#define MSG_GetDisplayPosition        MSG_ID(GetDisplayPosition)
#define MSG_OpenDisplaySizedAt        MSG_ID(OpenDisplaySizedAt)
#define MSG_OpenDisplayAboveSizedAt   MSG_ID(OpenDisplayAboveSizedAt)
#define MSG_CloseDisplay              MSG_ID(CloseDisplay)
#define MSG_UpdateDisplayPortionEx    MSG_ID(UpdateDisplayPortionEx)
#define MSG_UpdateDisplay             MSG_ID(UpdateDisplayEx)
#define MSG_SetMousePosition          MSG_ID(SetMousePosition)
#define MSG_GetMousePosition          MSG_ID(GetMousePosition)
#define MSG_GetMouseState             MSG_ID(GetMouseState )
#define MSG_Redraw               MSG_ID(Redraw)
#define MSG_EnableSpriteMethod             MSG_ID(EnableSpriteMethod )
#define MSG_WinShell_AcceptDroppedFiles    MSG_ID(WinShell_AcceptDroppedFiles )
#define MSG_MoveDisplay               MSG_ID(MoveDisplay)
#define MSG_MoveDisplayRel            MSG_ID(MoveDisplayRel)
#define MSG_SizeDisplay               MSG_ID(SizeDisplay)
#define MSG_SizeDisplayRel            MSG_ID(SizeDisplayRel)
#define MSG_MoveSizeDisplay           MSG_ID(MoveSizeDisplay)
#define MSG_MoveSizeDisplayRel        MSG_ID(MoveSizeDisplayRel)
#define MSG_PutDisplayAbove           MSG_ID(PutDisplayAbove)
#define MSG_GetDisplayImage           MSG_ID(GetDisplayImage)
#define MSG_SetCloseHandler           MSG_ID(SetCloseHandler)
#define MSG_SetMouseHandler           MSG_ID(SetMouseHandler)
#define MSG_SetRedrawHandler          MSG_ID(SetRedrawHandler)
#define MSG_SetKeyboardHandler        MSG_ID(SetKeyboardHandler)
#define MSG_SetLoseFocusHandler       MSG_ID(SetLoseFocusHandler)
#define MSG_SetDefaultHandler         MSG_ID(SetDefaultHandler)
// -- all other handlers - client side only
#define MSG_HasFocus                  MSG_ID(HasFocus)
#define MSG_SendActiveMessage         MSG_ID(SendActiveMessage)
#define MSG_GetKeyText                MSG_ID(GetKeyText)
#define MSG_IsKeyDown                 MSG_ID(IsKeyDown)
#define MSG_KeyDown                   MSG_ID(KeyDown)
#define MSG_DisplayIsValid            MSG_ID(DisplayIsValid)
#define MSG_OwnMouseEx                 MSG_ID(OwnMouseEx)
#define MSG_BeginCalibration           MSG_ID(BeginCalibration)
#define MSG_SyncRender                 MSG_ID(SyncRender)
#define MSG_OkaySyncRender                 MSG_ID(OkaySyncRender)
#define MSG_HideDisplay               MSG_ID(HideDisplay)
#define MSG_IsDisplayHidden               MSG_ID(IsDisplayHidden)
#define MSG_RestoreDisplay             MSG_ID(RestoreDisplay)
#define MSG_MakeTopmost               MSG_ID(MakeTopmost)
#define MSG_BindEventToKey          MSG_ID(BindEventToKey)
#define MSG_UnbindKey               MSG_ID(UnbindKey)
#define MSG_IsTouchDisplay          MSG_ID(IsTouchDisplay )
#define MSG_GetNativeHandle             MSG_ID(GetNativeHandle)
#endif
#endif
// static void OnDisplayChangedSize( "" )( PRENDERER, int nDisplay, uint32_t x, uint32_t y, uint32_t width, uint32_t height )
	// OnDisplayPause is called on systems that allow the application to suspend its display.
	// Sleep mode may also trigger such an event, allows application to save state
   // a media player, for instance, may recover unplayed buffers to prepare for resume
#define OnDisplaySizeChange(name)	 DefineRegistryMethod("sack/render",OnDisplaySizeChange,"display",name,"on_display_size_change",void,( uintptr_t psv_redraw, int nDisplay, int32_t x, int32_t y, uint32_t width, uint32_t height ),__LINE__)
// static void OnDisplayPause( "" )( void )
	// OnDisplayPause is called on systems that allow the application to suspend its display.
	// Sleep mode may also trigger such an event, allows application to save state
   // a media player, for instance, may recover unplayed buffers to prepare for resume
#define OnDisplayPause(name)	 DefineRegistryMethod("sack/render/android",OnDisplayPause,"display",name,"on_display_pause",void,(void),__LINE__)
// static void OnDisplayResume( "" )( void )
	// OnDisplayResume is called on systems that allow the application to suspend its display.
	// Wake from sleep mode may also trigger such an event, allows application to restore saved state
   // a media player, for instance, may continue playing ( it might be good to wait just a little longer than 'now')
#define OnDisplayResume(name)	 DefineRegistryMethod("sack/render/android",OnDisplayResume,"display",name,"on_display_resume",void,(void),__LINE__)
	struct display_app;
	struct display_app_local;
	// static void OnDisplayConnect( "" )( struct display_app*app, struct display_app_local ***pppLocal )
	//  app is a unique handle to the display instance.  Can be used as a key to locate resources for the display
	//  pppLocal is ... ugly.
	//  ThreadLocal struct instance_local *_thread_local;
	//  static void OnDisplayConnect( "" )( struct display_app*app, struct display_app_local ***pppLocal )
	//  {
	//	    _thread_local = New( struct instance_local );
	//      MemSet( option_thread, 0, sizeof( option_thread ) );
	//      (*local) = (struct display_app_local**)&option_thread;
	//       //... init local here
	//  }
	//
#define OnDisplayConnect(name)	 DefineRegistryMethod("/sack/render/remote display",OnDisplayConnect,"connect",name,"new_display_connect",void,(struct display_app*app, struct display_app_local ***),__LINE__)
	// unimplemented.
#define OnDisplayConnected(name)	 DefineRegistryMethod("/sack/render/remote display",OnDisplayConnect,"connect",name,"new_display_connected",void,(struct display_app*app),__LINE__)
RENDER_NAMESPACE_END
#ifdef __cplusplus
#ifdef _D3D_DRIVER
	using namespace sack::image::render::d3d;
#elif defined( _D3D10_DRIVER )
	using namespace sack::image::render::d3d10;
#elif defined( _D3D11_DRIVER )
	using namespace sack::image::render::d3d11;
#else
	using namespace sack::image::render;
#endif
#endif
#endif
// : $
// $Log: render.h,v $
// Revision 1.48  2005/05/25 16:50:09  d3x0r
// Synch with working repository.
//
// Revision 1.10  2003/03/25 08:38:11  panther
// Add logging
//
#ifndef __panthers_slick_interface_namespace__
#define __panthers_slick_interface_namespace__
#ifdef __cplusplus
#define PSI_NAMESPACE SACK_NAMESPACE namespace PSI {
#define _PSI_NAMESPACE namespace PSI {
#define _PSI_NAMESPACE_END }
#define PSI_NAMESPACE_END _PSI_NAMESPACE_END SACK_NAMESPACE_END
#define USE_PSI_NAMESPACE using namespace sack::PSI;
#   define _PSI_INTERFACE_NAMESPACE namespace Interface {
#   define _PSI_INTERFACE_NAMESPACE_END }
#   define _BUTTON_NAMESPACE namespace button {
#   define _BUTTON_NAMESPACE_END }
#   define USE_BUTTON_NAMESPACE using namespace button;
#   define USE_PSI_BUTTON_NAMESPACE using namespace sack::PSI::button;
#   define _COLORWELL_NAMESPACE namespace colorwell {
#   define _COLORWELL_NAMESPACE_END }
#   define USE_COLORWELL_NAMESPACE using namespace colorwell;
#   define USE_PSI_COLORWELL_NAMESPACE using namespace sack::PSI::colorwell;
#   define _MENU_NAMESPACE namespace popup {
#   define _MENU_NAMESPACE_END }
#   define USE_MENU_NAMESPACE using namespace popup;
#   define USE_PSI_MENU_NAMESPACE using namespace sack::PSI::popup;
#   define _TEXT_NAMESPACE namespace text {
#   define _TEXT_NAMESPACE_END }
#   define USE_TEXT_NAMESPACE using namespace text;
#   define USE_PSI_TEXT_NAMESPACE using namespace sack::PSI::text;
#   define _EDIT_NAMESPACE namespace edit {
#   define _EDIT_NAMESPACE_END }
#   define USE_EDIT_NAMESPACE using namespace edit;
#   define USE_PSI_EDIT_NAMESPACE using namespace sack::PSI::edit;
#   define _SLIDER_NAMESPACE namespace slider {
#   define _SLIDER_NAMESPACE_END }
#   define USE_SLIDER_NAMESPACE using namespace slider;
#   define USE_PSI_SLIDER_NAMESPACE using namespace sack::PSI::slider;
#   define _FONTS_NAMESPACE namespace font {
#   define _FONTS_NAMESPACE_END }
#   define USE_FONTS_NAMESPACE using namespace font;
#   define USE_PSI_FONTS_NAMESPACE using namespace sack::PSI::font;
#   define _COMBOBOX_NAMESPACE namespace listbox {
#   define _COMBOBOX_NAMESPACE_END }
#   define USE_COMBOBOX_NAMESPACE using namespace listbox;
#   define USE_PSI_COMBOBOX_NAMESPACE using namespace sack::PSI::listbox;
#   define _LISTBOX_NAMESPACE namespace listbox {
#   define _LISTBOX_NAMESPACE_END }
#   define USE_LISTBOX_NAMESPACE using namespace listbox;
#   define USE_PSI_LISTBOX_NAMESPACE using namespace sack::PSI::listbox;
#   define _SCROLLBAR_NAMESPACE namespace scrollbar {
#   define _SCROLLBAR_NAMESPACE_END }
#   define USE_SCROLLBAR_NAMESPACE using namespace scrollbar;
#   define USE_PSI_SCROLLBAR_NAMESPACE using namespace sack::PSI::scrollbar;
#   define _SHEETS_NAMESPACE namespace sheet_control {
#   define _SHEETS_NAMESPACE_END }
#   define USE_SHEETS_NAMESPACE using namespace sheet_control;
#   define USE_PSI_SHEETS_NAMESPACE using namespace sack::PSI::sheet_control;
#   define _MOUSE_NAMESPACE namespace _mouse {
#   define _MOUSE_NAMESPACE_END }
#   define USE_MOUSE_NAMESPACE using namespace _mouse;
#   define USE_PSI_MOUSE_NAMESPACE using namespace sack::PSI::_mouse;
#   define _XML_NAMESPACE namespace xml {
#   define _XML_NAMESPACE_END }
#   define USE_XML_NAMESPACE using namespace xml;
#   define USE_PSI_XML_NAMESPACE using namespace sack::PSI::xml;
#   define _PROP_NAMESPACE namespace properties {
#   define _PROP_NAMESPACE_END }
#   define USE_PROP_NAMESPACE using namespace properties;
#   define USE_PSI_PROP_NAMESPACE using namespace sack::PSI::properties;
#   define _CLOCK_NAMESPACE namespace clock {
#   define _CLOCK_NAMESPACE_END }
#   define USE_CLOCK_NAMESPACE using namespace clock;
#   define USE_PSI_CLOCK_NAMESPACE using namespace sack::PSI::clock;
#else
#define PSI_NAMESPACE SACK_NAMESPACE
#define _PSI_NAMESPACE
#define PSI_NAMESPACE_END SACK_NAMESPACE_END
#define USE_PSI_NAMESPACE
#   define _PSI_INTERFACE_NAMESPACE
#   define _PSI_INTERFACE_NAMESPACE_END
#   define _BUTTON_NAMESPACE
#   define _BUTTON_NAMESPACE_END
#   define USE_BUTTON_NAMESPACE
#   define USE_PSI_BUTTON_NAMESPACE
#   define _COLORWELL_NAMESPACE
#   define _COLORWELL_NAMESPACE_END
#   define USE_COLORWELL_NAMESPACE
#   define USE_PSI_COLORWELL_NAMESPACE
#   define _MENU_NAMESPACE
#   define _MENU_NAMESPACE_END
#   define USE_MENU_NAMESPACE
#   define USE_PSI_MENU_NAMESPACE
#   define _TEXT_NAMESPACE
#   define _TEXT_NAMESPACE_END
#   define USE_TEXT_NAMESPACE
#   define USE_PSI_TEXT_NAMESPACE
#   define _EDIT_NAMESPACE
#   define _EDIT_NAMESPACE_END
#   define USE_EDIT_NAMESPACE
#   define USE_PSI_EDIT_NAMESPACE
#   define _SLIDER_NAMESPACE
#   define _SLIDER_NAMESPACE_END
#   define USE_SLIDER_NAMESPACE
#   define USE_PSI_SLIDER_NAMESPACE
#   define _FONTS_NAMESPACE
#   define _FONTS_NAMESPACE_END
#   define USE_FONTS_NAMESPACE
#   define USE_PSI_FONTS_NAMESPACE
#   define _COMBOBOX_NAMESPACE
#   define _COMBOBOX_NAMESPACE_END
#   define USE_COMBOBOX_NAMESPACE
#   define USE_PSI_COMBOBOX_NAMESPACE
#   define _LISTBOX_NAMESPACE
#   define _LISTBOX_NAMESPACE_END
#   define USE_LISTBOX_NAMESPACE
#   define USE_PSI_LISTBOX_NAMESPACE
#   define _SCROLLBAR_NAMESPACE
#   define _SCROLLBAR_NAMESPACE_END
#   define USE_SCROLLBAR_NAMESPACE
#   define USE_PSI_SCROLLBAR_NAMESPACE
#   define _SHEETS_NAMESPACE
#   define _SHEETS_NAMESPACE_END
#   define USE_SHEETS_NAMESPACE
#   define USE_PSI_SHEETS_NAMESPACE
#   define _MOUSE_NAMESPACE
#   define _MOUSE_NAMESPACE_END
#   define USE_MOUSE_NAMESPACE
#   define USE_PSI_MOUSE_NAMESPACE
#   define _XML_NAMESPACE
#   define _XML_NAMESPACE_END
#   define USE_XML_NAMESPACE
#   define USE_PSI_XML_NAMESPACE
#   define _PROP_NAMESPACE
#   define _PROP_NAMESPACE_END
#   define USE_PROP_NAMESPACE
#   define USE_PSI_PROP_NAMESPACE
#   define _CLOCK_NAMESPACE
#   define _CLOCK_NAMESPACE_END
#   define USE_CLOCK_NAMESPACE
#   define USE_PSI_CLOCK_NAMESPACE
#endif
#define PSI_BUTTON_NAMESPACE PSI_NAMESPACE _BUTTON_NAMESPACE
#define PSI_BUTTON_NAMESPACE_END _BUTTON_NAMESPACE_END PSI_NAMESPACE_END
#define PSI_COLORWELL_NAMESPACE PSI_NAMESPACE _COLORWELL_NAMESPACE
#define PSI_COLORWELL_NAMESPACE_END _COLORWELL_NAMESPACE_END PSI_NAMESPACE_END
#define PSI_MENU_NAMESPACE PSI_NAMESPACE _MENU_NAMESPACE
#define PSI_MENU_NAMESPACE_END _MENU_NAMESPACE_END PSI_NAMESPACE_END
#define PSI_TEXT_NAMESPACE PSI_NAMESPACE _TEXT_NAMESPACE
#define PSI_TEXT_NAMESPACE_END _TEXT_NAMESPACE_END PSI_NAMESPACE_END
#define PSI_EDIT_NAMESPACE PSI_NAMESPACE _EDIT_NAMESPACE
#define PSI_EDIT_NAMESPACE_END _EDIT_NAMESPACE_END PSI_NAMESPACE_END
#define PSI_SLIDER_NAMESPACE PSI_NAMESPACE _SLIDER_NAMESPACE
#define PSI_SLIDER_NAMESPACE_END _SLIDER_NAMESPACE_END PSI_NAMESPACE_END
#define PSI_FONTS_NAMESPACE PSI_NAMESPACE _FONTS_NAMESPACE
#define PSI_FONTS_NAMESPACE_END _FONTS_NAMESPACE_END PSI_NAMESPACE_END
#define PSI_COMBOBOX_NAMESPACE PSI_NAMESPACE _COMBOBOX_NAMESPACE
#define PSI_COMBOBOX_NAMESPACE_END _COMBOBOX_NAMESPACE_END PSI_NAMESPACE_END
#define PSI_LISTBOX_NAMESPACE PSI_NAMESPACE _LISTBOX_NAMESPACE
#define PSI_LISTBOX_NAMESPACE_END _LISTBOX_NAMESPACE_END PSI_NAMESPACE_END
#define PSI_SCROLLBAR_NAMESPACE PSI_NAMESPACE _SCROLLBAR_NAMESPACE
#define PSI_SCROLLBAR_NAMESPACE_END _SCROLLBAR_NAMESPACE_END PSI_NAMESPACE_END
#define PSI_SHEETS_NAMESPACE PSI_NAMESPACE _SHEETS_NAMESPACE
#define PSI_SHEETS_NAMESPACE_END _SHEETS_NAMESPACE_END PSI_NAMESPACE_END
#define PSI_MOUSE_NAMESPACE PSI_NAMESPACE _MOUSE_NAMESPACE
#define PSI_MOUSE_NAMESPACE_END _MOUSE_NAMESPACE_END PSI_NAMESPACE_END
#define PSI_XML_NAMESPACE PSI_NAMESPACE _XML_NAMESPACE
#define PSI_XML_NAMESPACE_END _XML_NAMESPACE_END PSI_NAMESPACE_END
#define PSI_PROP_NAMESPACE PSI_NAMESPACE _PROP_NAMESPACE
#define PSI_PROP_NAMESPACE_END _PROP_NAMESPACE_END PSI_NAMESPACE_END
#define PSI_CLOCK_NAMESPACE PSI_NAMESPACE _CLOCK_NAMESPACE
#define PSI_CLOCK_NAMESPACE_END _CLOCK_NAMESPACE_END PSI_NAMESPACE_END
#endif
#ifndef SOURCE_PSI2
#define SOURCE_PSI2
#endif
#ifndef __CONTROLS_DEFINED__
#define __CONTROLS_DEFINED__
//---------------------------------------------------------------
// PSI Version comments
//   1.1 )
//     - added PSI_VERSION so that after this required features
//       may be commented out...
//     - added fonts to common structure - controls and frames may define
//       frames an apply a scale factor to itself and or its children..
//
// copied from win.h distributed with lcc
//#define MF_BITMAP	4
//#define MF_CHECKED	8
//#define MF_DISABLED	2
//#define MF_ENABLED	0
//#define MF_GRAYED	1
//#define MF_MENUBARBREAK	32
//#define MF_MENUBREAK	64
//#define MF_OWNERDRAW	256
//#define MF_POPUP	16
//#define MF_SEPARATOR	0x800
//#define MF_STRING	0
//#define MF_UNCHECKED	0
//#define MF_DEFAULT	4096
//#define MF_SYSMENU	0x2000
//#define MF_HELP		0x4000
//#define MF_END	128
//#define MF_RIGHTJUSTIFY 0x4000
//#define MF_MOUSESELECT 0x8000
// duplicated from a section futher down...
//#define MF_BYCOMMAND	0
//#define MF_BYPOSITION	0x400
//#define MF_UNCHECKED	0
//#define MF_HILITE	128
//#define MF_UNHILITE	0
#ifndef MF_BYPOSITION
#define MF_BYPOSITION 0x400
#endif
#ifndef MF_BYCOMMAND
#define MF_BYCOMMAND 0
#endif
#ifndef MF_HILITE
#define MF_HILITE 0x80
#endif
#ifndef MF_UNHILITE
#define MF_UNHILITE 0
#endif
#ifndef MF_BITMAP
#define MF_BITMAP 4
#endif
#ifndef MF_CHECKED
#define MF_CHECKED 8
#endif
#ifndef MF_DISABLED
#define MF_DISABLED 0x0010
#endif
#ifndef MF_ENABLED
#define MF_ENABLED 0
#endif
#ifndef MF_GRAYED
#define MF_GRAYED 1
#endif
#ifndef MF_MENUBARBREK
#define MF_MENUBARBREK 0x0020
#endif
#ifndef MF_MENUBREAK
#define MF_MENUBREAK 0x0040
#endif
#ifndef MF_OWNERDRAW
#define MF_OWNERDRAW 0x0100
#endif
#ifndef MF_POPUP
#define MF_POPUP 0x0010
#endif
#ifndef MF_SEPARATOR
#define MF_SEPARATOR 0x0800
#endif
#ifndef MF_STRING
#define MF_STRING 0
#endif
#ifndef MF_UNCHECKED
/* Menu item is not checked. */
#define MF_UNCHECKED 0
#endif
#ifndef MF_DEFAULT
#define MF_DEFAULT 0x1000
#endif
#ifndef MF_SYSMENU
/* Not sure what menu flag SYSMENU is for */
#define MF_SYSMENU 0x2000
#endif
/*
#ifndef MF_
#define MF_ 0
#endif
*/
// $Log: $
/* It's called System Abstraction Component Kit - that is almost
   what it is, self descriptively, but that's not what it
   entirely. It's more appropriately just a sack-o-goodies. A
   grab-bag of tidbits. The basic aggregation of group of
   objects in sack is bag. Bag contains everything that is not
   graphic.
   It abstracts loading external libraries (.dll and .so shared
   objects) so applications can be unbothered by platform
   details.
   It abstracts system features like threads into a consistent
   API.
   It abstracts system shared memory allocation and management,
   does have a custom allocation and release method, but
   currently falls back to using malloc and free.
   It abstracts access to system file system browsing; getting
   the contents of directories.
   It abstracts creating external processes, and the use of
   standard input-output methods to communicate with those
   tasks.
   It has a custom timer implementation using a thread and
   posting timer events as calls to user callbacks.
   It contains a variety of structures to manage data from
   lists, stack and queues to complex linked list of slab
   allocated structures, and management for text as words and
   phrases.
   It contains an event based networking system, using an
   external thread to coordinate network socket events.
   It contains methods to work with images.
   It contains methods to display images on a screen. This is
   also a system abstraction point, since to put a display out
   under Linux and Windows is entirely different.
   It contains a control system based on the above images and
   display, managing events to controls as user event callbacks.
   It contains a method of registering values, code, and even
   structures, and methods to browse and invoke registered code,
   create registered structures, and get back registered values.
   It contains a SQL abstraction that boils SQL communication to
   basically 2 methods, Commands and Queries.
   It provides application logging features, for debug, and
   crash diagnostics. This is basically a single command
   'lprintf'.
   It provides a vector and matrix library for 3D and even 4D
   graphics projects.
   Beyond that - it uses libpng, jpeg, and freetype for dealing
   with images. These are included in this one package for
   windows where they are not system libraries. Internal are up
   to date as of march 2010. Also includes sqlite. All of these
   \version compile as C++ replacing extern "C"{} with an
   appropriate namespace XXX {}.
   Example
   The current build system is CMake. Previously I had a bunch
   of makefiles, but then required gnu make to compile with open
   watcom, with cmake, the correct makefiles appropriate for
   each package is generated. Visual studio support is a little
   lacking in cmake. So installed output should be compatible
   with cmake find XXX.
   <code>
   PROJECT( new_project )
   ADD_EXECTUABLE( my_program my_source.c )
   LINK_TARGET_LIBRARIES( my_program ${SACK_LIBRARY} )
   </code>
   The problem with this... depends on the mode of sack being
   built against... maybe I should have a few families of
   compile-options and link libraries.
   Remarks
   If sack is built 'monolithic' then everything that is any
   sort of library is compiled together.
   If sack is not built monolithic, then it produces
     * \  bag &#45; everything that requires no system display,
       it is all the logic components for lists, SQL, processes,
       threads, networking
       * ODBC is currently linked here, so unixodbc or odbc32
         will be required as appropriate. Considering moving SQL
         entirely to a seperate module, but the core library can take
         advantage options, which may require SQL.
     * \  bag.external &#45; external libraries zlib, libpng,
       jpeg, freetype.
     * bag.sqlite3.external &#45; external sqlite library, with
       sqlite interface structure. This could be split to be just
       the sqlite interface, and link to a system sqlite library.
     * bag.image &#45; library that provides an image namespace
       interface.
     * bag.video &#45; library that provides a render namespace
       interface. Windows system only. Provides OpenGL support for
       displays also.
     * bag.display.image &#45; a client library that
       communicates to a remote image namespace interface.
     * bag.image.video &#45; a client library that communicates
       to a remote render namespace interface.
     * bag.display &#45; a host library that provides window
       management for render interface, which allows the application
       multliple windows. bag.display was built against SDL, and SDL
       only supplies a single display surface for an application, so
       popup dialogs and menus needed to be tracked internally.
       Bag.display can be loaded as a display service, and shared
       between multiple applications. SDL Can provide OpenGL support
       for render interface also. This can be mounted against
       bag.video also, for developing window support. This has
       fallen by the wayside... and really a display interface
       should be provided that can just open X displays directly to
       copy <link sack::image::Image, Images> to.
     * bag.psi &#45; provides the PSI namespace.                      */
SACK_NAMESPACE
/* PSI is Panther's Slick Interface.
   This is a control library which handles custom controls and
   regions within a form. This isn't a window manager.
   PSI_CONTROL is the primary structure that this uses. It
   esists as a pointer to a structure, the content of which
   should never be accessed by the real world. For purposes of
   documentation these structures (in controlstruc.h) are
   presented, but they are inaccessable from outside of SACK
   itself, and will not be provided in the SDK.
   A PSI_CONTROL can represent a 'Frame' which contains other
   controls. A Frame owns a PRENDERER which it uses to present
   its content to the display. A frame can have an outside
   border, and provides the ability to click on the border and
   resize the form. The frame can use a custom image, which will
   be automatically portioned up and used as corner pieces, edge
   pieces, and may automatically set the default background
   color for forms. The frame draws directly on the Image from
   the PRENDERER, and all controls know only their image.
   Controls are based on sub-images on the frame's displayed
   image, so when they draw they are drawing directly on the
   buffer targeted to the display. The image library prohibits
   any operations that go outside the bounds of a sub-image;
   though, the user can request the color buffer pointer from an
   image, and may draw directly anywhere on that surface.
   Controls are implemented as a pair of sub-images on the color
   buffer of the renderer. The pair is the image containing the
   border of the control, and a sub-image inside that
   representing the drawable area of a control. When created,
   controls are always sized including their frame, this allow
   positioning controls inside a frame without regard to how
   much extra space might have been added. The size of the Frame
   control outside, is handled differently, and is created with
   the size of the inside of the control. The area of the render
   surface is expanded outside this. There are BorderOptionTypes
   that can control whether the border on the frame is handled
   as an expansion or not.
   Controls are all drawn using an internal table of colors
   which can be index using ControlColorTypes with SetBaseColor
   and GetBaseColor.
   If the fancy border frame image is used for a control, then
   the color of the center pixel is set into the NORMAL color
   index.
   What else can I say about controls...
   Any control can contain any other control, but there is a
   specific container type Frame that is commonly used for
   dialogs. The top level control can display on a renderer. If
   a sub-control is told to show, then it is divorced from and
   opened in a new popup renderer.
   History
   Control registration was done original by filling in a
   CONTROL_REGISTRATION structure, and passing that structure to
   PSI to register. This method is still available, and is
   certainly more straight forward method of use, but it's not
   the easier method or the current method.
   Currently, a registration structure is still used, but only
   the first few elements are actually filled out, the functions
   to handle a control's events are declared by fancy macros.
   This relies on the deadstart features of compiler working,
   but there are fewer places to have to remember to make
   changes, and controls are much more straight forward to
   implement, and extend as required, without necessarily
   requiring everything to be done all at once. Methods
   registered this way MUST be static, otherwise compiler errors
   will result; they MUST have the correct return type for the
   method specified, and they must have the correct parameters.
   \Examples of each method supported will be provided with each
   method's documentation. These are nasty macros that insert a
   bit of magic code between the 'static int' and the parameters
   specified. The names of the parameter values to the callback
   are up to the user, but the types must match. This is a very
   exact method, that cannot be circumvented using bad
   typecasting.
   Example
   This is a custom control that shows red or green.
   <code lang="c++">
   struct control_data
   {
       // declare some data that you want to have associated with your control.
       CDATA color;
       uint32_t last_buttons; // used to track when a click happens
   };
   EasyRegisterControl( "simple", sizeof( struct ball_timer_data ) );
   // define the function called when a new 'simple' control is created.
   static int OnCreateCommon( "simple" )( PSI_CONTROL pc )
   {
       MyValidatedControlData( struct control_data*, my_data, pc );
       if( my_data )
       {
           // assign a color to start
           my_data-\>color = BASE_COLOR_RED;
           return 1;
       }
       return 0;
   }
   // define a method to draw the control
   static int OnDrawCommon( "simple" )( PSI_CONTROL pc )
   {
       MyValidatedControlData( struct control_data*, my_data, pc );
       if( my_data )
       {
           Image image = GetControlSufrace( pc );
           BlatColor( image, my_data-\>color );
           return 1;  // return that the draw happened.
       }
       return 0;  // return no draw - prevents update.
   }
   // define a handler when the simple control is clicked.
   static int OnMouseCommon( "simple" )( PSI_CONTROL pc, int32_t x, int32_t y, uint32_t b )
   {
   </code>
   <code>
       MyValidatedControlData( struct control_data*, my_data, pc );
       // this checks to see if any mouse button goes down
       if( MAKE_NEWBUTTON( b, my_data-\>last_buttons ) )
       {
           if( my_data-\>color == BASE_COLOR_RED )
               my_data-\>color = BASE_COLOR_GREEN;
           else
               my_data-\>color = BASE_COLOR_RED;
           // tell the control to update.
           SmudgeCommon( pc );
       }
       // save this button state as the prior button state for future checks
       my_data-\>last_buttons = b;
   </code>
   <code lang="c++">
   }
   </code>
   See Also
   OnCreateCommon
   OnDrawCommon
   OnMouseCommon
   OnKeyCommon
   OnCommonFocus
   OnDestroyCommon
   \-- Less common
   OnMoveCommon
   OnSizeCommon
   OnMotionCommon
   OnHideCommon
   OnRevealCommon
   OnPropertyEdit
   OnPropertyEditOkay
   OnPropertyEditCancel
   OnPropertyEditDone
   \--- Much Less used
   OnEditFrame                                                                           */
_PSI_NAMESPACE
// this was never implemented.
#define MK_PSI_VERSION(ma,mi)  (((ma)<<8)|(mi))
// this was never implemented.
#define PSI_VERSION            MK_PSI_VERSION(1,1)
// this was never implemented.
#define REQUIRE_PSI(ma,mi)    ( PSI_VERSION >= MK_PSI_VERSION(ma,mi) )
#ifdef PSI_SOURCE
#define PSI_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define PSI_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
// Control callback functions NEED to be declared in the same source as what
// created the control/frame...
#ifdef SOURCE_PSI2
	  /*PSI_PROC( PSI_CONTROL, Make##name )( PSI_CONTROL pFrame, int attr */
	 /*, int x, int y, int w, int h*/
#define CONTROL_PROC( name,_args )	  PSI_PROC( PSI_CONTROL, Get##name##PropertyPage )( PSI_CONTROL pc );	 PSI_PROC( void, Apply##name##PropertyPage )( PSI_CONTROL pc, PSI_CONTROL page );    PSI_PROC( int, Config##name)( PSI_CONTROL )
	  /*PSI_PROC( PSI_CONTROL, Make##name )( PSI_CONTROL pFrame, int attr */
	/*, int x, int y, int w, int h  */
#define CAPTIONED_CONTROL_PROC( name,_args )	  PSI_PROC( PSI_CONTROL, Get##name##PropertyPage )( PSI_CONTROL pc );	 PSI_PROC( void, Apply##name##PropertyPage )( PSI_CONTROL pc, PSI_CONTROL page );    PSI_PROC( int, Config##name)( PSI_CONTROL )
#else
	  /*PSI_PROC( PSI_CONTROL, Make##name )( PSI_CONTROL pFrame, int attr*/
	 /*, int x, int y, int w, int h*/
#define CONTROL_PROC( name,_args )	  PSI_PROC( PSI_CONTROL, Get##name##PropertyPage )( PSI_CONTROL pc );	 PSI_PROC( void, Apply##name##PropertyPage )( PSI_CONTROL pc, PSI_CONTROL page );    PSI_PROC( PSI_CONTROL, Config##name)( PSI_CONTROL )
	  /*PSI_PROC( PSI_CONTROL, Make##name )( PSI_CONTROL pFrame, int attr */
	/*, int x, int y, int w, int h */
#define CAPTIONED_CONTROL_PROC( name,_args )	  PSI_PROC( PSI_CONTROL, Get##name##PropertyPage )( PSI_CONTROL pc );	 PSI_PROC( void, Apply##name##PropertyPage )( PSI_CONTROL pc, PSI_CONTROL page );    PSI_PROC( PSI_CONTROL, Config##name)( PSI_CONTROL )
#endif
enum {
    COMMON_PROC_ANY
     , COMMON_PROC_DRAW
     , COMMON_PROC_MOUSE
     , COMMON_PROC_KEY
};
#define RegisterControl(name)  do { extern CTEXTSTR  ControlMakeProcName_##name, ControlLoadProcName_##name;     RegisterControlProcName( ControlMakeProcName_##name     , (POINTER)Make##name            , ControlLoadProcName_##name     , (POINTER)Load##name );     } while(0)
#define RegisterFrame(name)       RegisterControlProcName( FrameProcName_##name     , (POINTER)Make##name      , (POINTER)Load##name )
//PSI_PROC( int, RegisterControlProcName )( CTEXTSTR name, POINTER MakeProc, POINTER LoadProc );
#ifndef CONTROL_SOURCE
#define MKPFRAME(hVid) (((uintptr_t)(hVid))|1)
//typedef POINTER PSI_CONTROL;
// any remaining code should reference PSI_CONTROL
//#define PCOMMON PSI_CONTROL
//#define PCONTROL PSI_CONTROL
#endif
typedef struct frame_border *PFrameBorder;
/* <combine sack::PSI>
   A handle to a PSI control or frame. The User's data is stored
   as the first member of this structure, so de-referencing the
   pointer twice gets the user data. All PSI functions work
   against PSI_CONTROL. Once upon a time this was just PSI_CONTROL,
   and so the methods for registering to handle events on the
   control still reference 'Common'.
   Remarks
   <code lang="c++">
   PSI_CONTROL control;
   POINTER user_data;
   user_data = *(POINTER*)control;
   </code>                                                       */
typedef struct psi_common_control_frame *PSI_CONTROL;
#define COMMON_BUTTON_WIDTH 55
#define COMMON_BUTTON_HEIGHT 19
#define COMMON_BUTTON_PAD 5
/* This enumeration defines flags that can be used to specify
   the border of controls.                                    */
enum BorderOptionTypes {
 // normal case needs to be 0 - but this is the thickest - go figure.
 BORDER_NORMAL        =     0,
 BORDER_NONE          =     3,
 /* The control has no border - this overrides all other styles;
    no caption, no border at all, the surface drawable area is
    the same as the control's outer area.                        */
 BORDER_THIN          =     1,
 BORDER_THINNER       =     2,
 BORDER_DENT          =     4,
 /* A dent is a 3 pixel line which is a thin etch-line that is 1
    step in, 1 across and 1 step up.                             */
 BORDER_THIN_DENT     =     5,
 BORDER_THICK_DENT    =     6,
 /* A thick etch line - that is a step in, and a step out, so the
    content is the same level as its parent.                      */
 BORDER_USER_PROC     =     7,
 /* External user code is used to draw the border when required
    use PSI_SetCustomBorder to set this border type...
    or define an OnBorderDraw and OnBorderMeasure routine for custom controls */
 // 16 different frame types standard...
 BORDER_TYPE          =  0x0f,
 BORDER_INVERT        =  0x80,
 /* This modifies styles like BORDER_BUMP to make them
    BORDER_DENT.                                       */
 BORDER_CAPTION       =  0x40,
 /* Border should include a space to show the text of the control
    as a caption.                                                 */
 BORDER_NOCAPTION     =  0x20,
 BORDER_INVERT_THINNER=  (BORDER_THINNER|BORDER_INVERT),
 BORDER_INVERT_THIN   =  (BORDER_THIN|BORDER_INVERT),
 /* It's a thin frame (3 pixels?) which is a descent step frame
    ... so instead of being stacked 'up' it's stacked 'down'.   */
 BORDER_BUMP          =  (BORDER_DENT|BORDER_INVERT),
 /* Draws a 3 pixel frame around a control - it is 1 up 1 acros
    and 1 down - a thin bump line.                              */
 BORDER_NOMOVE        =  0x0100,
 // well okay maybe these are border traits
 BORDER_CLOSE         =  0x0200,
 // can resize this window with a mouse
 BORDER_RESIZABLE     =  0x0400,
 // frame is on the surface of parent...
 BORDER_WITHIN        =  0x0800,
 // frame surface desires any unclaimed mouse calls
 BORDER_WANTMOUSE     =  0x1000,
 // frame wants exclusive application input.
 BORDER_EXCLUSIVE     =  0x2000,
 // marks controls which were done with 'create frame', and without BORDER_WITHIN
 BORDER_FRAME         =  0x4000,
 // scale does not apply to coordinates... otherwise it will be... by default controls are scalable.
 BORDER_FIXED         =  0x8000,
 // control is private to psi library(used for scrollbars in listboxes, etc) and as such does not call 'extra init'
 BORDER_NO_EXTRA_INIT           =  0x010000,
 //add a close button to the caption bar (has to have text, and a caption)
 BORDER_CAPTION_CLOSE_BUTTON    =  0x020000,
 //do not allow a close button on the caption bar (has to have text, and a caption)
 BORDER_CAPTION_NO_CLOSE_BUTTON =  0x040000,
 //add a close button to the caption bar (has to have text, and a caption)
 BORDER_CAPTION_CLOSE_IS_DONE   =  0x080000,
};
enum BorderAnchorFlags {
	BORDER_ANCHOR_TOP_MIN    = 1,
	BORDER_ANCHOR_TOP_CENTER = 2,
	BORDER_ANCHOR_TOP_MAX    = 3,
	BORDER_ANCHOR_TOP_MASK   = 3,
	BORDER_ANCHOR_TOP_SHIFT  = 0,
	BORDER_ANCHOR_LEFT_MIN    = 4,
	BORDER_ANCHOR_LEFT_CENTER = 8,
	BORDER_ANCHOR_LEFT_MAX    = 12,
	BORDER_ANCHOR_LEFT_MASK   = 0x0c,
	BORDER_ANCHOR_LEFT_SHIFT  = 2,
	BORDER_ANCHOR_RIGHT_MIN    = 0x10,
	BORDER_ANCHOR_RIGHT_CENTER = 0x20,
	BORDER_ANCHOR_RIGHT_MAX    = 0x30,
	BORDER_ANCHOR_RIGHT_MASK   = 0x30,
	BORDER_ANCHOR_RIGHT_SHIFT  = 4,
	BORDER_ANCHOR_BOTTOM_MIN    = 0x40,
	BORDER_ANCHOR_BOTTOM_CENTER = 0x80,
	BORDER_ANCHOR_BOTTOM_MAX    = 0xC0,
	BORDER_ANCHOR_BOTTOM_MASK   = 0xC0,
	BORDER_ANCHOR_BOTTOM_SHIFT  = 6
};
// these are the indexes for base color
enum ControlColorTypes {
 HIGHLIGHT           = 0,
 NORMAL              = 1,
 SHADE               = 2,
 SHADOW              = 3,
 TEXTCOLOR           = 4,
 CAPTION             = 5,
 CAPTIONTEXTCOLOR    = 6,
 INACTIVECAPTION     = 7,
 INACTIVECAPTIONTEXTCOLOR = 8,
 SELECT_BACK         = 9,
 SELECT_TEXT         = 10,
 EDIT_BACKGROUND     = 11,
 EDIT_TEXT           = 12,
 SCROLLBAR_BACK      = 13
};
// these IDs are used to designate default control IDs for
// buttons...
#define TXT_STATIC -1
#ifndef IDOK
#  define IDOK BTN_OKAY
#endif
#ifndef IDCANCEL
#  define IDCANCEL BTN_CANCEL
#endif
#ifndef IDIGNORE
#  define IDIGNORE BTN_IGNORE
#endif
#ifndef BTN_OKAY
#  define BTN_OKAY   1
#  define BTN_CANCEL 2
#  define BTN_IGNORE 3
#endif
#ifdef __cplusplus
namespace old_constants {
#endif
// enumeration for control->nType
//enum {
// master level control framing...
#define	CONTROL_FRAME  0
// master level control framing...
#define	CONTROL_FRAME_NAME  "Frame"
// returns a default control to user - type 1
#define  UNDEFINED_CONTROL  1
// returns a default control to user - type 1
#define  UNDEFINED_CONTROL_NAME  "Undefined"
#define  CONTROL_SUB_FRAME 2
#define  CONTROL_SUB_FRAME_NAME "SubFrame"
#define  STATIC_TEXT 3
#define  STATIC_TEXT_NAME "TextControl"
#define  NORMAL_BUTTON 4
#define  NORMAL_BUTTON_NAME "Button"
#define  CUSTOM_BUTTON 5
#define  CUSTOM_BUTTON_NAME "CustomDrawnButton"
#define  IMAGE_BUTTON 6
#define  IMAGE_BUTTON_NAME "ImageButton"
// also subtype radio button
#define  RADIO_BUTTON 7
// also subtype radio button
#define  RADIO_BUTTON_NAME "CheckButton"
#define  EDIT_FIELD 8
#define  EDIT_FIELD_NAME "EditControl"
#define  SLIDER_CONTROL 9
#define  SLIDER_CONTROL_NAME "Slider"
#define  LISTBOX_CONTROL 10
#define  LISTBOX_CONTROL_NAME "ListBox"
#define  SCROLLBAR_CONTROL 11
#define  SCROLLBAR_CONTROL_NAME "ScrollBar"
 // TBI (to be implemented)
#define  GRIDBOX_CONTROL  12
 // TBI (to be implemented)
#define  GRIDBOX_CONTROL_NAME  "Gridbox"
 // TBI (to be implemented)
#define  CONSOLE_CONTROL  13
 // TBI (to be implemented)
#define  CONSOLE_CONTROL_NAME  "Console"
#define  SHEET_CONTROL    14
#define  SHEET_CONTROL_NAME    "SheetControl"
#define  COMBOBOX_CONTROL 15
#define  COMBOBOX_CONTROL_NAME "Combo Box"
 // last known builtin control...
#define  BUILTIN_CONTROL_COUNT 16
 // should be sufficiently high as to not conflict with common controls
#define  USER_CONTROL   128
#ifdef __cplusplus
}
#endif
//};
_MENU_NAMESPACE
/* This is an item on a menu. (AppendMenuItem can return this I
   think)                                                       */
typedef struct menuitem_tag *PMENUITEM;
/* This is a popup menu or sub-menu. */
typedef struct menu_tag *PMENU;
/* <combine sack::PSI::popup::draw_popup_item_tag>
   \ \                                             */
typedef struct draw_popup_item_tag  DRAWPOPUPITEM;
/* <combine sack::PSI::popup::draw_popup_item_tag>
   \ \                                             */
typedef struct draw_popup_item_tag *PDRAWPOPUPITEM;
/* This is used when a custom drawn menu item is used. Allows
   user code to draw onto the menu.                           */
struct draw_popup_item_tag
{
   // ID param of append menu item
    uintptr_t psvUser;
    /* Optional states an item might be in. */
    /* <combine sack::containers::text::format_info_tag::flags@1>
       \ \                                                        */
    struct {
        /* Menu item is in a selected state. (Mouse Over) */
        BIT_FIELD selected : 1;
        /* Menu item has a checkmark on it. */
        BIT_FIELD checked  : 1;
    } flags;
    /* Define options which may be passed to measure an item or to
       have an item drawn.                                         */
    union {
        /* Information which should be filled in when measuring popup
           items.                                                     */
        /* <combine sack::PSI::popup::draw_popup_item_tag::union@1::measure@1>
           \ \                                                                 */
        struct {
            /* Height of the menu item. */
            /* Width of the menu item. */
            uint32_t width, height;
        } measure;
        /* Contains information passed when the draw is required. */
        /* <combine sack::PSI::popup::draw_popup_item_tag::union@1::draw@1>
           \ \                                                              */
        struct {
            /* x to draw into */
            /* y coordinate to start drawing at. */
            int32_t x, y;
            /* Width to draw. */
            /* Height to draw. */
            uint32_t width, height;
            /* Image to draw into. */
            Image image;
        } draw;
    };
};
_MENU_NAMESPACE_END
USE_MENU_NAMESPACE
//-------- Initialize colors to current windows colors -----------
PSI_PROC( PRENDER_INTERFACE, SetControlInterface)( PRENDER_INTERFACE DisplayInterface );
PSI_PROC( PIMAGE_INTERFACE, SetControlImageInterface )( PIMAGE_INTERFACE DisplayInterface );
PSI_PROC( void, AlignBaseToWindows)( void );
PSI_PROC( void, SetBaseColor )( INDEX idx, CDATA c );
PSI_PROC( CDATA, GetBaseColor )( INDEX idx );
PSI_PROC( void, SetControlColor )( PSI_CONTROL pc, INDEX idx, CDATA c );
PSI_PROC( CDATA, GetControlColor )( PSI_CONTROL pc, INDEX idx );
//-------- Frame and generic control functions --------------
#ifdef CONTROL_SOURCE
#define MKPFRAME(hvideo) ((PSI_CONTROL)(((uintptr_t)(hvideo))|1))
#endif
/* Update the border type of a control.  See BorderOptionTypes
   Parameters
   pc :      control to modify the border
   BorderType :  new border style
 */
PSI_PROC( void, SetCommonBorderEx )( PSI_CONTROL pc, uint32_t BorderType DBG_PASS);
/* Update the border type of a control.  See BorderOptionTypes
   Parameters
   pc :      control to modify the border
   b :  new border style
 */
#define SetCommonBorder(pc,b) SetCommonBorderEx(pc,b DBG_SRC)
#define SetControlBorder(pc,b) SetCommonBorderEx(pc,b DBG_SRC)
#define SetFrameBorder(pc,b) SetCommonBorderEx(pc,b DBG_SRC)
/* Update the border type of a control.  Border is drawn by routine
   Parameters
	pc :      control to modify the border draw routine
	proc:     draw routine; image parameter is the 'window' in which the surface is...
	measure_proc : get how much the outside border should be offset (or inside image should be inset)
 */
PSI_PROC( void, PSI_SetCustomBorder )( PSI_CONTROL pc, void (CPROC*proc)(PSI_CONTROL,Image)
                                      , void (CPROC*measure_proc)( PSI_CONTROL, int *x_offset, int *y_offset, int *right_inset, int *bottom_inset )
												 );
 // update to current border type drawing.
PSI_PROC( void, SetDrawBorder )( PSI_CONTROL pc );
PSI_PROC( PSI_CONTROL, CreateFrame)( CTEXTSTR caption, int x, int y
										, int w, int h
										, uint32_t BorderFlags
											  , PSI_CONTROL hAbove );
// 1) causes all updates to be done in video thread, otherwise selecting opengl context fails.
// 2) ...
PSI_PROC( void, EnableControlOpenGL )( PSI_CONTROL pc );
//PSI_PROC( void, SetFrameDraw )( PSI_CONTROL pc, void (CPROC*OwnerDraw)(PSI_CONTROL pc) );
//PSI_PROC( void, SetFrameMouse )( PSI_CONTROL pc, void (CPROC*OwnerMouse)(PSI_CONTROL pc, int32_t x, int32_t y, uint32_t b) );
// Control Init Proc is called each time a control is created
// a control may be created either with a 'make' routine
// or by loading a dialog resource.
#ifdef SOURCE_PSI2
typedef int (CPROC*ControlInitProc)( PSI_CONTROL, va_list );
#else
typedef int (CPROC*ControlInitProc)( uintptr_t, PSI_CONTROL, uint32_t ID );
#endif
/* \Internal event callback definition. After creation, an
   initializer is available to call on controls to pass
   \arguments to. This is more useful for loading from an XML
   \file where the control may have specified extra data.     */
typedef int (CPROC*FrameInitProc)( uintptr_t, PSI_CONTROL, uint32_t ID );
PSI_PROC( void, SetFrameInit )( PSI_CONTROL, ControlInitProc, uintptr_t );
PSI_PROC( CTEXTSTR, GetControlTypeName)( PSI_CONTROL pc );
// internal routine now exposed... results in a frame from a given
// renderer - a more stable solution than MKPFRAME which
// would require MUCH work to implement all checks everywhere...
PSI_PROC( PSI_CONTROL, CreateFrameFromRenderer )( CTEXTSTR caption
                                                         , uint32_t BorderTypeFlags
														 , PRENDERER pActImg );
/* Attach a frame to a renderer. Not sure which is sized to
   which if they are not the same size... probably the control
   is sized to the display.
   Parameters
   pcf :      control to attach to the display frame
   pActImg :  the display surface to use to show the control.
   Returns
   the control which was being attached to a display surface.  */
PSI_PROC( PSI_CONTROL, AttachFrameToRenderer )( PSI_CONTROL pcf, PRENDERER pActImg );
// any control on a frame may be passed, and
// the top level
PSI_PROC( PRENDERER, GetFrameRenderer )( PSI_CONTROL );
PSI_PROC( PSI_CONTROL, GetFrameFromRenderer )( PRENDERER renderer );
PSI_PROC( void, GetPhysicalCoordinate )( PSI_CONTROL relative_to, int32_t *_x, int32_t *_y, int include_surface );
//PSI_PROC( void, DestroyFrameEx)( PSI_CONTROL pf DBG_PASS );
#ifdef SOURCE_PSI2
#define DestroyFrame(pf) DestroyCommonEx( pf DBG_SRC )
#else
#define DestroyFrame(pf) DestroyControlEx( pf DBG_SRC )
#endif
PSI_PROC( int, SaveFrame )( PSI_CONTROL pFrame, CTEXTSTR file );
/* This is actually a load/save namespace. These functions are
   used to save and load frames and their layouts to and from
   XML.                                                        */
_XML_NAMESPACE
/* Unused. Please Delete. */
PSI_PROC( void, SetFrameInitProc )( PSI_CONTROL pFrame, ControlInitProc InitProc, uintptr_t psvInit );
/* Saves the current layout and controls of a frame. Can be
   recreated later with LoadXMLFrame.
   Parameters
   frame :  Frame to save with all of its contents.
   file\ :  filename to save XML frame into.                */
PSI_PROC( int, SaveXMLFrame )( PSI_CONTROL frame, CTEXTSTR file );
/* results with the frame and all controls created
   whatever extra init needs to be done... needs to be done
   if parent, use DisplayFrameOver().
                                                          If frame is specified in parameters, and is not NULL, then
                                                          this window is stacked against the other one so it is always
                                                          above the other window.
                                                          Parameters
                                                          file\ :     name of XML file to read and pass to ParseXMLFrame
                                                          frame :     frame to stack this frame against. (specify parent
                                                                      window.)
                                                          DBG_PASS :  passed to track allocation responsiblity.          */
	PSI_PROC( PSI_CONTROL, LoadXMLFrameEx )( CTEXTSTR file DBG_PASS );
	/* Handles recreating a frame from an XML description.
   Parameters
   buffer :    buffer to parse with XML frame loader
   size :      length of the buffer in bytes.
   DBG_PASS :  passed to track allocation responsiblity. */
PSI_PROC( PSI_CONTROL, ParseXMLFrameEx )( POINTER buffer, size_t size DBG_PASS );
/* <combine sack::PSI::xml::LoadXMLFrameEx@CTEXTSTR file>
   \ \                                                    */
PSI_PROC( PSI_CONTROL, LoadXMLFrameOverExx )( PSI_CONTROL frame, CTEXTSTR file, LOGICAL create DBG_PASS );
/* <combine sack::PSI::xml::LoadXMLFrameEx@CTEXTSTR file>
   \ \                                                    */
PSI_PROC( PSI_CONTROL, LoadXMLFrameOverEx )( PSI_CONTROL frame, CTEXTSTR file DBG_PASS );
/* <combine sack::PSI::xml::LoadXMLFrameOverEx@PSI_CONTROL@CTEXTSTR file>
   \ \                                                                    */
#define LoadXMLFrameOverOption(parent,file,create) LoadXMLFrameOverExx( parent,file,create DBG_SRC )
/* <combine sack::PSI::xml::LoadXMLFrameOverEx@PSI_CONTROL@CTEXTSTR file>
   \ \                                                                    */
#define LoadXMLFrameOver(parent,file) LoadXMLFrameOverEx( parent,file DBG_SRC )
/* <combine sack::PSI::xml::LoadXMLFrameEx@CTEXTSTR file>
   \ \                                                    */
#define LoadXMLFrame(file) LoadXMLFrameEx( file DBG_SRC )
/* <combine sack::PSI::xml::ParseXMLFrameEx@POINTER@uint32_t size>
   \ \                                                        */
#define ParseXMLFrame(p,s) ParseXMLFrameEx( (p),(s) DBG_SRC )
_XML_NAMESPACE_END
USE_XML_NAMESPACE
PSI_PROC( PSI_CONTROL, LoadFrameFromMemory )( POINTER info, uint32_t size, PSI_CONTROL hAbove, FrameInitProc InitProc, uintptr_t psv  );
PSI_PROC( PSI_CONTROL, LoadFrameFromFile )( FILE *in, PSI_CONTROL hAbove, FrameInitProc InitProc, uintptr_t psv  );
PSI_PROC( PSI_CONTROL, LoadFrame )( CTEXTSTR file, PSI_CONTROL hAbove, FrameInitProc InitProc, uintptr_t psv );
/* methods to edit frames at runtime. */
_PROP_NAMESPACE
/* Turns edit features of a frame on and off.
   Parameters
   pf :       frame to set the edit state of
   bEnable :  if TRUE, enable edit. if FALSE, disable edit.
   Example
   <code lang="c#">
   PSI_CONTROL frame = CreateFrame( "test", 0, 0, 100, 100, BORDER_NORMAL, NULL );
   EditFrame( frame );
   </code>
   This turns on edit features of a frame, right click you can
   add a new registered control, controls have hotspots on them,
   if you right click on a hotspot, then you can edit properties
   of that control like it's control ID.
   Note
   When LoadXMLFrame fails to find the file, a frame is created
   and edit enabled like this.                                                     */
PSI_PROC( void, EditFrame )( PSI_CONTROL pf, int bEnable );
_PROP_NAMESPACE_END
PSI_PROC( void, SetFrameEditDoneHandler )( PSI_CONTROL pc, void ( CPROC*editDone )( PSI_CONTROL pc ) );
PSI_PROC( void, SetFrameDetachHandler )( PSI_CONTROL pc, void ( CPROC*frameDetached )( PSI_CONTROL pc ) );
PSI_PROC( void, GetFramePosition )( PSI_CONTROL pf, int32_t *x, int32_t *y );
PSI_PROC( void, GetFrameSize )( PSI_CONTROL pf, uint32_t *w, uint32_t *h );
// results in the total width (left and right) of the frame
PSI_PROC( int, FrameBorderX )( PSI_CONTROL pc, uint32_t BorderFlags );
// results in left offset of the surface within the frame...
PSI_PROC( int, FrameBorderXOfs )( PSI_CONTROL pc, uint32_t BorderFlags );
// results in the total height (top and bottom) of frame (and caption)
PSI_PROC( int, FrameBorderY )( PSI_CONTROL pc, uint32_t BorderFlags, CTEXTSTR caption );
// results in top offset of the surface within the frame...
PSI_PROC( int, FrameBorderYOfs )( PSI_CONTROL pc, uint32_t BorderFlags, CTEXTSTR caption );
PSI_PROC( int, CaptionHeight )( PSI_CONTROL pf, CTEXTSTR text );
PSI_PROC( void, DisplayFrameOverOn )( PSI_CONTROL pc, PSI_CONTROL over, PRENDERER pActImg );
// stacks the physical display behind this other frame...
PSI_PROC( void, DisplayFrameUnder )( PSI_CONTROL pc, PSI_CONTROL under );
PSI_PROC( void, DisplayFrameOver )( PSI_CONTROL pc, PSI_CONTROL over );
PSI_PROC( void, DisplayFrameOn )( PSI_CONTROL pc, PRENDERER pActImg );
PSI_PROC( void, DisplayFrame)( PSI_CONTROL pf );
PSI_PROC( void, HideControl )( PSI_CONTROL pf );
PSI_PROC( LOGICAL, IsControlHidden )( PSI_CONTROL pc );
PSI_PROC( void, RevealCommonEx )( PSI_CONTROL pf DBG_PASS );
#define RevealCommon(pc) RevealCommonEx(pc DBG_SRC )
PSI_PROC( void, SizeCommon)( PSI_CONTROL pf, uint32_t w, uint32_t h );
#define SizeControl(c,x,y) SizeCommon((PSI_CONTROL)c,x,y)
#define SizeFrame(c,x,y) SizeCommon((PSI_CONTROL)c,x,y)
PSI_PROC( void, SizeCommonRel)( PSI_CONTROL pf, uint32_t w, uint32_t h );
#define SizeControlRel(c,x,y) SizeCommonRel((PSI_CONTROL)c,x,y)
#define SizeFrameRel(c,x,y) SizeCommonRel((PSI_CONTROL)c,x,y)
PSI_PROC( void, MoveCommon)( PSI_CONTROL pf, int32_t x, int32_t y );
#define MoveControl(c,x,y) MoveCommon((PSI_CONTROL)c,x,y)
#define MoveFrame(c,x,y) MoveCommon((PSI_CONTROL)c,x,y)
PSI_PROC( void, MoveCommonRel)( PSI_CONTROL pf, int32_t x, int32_t y );
#define MoveControlRel(c,x,y) MoveCommonRel((PSI_CONTROL)c,x,y)
#define MoveFrameRel(c,x,y) MoveCommonRel((PSI_CONTROL)c,x,y)
PSI_PROC( void, MoveSizeCommon)( PSI_CONTROL pf, int32_t x, int32_t y, uint32_t width, uint32_t height );
#define MoveSizeControl(c,x,y,w,h) MoveSizeCommon((PSI_CONTROL)c,x,y,w,h)
#define MoveSizeFrame(c,x,y,w,h) MoveSizeCommon((PSI_CONTROL)c,x,y,w,h)
PSI_PROC( void, MoveSizeCommonRel)( PSI_CONTROL pf, int32_t x, int32_t y, uint32_t width, uint32_t height );
#define MoveSizeControlRel(c,x,y,w,h) MoveSizeCommonRel((PSI_CONTROL)c,x,y,w,h)
#define MoveSizeFrameRel(c,x,y,w,h) MoveSizeCommonRel((PSI_CONTROL)c,x,y,w,h)
PSI_PROC( PSI_CONTROL, GetControl )( PSI_CONTROL pContainer, int ID );
#ifdef PSI_SOURCE
//#define GetControl(pc,id) GetControl( &((pc)->common),id)
#define GetControl(pc,id) GetControl( (PSI_CONTROL)(pc),id)
#endif
PSI_PROC( PSI_CONTROL, GetControlByName )( PSI_CONTROL pContainer, const char *ID );
	//PSI_PROC( PSI_CONTROL, GetControl)( PSI_CONTROL pf, int ID );
PSI_PROC( uintptr_t, GetControlUserData )( PSI_CONTROL pf );
#define GetFrameUserData(pf) GetControlUserData( (PSI_CONTROL)pf )
//#define GetCommonUserData(pf) GetControlUserData( (PSI_CONTROL)pf ) // deprecated delete soon
PSI_PROC( void, SetControlUserData )( PSI_CONTROL pf, uintptr_t psv );
#define SetFrameUserData(pf,d) SetControlUserData( (PSI_CONTROL)pf,d )
//#define SetCommonUserData(pf,d) SetControlUserData( (PSI_CONTROL)pf,d )  // deprecated delete soon
// Added methods for SACK->Other lnguge binding data; things
// that register 'ExtraInit' would use this... (Dekware may also need another)
// maybe; should register for a ID of indexed data per control...
PSI_PROC( int,       PSI_AddBindingData )(CTEXTSTR name);
PSI_PROC( uintptr_t, PSI_GetBindingData )(PSI_CONTROL pf, int binding );
PSI_PROC( void,      PSI_SetBindingData )(PSI_CONTROL pf, int binding, uintptr_t psv);
PSI_PROC( PFrameBorder, PSI_CreateBorder )( Image image, int width, int height, int anchors, LOGICAL defines_colors );
PSI_PROC( void, PSI_SetFrameBorder )( PSI_CONTROL pc, PFrameBorder border );
PSI_PROC( void, BeginUpdate )( PSI_CONTROL pc );
PSI_PROC( void, EndUpdate )( PSI_CONTROL pc );
// do the draw to the display...
PSI_PROC( void, UpdateFrameEx )( PSI_CONTROL pf
                                      , int x, int y
										 , int w, int h DBG_PASS );
#define UpdateFrame(pf,x,y,w,h) UpdateFrameEx(pf,x,y,w,h DBG_SRC )
/* \INTERNAL
   This is for internal organization, events and routines the
   mouse uses and features it adds to the PSI control... like
   issuing auto updates on unlock... well... it's internal
   anyhow                                                     */
_MOUSE_NAMESPACE
/* Releases a use. This is the oppsite of AddWait(). */
PSI_PROC( void, ReleaseCommonUse )( PSI_CONTROL pc );
/* This one is public, Sets the mouse position relative to a
   point in a frame.
   Parameters
   frame :  frame to position the mouse relative to
   x :      x of the mouse
   y :      y of the mouse                                   */
PSI_PROC( void, SetFrameMousePosition )( PSI_CONTROL frame, int x, int y );
/* Captures the mouse to the current control, it's like an
   OwnMouse for a control.                                 */
PSI_PROC( void, CaptureCommonMouse )( PSI_CONTROL pc, LOGICAL bCapture );
_MOUSE_NAMESPACE_END
USE_MOUSE_NAMESPACE
PSI_PROC( SFTFont, GetCommonFontEx )( PSI_CONTROL pc DBG_PASS );
#define GetCommonFont(pc) GetCommonFontEx( pc DBG_SRC )
#define GetFrameFont(pf) GetCommonFont((PSI_CONTROL)pf)
PSI_PROC( void, SetCommonFont )( PSI_CONTROL pc, SFTFont font );
#define SetFrameFont(pf,font) SetCommonFont((PSI_CONTROL)pf,font)
#define SetControlFont(pf,font) SetCommonFont((PSI_CONTROL)pf,font)
// setting scale of this control immediately scales all contained
// controls, but the control itself remains at it's current size.
PSI_PROC( void, SetCommonScale )( PSI_CONTROL pc, PFRACTION scale_x, PFRACTION scale_y );
PSI_PROC( void, GetCommonScale )( PSI_CONTROL pc, PFRACTION *sx, PFRACTION *sy );
// use scale_x and scale_y to scale a, b, results are done in a, b
void ScaleCoords( PSI_CONTROL pc, int32_t* a, int32_t* b );
// bOwn sets the ownership of mouse events to a control, where it remains
// until released.  Some other control has no way to steal it.
//PSI_PROC( void, OwnCommonMouse)( PSI_CONTROL pc, int bOwn );
//PSI_PROC void SetDefaultOkayID( PSI_CONTROL pFrame, int nID );
//PSI_PROC void SetDefaultCancelID( PSI_CONTROL pFrame, int nID );
//-------- Generic control functions --------------
// previously this was used;
PSI_PROC( PSI_CONTROL, GetCommonParent )( PSI_CONTROL pc );
#define GetCommonParent(pc)  GetParentControl(pc)
/* Return the container control of this control.
   NULL if there is no parent container. */
PSI_PROC( PSI_CONTROL, GetParentControl )( PSI_CONTROL pc );
/* Return the first control contained in the specified control.
 returns NULL if there is no child control
 <code>
 void enum_all_controls( PSI_CONTROL a_control )
 {
     PSI_CONTROL root_control = a_control;
	  PSI_CONTROL current_control;
	  while( current_control = GetParentControl( root_control ) )
	      root_control = current_control;
			for( current_control = GetFirstChildControl( root_control );
              current_control;
				  current_control = GetNextControl( current_control ) )
			{
             // hmm some sort of recursion on each of these too...
			}
 }
   </code>
 */
PSI_PROC( PSI_CONTROL, GetFirstChildControl )( PSI_CONTROL pc );
/* Return the next control after this one.
    returns NULL if there are no other controls after this one*/
PSI_PROC( PSI_CONTROL, GetNextControl )( PSI_CONTROL pc );
PSI_PROC( PSI_CONTROL, GetFrame)( PSI_CONTROL pc );
#define GetFrame(c) GetFrame((PSI_CONTROL)(c))
PSI_PROC( PSI_CONTROL, GetNearControl)( PSI_CONTROL pc, int ID );
PSI_PROC( void, GetCommonTextEx)( PSI_CONTROL pc, TEXTSTR  buffer, int buflen, int bCString );
#define GetControlTextEx(pc,b,len,str) GetCommonTextEx(pc,b,len,str)
#define GetControlText( pc, buffer, buflen ) GetCommonTextEx( (PSI_CONTROL)(pc), buffer, buflen, FALSE )
#define GetFrameText( pc, buffer, buflen ) GetCommonTextEx( (PSI_CONTROL)(pc), buffer, buflen, FALSE )
//PSI_PROC( void, SetCommonText )( PSI_CONTROL pc, CTEXTSTR text );
PSI_PROC( void, SetControlText )( PSI_CONTROL pc, CTEXTSTR text );
PSI_PROC( void, SetControlCaptionImage )( PSI_CONTROL pc, Image image, int pad );
PSI_PROC( void, SetFrameText )( PSI_CONTROL pc, CTEXTSTR text );
// this is used to set the height of the caption bar when OnDrawCaption is defined for a control
PSI_PROC( void, SetCaptionHeight )( PSI_CONTROL pc, int height );
// set focus to this control,
// it's container which needs to be updated
// is discoverable from the control itself.
PSI_PROC( void, SetCommonFocus)( PSI_CONTROL pc );
PSI_PROC( void, EnableControl)( PSI_CONTROL pc, int bEnable );
PSI_PROC( int, IsControlFocused )( PSI_CONTROL pc );
PSI_PROC( int, IsControlEnabled)( PSI_CONTROL pc );
PSI_PROC( struct physical_device_caption_button *, AddCaptionButton )( PSI_CONTROL frame, Image normal, Image pressed, Image highlight, int extra_pad, void (CPROC*event)(PSI_CONTROL) );
PSI_PROC( void, SetCaptionButtonImages )( struct physical_device_caption_button *, Image normal, Image pressed, Image rollover );
PSI_PROC( void, HideCaptionButton )( struct physical_device_caption_button * );
PSI_PROC( void, ShowCaptionButton )( struct physical_device_caption_button * );
PSI_PROC( void, SetCaptionButtonOffset )( PSI_CONTROL frame, int32_t x, int32_t y );
PSI_PROC( void, SetCaptionChangedMethod )(PSI_CONTROL frame, void (CPROC*_CaptionChanged)    (PSI_CONTROL));
/*
PSI_PROC( PSI_CONTROL, CreateCommonExx)( PSI_CONTROL pContainer
											  , CTEXTSTR pTypeName
											  , uint32_t nType
											  , int x, int y
											  , int w, int h
											  , uint32_t nID
											  , CTEXTSTR caption
											  , uint32_t ExtraBorderType
											  , PTEXT parameters
											  //, va_list args
												DBG_PASS );
#define CreateCommonEx(pc,nt,x,y,w,h,id,caption) CreateCommonExx(pc,NULL,nt,x,y,w,h,id,caption,0,NULL DBG_SRC)
#define CreateCommon(pc,nt,x,y,w,h,id,caption) CreateCommonExx(pc,NULL,nt,x,y,w,h,id,caption,0,NULL DBG_SRC)
*/
/* returns the TypeID of the control, this can be used to validate the data received from the control.*/
#undef ControlType
PSI_PROC( INDEX, ControlType)( PSI_CONTROL pc );
PSI_PROC( PSI_CONTROL, MakeControl )( PSI_CONTROL pContainer
										  , uint32_t nType
										  , int x, int y
										  , int w, int h
										  , uint32_t nID
										  //, ...
										  );
// init is called with an extra parameter on the stack
// works as long as we guarantee C stack call basis...
// the register_control structure allows this override.
PSI_PROC( PSI_CONTROL, MakeControlParam )( PSI_CONTROL pContainer
													  , uint32_t nType
													  , int x, int y
													  , int w, int h
													  , uint32_t nID
													  , POINTER param
													  );
// MakePrivateControl passes BORDER_NO_EXTRA_INIT...
PSI_PROC( PSI_CONTROL, MakePrivateControl )( PSI_CONTROL pContainer
													, uint32_t nType
													, int x, int y
													, int w, int h
													, uint32_t nID
													//, ...
													);
// MakePrivateControl passes BORDER_NO_EXTRA_INIT...
PSI_PROC( PSI_CONTROL, MakePrivateNamedControl )( PSI_CONTROL pContainer
													, CTEXTSTR pType
													, int x, int y
													, int w, int h
													, uint32_t nID
													);
PSI_PROC( PSI_CONTROL, MakeCaptionedControl )( PSI_CONTROL pContainer
													  , uint32_t nType
													  , int x, int y
													  , int w, int h
													  , uint32_t nID
													  , CTEXTSTR caption
													  //, ...
													  );
PSI_PROC( PSI_CONTROL, VMakeCaptionedControl )( PSI_CONTROL pContainer
														, uint32_t nType
														, int x, int y
														, int w, int h
														, uint32_t nID
														, CTEXTSTR caption
														//, va_list args
														);
PSI_PROC( PSI_CONTROL, MakeNamedControl )( PSI_CONTROL pContainer
												 , CTEXTSTR pType
												 , int x, int y
												 , int w, int h
												 , uint32_t nID
												 //, ...
												 );
PSI_PROC( PSI_CONTROL, MakeNamedCaptionedControlByName )( PSI_CONTROL pContainer
																	 , CTEXTSTR pType
																	 , int x, int y
																	 , int w, int h
																	 , CTEXTSTR pIDName
 // also pass this (if known)
                                                    , uint32_t nID
																	 , CTEXTSTR caption
																	 );
PSI_PROC( PSI_CONTROL, MakeNamedCaptionedControl )( PSI_CONTROL pContainer
															 , CTEXTSTR pType
															 , int x, int y
															 , int w, int h
															 , uint32_t nID
															 , CTEXTSTR caption
															 //, ...
															 );
PSI_PROC( PSI_CONTROL, VMakeControl )( PSI_CONTROL pContainer
											, uint32_t nType
											, int x, int y
											, int w, int h
											, uint32_t nID
											//, va_list args
											);
/*
 depricated
 PSI_PROC( PSI_CONTROL, CreateControl)( PSI_CONTROL pFrame
 , int nID
 , int x, int y
 , int w, int h
 , int BorderType
 , int extra );
 */
PSI_PROC( Image,GetControlSurface)( PSI_CONTROL pc );
// result with an image pointer, will sue the image passed
// as prior_image to copy into (resizing if nessecary), if prior_image is NULL
// then a new Image will be returned.  If the surface has not been
// marked as parent_cleaned, then NULL results, as no Original image is
// available.  The image passed as a destination for the surface copy is
// not released, it is resized, and copied into.  THe result may still be NULL
// the image will still be the last valid copy of the surface.
PSI_PROC( Image, CopyOriginalSurface )( PSI_CONTROL pc, Image prior_image );
// this allows the application to toggle the transparency
// characteristic of a control.  If a control is transparent, then it behaves
// automatically as one should using CopyOriginalSurface and restoring that surface
// before doing the draw.  The application does not need to concern itself
// with restoring the prior image, but it must also assume that the entire surface
// has been destroyed, and partial updates are not possible.
PSI_PROC( void, SetControlTransparent )( PSI_CONTROL pc, LOGICAL bTransparent );
#define SetCommonTransparent SetControlTransparent
PSI_PROC( void, OrphanCommonEx )( PSI_CONTROL pc, LOGICAL bDraw );
PSI_PROC( void, OrphanCommon )( PSI_CONTROL pc );
#define OrphanFrame(pf) OrphanCommonEx((PSI_CONTROL)pf, FALSE)
#define OrphanControl(pc) OrphanCommonEx((PSI_CONTROL)pc, FALSE)
#define OrphanControlEx(pc,d) OrphanCommonEx((PSI_CONTROL)pc, d)
PSI_PROC( void, AdoptCommonEx )( PSI_CONTROL pFoster, PSI_CONTROL pElder, PSI_CONTROL pOrphan, LOGICAL bDraw );
PSI_PROC( void, AdoptCommon )( PSI_CONTROL pFoster, PSI_CONTROL pElder, PSI_CONTROL pOrphan );
#define AdoptFrame(pff,pfe,pfo) AdoptCommonEx((PSI_CONTROL)pff,(PSI_CONTROL)pfe,(PSI_CONTROL)pfo, TRUE)
#define AdoptControl(pcf,pce,pco) AdoptCommonEx((PSI_CONTROL)pcf,(PSI_CONTROL)pce,(PSI_CONTROL)pco, TRUE)
#define AdoptControlEx(pcf,pce,pco,d) AdoptCommonEx((PSI_CONTROL)pcf,(PSI_CONTROL)pce,(PSI_CONTROL)pco, d)
PSI_PROC( void, SetCommonDraw )( PSI_CONTROL pf, int (CPROC*Draw)( PSI_CONTROL pc ) );
PSI_PROC( void, SetCommonDrawDecorations )( PSI_CONTROL pc, void(CPROC*DrawDecorations)(PSI_CONTROL,PSI_CONTROL) );
PSI_PROC( void, SetCommonKey )( PSI_CONTROL pf, int (CPROC*Key)(PSI_CONTROL,uint32_t) );
typedef int (CPROC*psi_mouse_callback)(PSI_CONTROL, int32_t x, int32_t y, uint32_t b );
PSI_PROC( void, SetCommonMouse)( PSI_CONTROL pc, psi_mouse_callback MouseMethod );
PSI_PROC( void, AddCommonDraw )( PSI_CONTROL pf, int (CPROC*Draw)( PSI_CONTROL pc ) );
PSI_PROC( void, AddCommonKey )( PSI_CONTROL pf, int (CPROC*Key)(PSI_CONTROL,uint32_t) );
PSI_PROC( void, AddCommonMouse)( PSI_CONTROL pc, int (CPROC*MouseMethod)(PSI_CONTROL, int32_t x, int32_t y, uint32_t b ) );
PSI_PROC( void, SetCommonAcceptDroppedFiles)( PSI_CONTROL pc, LOGICAL (CPROC*AcceptDroppedFilesMethod)(PSI_CONTROL, CTEXTSTR file, int32_t x, int32_t y ) );
PSI_PROC( void, AddCommonAcceptDroppedFiles)( PSI_CONTROL pc, LOGICAL (CPROC*AcceptDroppedFilesMethod)(PSI_CONTROL, CTEXTSTR file, int32_t x, int32_t y ) );
PSI_PROC( void, SetCommonSave)( PSI_CONTROL pc, void (CPROC*)(int PSI_CONTROL) );
#define SetControlSave(pc,mm)   SetCommonSave((PSI_CONTROL)pc,(void (CPROC*)(int, PSI_CONTROL))mm)
#define SetFrameSave(pc,mm)     SetCommonSave((PSI_CONTROL)pc,(void (CPROC*)(int, PSI_CONTROL))mm)
PSI_PROC( void, SetCommonLoad)( PSI_CONTROL pc, void (CPROC*)(int PSI_CONTROL) );
#define SetControlLoad(pc,mm)   SetCommonLoad((PSI_CONTROL)pc,(void (CPROC*)(int, PSI_CONTROL))mm)
#define SetFrameLoad(pc,mm)     SetCommonLoad((PSI_CONTROL)pc,(void (CPROC*)(int, PSI_CONTROL))mm)
// ---
// restore background restores the prior background of the control
// so that semi-opaque controls can draw over the correct surface.
PSI_PROC( void, RestoreBackground )( PSI_CONTROL pc, P_IMAGE_RECTANGLE r );
// --
// output to the physical surface the rectangle of the control's surface specified.
PSI_PROC( void, UpdateSomeControls )( PSI_CONTROL pc, P_IMAGE_RECTANGLE pRect );
PSI_PROC( void, SetUpdateRegionEx )( PSI_CONTROL pc, int32_t rx, int32_t ry, uint32_t rw, uint32_t rh DBG_PASS );
#define SetUpdateRegion(pc,x,y,w,h) SetUpdateRegionEx( pc,x,y,w,h DBG_SRC )
PSI_PROC( void, EnableCommonUpdates )( PSI_CONTROL frame, int bEnable );
#define EnableFrameUpdates(pf,e) EnableCommonUpdates( (PSI_CONTROL)pf, e )
#define EnableControlUpdates(pc,e) EnableCommonUpdates( (PSI_CONTROL)pc, e )
//PSI_PROC void SetControlKey( PSI_CONTROL pc, void (*KeyMethod)( PSI_CONTROL pc, int key ) );
PSI_PROC( void, UpdateCommonEx )( PSI_CONTROL pc, int bDraw DBG_PASS );
PSI_PROC( void, SmudgeCommonAreaEx )( PSI_CONTROL pc, P_IMAGE_RECTANGLE rect DBG_PASS );
#define SmudgeCommonArea( pc, area ) SmudgeCommonAreaEx( pc, area DBG_SRC )
PSI_PROC( void, SmudgeCommonEx )( PSI_CONTROL pc DBG_PASS );
#define SmudgeCommon(pc) SmudgeCommonEx( pc DBG_SRC )
//#ifdef SOURCE_PSI2
#define UpdateCommon(pc) SmudgeCommon(pc)
//#else
//#define UpdateCommon(pc) UpdateCommonEx(pc,TRUE DBG_SRC)
//#endif
//#define UpdateControlEx(pc,draw) UpdateCommonEx( (PSI_CONTROL)pc, draw )
//#define UpdateFrameEx(pc,draw)   UpdateCommonEx( (PSI_CONTROL)pc, draw )
PSI_PROC( void, UpdateControlEx)( PSI_CONTROL pc DBG_PASS );
#define UpdateControl(pc) UpdateControlEx( pc DBG_SRC )
PSI_PROC( int, GetControlID)( PSI_CONTROL pc );
PSI_PROC( void, SetControlID )( PSI_CONTROL pc, int ID );
PSI_PROC( void, DestroyCommonEx)( PSI_CONTROL *ppc DBG_PASS);
#define DestroyCommon(ppc) DestroyCommonEx(ppc DBG_SRC )
PSI_PROC( void, DestroyControlEx)( PSI_CONTROL pc DBG_PASS);
#define DestroyControl(pc) DestroyControlEx( pc DBG_SRC )
PSI_PROC( void, SetNoFocus)( PSI_CONTROL pc );
PSI_PROC( void *, ControlExtraData)( PSI_CONTROL pc );
_PROP_NAMESPACE
/* Show a dialog to edit a control's properties.
   Parameters
   control :  pointer to a control to edit the properties of.
   TODO
   Add an example image of this.                              */
PSI_PROC( int, EditControlProperties )( PSI_CONTROL control );
/* Shows a dialog to edit the properties of the frame (the outer
   container control.) Borders matter, title, size, position...
   TODO
   Add ability to specify parent frame for stacking.
   Parameters
   frame :  frame to edit properties of
   x :      x of the left of the edit dialog
   y :      y of the top of the edit dialog                      */
PSI_PROC( int, EditFrameProperties )( PSI_CONTROL frame, int32_t x, int32_t y );
_PROP_NAMESPACE_END
USE_PROP_NAMESPACE
//------ General Utilities ------------
// adds OK and Cancel buttons based off the
// bottom right of the frame, and when pressed set
// either done (cancel) or okay(OK) ...
// could do done&ok or just done - but we're bein cheesey
PSI_PROC( void, AddCommonButtonsEx)( PSI_CONTROL pf
                                , int *done, CTEXTSTR donetext
                                , int *okay, CTEXTSTR okaytext );
PSI_PROC( void, AddCommonButtons)( PSI_CONTROL pf, int *done, int *okay );
PSI_PROC( void, SetCommonButtons)( PSI_CONTROL pf, int *pdone, int *pokay );
PSI_PROC( void, InitCommonButton )( PSI_CONTROL pc, int *value );
/*
 * set callback which is invoked when a dialog's done/okay button is invoked or the dialog is closed.
 * This allows the application to wait asynchrously.
 *
 */
 // perhaps give a callback for within the loop?
PSI_PROC( void, PSI_HandleStatusEvent )( PSI_CONTROL pc, void (*f)( uintptr_t psv, PSI_CONTROL pc, int done, int okay ), uintptr_t userData );
/* DEPRECTATED - DO NOT USE */
 // perhaps give a callback for within the loop?
PSI_PROC( void, CommonLoop)( int *done, int *okay );
/* DEPRECTATED - DO NOT USE */
 // perhaps give a callback for within the loop?
PSI_PROC( void, CommonWait)( PSI_CONTROL pf );
/* DEPRECTATED - DO NOT USE */
 // a frame in edit mode, once edit mode done, continue
PSI_PROC( void, CommonWaitEndEdit)( PSI_CONTROL *pf );
/* DEPRECTATED - DO NOT USE */
  // internal function; posted to AddIdleProc Later...
PSI_PROC( void, ProcessControlMessages)(void);
/* Buttons. Clickable buttons, Radio buttons and checkboxes. */
_BUTTON_NAMESPACE
/* Symbol which can be used as an attribute of a button to not
   show the button border (custom drawn buttons)               */
#define BUTTON_NO_BORDER 0x0001
/* Defined function signature for the event attached to a button
   when the button is clicked.                                   */
typedef void (CPROC *ButtonPushMethod)(uintptr_t,PSI_CONTROL);
/* A function signature for the event attached to a "Custom
   Button" when it is drawn, this function is called.       */
typedef void (CPROC*ButtonDrawMethod)(uintptr_t psv, PSI_CONTROL pc);
CONTROL_PROC(Button,(CTEXTSTR,void (CPROC*PushMethod)(uintptr_t psv, PSI_CONTROL pc)
						  , uintptr_t Data));
// this method invokes the button push method...
PSI_PROC( void, InvokeButton )( PSI_CONTROL pc );
PSI_PROC( void, GetButtonPushMethod )( PSI_CONTROL pc, ButtonPushMethod *method, uintptr_t *psv );
PSI_PROC( PSI_CONTROL, SetButtonPushMethod )( PSI_CONTROL pc, ButtonPushMethod method, uintptr_t psv );
 // BUTTON_ flags...
PSI_PROC( PSI_CONTROL, SetButtonAttributes )( PSI_CONTROL pc, int attr );
PSI_PROC( PSI_CONTROL, SetButtonDrawMethod )( PSI_CONTROL pc, ButtonDrawMethod method, uintptr_t psv );
/* An all-in-one macro to create a Slider control, set the
   callback, and set direction options.
   Parameters
   f :            frame to create the button in
   x :            left coordinate of the control
   y :            top coordinate of the control
   w :            how wide the control is
   h :            how tall to make the control
   nID :          ID of the control (any numeric ID you want to
                  call it)
   a :            SliderDirection
   c :            caption \- text for the button.
   update_proc :  button click callback function.
                  ButtonPushMethod.
   user_data :    user data to pass to callback when it is
                  invoked.
   Returns
   PSI_CONTROL that is a button.                                */
#define MakeButton(f,x,y,w,h,id,c,a,p,d) SetButtonAttributes( SetButtonPushMethod( MakeCaptionedControl(f,NORMAL_BUTTON,x,y,w,h,id,c), p, d ), a )
PSI_CONTROL PSIMakeImageButton( PSI_CONTROL parent, int x, int y, int w, int h, uint32_t ID
							 , Image pImage
							 , void (CPROC*PushMethod)(uintptr_t psv, PSI_CONTROL pc)
							 , uintptr_t Data );
/* An all-in-one macro to create a Slider control, set the
   callback, and set direction options.
   Parameters
   f :            frame to create the button in
   x :            left coordinate of the control
   y :            top coordinate of the control
   w :            how wide the control is
   h :            how tall to make the control
   nID :          ID of the control (any numeric ID you want to
                  call it)
   a :            SliderDirection
   c :            caption \- text for the button.
   update_proc :  button click callback function.
                  ButtonPushMethod.
   user_data :    user data to pass to callback when it is
                  invoked.
   Returns
   PSI_CONTROL that is a button.                                */
#define MakeImageButton(f,x,y,w,h,id,c,a,p,d) SetButtonPushMethod( SetButtonAttributes( SetButtonImage( MakeControl(f,IMAGE_BUTTON,x,y,w,h,id),c),a),p,d)
PSI_PROC( PSI_CONTROL, SetButtonImage )( PSI_CONTROL pc, Image image );
// set up/down state images for button ( NORMAL_BUTTON or IMAGE_BUTTON_NAME )
PSI_PROC( PSI_CONTROL, SetButtonImages )( PSI_CONTROL pc, Image normal_image, Image pressed_image );
// set up/down state images for button ( NORMAL_BUTTON or IMAGE_BUTTON_NAME )
PSI_PROC( PSI_CONTROL, SetButtonSlicedImages )( PSI_CONTROL pc, SlicedImage normal_image, SlicedImage pressed_image );
// set up/down state images for button with mouse rollover ( NORMAL_BUTTON or IMAGE_BUTTON_NAME )
PSI_PROC( PSI_CONTROL, SetButtonRolloverImages )( PSI_CONTROL pc, Image pRollover, Image pRollover_pressed );
// set up/down state images for button with mouse rollover ( NORMAL_BUTTON or IMAGE_BUTTON_NAME )
PSI_PROC( PSI_CONTROL, SetButtonSlicedRolloverImages )( PSI_CONTROL pc, SlicedImage pRollover, SlicedImage pRollover_pressed );
// set an offset for button caption text (left/right bias for non-symetric backgrounds)
PSI_PROC( PSI_CONTROL, SetButtonTextOffset )( PSI_CONTROL pc, int32_t x, int32_t y );
// set up/down state images for button for focused state; overrides drawing focus underline.
//  ( NORMAL_BUTTON or IMAGE_BUTTON_NAME )
PSI_PROC( PSI_CONTROL, SetButtonFocusedImages )( PSI_CONTROL pc, Image pImage, Image pImage_pressed );
// set up/down state images for button for focused state; overrides drawing focus underline.
//  ( NORMAL_BUTTON or IMAGE_BUTTON_NAME )
PSI_PROC( PSI_CONTROL, SetButtonSlicedFocusedImages )( PSI_CONTROL pc, SlicedImage pImage, SlicedImage pImage_pressed );
/* An all-in-one macro to create a Slider control, set the
   callback, and set direction options.
   Parameters
   f :            frame to create the button in
   x :            left coordinate of the control
   y :            top coordinate of the control
   w :            how wide the control is
   h :            how tall to make the control
   nID :          ID of the control (any numeric ID you want to
                  call it)
   a :            SliderDirection
   c :            caption \- text for the button.
   update_proc :  button click callback function.
                  ButtonPushMethod.
   user_data :    user data to pass to callback when it is
                  invoked.
   Returns
   PSI_CONTROL that is a button.                                */
#define MakeCustomDrawnButton(f,x,y,w,h,id,a,dr,p,d) SetButtonPushMethod( SetButtonDrawMethod( SetButtonAttributes( MakeControl(f,CUSTOM_BUTTON,x,y,w,h,id),a ), dr, d ), p,d)
PSI_PROC( void, PressButton)( PSI_CONTROL pc, int bPressed );
PSI_PROC( void, SetButtonFont)( PSI_CONTROL pc, SFTFont font );
PSI_PROC( int, IsButtonPressed)( PSI_CONTROL pc );
PSI_PROC( PSI_CONTROL, SetButtonGroupID )(PSI_CONTROL pc, int nGroupID );
PSI_PROC( PSI_CONTROL, SetButtonCheckedProc )( PSI_CONTROL pc
														, void (CPROC*CheckProc)(uintptr_t psv, PSI_CONTROL pc)
															, uintptr_t psv );
/* Attributes that affect behavior of radio buttons. */
enum RadioButtonAttributes{
 RADIO_CALL_ALL       = 0,
 RADIO_CALL_CHECKED   = 1,
 RADIO_CALL_UNCHECKED = 2,
		RADIO_CALL_CHANGED   = (RADIO_CALL_CHECKED|RADIO_CALL_UNCHECKED)
};
/* An all-in-one macro to create a Slider control, set the
   callback, and set direction options.
   Parameters
   f :            frame to create the button in
   x :            left coordinate of the control
   y :            top coordinate of the control
   w :            how wide the control is
   h :            how tall to make the control
   nID :          ID of the control (any numeric ID you want to
                  call it)
   a :            SliderDirection
   c :            caption \- text for the button.
   update_proc :  button click callback function.
                  ButtonPushMethod.
   user_data :    user data to pass to callback when it is
                  invoked.
   Returns
   PSI_CONTROL that is a button.                                */
#define MakeRadioButton(f,x,y,w,h,id,t,gr,a,p,d) SetCheckButtonHandler( SetButtonGroupID( SetButtonAttributes( MakeCaptionedControl(f,RADIO_BUTTON,x,y,w,h,id,t), a ), gr ), p, d )
/* An all-in-one macro to create a Slider control, set the
   callback, and set direction options.
   Parameters
   f :            frame to create the button in
   x :            left coordinate of the control
   y :            top coordinate of the control
   w :            how wide the control is
   h :            how tall to make the control
   nID :          ID of the control (any numeric ID you want to
                  call it)
   a :            SliderDirection
   c :            caption \- text for the button.
   update_proc :  button click callback function.
                  ButtonPushMethod.
   user_data :    user data to pass to callback when it is
                  invoked.
   Returns
   PSI_CONTROL that is a button.                                */
#define MakeCheckButton(f,x,y,w,h,id,t,a,p,d) SetCheckButtonHandler( SetButtonAttributes( SetButtonGroupID( MakeCaptionedControl(f,RADIO_BUTTON,x,y,w,h,id,t),0),a),p,d)
PSI_PROC( PSI_CONTROL, SetRadioButtonGroup )( PSI_CONTROL, int group_id );
PSI_PROC( PSI_CONTROL, SetCheckButtonHandler )( PSI_CONTROL
															 , void (CPROC*CheckProc)(uintptr_t psv, PSI_CONTROL pc)
															 , uintptr_t psv );
PSI_PROC( int, GetCheckState)( PSI_CONTROL pc );
PSI_PROC( void, SetCheckState)( PSI_CONTROL pc, int nState );
// set the button's background color...
PSI_PROC( void, SetButtonColor )( PSI_CONTROL pc, CDATA color );
_BUTTON_NAMESPACE_END
USE_BUTTON_NAMESPACE
/* Static Text - this control just shows simple text on a
   dialog. Non selectable.
                                                          */
	_TEXT_NAMESPACE
	/* Attributes which can be passed to SetTextControlAttributes. */
	enum TextControlAttributes {
 TEXT_NORMAL     = 0x00,
 TEXT_VERTICAL   = 0x01,
 TEXT_CENTER     = 0x02,
 TEXT_RIGHT      = 0x04,
 TEXT_FRAME_BUMP = 0x10,
 /* frame of the text control is bump frame (1 up, 1 down thin
    frame)                                                     */
			TEXT_FRAME_DENT = 0x20,
 TEXT_SHADOW_TEXT = 0x40
	};
/* \ \
   Parameters
   pf :   frame to create the control in
   x :   left coordinate of control
   y :   top coordinate of the control
   w :   width of the control
   h :   height of the control
   ID :  an integer to identify the control
   text :   text to initialize the control with
   flags :   Attributes \- can be one or more of TextControlAttributes
   Returns
   a PSI_CONTROL which is an text control.               */
#define MakeTextControl( pf,x,y,w,h,id,text,flags ) SetTextControlAttributes( MakeCaptionedControl( pf, STATIC_TEXT, x, y, w,h, id, text ), flags )
/* Set the alignment of the text in the TextControl.
   Parameters
   pc :     a "TextControl" control.
   align :  A flag from TextControlAttributes        */
PSI_PROC( void, SetControlAlignment )( PSI_CONTROL pc, int align );
/* offset is a pixel specifier... +/- amount from it's normal
   position. returns if any text remains visible (true is
   visible, false is no longer visible, allowing upper level
   application to reset to 0 offset.
   The least amount and maximum effective amount can be received
   from GetControlTextOffsetMinMax.
   Parameters
   pc :      a Text control.
   offset :  offset to apply to the text.
   Returns
   TRUE if ti was a valid control, else FALSE.                   */
PSI_PROC( LOGICAL, SetControlTextOffset )( PSI_CONTROL pc, int offset );
/* Get the minimum and maximum offsets that can be applied to a
   text control based on its justification attributes before the
   text will not be drawn in the control. This can be used to
   marquee the text in from the left with the first update
   showing text, until the last bit of text scrolls out at the
   end.
   Parameters
   pc :          A STATIC_TEXT_NAME control.
   min_offset :  pointer to an integer that is filled with the
                 least amount that can be set for an offset
                 before text is not shown.
   max_offset :  pointer to an integer that is filled with the
                 most amount of offset that can be set before
                 text is not shown.
   Returns
   TRUE if a valid Text control was passed.
   FALSE otherwise.
   See Also
   SetControlTextOffset                                          */
PSI_PROC( LOGICAL, GetControlTextOffsetMinMax )( PSI_CONTROL pc, int *min_offset, int *max_offset );
CAPTIONED_CONTROL_PROC( TextControl, (void) );
/* Sets attributes of the text control.
   Parameters
   pc :     a STATIC_TEXT_NAME control.
   flags :  one or move values combined from
            TextControlAttributes.           */
PSI_PROC( PSI_CONTROL, SetTextControlAttributes )( PSI_CONTROL pc, int flags );
/* Sets the foreground and background of a text control.
   Parameters
   pc :    a Text control
   fore :  CDATA describing the foreground color to use
   back :  CDATA describing the background color to use. 0 is no
           color, and only the foreground text is output. See
           PutString.                                            */
PSI_PROC( void, SetTextControlColors )( PSI_CONTROL pc, CDATA fore, CDATA back );
_TEXT_NAMESPACE_END
USE_TEXT_NAMESPACE
/* Edit Control. This is a control that allows for text input. It
   also works as a drop file acceptor, and the name of the file
   or folder being dropped on it is entered as text.              */
	_EDIT_NAMESPACE
	/* Options which can be passed to the MakeEditControl macro. */
	enum EditControlOptions {
		EDIT_READONLY = 0x01,
		EDIT_PASSWORD = 0x02
	};
CAPTIONED_CONTROL_PROC( EditControl, (CTEXTSTR text) );
/* This enters the text into the edit field as if it were typed.
   This respects things like marked region auto delete. It's not
   the same as SetText, but will insert at the position the
   cursor is at.
   Parameters
   control :  control to type into
   text :     the text to type.                                  */
PSI_PROC( void, TypeIntoEditControl )( PSI_CONTROL control, CTEXTSTR text );
/* \ \
   Parameters
   f :   frame to create the control in
   x :   left coordinate of control
   y :   top coordinate of the control
   w :   width of the control
   h :   height of the control
   ID :  an integer to identify the control
   t :   text to initialize the control with
   a :   Attributes \- can be one or more of EditControlOptions
   Returns
   a PSI_CONTROL which is an edit control.               */
#define MakeEditControl(f,x,y,w,h,id,t,a) SetEditControlPassword( SetEditControlReadOnly( MakeCaptionedControl( f,EDIT_FIELD,x,y,w,h,id,t )	 , ( a & EDIT_READONLY)?TRUE:FALSE )	   , ( a & EDIT_PASSWORD)?TRUE:FALSE )
/* Sets an edit control into read only mode. This actually means
   that the user cannot enter data, and can only see what is in
   it. The difference between this and a text control is the
   border and background style.
   Parameters
   pc :         edit control to set readonly
   bReadOnly :  if TRUE, sets readonly. If false, clears readonly.
   Returns
   The PSI Control passed is returned, for nesting.                */
PSI_PROC( PSI_CONTROL, SetEditControlReadOnly )( PSI_CONTROL pc, LOGICAL bReadOnly );
/* If password style is set, then the text in the edit field is
   shown as ******.
   Parameters
   pc :         pointer to an edit control
   bPassword :  if TRUE, Sets style to password, if FALSE, clears
                password style.                                   */
PSI_PROC( PSI_CONTROL, SetEditControlPassword )( PSI_CONTROL pc, LOGICAL bPassword );
/* Set edit control selection paramets; for use with keyinto control to  clear
existing data and enter new data.
*/
PSI_PROC( void, SetEditControlSelection )( PSI_CONTROL pc, int start, int end );
//PSI_PROC( void, SetEditFont )( PSI_CONTROL pc, SFTFont font );
// Use GetControlText/SetControlText
_EDIT_NAMESPACE_END
USE_EDIT_NAMESPACE
/* Slider Control - this is a generic control that has a minimum
   value, and a maximum value, and a clickable knob that can
   select a value inbetween.
   the maximum value may be less than the minimum value, the
   current selected value will be between these.
   A horizontal slider, the value for minimum is on the left. A
   vertical slider, the value for minimum is on the bottom.      */
	_SLIDER_NAMESPACE
	/* These are values to pass to SetSliderOptions to control the
	   slider's direction.                                         */
	enum SliderDirection {
		SLIDER_HORIZ =1,
 /* Slider is horizontal. That is the knob moves left and right. The
		   value as minimum is at the left, and the value maximum is at
		   the right. numerically minimum can be more than maximum.         */
			SLIDER_VERT  =0
 /* Slider is vertical. That is the knob moves up and down. The
			   value as minimum is at the bottom, and the value maximum is
			   at the top. numerically minimum can be more than maximum.   */
	};
/* An all-in-one macro to create a Slider control, set the
   callback, and set direction options.
   Parameters
   pf :           frame to create the slider in
   x :            left coordinate of the control
   y :            top coordinate of the control
   w :            how wide the control is
   h :            how tall to make the control
   nID :          ID of the control (any numeric ID you want to
                  call it)
   opt :          SliderDirection
   update_proc :  callback to which gets called when the slider's
                  current value changes.
   user_data :    user data to pass to callback when it is
                  invoked.                                        */
#define MakeSlider(pf,x,y,w,h,nID,opt,updateproc,updateval) SetSliderOptions( SetSliderUpdateHandler( MakeControl(pf,SLIDER_CONTROL,x,y,w,h,nID ), updateproc,updateval ), opt)
//CONTROL_PROC( Slider, (
typedef void (CPROC*SliderUpdateProc)(uintptr_t psv, PSI_CONTROL pc, int val);
/* Set the new minimum, maximum and current for the slider.
   Parameters
   pc :       pointer to a slider control \- does nothing
              otherwise.
   min :      new minimum value for the mimimum amount to scale.
   current :  the current selected value. (should be between
              min\-max)
   max :      new maximum value which can be selected.           */
PSI_PROC( void, SetSliderValues)( PSI_CONTROL pc, int min, int current, int max );
/* Set's the slider's direction. (horizontal or vertical)
   Parameters
   pc :    slider control
   opts :  SliderDirection                                */
PSI_PROC( PSI_CONTROL, SetSliderOptions )( PSI_CONTROL pc, int opts );
/* Set a callback function to allow responding to changes in the
   slider.
   Parameters
   pc :                 pointer to a slider control
   SliderUpdateEvent :  callback to a user function when the
                        slider's value changes.
   psvUser :            data to pass to callback function when
                        invoked.                                 */
PSI_PROC( PSI_CONTROL, SetSliderUpdateHandler )( PSI_CONTROL pc, SliderUpdateProc, uintptr_t psvUser );
_SLIDER_NAMESPACE_END
USE_SLIDER_NAMESPACE
/* SFTFont Control - Really this is all about a font picker. The
   data used to create the font to show can be retreived to be
   saved for later recreation.                                 */
_FONTS_NAMESPACE
#ifndef FONT_RENDER_SOURCE
// types of data which may result...
//typedef struct font_data_tag *PFONTDATA;
//typedef struct render_font_data_tag *PRENDER_FONTDATA;
#endif
// common dialog to get a font which is then available for all
// Image text operations (PutString, PutCharacter)
// result font selection data can be resulted in the area referenced by
// the pointer, and size pointer...
//
// actual work done here for pUpdateFontFor(NULL) ...
// if pUpdateFontFor is not null, an apply button will appear, allowing the actual
// control to be updated to the chosen font.
//
/* scale_width, height magically apply... and are saved in the
   font data structure for re-rendering... if a font is rendered
   here the same exact font result will be acheived using
   RenderScaledFont( pdata )
   Parameters
   width_scale :   pointer to a scalar fraction to scale
                   the font by
   height_scale :  pointer to a scalar fraction to scale
                   the font by                                          */
PSI_PROC( SFTFont, PickScaledFontWithUpdate )( int32_t x, int32_t y
														, PFRACTION width_scale
														, PFRACTION height_scale
														, size_t *pFontDataSize
														 // resulting parameters for the data and size of data
														 // which may be passe dto RenderFontData
														, POINTER *pFontData
														, PSI_CONTROL pAbove
														, void (CPROC *UpdateFont)( uintptr_t psv, SFTFont font )
														, uintptr_t psvUpdate );
/* <combine sack::PSI::font::PickScaledFontWithUpdate@int32_t@int32_t@PFRACTION@PFRACTION@uint32_t*@POINTER *@PSI_CONTROL@void __cdecl *UpdateFont uintptr_t psv\, SFTFont font@uintptr_t>
   PickFontWithUpdate can be used to receive event notices when
   the font is changed, allowing immediately refresh using the
   changed font.
   Parameters
   x :              x screen position to put the dialog
   y :              y screen position to put the dialog
   pFontDataSize :  pointer to a 32 bit value to receive the font
                    data length. (can ba NULL to ignore)
   pFontData :      pointer to pointer to get font_data. (can ba
                    NULL to ignore)
   pAbove :         pointer to a frame to stack this one above.
   UpdateFont :     user callback passed the psvUpdate data and
                    the SFTFont that has been updated.
   psvUpdate :      user data to pass to use callback when
                    invoked.                                                                                                                                           */
PSI_PROC( SFTFont, PickFontWithUpdate )( int32_t x, int32_t y
										  , size_t *pFontDataSize
											// resulting parameters for the data and size of data
											// which may be passe dto RenderFontData
										  , POINTER *pFontData
										  , PSI_CONTROL pAbove
										  , void (CPROC *UpdateFont)( uintptr_t psv, SFTFont font )
												, uintptr_t psvUpdate );
// pick font for uses pickfontwithupdate where the update procedure
// sets the font on a control.
PSI_PROC( SFTFont, PickFontFor )( int32_t x, int32_t y
								  , size_t *pFontDataSize
									// resulting parameters for the data and size of data
                           // which may be passe dto RenderFontData
								  , POINTER *pFontData
									  , PSI_CONTROL pAbove
									  , PSI_CONTROL pUpdateFontFor );
/* Pick a font. This shows a dialog
   Parameters
   x :          screen location of the dialog
   y :          screen location of the dialog
   size :       pointer to a 32 bit value to receive the length
                of the font's data
   pFontData :  pointer to a pointer to be filled with the
                address of a FONTDATA describing the chosen font.
   pAbove :     parent window to make sure this is stacked above.
   Example
   <code lang="c++">
   POINTER data = NULL; // gets filled with font data - initialize to NULL or a previously returned FONTDATA.
   uint32_t data_length = 0; // result font data length.
   SFTFont font = PickFont( 0, 0, &amp;data_length, &amp;data, NULL );
   {
       // and like I really need to exemplify saving a block of data...
       \FILE *file = fopen( "font_description", "wb" );
       fwrite( data, 1, data_length, file );
       fclose( file );
   }
   </code>                                                                                                    */
PSI_PROC( SFTFont, PickFont)( int32_t x, int32_t y
                                  , size_t * size, POINTER *pFontData
								 , PSI_CONTROL pAbove );
/* <combine sack::PSI::font::PickScaledFontWithUpdate@int32_t@int32_t@PFRACTION@PFRACTION@uint32_t*@POINTER *@PSI_CONTROL@void __cdecl *UpdateFont uintptr_t psv\, SFTFont font@uintptr_t>
   \ \                                                                                                                                                                 */
#define PickScaledFont( x,y,ws,hs,size,fd,pa) PickScaledFontWithUpdate( x,y,ws,hs,size,fd,pa,NULL,0)
// this can take the resulting data from a pick font operation
// and result in a font... concerns at the moment are for cases
// of trying to use the same  string on different systems (different font
// locations) and getting a same (even similar?) result
//PSI_PROC( void, DestroyFont)( SFTFont *font );
// takes an already rendered font, and writes it to a file.
// at the moment this will not work with display services....
//PSI_PROC( void, DumpFontFile )( CTEXTSTR name, SFTFont font );
_FONTS_NAMESPACE_END
USE_FONTS_NAMESPACE
PSI_PROC( void, DumpFrameContents )( PSI_CONTROL pc );
//------- common between combobox and listbox
typedef struct listitem_tag *PLISTITEM;
typedef void (CPROC*SelectionChanged )( uintptr_t psvUser, PSI_CONTROL pc, PLISTITEM hli );
/* PopupEvent will be called just before the menu pops up, and just after it is hidden,
  LOGICAL parameter is TRUE on show, and FALSE on hide.*/
PSI_PROC( void, SetComboBoxPopupEventCallback )( PSI_CONTROL pc, void (CPROC*PopupEvent)( uintptr_t,LOGICAL ), uintptr_t psvEvent );
PSI_PROC( void, SetComboBoxSelectedItem )( PSI_CONTROL pc, PLISTITEM hli );
//------- ComboBox Control --------
_COMBOBOX_NAMESPACE
PSI_PROC( PLISTITEM, AddComboBoxItem )( PSI_CONTROL pc, CTEXTSTR text );
PSI_PROC( void, SetComboBoxSelChangeHandler )( PSI_CONTROL pc, SelectionChanged proc, uintptr_t psvUser );
PSI_PROC( void, ResetComboBox )( PSI_CONTROL pc );
_COMBOBOX_NAMESPACE_END
USE_COMBOBOX_NAMESPACE
//------- ListBox Control --------
_LISTBOX_NAMESPACE
#define LISTOPT_TREE   2
#define LISTOPT_SORT   1
CONTROL_PROC( ListBox, (void) );
#define MakeListBox(pf,x,y,w,h,nID,opt) SetListboxIsTree( MakeControl(pf,LISTBOX_CONTROL,x,y,w,h,nID), (opt & LISTOPT_TREE)?TRUE:FALSE )
PSI_PROC( PSI_CONTROL, SetListboxIsTree )( PSI_CONTROL pc, int bTree );
#define LISTBOX_SORT_NORMAL 1
#define LISTBOX_SORT_DISABLE 0
 // may someday add SORT_INVERSE?
PSI_PROC( PSI_CONTROL, SetListboxSort )( PSI_CONTROL pc, int bSortTrue );
PSI_PROC( PSI_CONTROL, SetListboxHorizontalScroll )( PSI_CONTROL pc, int bEnable, int max );
PSI_PROC( PSI_CONTROL, SetListboxMultiSelect )( PSI_CONTROL, int bEnable );
PSI_PROC( PSI_CONTROL, SetListboxMultiSelectEx )( PSI_CONTROL, int bEnable, int bLazy );
PSI_PROC( int, GetListboxMultiSelectEx )( PSI_CONTROL, int *multi, int *lazy );
 // returns only multiselect option, not lazy with multselect
PSI_PROC( int, GetListboxMultiSelect )( PSI_CONTROL );
PSI_PROC( void, ResetList)( PSI_CONTROL pc );
// tree lists might have mulptiple headers...
PSI_PROC( PLISTITEM, SetListboxHeaderEx )( PSI_CONTROL pc, const TEXTCHAR* text, int level );
PSI_PROC( PLISTITEM, SetListboxHeader )( PSI_CONTROL pc, const TEXTCHAR *text );
PSI_PROC( int, MeasureListboxItemEx )(PSI_CONTROL pc, CTEXTSTR item, int asLevel);
PSI_PROC( int, MeasureListboxItem )( PSI_CONTROL pc, CTEXTSTR item );
	// put an item at end of list.
PSI_PROC( PLISTITEM, AddListItem)( PSI_CONTROL pc, CTEXTSTR text );
PSI_PROC( PLISTITEM, AddListItemEx)( PSI_CONTROL pc, int nLevel, CTEXTSTR text );
// put an item after a known item... NULL to add at head of list.
PSI_PROC( PLISTITEM, InsertListItem)( PSI_CONTROL pc, PLISTITEM pAfter, CTEXTSTR text );
// put an item after a known item... NULL to add at head of list, and specify level if in a tree list
PSI_PROC( PLISTITEM, InsertListItemEx)( PSI_CONTROL pc, PLISTITEM pAfter, int nLevel, CTEXTSTR text );
// put an item at the end of a sub-group of the same level.
PSI_PROC( PLISTITEM, AddAfterListItemEx )(PSI_CONTROL pc, PLISTITEM pAfter, int nLevel, CTEXTSTR text);
PSI_PROC( PLISTITEM, AddAfterListItem )(PSI_CONTROL pc, PLISTITEM pAfter, CTEXTSTR text);
PSI_PROC( void, DeleteListItem)( PSI_CONTROL pc, PLISTITEM hli );
PSI_PROC( PLISTITEM, SetItemData)( PLISTITEM hli, uintptr_t psv );
PSI_PROC( uintptr_t, GetItemData)( PLISTITEM hli );
PSI_PROC( void, GetListItemText)( PLISTITEM hli, TEXTSTR buffer, int bufsize );
/* depreicated, use GetListItemText instead, please */
PSI_PROC( void, GetItemText)( PLISTITEM hli, int bufsize, TEXTSTR buffer );
#define GetItemText(hli,bufsize,buf) GetListItemText(hli,buf,bufsize)
PSI_PROC( void, SetItemText )( PLISTITEM hli, CTEXTSTR buffer );
PSI_PROC( PLISTITEM, GetSelectedItem)( PSI_CONTROL pc );
PSI_PROC( void, ClearSelectedItems )( PSI_CONTROL plb );
PSI_PROC( void, SetSelectedItem)( PSI_CONTROL pc, PLISTITEM hli );
PSI_PROC( void, SetItemSelected)( PSI_CONTROL pc, PLISTITEM hli, int bSelect );
PSI_PROC( void, SetCurrentItem)( PSI_CONTROL pc, PLISTITEM hli );
PSI_PROC( PLISTITEM, FindListItem)( PSI_CONTROL pc, CTEXTSTR text );
PSI_PROC( PLISTITEM, GetNthTreeItem )( PSI_CONTROL pc, PLISTITEM pli, int level, int idx );
PSI_PROC( PLISTITEM, GetNthItem )( PSI_CONTROL pc, int idx );
PSI_PROC( void, SetSelChangeHandler)( PSI_CONTROL pc, SelectionChanged proc, uintptr_t psvUser );
typedef void (CPROC*DoubleClicker)( uintptr_t psvUser, PSI_CONTROL pc, PLISTITEM hli );
PSI_PROC( void, SetDoubleClickHandler)( PSI_CONTROL pc, DoubleClicker proc, uintptr_t psvUser );
// if bopened - branch is being expanded, else it is being closed (collapsed)
typedef void (CPROC*ListItemOpened)( uintptr_t psvUser, PSI_CONTROL pc, PLISTITEM hli, LOGICAL bOpened );
PSI_PROC( void, SetListItemOpenHandler )( PSI_CONTROL pc, ListItemOpened proc, uintptr_t psvUser );
// returns the prior state of disabledness
PSI_PROC( int, DisableUpdateListBox )( PSI_CONTROL pc, LOGICAL bDisable );
// on right click down,up this proc is triggered...
PSI_PROC( void, SetItemContextMenu )( PLISTITEM pli, PMENU pMenu, void (CPROC*MenuProc)(uintptr_t, PLISTITEM, uint32_t menuopt ), uintptr_t psv );
PSI_PROC( int, OpenListItem )( PLISTITEM pli, int bOpen );
PSI_PROC( void, SetListBoxTabStopsEx )(PSI_CONTROL pc, int nLevel, int nStops, int* pStops);
PSI_PROC( void, SetListBoxTabStops )( PSI_CONTROL pc, int nStops, int *pStops );
PSI_PROC( void, EnumListItems )( PSI_CONTROL pc
										 , PLISTITEM pliStart
										 , void (CPROC *HandleListItem )(uintptr_t,PSI_CONTROL,PLISTITEM)
										 , uintptr_t psv );
PSI_PROC( void, EnumSelectedListItems )( PSI_CONTROL pc
													, PLISTITEM pliStart
													, void (CPROC *HandleListItem )(uintptr_t,PSI_CONTROL,PLISTITEM)
													, uintptr_t psv );
PSI_PROC( PSI_CONTROL, GetItemListbox )( PLISTITEM pli );
PSI_PROC( void, MoveListItemEx )( PSI_CONTROL pc, PLISTITEM pli, int level_direction, int direction );
PSI_PROC( void, MoveListItem )( PSI_CONTROL pc, PLISTITEM pli, int direction );
_LISTBOX_NAMESPACE_END
USE_LISTBOX_NAMESPACE
//------- GridBox Control --------
#ifdef __LINUX__
typedef uintptr_t HGRIDITEM;
PSI_PROC(PSI_CONTROL, MakeGridBox)( PSI_CONTROL pf, int options, int x, int y, int w, int h,
                                 int viewport_x, int viewport_y, int total_x, int total_y,
                                 int row_thickness, int column_thickness, uintptr_t nID );
#endif
/* * ------ Popup Menus ----------- *
   popup interface.... these are mimics of windows... and at
   some point should internally alias to popup code - if I ever
   get it back.
   Actually, I depricated my own implementation (maybe on Linux
   they could resemble working), but since I cloned the Windows
   API, I just fell back to standard windows popups instead.    */
_MENU_NAMESPACE
/* Create a popup menu which can have items added to it. This is
   not shown until TrackPopup is called.
   Parameters
   None.                                                         */
PSI_PROC( PMENU, CreatePopup)( void );
/* Destroys a popup menu.
   Parameters
   pm :  menu to delete   */
PSI_PROC( void, DestroyPopup)( PMENU pm );
/* Clears all entries on a menu.
   Parameters
   pm :  menu to clear           */
PSI_PROC( void, ResetPopup)( PMENU pm );
/* get sub-menu data...
   Parameters
   pm :    PMENU to get popup data for...
   item :  Item on the menu to get the popup menu for. */
PSI_PROC( void *,GetPopupData)( PMENU pm, int item );
/* Add a new item to a popup menu
   Parameters
   pm :     menu to add items to
   type :   type of the item (MF_STRING,MF_POPUP, MF_SEPARATOR ?)
   dwID :   ID of item. (PMENU of a popup menu if it's a popup
            item)
   pData :  text data of the item (unless separator)             */
PSI_PROC( PMENUITEM, AppendPopupItem)( PMENU pm, int type, uintptr_t dwID, CPOINTER pData );
/* Set a checkmark on a menu item.
   Parameters
   pm :     menu containing the item to check
   dwID :   ID of the item to check
   state :  (MF_CHECKED, MF_UNCHECKED?)       */
PSI_PROC( PMENUITEM, CheckPopupItem)( PMENU pm, uintptr_t dwID, uint32_t state );
/* Delete a single item from a menu.
   Parameters
   pm :     menu containing the item to delete
   dwID :   ID of the item to delete
   state :  (?)                                */
PSI_PROC( PMENUITEM, DeletePopupItem)( PMENU pm, uintptr_t dwID, uint32_t state );
/* This Shows a popup on the screen, and waits until it returns
   with a result. I guess this is actually the internal routine
   used for handling selected popup items on popup menus.
   Parameters
   hMenuSub :  sub menu to track
   parent :    parent menu that has started tracking a
               submenu.                                         */
PSI_PROC( int, TrackPopup)( PMENU hMenuSub, PSI_CONTROL parent );
/* Shows a popup to get input from the usr;
 this shows the popup in the background, and does not wait for the rsult.
 the result is instead dispatched through the callback. */
PSI_PROC( void, TrackPopup_v2 )( PMENU hMenuSub, PSI_CONTROL parent, void (*callback)( uintptr_t psv, int menuStatus ), uintptr_t psvParam );
_MENU_NAMESPACE_END
USE_MENU_NAMESPACE
//------- File Selector Control --------
// these are basic basic file selection dialogs...
	// the concept is valid, and they should be common like controls...
	// types are tab sepeared list of default extensions to open.
	// returns TRUE if the filename is selected and the result buffer is filled.
   // returns FALSE if the filename selection is canceled, result is not modified.
	// if bcreate is used, then the filename does not HAVE to exist..
   // bCreate may also be read as !bMustExist
PSI_PROC( int, PSI_PickFile)( PSI_CONTROL parent, CTEXTSTR basepath, CTEXTSTR types, TEXTSTR result, uint32_t result_len, int bCreate );
PSI_PROC( int, PSI_OpenFile)( CTEXTSTR basepath, CTEXTSTR types, TEXTSTR result );
// this may be used for save I think....
//PSI_PROC( int, PSI_OpenFileEx)( PSI_CONTROL parent, CTEXTSTR basepath, CTEXTSTR types, CTEXTSTR result, uint32_t result_len, int Create );
//------- Scroll Control --------
#define SCROLL_HORIZONTAL 1
#define SCROLL_VERITCAL   0
/* This is a scrollbar type control. It's got an up/down or
   left/right arrow, and a thumb that can be clicked on. Used by
   the listbox control.                                          */
_SCROLLBAR_NAMESPACE
	// types values for MoveScrollBar
	enum MoveScrollBarTypes{
 UPD_1UP       = 0,
 UPD_1DOWN     = 1,
 UPD_RANGEUP   = 2,
 UPD_RANGEDOWN = 3,
 UPD_THUMBTO   = 4
	};
/* \ \
   Parameters
   pc :     SCROLLBAR_CONTROL_NAME
   min :    minimum value (needs to be less than max)
   cur :    current value (should be between min to max
   range :  how many of the values to span
   max :    max value
   Remarks
   The range of the control controls how wide the thumb control
   is. It should reflect things like how many of the maximum
   items are showing in a list.                                 */
PSI_PROC( void, SetScrollParams)( PSI_CONTROL pc, int min, int cur, int range, int max );
CONTROL_PROC( ScrollBar, (uint32_t attr) );
/* Set the event callback for when the position on the control
   changes.
   Parameters
   pc :        a SCROLLBAR_CONTROL_NAME.
   callback :  the address of the function to call when the
               position changes.
   data :      user data passed to the event function when it is
               invoked.                                          */
PSI_PROC( void, SetScrollUpdateMethod)( PSI_CONTROL pc
                    , void (CPROC*UpdateProc)(uintptr_t psv, int type, int current)
                                                  , uintptr_t data );
/* move the scrollbar. operations to specify move are +1, -1, +1
   range, -1 range. the MOVE_THUMB operation is actually passed
   to the event callback?
   Parameters
   pc :    control that is a SCROLLBAR_CONTROL_NAME
   type :  a value from MoveScrollBarTypes                       */
PSI_PROC( void, MoveScrollBar )( PSI_CONTROL pc, int type );
_SCROLLBAR_NAMESPACE_END
USE_SCROLLBAR_NAMESPACE
//------- Misc Controls (and widgets) --------
_SHEETS_NAMESPACE
#define MakeSheetControl(c,x,y,w,h,id) MakeControl(c,SHEET_CONTROL,x,y,w,h,id)
/* Adds a sheet to a tab control. A sheet is just another
   PSI_CONTROL frame.
   Parameters
   pControl :  control to add the page to
   contents :  frame control to add                       */
PSI_PROC( void, AddSheet )( PSI_CONTROL pControl, PSI_CONTROL contents );
/* Removes a sheet from a tab control.
   Parameters
   pControl :  tab control to remove the sheet from
   ID :        identifier of the sheet to remove.   */
PSI_PROC( int, RemoveSheet )( PSI_CONTROL pControl, uint32_t ID );
/* Request a sheet control by ID.
   Parameters
   pControl :  tab control to get a sheet from.
   ID :        the ID of the page to get from the tab control.
   Returns
   Control that is the sheet that was added as the specified ID. */
PSI_PROC( PSI_CONTROL, GetSheet )( PSI_CONTROL pControl, uint32_t ID );
/* Gets a control from a specific sheet in the tab control
   Parameters
   pControl :   tab control to get the control from a sheet of.
   IDSheet :    identifier of the sheet to get a control from
   IDControl :  identifier of the control on a sheet in the tab
                control.
   Returns
   Control that has the requested ID on the requested page, if
   found. Otherwise NULL.                                       */
PSI_PROC( PSI_CONTROL, GetSheetControl )( PSI_CONTROL pControl, uint32_t IDSheet, uint32_t IDControl );
/* \returns the integer ID of the selected sheet.
   Parameters
   pControl :  Sheet control to get the current sheet ID from. */
PSI_PROC( PSI_CONTROL, GetCurrentSheet )( PSI_CONTROL pControl );
/* Set which property sheet is currently selected.
   Parameters
   pControl :  Sheet Control.
   ID :        ID of the page control to select.   */
PSI_PROC( void, SetCurrentSheet )( PSI_CONTROL pControl, uint32_t ID );
/* Get the size of sheets for this sheet control. So the page
   creator can create a page that is the correct size for the
   sheet dialog.
   Parameters
   pControl :  tab control to get the sheet size for
   width :     pointer to a 32 bit unsigned value to receive the
               width sheets should be.
   height :    pointer to a 32 bit unsigned value to receive the
               height sheets should be.                          */
PSI_PROC( int, GetSheetSize )( PSI_CONTROL pControl, uint32_t *width, uint32_t *height );
/* Sets a page as disabled. Disabled tabs cannot be clicked on
   to select.
   Parameters
   pControl :  tab control containing sheet to disable or enable.
   ID :        ID of the sheet to disable.
   bDisable :  TRUE to disable the page, FALSE to re\-enable the
               page.                                              */
PSI_PROC( void, DisableSheet )( PSI_CONTROL pControl, uint32_t ID, LOGICAL bDisable );
// Tab images are sliced and diced across the vertical center of the image
// the center is then spread as wide as the caption requires.
// set default tabs for the sheet control itself
PSI_PROC( void, SetTabImages )( PSI_CONTROL pControl, Image active, Image inactive );
// set tab images on a per-sheet basis, overriding the defaults specified.
PSI_PROC( void, SetSheetTabImages )( PSI_CONTROL pControl, uint32_t ID, Image active, Image inactive );
// with the ability to set the image for the tab, suppose it would be
// wise to set the sheet's text color on the tab...
// Initial tabs are black and white, with inverse black/white text...
PSI_PROC( void, SetTabTextColors )( PSI_CONTROL pControl, CDATA cActive, CDATA cInactive );
/* Sets the active and inactive colors for text.
   Parameters
   pControl :   sheet control to set the tab attribute of
   ID :         ID of the sheet to set the tab color attributes for
   cActive :    Color of the text when the tab is active.
   cInactive :  Color of the text when the tab is inactive.         */
PSI_PROC( void, SetSheetTabTextColors )( PSI_CONTROL pControl, uint32_t ID, CDATA cActive, CDATA cInactive );
_SHEETS_NAMESPACE_END
USE_SHEETS_NAMESPACE
//------- Misc Controls (and widgets) --------
PSI_PROC( void, SimpleMessageBox )( PSI_CONTROL parent, CTEXTSTR title, CTEXTSTR content );
// result is the address of a user buffer to read into, reslen is the size of that buffer.
// question is put above the question... pAbove is the window which this one should be placed above (lock-stacked)
PSI_PROC( int, SimpleUserQuery )( TEXTSTR result, int reslen, CTEXTSTR question, PSI_CONTROL pAbove );
PSI_PROC( int, SimpleUserQueryEx )( TEXTSTR result, int reslen, CTEXTSTR question, PSI_CONTROL pAbove
								   , void (CPROC*query_success_callback)(uintptr_t, LOGICAL)
								   , uintptr_t query_user_data );
PSI_PROC( void, RegisterResource )( CTEXTSTR appname, CTEXTSTR resource_name, int ID, int resource_name_range, CTEXTSTR type_name );
// assuming one uses a
#define SimpleRegisterResource( name, typename ) RegisterResource( "application", #name, name, 1, typename );
#define EasyRegisterResource( domain, name, typename ) RegisterResource( domain, #name, name, 1, typename );
#define EasyRegisterResourceRange( domain, name, range, typename ) RegisterResource( domain, #name, name, range, typename );
#define SimpleRegisterAppResource( name, typename, class ) RegisterResource( "application/" class, #name, name, 1, typename );
PSI_PROC( size_t, _SQLPromptINIValue )(
												CTEXTSTR lpszSection,
												CTEXTSTR lpszEntry,
												CTEXTSTR lpszDefault,
												TEXTSTR lpszReturnBuffer,
												size_t cbReturnBuffer,
												CTEXTSTR filename
											  );
//------------------------ Image Display -------------------------------------
#define IMAGE_DISPLAY_CONTROL_NAME "Image Display"
PSI_PROC( void, SetImageControlImage )( PSI_CONTROL pc, Image show_image );
//------------------------ Tool Tip Hover-over -------------------------------------
#define TOOL_TIP_CONTROL_NAME "Tool Tip Display"
PSI_PROC( void, SetControlHoverTip )( PSI_CONTROL pc, CTEXTSTR text );
//------------------------ Progress Bar --------------------------------------
#define PROGRESS_BAR_CONTROL_NAME  "Progress Bar"
// Set Range of progress bar (maximum value)
PSI_PROC( void, ProgressBar_SetRange )( PSI_CONTROL pc, int range );
// Set progress of progress bar (maximum value)
PSI_PROC( void, ProgressBar_SetProgress )( PSI_CONTROL pc, int progress );
// Set Colors for progress bar
PSI_PROC( void, ProgressBar_SetColors )( PSI_CONTROL pc, CDATA background, CDATA foreground );
// Enable/Disable showing text as a percentage on progress bar.
PSI_PROC( void, ProgressBar_EnableText )( PSI_CONTROL pc, LOGICAL enable );
#define GetFrameSurface GetControlSurface
PSI_NAMESPACE_END
USE_PSI_NAMESPACE
PSI_EDIT_NAMESPACE
// for convenience of migration, return pc
PSI_PROC( PSI_CONTROL, SetEditControlReadOnly )( PSI_CONTROL pc, LOGICAL bEnable );
PSI_EDIT_NAMESPACE_END
USE_PSI_EDIT_NAMESPACE
#ifndef BUTTON_METHODS_DEFINED
#define BUTTON_METHODS_DEFINED
#define BUTTON_CLICK( name, args ) PUBLIC( void, name )args;	   PRELOAD( name##_Init ) { SimpleRegisterMethod( PSI_ROOT_REGISTRY "/methods/Button/Click"	                                         , name, "void", #name, "(uintptr_t,PCOMMON)" ); }	 void CPROC name args
#define BUTTON_DRAW( name, args ) PUBLIC( void, name )args;	   PRELOAD( name##_Init ) { SimpleRegisterMethod( PSI_ROOT_REGISTRY "/methods/Button/Draw"	                                         , name, "void", #name, "(uintptr_t,PCOMMON)" ); }	 void CPROC name args
#define BUTTON_CHECK( name, args ) PUBLIC( void, name )args;	   PRELOAD( name##_Init ) { SimpleRegisterMethod( PSI_ROOT_REGISTRY "/methods/Button/Check"	                                         , name, "void", #name, "(uintptr_t,PCOMMON)" ); }	 void CPROC name args
#endif
#define SLIDER_UPDATE( name, args ) PUBLIC( void, name )args;	   PRELOAD( name##_Init ) { SimpleRegisterMethod( PSI_ROOT_REGISTRY "/control/Slider/Update"	                                         , name, "void", #name, "(uintptr_t,PCONTROL,int)" ); }	 void CPROC name args
//#include <psi/controls.h>
PSI_NAMESPACE
/* A colorwell is a indented control that contains a color.
   Often, if clicked, the color well will show the palette color
   selector to allow the color to be changed. The color may be a
   full alpha representation. When drawn in the well, I think
   the control itself draws the color with 255 alpha.
   Color well controls are "Color Well"
   Shade well controls are "Shade Well"
   Palette Shader grid is "Color Matrix"
   Example
   <code lang="c++">
   PSI_CONTROL color_well = MakeColorWell( NULL, 5, 5, 25, 25, -1, BASE_COLOR_WHITE );
   </code>
   Or using the natrual forms now...
   <code lang="c++">
   PSI_CONTROL shade_well = MakeNamedControl( frame, "Shade Well", 5, 5, 25, 150, -1 );
   SetShadeMin( shade_well, BASE_COLOR_WHITE );
   SetShadeMax( shade_well, BASE_COLOR_RED );
   SetShadeMid( shade_well, BSAE_COLOR_LIGHTBLUE );
   </code>                                                                              */
_COLORWELL_NAMESPACE
// common dialog to get a color... returns TRUE if *result is set
// if result is NULL color is not returned, but still can set presets...
#define  COLORWELL_NAME "Color Well"
/* <combine sack::psi::colorwell::PickColor@CDATA *@CDATA@PSI_CONTROL>
   \ \
   Parameters
   x :  position of the color choice dialog, otherwise uses the
        mouse position.
   y :  position of the color choice dialog, otherwise uses the
        mouse position.                                                */
PSI_PROC( int, PickColorEx )( CDATA *result, CDATA original, PSI_CONTROL hAbove, int x, int y );
/* Shows a color picking dialog. Results with a chosen color.
   Parameters
   result\ :   pointer to CDATA to result into
   original :  CDATA that is the color to start from.
   pAbove :    frame to stack this dialog over.
   Returns
   TRUE if *result is set, else FALSE. (Reflects the Ok/Cancel
   of the dialog)                                              */
PSI_PROC( int, PickColor)( CDATA *result, CDATA original, PSI_CONTROL pAbove );
// creates a control which can then select a color
CONTROL_PROC( ColorWell, (CDATA color) );
/* Macro to create a colorwell.
   Parameters
   f :   frame to create the control in
   x :   x coordinate of the left of the control in the frame
   y :   y coordinate of the left of the control in the frame
   w :   width of the control
   h :   height of the control
   ID :  an integer identifier for the control
   c :   a CDATA color to initialize with.
   Returns
   \Returns a PSI_CONTROL that is a color well.               */
#define MakeColorWell(f,x,y,w,h,id,c) SetColorWell( MakeNamedControl(f,COLORWELL_NAME,x,y,w,h,id ),c)
/* Three colors define the gradient in a shade well. They can be
   all the same and show a solid color, but this is for picking
   colors from linear gradients. The 'Min' is one end, the 'Mid'
   is the center and 'Max' is the other end. Control also only
   does this vertically.
   Parameters
   pc :     "Shade Well" control
   color :  Color to set the max end to.                         */
PSI_PROC( void, SetShadeMin )( PSI_CONTROL pc, CDATA color );
/* Three colors define the gradient in a shade well. They can be
   all the same and show a solid color, but this is for picking
   colors from linear gradients. The 'Min' is one end, the 'Mid'
   is the center and 'Max' is the other end. Control also only
   does this vertically.
   Parameters
   pc :     Shade Well control
   color :  color to set the max to.                             */
PSI_PROC( void, SetShadeMax )( PSI_CONTROL pc, CDATA color );
/* Three colors define the gradient in a shade well. They can be
   all the same and show a solid color, but this is for picking
   colors from linear gradients. The 'Min' is one end, the 'Mid'
   is the center and 'Max' is the other end. Control also only
   does this vertically.
   Parameters
   pc :     "Shade Well" control
   color :  sets the mid color of the control                    */
PSI_PROC( void, SetShadeMid )( PSI_CONTROL pc, CDATA color );
/* Sets the current color of a "Color Well"
   Parameters
   pc :     a "Color Well" control
   color :  CDATA to set the color to.      */
PSI_PROC( PSI_CONTROL, SetColorWell )( PSI_CONTROL pc, CDATA color );
/* Enables clicking in a color well to auto show the dialog.
   Parameters
   pc :       "Color Well" control to enable auto pick
   bEnable :  If TRUE, enable autopick; if FALSE, disable autopick. */
PSI_PROC( PSI_CONTROL, EnableColorWellPick )( PSI_CONTROL pc, LOGICAL bEnable );
/* Sets the handler for when the control is clicked. (or when
   it's changed?)
   Parameters
   PC :             pointer to a "Color Well"
   EventCallback :  This routine is called when the color is
                    changed.
   user_data :      user data to be passed to the callback when
                    invoked.                                    */
PSI_PROC( PSI_CONTROL, SetOnUpdateColorWell )( PSI_CONTROL PC, void(CPROC*EventCallback)(uintptr_t,CDATA), uintptr_t user_data);
/* Gets the CDATA color in a color well.
   Parameters
   pc :  "Color Well" control to get the color from */
PSI_PROC( CDATA, GetColorFromWell )( PSI_CONTROL pc );
PSI_COLORWELL_NAMESPACE_END
USE_PSI_COLORWELL_NAMESPACE
#endif
PSI_NAMESPACE
#if !defined( CONTROL_BASE )
extern
#endif
	CDATA DefaultColors[14];
//DOM-IGNORE-BEGIN
typedef struct psi_global_tag
{
#ifndef PSI_SERVICE
#  ifndef FORCE_NO_INTERFACE
	PIMAGE_INTERFACE MyImageInterface;
	PRENDER_INTERFACE MyDisplayInterface;
#endif
#endif
	struct {
		// will be set optionally when on a touch display
		// which will auto-magically grow certain controls
      // listbox, scrollbar...
		BIT_FIELD touch_display : 1;
		BIT_FIELD fancy_border : 1;
		BIT_FIELD bLogDebugUpdate : 1;
 // removes dirty, and expects to have to draw every display frame
		BIT_FIELD always_draw : 1;
		BIT_FIELD bLogDetailedMouse : 1;
		BIT_FIELD bLogSuperDetailedMouse : 1;
		BIT_FIELD bLogKeyEvents : 1;
		BIT_FIELD allow_threaded_draw : 1;
 // don't use fancy border... unless it's also set externally
		BIT_FIELD system_color_set : 1;
		BIT_FIELD allow_copy_from_render : 1;
	} flags;
	PLIST borders;
	PFrameBorder DefaultBorder;
#if 0
	CDATA *defaultcolors;
	int32_t BorderWidth;
	int32_t BorderHeight;
	struct psi_global_border_info {
 // 0 = none, 1=left, 2=center, 3=right
		BIT_FIELD bAnchorTop : 2;
 // 0 = none, 1=left, 2=center, 3=right
		BIT_FIELD bAnchorBottom : 2;
 // 0 = none, 1=top, 2=center, 3=bottom
		BIT_FIELD bAnchorLeft : 2;
 // 0 = none, 1=top, 2=center, 3=bottom
		BIT_FIELD bAnchorRight : 2;
	} Border;
	Image BorderImage;
 // really 8, but symetry is kept
	Image BorderSegment[9];
#endif
	Image FrameCaptionImage;
	Image FrameCaptionFocusedImage;
	Image StopButton;
	Image StopButtonPressed;
	int   StopButtonPad;
	PLIST shown_frames;
	SFTFont default_font;
	PTHREAD updateThread;
}PSI_GLOBAL;
enum {
	SEGMENT_TOP_LEFT
	  , SEGMENT_TOP
	  , SEGMENT_TOP_RIGHT
	  , SEGMENT_LEFT
	  , SEGMENT_CENTER
	  , SEGMENT_RIGHT
	  , SEGMENT_BOTTOM_LEFT
	  , SEGMENT_BOTTOM
	  , SEGMENT_BOTTOM_RIGHT
     // border segment index's
};
#if !defined( CONTROL_BASE ) && (defined( SOURCE_PSI2 ) || defined( __cplusplus_cli ))
extern
#endif
#ifndef __cplusplus_cli
#  ifdef WIN32
#    if !defined( SOURCE_PSI2 )
#      if !defined( CONTROL_BASE )
__declspec(dllimport)
#      else
__declspec(dllexport)
#      endif
#    endif
#  else
#    if !defined( SOURCE_PSI2 )
#      if !defined( CONTROL_BASE )
extern
#      else
#      endif
#    endif
#  endif
#endif
/* This is the structure PSI uses to track .... what? The
   application has to know its own handles... what does PSI keep
   anyhow? most methods are registered now.                      */
PSI_GLOBAL global_psi_structure
#ifndef CONTROL_BASE
;
#else
= {
#ifndef PSI_SERVICE
#  ifndef FORCE_NO_INTERFACE
	NULL, NULL,
#  endif
#endif
  { 0 }
  // none of these should be 0 (black) may be 1 (nearest black)
  , 0 };
#endif
//DOM-IGNORE-END
#ifndef CONTROL_BASE
extern
#endif
	void GetMyInterface( void );
// --------- borders.c --------------
void UpdateSurface( PSI_CONTROL pc );
void CPROC DrawFancyFrame( PSI_CONTROL pc );
void CPROC DrawNormalFrame( PSI_CONTROL pc );
PSI_NAMESPACE_END
#endif
// $Log: global.h,v $
// Revision 1.13  2005/03/23 12:20:53  panther
// Fix positioning of common buttons.  Also do a quick implementation of fancy borders.
//
// Revision 1.12  2005/03/23 02:43:07  panther
// Okay probably a couple more badly initialized 'unusable' flags.. but font rendering/picking seems to work again.
//
// Revision 1.11  2005/03/22 12:41:58  panther
// Wow this transparency thing is going to rock! :) It was much closer than I had originally thought.  Need a new class of controls though to support click-masks.... oh yeah and buttons which have roundable scaleable edged based off of a dot/circle
//
// Revision 1.10  2004/10/24 20:09:47  d3x0r
// Sync to psilib2... stable enough to call it mainstream.
//
// Revision 1.3  2004/10/07 04:37:16  d3x0r
// Okay palette and listbox seem to nearly work... controls draw, now about that mouse... looks like my prior way of cheating is harder to step away from than I thought.
//
// Revision 1.2  2004/10/06 09:52:16  d3x0r
// checkpoint... total conversion... now how does it work?
//
// Revision 1.1  2004/09/19 19:22:31  d3x0r
// Begin version 2 psilib...
//
// Revision 1.9  2003/04/02 07:31:25  panther
// Enable local GetMyInterface which will auto configure library to current link
//
// Revision 1.8  2003/03/29 15:52:17  panther
// Fix service PSI compilation (direct link to render/image).  Just for grins make caption text 3dlike
//
// Revision 1.7  2003/03/25 08:45:56  panther
// Added CVS logging tag
//
SACK_NAMESPACE
_PSI_NAMESPACE
// define this to prevent multiple definition to application
// viewpoint...
//---------------------------------------------------------------------------
// default_width, default_height,
#define CONTROL_PROC_DEF( controltype, type, name, _args )	                  int CPROC Init##name( PSI_CONTROL pControl );	  int CPROC Config##name( PSI_CONTROL pc ) { return Init##name(pc); }	 int CPROC Init##name( PSI_CONTROL pc )
#define CAPTIONED_CONTROL_PROC_DEF( controltype, type, name, _args )	                  int CPROC Init##name( PSI_CONTROL pControl );	  int CPROC Config##name( PSI_CONTROL pc ) { return Init##name(pc); }	 int CPROC Init##name( PSI_CONTROL pc )
#define CONTROL_PROC_DEF_EX( controltype, type, name, _args)	 int CPROC Init##name( PSI_CONTROL );	  int CPROC Config##name( PSI_CONTROL pc ) { return Init##name(pc); }	 int CPROC Init##name( PSI_CONTROL pc )
#define ARG( type, name ) PARAM( args, type, name )
#define FP_ARG( type, name, funcargs ) FP_PARAM( args, type, name, funcargs )
#ifdef GCC
#define CONTROL_INIT(name) CONTROL_PROPERTIES( name )(PSI_CONTROL pControl)      { return NULL; } CONTROL_PROPERTIES_APPLY( name )(PSI_CONTROL pc,PSI_CONTROL page) { ; }	    int CPROC Init##name ( uintptr_t psv, PSI_CONTROL pControl, uint32_t ID )
#define CONTROL_INIT_EX(name)	  int CPROC Init##name ( uintptr_t psv, PSI_CONTROL pControl, uint32_t ID )
//#error Need to figure out how to register control Inits
#else
#define CONTROL_INIT(name)  CONTROL_PROPERTIES( name )(PSI_CONTROL pc)      { return NULL; } CONTROL_PROPERTIES_APPLY( name )(PSI_CONTROL pc,PSI_CONTROL page) { ; }	   int CPROC Init##name ( PSI_CONTROL pc, va_list args )
#define CONTROL_INIT_EX(name)	  int CPROC Init##name ( PSI_CONTROL pc, va_list args )
//#error Need to figure out how to register control Inits
#endif
// size of the property dialog page...
#define PROP_WIDTH 540
#define PROP_HEIGHT 240
#define PROP_PAD 5
/* \Internal event callback definition. Request an additional
	page to add to the control property edit dialog.           */
typedef PSI_CONTROL (CPROC*GetControlPropSheet)( PSI_CONTROL );
#define CONTROL_PROPERTIES( name )  OnPropertyEdit( TOSTR(name) )
/* \Internal defintion of the callback to invoke when a property
	sheet is requested to be applied when editing the control.    */
typedef void (CPROC*ApplyControlPropSheet)( PSI_CONTROL, PSI_CONTROL );
#define CONTROL_PROPERTIES_APPLY( name )  OnPropertyEditOkay( TOSTR(name) )
/* Tells a control that the edit process is done with the
	property sheet requested.
	\Internal event callback definition.                   */
typedef void (CPROC*DoneControlPropSheet)( PSI_CONTROL );
#define CONTROL_PROPERTIES_DONE( name )  OnPropertyEditDone( TOSTR(name) )
//typedef struct subclass_control_tag {
//	PCONTROL_REGISTRATION methods;
//};
//#define ControlType(pc) ((pc)->nType)
enum HotspotLocations {
 // 0 = no spot locked...
	SPOT_NONE
	 , SPOT_TOP_LEFT
	 , SPOT_TOP
	 , SPOT_TOP_RIGHT
	 , SPOT_LEFT
	 , SPOT_CENTER
	 , SPOT_RIGHT
	 , SPOT_BOTTOM_LEFT
	 , SPOT_BOTTOM
	 , SPOT_BOTTOM_RIGHT
};
/* \Internal event callback definition. Draw border, this
	usually pointing to an internal function, but may be used for
	a control to draw a custom border.                            */
typedef void (CPROC*_DrawBorder)        ( struct psi_common_control_frame * );
/* \Event callback definition. Draw caption, set with OnCaptionDraw().
    Use SetCaptionHeight() when creating the frame to set the height of the
	custom caption.
*/
typedef void (CPROC*_DrawCaption)        ( struct psi_common_control_frame *, Image );
/* \Internal event callback definition. This is called when the
	control needs to draw itself. This happens when SmudgeCommon
	is called on the control or on a parent of the control.      */
typedef int (CPROC*__DrawThySelf)       ( struct psi_common_control_frame * );
/* \Internal event callback definition. This is called when the
	control needs to draw itself. This happens when SmudgeCommon
	is called on the control or on a parent of the control.      */
typedef void (CPROC*__DrawDecorations)       ( struct psi_common_control_frame *frame, struct psi_common_control_frame *child );
/* \Internal event callback definition. A mouse event is
	happening over the control.                           */
typedef int (CPROC*__MouseMethod)       ( struct psi_common_control_frame *, int32_t x, int32_t y, uint32_t b );
/* \Internal event callback definition. A key has been pressed. */
typedef int (CPROC*__KeyProc)           ( struct psi_common_control_frame *, uint32_t );
/* \Internal event callback definition. The caption of a control
	is changing (Edit control uses this).                         */
typedef void (CPROC*_CaptionChanged)    ( struct psi_common_control_frame * );
/* \Internal event callback definition. Destruction of the
	control is in progress. Allow control to free internal
	resources.                                              */
typedef void (CPROC*_Destroy)           ( struct psi_common_control_frame * );
/* \Internal event callback definition.
	A control has been added to this control. */
typedef void (CPROC*_AddedControl)      ( struct psi_common_control_frame *, struct psi_common_control_frame *pcAdding );
/* \Internal event callback definition. The focus of a control
	is changing.                                                */
typedef int (CPROC*_ChangeFocus)       ( struct psi_common_control_frame *, LOGICAL bFocused );
/* \Internal event callback definition. Called when a control is
		being resized. Width or height changing.                      */
typedef void (CPROC*_Resize)            ( struct psi_common_control_frame *, LOGICAL bSizing );
typedef void (CPROC*_Move)            ( struct psi_common_control_frame *, LOGICAL bSizing );
typedef void (CPROC*_Rescale)            ( struct psi_common_control_frame * );
/* \Internal event callback definition. Called when the
	control's position (x,y) is changing.                */
typedef void (CPROC*_PosChanging)       ( struct psi_common_control_frame *, LOGICAL bMoving );
/* \Internal event callback definition. Triggered when edit on a
	frame is started.                                             */
typedef void (CPROC*_BeginEdit)         ( struct psi_common_control_frame * );
/* \Internal event callback definition. Ending control editing. */
typedef void (CPROC*_EndEdit)           ( struct psi_common_control_frame * );
/* \Internal event callback definition. A file has been dropped
	on the control.                                              */
typedef LOGICAL (CPROC*_AcceptDroppedFiles)( struct psi_common_control_frame *, CTEXTSTR filename, int32_t x, int32_t y );
typedef void (CPROC*_HoverEventCallback)           ( struct psi_common_control_frame * );
#define DeclMethod( name ) int n##name; _##name *name
#define DeclSingleMethod( name ) _##name name
// right now - all these methods evolved from a void
// function, therefore, this needs to invoke all key/draw methods not just
// until 'processed'
 /*if(*/
 /*)*/
 /*break*/
#define InvokeDrawMethod(pc,name,args)  if( (pc) && (pc)->name ) { int n; for( n = 0; (pc) && n < (pc)->n##name; n++ ) if( (pc)->name[n] )(pc)->draw_result |= (pc)->name[n]args; }
 /*if(*/
 /*)*/
 /*break*/
#define InvokeMethod(pc,name,args)  if( (pc) && (pc)->name ) { int n; for( n = 0; (pc) && n < (pc)->n##name; n++ ) if( (pc)->name[n] )(pc)->name[n]args; }
#define InvokeResultingMethod(result,pc,name,args)  if( (pc) && (pc)->name ) { int n; for( n = 0; (pc) && n < (pc)->n##name; n++ ) if( (pc)->name[n] ) if( (result)=(pc)->name[n]args ) break; }
#define InvokeSingleMethod(pc,name,args)  if( (pc)->name ) { (pc)->name args; }
void InvokeControlHidden( PSI_CONTROL pc );
void InvokeControlRevealed( PSI_CONTROL pc );
struct edit_state_tag {
//DOM-IGNORE-BEGIN
	PSI_CONTROL pCurrent;
	// so we can restore keystrokes to the control
	// and/or relay unused keys to the control...
	// perhaps should override draw this way
	// some controls may take a long time to draw while
	// sizing... although we probably do want to see
	// their behavior at the new size....
	// but THIS definatly so we can process arrow keys...
	//void (CPROC*PriorKeyProc)( uintptr_t psv, uint32_t );
	//uintptr_t psvPriorKey;
	DeclMethod( _KeyProc );
	//void (CPROC*_PriorKeyProc)( PSI_CONTROL pc, uint32_t );
	IMAGE_POINT hotspot[9];
	IMAGE_RECTANGLE bound;
 // pCurrent upper left corner kinda on the master frame
	IMAGE_POINT bias;
 // marked x, y when the hotspot was grabbed...
	int32_t _x, _y;
	// should also do a cumulative change delta off
	// this to lock the mouse in position...
	int32_t delxaccum, delyaccum;
	struct {
 // edit state is active.
		BIT_FIELD bActive : 1;
 // which spot it's locked on...
		BIT_FIELD fLocked : 4;
		BIT_FIELD bDragging : 1;
 // any sizing flag set
		BIT_FIELD bSizing : 1;
		BIT_FIELD bSizing_left  : 1;
		BIT_FIELD bSizing_right : 1;
		BIT_FIELD bSizing_top   : 1;
		BIT_FIELD bSizing_bottom: 1;
		BIT_FIELD bFrameWasResizable : 1;
		BIT_FIELD bHotSpotsActive : 1;
	} flags;
	uint32_t BorderType;
	void ( CPROC*frameDetached )( struct psi_common_control_frame * pc );
	void ( CPROC*frameEditDone )( struct psi_common_control_frame * pc );
//DOM-IGNORE-END
};
typedef struct edit_state_tag EDIT_STATE;
typedef struct edit_state_tag *PEDIT_STATE;
struct physical_device_caption_button
{
	Image normal;
	Image pressed;
	Image highlight;
	void (CPROC*pressed_event)( PSI_CONTROL pc );
	LOGICAL is_pressed;
	int extra_pad;
	int32_t offset;
	struct {
		BIT_FIELD hidden : 1;
		BIT_FIELD rollover : 1;
	} flags;
	PSI_CONTROL pc;
};
typedef struct physical_device_caption_button CAPTION_BUTTON;
typedef struct physical_device_caption_button *PCAPTION_BUTTON;
typedef struct frame_border {
	CDATA *defaultcolors;
	int32_t BorderWidth;
	int32_t BorderHeight;
	struct psi_global_border_info {
 // 0 = none, 1=left, 2=center, 3=right
		BIT_FIELD bAnchorTop : 2;
 // 0 = none, 1=left, 2=center, 3=right
		BIT_FIELD bAnchorBottom : 2;
 // 0 = none, 1=top, 2=center, 3=bottom
		BIT_FIELD bAnchorLeft : 2;
 // 0 = none, 1=top, 2=center, 3=bottom
		BIT_FIELD bAnchorRight : 2;
	} Border;
	Image BorderImage;
 // really 8, but symetry is kept
	Image BorderSegment[9];
	LOGICAL hasFill;
	LOGICAL drawFill;
} FrameBorder;
struct physical_device_interface
{
//DOM-IGNORE-BEGIN
 // any control can have a physical renderer...
	PRENDERER pActImg;
 // need this to easily back track...
	struct psi_common_control_frame * common;
	struct device_flags {
 // frame is being moved
		BIT_FIELD bDragging : 1;
 // flags for when frame is sizable
		BIT_FIELD bSizing       : 1;
		BIT_FIELD bSizing_left  : 1;
		BIT_FIELD bSizing_right : 1;
		BIT_FIELD bSizing_top   : 1;
		BIT_FIELD bSizing_bottom: 1;
 // pCurrent is also owner of the mouse (button was clicked, and never released)
		BIT_FIELD bCurrentOwns : 1;
 // don't call update function...
		BIT_FIELD bNoUpdate : 1;
 // frame owns mouse, control behaving as frame wants all mouse events.
		BIT_FIELD bCaptured : 1;
 // current owns was set by application, do not auto disown.
		BIT_FIELD bApplicationOwned : 1;
 // stops sending multiple redraw events....
		BIT_FIELD sent_redraw : 1;
		BIT_FIELD bClosed : 1;
	}flags;
	EDIT_STATE EditState;
	//PRENDERER pActImg;
	//uintptr_t psvUser; // user data...
 // position drag was started; for absolute motion
	int drag_x, drag_y;
	int _x, _y;
 // last button state...
	uint32_t _b;
	// these two buttons override controls which have the ID BTN_OKAY, BTN_CANCEL
	int nIDDefaultOK;
	int nIDDefaultCancel;
	// when has mouse is set, this is set
	// as a quick computation of the coordinate
	// bias.
	struct {
		struct {
			BIT_FIELD bias_is_surface : 1;
		} flags;
		int32_t x, y;
	} CurrentBias;
	//Image original_surface;
 // Current control which has the mouse within it...(or owns mouse)
	struct psi_common_control_frame * pCurrent;
   // keyboard goes here...
	struct psi_common_control_frame * pFocus;
	// this is now added as a draw callback method
	//void (CPROC*OwnerDraw)(struct psi_common_control_frame * pc);
	// this is now added as a mouse callback method
	//void (CPROC*OwnerMouse)(struct psi_common_control_frame * pc, int32_t x, int32_t y, uint32_t b);
	// this is unused yet...
	//int (CPROC*InitControl)(uintptr_t, struct psi_common_control_frame *, uint32_t);// match ControlInitProc(controls.h)
	uintptr_t psvInit;
 // optimized search list for (allow_threaded_draw == FALSE)
	PLIST pending_dirty_controls;
//DOM-IGNORE-END
};
typedef struct physical_device_interface PHYSICAL_DEVICE;
typedef struct physical_device_interface*PPHYSICAL_DEVICE;
typedef struct psi_common_button_data {
//DOM-IGNORE-BEGIN
	PTHREAD thread;
	int *okay_value;
	int *done_value;
	struct button_flags {
		uint32_t bWaitOnEdit : 1;
	} flags;
 // replace commonLoopWait
	void (*event)( uintptr_t, PSI_CONTROL pc, int done, int okay );
 // event user data (pointer size val)
   uintptr_t psv;
//DOM-IGNORE-END
} PSI_COMMON_BUTTON_DATA, *PPSI_COMMON_BUTTON_DATA;
//DOM-IGNORE-BEGIN
typedef struct psi_common_control_frame
{
	// this is the one place allowed for
	// an application to store data.
	// once upon a time, I followed windows and
	// allowed set/get network long, which allowed
	// multiple values to be kept...
	// but that doesn't help anything, it just allows for
	// bad coding, and useless calls to fetch values
	// from the object...
	POINTER pUser;
	// the user may also set a DWORD value associated with a control.
	uintptr_t psvUser;
 // this is used by languge binding layer; allowing the app to still use userdata
	uintptr_t psvBinding;
	// this is the numeric type ID of the control.  Although, now
	// controls are mostly tracked with their name.
	int nType;
	/* Name of the type this control is. Even if a control is
		created by numeric Type ID, it still gets its name from the
		procedure registry.                                         */
	CTEXTSTR pTypeName;
	// unique control ID ....
	int nID;
	// this is the text ID registered...
	CTEXTSTR pIDName;
	//----------------
	// the data above this point may be known by
	// external sources...
	/* just the data portion of the control */
	Image Surface;
 // just the data portion of the control
	Image OriginalSurface;
	/* flags that affect a control's behavior or state.
		                                                 */
	/* <combine sack::psi::psi_common_control_frame::flags@1>
		\ \                                                */
	struct {
		/* Control is currently keyboard focused. */
		BIT_FIELD bFocused : 1;
		// destroyed - and at next opportunity will be...
		BIT_FIELD bDestroy : 1;
		// set when a size op begins to void draw done during size
		BIT_FIELD bSizing : 1;
		// used to make Frame more 'Pop' Up...
		BIT_FIELD bInitial : 1;
		// set to disable updates
		BIT_FIELD bNoUpdate : 1;
		// this control was explicitly set hidden.. don't unhide.
		BIT_FIELD bHiddenParent : 1;
		// can't see it, can't touch it.
		BIT_FIELD bHidden : 1;
		// scale currently applies.
		BIT_FIELD bScaled : 1;
		/* control gets no keyboard focus. */
		BIT_FIELD bNoFocus:1;
		// greyed out state?
		BIT_FIELD bDisable : 1;
		 // 0 = default alignment 1 = left, 2 = center 3 = right
		BIT_FIELD bAlign:2;
		// draw veritcal instead of horizontal
		BIT_FIELD bVertical:1;
		 // draw opposite/upside down from normal
		BIT_FIELD bInvert:1;
		// needs DrawThySelf called...
		BIT_FIELD bDirty : 1;
		// DrawThySelf has been called...
		BIT_FIELD bCleaning : 1;
		// only need to update the control's frame... (focus change)
		BIT_FIELD bDirtyBorder : 1;
		// parent drew, therefore this needs to draw, and it's an initial draw.
		BIT_FIELD bParentCleaned : 1;
		// saves it's original surface and restores it before invoking the control draw.
		BIT_FIELD bTransparent : 1;
		/* Adopted children are not automatically saved in XML files. */
		BIT_FIELD bAdoptedChild : 1;
		// children were cleaned by an internal update... don't draw again.
		BIT_FIELD children_cleaned : 1;
		// no extra init, and no save, this is a support control created for a master control
		BIT_FIELD private_control : 1;
		// control has been temporarily displaced from its parent control.
		BIT_FIELD detached : 1;
		// edit mode enabled visibility of this window and opened it.
		BIT_FIELD auto_opened : 1;
		// first time this is being cleaned (during the course of refresh this could be called many times)
		BIT_FIELD bFirstCleaning : 1;
		// frame was loaded from XML, and desires that EditFrame not be enablable.
		BIT_FIELD bNoEdit : 1;
		// Edit has been enabled on the control.
		BIT_FIELD bEditSet : 1;
		// this came from the XML file.
		BIT_FIELD bEditLoaded : 1;
		// an update event is already being done, bail on this and all children?
		BIT_FIELD bUpdating : 1;
		// enable only real draw events in video thread.  (post invalidate only)
		BIT_FIELD bOpenGL : 1;
		// needs DrawThySelf called... // collect these, so a master level draw can be done down. only if a control or it's child is dirty.
		BIT_FIELD bChildDirty : 1;
		// there is a frame caption update (with flush to display) which needs to be locked....
		BIT_FIELD bRestoring : 1;
		// got at least one frame redraw event (focus happens before first draw)
		BIT_FIELD bShown : 1;
		// Set when resized by a mouse drag, causes a dirty state.
		BIT_FIELD bResizedDirty : 1;
		// during control update the effective surface region was set while away.
		BIT_FIELD bUpdateRegionSet : 1;
		// control was in the process of being cleaned, and received a smudge again... control needs to draw itself AGAIN
		BIT_FIELD bDirtied : 1;
		// parent did a draw, and marks this on all his children, then copy originalsurface clears this flag to indicate it got a clean snapshot
		BIT_FIELD bParentUpdated : 1;
		// this is set on controls which have completed their redraw after a smudge.
		BIT_FIELD bCleanedRecently : 1;
		// this is set by BeginUpdate and EndUpdate to prevent hiding/disable update during update
		BIT_FIELD bDirectUpdating : 1;
		// this is set when BorderType is not the same as the inital border type
		BIT_FIELD bSetBorderType : 1;
		// set when the close button has been added to caption_buttons (standardized)
		BIT_FIELD bCloseButtonAdded : 1;
		// set while initially opening a display; is a carry-over for bInitial
		BIT_FIELD bOpeningFrameDisplay : 1;
		// set for the short time the control is creating, but hasn't yet called the control init function
		BIT_FIELD bCreating : 1;
	} flags;
	/* Information about the caption of a control. */
	/* <combine sack::psi::psi_common_control_frame::caption@1>
		\ \                                                  */
	struct {
		/* This is the font that applies to the current control. If it
			is NULL, then it uses the parent controls' font. If that's
			null, it keeps searching up until it finds a font or results
			NULL and uses the default internal font.                     */
		SFTFont font;
		/* This is actually a PFONTDATA.
			                              */
		POINTER fontdata;
		/* Length of the PFONTDATA. */
		size_t fontdatalen;
		/* Text of the control's caption. */
		PTEXT text;
		Image image;
  // how much above/below image
		int pad;
	} caption;
	 // original size the control was created at (before the border is applied)
	IMAGE_RECTANGLE original_rect;
	/* the scalex that is applied to creation of controls within
		this control. Modifies the width of a control and X
		positioning.                                              */
	FRACTION scalex;
	/* the scaley that is applied to creation of controls within
		this control. Modifies the height of a control and Y
		positioning.                                              */
	FRACTION scaley;
		// the actual rect of the control...
	IMAGE_RECTANGLE rect;
	/* This is the rectangle that describes where the surface of the
		control is relative to is outside position.                   */
	IMAGE_RECTANGLE surface_rect;
		// size and position of detachment.
	IMAGE_RECTANGLE detached_at;
	/* this is the output device that the control is being rendered
		to.                                                          */
	PPHYSICAL_DEVICE device;
	// includes border/caption of control
	Image Window;
 // actively processing - only when decremented to 0 do we destroy...
	uint32_t InUse;
	// fake counter to allow ReleaseCommonUse to work.
	uint32_t NotInUse;
	// waitinig for a responce... when both inuse and inwait become 0 destroy can happy.
	// otherwise when inuse reduces to 0, draw events are dispatched.
	uint32_t InWait;
	/* This is a pointer to the prior control in a frame. */
	/* pointer to the first child control in this one. */
	/* pointer to the next control within this control's parent. */
	/* pointer to the control that contains this control. */
	struct psi_common_control_frame *child, *parent, *next, *prior, *stack_parent, *stack_child;
	// maybe I can get pointers to this....
	uint32_t BorderType;
	void (CPROC*BorderDrawProc)( PSI_CONTROL, Image );
	void (CPROC*Rollover)( PSI_CONTROL, LOGICAL );
	void (CPROC*FontChange)(PSI_CONTROL);
	void (CPROC*BorderMeasureProc)( PSI_CONTROL, int *x_offset, int *y_offset, int *right_inset, int *bottom_inset );
	// also declare a method above of the same name...
	int draw_result;
	DeclMethod( _DrawThySelf );
	DeclMethod( _DrawDecorations );
	// also declare a method above of the same name...
	DeclMethod( _MouseMethod );
	// also declare a method above of the same name...
	DeclMethod( _KeyProc );
	// also declare a method above of the same name...
	DeclSingleMethod( DrawBorder );
	// also declare a method above of the same name...
	DeclSingleMethod( CaptionChanged );
	// also declare a method above of the same name...
	DeclSingleMethod( Destroy );
	// also declare a method above of the same name...
	DeclSingleMethod( AddedControl );
	// also declare a method above of the same name...
	DeclSingleMethod( ChangeFocus );
	// also declare a method above of the same name...
	DeclSingleMethod( Resize );
	DeclSingleMethod( Move );
	DeclSingleMethod( Rescale );
	//DeclSingleMethod( PosChanging );
	DeclSingleMethod( BeginEdit );
	DeclSingleMethod( EndEdit );
	DeclSingleMethod( DrawCaption );
	DeclSingleMethod( HoverEventCallback );
	DeclMethod( AcceptDroppedFiles );
	/* Pointer to common button data. Common buttons are the Okay
		and Cancel buttons that are commonly on dialogs.           */
	PSI_COMMON_BUTTON_DATA pCommonButtonData;
		// invalidating an arbitrary rect, this is the intersection of the parent's dirty rect on this
	IMAGE_RECTANGLE dirty_rect;
		// during update this may be set, and should be used for the update region insted of control surface
	IMAGE_RECTANGLE update_rect;
	/* A copy of the name that the frame was loaded from or saved
		to. For subsequent save when the control is edited.        */
	TEXTSTR save_name;
	CDATA *basecolors;
	/* when registered this gets set as where the control's events and rtti are registered.
		 This will seperate /psi/control and /psi++/control without other flags to switch on */
  // extra controls that are stuffed on the caption bar.
	PLIST caption_buttons;
	int32_t caption_button_x_ofs, caption_button_y_ofs;
	PFrameBorder border;
  // the current button pressed
	PCAPTION_BUTTON hover_caption_button;
  // the current button pressed
	PCAPTION_BUTTON pressed_caption_button;
	PCLASSROOT class_root;
	int nCaptionHeight;
	Image pCaptionImage;
 // size above common required...
	int nExtra;
} FR_CT_COMMON;
//DOM-IGNORE-END
//---------------------------------------------------------------------------
// each control has itself a draw border method.
//void CPROC DrawBorder( uintptr_t psv, PSI_CONTROL pc );
// check box uses these... ???
void CPROC DrawThinFrame( PSI_CONTROL pc );
void CPROC DrawThinnerFrame( PSI_CONTROL pc );
void CPROC DrawThinFrameInverted( PSI_CONTROL pc );
void CPROC DrawThinnerFrameInverted( PSI_CONTROL pc );
void CPROC DrawThinFrameImage( Image pc );
/* Draw a 2 pixel frame around a control.
	Parameters
	pc :  COntrol to draw a thinner frame on;. */
void CPROC DrawThinnerFrameImage( PSI_CONTROL pc, Image image );
void CPROC DrawThinFrameInvertedImage( PSI_CONTROL pc, Image image );
void CPROC DrawThinnerFrameInvertedImage( PSI_CONTROL pc, Image image );
void GetCurrentDisplaySurface( PPHYSICAL_DEVICE device );
_MOUSE_NAMESPACE
/* This is an internal routine which sets the hotspot drawing
	coordiantes. Prepares for drawing, but doesn't draw.       */
void SetupHotSpots( PEDIT_STATE pEditState );
/* Routine in mouse space which draws hotspots on the frame
	indicating areas that can be manipulated on a control. Otherwise
	controls are fully active, and you can use them as you are
	developing. Hotspots are drawn in WHITE unless the mouse is
	captured by one, then the spot is RED.
	Parameters
	pf :  frame being edited.
	pe :  pointer to the current edit state containing information
		   like the currently active control for editing on a frame.  */
void DrawHotSpotsEx( PSI_CONTROL pf, PEDIT_STATE pEditState, PSI_CONTROL pcChild DBG_PASS );
/* <combine sack::psi::_mouse::DrawHotSpotsEx@PSI_CONTROL@PEDIT_STATE pEditState>
	\ \                                                                        */
#define DrawHotSpots(pf,pe,pChild) DrawHotSpotsEx(pf,pe,pChild DBG_SRC)
//void DrawHotSpots( PSI_CONTROL pf, PEDIT_STATE pEditState );
_MOUSE_NAMESPACE_END
void SmudgeSomeControls( PSI_CONTROL pc, P_IMAGE_RECTANGLE pRect );
void DetachFrameFromRenderer( PSI_CONTROL pc );
void IntelligentFrameUpdateAllDirtyControls( PSI_CONTROL pc DBG_PASS );
_BUTTON_NAMESPACE
//	void InvokeButton( PSI_CONTROL pc );
_BUTTON_NAMESPACE_END
// dir 0 here only... in case we removed ourself from focusable
// dir -1 go backwards
// dir 1 go forwards
#define FFF_HERE      0
#define FFF_FORWARD   1
#define FFF_BACKWARD -1
void FixFrameFocus( PPHYSICAL_DEVICE pf, int dir );
_MOUSE_NAMESPACE
	/* Specifies symbols for which default control to press -
		default accept or default cancel.                      */
	enum MouseInvokeType {
 INV_OKAY   = 0,
 INV_CANCEL = 1
	};
/* Invokes a default button on a frame.
	Parameters
	pc :    frame to invoke the event on
	type :  type of Event from MouseInvokeType. */
int InvokeDefault( PSI_CONTROL pc, int type );
/* Add a usage counter to a control. Controls in use have redraw
	events blocked.                                               */
void AddUseEx( PSI_CONTROL pc DBG_PASS);
/* <combine sack::psi::_mouse::AddUseEx@PSI_CONTROL pc>
	\ \                                              */
#define AddUse( pc ) AddUseEx( pc DBG_SRC )
/* Removes a use added by AddUse. COntrols in use cannot update. */
void DeleteUseEx( PSI_CONTROL *pc DBG_PASS );
/* <combine sack::psi::_mouse::DeleteUseEx@PSI_CONTROL *pc>
	\ \                                                  */
#define DeleteUse(pc) DeleteUseEx( &pc DBG_SRC )
/* Adds a wait to a control. This prevents drawing while the
	system is out of a drawable state.                        */
void AddWaitEx( PSI_CONTROL pc DBG_PASS);
/* <combine sack::psi::_mouse::AddWaitEx@PSI_CONTROL pc>
	\ \                                               */
#define AddWait( pc ) AddWaitEx( pc DBG_SRC )
/* Removes a wait added by AddWait */
void DeleteWaitEx( PSI_CONTROL *pc DBG_PASS );
#define DeleteWait(pc) DeleteWaitEx( &pc DBG_SRC )
 /* <combine sack::psi::_mouse::DeleteWaitEx@PSI_CONTROL *pc>
		                                                \ \                                                   */
_MOUSE_NAMESPACE_END
USE_MOUSE_NAMESPACE
int FrameCaptionYOfs( PSI_CONTROL pc, uint32_t BorderType );
void DrawFrameCaption( PSI_CONTROL pc );
PPHYSICAL_DEVICE OpenPhysicalDevice( PSI_CONTROL pc, PSI_CONTROL over, PRENDERER pActImg, PSI_CONTROL under );
void TryLoadingFrameImage( void );
Image CopyOriginalSurfaceEx( PSI_CONTROL pc, Image use_image DBG_PASS );
#define CopyOriginalSurface(pc,i) CopyOriginalSurfaceEx(pc,i DBG_SRC )
//#define PSI_CONTROL PSI_CONTROL
CDATA *basecolor( PSI_CONTROL pc );
PSI_NAMESPACE_END
#endif
// $Log: controlstruc.h,v $
// Revision 1.73  2005/07/08 00:45:47  d3x0r
// Define NotInUse in control structure.
//
// Revision 1.20  2003/03/25 08:45:56  panther
// Added CVS logging tag
//
/*
 * Crafted by: Jim Buckeyne
 *
 * Purpose: Provide a well defined, concise structure for
 *   describing controls.  The only methods that are well
 *   supported are create, destroy, draw, mouse, and keyboard
 *   all others are dispatched as appropriate, but may be
 *   somewhat before or after what others might like.
 *
 *
 *
 * Define registration function that hooks into deadstart loading
 * is available so that registrations are complete by the time the
 * application starts in main.
 *
 * (c)Freedom Collective, Jim Buckeyne 2006; SACK Collection.
 *
 */
#ifndef PSI_STUFF_DEFINED
#define PSI_STUFF_DEFINED
PSI_NAMESPACE
#ifdef __cplusplus
#define PSI_ROOT_REGISTRY "psi++"
#define PSI_ROOT_REGISTRY_OTHER "psi"
#else
#define PSI_ROOT_REGISTRY "psi"
#define PSI_ROOT_REGISTRY_OTHER "psi++"
#endif
#ifdef __cplusplus
//	namespace registration {
#endif
/* Control Registration structure. Obsolete method of
   registering a control and the methods of a control. Internally
   these methods are just registered as they would with the
   procedure registration methods                                 */
struct ControlRegistration_tag {
	/* This is the name of this type of control. Future controls can
	   be created using this name. The name may not contain slashes,
	   but may contain spaces and other punctuation marks.           */
	CTEXTSTR name;
	/* This member is never referenced by name, it defines stuff
	 about the control like default width and height, size of the
	 extra data associated with the control (size of user data),
	 and the default border style of the control.                 */
	  struct control_extra_data {
		/* This member is never referenced by name, it defines stuff
		 about the control like default width and height           */
		struct width_height_tag {
			/* default width of the control. */
			uint32_t width;
			/* default height of the control. */
			uint32_t height;
		}	stuff;
 // default width, height for right-click creation.
		uint32_t extra;
  // default border style of the control see BorderOptionTypes
		uint32_t default_border;
		//CTEXTSTR master_config;
      //struct ControlRegistration_tag *pMasterConfig;
	}
	stuff
	;
	/* <combine sack::PSI::OnCreateCommon>
	   \ \                                 */
	int (CPROC*init)( PSI_CONTROL );
	/* <combine sack::PSI::SetCommonLoad@PSI_CONTROL@void __cdecl*int PSI_CONTROL>
	   This is depricated? Never figured a good way of saving extra
	   data in frames?                                                             */
	int (CPROC*load)( PSI_CONTROL , PTEXT parameters );
	/* <combine sack::PSI::OnDrawCommon>
	   \ \                               */
	int (CPROC*draw)( PSI_CONTROL  );
	/* <combine sack::PSI::OnMouseCommon>
	   \ \                                */
	int (CPROC*mouse)( PSI_CONTROL , int32_t x, int32_t y, uint32_t b );
	/* <combine sack::PSI::OnKeyCommon>
	   \ \                              */
	int (CPROC*key)( PSI_CONTROL , uint32_t );
	/* <combine sack::PSI::OnDestroyCommon>
	   \ \                                  */
	void (CPROC*destroy)( PSI_CONTROL  );
	/* <combine sack::PSI::OnPropertyEdit>
	   \ \                                                        */
	PSI_CONTROL (CPROC*prop_page)( PSI_CONTROL pc );
	/* <combine sack::PSI::OnPropertyEditOkay>
	   \ \                                     */
	void (CPROC*apply_prop)( PSI_CONTROL pc, PSI_CONTROL frame );
	void (CPROC*save)( PSI_CONTROL pc, PVARTEXT pvt );
	void (CPROC*AddedControl)(PSI_CONTROL me, PSI_CONTROL pcAdding );
	void (CPROC*CaptionChanged)( PSI_CONTROL pc );
	/* <combine sack::PSI::OnCommonFocus>
	   \ \                                */
	int (CPROC*FocusChanged)( PSI_CONTROL pc, LOGICAL bFocused );
   /* <combine sack::PSI::OnMotionCommon>
      \ \                                 */
   void (CPROC*PositionChanging)( PSI_CONTROL pc, LOGICAL bStart );
	/* \result data - uninitialized this is filled in by the
	   registrar (handler of registration). This Should have been
	   moved up, but it was meant to indicate the end of the
	   registration structure. This type ID is filled in by
	   DoRegisterControl. This type ID is a numeric ID that can be
	   checked to identify the type of the control, and make sure
	   that the user data retreived from the control is the correct
	   type.                                                        */
	uint32_t TypeID;
};
typedef struct ControlRegistration_tag CONTROL_REGISTRATION;
typedef struct ControlRegistration_tag *PCONTROL_REGISTRATION;
#define LinePaste(a,b) a##b
#define LinePaste2(a,b) LinePaste(a,b)
#define SYMVAL(a) a
#define EasyRegisterControl( name, extra ) static CONTROL_REGISTRATION LinePaste2(ControlType,SYMVAL(__LINE__))= { name, { 32, 32, extra, BORDER_THINNER } }; PRELOAD( LinePaste2(SimpleRegisterControl,__LINE__) ){ DoRegisterControl( &LinePaste2(ControlType,SYMVAL(__LINE__)) ); } static uint32_t* _MyControlID = &LinePaste2(ControlType,SYMVAL(__LINE__)).TypeID;
#define EasyRegisterControlEx( name, extra, reg_name ) static CONTROL_REGISTRATION reg_name= { name, { 32, 32, extra, BORDER_THINNER } }; PRELOAD( SimpleRegisterControl##reg_name ){ DoRegisterControl( &reg_name ); } static uint32_t* _MyControlID##reg_name = &reg_name.TypeID;
#define EasyRegisterControlWithBorder( name, extra, border_flags ) static CONTROL_REGISTRATION LinePaste2(ControlType,SYMVAL(__LINE__))= { name, { 32, 32, extra, border_flags} }; PRELOAD( LinePaste2(SimpleRegisterControl,SYMVAL(__LINE__)) ){ DoRegisterControl( &LinePaste2(ControlType,SYMVAL(__LINE__)) ); } static uint32_t* _MyControlID = &LinePaste2(ControlType,SYMVAL(__LINE__)).TypeID;
#define EasyRegisterControlWithBorderEx( name, extra, border_flags, reg_name ) static CONTROL_REGISTRATION reg_name= { name, { 32, 32, extra, border_flags} }; PRELOAD( SimpleRegisterControl##reg_name ){ DoRegisterControl( &reg_name ); } static uint32_t* _MyControlID##reg_name = &reg_name.TypeID;
#define RegisterControlWithBorderEx( name, extra, border_flags, reg_name )  CONTROL_REGISTRATION reg_name= { name, { 32, 32, extra, border_flags} }; PRELOAD( SimpleRegisterControl##reg_name ){ DoRegisterControl( &reg_name ); } uint32_t* _MyControlID##reg_name = &reg_name.TypeID;
#define ExternRegisterControlWithBorderEx( name, extra, border_flags, reg_name ) extern CONTROL_REGISTRATION reg_name; extern uint32_t* _MyControlID##reg_name;
#define MyControlID (_MyControlID[0])
#define MyControlIDEx(n) (_MyControlID##n[0])
#define MyValidatedControlData( type, result, pc ) ValidatedControlData( type, MyControlID, result, pc )
#define MyValidatedControlDataEx( type, reg_name, result, pc ) ValidatedControlData( type, MyControlIDEx(reg_name), result, pc )
//#define CONTROL_METHODS(draw,mouse,key,destroy) {{"draw",draw},{"mouse",mouse},{"key",key},{"destroy",destroy}}
//---------------------------------------------------------------------------
// please fill out the required forms, submit them once and only once.
// see form definition above, be sure to sign them.
	// in the future (after now), expansion can be handled by observing the size
	// of the registration entry.  at sizeof(registration) - 4 is always the
   // type ID result of this registration...
	PSI_PROC( int, DoRegisterControlEx )( PCONTROL_REGISTRATION pcr, int sizeof_registration );
#define DoRegisterControl(pcr) DoRegisterControlEx( pcr, sizeof(*pcr) )
//PSI_PROC( int, DoRegisterSubcontrol )( PSUBCONTROL_REGISTRATION pcr );
#define ControlData(type,common) ((common)?(*((type*)(common))):NULL)
#define SetControlData(type,common,pf) (*((type*)(common))) = (type)(pf)
#define ValidatedControlData(type,id,result,com) type result = (((com)&&(ControlType(com)==(id)))?ControlData(type,com):NULL)
#ifdef __cplusplus
//using namespace sack::psi::registration;
//namespace methods {
#endif
/* This event is called when a control is hidden. A control that
   is now hidden might do something like stop update timers,
   stop reading input information, or whatever else the control
   is doing that affects its display.
   Example
   <code lang="c++">
   static void OnHideCommon(name)( PSI_CONTROL control )
   {
   }
   </code>
   Internal
   Registers under
   /psi/control/\<name\>/hide_common=(PSI_CONTROL)@void@_@hide_common */
#define OnHideCommon(name)	 DefineRegistryMethod(PSI_ROOT_REGISTRY,HideCommon,"control",name "/hide_control",PASTE(name,"hide_control"),void,(PSI_CONTROL),__LINE__)
/* Event given to the control when it is shown. Some controls
   assign new content to themselves if they are now able to be
   shown.
   Example
   <code lang="c#">
   static void OnRevealCommon(name)( PSI_CONTROL control )
   {
       // do something when the control is revealed (was previously hidden)
   }
   </code>
   Internal
   Registers under
   /psi/control/\<name\>/reveal_control/reveal_control=(PSI_CONTROL)@void@_@reveal_control */
#define OnRevealCommon(name)	 DefineRegistryMethod(PSI_ROOT_REGISTRY,RevealCommon,"control",name "/reveal_control","reveal_control",void,(PSI_CONTROL),__LINE__)
/* This is the first event a control will receive. When it is
   created with MakeNamedControl, et al. this event will be
   called. It allows the control to initialize its personal data
   to something. It can be considered a constructor of the
   control.
   Example
   <code lang="c++">
   static int OnCreateCommon(name)( PSI_CONTROL control )
   {
       POINTER user_data = ControlData( control );
       //return 0; // return 0 or FALSE to fail control creation.
       return 1; // allow the control to be created
   }
   </code>
   Internal
   Registers under
   /psi/control/\<name\>/rtt/init=(PSI_CONTROL)@int@_@init        */
#define OnCreateCommon(name)	  DefineRegistryMethod(PSI_ROOT_REGISTRY,_OnCreateCommon,"control",name "/rtti","init",int,(PSI_CONTROL), __LINE__)
/* Event given to a control when it needs to draw.
   Example
   <code lang="c#">
   static int OnDrawCommon(name)( PSI_CONTROL control )
   {
      // draw (or nto) to a control.
      // return TRUE to update, otherwise FALSE, and update will not be performed.
      // but then, child controls also do not draw, because their parent is not dirty?
   }
   </code>
   Internal
   Registers under
   /psi/control/\<name\>/rtti/draw=(PSI_CONTROL)@int@_@draw                           */
#define OnDrawCommon(name)	  DefineRegistryMethod(PSI_ROOT_REGISTRY,_OnDrawCommon,"control",name "/rtti","draw",int,(PSI_CONTROL), __LINE__)
/* Event given to a frame control when it needs to draw.
   Example
   <code lang="c#">
   static void OnDrawCaption(name)( PSI_CONTROL control, Image caption )
   {
      // draw (or nto) to a control.
      // return TRUE to update, otherwise FALSE, and update will not be performed.
      // but then, child controls also do not draw, because their parent is not dirty?
   }
   </code>
   Internal
   Registers under
   /psi/control/\<name\>/rtti/draw_caption=(PSI_CONTROL,Image)@void@_@draw                           */
#define OnDrawCaption(name)	  DefineRegistryMethod(PSI_ROOT_REGISTRY,_OnDrawCaption,"control",name "/rtti","draw_caption",void,(PSI_CONTROL, Image), __LINE__)
/* Event given to a control when it needs to draw its decorations after children have updated.
   Example
   <code lang="c#">
   static void OnDrawCommonDecorations(name)( PSI_CONTROL control )
   {
      // draw decorations (effects after child controls have drawn)
   }
   </code>
   Internal
   Registers under
   /psi/control/\<name\>/rtti/draw_decorations=(PSI_CONTROL)@void@_@draw                           */
#define OnDrawCommonDecorations(name)	  DefineRegistryMethod(PSI_ROOT_REGISTRY,_OnDrawCommonDecorations,"control",name "/rtti","decoration_draw",void,(PSI_CONTROL,PSI_CONTROL), __LINE__)
/* User event callback called when a mouse event happens over a
   control, unless the control has claimed the mouse, in which
   case the mouse may not be over the control. X and Y are
   signed coordinates, if OwnMouse is called, then mouse events
   outside of the control may be trapped. buttons is a
   combination of ButtonFlags. If there is no keyboard event,
   keys will also be given to mouse event as button MK_OBUTTON.
   Example
   <code lang="c++">
   static int OnMouseCommon( TEXT("YourControlName") )( PSI_CONTROL control, int32_t x, int32_t y, uint32_t buttons )
   {
       // if the control uses the mouse, it should return 1, else the mouse is passed through.
       return 0;
   }
   </code>
   Internal
   Registers under
   /psi/control/\<name\>/rtti/mouse =
   (PSI_CONTROL,int32_t,int32_t,uint32_t)@void@_@mouse                                                                */
#define OnMouseCommon(name)	  DefineRegistryMethod(PSI_ROOT_REGISTRY,_OnMouseCommon,"control",name "/rtti","mouse",int,(PSI_CONTROL,int32_t,int32_t,uint32_t), __LINE__)
/* Controls may register a keyboard event procedure. This will
   receive notifications about what key is hit. Using mouse keys
   are impractical, because you would have to test every key for
   a new up/down status and figure out which key it was that
   went up and down and whether you should so something. A
   Simple test for like 'is this the space bar' might work as a
   mouse event processing MK_OBUTTON events.
   Example
   This event may return TRUE if it uses the key or FALSE, and
   the key will be passed to the parent control to see if it
   wants to process it.
   <code lang="c++">
   static int OnKeyCommon( name )( PSI_CONTROL control, uint32_t key )
   {
      // a new key event has happened to this focused control.
      // the key passed may be parsed with macros from keybrd.h
      // that is, a key is a bit packed event described by keybrd.h
   }
   </code>
   Internal
   Registers under
   /psi/control/\<name\>/rtti/key=(PSI_CONTROL,uint32_t)@int@_@key       */
#define OnKeyCommon(name)	  DefineRegistryMethod(PSI_ROOT_REGISTRY,_OnKeyCommon,"control",name "/rtti","key",int,(PSI_CONTROL,uint32_t), __LINE__)
/* This event callback is called when a control's position
   changes. Usually only happens on the outer parent frame.
   Example
   <code lang="c++">
   static void OnMoveCommon(name)( PSI_CONTROL control, LOGICAL bStart )
   {
       // if bStart is TRUE, the control is about to be moved
       // if bStart is FALSE, then the control is now in a new location.
   }
   </code>
   Internal
   Registers under
   /psi/control/\<name\>/rtti/position_changing=
   (PSI_CONTROL,LOGICAL)@void@_@position_changing                        */
#define OnMoveCommon(name)	  DefineRegistryMethod(PSI_ROOT_REGISTRY,_OnMoveCommon,"control",name "/rtti","position_changing",void,(PSI_CONTROL,LOGICAL), __LINE__)
/* User event that is triggered when the size of a control
   changes.
   Example
   The logical parameter passed is TRUE when sizing starts, and
   FALSE when sizing is done.
   <code lang="c++">
   static void OnSizeCommon( "control name" )( PSI_CONTROL control, LOGICAL begin_move )
   {
   }
   </code>
   Internal
   Registers under
   /psi/control/\<name\>/rtti/resize =
   (PSI_CONTROL)@void@_@resize                                                           */
#define OnSizeCommon(name)	  DefineRegistryMethod(PSI_ROOT_REGISTRY,_OnSizeCommon,"control",name "/rtti","resize",void,(PSI_CONTROL,LOGICAL), __LINE__)
/* User event that is triggered when the size of a control
   changes.
   Example
   The logical parameter passed is TRUE when sizing starts, and
   FALSE when sizing is done.
   <code lang="c++">
   static void OnScaleCommon( "control name" )( PSI_CONTROL control, LOGICAL begin_move )
   {
   }
   </code>
   Internal
   Registers under
   /psi/control/\<name\>/rtti/resize =
   (PSI_CONTROL)@void@_@resize                                                           */
#define OnScaleCommon(name)	  DefineRegistryMethod(PSI_ROOT_REGISTRY,_OnScaleCommon,"control",name "/rtti","rescale",void,(PSI_CONTROL), __LINE__)
	/* move_starting is TRUE when the position starts changing and
	   is false when the change is done... this allows a critical
	   section to be entered and left around the resize.
	   Example
	   <code lang="c++">
	   static void OnMotionCommon(name)( PSI_CONTROL control, LOGICAL move_starting )
	   {
	       if( move_starting )
	       {
	   </code>
	   <code>
	          // move is starting, but still in old location
	       }
	   </code>
	   <code lang="c++">
	       else
	       {
	          // move has completed and control is in its target location.
	       }
	   }
	   </code>
	   Internal
	   Registers under
	   /psi/control/\<name\>/rtti/some_parents_position_changing=(PSI_CONTROL,LOGICAL)@void@_@some_parents_position_changing */
#define OnMotionCommon(name)	  DefineRegistryMethod(PSI_ROOT_REGISTRY,_OnMotionCommon,"control",name "/rtti","some_parents_position_changing",void,(PSI_CONTROL,LOGICAL), __LINE__)
/* Event when a control is being destroyed. Allows a control to
   destroy any internal resources it may have associated with
   the control.
   Example
   <code lang="c++">
   static void OnDestroyCommon(name)( PSI_CONTROL control )
   {
       // do anything you might need when this control is destroyed.
   }
   </code>
   Internal
   Registers under
   /psi/control/\<name\>/rtti/destroy=(PSI_CONTROL)@void@_@destroy   */
#define OnDestroyCommon(name)	  DefineRegistryMethod(PSI_ROOT_REGISTRY,_OnDestroyCommon,"control",name "/rtti","destroy",void,(PSI_CONTROL), __LINE__)
/* return a frame page to the caller for display.
   Example
   <code lang="c++">
   static PSI_CONTROL OnPropertyEdit(name)( PSI_CONTROL control )
   {
       // return an optional frame which will be added to the
       // edit dialogs tab control.
       return LoadXMLFrameOver(name ".configure.frame", control);
   }
   </code>
   return NULL for no dialog.
   Internal
   Registers under
   /psi/control/\<name\>/reveal_control/reveal_control=(PSI_CONTROL)@void@_@reveal_control
                                                                                           */
#define OnPropertyEdit(name)	 DefineRegistryMethod(PSI_ROOT_REGISTRY,PropertyEditControl,"control",name "/rtti","get_property_page",PSI_CONTROL,(PSI_CONTROL),__LINE__)
	/* bFocused will be true if control gains focus if !bFocused,
	   control is losing focus.
	   Return type is actually void now. The below notes were for
	   before.
	     1. with current focus is told it will lose focus (!bFocus).
	        1. control may allow focus loss (return !FALSE) (goto 3)
	        2. \  control may reject focus loss, which will force it
	           to remain (return FALSE)
	     2. current focus reference of the container is cleared
	     3. newly focused control is told it now has focus.
	        1. it may accept the focus (return TRUE/!FALSE)
	        2. it may reject the focus - and the focus will be left
	           nowhere.
	     4. \  the current focus reference of the container is set
	   Example
	   <code lang="c++">
	   static void OnCommonFocus(name)(PSI_CONTROL control, LOGICAL bFocused )
	   {
	      // update control to show focus.  Buttons draw a line under themselves, list boxes highlight
	      // edit fields draw a cursor for entering text...
	   }
	   </code>
	   Internal
	   Registers under
	   /psi/control/\<name\>/rtti/focus_changed=(PSI_CONTROL,LOGICAL)@void@_@focus_changed             */
#define OnCommonFocus(name)	 DefineRegistryMethod(PSI_ROOT_REGISTRY,FocusChanged,"control",name "/rtti","focus_changed",int,(PSI_CONTROL,LOGICAL),__LINE__)
/* The frame edit mode has begun, and controls are given an
   opportunity to make life good for themselves and those around
   them - such as sheet controls displaying sheets separately.
   Example
   <code lang="c++">
   static void OnEditFrame(name)( PSI_CONTROL control )
   {
       // setup control for editing
   }
   </code>
   Internal
   Registers under
   /psi/control/\<name\>/rtti/begin_frame_edit=(PSI_CONTROL)@void@_@begin_frame_edit */
#define OnEditFrame(name)	 DefineRegistryMethod(PSI_ROOT_REGISTRY,FrameEditControl,"control",name "/rtti","begin_frame_edit",void,(PSI_CONTROL),__LINE__)
/* When a frame's edit phase ends, controls are notified with
   this event.
   Example
   <code lang="c++">
   static void OnEditFrameDone( PSI_CONTROL control )
   {
      // a frame's edit is complete, update control appropriately.
   }
   </code>
   Internal
   Registers under
   /psi/control/\<name\>/rtti/end_frame_edit=(PSI_CONTROL)@void@_@end_frame_edit */
#define OnEditFrameDone(name)	 DefineRegistryMethod(PSI_ROOT_REGISTRY,_OnEditFrameDone,"control",name "/rtti","end_frame_edit",void,(PSI_CONTROL),__LINE__)
// somet
//#define OnFrameEdit(name)
//	DefineRegistryMethod(PSI_ROOT_REGISTRY,FrameEditControl,"common",name,"begin_edit",void,(void))
/* on okay - read your information for ( your control, from the
   frame )
   Example
   <code lang="c++">
   static void OnPropertyEditOkay(name)( PSI_CONTROL control, PSI_CONTROL property_sheet )
   {
       // read controls on property sheet and update control properties.
   }
   </code>
   Internal
   Registers under
   /psi/control/\<name\>/rtti/read_property_page=(PSI_CONTROL,PSI_CONTROL)@void@_@read_property_page */
#define OnPropertyEditOkay(name)	 DefineRegistryMethod(PSI_ROOT_REGISTRY,_OnPropertyEditOkay,"control",name "/rtti","read_property_page",void,(PSI_CONTROL,PSI_CONTROL),__LINE__)
/* on cancel return void ( your_control, the sheet your resulted
   to get_property_page
   Example
   <code lang="c++">
   static void OnPropertyEditCancel(name)( PSI_CONTROL control, PSI_CONTROL property_sheet )
   {
      // delete custom property sheet if any.
      // undo any changes as appropriate
   }
   </code>                                                                                   */
#define OnPropertyEditCancel(name)	 DefineRegistryMethod(PSI_ROOT_REGISTRY,PropertyEditCancelControl,"control",name "/rtti","abort_property_page",void,(PSI_CONTROL,PSI_CONTROL),__LINE__)
/* some controls may change their appearance and drawing
   characteristics based on having their properties edited. This
   is done after either read or abort is done, also after the
   container dialog is destroyed, thereby indicating that any
   reference to the frame you created is now gone, unless you
   did magic.
   Example
   <code lang="c++">
   static void OnPropertyEditDone(name)( PSI_CONTROL control )
   {
       // do something when edit mode on the frame is being exited.
   }
   </code>
   Internal
   Registers under
   /psi/control/\<name\>/rtti/done_property_page=(PSI_CONTROL)@void@_@done_property_page */
#define OnPropertyEditDone( name )	  DefineRegistryMethod(PSI_ROOT_REGISTRY,PropertyEditDoneControl,"control",name "/rtti","done_property_page",void,(PSI_CONTROL),__LINE__)
#define OnChangeCaption( name )	  DefineRegistryMethod(PSI_ROOT_REGISTRY,OnChangeCaption,"control",name "/rtti","caption_changed",void,(PSI_CONTROL), __LINE__)
#ifndef NO_TOUCH
/* function signature for the touch callback  which can be specified to handle events from touching the display.  see SetMouseHandler.
  would be 'wise' to retun 0 if ignored, 1 if observed (perhaps not used), but NOT ignored.  Return 1 if some of the touches are used.
  This will trigger a check to see if there are unused touches to continue sending... oh but on renderer there's only one callback, more
  important as a note of the control touch event handerer.
   Example
   <code lang="c++">
   static int OnTouchCommon(name)( PSI_CONTROL control, PTOUCHINPUT inputs, int input_count )
   {
       // do something when edit mode on the frame is being exited.
	   // set input[x].dwFlags |= TOUCHEVENTF_USED; as inputs are used.
	   // I also guess only events on that control should be sent, so the input list will change
	   // by control?
   }
   </code>
   Internal
   Registers under
   /psi/control/\<name\>/rtti/touch_event=(PSI_CONTROL,PINPUT_POINT,int)@int@_@touch_event */
#define OnTouchCommon(name)	  DefineRegistryMethod(PSI_ROOT_REGISTRY,_OnTouchCommon,"control",name "/rtti","touch_event",int,(PSI_CONTROL,PINPUT_POINT,int), __LINE__)
#endif
/* function signature for the custom border draw routine
   Example
   <code lang="c++">
   static int OnDrawCustomBorder(name)( PSI_CONTROL control, Image window )
	{
	// draw border decoration on the window surface child window can reveal
   // measurements if not known
   }
   </code>
   Internal
   Registers under
   /psi/control/\<name\>/rtti/border_draw=(PSI_CONTROL,Image)@void@_@touch_event */
#define OnDrawCustomBorder(name)	  DefineRegistryMethod(PSI_ROOT_REGISTRY,_OnDrawCustomBorder,"control",name "/rtti","border_draw",void,(PSI_CONTROL,Image), __LINE__)
		/* function signature for the custom border measure routine.
         allows custom border to specify left/right/top/bottom insets
   Example
   <code lang="c++">
   static int OnMeasuerCustomBorder(name)( PSI_CONTROL control, int *left_inset, int *top_inset, int *right_inset, int *bottom_inset )
	{
	     // fill inset result pointers with correct insets for the control...
   }
   </code>
   Internal
   Registers under
   /psi/control/\<name\>/rtti/border_measure=(PSI_CONTROL,int*,int*,int*,int*)@void@_@touch_event */
#define OnMeasureCustomBorder(name)	  DefineRegistryMethod(PSI_ROOT_REGISTRY,_OnMeasureCustomBorder,"control",name "/rtti","border_measure",void,(PSI_CONTROL,int*,int*,int*,int*), __LINE__)
// static LOGICAL OnDropAccept("")(PSI_CONTROL pc_canvas,CTEXTSTR filepath,int x,int y)
#define OnControlDropAccept(name)	  DefineRegistryMethod(PSI_ROOT_REGISTRY,_OnControlDropAccept,"control",name "/rtti","drop_accept",LOGICAL,(PSI_CONTROL,CTEXTSTR,int32_t,int32_t), __LINE__)
// static void OnControlRollover("")(PSI_CONTROL pc_canvas,LOGICAL enter)
// enter is a boolean if true mouse entered control else mouse left control
#define OnControlRollover(name)	  DefineRegistryMethod(PSI_ROOT_REGISTRY,_OnControlRollover,"control",name "/rtti","rollover",void,(PSI_CONTROL,LOGICAL), __LINE__)
// static void OnControlFontChange("")(PSI_CONTROL pc)
// font on control or parent of control has changed.
#define OnControlFontChanged(name)	  DefineRegistryMethod(PSI_ROOT_REGISTRY,_OnControlFontChange,"control",name "/rtti","font_change",void,(PSI_CONTROL), __LINE__)
// just a passing thought.
//#define OnEditFrameBegin( name )
//	DefineRegistryMethod(PSI_ROOT_REGISTRY,EditFrameBegin,"common",name,"frame_edit_begin",void,(PSI_CONTROL))
// and here we can use that fancy declare method thing
// to register the appropriate named things LOL!
//
PSI_NAMESPACE_END
#endif
#define SPOT_SIZE 4
PSI_MOUSE_NAMESPACE
uintptr_t CPROC AltFrameMouse( uintptr_t psvCommon, int32_t x, int32_t y, uint32_t b );
int CPROC DefaultFrameMouse( PSI_CONTROL pc, int32_t x, int32_t y, uint32_t b );
PSI_MOUSE_NAMESPACE_END
USE_PSI_MOUSE_NAMESPACE
PSI_NAMESPACE
//void DrawFrameCaption( PSI_CONTROL );
//void DrawFrameCaptionEx( PSI_CONTROL pc DBG_PASS );
//#define DrawFrameCaption(pc) DrawFrameCaptionEx( pc DBG_SRC )
PSI_NAMESPACE_END
PSI_NAMESPACE
#ifndef FIRST_SYMBOL_VALUE
#define FIRST_SYMBOL_VALUE 1
#endif
#ifndef BUILD_NAMES
#  if !defined( NAME_ENUMERATION_DECLARED )
#    define FIRST_SYMNAME(name,control_type_name)    FIRST_SYMBOL = FIRST_SYMBOL_VALUE, name = FIRST_SYMBOL_VALUE
#    define SYMNAME(name,control_type_name)        , name
#    define SYMNAME_SKIP(prior, range, name,control_type_name)        , prior, name = prior+range
enum resource_enum {
#  endif
#endif
#if !defined( NAME_ENUMERATION_DECLARED ) || defined( BUILD_NAMES )
#undef BTN_OKAY
#undef BTN_CANCEL
FIRST_SYMNAME( BTN_OKAY, NORMAL_BUTTON_NAME )
SYMNAME(BTN_CANCEL,NORMAL_BUTTON_NAME)
SYMNAME( BTN_ABORT, NORMAL_BUTTON_NAME )
SYMNAME( EDT_X     , EDIT_FIELD_NAME )
SYMNAME( EDT_Y     , EDIT_FIELD_NAME )
SYMNAME( EDT_WIDTH , EDIT_FIELD_NAME )
SYMNAME( EDT_HEIGHT, EDIT_FIELD_NAME )
SYMNAME( EDT_CAPTION, EDIT_FIELD_NAME)
SYMNAME( EDT_ID     , EDIT_FIELD_NAME)
SYMNAME( EDT_IDNAME , EDIT_FIELD_NAME)
SYMNAME( LABEL_X    , STATIC_TEXT_NAME )
SYMNAME( LABEL_Y    , STATIC_TEXT_NAME)
SYMNAME( LABEL_WIDTH  , STATIC_TEXT_NAME)
SYMNAME( LABEL_HEIGHT , STATIC_TEXT_NAME)
SYMNAME( LABEL_CAPTION, STATIC_TEXT_NAME)
SYMNAME( LABEL_ID     , STATIC_TEXT_NAME)
SYMNAME( LISTBOX_IDS , LISTBOX_CONTROL_NAME  )
SYMNAME( SLD_GREENBAR    , SLIDER_CONTROL_NAME )
SYMNAME( PAL_COLORS      , "Color Matrix" )
 // define a preset
SYMNAME( BTN_PRESET      , NORMAL_BUTTON_NAME )
SYMNAME( CHK_ALPHA       , RADIO_BUTTON_NAME  )
SYMNAME( CST_SHADE       , "Shade Well" )
SYMNAME( CST_ZOOM        , "Shade Well" )
SYMNAME( CST_SHADE_RED   , "Shade Well" )
SYMNAME( CST_SHADE_BLUE  , "Shade Well" )
SYMNAME( CST_SHADE_GREEN , "Shade Well" )
		SYMNAME_SKIP( BTN_PRESET_BASE, 64, BTN_PRESET_LAST, CUSTOM_BUTTON_NAME )
#endif
#ifndef BUILD_NAMES
#  if !defined( NAME_ENUMERATION_DECLARED )
#  define NAME_ENUMERATION_DECLARED
};
#  endif
#endif
#undef SYMNAME
#undef FIRST_SYMNAME
#undef SYMNAME_SKIP
#undef BUILD_NAMES
#ifdef BLAT_COLOR_UPDATE_PORTION
// was for testing blotting regions...
  CDATA TESTCOLOR;
#endif
typedef struct resource_names
{
	uint32_t resource_name_id;
	uint32_t resource_name_range;
	CTEXTSTR resource_name;
	CTEXTSTR type_name;
} RESOURCE_NAMES;
static RESOURCE_NAMES resource_names[] = {
#define BUILD_NAMES
#ifdef __cplusplus
#define FIRST_SYMNAME(name,control_type_name)  { name, 1, #name, control_type_name }
#define SYMNAME(name,control_type_name)  , { name, 1, #name, control_type_name }
#define SYMNAME_SKIP(prior,range,name,control_type_name)  , { prior, range, #prior, control_type_name }	 , { name, 1, #name, control_type_name }
#else
#ifdef __WATCOMC__
#define FIRST_SYMNAME(name,control_type_name)  [name - FIRST_SYMBOL] = { name, 1, #name, control_type_name }
#define SYMNAME(name,control_type_name)  , [name - FIRST_SYMBOL] = { name, 1, #name, control_type_name }
#define SYMNAME_SKIP(prior,range,name,control_type_name)  , [prior - FIRST_SYMBOL] = { prior, range, #prior, control_type_name }	 , [name - FIRST_SYMBOL] = { name, 1, #name, control_type_name }
#else
#define FIRST_SYMNAME(name,control_type_name)  { name, 1, #name, control_type_name }
#define SYMNAME(name,control_type_name)  , { name, 1, #name, control_type_name }
#define SYMNAME_SKIP(prior,range,name,control_type_name)  , { prior, range, #prior, control_type_name }	 , { name, 1, #name, control_type_name }
#endif
#endif
#ifndef FIRST_SYMBOL_VALUE
#define FIRST_SYMBOL_VALUE 1
#endif
#ifndef BUILD_NAMES
#  if !defined( NAME_ENUMERATION_DECLARED )
#    define FIRST_SYMNAME(name,control_type_name)    FIRST_SYMBOL = FIRST_SYMBOL_VALUE, name = FIRST_SYMBOL_VALUE
#    define SYMNAME(name,control_type_name)        , name
#    define SYMNAME_SKIP(prior, range, name,control_type_name)        , prior, name = prior+range
enum resource_enum {
#  endif
#endif
#if !defined( NAME_ENUMERATION_DECLARED ) || defined( BUILD_NAMES )
#undef BTN_OKAY
#undef BTN_CANCEL
FIRST_SYMNAME( BTN_OKAY, NORMAL_BUTTON_NAME )
SYMNAME(BTN_CANCEL,NORMAL_BUTTON_NAME)
SYMNAME( BTN_ABORT, NORMAL_BUTTON_NAME )
SYMNAME( EDT_X     , EDIT_FIELD_NAME )
SYMNAME( EDT_Y     , EDIT_FIELD_NAME )
SYMNAME( EDT_WIDTH , EDIT_FIELD_NAME )
SYMNAME( EDT_HEIGHT, EDIT_FIELD_NAME )
SYMNAME( EDT_CAPTION, EDIT_FIELD_NAME)
SYMNAME( EDT_ID     , EDIT_FIELD_NAME)
SYMNAME( EDT_IDNAME , EDIT_FIELD_NAME)
SYMNAME( LABEL_X    , STATIC_TEXT_NAME )
SYMNAME( LABEL_Y    , STATIC_TEXT_NAME)
SYMNAME( LABEL_WIDTH  , STATIC_TEXT_NAME)
SYMNAME( LABEL_HEIGHT , STATIC_TEXT_NAME)
SYMNAME( LABEL_CAPTION, STATIC_TEXT_NAME)
SYMNAME( LABEL_ID     , STATIC_TEXT_NAME)
SYMNAME( LISTBOX_IDS , LISTBOX_CONTROL_NAME  )
SYMNAME( SLD_GREENBAR    , SLIDER_CONTROL_NAME )
SYMNAME( PAL_COLORS      , "Color Matrix" )
 // define a preset
SYMNAME( BTN_PRESET      , NORMAL_BUTTON_NAME )
SYMNAME( CHK_ALPHA       , RADIO_BUTTON_NAME  )
SYMNAME( CST_SHADE       , "Shade Well" )
SYMNAME( CST_ZOOM        , "Shade Well" )
SYMNAME( CST_SHADE_RED   , "Shade Well" )
SYMNAME( CST_SHADE_BLUE  , "Shade Well" )
SYMNAME( CST_SHADE_GREEN , "Shade Well" )
		SYMNAME_SKIP( BTN_PRESET_BASE, 64, BTN_PRESET_LAST, CUSTOM_BUTTON_NAME )
#endif
#ifndef BUILD_NAMES
#  if !defined( NAME_ENUMERATION_DECLARED )
#  define NAME_ENUMERATION_DECLARED
};
#  endif
#endif
#undef SYMNAME
#undef FIRST_SYMNAME
#undef SYMNAME_SKIP
#undef BUILD_NAMES
};
TEXTCHAR *GetResourceIDName( CTEXTSTR pTypeName, int ID )
{
	PCLASSROOT data = NULL;
	CTEXTSTR name;
	for( name = GetFirstRegisteredName( PSI_ROOT_REGISTRY "/resources/", &data );
		  name;
		  name = GetNextRegisteredName( &data ) )
	{
		TEXTCHAR rootname[256];
		CTEXTSTR name2;
		PCLASSROOT data2 = NULL;
		tnprintf( rootname, sizeof(rootname),PSI_ROOT_REGISTRY "/resources/%s/%s", name, pTypeName );
		//lprintf( "newroot = %s", rootname );
		for( name2 = GetFirstRegisteredName( rootname, &data2 );
			 name2;
			  name2 = GetNextRegisteredName( &data2 ) )
		{
			int value = (int)(uintptr_t)(GetRegisteredValueExx( data2, name2, "value", TRUE ));
			int range = (int)(uintptr_t)(GetRegisteredValueExx( data2, name2, "range", TRUE ));
			//lprintf( "Found Name %s", name2 );
			if( (value <= ID) && ((value+range) > ID) )
			{
				size_t len;
				TEXTCHAR *result = NewArray( TEXTCHAR, len = strlen( pTypeName ) + strlen( name ) + strlen( name2 ) + 3 + 20 );
				if( value == ID )
					tnprintf( result, len*sizeof(TEXTCHAR), "%s/%s/%s", name, pTypeName, name2 );
				else
					tnprintf( result, len*sizeof(TEXTCHAR), "%s/%s/%s+%d", name, pTypeName, name2, ID-value );
				return result;
			}
		}
	}
	return NULL;
}
// also fix the name passed in?
int GetResourceID( PSI_CONTROL parent, CTEXTSTR name, uint32_t nIDDefault )
{
	if( !pathchr( name ) )
	{
		// assume search mode to find name... using name as terminal leef, but application and control class are omitted...
		PCLASSROOT data = NULL;
		CTEXTSTR name;
		//DebugBreak(); // changed 'name' to data and 'name2' to 'data2' ...
		for( name = GetFirstRegisteredName( PSI_ROOT_REGISTRY "/resources/", &data );
			 name;
			  name = GetNextRegisteredName( &data ) )
		{
			//TEXTCHAR rootname[256];
			CTEXTSTR name2;
			PCLASSROOT data2 = NULL;
			//tnprintf( rootname, sizeof(rootname),PSI_ROOT_REGISTRY "/resources/%s", name );
			//lprintf( "newroot = %s", rootname );
			for( name2 = GetFirstRegisteredName( (CTEXTSTR)data, &data2 );
				 name2;
				  name2 = GetNextRegisteredName( &data2 ) )
			{
				TEXTCHAR rootname[256];
				int nResult;
				//lprintf( "Found Name %s", name2 );
				tnprintf( rootname, sizeof( rootname ), PSI_ROOT_REGISTRY "/resources/%s/%s", name, name2 );
				if( GetRegisteredStaticIntValue( NULL, rootname, name, &nResult ) )
				{
					return nResult;
				}
				else
				{
					if( ( nIDDefault != -1 ) )
					{
						RegisterIntValue( rootname, "value", nIDDefault );
						//RegisterIntValue( rootname, "range", offset + 1 );
						return nIDDefault;
					}
				}
			}
		}
	}
	else
	{
		CTEXTSTR ofs_string;
		int offset = 0;
		ofs_string = strchr( name, '+' );
		if( ofs_string )
		{
			offset = (int)IntCreateFromText( ofs_string );
			(*((TEXTCHAR*)ofs_string)) = 0;
		}
		{
			int result;
			int range;
			TEXTCHAR buffer[256];
			tnprintf( buffer, sizeof( buffer ), PSI_ROOT_REGISTRY "/resources/%s", name );
			range = (int)(uintptr_t)GetRegisteredValueExx( (PCLASSROOT)PSI_ROOT_REGISTRY "/resources", name, "range", TRUE );
/* + offset*/
			result = (int)(uintptr_t)GetRegisteredValueExx( (PCLASSROOT)PSI_ROOT_REGISTRY "/resources", name, "value", TRUE );
			if( !result && !range && ( nIDDefault != -1 ) )
			{
				RegisterIntValue( buffer, "value", nIDDefault );
				RegisterIntValue( buffer, "range", offset + 1 );
				result = nIDDefault;
				range = offset + 1;
			}
			// auto offset old resources...
			// this is probably depricated code, but wtf.
			if( parent && range > 1 && !ofs_string )
			{
				PSI_CONTROL pc;
 // alternative way to compute offset here...
				offset = 0;
				for( pc = parent->child; pc; pc = pc->next )
				{
					if( pc->nID >= result && ( pc->nID < (result+range) ) )
						offset++;
				}
			}
			result += offset;
			if( ofs_string )
				(*((TEXTCHAR*)ofs_string)) = '+';
#ifdef DEBUG_RESOURCE_NAME_LOOKUP
			lprintf( "Result of %s is %d", name, result );
#endif
			return result;
		}
	}
 // TXT_STATIC id... invalid to search or locate on...
	return -1;
}
// yes, sometimes we end up having to register psi outside of preload...
// sometimes it works.
static void CPROC InitPSILibrary( void );
//#undef DoRegisterControl
int DoRegisterControlEx( PCONTROL_REGISTRATION pcr, int nSize )
{
	if( pcr )
	{
#ifdef __cplusplus_cli
		// skip these well above legacy controls...
		// if we have 50 controls existing we'd be lucky
		// so creation of 1950 more controls shouldn't happen
		// within the timespan of xperdex.
		static uint32_t ControlID = USER_CONTROL + 2000;
#else
		static uint32_t ControlID = USER_CONTROL;
#endif
		TEXTCHAR namebuf[64], namebuf2[64];
		PCLASSROOT root;
		//lprintf( "Registering control: %s", pcr->name );
		// okay do this so we get our names right?
		InitPSILibrary();
		//pcr->TypeID = ControlID;
		tnprintf( namebuf2, sizeof( namebuf2 ), PSI_ROOT_REGISTRY "/control/%s"
				  , pcr->name );
		root = GetClassRoot( namebuf2 );
		pcr->TypeID = (int)(uintptr_t)GetRegisteredValueExx( root, NULL, "Type", TRUE );
		if( !pcr->TypeID && (StrCaseCmp( pcr->name, "FRAME" )!=0) )
		{
			ControlID = (uint32_t)(uintptr_t)GetRegisteredValueExx( "PSI/Controls", NULL, "User Type ID", TRUE);
			if( !ControlID )
			{
#ifdef __cplusplus_cli
				ControlID = USER_CONTROL + 2000;
#else
				ControlID = USER_CONTROL;
#endif
			}
			pcr->TypeID = ControlID;
			tnprintf( namebuf, sizeof( namebuf ), PSI_ROOT_REGISTRY "/control/%" _32f
					  , ControlID );
			root = RegisterClassAlias( namebuf2, namebuf );
			RegisterValueExx( root, NULL, "Type", FALSE, pcr->name );
			RegisterValueExx( root, NULL, "Type", TRUE, (CTEXTSTR)(uintptr_t)ControlID );
			/*
			tnprintf( namebuf, sizeof( namebuf ), PSI_ROOT_REGISTRY "/control/%" _32f
					  , ControlID );
			root = RegisterClassAlias( namebuf2, namebuf );
			tnprintf( namebuf, sizeof( namebuf ), PSI_ROOT_REGISTRY "/control/%s"
				, pcr->name );
			root = RegisterClassAlias( namebuf2, namebuf );
			*/
 // new control type registered...
			ControlID++;
			RegisterIntValueEx( (PCLASSROOT)"PSI/Controls", NULL, "User Type ID", (uintptr_t)ControlID );
		}
		else
		{
			//char longbuf[128];
			//tnprintf( longbuf, sizeof( longbuf ), PSI_ROOT_REGISTRY "/control/%s/rtti", pcr->name );
			//if( CheckClassRoot( longbuf ) )
			{
				//lprintf( "Aborting second registration fo same type." );
				//return pcr->TypeID;
			}
		}
#define EXTRA2 stuff.stuff.
#define EXTRA stuff.
		RegisterIntValueEx( root, NULL, "extra", pcr->EXTRA extra );
		RegisterIntValueEx( root, NULL, "width", pcr->EXTRA2 width );
		RegisterIntValueEx( root, NULL, "height", pcr->EXTRA2 height );
		RegisterIntValueEx( root, NULL, "border", pcr->EXTRA default_border );
		// root will now be /psi/controls/(name)/rtti/...=...
		root = GetClassRootEx( root, "rtti" );
		if( pcr->init )
			SimpleRegisterMethod( root, pcr->init
									  , "int", "init", "(PSI_CONTROL,va_list)" );
		if( pcr->load )
			SimpleRegisterMethod( root, pcr->load
									  , "int", "load", "(PSI_CONTROL,PTEXT)" );
		if( pcr->draw )
			SimpleRegisterMethod( root, pcr->draw
									  , "void", "draw", "(PSI_CONTROL)" );
		if( pcr->mouse )
			SimpleRegisterMethod( root, pcr->mouse
									  , "void", "mouse", "(PSI_CONTROL,int32_t,int32_t,uint32_t)" );
		if( pcr->key )
			SimpleRegisterMethod( root, pcr->key
									  , "void", "key", "(PSI_CONTROL,uint32_t)" );
		if( pcr->destroy )
			SimpleRegisterMethod( root, pcr->destroy
									  , "void", "destroy", "(PSI_CONTROL)" );
		if( pcr->save )
			SimpleRegisterMethod( root, pcr->save
									  , "void", "save", "(PSI_CONTROL,PVARTEXT)" );
		if( pcr->prop_page )
			SimpleRegisterMethod( root, pcr->prop_page
									  , "PSI_CONTROL", "get_prop_page", "(PSI_CONTROL)" );
		if( pcr->apply_prop )
			SimpleRegisterMethod( root, pcr->apply_prop
									  , "void", "apply", "(PSI_CONTROL,PSI_CONTROL)" );
		if( pcr->CaptionChanged )
			SimpleRegisterMethod( root, pcr->CaptionChanged
									  , "void", "caption_changed", "(PSI_CONTROL)" );
		if( pcr->FocusChanged )
			SimpleRegisterMethod( root, pcr->FocusChanged
									  , "void", "focus_changed", "(PSI_CONTROL,LOGICAL)" );
		if( pcr->AddedControl )
			SimpleRegisterMethod( root, pcr->AddedControl
									  , "void", "add_control", "(PSI_CONTROL,PSI_CONTROL)" );
		if( nSize > ( offsetof( CONTROL_REGISTRATION, PositionChanging ) + sizeof( pcr->PositionChanging ) ) )
		{
			if( pcr->PositionChanging )
				SimpleRegisterMethod( root, pcr->PositionChanging
										  , "void", "position_changing", "(PSI_CONTROL,LOGICAL)" );
		}
		return ControlID;
	}
	return 0;
}
#ifdef USE_INTERFACES
void GetMyInterface( void )
#define GetMyInterface() if( !g.MyImageInterface || !g.MyDisplayInterface ) GetMyInterface()
{
	if( !g.MyImageInterface )
	{
		g.MyImageInterface = (PIMAGE_INTERFACE)GetInterface( "image" );
		if( !g.MyImageInterface )
			g.MyImageInterface = (PIMAGE_INTERFACE)GetInterface( "real_image" );
		if( !g.MyImageInterface )
		{
#ifndef XBAG
			//if( is_deadstart_complete() )
#endif
			{
#ifndef WIN32
				fprintf( stderr, "Failed to get 'image' interface.  PSI interfaces failing execution." );
#endif
				lprintf( "Failed to get 'image' interface.  PSI interfaces failing execution." );
				lprintf( "and why yes, if we had a display, I suppose we could allow someone to fix this problem in-line..." );
				lprintf( "-------- DIE - DIE - DIE - DIE - DIE - DIE - DIE - DIE - DIE - DIE - DIE ---------" );
				//DebugBreak();
				//exit(0);
			}
			lprintf( "Fail image load once..." );
		}
		SetControlImageInterface( g.MyImageInterface );
	}
	if( !g.MyDisplayInterface )
	{
		g.MyDisplayInterface = (PRENDER_INTERFACE)GetInterface( "render" );
		if( !g.MyImageInterface )
			g.MyDisplayInterface = (PRENDER_INTERFACE)GetInterface( "video" );
		if( !g.MyDisplayInterface )
		{
			{
#ifndef WIN32
				fprintf( stderr, "Failed to get 'render' interface.  PSI interfaces failing execution." );
#endif
				lprintf( "Failed to get 'render' interface.  PSI interfaces failing execution." );
				lprintf( "and why yes, if we had a display, I suppose we could allow someone to fix this problem in-line..." );
				//exit(0);
			}
			lprintf( "Fail render load once..." );
		}
		else
		{
		}
		SetControlInterface( g.MyDisplayInterface );
	}
}
#endif
//--------------------------------------------------------------------------
#ifdef __WATCOM_CPLUSPLUS__
#pragma initialize 47
#endif
PRIORITY_PRELOAD( InitPSILibrary, PSI_PRELOAD_PRIORITY )
{
	//static int bInited;
	if( !GetRegisteredIntValue( PSI_ROOT_REGISTRY "/init", "done" ) )
	//if( !bInited )
	{
		TEXTCHAR namebuf[64], namebuf2[64];
#define REG(name) {			   tnprintf( namebuf, sizeof( namebuf ), PSI_ROOT_REGISTRY "/control/%d", name );			 tnprintf( namebuf2, sizeof( namebuf2 ), PSI_ROOT_REGISTRY "/control/%s", name##_NAME );			             RegisterClassAlias( namebuf2, namebuf );			  RegisterValue( namebuf2, "Type", name##_NAME );			 RegisterIntValue( namebuf2, "Type", name );		 }
#define REG2(name,number) {			   tnprintf( namebuf, sizeof( namebuf ), PSI_ROOT_REGISTRY "/control/%d", number );			 tnprintf( namebuf2, sizeof( namebuf2 ), PSI_ROOT_REGISTRY "/control/%s", name );			             RegisterClassAlias( namebuf2, namebuf );			  RegisterValue( namebuf2, "Type", name );			 RegisterIntValue( namebuf2, "Type", number );		 }
		//lprintf( "Begin registering controls..." );
		REG(CONTROL_FRAME );
		REG(UNDEFINED_CONTROL );
		REG(CONTROL_SUB_FRAME );
		REG(STATIC_TEXT );
		REG(NORMAL_BUTTON );
		REG(CUSTOM_BUTTON );
		REG(IMAGE_BUTTON );
		REG(RADIO_BUTTON );
		REG(EDIT_FIELD );
		REG(SLIDER_CONTROL );
		REG(LISTBOX_CONTROL );
		REG(SCROLLBAR_CONTROL );
		REG(GRIDBOX_CONTROL );
		REG(CONSOLE_CONTROL );
		REG(SHEET_CONTROL );
		REG(COMBOBOX_CONTROL );
		REG2("Color Matrix", BUILTIN_CONTROL_COUNT + 0 );
		REG2("Font Sample", BUILTIN_CONTROL_COUNT + 1 );
		REG2("Font Size Control", BUILTIN_CONTROL_COUNT + 2 );
		REG2("Popup Menu", BUILTIN_CONTROL_COUNT + 3 );
		REG2("Basic Clock Widget", BUILTIN_CONTROL_COUNT + 4 );
		REG2("Scroll Knob", BUILTIN_CONTROL_COUNT + 5 );
		REG2("PSI Console", BUILTIN_CONTROL_COUNT + 6 );
		REG2("Shade Well", BUILTIN_CONTROL_COUNT + 7 );
		REG2("Color Well", BUILTIN_CONTROL_COUNT + 8 );
		{
			int nResources = sizeof( resource_names ) / sizeof( resource_names[0] );
			int n;
			for( n = 0; n < nResources; n++ )
			{
				if( resource_names[n].resource_name_id )
				{
					TEXTCHAR root[256];
					TEXTCHAR old_root[256];
#define TASK_PREFIX "core"
					tnprintf( root, sizeof( root )
							  , PSI_ROOT_REGISTRY "/resources/%s/" TASK_PREFIX "/%s"
							  , resource_names[n].type_name
							  , resource_names[n].resource_name );
					RegisterIntValue( root
										 , "value"
										 , resource_names[n].resource_name_id );
					RegisterIntValue( root
										 , "range"
										 , resource_names[n].resource_name_range );
					tnprintf( root, sizeof( root ), PSI_ROOT_REGISTRY "/resources/%s/" TASK_PREFIX "", resource_names[n].type_name );
					tnprintf( old_root, sizeof( old_root ), PSI_ROOT_REGISTRY "/resources/" TASK_PREFIX "/%s", resource_names[n].type_name );
					RegisterIntValue( root
										 , resource_names[n].resource_name
										 , resource_names[n].resource_name_id );
					RegisterClassAlias( root, old_root );
				}
			}
		}
		RegisterIntValue( PSI_ROOT_REGISTRY "/init", "done", 1 );
	}
}
PFrameBorder PSI_CreateBorder( Image image, int width, int height, int anchors, LOGICAL defines_colors )
{
	GetMyInterface();
	 //if( !g.BorderImage )
	if( image )
	{
		PFrameBorder border;
		INDEX idx;
		LIST_FORALL( g.borders, idx, PFrameBorder, border )
		{
			if( border->BorderImage == image )
				return border;
		}
		border = New( FrameBorder );
		border->hasFill = 0;
		border->drawFill = 0;
		border->defaultcolors = (CDATA*)Allocate( sizeof( DefaultColors ) );
		MemCpy( border->defaultcolors, DefaultColors, sizeof( DefaultColors ) );
		border->BorderImage = image;
		if( border->BorderImage )
		{
			int MiddleSegmentWidth, MiddleSegmentHeight;
			/*
			if( border->BorderImage->width & 1 )
				border->BorderWidth = border->BorderImage->width / 2;
			else
				border->BorderWidth = (border->BorderImage->width-1) / 2;
			if( border->BorderImage->height )
				border->BorderHeight = border->BorderImage->height / 2;
			else
				border->BorderHeight = (border->BorderImage->height-1) / 2;
			*/
			border->BorderWidth = width;
			border->BorderHeight = height;
			border->Border.bAnchorTop = ( ( anchors & BORDER_ANCHOR_TOP_MASK ) >> BORDER_ANCHOR_TOP_SHIFT );
			border->Border.bAnchorLeft = ( ( anchors & BORDER_ANCHOR_LEFT_MASK ) >> BORDER_ANCHOR_LEFT_SHIFT );
			border->Border.bAnchorRight = ( ( anchors & BORDER_ANCHOR_RIGHT_MASK ) >> BORDER_ANCHOR_RIGHT_SHIFT );
			border->Border.bAnchorBottom = ( ( anchors & BORDER_ANCHOR_BOTTOM_MASK ) >> BORDER_ANCHOR_BOTTOM_SHIFT );
			// overcompensate if the settings cause an underflow
			if( border->BorderWidth > border->BorderImage->width )
				border->BorderWidth = border->BorderImage->width / 3;
			if( border->BorderHeight > border->BorderImage->height )
				border->BorderHeight= border->BorderImage->height / 3;
			MiddleSegmentWidth = border->BorderImage->width - (border->BorderWidth*2);
			MiddleSegmentHeight = border->BorderImage->height - (border->BorderHeight*2);
			border->BorderSegment[SEGMENT_TOP_LEFT] = MakeSubImage( border->BorderImage, 0, 0, border->BorderWidth, border->BorderHeight );
			border->BorderSegment[SEGMENT_TOP] = MakeSubImage( border->BorderImage, border->BorderWidth, 0
																	 , MiddleSegmentWidth, border->BorderHeight );
			border->BorderSegment[SEGMENT_TOP_RIGHT] = MakeSubImage( border->BorderImage, border->BorderWidth + MiddleSegmentWidth, 0, border->BorderWidth, border->BorderHeight );
			border->BorderSegment[SEGMENT_LEFT] = MakeSubImage( border->BorderImage
																	  , 0, border->BorderHeight
																	  , border->BorderWidth, MiddleSegmentHeight );
			border->BorderSegment[SEGMENT_CENTER] = MakeSubImage( border->BorderImage
																		 , border->BorderWidth, border->BorderHeight
																		 , MiddleSegmentWidth, MiddleSegmentHeight );
			border->BorderSegment[SEGMENT_RIGHT] = MakeSubImage( border->BorderImage
																		, border->BorderWidth + MiddleSegmentWidth, border->BorderHeight
																		, border->BorderWidth, MiddleSegmentHeight );
			border->BorderSegment[SEGMENT_BOTTOM_LEFT] = MakeSubImage( border->BorderImage
																				, 0, border->BorderHeight + MiddleSegmentHeight
																				, border->BorderWidth, border->BorderHeight );
			border->BorderSegment[SEGMENT_BOTTOM] = MakeSubImage( border->BorderImage
																		 , border->BorderWidth, border->BorderHeight + MiddleSegmentHeight
																	 , MiddleSegmentWidth, border->BorderHeight );
			border->BorderSegment[SEGMENT_BOTTOM_RIGHT] = MakeSubImage( border->BorderImage
																				 , border->BorderWidth + MiddleSegmentWidth, border->BorderHeight + MiddleSegmentHeight
																				 , border->BorderWidth, border->BorderHeight );
			if( 1
 /*SACK_GetProfileInt( "SACK/PSI/Frame border"
					, "Use center base colors"
					, 1 )*/
 )
			{
				//CDATA *old_colors = border->defaultcolors;
				//border->defaultcolors = (CDATA*)Allocate( sizeof( DefaultColors ) );
				//MemCpy( border->defaultcolors, DefaultColors, sizeof( DefaultColors ) );
				if( border->BorderSegment[SEGMENT_CENTER]->height >= 2
					&& border->BorderSegment[SEGMENT_CENTER]->width >= 7
					&& defines_colors )
				{
#define TestAndSetBaseColor( c, s ) { CDATA src = s; if( src ) border->defaultcolors[c] = src; }
					TestAndSetBaseColor( HIGHLIGHT          , getpixel( border->BorderSegment[SEGMENT_CENTER], 0, 0 ) );
					TestAndSetBaseColor( SHADE               , getpixel( border->BorderSegment[SEGMENT_CENTER], 0, 1 ) );
					TestAndSetBaseColor( NORMAL              , getpixel( border->BorderSegment[SEGMENT_CENTER], 1, 0 ) );
					TestAndSetBaseColor( SHADOW              , getpixel( border->BorderSegment[SEGMENT_CENTER], 1, 1 ) );
					TestAndSetBaseColor( TEXTCOLOR           , getpixel( border->BorderSegment[SEGMENT_CENTER], 2, 0 ) );
					TestAndSetBaseColor( CAPTIONTEXTCOLOR    , getpixel( border->BorderSegment[SEGMENT_CENTER], 3, 0 ) );
					TestAndSetBaseColor( CAPTION             , getpixel( border->BorderSegment[SEGMENT_CENTER], 3, 1 ) );
					TestAndSetBaseColor( INACTIVECAPTIONTEXTCOLOR, getpixel( border->BorderSegment[SEGMENT_CENTER], 4, 0 ) );
					TestAndSetBaseColor( INACTIVECAPTION     , getpixel( border->BorderSegment[SEGMENT_CENTER], 4, 1 ) );
					TestAndSetBaseColor( SELECT_TEXT         , getpixel( border->BorderSegment[SEGMENT_CENTER], 5, 0 ) );
					TestAndSetBaseColor( SELECT_BACK         , getpixel( border->BorderSegment[SEGMENT_CENTER], 5, 1 ) );
					TestAndSetBaseColor( EDIT_TEXT           , getpixel( border->BorderSegment[SEGMENT_CENTER], 6, 0 ) );
					TestAndSetBaseColor( EDIT_BACKGROUND     , getpixel( border->BorderSegment[SEGMENT_CENTER], 6, 1 ) );
					TestAndSetBaseColor( SCROLLBAR_BACK      , getpixel( border->BorderSegment[SEGMENT_CENTER], 7, 0 ) );
				}
				else
					TestAndSetBaseColor( NORMAL              , 0 );
				border->BorderSegment[SEGMENT_CENTER] = MakeSubImage( border->BorderImage
					, border->BorderWidth, border->BorderHeight
					, MiddleSegmentWidth, MiddleSegmentHeight );
				if( MiddleSegmentWidth > 2 * border->BorderWidth )
					border->hasFill = TRUE;
			}
		}
		AddLink( &g.borders, border );
		return border;
	}
	return NULL;
}
void PSI_SetFrameBorder( PSI_CONTROL pc, PFrameBorder border )
{
	pc->border = border;
	if( !( pc->BorderType & BORDER_USER_PROC ) )
		pc->DrawBorder = (pc->border&&pc->border->BorderImage)?DrawFancyFrame:DrawNormalFrame;
	if( border )
		border->drawFill = 1;
	UpdateSurface( pc );
}
//#define basecolor(pc) ((pc)?((pc)->border?(pc)->border->defaultcolors:(pc)->basecolors):(g.DefaultBorder?g.DefaultBorder->defaultcolors:DefaultColors))
CDATA *basecolor( PSI_CONTROL pc )
{
	//xlprintf( "get base color pc: %p %p %p", pc, pc?pc->basecolors:0, pc?pc->border:0 );
	if( pc )
		if( ( pc )->border ) {
			return ( pc )->border->defaultcolors;
		} else {
			if( pc->basecolors )
				return ( pc )->basecolors;
			return basecolor( pc->parent );
		}
	else
		if (g.DefaultBorder)
			return g.DefaultBorder->defaultcolors;
		else
			return DefaultColors;
}
void TryLoadingFrameImage( void )
{
	if( g.flags.system_color_set )
		return;
#ifndef __NO_OPTIONS__
	g.StopButtonPad = SACK_GetProfileInt( "SACK/PSI"
		, "Frame close button pad"
		, 2 );
#else
	g.StopButtonPad = 2;
#endif
	if( !g.StopButton )
	{
		TEXTCHAR buffer[256];
#ifndef __NO_OPTIONS__
		SACK_GetProfileStringEx( GetProgramName(), "SACK/PSI/Frame close button image", "stop_button.png", buffer, sizeof( buffer ), TRUE );
#else
		StrCpy( buffer, "stop_button.png" );
#endif
		g.StopButton = LoadImageFileFromGroup( GetFileGroup( "Images", "./images" ), buffer );
	}
	if( !g.StopButtonPressed )
	{
		TEXTCHAR buffer[256];
#ifndef __NO_OPTIONS__
		SACK_GetProfileStringEx( GetProgramName(), "SACK/PSI/Frame close button pressed image", "stop_button_pressed.png", buffer, sizeof( buffer ), TRUE );
#else
		StrCpy( buffer, "stop_button_pressed.png" );
#endif
		g.StopButtonPressed = LoadImageFileFromGroup( GetFileGroup( "Images", "./images" ), buffer );
	}
	 if( !g.FrameCaptionImage )
	{
		TEXTCHAR buffer[256];
#ifndef __NO_OPTIONS__
		SACK_GetProfileStringEx( GetProgramName(), "SACK/PSI/Frame caption background", "", buffer, sizeof( buffer ), TRUE );
#else
		StrCpy( buffer, "" );
#endif
		if( buffer[0] )
			g.FrameCaptionImage = LoadImageFileFromGroup( GetFileGroup( "Images", "./images" ), buffer );
	}
	if( !g.FrameCaptionFocusedImage )
	{
		TEXTCHAR buffer[256];
#ifndef __NO_OPTIONS__
		SACK_GetProfileStringEx( GetProgramName(), "SACK/PSI/Frame caption focused background", "", buffer, sizeof( buffer ), TRUE );
#else
		StrCpy( buffer, "" );
#endif
		if( buffer[0] )
			g.FrameCaptionFocusedImage = LoadImageFileFromGroup( GetFileGroup( "Images", "./images" ), buffer );
	}
	 if( !g.DefaultBorder )
	{
		TEXTCHAR buffer[256];
		Image border_image;
		int width, height;
		int anchors;
#ifndef __NO_OPTIONS__
		SACK_GetProfileStringEx( GetProgramName(), "SACK/PSI/Frame border image", "frame2.png", buffer, sizeof( buffer ), TRUE );
#else
		StrCpy( buffer, "frame_border.png" );
#endif
		border_image = LoadImageFileFromGroup( GetFileGroup( "Images", "./images" ), buffer );
		if( border_image )
		{
#ifndef __NO_OPTIONS__
			width = SACK_GetProfileIntEx( GetProgramName()
					, "SACK/PSI/Frame border/Width"
					, 0, TRUE );
			height = SACK_GetProfileIntEx( GetProgramName()
					, "SACK/PSI/Frame border/Height"
					, 0, TRUE );
			anchors = 0;
			anchors |= SACK_GetProfileIntEx( GetProgramName()
					, "SACK/PSI/Frame border/Anchor Top"
					, 0, TRUE )<<BORDER_ANCHOR_TOP_SHIFT;
			anchors |= SACK_GetProfileIntEx( GetProgramName()
					, "SACK/PSI/Frame border/Anchor Bottom"
					, 0, TRUE )<<BORDER_ANCHOR_BOTTOM_SHIFT;
			anchors |= SACK_GetProfileIntEx( GetProgramName()
					, "SACK/PSI/Frame border/Anchor Left"
					, 0, TRUE )<<BORDER_ANCHOR_LEFT_SHIFT;
			anchors |= SACK_GetProfileIntEx( GetProgramName()
					, "SACK/PSI/Frame border/Anchor Right"
					, 0, TRUE )<<BORDER_ANCHOR_RIGHT_SHIFT;
			// overcompensate if the settings cause an underflow
			if( !width || (2*width) >= border_image->width )
				width = border_image->width / 3;
			if( !height || (2*height) >= border_image->height )
				height = border_image->height / 3;
#else
			if( border_image->width & 1 )
				width = border_image->width / 2;
			else
				width = (border_image->width-1) / 2;
			if( border_image->height )
				height = border_image->height / 2;
			else
				height = (border_image->height-1) / 2;
#endif
			g.DefaultBorder = PSI_CreateBorder( border_image, width, height, anchors
					, SACK_GetProfileInt( "SACK/psi/Frame Border", "Has Control theme colors", 0 ) );
		}
	}
}
#ifdef __cplusplus
static void OnDisplayConnect( "@00 PSI++ Core" )( struct display_app*app, struct display_app_local ***pppLocal )
#else
static void OnDisplayConnect( "@00 PSI Core" )(struct display_app*app, struct display_app_local ***pppLocal)
#endif
{
	PFrameBorder border;
	INDEX idx;
	GetMyInterface();
	ReuseImage( g.StopButton );
	ReuseImage( g.StopButtonPressed );
	LIST_FORALL( g.borders, idx, PFrameBorder, border )
	{
		{
			int n;
			ReuseImage( border->BorderImage );
			for( n = 0; n < 9; n++ )
			{
				ReuseImage( border->BorderSegment[n] );
			}
		}
	}
}
// this can be run very late...
PRELOAD( DefaultControlStartup )
{
#ifndef __NO_OPTIONS__
	g.flags.bLogDebugUpdate = SACK_GetProfileIntEx( GetProgramName(), "SACK/PSI/Log Control Updates", 0, TRUE );
	g.flags.bLogDetailedMouse = SACK_GetProfileIntEx( GetProgramName(), "SACK/PSI/Log Mouse Events", 0, TRUE );
	g.flags.bLogKeyEvents = SACK_GetProfileIntEx( GetProgramName(), "SACK/PSI/Log Key Events", 0, TRUE );
	g.flags.bLogSuperDetailedMouse = SACK_GetProfileIntEx( GetProgramName(), "SACK/PSI/Log Mouse Events extra detail", 0, TRUE );
#endif
}
PSI_PROC( PIMAGE_INTERFACE, SetControlImageInterface )( PIMAGE_INTERFACE DisplayInterface )
{
	g.MyImageInterface = DisplayInterface;
	if( !DisplayInterface ) return DisplayInterface;
	if( !DefaultColors[0] ) {
 // highlight
		DefaultColors[0] = Color( 192, 192, 192 );
 // normal
		DefaultColors[1] = AColor( 53, 96, 89, 225 );
 // shade
		DefaultColors[2] = Color( 35, 63, 57 );
 // shadow
		DefaultColors[3] = Color( 0, 0, 1 );
 // text
		DefaultColors[4] = AColor( 0, 240, 240, 255 );
 // caption background
		DefaultColors[5] = Color( 88, 124, 200 );
 // cannot be black(0). caption text
		DefaultColors[6] = Color( 240, 240, 240 );
 // inactive caption background
		DefaultColors[7] = Color( 89, 120, 120 );
     // inactive caption text (not black)
		DefaultColors[8] = Color( 0, 0, 1 );
  // text select background
		DefaultColors[9] = Color( 0, 0, 128 );
 // text select foreground
		DefaultColors[10] = Color( 220, 220, 255 );
 // edit background
		DefaultColors[11] = AColor( 192, 192, 192, 225 );
  // edit text
		DefaultColors[12] = Color( 0, 0, 1 );
 // scroll bar...
		DefaultColors[13] = Color( 120, 120, 180 );
	}
#ifdef __ANDROID__
	if( !g.default_font ) {
		uint32_t w, h;
		GetDisplaySize( &w, &h );
		if( h > w )
/*FONT_FLAG_8BIT*/
			g.default_font = RenderFontFileScaledEx( "%resources%/fonts/MyriadPro.ttf", w / 34, h / 48, NULL, NULL, 2, NULL, NULL );
		else
/*FONT_FLAG_8BIT*/
			g.default_font = RenderFontFileScaledEx( "%resources%/fonts/MyriadPro.ttf", w / 58, h / 32, NULL, NULL, 2, NULL, NULL );
	}
#else
	if( !g.default_font ) {
		TEXTCHAR buffer[256];
		CTEXTSTR default_name;
		uint32_t w, h;
		int bias_x, bias_y;
		GetFileGroup( "Resources", "@/../Resources" );
		//GetDisplaySize( &w, &h );
		//g.default_font = RenderFontFileScaledEx( "%resources%/fonts/rod.ttf", 20, 20, NULL, NULL, 0*2/*FONT_FLAG_8BIT*/, NULL, NULL );
		//g.default_font = RenderFontFileScaledEx( "rod.ttf", 18, 18, NULL, NULL, 2/*FONT_FLAG_8BIT*/, NULL, NULL );
		if( sack_exists( "c:/windows/fonts/msyh.ttf" ) )
			default_name = "msyh.ttf";
		else if( sack_exists( "c:/windows/fonts/msyh.ttc" ) )
			default_name = "msyh.ttc";
		else
			default_name = "arialbd.ttf";
		SACK_GetProfileString( "SACK/PSI/Font", "Default File", default_name, buffer, 256 );
		w = SACK_GetProfileInt( "SACK/PSI/Font", "Default Width", 18 );
		h = SACK_GetProfileInt( "SACK/PSI/Font", "Default Height", 18 );
/*FONT_FLAG_8BIT*/
		g.default_font = RenderFontFileScaledEx( buffer, w, h, NULL, NULL, 2, NULL, NULL );
		bias_x = SACK_GetProfileInt( "SACK/PSI/Font", "Bias X", 0 );
		bias_y = SACK_GetProfileInt( "SACK/PSI/Font", "Bias Y", 0 );
		//lprintf( "default font %p %d,%d", g.default_font, bias_x, bias_y );
		//SetFontBias( g.default_font, bias_x, bias_y );
	}
#endif
#ifndef PSI_SERVICE
#  ifdef USE_INTERFACES
	return g.MyImageInterface = DisplayInterface;
#endif
#endif
	return DisplayInterface;
}
PSI_PROC( PRENDER_INTERFACE, SetControlInterface )( PRENDER_INTERFACE DisplayInterface )
{
	g.MyDisplayInterface = DisplayInterface;
	if( !( g.flags.always_draw = RequiresDrawAll() ) )
		g.flags.allow_threaded_draw = AllowsAnyThreadToUpdate();
	g.flags.allow_copy_from_render = VidlibRenderAllowsCopy();
	return DisplayInterface;
}
//---------------------------------------------------------------------------
// basic controls implement begin here!
//---------------------------------------------------------------------------
PSI_PROC( void, AlignBaseToWindows )( void )
{
#ifdef _WIN32
	int sys_r;
	int sys_g;
	int sys_b;
	int sys_a;
	int tmp;
	if( !g.MyImageInterface )
		GetMyInterface();
#define Swap(i)    ( (tmp = i),( sys_r = ((tmp) & 0xFF)), (sys_g = ((tmp>>8) & 0xFF)),(sys_b = ((tmp >>16) & 0xFF)),(sys_a = 0xFF),AColor(sys_r,sys_g,sys_b,sys_a) )
	g.flags.system_color_set = 1;
	 DefaultColors[HIGHLIGHT        ] =  Swap(GetSysColor( COLOR_3DHIGHLIGHT));
	//if( !g.BorderImage )
	DefaultColors[NORMAL           ] =  Swap(GetSysColor(COLOR_3DFACE ));
	DefaultColors[SHADE            ] =  Swap(GetSysColor(COLOR_3DSHADOW ));
	DefaultColors[SHADOW           ] =  Swap(GetSysColor(COLOR_3DDKSHADOW ));
	DefaultColors[TEXTCOLOR        ] =  Swap(GetSysColor(COLOR_BTNTEXT ));
	DefaultColors[CAPTION          ] =  Swap(GetSysColor(COLOR_ACTIVECAPTION ));
	DefaultColors[CAPTIONTEXTCOLOR] =  Swap(GetSysColor( COLOR_CAPTIONTEXT));
	DefaultColors[INACTIVECAPTION ] =  Swap(GetSysColor(COLOR_INACTIVECAPTION ));
	DefaultColors[INACTIVECAPTIONTEXTCOLOR]=Swap(GetSysColor(COLOR_INACTIVECAPTIONTEXT ));
	DefaultColors[SELECT_BACK      ] =  Swap(GetSysColor(COLOR_HIGHLIGHT ));
	DefaultColors[SELECT_TEXT      ] =  Swap(GetSysColor(COLOR_HIGHLIGHTTEXT ));
	DefaultColors[EDIT_BACKGROUND ] =  Swap(GetSysColor(COLOR_WINDOW ));
	DefaultColors[EDIT_TEXT       ] =  Swap(GetSysColor(COLOR_WINDOWTEXT ));
	DefaultColors[SCROLLBAR_BACK  ] =  Swap(GetSysColor(COLOR_SCROLLBAR ));
#endif
    // No base to set to - KDE/Gnome/E/?
}
//---------------------------------------------------------------------------
PSI_PROC( void, SetBaseColor )( INDEX idx, CDATA c )
{
	//lprintf( "Color %d was %08X and is now %08X", idx, defaultcolor[idx], c );
	DefaultColors[idx] = c;
}
PSI_PROC( CDATA, GetBaseColor )( INDEX idx )
{
	return DefaultColors[idx] ;
}
//---------------------------------------------------------------------------
PSI_PROC( void, SetControlColor )( PSI_CONTROL pc, INDEX idx, CDATA c )
{
	if( pc )
	{
		if( !pc->basecolors || basecolor( pc ) == DefaultColors ) {
			if( !pc->border ) {
				pc->basecolors = NewArray( CDATA, sizeof( DefaultColors ) / sizeof( CDATA ) );
				MemCpy( pc->basecolors, DefaultColors, sizeof( DefaultColors ) );
 // otherwise we'll be setting the border default... which can be shared...
			}
		}
		basecolor( pc )[idx] = c;
	}
}
PSI_PROC( CDATA, GetControlColor )( PSI_CONTROL pc, INDEX idx )
{
	return basecolor(pc)[idx];
}
//---------------------------------------------------------------------------
// dir 0 here only... in case we removed ourself from focusable
// dir -1 go backwards
// dir 1 go forwards
#define FFF_HERE      0
#define FFF_FORWARD   1
#define FFF_BACKWARD -1
void FixFrameFocus( PPHYSICAL_DEVICE pf, int dir )
{
	if( pf )
	{
		PSI_CONTROL pc = pf->common;
#ifdef DEBUG_FOCUS_STUFF
		lprintf( "FixFrameFocus...." );
#endif
		if( !pc->flags.bDestroy  )
		{
			PSI_CONTROL pcCurrent, pcStart;
			int bLooped = FALSE, bTryAgain = FALSE;
			pcStart = pcCurrent = pf->pFocus;
			if( !pcCurrent )
			{
				// have to focus SOMETHING
				pcCurrent = pf->pFocus = pc->child;
				//pcCurrent = pcStart = pc->child;
				//return; // doesn't matter where the focus in the frame is.
			}
			// no child controls to focus...
			if( !pcCurrent )
				return;
			if( dir == FFF_FORWARD )
				pcCurrent = pcCurrent->next;
			else if( dir == FFF_BACKWARD )
				pcCurrent = pcCurrent->prior;
			do
			{
				if( bTryAgain )
					bLooped = TRUE;
				bTryAgain = FALSE;
				while( pcCurrent )
				{
					if( (!pcCurrent->flags.bHidden) &&(!pcCurrent->flags.bNoFocus) &&
						((!pcCurrent->flags.bDisable) ||
						 (pcCurrent == pcStart )))
					{
						if( pcStart && pcCurrent != pcStart )
							SetCommonFocus( pcCurrent );
						break;
					}
					if( ( dir == FFF_FORWARD ) || ( dir == FFF_HERE ) )
						pcCurrent = pcCurrent->next;
					else
						pcCurrent = pcCurrent->prior;
				}
				if( !pcCurrent && ( pcCurrent = pc->child ) )
				{
					if( dir != FFF_FORWARD )
					{
						// go to last.
						while( pcCurrent->next )
							pcCurrent = pcCurrent->next;
					}
					bTryAgain = TRUE;
				}
			}while( bTryAgain && !bLooped );
		}
	}
}
//---------------------------------------------------------------------------
void RestoreBackground( PSI_CONTROL pc, P_IMAGE_RECTANGLE r )
{
	PSI_CONTROL parent;
	if( pc )
	{
		for( parent = pc->parent; parent; parent = parent->parent )
		{
			if( parent->flags.bDirty )
			{
				break;
			}
		}
		if( !parent )
		{
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				lprintf( "Restoring orignal background... " );
#endif
			pc->flags.bParentCleaned = 1;
			BlotImageSizedTo( pc->Surface, pc->OriginalSurface,  r->x, r->y, r->x, r->y, r->width, r->height );
		}
		else
		{
			lprintf( "parent would have to draw before I can restore my control's background" );
		}
	}
}
//---------------------------------------------------------------------------
void InvokeControlHidden( PSI_CONTROL pc )
{
	void (CPROC *OnHidden)(PSI_CONTROL);
	PCLASSROOT data = NULL;
	PCLASSROOT event_root = GetClassRootEx( pc->class_root, "hide_control" );
	CTEXTSTR name;
	for( name = GetFirstRegisteredName( event_root, &data );
		 name;
		  name = GetNextRegisteredName( &data ) )
	{
		OnHidden = GetRegisteredProcedureExx( data,(CTEXTSTR)NULL,void,name,(PSI_CONTROL));
		if( OnHidden )
		{
			OnHidden( pc );
		}
	}
}
//---------------------------------------------------------------------------
void InvokeControlRevealed( PSI_CONTROL pc )
{
	void (CPROC *OnReveal)(PSI_CONTROL);
	PCLASSROOT data = NULL;
	PCLASSROOT event_root = GetClassRootEx( pc->class_root, "reveal_control" );
	CTEXTSTR name;
	for( name = GetFirstRegisteredName( event_root, &data );
		 name;
		  name = GetNextRegisteredName( &data ) )
	{
		OnReveal = GetRegisteredProcedureExx( data,(CTEXTSTR)NULL,void,name,(PSI_CONTROL));
		if( OnReveal )
		{
			OnReveal( pc );
		}
	}
}
//---------------------------------------------------------------------------
// this always works from the root dialog
// ... which causes in essense the whole window
// to update ... we hate this... and really only have to go
// as far as the last non-transparent image...
void UpdateSomeControls( PSI_CONTROL pc, P_IMAGE_RECTANGLE pRect )
{
	if( !g.flags.always_draw )
	{
	PPHYSICAL_DEVICE pf = GetFrame( pc )->device;
	//IMAGE_RECTANGLE _rect;
#ifdef DEBUG_UPDAATE_DRAW
	if( g.flags.bLogDebugUpdate )
		lprintf( "Update Some Controls - (all controls within rect %d) ", pc->flags.bInitial );
#endif
	//ValidatedControlData( PFRAME, CONTROL_FRAME, pf, GetFrame( pc ) );
	//cpg26dec2006 c:\work\sack\src\psilib\controls.c(741): Warning! W202: Symbol 'prior_flag' has been defined, but not referenced
	//cpg26dec2006	 int prior_flag;
	// include bias to surface - allow everyone
	// else to think in area within frame surface...
	// add the final frame surface offset...
	// this should remove the need for edit_bias to be added...
	// plus - now pc will refer to the frame, and is where
	// we desire to be drawing anyhow....
	// working down within the frame/controls ....
	// but so far - usage has been from the control's rect,
	// and not its surface, therefore subracting it's surface rect was
	// wrong - but this allows us to cleanly subract the last, and not
	// the first...
	if( !pRect )
		return;
	if( !pc )
		return;
	if( pc->flags.bHidden )
	{
		lprintf( "Control is hidden, skipping it." );
		return;
		//continue;
	}
	//lprintf( "UpdateSomeControls - input rect is %d,%d  %d,%d", pRect->x, pRect->y, pRect->width, pRect->height );
	//lprintf( "UpdateSomeControls - changed rect is %d,%d  %d,%d", pRect->x, pRect->y, pRect->width, pRect->height );
	// Uhmm well ... transporting dirty_rect ... on the control
	// passing a rect in...
	//(*pRect) = pc->dirty_rect;
	if( pf && !pc->flags.bInitial && pf->pActImg )
	{
		IMAGE_RECTANGLE clip;
		IMAGE_RECTANGLE surf_rect;
		clip.x = 0;
		clip.y = 0;
		clip.width = pc->surface_rect.width;
		clip.height = pc->surface_rect.width;
		if( IntersectRectangle( &surf_rect, pRect, &clip ) )
		{
			surf_rect.x += pc->surface_rect.x;
			surf_rect.y += pc->surface_rect.y;
			while( pc && pc->parent && !pc->device )
			{
				// don't subract the first surface
				// but do subtract the last surface...
				surf_rect.x += pc->rect.x;
				surf_rect.y += pc->rect.y;
				pc = pc->parent;;
				surf_rect.x += pc->surface_rect.x;
				surf_rect.y += pc->surface_rect.y;
			}
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				lprintf( "Some controls using normal updatecommon to draw..." );
#endif
			// enabled minimal update region...
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
			{
				lprintf( "Blatting color to surface so that we have something update?!" );
				lprintf( "Update portion %d,%d to %d,%d", surf_rect.x, surf_rect.y, surf_rect.width, surf_rect.height );
			}
#endif
#ifdef BLAT_COLOR_UPDATE_PORTION
			BlatColorAlpha( pc->Window,  surf_rect.x
							  ,  surf_rect.y, surf_rect.width, surf_rect.height, SetAlpha( BASE_COLOR_PURPLE, 0x20 ) );
#endif
			UpdateDisplayPortion( pf->pActImg
									  , surf_rect.x
									  , surf_rect.y
									  , surf_rect.width
									  , surf_rect.height );
		}
	}
	}
}
//---------------------------------------------------------------------------
void SmudgeSomeControlsWork( PSI_CONTROL pc, P_IMAGE_RECTANGLE pRect )
{
	IMAGE_RECTANGLE wind_rect;
	IMAGE_RECTANGLE surf_rect;
	for( ;pc; pc = pc->next )
	{
		{
			PSI_CONTROL parent;
			for( parent = pc; parent; parent = parent->parent )
			{
				if( parent->flags.bNoUpdate || parent->flags.bHidden )
				{
					lprintf( "a control %p (self, or some parent %p) has %s or %s"
							  , pc, parent
							  , parent->flags.bNoUpdate?"noupdate":"..."
							  , parent->flags.bHidden?"hidden":"..."
							  );
					break;
				}
			}
			if( parent )
			{
				lprintf( "ABORTING SMUDGE" );
				continue;
			}
		}
		if( pc->flags.bHidden || pc->flags.bNoUpdate )
		{
			lprintf( "Control is hidden, skipping it." );
			continue;
		}
#ifdef DEBUG_UPDAATE_DRAW
		if( g.flags.bLogDebugUpdate )
			lprintf( "updating some controls... rectangles and stuff." );
#endif
	 //Log( "Update some controls...." );
		if( !IntersectRectangle( &wind_rect, pRect, &pc->rect ) )
			continue;
		wind_rect.x -= pc->rect.x;
		wind_rect.y -= pc->rect.y;
		 // bound window rect (frame update)
			// The update region may be
		if( IntersectRectangle( &surf_rect, &wind_rect, &pc->surface_rect ) )
		{
			surf_rect.x -= pc->surface_rect.x;
			surf_rect.y -= pc->surface_rect.y;
#ifdef DEBUG_UPDAATE_DRAW
				if( g.flags.bLogDebugUpdate )
					lprintf( "Some controls using normal updatecommon to draw..." );
#endif
			// enabled minimal update region...
			pc->dirty_rect = surf_rect;
 // and all children, if dirtied...
			SmudgeCommon( pc );
		}
		else
		{
			// wind_rect is the merge of the update needed
			// and the window's bounds, but none of the surface
			// setting the image bound to this will short many things like blotting the
			//fancy image borders.
			// yes redundant with above, but need to fix the image pos
			// AFTER the update... and well....
			//Log( "Hit the rectange, but didn't hit the content... so update border only." );
			if( pc->DrawBorder )
			{
#ifdef DEBUG_BORDER_DRAWING
				lprintf( "Drawing border ..." );
#endif
				pc->DrawBorder( pc );
			}
			if( pc->device )
			{
				//void DrawFrameCaption( PSI_CONTROL );
#ifdef DEBUG_UPDAATE_DRAW
				if( g.flags.bLogDebugUpdate )
					lprintf( "Drew border, drawing caption uhmm update some work controls" );
#endif
				DrawFrameCaption( pc );
			}
		}
	}
}
//---------------------------------------------------------------------------
// this always works from the root dialog
// ... which causes in essense the whole window
// to update ... we hate this... and really only have to go
// as far as the last non-transparent image...
void SmudgeSomeControls( PSI_CONTROL pc, P_IMAGE_RECTANGLE pRect )
{
	PPHYSICAL_DEVICE pf = GetFrame( pc )->device;
	//IMAGE_RECTANGLE _rect;
	//ValidatedControlData( PFRAME, CONTROL_FRAME, pf, GetFrame( pc ) );
	int prior_flag;
	// include bias to surface - allow everyone
	// else to think in area within frame surface...
	// add the final frame surface offset...
	// this should remove the need for edit_bias to be added...
	// plus - now pc will refer to the frame, and is where
	// we desire to be drawing anyhow....
	// working down within the frame/controls ....
	// but so far - usage has been from the control's rect,
	// and not its surface, therefore subracting it's surface rect was
	// wrong - but this allows us to cleanly subract the last, and not
	// the first...
	if( !pRect )
		return;
	//lprintf( "SmudgeSomeControls - input rect is %d,%d  %d,%d", pRect->x, pRect->y, pRect->width, pRect->height );
	while( pc && pc->parent && !pc->device )
	{
		// don't subract the first surface
		// but do subtract the last surface...
		pRect->x += pc->rect.x;
		pRect->y += pc->rect.y;
		pc = pc->parent;;
		pRect->x += pc->surface_rect.x;
		pRect->y += pc->surface_rect.y;
	}
	//lprintf( "SmudgeSomeControls - changed rect is %d,%d  %d,%d", pRect->x, pRect->y, pRect->width, pRect->height );
	prior_flag = pc->flags.bInitial;
	pc->flags.bInitial = 1;
	SmudgeSomeControlsWork( pc, pRect );
	pc->flags.bInitial = prior_flag;
	// Uhmm well ... transporting dirty_rect ... on the control
	// passing a rect in...
	(*pRect) = pc->dirty_rect;
	if( pf && !pc->flags.bInitial && pf->pActImg )
	{
#ifdef DEBUG_UPDAATE_DRAW
		if( g.flags.bLogDebugUpdate )
		{
			lprintf( "Blatting color to surface so that we have something update?!" );
			lprintf( "Update portion %d,%d to %d,%d", pRect->x, pRect->y, pRect->width, pRect->height );
		}
#endif
		/*
		 UpdateDisplayPortion( pf->pActImg
									, pRect->x
									, pRect->y
									, pRect->width
									, pRect->height );
		*/
	 }
}
//---------------------------------------------------------------------------
static int OnDrawCommon( "Frame" )( PSI_CONTROL pc )
{
#ifdef DEBUG_UPDAATE_DRAW
	if( g.flags.bLogDebugUpdate )
		lprintf( "-=-=-=-=- Output Frame background..." );
#endif
	if( !pc->border || !pc->border->hasFill ) {
		if( !pc->parent )
			BlatColor( pc->Surface, 0, 0, pc->surface_rect.width, pc->surface_rect.height, basecolor( pc )[NORMAL] );
		else
			BlatColorAlpha( pc->Surface, 0, 0, pc->surface_rect.width, pc->surface_rect.height, basecolor( pc )[NORMAL] );
	}
	else {
		PFrameBorder border = pc->border;
		if( (border->BorderSegment[SEGMENT_CENTER]->width > border->BorderWidth * 3) && (!pc->flags.bInitial || border->drawFill) ) {
			BlotScaledImageSizedEx( pc->Window, border->BorderSegment[SEGMENT_CENTER]
				, pc->surface_rect.x, pc->surface_rect.y
				, pc->surface_rect.width, pc->surface_rect.height
				, 0, 0
				, border->BorderSegment[SEGMENT_CENTER]->width, border->BorderSegment[SEGMENT_CENTER]->height
				, ALPHA_TRANSPARENT, BLOT_COPY );
			border->drawFill = 0;
		}
	}
	DrawFrameCaption( pc );
	return 1;
}
//--------------------------------------------------------------------------
static void OnDrawCommonDecorations( "Frame" )( PSI_CONTROL pc, PSI_CONTROL child )
{
#ifdef DEBUG_UPDAATE_DRAW
	if( g.flags.bLogDebugUpdate )
		lprintf( "-=-=-=-=- Output Frame decorations... %p  %p", pc, child );
#endif
	if( pc->device )
		DrawHotSpots( pc, &pc->device->EditState, child );
}
//--------------------------------------------------------------------------
// forward declaration cause we're lazy and don't want to re-wind the below routines...
typedef struct psi_penging_rectangle_tag
{
	struct {
		BIT_FIELD bHasContent : 1;
		BIT_FIELD bTmpRect : 1;
		BIT_FIELD bInitialized : 1;
	} flags;
   // this shouldn't be a thread-shared structure.
	//CRITICALSECTION cs;
	int32_t x, y;
   uint32_t width, height;
} PSI_PENDING_RECT, *PPSI_PENDING_RECT;
static void DoUpdateCommonEx( PPSI_PENDING_RECT upd, PSI_CONTROL pc, int bDraw, int level DBG_PASS );
static void DoUpdateFrame( PSI_CONTROL pc
								 , int x, int y
								 , int w, int h
								 , int surface_bias
								  DBG_PASS)
{
	static int level;
	PPHYSICAL_DEVICE pf = NULL;
	if( pc )
	{
		if( pc->flags.bHidden )
			return;
		pf = pc->device;
	}
	else
	{
		lprintf( "Why did ypu pass a NULL control to this?! ( the event to close happeend before updat" );
		return;
	}
#if DEBUG_UPDAATE_DRAW > 2
	if( g.flags.bLogDebugUpdate )
		_lprintf(DBG_RELAY)( "Do Update frame.. x, y on frame of %d,%d,%d,%d ", x, y, w, h );
#endif
	level++;
	if( pc && !pf )
	{
#ifdef DEBUG_UPDAATE_DRAW
		if( g.flags.bLogDebugUpdate )
			lprintf( "Stepping to parent, adding my surface rect and my rect to the coordinate updated... %d+%d+%d %d+%d+%d"
					 , x, pc->parent->rect.x, pc->parent->surface_rect.x
					 , y, pc->parent->rect.y, pc->parent->surface_rect.y
					 );
#endif
 // otherwise we're probably still creating the thing, and it's in bInitial?
		if( pc->parent && !pc->device )
		{
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				lprintf( "stepping to parent, assuming I'm copying my surface, so update appropriately" );
#endif
#ifdef BLAT_COLOR_UPDATE_PORTION
			TESTCOLOR=SetAlpha( BASE_COLOR_BLUE, 128 );
#endif
			DoUpdateFrame( pc->parent
							 , (pc->parent->device?0:pc->parent->rect.x) + pc->parent->surface_rect.x + x
							 , (pc->parent->device?0:pc->parent->rect.y) + pc->parent->surface_rect.y + y
							 , w, h
							 , FALSE
							  DBG_RELAY
							 );
		}
	}
	else if( pf )
	{
		if( pc->flags.bInitial || pc->flags.bNoUpdate )
		{
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				lprintf( "Failing to update to screen cause %s and/or %s", pc->flags.bInitial?"it's initial":""
						 , pc->flags.bNoUpdate ?"it's no update...":"...");
#endif
			level--;
			return;
		}
		{
			int bias_x = 0;
			int bias_y = 0;
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				_xlprintf( 1 DBG_RELAY )( "updating display portion %d,%d (%d,%d)"
												, bias_x + x
												, bias_y + y
												, w, h );
#endif
#ifdef BLAT_COLOR_UPDATE_PORTION
			BlatColorAlpha( pc->Window
 //+ pc->surface_rect.x
							  , x
 //+ pc->surface_rect.y
							  , y
							  , w, h, TESTCOLOR );
#endif
			UpdateDisplayPortion( pf->pActImg
									  , bias_x + x
									  , bias_y + y
									  , w, h );
		}
	}
	level--;
}
//---------------------------------------------------------------------------
PSI_PROC( void, UpdateFrameEx )( PSI_CONTROL pc
									  , int x, int y
									  , int w, int h DBG_PASS)
{
	PPHYSICAL_DEVICE pf = pc->device;
   //ValidatedControlData( PFRAME, CONTROL_FRAME, pf, pc );
#ifdef DEBUG_UPDAATE_DRAW
	if( g.flags.bLogDebugUpdate )
		_lprintf(DBG_RELAY)( "Update Frame (Another flavor ) %p %p  %d,%d %d,%d", pc, pf, x, y, w, h );
#endif
   //_xlprintf( 1 DBG_RELAY )( "Update Frame ------------" );
	if( pc && !pf )
	{
#ifdef DEBUG_UPDAATE_DRAW
		if( g.flags.bLogDebugUpdate )
		{
			//lprintf( "Stepping to parent, adding my surface rect and my rect to the coordinate updated..." );
			lprintf( "stepping to parent, assuming I'm copying my surface, so update appropriately" );
			lprintf( "Stepping to parent, adding my surface rect and my rect to the coordinate updated... %d+%d+%d %d+%d+%d"
					 , x, pc->parent->rect.x, pc->parent->surface_rect.x
					 , y, pc->parent->rect.y, pc->parent->surface_rect.y
					 );
		}
#endif
		if( pc->parent )
			UpdateFrameEx( pc->parent
							 , pc->rect.x + pc->surface_rect.x + x
							 , pc->rect.y + pc->surface_rect.y + y
							 , w?w:pc->rect.width, h?h:pc->rect.height DBG_RELAY );
	}
	else if( pf )
	{
		if( pc->flags.bInitial || pc->flags.bNoUpdate )
		{
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				lprintf( "Faileing to update to screen cause we're initial or it's no update..." );
#endif
			return;
		}
#ifdef DEBUG_UPDAATE_DRAW
		if( g.flags.bLogDebugUpdate )
			_xlprintf( 1 DBG_RELAY )( "updating display portion %d,%d (%d,%d)"
											, pc->surface_rect.x + x
											, pc->surface_rect.y + y
											, w, h );
#endif
#ifdef BLAT_COLOR_UPDATE_PORTION
		BlatColorAlpha( pc->Window,  x + pc->surface_rect.x
						  ,  y + pc->surface_rect.y
						  , w, h, SetAlpha( BASE_COLOR_PURPLE, 0x20 ) );
#endif
		UpdateDisplayPortionEx( pf->pActImg
								  , x + pc->surface_rect.x
								  , y + pc->surface_rect.y
								  , w, h DBG_RELAY );
	}
}
//---------------------------------------------------------------------------
void IntelligentFrameUpdateAllDirtyControls( PSI_CONTROL pc DBG_PASS )
{
	{
		// Draw this now please?!
		PSI_PENDING_RECT upd;
#ifdef DEBUG_UPDAATE_DRAW
		if( g.flags.bLogDebugUpdate )
		{
			_lprintf( DBG_RELAY )( "Intelligent update? %p", pc );
			lprintf( "pc = %p par = %p", pc, pc->parent );
		}
#endif
		upd.flags.bHasContent = 0;
		upd.flags.bTmpRect = 0;
		//lprintf( "doing update common..." );
		DoUpdateCommonEx( &upd, pc, FALSE, 0 DBG_RELAY);
		if( upd.flags.bHasContent )
		{
			PSI_CONTROL frame;
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				lprintf( "Updated all commons? %d,%d  %d,%d", upd.x,upd.y, upd.width, upd.height );
#endif
#ifdef BLAT_COLOR_UPDATE_PORTION
			BlatColor( GetFrame( pc )->Window
 //pc->surface_rect.x
						,
						 + upd.x
 //pc->surface_rect.x
						,
						 + upd.y
						, 5, 5, BASE_COLOR_ORANGE );
			TESTCOLOR=SetAlpha( BASE_COLOR_RED, 0x20 );
#endif
			// the frame may return NULL if the frame is bDestroy.
			if( frame = GetFrame( pc ) )
				DoUpdateFrame( frame
								 , upd.x, upd.y
								 , upd.width, upd.height
								 , FALSE
								  DBG_RELAY );
		}
	}
}
//---------------------------------------------------------------------------
void AddCommonUpdateRegionEx( PPSI_PENDING_RECT update_rect, int bSurface, PSI_CONTROL pc DBG_PASS )
#define AddCommonUpdateRegion(upd,surface,pc) AddCommonUpdateRegionEx( upd,surface,pc DBG_SRC )
{
	PSI_CONTROL parent;
	int32_t x, y;
	uint32_t wd, ht;
	if( !pc )
		return;
#ifdef DEBUG_UPDAATE_DRAW
	if( g.flags.bLogDebugUpdate )
		_lprintf(DBG_RELAY)( "Adding region.... (mayfbe should wait)" );
#endif
	if( !pc->parent && pc->flags.bRestoring )
	{
		if( g.flags.bLogDebugUpdate )
			lprintf( "no parent and not restoring." );
		wd = pc->rect.width;
		ht = pc->rect.height;
//pc->rect.x;
		x = 0;
//pc->rect.y;
		y = 0;
		pc->flags.bUpdateRegionSet = 0;
	}
	else if( pc->flags.bUpdateRegionSet )
	{
		if( g.flags.bLogDebugUpdate )
			lprintf( "someone already set the region... " );
		wd = pc->update_rect.width;
		ht = pc->update_rect.height;
		x = pc->update_rect.x + pc->surface_rect.x;
		y = pc->update_rect.y + pc->surface_rect.y;
		pc->flags.bUpdateRegionSet = 0;
	}
	else
	{
		if( g.flags.bLogDebugUpdate )
			lprintf( "parent and this is restoring " );
		if( bSurface )
		{
			//lprintf( "Computing control's surface rectangle." );
			wd = pc->surface_rect.width;
			ht = pc->surface_rect.height;
		}
		else
		{
			//lprintf( "Computing control's window rectangle." );
			wd = pc->rect.width;
			ht = pc->rect.height;
		}
		if( pc->parent && !pc->device )
		{
			x = pc->rect.x;
			y = pc->rect.y;
		}
		else
		{
			// if a control was created (or if we're using the bare
			// frame for the surface of something)
			// then don't include pc's offset since that is actually
			// a representation of the screen offset.
			x = 0;
			y = 0;
		}
		if( bSurface )
		{
			x += pc->surface_rect.x;
			y += pc->surface_rect.y;
		}
	}
	if( pc->parent )
	{
		if( g.flags.bLogDebugUpdate )
			lprintf( "control has parent..." );
 /*&& parent->parent*/
		for( parent = pc->parent; parent; parent = parent->parent )
		{
			x += ((parent->parent&&!parent->device)?parent->rect.x:0) + parent->surface_rect.x;
			y += ((parent->parent&&!parent->device)?parent->rect.y:0) + parent->surface_rect.y;
			if( g.flags.bLogDebugUpdate )
				lprintf( "control's parent makes x=%d and y=%d", x, y );
			if( parent->device )
				break;
		}
		//x += parent->surface_rect.x;
		//y += parent->surface_rect.y;
	}
	//else
   //   parent = pc;
   //lprintf( "Adding update region (%d,%d)-(%d,%d)", x, y, wd, ht );
	if( wd && ht )
	{
		if( update_rect->flags.bHasContent )
		{
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				lprintf( "Adding (%d,%d)-(%d,%d) to (%d,%d)-(%d,%d)"
						 , x, y
						 , wd, ht
						 , update_rect->x, update_rect->y
						 , update_rect->width, update_rect->height
						 );
#endif
			if( x < update_rect->x )
			{
				update_rect->width += update_rect->x - x;
				update_rect->x = x;
			}
			if( ( x + (int32_t)wd ) > ( update_rect->x + (int32_t)update_rect->width ) )
				update_rect->width = ( (int32_t)wd + x ) - update_rect->x;
			if( y < update_rect->y )
			{
				update_rect->height += update_rect->y - y;
				update_rect->y = y;
			}
			if( y + (int32_t)ht > update_rect->y + (int32_t)update_rect->height )
				update_rect->height = ( y + (int32_t)ht ) - update_rect->y;
			//lprintf( (fs"result (%d,%d)-(%d,%d)")
		 //       , update_rect->x, update_rect->y
		 //       , update_rect->width, update_rect->height
			//		 );
		}
		else
		{
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				_lprintf(DBG_RELAY)( "Setting (%d,%d)-(%d,%d)"
										 , x, y
										 , wd, ht
										 );
#endif
			update_rect->x = x;
			update_rect->y = y;
			update_rect->width = wd;
			update_rect->height = ht;
		}
		update_rect->flags.bHasContent = 1;
	}
}
//---------------------------------------------------------------------------
void SetUpdateRegionEx( PSI_CONTROL pc, int32_t rx, int32_t ry, uint32_t rw, uint32_t rh DBG_PASS )
{
	PSI_CONTROL parent;
	int32_t x, y;
	uint32_t wd, ht;
	if( !pc )
		return;
	//lprintf( "Computing control's surface rectangle." );
	wd = rw;
	ht = rh;
	if( pc->parent && !pc->device )
	{
		x = pc->rect.x;
		y = pc->rect.y;
	}
	else
	{
		// if a control was created (or if we're using the bare
		// frame for the surface of something)
		// then don't include pc's offset since that is actually
		// a representation of the screen offset.
		x = 0;
		y = 0;
	}
	x += pc->surface_rect.x;
	y += pc->surface_rect.y;
	x += rx;
	y += ry;
	if( pc->parent )
	{
 /*&& parent->parent*/
		for( parent = pc->parent; parent; parent = parent->parent )
		{
			x += ((parent->parent&&!parent->device)?parent->rect.x:0) + parent->surface_rect.x;
			y += ((parent->parent&&!parent->device)?parent->rect.y:0) + parent->surface_rect.y;
			if( parent->device )
				break;
		}
	}
	//else
   //   parent = pc;
   //lprintf( "Adding update region (%d,%d)-(%d,%d)", x, y, wd, ht );
	if( wd && ht )
	{
		pc->flags.bUpdateRegionSet = 1;
		{
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				_lprintf(DBG_RELAY)( "Setting (%d,%d)-(%d,%d)"
										 , x, y
										 , wd, ht
										 );
#endif
			pc->update_rect.x = x;
			pc->update_rect.y = y;
			pc->update_rect.width = wd;
			pc->update_rect.height = ht;
		}
	}
}
//---------------------------------------------------------------------------
Image CopyOriginalSurfaceEx( PSI_CONTROL pc, Image use_image DBG_PASS )
{
	Image copy;
	if( !pc || !g.flags.allow_copy_from_render || !pc->parent || ( pc->BorderType & BORDER_FRAME ) )
	{
		return NULL;
	}
	if( pc->flags.bInitial )
	{
#ifdef DEBUG_TRANSPARENCY_SURFACE_SAVE_RESTORE
		lprintf( "Control has not drawn yet." );
#endif
		if( use_image )
			UnmakeImageFile( use_image );
		return NULL;
	}
	if( pc->flags.bParentCleaned && (pc->parent && !pc->parent->flags.bDirty ) && pc->flags.bParentUpdated )
	{
  // okay we'll have a new snapshot of the parent after this.
		pc->flags.bParentUpdated = 0;
		if( !use_image )
		{
#ifdef DEBUG_TRANSPARENCY_SURFACE_SAVE_RESTORE
			lprintf( "Creating a new image.. %p", pc );
#endif
			copy = MakeImageFileEx( pc->rect.width, pc->rect.height DBG_RELAY );
		}
		else
		{
			// use smae image - typically pc->Original_image is set indirectly to this funciton's result
			// therefore there's only one ever, made if NULL and resized otherwise.
			// clean it up later...
#ifdef DEBUG_TRANSPARENCY_SURFACE_SAVE_RESTORE
			lprintf( "Using old image %p", pc );
#endif
			copy = use_image;
		}
		// if the sizes match already, resize does nothing.
		ResizeImage( copy, pc->rect.width, pc->rect.height );
		//lprintf( "################ COPY SURFACE ###################### " );
		BlotImage( copy, pc->Window, 0, 0 );
		//ClearImageTo( copy, BASE_COLOR_ORANGE );
#ifdef DEBUG_TRANSPARENCY_SURFACE_SAVE_RESTORE
		lprintf( "Copied old image %p", pc );
#endif
		return copy;
	}
#ifdef DEBUG_TRANSPARENCY_SURFACE_SAVE_RESTORE
	lprintf( "Parent was unclean, no image %p" );
#endif
	return NULL;
}
//---------------------------------------------------------------------------
// This routine actually sends the draw events to dirty rectangles.
static void DoUpdateCommonEx( PPSI_PENDING_RECT upd, PSI_CONTROL pc, int bDraw, int level DBG_PASS )
{
	int cleaned = 0;
	if( pc )
	{
#if LOCK_TEST
		PPHYSICAL_DEVICE device = GetFrame( pc )->device;
#endif
		if( pc->parent && !pc->device )
		{
			// okay surface rect of parent should be considered as 0,0.
			if( SUS_GT( pc->rect.x, IMAGE_COORDINATE, pc->parent->surface_rect.width, IMAGE_SIZE_COORDINATE )
			    || SUS_GT( pc->rect.y, IMAGE_COORDINATE, pc->parent->surface_rect.height, IMAGE_SIZE_COORDINATE )
 /*pc->parent->surface_rect.x*/
			    || USS_LT( pc->rect.width, IMAGE_SIZE_COORDINATE,-pc->rect.x, IMAGE_COORDINATE )
 /*pc->parent->surface_rect.y*/
			    || USS_LT( pc->rect.height, IMAGE_SIZE_COORDINATE,-pc->rect.y, IMAGE_COORDINATE )
			  )
			{
				if( g.flags.bLogDebugUpdate )
				{
 /*pc->parent->surface_rect.x*/
 /*pc->parent->surface_rect.y*/
					lprintf( "out of bounds? %d,%d %d,%d  %d,%d %d,%d", pc->original_rect.x, pc->original_rect.y, pc->original_rect.width, pc->original_rect.height, pc->parent->surface_rect.width, pc->parent->surface_rect.height,-pc->original_rect.x,-pc->original_rect.y );
				}
				return;
			}
		}
#if DEBUG_UPDAATE_DRAW > 2
		if( g.flags.bLogDebugUpdate )
			_lprintf(DBG_RELAY)( ">>Control updating %p(parent:%p,child:%p)", pc, pc->parent, pc->child );
#endif
 /*|| !GetImageSurface(pc->Surface)*/
		if( pc->flags.bNoUpdate )
		{
#if DEBUG_UPDAATE_DRAW > 2
			if( g.flags.bLogDebugUpdate )
				lprintf( "Control update is disabled" );
#endif
			return;
		}
#if DEBUG_UPDAATE_DRAW > 3
		if( g.flags.bLogDebugUpdate )
		{
			// might filter this to just if dirty, we get called a lot without dirty controls
			lprintf( "Control %p(%s) is %s and parent is %s", pc, pc->pTypeName, pc->flags.bDirty?"SMUDGED":"clean", pc->flags.bParentCleaned?"cleaned to me":"dirty to me" );
			// again might filter to just forced...
			_xlprintf(LOG_NOISE DBG_RELAY )( ">>do draw... %p %p %s %s", pc, pc->child
			                               , bDraw?"FORCE":"..."
			                               , pc->flags.bCleaning?"CLEANING":"cleanable");
		}
#endif
#if LOCK_TEST
		if( device )
			LockRenderer( device->pActImg );
#endif
		//#endif
		if( !pc->flags.bCleaning )
		{
#if DEBUG_UPDAATE_DRAW > 2
			if( g.flags.bLogDebugUpdate )
				_xlprintf(1 DBG_RELAY)( ">>Begin control %p update forced?%s", pc, bDraw?"Yes":"No" );
#endif
			pc->flags.bCleaning = 1;
		retry_update:
			if( pc->parent && !pc->device )
			{
				// if my parent is initial, become initial also...
				//lprintf( " Again, relaying my initial status..." );
				if( pc->flags.bInitial != pc->parent->flags.bInitial )
				{
					pc->flags.bInitial = pc->parent->flags.bInitial;
					if( !pc->flags.bHidden )
						InvokeControlRevealed( pc );
				}
				// also, copy hidden status... can't be shown within a hidden parent.
				if( !pc->flags.bHiddenParent )
				{
					// if this control itself is the hidden control
					// (top level hidden controls are ParentHidden)
					// don't copy the parent's visibility - cause it probably
					// is visible.
					pc->flags.bHidden = pc->parent->flags.bHidden;
				}
			}
			/* this previsouly tested if bInitial... but that only counts for the top level... */
			if( !pc->flags.bNoUpdate && ((pc->parent&&!pc->device)?1:!pc->flags.bInitial) && ( (pc->flags.bDirty || pc->flags.bDirtied) || bDraw ) && !pc->flags.bHidden )
			{
#if DEBUG_UPDAATE_DRAW > 2
				if( g.flags.bLogDebugUpdate )
					lprintf( "Control draw %p %s parent_clean?%d transparent?%d"
							 , pc, pc->pTypeName
							 , pc->flags.bParentCleaned
							 , pc->flags.bTransparent );
#endif
				if( !g.flags.always_draw && !IsImageTargetFinal( pc->Window )
					&& g.flags.allow_copy_from_render )
				{
//&& pc->flags.bFirstCleaning )
					if( ( ((pc->parent&&!pc->device) && pc->parent->flags.bDirty ) || pc->flags.bParentCleaned ) && pc->flags.bTransparent )
					{
						Image OldSurface;
						OldSurface = CopyOriginalSurface( pc, pc->OriginalSurface );
						if( OldSurface )
						{
#ifdef DEBUG_UPDAATE_DRAW
							if( g.flags.bLogDebugUpdate )
								_lprintf(DBG_RELAY)( "--------------- Successfully copied new background original image" );
#endif
							pc->OriginalSurface = OldSurface;
						}
						else
							if( pc->OriginalSurface )
							{
#ifdef DEBUG_UPDAATE_DRAW
								if( g.flags.bLogDebugUpdate )
									_xlprintf(LOG_NOISE DBG_RELAY)( "--------------- Restoring prior image (didn't need a new image)" );
								if( g.flags.bLogDebugUpdate )
									lprintf( "Restoring orignal background... " );
#endif
								BlotImage( pc->Window, pc->OriginalSurface, 0, 0 );
								pc->flags.bParentCleaned = 1;
								pc->flags.children_cleaned = 0;
							}
					}
					else
					{
						if( pc->OriginalSurface )
						{
#ifdef DEBUG_UPDAATE_DRAW
							if( g.flags.bLogDebugUpdate )
								_xlprintf(LOG_NOISE DBG_RELAY)( "--------------- Restoring prior image" );
							if( g.flags.bLogDebugUpdate )
								lprintf( "Restore original background..." );
#endif
							BlotImage( pc->Window, pc->OriginalSurface, 0, 0 );
							pc->flags.bParentCleaned = 1;
							pc->flags.children_cleaned = 0;
						}
					}
				}
				pc->flags.bFirstCleaning = 0;
			}
			// dirty, draw, not hidden... but also
			// bInitial still invokes first draw.
			if( !pc->flags.bNoUpdate && ( g.flags.always_draw || pc->flags.bDirty || bDraw ) && !pc->flags.bHidden )
			{
				Image current = NULL;
#ifdef DEBUG_UPDAATE_DRAW
				if( g.flags.bLogDebugUpdate ) {
					_lprintf( DBG_RELAY )( "Invoking a draw self for %p level %d", pc, level );
				}
#endif
				if( pc->flags.bDestroy )
				{
#if LOCK_TEST
					if( device )
						UnlockRenderer( device->pActImg );
#endif
					return;
				}
				if( pc->flags.bTransparent
					&& !pc->flags.bParentCleaned
					&& (pc->parent&&!pc->device)
					)
				{
#ifdef DEBUG_UPDAATE_DRAW
					if( g.flags.bLogDebugUpdate )
						lprintf( "(RECURSE UP!)Calling parent inline - wasn't clean, isn't clean, try and get it clean..." );
#endif
					// could adjust the clipping rectangle...
					DoUpdateCommonEx( upd, pc->parent, TRUE, level+1 DBG_RELAY );
					if( !upd->flags.bHasContent )
					{
						//  control did not draw...
						//lprintf( " Expected handling of this condition... Please return FALSE, and abort UpdateDIsplayPortion? Return now, leaving the rect without content?" );
						//DebugBreak();
					}
					if( !pc->flags.bParentCleaned || ( ( pc->parent && !pc->device )?pc->parent->flags.bDirty:0))
					{
						//DebugBreak();
						lprintf( "Aborting my update... waiting for container to get his update done" );
#if LOCK_TEST
						if( device )
							UnlockRenderer( device->pActImg );
#endif
						pc->flags.bCleaning = 0;
						return;
					}
					if( pc->flags.bTransparent )
					{
						//lprintf( "COPYING SURFACE HERE!?" );
						// we should be drawing when the parent does his thing...
						if( g.flags.allow_copy_from_render )
							pc->OriginalSurface = CopyOriginalSurface( pc, pc->OriginalSurface );
						else
							pc->OriginalSurface = NULL;
					}
				}
				pc->draw_result = 0;
#ifdef DEBUG_UPDAATE_DRAW
				if( g.flags.bLogDebugUpdate )
					_lprintf(DBG_RELAY)( " --- INVOKE DRAW (get region) --- %s ", pc->pTypeName );
#endif
				{
#if LOCK_TEST
					PPHYSICAL_DEVICE device = GetFrame( pc )->device;
					if( device )
						LockRenderer( device->pActImg );
#endif
					// this causes a lock in that layer.?
					ResetImageBuffers( pc->Surface, FALSE );
					InvokeDrawMethod( pc, _DrawThySelf, ( pc ) );
				}
#ifdef DEBUG_UPDAATE_DRAW
				// if it didn't draw... then why do anything?
				if( g.flags.bLogDebugUpdate )
					lprintf( "draw result is... %d", pc->draw_result );
#endif
				//if( current )
				{
					if( !pc->draw_result )
					{
						//pc->flags.bParentCleaned = 0; // has now drawn itself, and we must assume that it's not clean.
						 //BlotImage( pc->Window, current, 0, 0 );
					}
					else
					{
#ifdef DEBUG_UPDAATE_DRAW
						if( g.flags.bLogDebugUpdate )
							lprintf( "Parent is no longer cleaned...." );
#endif
						pc->flags.bCleanedRecently = 1;
						//pc->flags.bParentCleaned = 0; // has now drawn itself, and we must assume that it's not clean.
						pc->flags.children_cleaned = 0;
					}
					//UnmakeImageFile( current);
				}
				// better clear this flag after so that a smudge during
				// a dumb control doesn't make us loop...
				// though I suppose some other control could cause us to draw again?
				// well leaving it set during will cause smudge to do what exactly
				pc->flags.bDirty = FALSE;
				//lprintf( "Invoked a draw self" );
				// the outermost border/frame will be drawn
				// from a different place... this one only needs to
				// worry aobut child region borders after telling them to
				// draw - to enforce cleanest bordering...
				if( g.flags.always_draw
					|| ( pc->parent && !pc->parent->flags.children_cleaned )
					|| ( pc->flags.bParentCleaned )
					)
  // and initial?
					if( pc->DrawBorder )
					{
#ifdef DEBUG_BORDER_DRAWING
						lprintf( "Drawing border here too.." );
#endif
						pc->DrawBorder( pc );
					}
#if DEBUG_UPDAATE_DRAW > 2
				if( g.flags.bLogDebugUpdate )
				{
					if( upd->flags.bHasContent )
						_lprintf(DBG_RELAY)( "Added update region %d,%d %d,%d", upd->x ,upd->y, upd->width, upd->height );
					else
						_lprintf(DBG_RELAY)( "No prior content in update rect..." );
				}
#endif
				// okay hokey logic here...
				// if not transparent - go
				// (else IS transparent, in which case if draw_result, go )
				//   ELSE don't add
				if( !pc->flags.bTransparent || pc->draw_result )
				{
					AddCommonUpdateRegion( upd, FALSE, pc );
				}
#if DEBUG_UPDAATE_DRAW > 2
				if( g.flags.bLogDebugUpdate )
				{
					if( upd->flags.bHasContent )
						_lprintf(DBG_RELAY)( "Added update region %d,%d %d,%d", upd->x ,upd->y, upd->width, upd->height );
				}
#endif
				cleaned = 1;
				{
					PSI_CONTROL child;
					//lprintf( "pc is %p and first child is %p", pc, pc->child );
					for( child = pc->child; child; child = child->next )
					{
						if( pc->draw_result )
						{
							// if it didn't draw, then probably the prior snapshot is still valid
 // set so controls grab new snapshots
							child->flags.bParentUpdated = 1;
						}
 // has now drawn itself, and we must assume that it's not clean.
						child->flags.bParentCleaned = 1;
#if DEBUG_UPDAATE_DRAW > 2
						if( g.flags.bLogDebugUpdate )
							lprintf( "marking on child %p parent %p(%p) is %s;%s", child, pc, child->parent, cleaned?"CLEANED":"UNCLEAN", child->parent->flags.bDirty?"DIRTY":"not dirty" );
#endif
					}
				}
				//pc->flags.bDirty = 0;
#ifdef DEBUG_UPDAATE_DRAW
				if( g.flags.bLogDebugUpdate )
					lprintf( "And now it has been cleaned..." );
#endif
			}
			else
			{
				//cleaned = 1; // well, lie here... cause we're already clean?
#ifdef DEBUG_UPDAATE_DRAW
				if( g.flags.bLogDebugUpdate )
					lprintf( "Not invoking draw self." );
#endif
				//#if 0
#if DEBUG_UPDAATE_DRAW > 3
				// general logging of the current status of the control
				// at this point the NORMAL status is clean, visible, no force, and drawing proc.
				if( g.flags.bLogDebugUpdate )
					lprintf( "control %p is %s %s %s %s", pc, pc->flags.bDirty?"dirty":"clean"
							 , bDraw?"force":""
							 , pc->flags.bHidden?"hidden!":"visible..."
							 , pc->_DrawThySelf?"drawingproc":"NO DRAW PROC" );
#endif
//#endif
			}
			// check for dirty children.  That we over-drew ourselves...
//		check_for_dirty_children: ;
			if( !pc->flags.children_cleaned )
			{
				PSI_CONTROL child;
				for( child = pc->child; child; child = child->next )
				{
					// that we are ourselved drawn implies that
					// our max bound will be updated when children finish.
					// I drew myself, must draw all children.
					//lprintf( "doing a child update..." );
#if DEBUG_UPDAATE_DRAW > 2
					if( g.flags.bLogDebugUpdate )
						lprintf( "updating child %p parent %p is %s;%s", child, pc, cleaned?"CLEANED":"UNCLEAN", child->parent->flags.bDirty?"DIRTY":"not dirty" );
#endif
					//lprintf( "Do update region %d,%d %d,%d", upd->x ,upd->y, upd->width, upd->height );
					//child->flags.bParentCleaned = 1; // has now drawn itself, and we must assume that it's not clean.
					DoUpdateCommonEx( upd, child, cleaned, level+1 DBG_RELAY );
				}
			}
			if( pc->flags.bDirtied )
			{
				pc->flags.bDirtied = 0;
#ifdef DEBUG_UPDAATE_DRAW
				if( g.flags.bLogDebugUpdate )
					lprintf( "Recovered dirty that was set while we were cleaning... going back to draw again." );
#endif
				goto retry_update;
			}
			{
				PSI_CONTROL pcTemp = pc;
				for( pcTemp = pc; pcTemp; pcTemp = pcTemp->parent )
					// after all children have updated, draw decorations (edit hotspots, cover animations...)
					InvokeMethod( pcTemp, _DrawDecorations, (pcTemp, pc) );
			}
#if LOCK_TEST
			{
				PPHYSICAL_DEVICE device = GetFrame( pc )->device;
				if( device )
					UnlockRenderer( device->pActImg );
			}
#endif
			pc->flags.children_cleaned = 1;
			pc->flags.bCleaning = 0;
			pc->flags.bFirstCleaning = 1;
			//pc->flags.bParentCleaned = 0; // has now drawn itself, and we must assume that it's not clean.
		}
		else
		{
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				_xlprintf(1 DBG_RELAY)( "Already Cleaning!!!!!  (THIS IS A FATAL LOCK POTENTIAL)" );
#endif
			if( pc->NotInUse )
			{
				// it's in clean, and did a 'releasecommonuse'
				// this means that it wants everything within itself
				// to draw, at which time it will do it's own draw.
				// there's going to be a hang though, when the final
				// update to display happens... need to catch that.
 // lie.  The parent claims it finished cleaning
				cleaned = 1;
				// clear this, cause we're no longer drawing within the parent
#ifdef DEBUG_UPDAATE_DRAW
				if( g.flags.bLogDebugUpdate )
					lprintf( "Parent is no longer cleaned..." );
#endif
 // has now drawn itself, and we must assume that it's not clean.
				pc->flags.bParentCleaned = 0;
				pc->flags.children_cleaned = 1;
				{
					PSI_CONTROL child;
					for( child = pc->child; child; child = child->next )
					{
						// that we are ourselved drawn implies that
						// our max bound will be updated when children finish.
						// I drew myself, must draw all children.
#ifdef DEBUG_UPDAATE_DRAW
						if( g.flags.bLogDebugUpdate )
							lprintf( "***doing a child update... to %s", cleaned?"CLEAN":"UNCLEAN" );
#endif
 // has now drawn itself, and we must assume that it's not clean.
						child->flags.bParentCleaned = cleaned;
						//lprintf( "Do update region %d,%d %d,%d", upd->x ,upd->y, upd->width, upd->height );
						//child->flags.bParentCleaned = 1; // has now drawn itself, and we must assume that it's not clean.
						DoUpdateCommonEx( upd, child, cleaned, level+1 DBG_SRC );
					}
				}
				//pc->flags.bParentCleaned = 0; // has now drawn itself, and we must assume that it's not clean.
				//pc->flags.children_cleaned = 1;
			}
#if DEBUG_UPDAATE_DRAW > 2
			if( g.flags.bLogDebugUpdate )
				_xlprintf(1 DBG_RELAY)( "Control %p already drawing itself!?", pc );
#endif
		}
#if LOCK_TEST
		if( device )
			UnlockRenderer( device->pActImg );
#endif
	}
#ifdef DEBUG_UPDAATE_DRAW
	else
		if( g.flags.bLogDebugUpdate )
			_xlprintf(1 DBG_RELAY)( "NULL control told to update!" );
#endif
}
static int ChildInUse( PSI_CONTROL pc, int level )
{
	int n;
	while( pc )
	{
		if( pc->InUse )
			return TRUE;
		n = ChildInUse( pc->child, level+1 );
		if( n )
			return n;
		if( level )
			pc = pc->next;
		else
			break;
	}
	return FALSE;
}
//---------------------------------------------------------------------------
void SmudgeCommonEx( PSI_CONTROL pc DBG_PASS )
{
	if( !pc )
		return;
	if( pc->flags.bDestroy || !pc->Window )
		return;
	// if( pc->flags.bTransparent && pc->parent && !pc->parent->flags.bDirty )
	//    SmudgeCommon( pc->parent );
	if( g.flags.always_draw )
	{
		if( !pc->flags.bDestroy )
		{
			PSI_CONTROL frame = GetFrame( pc );
			PPHYSICAL_DEVICE device = frame?frame->device:NULL;
			if( device )
				MarkDisplayUpdated( device->pActImg );
		}
		if( g.flags.bLogDebugUpdate )
			_lprintf(DBG_RELAY)( "%p(%s) wanted to draw...", pc, pc->pTypeName );
		return;
	}
	else {
		LOGICAL schedule_only = FALSE;
#if DEBUG_UPDAATE_DRAW > 0
		if( g.flags.bLogDebugUpdate )
			_lprintf( DBG_RELAY )("Smudge %p %s", pc, pc->pTypeName ? pc->pTypeName : "NoTypeName");
#endif
		{
			PSI_CONTROL parent;
			for( parent = pc; parent; parent = parent->parent )
			{
				if( parent->flags.bNoUpdate || parent->flags.bHidden )
				{
#if DEBUG_UPDAATE_DRAW > 3
					if( g.flags.bLogDebugUpdate )
						lprintf( "a control %p(%d) (self, or some parent %p(%d)) has %s or %s  (marks me as dirty anhow, but doesn't attempt anything further)"
							, pc, pc->nType, parent, parent->nType
							, parent->flags.bNoUpdate ? "noupdate" : "..."
							, parent->flags.bHidden ? "hidden" : "..."
							);
#endif
					pc->flags.bDirty = 1;
					{
						PSI_CONTROL child;
						for( child = pc->child; child; child = child->next )
						{
 // has now drawn itself, and we must assume that it's not clean.
							child->flags.bParentCleaned = 0;
						}
					}
					// otherwise we need to schedule the drawing...
					if( g.flags.allow_threaded_draw )
						return;
					else
						schedule_only = TRUE;
				}
			}
		}
		if( !g.flags.allow_threaded_draw && !IsThisThread( g.updateThread ) )
		{
			PSI_CONTROL frame = GetFrame( pc );
			PPHYSICAL_DEVICE device = frame?frame->device:NULL;
			if( device )
			{
#if DEBUG_UPDAATE_DRAW > 0
				if( g.flags.bLogDebugUpdate )
					_lprintf(DBG_RELAY)( "Add to dirty controls... Smudge %p %s", pc, pc->pTypeName?pc->pTypeName:"NoTypeName" );
#endif
				if( FindLink( &device->pending_dirty_controls, pc ) == INVALID_INDEX )
					AddLink( &device->pending_dirty_controls, pc );
				if( !schedule_only && !device->flags.sent_redraw && device->pActImg )
				{
					//lprintf( "Send redraw to self.... draw controls in pending_dirty_controls" );
					//device->flags.sent_redraw = 1;
					//lprintf( " -----  parent update Redraw ----" );
					Redraw( device->pActImg );
				}
			}
			return;
		}
		else
		{
			if( pc->flags.bDirty || pc->flags.bCleaning )
			{
				if( pc->flags.bCleaning )
				{
					uint32_t tick = timeGetTime();
					// something changed, and we'll have to draw that control again... as soon as it's done cleaning actually.
					pc->flags.bDirtied = 1;
					while( pc->flags.bCleaning && pc->flags.bDirtied && ((tick + 500) < timeGetTime()) )
						WakeableSleep( 10 );
					if( !pc->flags.bCleaning )
						if( pc->flags.bDirtied )
							pc->flags.bDirty = 1;
				}
#if DEBUG_UPDAATE_DRAW > 3
				if( g.flags.bLogDebugUpdate )
					_xlprintf( LOG_LEVEL_DEBUG DBG_RELAY )("%s %s %s %p"
						, pc->flags.bDirty ? "already smudged" : ""
						, (pc->flags.bDirty && pc->flags.bCleaning) ? "and" : ""
						, pc->flags.bCleaning ? "in process of cleaning..." : ""
						, pc);
#endif
				//Sleep( 10 );
				   //return;
			}
 // if( !pc->flags.bDirty )
			else
			{
				PSI_CONTROL parent;
#if DEBUG_UPDAATE_DRAW > 3
				if( g.flags.bLogDebugUpdate )
					lprintf( "not dirty, and not cleaning" );
#endif
#ifdef DEBUG_UPDAATE_DRAW
				//if( pc->parent && pc->flags.bTransparent )
				//   SmudgeCommon( pc->parent );
 /*&& parent->flags.bTransparent*/
				for( parent = pc; parent &&
					!parent->InUse &&
					!parent->flags.bDirty; parent = parent->parent )
				{
					if( g.flags.bLogDebugUpdate )
						_xlprintf( LOG_LEVEL_DEBUG DBG_RELAY ) ("%s %p is %s and %s %s"
							, (parent == pc) ? "self" : "parent"
							, parent
							, parent->InUse ? "USED" : "Not Used"
							, parent->flags.bTransparent ? "Transparent" : "opaque"
							, parent->flags.bChildDirty ? "has Dirty Child" : "children clean");
					//parent->flags.bChildDirty = 1;
				}
#endif
				// a parent is in use (misleading - parent may be self...)
				// - that means that
				// an event is dispatched, and when that event is complete
				// it will have all children checked for dirt.
#ifdef DEBUG_UPDAATE_DRAW
				{
					if( g.flags.bLogDebugUpdate )
						_xlprintf( LOG_NOISE DBG_RELAY )("marking myself dirty. %p", pc);
				}
#endif
				pc->flags.bDirty = 1;
			}
		}
		if( pc->flags.bOpenGL )
		{
			UpdateDisplay( GetFrameRenderer( pc ) );
			return;
		}
		// actually when it comes time to do the update
		// the children's draw is forced-run because the
		// parent updated, and therefore obviously oblitereted
		// the region the child had, the child therefore NEEDS to draw.
		// if dirty, but nothings in use...
		// then I guess we get to clear stuff out.
		//if( !pc->InUse && !ChildInUse( pc, 0 ) )
		{
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				lprintf( "control is not in use... (smudge logic) Initial=%d ", pc->flags.bInitial );
#endif
			if( !pc->flags.bInitial )
			{
				IntelligentFrameUpdateAllDirtyControls( pc DBG_RELAY );
			}
#ifdef DEBUG_UPDAATE_DRAW
			else
				if( g.flags.bLogDebugUpdate )
					lprintf( "pc->flags.bInitial is true..." );
#endif
		}
	}
}
//---------------------------------------------------------------------------
void DoDumpFrameContents( int level, PSI_CONTROL pc )
{
	while( pc )
	{
		lprintf( "%*.*s" "Control %d(%d)%p at (%" _32fs ",%" _32fs ")-(%" _32f ",%" _32f ") (%" _32fs ",%" _32fs ")-(%" _32f ",%" _32f ") (%s %s %s %s) '%s' [%s]"
		       , level*3,level*3,"----------------------------------------------------------------"
		       , pc->nID, pc->nType, pc
		       , pc->rect.x, pc->rect.y, pc->rect.width, pc->rect.height
		       , pc->surface_rect.x
		       , pc->surface_rect.y
		       , pc->surface_rect.width
		       , pc->surface_rect.height
		       , pc->flags.bTransparent?"transparent":"t"
		       , pc->flags.bDirty?"dirty":"d"
		       , pc->flags.bNoUpdate?"NoUpdate":"nu"
		       , pc->flags.bHidden?"hidden":"h"
		       , pc->caption.text?GetText(pc->caption.text):""
		       , pc->pTypeName
		       );
		if( pc->child )
		{
			//lprintf( "%*.*s", level*2,level*2,"                                                                                                          " );
			DoDumpFrameContents( level + 1, pc->child );
		}
		pc = pc->next;
	}
}
void DumpFrameContents( PSI_CONTROL pc )
{
   DoDumpFrameContents( 0, GetFrame( pc ) );
}
//---------------------------------------------------------------------------
PSI_PROC( void, UpdateCommonEx )( PSI_CONTROL pc, int bDraw DBG_PASS )
{
	PSI_PENDING_RECT upd;
	upd.flags.bTmpRect = 0;
	upd.flags.bHasContent = 0;
	if( !(pc->flags.bNoUpdate || pc->flags.bHidden) )
	{
		PSI_CONTROL frame = GetFrame( pc );
 // else we're being destroyed probably...
		if( frame )
		{
#if DEBUG_UPDAATE_DRAW > 2
			if( g.flags.bLogDebugUpdate )
				_xlprintf(LOG_NOISE DBG_RELAY )( "Updating common ( which invokes frame... )%p %p", pc, frame );
#endif
			// go up, check all
			{
				//void DumpFrameContents( PSI_CONTROL pc );
				//DumpFrameContents( frame );
			}
			DoUpdateCommonEx( &upd, pc, bDraw, 0 DBG_RELAY );
			if( upd.flags.bHasContent )
			{
#ifdef DEBUG_UPDAATE_DRAW
				if( g.flags.bLogDebugUpdate )
					lprintf( "Updated all commons? flush display %d,%d  %d,%d", upd.x,upd.y, upd.width, upd.height );
#endif
#ifdef BLAT_COLOR_UPDATE_PORTION
				TESTCOLOR=SetAlpha( BASE_COLOR_GREEN, 0x80 );
#endif
				DoUpdateFrame( frame
								 , upd.x, upd.y
								 , upd.width, upd.height
								 , FALSE
								  DBG_SRC );
			}
		}
	}
}
//---------------------------------------------------------------------------
static int OnCreateCommon( "Frame" )( PSI_CONTROL pc )
{
	// cannot fail create frame - it's a simple control
	// later - if DisplayFrame( pc ) creates a physical display
	// for such a thing, and DIsplayFrameOver if that should be
	// modally related to another contorl/frame
	return 1;
}
CONTROL_REGISTRATION frame_controls = { "Frame", { { 320, 240 }, 0, BORDER_NORMAL }
};
PRIORITY_PRELOAD( register_frame_control, PSI_PRELOAD_PRIORITY )
{
   DoRegisterControlEx( &frame_controls, sizeof( frame_controls ) );
}
//---------------------------------------------------------------------------
static void LinkInNewControl( PSI_CONTROL parent, PSI_CONTROL elder, PSI_CONTROL child );
PROCEDURE RealCreateCommonExx( PSI_CONTROL *pResult
									  , PSI_CONTROL pContainer
										// if not typename, must pass type ID...
									  , CTEXTSTR pTypeName
									  , uint32_t nType
										// position of control
									  , int x, int y
									  , int w, int h
									  , uint32_t nID
									  , CTEXTSTR pIDName
										// ALL controls have a caption...
									  , CTEXTSTR text
										// fields in this override the defaults...
										// if not 0.
									  , uint32_t ExtraBorderType
 // if !bCreate, return reload type
									  , int bCreate
										// if this is reloaded...
										//, PTEXT parameters
										//, va_list args
										DBG_PASS )
{
	TEXTCHAR mydef[256];
	PCLASSROOT root;
	PSI_CONTROL pc = NULL;
	uint32_t BorderType;
#ifdef USE_INTERFACES
	GetMyInterface();
	if( !g.MyImageInterface )
	{
		if( pResult )
			(*pResult) = NULL;
		return NULL;
	}
#endif
	if( pTypeName )
		tnprintf( mydef, sizeof( mydef ), PSI_ROOT_REGISTRY "/control/%s", pTypeName );
	else
		tnprintf( mydef, sizeof( mydef ), PSI_ROOT_REGISTRY "/control/%" _32f , nType );
	root = GetClassRoot( mydef );
	if( pTypeName )
		nType = (int)(uintptr_t)GetRegisteredValueExx( root, NULL, "type", TRUE );
	else
		pTypeName = GetRegisteredValueExx( root, NULL, "type", FALSE );
	pc = (PSI_CONTROL)AllocateEx( sizeof( FR_CT_COMMON ) DBG_RELAY );
	MemSet( pc, 0, sizeof( FR_CT_COMMON ) );
	pc->class_root = root;
	//pc->basecolors = basecolor( pContainer );
	{
		uint32_t size = GetRegisteredIntValue( root, "extra" );
		if( size )
		{
			POINTER data = Allocate( size );
			if( data )
				MemSet( data, 0, size );
			SetControlData( POINTER, pc, data );
		}
	}
	if( !w )
		w = GetRegisteredIntValue( root, "width" );
	if( !h )
		h = GetRegisteredIntValue( root, "height" );
	// save the orginal width/height/size
	// (pre-scaling...)
	pc->original_rect.x = x;
	pc->original_rect.y = y;
	pc->original_rect.width = w;
	pc->original_rect.height = h;
#ifdef DEFAULT_CONTROLS_TRANSPARENT
	pc->flags.bTransparent = 1;
#endif
	pc->flags.bParentCleaned = 1;
	BorderType = (int)(uintptr_t)GetRegisteredValueExx( root, NULL, "border", TRUE );
	BorderType |= ExtraBorderType;
	//lprintf( "BorderType is %08x", BorderType );
	if( !(BorderType & BORDER_FIXED) )
	{
		PFRACTION sx, sy;
		GetCommonScale( pContainer, &sx, &sy );
		x = ScaleValue( sx, x );
		w = ScaleValue( sx, w );
		y = ScaleValue( sy, y );
		h = ScaleValue( sy, h );
	}
	if( pIDName )
	{
		pc->nID = GetResourceID( pContainer, pIDName, nID );
		pc->pIDName = StrDup( pIDName );
	}
	else
	{
		pc->nID = nID;
		pc->pIDName = GetResourceIDName( pTypeName, nID );
	}
	pc->nType = nType;
	pc->pTypeName = SaveText( pTypeName );
	if( pContainer )
	{
		pc->Window = MakeSubImage( pContainer->Surface, x, y, w, h );
		if( !pc->Window )
		{
			DebugBreak();
		}
	}
	else
	{
		// need some kinda window here...
		pc->Window = BuildImageFile( NULL, w, h );
		if( !pc->Window )
		{
			DebugBreak();
		}
		// the surface will not exist until it is mounted
		// on a surface?  as of yet, we do not have invisible
		// memory-only dialogs(frames) but there comes a time
		// in all controls life when it needs its own backing
		// with real pixel data.
		// MakeImageFile( w, h );
	}
	// normal rect of control - post scaling, true coords within container..
	pc->rect.x = x;
	pc->rect.y = y;
	pc->rect.width = w;
	pc->rect.height = h;
	//lprintf( "Set default fraction 1/1" );
	SetFraction( pc->scalex, 1, 1 );
	SetFraction( pc->scaley, 1, 1 );
	pc->flags.bInitial = 1;
	//else
	//	pc->caption.font = g.default_font;
	// from here forward, root and mydef reference the RTTI of the control...
	//
	tnprintf( mydef, sizeof( mydef ), PSI_ROOT_REGISTRY "/control/%" _32f "/rtti", nType );
	root = GetClassRoot( mydef );
	SetCommonDraw( pc, GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,int,"draw",(PSI_CONTROL)));
	SetCommonDrawDecorations( pc, GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,void,"decoration_draw",(PSI_CONTROL,PSI_CONTROL)));
	SetCommonMouse( pc, GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,int,"mouse",(PSI_CONTROL,int32_t,int32_t,uint32_t)));
	SetCommonKey( pc, GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,int,"key",(PSI_CONTROL,uint32_t)));
	pc->Destroy        = GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,void,"destroy",(PSI_CONTROL));
	pc->CaptionChanged = GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,void,"caption_changed",(PSI_CONTROL));
	pc->ChangeFocus    = GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,int,"focus_changed",(PSI_CONTROL,LOGICAL));
	pc->AddedControl   = GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,void,"add_control",(PSI_CONTROL,PSI_CONTROL));
	AddCommonAcceptDroppedFiles( pc, GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,LOGICAL,"drop_accept",(PSI_CONTROL,CTEXTSTR,int32_t,int32_t)) );
	pc->Resize         = GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,void,"resize",(PSI_CONTROL,LOGICAL));
	pc->Move         = GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,void,"position_changing",(PSI_CONTROL,LOGICAL));
	pc->Rescale        = GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,void,"rescale",(PSI_CONTROL));
	pc->BorderDrawProc = GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,void,"border_draw",(PSI_CONTROL,Image));
	pc->Rollover = GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,void,"rollover",(PSI_CONTROL,LOGICAL));
	pc->FontChange = GetRegisteredProcedureExx(root,(CTEXTSTR)NULL, void, "font_change", (PSI_CONTROL) );
	if( !pContainer || ( ExtraBorderType & BORDER_FRAME ) )
	{
		// define default border.
		if( !g.flags.system_color_set )
			TryLoadingFrameImage();
		pc->border = g.DefaultBorder;
	}
	if( pc->BorderDrawProc )
	{
		pc->BorderMeasureProc = GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,void,"border_measure",(PSI_CONTROL,int*,int*,int*,int*));
		pc->BorderType = BORDER_USER_PROC | ( BorderType & ~BORDER_TYPE );
  // sets real draw proc
		SetDrawBorder( pc );
	}
	else
	{
  // this time, force the setting of the border... even if it's '0' or NONE
		pc->BorderType = ~BorderType;
 // updates the border proc...
		SetCommonBorder( pc, BorderType );
	}
	//pc->PosChanging    = GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,void,"position_changing",(PSI_CONTROL,LOGICAL));
	pc->BeginEdit      = GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,void,"begin_frame_edit",(PSI_CONTROL));
	pc->EndEdit        = GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,void,"end_frame_edit",(PSI_CONTROL));
	pc->DrawCaption    = GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,void,"draw_caption",(PSI_CONTROL,Image));
	if( pc->DrawCaption )
 // this will get resized later
		pc->pCaptionImage = MakeSubImage( pc->Window, 0, 0, 0, 0 );
	// creates
	pc->flags.bInitial = 1;
	pc->flags.bDirty = 1;
	pc->flags.bCreating = 1;
	// have to set border type to non 0 here; in case border includes FIXED and the scaling in SetFont should be skipped.
 /*pc->nType == CONTROL_FRAME*/
	if( !pContainer && g.default_font )
	{
		SetCommonFont( pc, g.default_font );
	}
	pc->flags.bSetBorderType = 0;
	SetControlText( pc, text );
	if( pContainer )
	{
		LinkInNewControl( pContainer, NULL, pc );
		pContainer->InUse++;
		//lprintf( "Added one to use.." );
		if( !pContainer->flags.bDirty )
			SmudgeCommon( pc );
		pContainer->InUse--;
		//lprintf( "Removed one to use.." );
	}
	if( pResult )
		*pResult = pc;
	if( !bCreate )
	{
		int (CPROC*Restore)(PSI_CONTROL,PTEXT);
		// allow init to return FALSE to destroy the control...
		Restore = GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,int,"load",(PSI_CONTROL,PTEXT));
		if( Restore )
			return (PROCEDURE)Restore;
	}
	else
	{
		int (CPROC*Init)(PSI_CONTROL,va_list);
		// allow init to return FALSE to destroy the control...
		Init = GetRegisteredProcedureExx(root,(CTEXTSTR)NULL,int,"init",(PSI_CONTROL,va_list));
		if( Init )
			return (PROCEDURE)Init;
	}
 //pc;
	return NULL;
}
//---------------------------------------------------------------------------
#define CreateCommonExx(pc,pt,nt,x,y,w,h,id,cap,ebt,p,ep) CreateCommonExxx(pc,pt,nt,x,y,w,h,id,NULL,cap,ebt,p,ep)
PSI_PROC( PSI_CONTROL, CreateCommonExxx)( PSI_CONTROL pContainer
													 , CTEXTSTR pTypeName
													 , uint32_t nType
													 , int x, int y
													 , int w, int h
													 , uint32_t nID
													 , CTEXTSTR pIDName
													 , CTEXTSTR caption
													 , uint32_t ExtraBorderType
													 , PTEXT parameters
													 , POINTER extra_param
													  DBG_PASS );
//---------------------------------------------------------------------------
PSI_PROC( PSI_CONTROL, CreateFrame )( CTEXTSTR caption
										  , int x, int y
										  , int w, int h
										  , uint32_t BorderTypeFlags
										  , PSI_CONTROL hAbove )
{
	PSI_CONTROL pc;
	//lprintf( "Creating a frame at %d,%d %d,%d", x, y, w, h );
#ifdef USE_INTERFACES
 // macro with builtin quickcheck
	GetMyInterface();
#endif
 // hAbove//(BorderTypeFlags & BORDER_WITHIN)?hAbove:NULL
	pc = CreateCommonExx( NULL
							  , NULL, CONTROL_FRAME
							  , x, y
							  , w, h
							  , -1
							  , caption
							  , BorderTypeFlags
							  , NULL
							  , NULL
								DBG_SRC );
	if( !(BorderTypeFlags & BORDER_WITHIN ) )
		pc->parent = hAbove;
	SetCommonBorder( pc, BorderTypeFlags
				| (( BorderTypeFlags & BORDER_CAPTION_NO_CLOSE_BUTTON )?0:BORDER_CAPTION_CLOSE_BUTTON)
				| ((BorderTypeFlags & BORDER_WITHIN)?0:BORDER_FRAME)
				);
	// init close button here.
	AddCaptionButton( pc, NULL, NULL, NULL, 0, NULL );
	//lprintf( "FRAME is %p", pc );
	return pc;
}
//---------------------------------------------------------------------------
PSI_PROC( uintptr_t, GetControlUserData )( PSI_CONTROL pf )
{
	if( pf )
		return pf->psvUser;
	return 0;
}
//---------------------------------------------------------------------------
PSI_PROC( void, SetControlUserData )( PSI_CONTROL pf, uintptr_t psv )
{
	if( pf )
		pf->psvUser = psv;
}
//---------------------------------------------------------------------------
PSI_PROC( int, PSI_AddBindingData )(CTEXTSTR name) {
	// add a binding dta; name may be used lter for diagnostics?
	return 0;
}
PSI_PROC( uintptr_t, PSI_GetBindingData )(PSI_CONTROL pf, int unused)
{
	// use indexer to load per-binding-type value
	if( pf )
		return pf->psvBinding;
	return 0;
}
//---------------------------------------------------------------------------
PSI_PROC( void, PSI_SetBindingData )(PSI_CONTROL pf, int unused, uintptr_t psv)
{
	// use indexer to store per-binding-type value
	if( pf )
		pf->psvBinding = psv;
}
//---------------------------------------------------------------------------
PSI_PROC( void, RevealCommonEx )( PSI_CONTROL pc DBG_PASS )
{
	static int level = 0;
	level++;
	if( pc )
	{
		int parent_hidden = 0;
		int parent_initial = 0;
		int was_hidden = pc->flags.bHidden;
		int revealed = 0;
		PSI_CONTROL parent;
		for( parent = pc?pc->parent:NULL; parent; parent = parent->parent )
		{
			if( parent->flags.bHidden )
				parent_hidden = 1;
			if( parent->flags.bInitial )
				parent_initial = 1;
			//lprintf( "(%p)Parent h %d i %d", parent, parent_hidden, parent_initial );
		}
		//lprintf( "Parent h %d i %d", parent_hidden, parent_initial );
#ifdef DEBUG_UPDAATE_DRAW
		if( g.flags.bLogDebugUpdate )
			_xlprintf(LOG_NOISE DBG_RELAY)( "Revealing %p %s %s"
					, pc
					, pc->pTypeName?pc->pTypeName:"NoTypeName"
					, pc->caption.text?GetText( pc->caption.text ):"" );
#endif
		if( pc->device )
		{
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				lprintf( "showing a renderer..." );
#endif
			revealed = was_hidden;
			pc->flags.bHidden = 0;
			pc->flags.bNoUpdate = 0;
			pc->flags.bRestoring = 1;
			RestoreDisplay( pc->device->pActImg );
			// need to not clear restoring here; it might take a while, (we might have to return before it happens)
		}
		if( was_hidden && ( (level > 1)?1:(pc->flags.bHiddenParent) ) )
		{
			PSI_CONTROL child;
			revealed = 1;
			if( !parent_hidden && !parent_initial )
				InvokeControlRevealed( pc );
			pc->flags.bNoUpdate = 0;
			pc->flags.bHidden = 0;
			if( pc->child )
			{
				//pc->child->flags.bHiddenParent = 0;
#ifdef DEBUG_UPDAATE_DRAW
				if( g.flags.bLogDebugUpdate )
					lprintf( "Found something hidden... revealing it, and all children." );
#endif
				for( child = pc->child; child; child = child->next )
					if( !child->flags.bHiddenParent )
						RevealCommon( child );
			}
#ifdef DEBUG_UPDAATE_DRAW
			else
				if( g.flags.bLogDebugUpdate )
					lprintf( "Control was hidden, now showing." );
#endif
			//pc->flags.bParentCleaned = 1;
			pc->flags.bHiddenParent = 0;
		}
		if( !pc->flags.bInitial )
		{
			if( !pc->flags.bRestoring )
			{
#ifdef UNDER_CE
				// initial show should already be triggering update draw...
				// this smudge should not happen for device reveals
				//if( !pc->device )
#endif
				if( !g.flags.always_draw )
					SmudgeCommon( pc );
				//UpdateCommon( pc );
			}
		}
#ifdef DEBUG_UPDAATE_DRAW
		else
			if( g.flags.bLogDebugUpdate )
				lprintf( "Initial, no draw" );
#endif
	}
	level--;
}
//---------------------------------------------------------------------------
PSI_PROC( void, DisplayFrameOverOnUnder )( PSI_CONTROL pc, PSI_CONTROL over, PRENDERER pActImg, PSI_CONTROL under )
{
	PPHYSICAL_DEVICE pf = pc?pc->device:NULL;
	if( pc && !pf )
	{
#ifdef DEBUG_UPDAATE_DRAW
		if( g.flags.bLogDebugUpdate )
			lprintf( "-------- OPEN DEVICE" );
#endif
		pc->flags.bInitial = FALSE;
		pc->flags.bOpeningFrameDisplay = TRUE;
		pf = OpenPhysicalDevice( pc, over, pActImg, under );
		pc->flags.bOpeningFrameDisplay = FALSE;
		pc->stack_parent = over;
		pc->stack_child = under;
		if( under )
			under->stack_parent = pc;
		if( over )
			over->stack_child = pc;
#ifdef DEBUG_UPDAATE_DRAW
		if( g.flags.bLogDebugUpdate )
			lprintf( "-------- device opened" );
#endif
	}
#ifdef DEBUG_CREATE
	lprintf( "-------------------- Display frame has been invoked..." );
#endif
	if( pf )
	{
		// if, by tthe time we show, there's no focus, set that up.
		if( !pf->pFocus )
			FixFrameFocus( pf, FFF_HERE );
		if( pc->flags.bInitial )
		{
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				lprintf( "********* FIrst showing of this window - it's been bINitial for so long..." );
#endif
			// one final draw to make sure everyone is clean.
			//lprintf( "Dipsatch draw." );
			//UpdateCommonEx( pc, FALSE DBG_SRC );
			// clear initial so that further updatecommon's
			// can result in updates to the display.
			// do the move before initial, otherwise certain video
			// drivers may give a redundant paint...
			//MoveSizeDisplay( pf->pActImg, pc->rect.x, pc->rect.y, pc->rect.width, pc->rect.height );
			//Initial prevents all updates in all ways.  So here we're showing, we have a device,
			// and we should be allowed to draw - right? that's what initial is?
			pc->flags.bInitial = FALSE;
			if( g.flags.bLogDebugUpdate )
				lprintf( "inital was set to false...." );
 // re-sets routines, but also calls draws for border and caption.
			SetDrawBorder( pc );
 // fake this.. so reveal shows it... hidden parents will remain hidden
			pc->flags.bHidden = TRUE;
		}
		RevealCommon( pc );
		//lprintf( "Draw common?!" );
		/* wait for the draw event from the video callback... */
		//UpdateCommonEx( pc, FALSE DBG_SRC );
		//SyncRender( pf->pActImg );
		if( pc->flags.bEditSet )
			EditFrame( pc, !pc->flags.bNoEdit );
		pc->flags.auto_opened = 0;
	}
}
PSI_PROC( void, DisplayFrameOverOn )( PSI_CONTROL pc, PSI_CONTROL over, PRENDERER pActImg )
{
	DisplayFrameOverOnUnder( pc, over, pActImg, NULL );
}
//---------------------------------------------------------------------------
PSI_PROC( void, DisplayFrameOver )( PSI_CONTROL pc, PSI_CONTROL over )
{
	//lprintf( "Displayframeover" );
	DisplayFrameOverOn( pc, over, NULL );
	//SmudgeCommon( pc );
}
//---------------------------------------------------------------------------
PSI_PROC( void, DisplayFrameUnder )( PSI_CONTROL pc, PSI_CONTROL under )
{
	//lprintf( "Displayframeover" );
	DisplayFrameOverOnUnder( pc, NULL, NULL, under );
	SmudgeCommon( pc );
}
//---------------------------------------------------------------------------
PSI_PROC( void, DisplayFrame )( PSI_CONTROL pc )
{
	//lprintf( "DisplayFrame" );
	DisplayFrameOverOn( pc, NULL, NULL );
}
//---------------------------------------------------------------------------
PSI_PROC( void, DisplayFrameOn )( PSI_CONTROL pc, PRENDERER pActImg )
{
	//lprintf( "DisplayfFrameOn" );
	DisplayFrameOverOn( pc, NULL, pActImg );
}
//---------------------------------------------------------------------------
PSI_PROC( void, HideControl )( PSI_CONTROL pc )
{
	/* should additionally wrap this with a critical section */
	static int levels;
	int hidden = 0;
	if( !pc )
		return;
#ifdef DEBUG_UPDAATE_DRAW
	if( g.flags.bLogDebugUpdate )
		lprintf( "Hide common %p %s %s"
				, pc
				, pc->pTypeName?pc->pTypeName:"NoTypeName"
				, pc->caption.text?GetText( pc->caption.text ):"" );
#endif
	//PSI_CONTROL _pc = pc;
	levels++;
	if( levels == 1 )
		pc->flags.bHiddenParent = 1;
 // already hidden, forget someeone telling me this.
	if( pc->flags.bHidden )
	{
#ifdef DEBUG_UPDAATE_DRAW
		if( g.flags.bLogDebugUpdate )
			lprintf( "Already hidden..." );
#endif
		levels--;
		return;
	}
	pc->flags.bHidden = 1;
	if( pc->flags.bInitial )
	{
#ifdef DEBUG_UPDAATE_DRAW
		if( g.flags.bLogDebugUpdate )
			lprintf( "Control hasn't been shown yet..." );
#endif
		// even if not shown, do mark this hidden control as a hidden parent
		// so it's not auto unhidden on revealing the containing frame.
		levels--;
		return;
	}
	//lprintf( "HIDING %p(%d)", pc, pc->nType );
	if( pc->device )
	{
		//lprintf( "hiding a display image..." );
		pc->flags.bNoUpdate = 1;
		HideDisplay( pc->device->pActImg );
	}
	if( pc )
	{
		PSI_CONTROL child;
		hidden = 1;
		if( GetFrame(pc )->device && GetFrame(pc )->device->pFocus == pc )
			FixFrameFocus( GetFrame(pc)->device, FFF_HERE );
		for( child = pc->child; child; child = child->next )
		{
			/* hide all children, which will trigger /dev/null update */
			HideControl( child );
		}
	}
	if( hidden )
	{
		// tell people that the control is hiding, in case they wanna do additional work
		// the clock for instance disables it's checked entirely when hidden.
		InvokeControlHidden( pc );
	}
	levels--;
	if( !levels && pc )
	{
		pc->flags.bHiddenParent = 1;
		if( pc->parent && hidden )
		{
			//pc->parent->InUse++;
			//lprintf( "Added one to use.." );
			ResetImageBuffers( pc->Window, FALSE );
			if( pc->flags.bTransparent && pc->OriginalSurface )
			{
#ifdef DEBUG_UPDAATE_DRAW
				if( g.flags.bLogDebugUpdate )
					lprintf( "transparent thing..." );
#endif
				if( !pc->flags.bParentCleaned && pc->OriginalSurface )
				{
#ifdef DEBUG_UPDAATE_DRAW
					if( g.flags.bLogDebugUpdate )
						lprintf( "Restoring old surface..." );
					if( g.flags.bLogDebugUpdate )
						lprintf( "Restoring orignal background... " );
#endif
					BlotImage( pc->Window, pc->OriginalSurface, 0, 0 );
					pc->flags.bParentCleaned = 1;
					{
						PSI_PENDING_RECT upd;
#ifdef DEBUG_UPDAATE_DRAW
						if( g.flags.bLogDebugUpdate )
							lprintf( "pc = %p par = %p", pc, pc->parent );
#endif
						upd.flags.bHasContent = 0;
						upd.flags.bTmpRect = 0;
						//lprintf( "doing update common..." );
#ifdef DEBUG_UPDAATE_DRAW
						if( g.flags.bLogDebugUpdate )
							lprintf( "Flushing this button to the display..." );
#endif
#ifdef BLAT_COLOR_UPDATE_PORTION
						TESTCOLOR=SetAlpha( BASE_COLOR_YELLOW, 0x20 );
#endif
						/*
						DoUpdateFrame( pc
										 , pc->rect.x, pc->rect.y
										 , pc->rect.width, pc->rect.height
										 , TRUE
										  DBG_SRC );
						*/
						DoUpdateFrame( pc->parent
							 , (pc->parent->device?0:pc->parent->rect.x) + pc->parent->surface_rect.x + pc->rect.x
							 , (pc->parent->device?0:pc->parent->rect.y) + pc->parent->surface_rect.y + pc->rect.y
							 , pc->rect.width, pc->rect.height
							 , FALSE
							  DBG_SRC
							 );
					}
				}
				else if( pc->OriginalSurface )
				{
#ifdef DEBUG_UPDAATE_DRAW
					if( g.flags.bLogDebugUpdate )
						lprintf( "Parent was already clean... did nothing" );
#endif
				}
				else
				{
					lprintf( "NOthing to recover?" );
				}
			}
			else
			{
#ifdef DEBUG_UPDAATE_DRAW
				if( g.flags.bLogDebugUpdate )
					lprintf( "Parent needs to be drawn, no auto recovery available");
#endif
				SmudgeCommon( pc->parent );
			}
		}
#ifdef DEBUG_UPDAATE_DRAW
		else
			if( g.flags.bLogDebugUpdate )
				lprintf( "..." );
#endif
	}
#ifdef DEBUG_UPDAATE_DRAW
	if( g.flags.bLogDebugUpdate )
		lprintf( "levels: %d", levels );
#endif
}
//---------------------------------------------------------------------------
PSI_PROC( void, SizeCommon )( PSI_CONTROL pc, uint32_t width, uint32_t height )
{
	if( pc && pc->Resize )
		pc->Resize( pc, TRUE );
	//if( pc->nType )
	if( pc )
	{
		PPHYSICAL_DEVICE pFrame = GetFrame(pc)->device;
		//ValidatedControlData( PFRAME, CONTROL_FRAME, pFrame, GetFrame( pc ) );
		IMAGE_RECTANGLE old;
		PEDIT_STATE pEditState;
		int32_t delw, delh;
		{
			PFRACTION ix, iy;
			GetCommonScale( pc, &ix, &iy );
			pc->original_rect.width = InverseScaleValue( ix, width );
			pc->original_rect.height = InverseScaleValue( iy, height );
		}
		if( !pc->parent && pc->device && pc->device->pActImg )
		{
			// we now have this accuragely handled.
			//  rect is active (with frame)
			//  oroginal_rect is the size it was before having to extend it
			// somwehere between original_rect changes and rect changes surface_rect is recomputed
			//lprintf( "Enlarging size..." );
			if( pc->BorderType == BORDER_USER_PROC )
			{
				int left, top, right, bottom;
				if( pc->BorderMeasureProc )
				{
					pc->BorderMeasureProc( pc, &left, &top, &right, &bottom );
					width += left + right;
					height += top + bottom;
				}
			}
			else
			{
				width += FrameBorderX(pc, pc->BorderType);
				height += FrameBorderY(pc, pc->BorderType, GetText( pc->caption.text ) );
			}
			SizeDisplay( pc->device->pActImg, width, height );
		}
		delw = (int32_t)width - (int32_t)pc->rect.width;
		delh = (int32_t)height - (int32_t)pc->rect.height;
		old = pc->rect;
		if( pFrame )
			pEditState = &pFrame->EditState;
		else
			pEditState = NULL;
		pc->rect.width = width;
		pc->rect.height = height;
		ResizeImage( pc->Window, width, height );
		if( pEditState && pEditState->flags.bActive &&
			pEditState->pCurrent == pc )
		{
			old.x -= SPOT_SIZE;
			old.y -= SPOT_SIZE;
			old.width += 2*SPOT_SIZE;
			old.height += 2*SPOT_SIZE;
		}
		UpdateSurface( pc );
		if( pFrame && !pFrame->flags.bNoUpdate )
		{
			if( pEditState->flags.bActive &&
				pEditState->pCurrent == pc )
			{
				SetupHotSpots( pEditState );
				SmudgeCommon( pFrame->common );
			}
		}
	}
	if( pc && pc->Resize )
		pc->Resize( pc, FALSE );
}
//---------------------------------------------------------------------------
PSI_PROC( void, SizeCommonRel )( PSI_CONTROL pc, uint32_t w, uint32_t h )
{
	SizeCommon( pc, w + pc->rect.width, h + pc->rect.height );
}
//---------------------------------------------------------------------------
void InvokePosChange( PSI_CONTROL pc, LOGICAL updating )
{
	void (CPROC *OnChanging)(PSI_CONTROL,LOGICAL);
	PCLASSROOT data = NULL;
	PCLASSROOT event_root = GetClassRootEx( pc->class_root, "position_changing" );
	CTEXTSTR name;
	for( name = GetFirstRegisteredName( event_root, &data );
		  name;
		  name = GetNextRegisteredName( &data ) )
	{
		OnChanging = GetRegisteredProcedureExx((PCLASSROOT)data,(CTEXTSTR)NULL,void,name,(PSI_CONTROL,LOGICAL));
		if( OnChanging )
		{
			OnChanging( pc, updating );
		}
	}
}
void InvokeMotionChange( PSI_CONTROL pc, LOGICAL updating )
{
	void (CPROC *OnChanging)(PSI_CONTROL,LOGICAL);
	PCLASSROOT data = NULL;
	PCLASSROOT event_root = GetClassRootEx( pc->class_root, "some_parents_position_changing" );
	CTEXTSTR name;
	for( name = GetFirstRegisteredName( event_root, &data );
		  name;
		  name = GetNextRegisteredName( &data ) )
	{
		OnChanging = GetRegisteredProcedureExx((PCLASSROOT)data,(CTEXTSTR)NULL,void,name,(PSI_CONTROL,LOGICAL));
		if( OnChanging )
		{
			OnChanging( pc, updating );
		}
	}
}
PSI_PROC( void, MoveCommon )( PSI_CONTROL pc, int32_t x, int32_t y )
{
	if( pc )
	{
		PPHYSICAL_DEVICE pf = pc->device;
		InvokePosChange( pc, TRUE );
		{
			PFRACTION ix, iy;
			GetCommonScale( pc, &ix, &iy );
			pc->original_rect.x = InverseScaleValue( ix, x );
			pc->original_rect.y = InverseScaleValue( iy, y );
		}
		pc->rect.x = x;
		pc->rect.y = y;
		if( pf )
		{
			MoveDisplay( pf->pActImg, x, y );
		}
		else
		{
			IMAGE_RECTANGLE old;
			PPHYSICAL_DEVICE pFrame = GetFrame(pc)->device;
			//ValidatedControlData( PFRAME, CONTROL_FRAME, pFrame, GetFrame( pc ) );
			PEDIT_STATE pEditState;
			old = pc->rect;
			if( pFrame )
			{
				pEditState = &pFrame->EditState;
				if( pEditState->flags.bActive &&
					pEditState->pCurrent == pc )
				{
					old.x -= SPOT_SIZE;
					old.y -= SPOT_SIZE;
					old.width += 2*SPOT_SIZE;
					old.height += 2*SPOT_SIZE;
				}
			}
			else
				pEditState = NULL;
			if( pc->Window )
				MoveImage( pc->Window, x, y );
			if( pEditState&& pEditState->flags.bActive &&
				pEditState->pCurrent == pc )
			{
				SetupHotSpots( pEditState );
				SmudgeCommon( pFrame->common );
			}
		}
		InvokePosChange( pc, FALSE );
	}
}
//---------------------------------------------------------------------------
void ScaleCoords( PSI_CONTROL pc, int32_t* a, int32_t* b )
{
	while( pc && !pc->flags.bScaled )
		pc = pc->parent;
	if( pc )
	{
#ifdef DEBUG_SCALING
		//if( 0 )
		{
			TEXTCHAR tmp[256];
			sLogFraction( tmp, &pc->scalex );
			lprintf( "%p(%s) X is %s", pc, pc->pTypeName, tmp );
			sLogFraction( tmp, &pc->scaley );
			lprintf( "%p(%s) Y is %s", pc, pc->pTypeName, tmp );
		}
#endif
		if( a )
			*a = ScaleValue( &pc->scalex, *a );
		if( b )
			*b = ScaleValue( &pc->scaley, *b );
	}
}
//---------------------------------------------------------------------------
void ApplyRescaleChild( PSI_CONTROL pc, PFRACTION scalex, PFRACTION scaley )
{
	pc = pc->child;
	while( pc )
	{
		//if( 0 )
#ifdef DEBUG_SCALING
		{
			TEXTCHAR tmp[32];
			TEXTCHAR tmp2[32];
			sLogFraction( tmp, scalex );
			sLogFraction( tmp2, scaley );
			lprintf( "updating scaled value %p(%s), X is %s Y is %s", pc, pc->pTypeName, tmp, tmp2 );
		}
#endif
		// if it has no children yet, then resize it according to the new scale...
		if( !(pc->BorderType & BORDER_FIXED) )
		{
			MoveSizeCommon( pc
							  , ScaleValue( scalex, pc->original_rect.x )
							  , ScaleValue( scaley, pc->original_rect.y )
							  , ScaleValue( scalex, pc->original_rect.width )
							  , ScaleValue( scaley, pc->original_rect.height )
							  );
			if( pc && pc->Rescale )
				pc->Rescale( pc );
		}
		// if this has a font, it's children are scaled according to
		// their parent...
		if( !pc->flags.bScaled )
			ApplyRescaleChild( pc, scalex, scaley );
		pc = pc->next;
	}
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
void ApplyRescale( PSI_CONTROL pc )
{
	//while( pc && !pc->flags.bScaled )
	//	pc = pc->parent;
	if( pc && pc->flags.bScaled )
	{
		//if( 0 )
#ifdef DEBUG_SCALING
		{
			TEXTCHAR tmp[256];
			lprintf( "Updating scaled value ...." );
			sLogFraction( tmp, &pc->scalex );
			lprintf( "X is %s", tmp );
			sLogFraction( tmp, &pc->scaley );
			lprintf( "Y is %s", tmp );
		}
#endif
		SizeCommon( pc
						  //, ScaleValue( &pc->scalex, pc->original_rect.x )
						  //, ScaleValue( &pc->scaley, pc->original_rect.y )
						  , ScaleValue( &pc->scalex, pc->original_rect.width )
						  , ScaleValue( &pc->scaley, pc->original_rect.height )
						  );
		if( pc && pc->Rescale )
			pc->Rescale( pc );
		ApplyRescaleChild( pc, &pc->scalex, &pc->scaley );
	}
}
//---------------------------------------------------------------------------
void GetCommonScale( PSI_CONTROL pc, PFRACTION *sx, PFRACTION *sy ) {
	while( pc && !pc->flags.bScaled )
		pc = pc->parent;
	if( pc ) {
		( *sx ) = &pc->scalex;
		( *sy ) = &pc->scaley;
	} else {
		static FRACTION one = { 1,1 };
		( *sx ) = &one;
		( *sy ) = &one;
	}
}
//---------------------------------------------------------------------------
void SetCommonScale( PSI_CONTROL pc, PFRACTION sx, PFRACTION sy )
{
	//if( 0 )
#ifdef DEBUG_SCALING
	{
		TEXTCHAR tmp[256];
		lprintf( "Updating scaled value ...." );
		sLogFraction( tmp, &pc->scalex );
		lprintf( "X is %s", tmp );
		sLogFraction( tmp, &pc->scaley );
		lprintf( "Y is %s", tmp );
	}
#endif
	if( sx )
		pc->scalex = *sx;
	if( sy )
		pc->scaley = *sy;
	if( sx || sy )
		pc->flags.bScaled = 1;
	else
		pc->flags.bScaled = 0;
	SetCommonBorder( pc, pc->BorderType );
	if( pc && pc->Rescale )
		pc->Rescale( pc );
	ApplyRescaleChild( pc, sx, sy );
}
//---------------------------------------------------------------------------
static void DispatchFontChange( PSI_CONTROL pc ) {
	while( pc ) {
		if( pc->FontChange )
			pc->FontChange( pc );
		DispatchFontChange( pc->child );
		pc = pc->next;
	}
}
//---------------------------------------------------------------------------
void SetCommonFont( PSI_CONTROL pc, SFTFont font )
{
	if( pc )
	{
		uint32_t w, h;
		uint32_t _w, _h;
#ifdef DEBUG_SCALING
		//if( 0 )
		{
			TEXTCHAR tmp[32];
			TEXTCHAR tmp2[32];
			sLogFraction( tmp, &pc->scalex );
			sLogFraction( tmp2, &pc->scaley );
			lprintf( "Updating scaled value .... %p  %p(%s)  X is %s  Y is %s", font, pc, pc->pTypeName, tmp, tmp2 );
		}
#endif
		// pc->font - prior state before we update it... evyerhting
		// gets rescaled by the new factor...
		// progressive updates will end up with lots of error...
		pc->caption.font = font;
		GetFontRenderData( font, &pc->caption.fontdata, &pc->caption.fontdatalen );
		if( !(pc->BorderType & BORDER_FIXED) )
		{
/*pc->caption.font*/
			GetStringSizeFont( "XXXXX", &_w, &_h, NULL );
			GetStringSizeFont( "XXXXX", &w, &h, font );
			if(h == 0 )
			{
				h = 10;
				//DebugBreak();
			}
			if( w != _w || h != _h )
			{
				//lprintf( "Font is %d/%d,%d/%d", w, _w, h, _h );
				SetFraction( pc->scalex,w,_w);
				SetFraction( pc->scaley,h,_h);
				pc->flags.bScaled = 1;
			}
			else
			{
				SetFraction( pc->scalex,w,_w);
				SetFraction( pc->scaley,h,_h);
				//pc->flags.bScaled = 0;
			}
#ifdef DEBUG_SCALING
			//if( 0 )
			{
				TEXTCHAR tmp[32];
				TEXTCHAR tmp2[32];
				sLogFraction( tmp, &pc->scalex );
				sLogFraction( tmp2, &pc->scaley );
				lprintf( "Updated scaled value .... %p(%s) X is %s  Y is %s", pc, pc->pTypeName, tmp, tmp2 );
			}
#endif
			if( !pc->flags.bInitial && !pc->flags.bNoUpdate )
				SetCommonBorder( pc, pc->BorderType );
			ApplyRescale( pc );
		}
		//else
		//	lprintf( "not setting scaling..." );
		if( !pc->flags.bCreating )
		{
			if( pc->FontChange )
				pc->FontChange( pc );
			DispatchFontChange( pc->child );
		}
		if( !g.flags.always_draw )
		{
			if( !pc->flags.bInitial && !pc->flags.bNoUpdate )
				SmudgeCommon( pc );
		}
	}
}
//---------------------------------------------------------------------------
SFTFont GetCommonFontEx( PSI_CONTROL pc DBG_PASS )
{
	//_xlprintf(1 DBG_RELAY )( "Someone getting font from %p", pc );
	while( pc )
	{
		// lprintf( "Checking control %p for font %p", pc, pc->caption.font );
		if( pc->caption.font )
			return pc->caption.font;
 // devices end parent relation also... we maintain (for some reason) parent link to parent control....
		if( pc->device )
			break;
		pc = pc->parent;
	}
	//lprintf( "No control, no font." );
	// results in DefaultFont() when used anyhow...
	return NULL;
}
//---------------------------------------------------------------------------
PSI_PROC( void, MoveCommonRel )( PSI_CONTROL pc, int32_t x, int32_t y )
{
   MoveFrame( pc, x + pc->rect.x, y + pc->rect.y );
}
//---------------------------------------------------------------------------
PSI_PROC( void, MoveSizeCommon )( PSI_CONTROL pc, int32_t x, int32_t y, uint32_t width, uint32_t height )
{
	if( pc )
	{
		PPHYSICAL_DEVICE pf = pc->device;
		PEDIT_STATE pEditState = pf?&pf->EditState:NULL;
		IMAGE_RECTANGLE old;
		// timestamp these...
		//lprintf( "move %p %d,%d %d,%d", pc, x, y, width, height );
		if( !pc )
			return;
		/*
		{
			PSI_CONTROL pf = GetParentControl( pc );
			if( pf && !(pc->BorderType & BORDER_FIXED))
			{
				x = ScaleValue( &pf->scalex, x );
				y = ScaleValue( &pf->scaley, y );
				width = ScaleValue( &pf->scalex, width );
				height = ScaleValue( &pf->scaley, height );
			}
		}
		*/
		if( pf )
		{
			InvokePosChange( pc, TRUE );
			MoveSizeDisplay( pf->pActImg, x, y, width, height );
		}
		// lock out auto updates...
		if( pf )
			pf->flags.bNoUpdate = TRUE;
		old = pc->rect;
		if( pf && pEditState->flags.bActive &&
			pEditState->pCurrent == pc )
		{
			old.x -= SPOT_SIZE;
			old.y -= SPOT_SIZE;
			old.width += 2*SPOT_SIZE;
			old.height += 2*SPOT_SIZE;
		}
		MoveCommon( pc, x, y );
		SizeCommon( pc, width, height );
		if( pf )
		{
			pf->flags.bNoUpdate = FALSE;
		}
		InvokePosChange( pc, FALSE );
	}
}
//---------------------------------------------------------------------------
PSI_PROC( void, MoveSizeCommonRel )( PSI_CONTROL pc, int32_t x, int32_t y, uint32_t width, uint32_t height )
{
    MoveSizeFrame( pc
                     , pc->rect.x + x
                     , pc->rect.y + y
                     , pc->rect.width + width
                     , pc->rect.height + height );
}
//---------------------------------------------------------------------------
#undef GetControl
PSI_PROC( PSI_CONTROL, GetControl )( PSI_CONTROL pContainer, int ID )
{
	PSI_CONTROL pc;
	if( !pContainer )
	   return NULL;
	pc = pContainer->child;
	while( pc )
	{
		if( !pc->flags.bHidden && pc->nID == ID )
			return pc;
		pc = pc->next;
	}
	return pc;
}
//---------------------------------------------------------------------------
#undef GetControl
PSI_PROC( PSI_CONTROL, GetControlByName )( PSI_CONTROL pContainer, const char *ID ) {
	PSI_CONTROL pc;
	if( !pContainer )
		return NULL;
	pc = pContainer->child;
	while( pc ) {
		if( pc->pIDName && ( strcmp( pc->pIDName, ID ) == 0 ) )
			return pc;
		pc = pc->next;
	}
	{
		pc = pContainer->child;
		while( pc ) {
			PSI_CONTROL result = GetControlByName( pc, ID );
			if( result )
				return result;
			pc = pc->next;
		}
	}
	return pc;
}
//---------------------------------------------------------------------------
PSI_PROC( void, EnableCommonUpdates )( PSI_CONTROL common, int bEnable )
{
	if( common )
	{
		while( common->flags.bDirectUpdating )
			Relinquish();
		if( common->flags.bNoUpdate && bEnable )
		{
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				lprintf( "Enable Common Updates on %p", common );
#endif
			common->flags.bNoUpdate = FALSE;
			// probably doing mass updates so just mark the status, and make the application draw.
		}
		else
		{
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				lprintf( "Disable Common Updates on %p", common );
#endif
			common->flags.bNoUpdate = !bEnable;
		}
	}
}
//---------------------------------------------------------------------------
PSI_PROC( PSI_CONTROL, GetNearControl )( PSI_CONTROL pc, int ID )
{
	PSI_CONTROL parent = pc->parent?pc->parent:pc;
 // parent itself is also a 'near' control
	if( parent->nID == ID )
		return parent;
	return GetControl( parent, ID );
}
//---------------------------------------------------------------------------
void GetCommonTextEx( PSI_CONTROL pc, TEXTSTR buffer, int buflen, int bCString )
{
	if( !buffer || !buflen )
		return;
	if( !pc )
	{
		if( buffer && buflen )
			buffer[0] = 0;
		return;
	}
	if( !pc->caption.text )
	{
		buffer[0] = 0;
		return;
	}
	StrCpyEx( buffer, GetText( pc->caption.text ), buflen );
	//lprintf( "GetText was %d", buflen );
 // make sure we nul terminate..
	buffer[buflen-1] = 0;
 // use C processing on escapes....
	if( bCString )
	{
		int n, ofs, escape = 0;
		ofs = 0;
		//lprintf( "GetText was %d", buflen );
		for( n = 0; buffer[n]; n++ )
		{
			if( escape )
			{
				switch( buffer[n] )
				{
				case 'n':
					buffer[n-ofs] = '\n';
					break;
				case 't':
					buffer[n-ofs] = '\t';
					break;
				case '\\':
					buffer[n-ofs] = '\\';
					break;
				default:
					ofs++;
					break;
				}
				escape = FALSE;
				continue;
			}
			if( buffer[n] == '\\' )
			{
				escape = TRUE;
				ofs++;
				continue;
			}
			buffer[n-ofs] = buffer[n];
		}
		buffer[n-ofs] = 0;
	}
}
//---------------------------------------------------------------------------
PSI_PROC( LOGICAL, IsControlHidden )( PSI_CONTROL pc )
{
	PSI_CONTROL parent;
	for( parent = pc; parent; parent = parent->parent )
	{
		if( parent->flags.bNoUpdate || parent->flags.bHidden )
			return TRUE;
	}
	return FALSE;
}
PSI_PROC( Image,  GetControlSurface )( PSI_CONTROL pc )
{
	if( pc )
	{
		return pc->Surface;
	}
	return NULL;
}
//---------------------------------------------------------------------------
PSI_PROC( void, SetControlCaptionImage )( PSI_CONTROL pc, Image image, int pad )
{
	if( pc )
	{
		pc->caption.image = image;
		pc->caption.pad = pad;
		SmudgeCommon( pc );
	}
}
PSI_PROC( void, SetControlText )( PSI_CONTROL pc, CTEXTSTR text )
{
	if( !pc )
		return;
	if( pc->caption.text )
	{
		PTEXT old = pc->caption.text;
		if( text && TextIs( old, text ) )
			return;
		pc->caption.text = NULL;
		LineRelease( old );
	}
	if( text )
	{
		pc->caption.text = SegCreateFromText( text );
	}
	else
		pc->caption.text = NULL;
	if( pc->CaptionChanged )
	{
		//lprintf( "invoke caption changed... " );
		pc->CaptionChanged( pc );
	}
	if( pc->device && pc->device->pActImg )
		SetRendererTitle( pc->device->pActImg, text );
	//else
	// we can use setcontrol text within a smudge condition...  so don't smudge again
	if( !g.flags.always_draw )
	{
		if( !pc->flags.bInitial && !pc->flags.bCleaning )
			SmudgeCommon( pc );
	}
}
//---------------------------------------------------------------------------
void EnableControl( PSI_CONTROL pc, int bEnable )
{
	if( pc )
	{
		pc->flags.bDisable = !bEnable;
		//FixFrameFocus( GetFrame( pc ), FFF_HERE );
		//lprintf( "Control draw %p", pc );
		SmudgeCommon( pc );
	}
}
//---------------------------------------------------------------------------
int IsControlEnabled( PSI_CONTROL pc )
{
	return !pc->flags.bDisable;
}
//---------------------------------------------------------------------------
void LinkInNewControl( PSI_CONTROL parent, PSI_CONTROL elder, PSI_CONTROL child )
{
	PSI_CONTROL pAdd;
	if( parent && child )
	{
		if( elder )
		{
			child->next = elder;
			if( !( child->prior = elder->prior ) )
				parent->child = child;
				elder->prior = child;
		}
		else
		{
			pAdd = parent->child;
			if( pAdd == child )
 // already linked.
				return;
			while( pAdd && pAdd->next )
			{
				if( pAdd == child )
 // already linked.
					return;
					//lprintf( "skipping %p...", pAdd );
				pAdd = pAdd->next;
			}
			if( !pAdd )
			{
				//lprintf( "Adding control first..." );
				child->prior = NULL;
				parent->child = child;
			}
			else
			{
				//lprintf( "Adding control after last..." );
				child->prior = pAdd;
				pAdd->next = child;
			}
			child->next = NULL;
		}
		child->parent = parent;
	}
}
//---------------------------------------------------------------------------
void GetControlSize( PSI_CONTROL _pc, uint32_t* w, uint32_t* h )
{
	if( _pc )
	{
		if( w )
			*w = _pc->original_rect.width;
		if( h )
			*h = _pc->original_rect.height;
	}
}
//---------------------------------------------------------------------------
PSI_CONTROL CreateCommonExxx( PSI_CONTROL pContainer
								 // if not typename, must pass type ID...
								, CTEXTSTR pTypeName
								, uint32_t nType
								 // position of control
								, int x, int y
								, int w, int h
								, uint32_t nID
 // if this is NOT NULL, use Named ID to ID the control.
								, CTEXTSTR pIDName
								// ALL controls have a caption...
							  , CTEXTSTR text
								// fields in this override the defaults...
								// if not 0.
							  , uint32_t ExtraBorderType
								// if this is reloaded...
							  , PTEXT parameters
                        , POINTER extra_param
								//, va_list args
								DBG_PASS )
{
	PSI_CONTROL pResult;
	PROCEDURE proc;
	proc = RealCreateCommonExx( &pResult, pContainer, pTypeName, nType, x, y, w, h, nID, pIDName, text
									  , ExtraBorderType
										// uhmm need to retain this ... as it also means 'private' as in contained
                              // within a control - editing functions should not operate on these either...
										//& ~( BORDER_NO_EXTRA_INIT )  // mask fake border bits to prevent confusion
									  , TRUE DBG_RELAY );
	if( proc )
	{
		if( !((int(CPROC *)(PSI_CONTROL))proc)( pResult ) )
		{
			_xlprintf(1 DBG_RELAY )( "Failed to init the control - destroying it." );
			DestroyCommon( &pResult );
		}
		else
		{
			if( pResult->BorderType & BORDER_CAPTION_CLOSE_BUTTON )
				AddCaptionButton( pResult, NULL, NULL, NULL, 0, NULL );
		}
	}
	pResult->flags.bCreating = 0;
 // no point in doing anything extra if the initial init fails.
	if( pResult )
	{
		TEXTCHAR mydef[256];
		if( pTypeName )
			tnprintf( mydef, sizeof( mydef ), PSI_ROOT_REGISTRY "/control/%s/rtti/extra init", pTypeName );
		else
			tnprintf( mydef, sizeof( mydef ), PSI_ROOT_REGISTRY "/control/%" _32f "/rtti/extra init", nType );
		if( !(ExtraBorderType & BORDER_NO_EXTRA_INIT ) )
		{
			int (CPROC *CustomInit)(PSI_CONTROL);
			CTEXTSTR name;
			PCLASSROOT data = NULL;
			pResult->flags.private_control = 0;
			{
				int (CPROC *CustomInit)(PSI_CONTROL);
				// dispatch for a common proc that is registered to handle extra init for
				// any control...
				for( name = GetFirstRegisteredName( "psi/control/rtti/extra init", &data );
						name;
						name = GetNextRegisteredName( &data ) )
				{
					CustomInit = GetRegisteredProcedureExx((PCLASSROOT)data,(CTEXTSTR)NULL,int,name,(PSI_CONTROL));
					if( CustomInit )
					{
						if( !CustomInit( pResult ) )
						{
							lprintf( "extra init has returned failure... so what?" );
						}
					}
				}
			}
			// then here lookup the specific control type's extra init proc...
			for( name = GetFirstRegisteredName( mydef, &data );
					name;
					name = GetNextRegisteredName( &data ) )
			{
				CustomInit = GetRegisteredProcedureExx((PCLASSROOT)data,(CTEXTSTR)NULL,int,name,(PSI_CONTROL));
				if( CustomInit )
				{
					if( !CustomInit( pResult ) )
					{
						lprintf( "extra init has returned failure... so what?" );
					}
				}
			}
		}
		else
		{
			pResult->flags.private_control = 1;
		}
	}
	if( pContainer && pContainer->AddedControl )
		pContainer->AddedControl( pContainer, pResult );
	if( pContainer )
	{
		// creation could have caused it to be hidden...
		pResult->flags.bInitial = pContainer->flags.bInitial;
		if( !pResult->flags.bHiddenParent && !pResult->flags.bInitial )
		{
			pResult->flags.bHidden = pContainer->flags.bHidden;
			// same thing as DeleteUse would do
			UpdateCommon( pResult );
		}
	}
	return pResult;
}
PSI_CONTROL MakeControl( PSI_CONTROL pFrame
					, uint32_t nType
					, int x, int y
					, int w, int h
					, uint32_t nID
					//, ...
					)
{
	return CreateCommonExx( pFrame, NULL, nType, x, y, w, h, nID, NULL, 0, NULL, NULL DBG_SRC );
}
PSI_CONTROL MakeControlParam( PSI_CONTROL pFrame
								, uint32_t nType
								, int x, int y
								, int w, int h
								, uint32_t nID
								, POINTER parameter
								)
{
	return CreateCommonExx( pFrame, NULL, nType, x, y, w, h, nID, NULL, 0, NULL, parameter DBG_SRC );
}
PSI_CONTROL MakePrivateControl( PSI_CONTROL pFrame
								  , uint32_t nType
								  , int x, int y
								  , int w, int h
								  , uint32_t nID
								  )
{
	return CreateCommonExx( pFrame, NULL, nType
								 , x, y
								 , w, h
								 , nID, NULL
								 , BORDER_NO_EXTRA_INIT|BORDER_FIXED
								 , NULL, NULL DBG_SRC );
}
PSI_CONTROL MakePrivateNamedControl( PSI_CONTROL pFrame
								  , CTEXTSTR pType
								  , int x, int y
								  , int w, int h
								  , uint32_t nID
								   )
{
	return CreateCommonExx( pFrame, pType, 0
								 , x, y
								 , w, h
								 , nID, NULL
								 , BORDER_NO_EXTRA_INIT
								 , NULL, NULL DBG_SRC );
}
PSI_CONTROL MakeCaptionedControl( PSI_CONTROL pFrame
									 , uint32_t nType
									 , int x, int y
									 , int w, int h
									 , uint32_t nID
									 , CTEXTSTR caption
									 //, ...
									 )
{
	return CreateCommonExx( pFrame, NULL, nType, x, y, w, h, nID, caption, 0, NULL, NULL DBG_SRC );
}
PSI_PROC( PSI_CONTROL, MakeNamedCaptionedControlByName )( PSI_CONTROL pContainer
																		  , CTEXTSTR pType
																		  , int x, int y
																		  , int w, int h
																		  , CTEXTSTR pIDName
																		  , uint32_t nID
																		  , CTEXTSTR caption
																		  )
{
	return CreateCommonExxx( pContainer, pType, 0, x, y, w, h, nID, pIDName, caption, 0, NULL, NULL DBG_SRC );
}
PSI_PROC( PSI_CONTROL, MakeNamedCaptionedControl )( PSI_CONTROL pContainer
															 , CTEXTSTR pType
															 , int x, int y
															 , int w, int h
															 , uint32_t nID
															 , CTEXTSTR caption
															 )
{
	return CreateCommonExx( pContainer, pType, 0, x, y, w, h, nID, caption, 0, NULL, NULL DBG_SRC );
}
PSI_CONTROL VMakeCaptionedControl( PSI_CONTROL pFrame
									 , uint32_t nType
									 , int x, int y
									 , int w, int h
									 , uint32_t nID
									 , CTEXTSTR caption
									  //, va_list args
									  )
{
	return CreateCommonExx( pFrame, NULL, nType, x, y, w, h, nID, caption, 0, NULL, NULL DBG_SRC );
}
PSI_CONTROL MakeNamedControl( PSI_CONTROL pFrame
                    , CTEXTSTR pType
						  , int x, int y
						  , int w, int h
						  , uint32_t nID
								//, ...
								)
{
	//va_list args;
   //va_start( args, nID );
   return CreateCommonExx( pFrame, pType, 0, x, y, w, h, nID, NULL, 0, NULL, NULL DBG_SRC );
}
PSI_CONTROL VMakeControl( PSI_CONTROL pFrame
                        , uint32_t nType
                        , int x, int y
                        , int w, int h
                        , uint32_t nID
                        )
{
   return CreateCommonExx( pFrame, NULL, nType, x, y, w, h, nID, NULL, 0, NULL, NULL DBG_SRC );
}
PSI_CONTROL RestoreControl( PSI_CONTROL pFrame
                          , uint32_t nType
                          , int x, int y
                          , int w, int h
                          , uint32_t nID
                          , PTEXT parameters )
{
   return CreateCommonExx( pFrame, NULL, nType, x, y, w, h, nID, NULL, 0, parameters, NULL DBG_SRC );
}
//---------------------------------------------------------------------------
void DestroyCommonExx( PSI_CONTROL *ppc, int level DBG_PASS )
{
	PSI_CONTROL pNext;
	if( ppc && *ppc )
	{
		PSI_CONTROL pc = *ppc;
		// need to get what frame this control is in before unlinking it from the frame!
		PSI_CONTROL pFrame = GetFrame( pc );
		if( pFrame )
		{
			if( pFrame->stack_parent )
				pFrame->stack_parent->stack_child = pFrame->stack_child;
			if( pFrame->stack_child )
				pFrame->stack_child->stack_parent = pFrame->stack_parent;
			pFrame->stack_parent = NULL;
			pFrame->stack_child = NULL;
		}
		if( !pc->flags.bDestroy )
		{
			if( pc->device )
			{
				AddUse( pc );
				DetachFrameFromRenderer( pc );
				DeleteUse( pc );
			}
			pc->flags.bDestroy = 1;
		}
		if( ( pNext = pc->next ) != NULL )
		{
			pc->next->prior = pc->prior;
			pc->next = NULL;
		}
		if( pc->prior )
		{
			pc->prior->next = pNext;
			pc->prior = NULL;
		}
		else if( pc->parent )
		{
			if( pc->parent->device )
				if( pc->parent->device->pFocus == pc )
				{
					pc->parent->device->pFocus = NULL;
					if( !pc->parent->flags.bDestroy )
						FixFrameFocus( pc->parent->device, FFF_FORWARD );
				}
			if( pc->parent->child == pc )
				pc->parent->child = pNext;
			if( !pc->parent->flags.bDestroy )
				SmudgeCommon( pc->parent );
			pc->parent = NULL;
		}
		if( !ChildInUse( pc, 0 ) && !pc->InWait )
		{
			level++;
			AddUse( pc );
			//lprintf( "Destroying control %p", pc );
			while( pc->child )
			{
				//lprintf( "destroying child control %p", pc->child );
				DestroyCommonExx( &pc->child, level DBG_RELAY );
			}
			if( pc->caption.text )
			{
				//lprintf( "Release caption text" );
				LineReleaseEx( pc->caption.text DBG_RELAY );
				pc->caption.text = NULL;
			}
			{
				if( pc->Destroy )
					pc->Destroy( pc );
				{
					int (CPROC *CustomDestroy)(PSI_CONTROL);
					TEXTCHAR mydef[256];
					CTEXTSTR name;
					PCLASSROOT data = NULL;
					tnprintf( mydef, sizeof( mydef ), "psi/control/rtti/extra destroy" );
					for( name = GetFirstRegisteredName( mydef, &data );
						 name;
						  name = GetNextRegisteredName( &data ) )
					{
						CustomDestroy = GetRegisteredProcedureExx((PCLASSROOT)data,(CTEXTSTR)NULL,int,name,(PSI_CONTROL));
						if( CustomDestroy )
						{
							//lprintf( "Invoking custom destroy" );
							if( !CustomDestroy( pc ) )
							{
								//lprintf( "extra destroy has returned failure... so what?" );
							}
						}
					}
					tnprintf( mydef, sizeof( mydef ), PSI_ROOT_REGISTRY "/control/%d/rtti/extra destroy", pc->nType );
					for( name = GetFirstRegisteredName( mydef, &data );
						 name;
						  name = GetNextRegisteredName( &data ) )
					{
						CustomDestroy = GetRegisteredProcedureExx((PCLASSROOT)data,(CTEXTSTR)NULL,int,name,(PSI_CONTROL));
						if( CustomDestroy )
						{
							if( !CustomDestroy( pc ) )
							{
								//lprintf( "extra destroy has returned failure... so what?" );
							}
						}
					}
				}
				Release( ControlData( POINTER, pc ) );
				pc->pUser = NULL;
			}
			if( !pc->device )
			{
				// this may not be destroyed if it's
				// the main frame, and the image is that
				// of the renderer...
				UnmakeImageFile( pc->Window );
			}
			if( pc->Surface )
				UnmakeImageFile( pc->Surface );
			if( pc->pTypeName )
			{
				//Release( pc->pTypeName );
				pc->pTypeName = NULL;
			}
			if( pc->pIDName )
			{
				Release( (POINTER)pc->pIDName );
				pc->pIDName = NULL;
			}
			{
				// get frame results null if it's being destroyed itself.
				// and I need to always clear this if it's able at all to be done.
				//GetFrame( pc );
				if( pFrame )
				{
					PPHYSICAL_DEVICE pf = pFrame->device;
					//ValidatedControlData( PFRAME, CONTROL_FRAME, pf, GetFrame( pc ) );
					if( pf )
					{
						if( pf->pCurrent == pc )
						{
							pf->pCurrent = NULL;
						}
						//else
						//   lprintf( "Current is not %p it is %p", pc, pf->pCurrent );
						if( pf->pFocus == pc )
						{
							pf->pFocus = NULL;
							FixFrameFocus( pf, FFF_FORWARD );
						}
						if( pf->EditState.flags.bActive && pf->EditState.pCurrent == pc )
						{
							pf->EditState.flags.bHotSpotsActive = 0;
							pf->EditState.pCurrent = NULL;
							{
								IMAGE_RECTANGLE upd = pf->EditState.bound;
								upd.x -= SPOT_SIZE;
								upd.y -= SPOT_SIZE;
								lprintf( "update some controls is a edit thing..." );
								SmudgeSomeControls( pf->common, &upd );
							}
						}
					}
					//else
					//   lprintf( "no device which might have a current..." );
				}
				//else
				//   lprintf( "no frame to unmake current" );
			}
 // only thing which may have a commonwait
			if( pc->device )
			{
				PPSI_COMMON_BUTTON_DATA pcbd = &pc->parent->pCommonButtonData;
				if( pcbd )
				{
					if( pcbd->event )
						pcbd->event( pcbd->psv, pc, *pcbd->done_value, *pcbd->okay_value );
					else
						WakeThread( pcbd->thread );
				}
			}
			Release( pc->_DrawThySelf );
			Release( pc->_DrawDecorations );
			Release( pc->_MouseMethod );
			Release( pc->_KeyProc );
			if( pc->OriginalSurface )
				UnmakeImageFile( pc->OriginalSurface );
			Release( pc );
		}
		//UnmakeImageFileEx( pf->Surface DBG_RELAY );
		*ppc = pNext;
		level--;
		if( !level )
			*ppc = NULL;
	}
}
//---------------------------------------------------------------------------
void DestroyCommonEx( PSI_CONTROL *ppc DBG_PASS )
{
	DestroyCommonExx( ppc, 0 DBG_RELAY );
}
//---------------------------------------------------------------------------
PSI_PROC( int, GetControlID )( PSI_CONTROL pc )
{
	if( pc )
		return pc->nID;
	return -1;
}
//---------------------------------------------------------------------------
PSI_PROC( void, SetControlID )( PSI_CONTROL pc, int ID )
{
	if( pc )
	{
		pc->nID = ID;
		if( pc->pIDName )
			Release( (POINTER)pc->pIDName );
		pc->pIDName = GetResourceIDName( pc->pTypeName, ID );
	}
}
//---------------------------------------------------------------------------
PSI_PROC( void, SetControlIDName )( PSI_CONTROL pc, TEXTCHAR *IDName )
{
	if( pc )
	{
		// no ID to default to, so pass -1
		pc->nID = GetResourceID( pc->parent, IDName, -1 );
	}
}
//------------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
static void CPROC ButtonOkay( uintptr_t psv, PSI_CONTROL pc )
{
	PPSI_COMMON_BUTTON_DATA pcbd = pc->parent?&pc->parent->pCommonButtonData:NULL;
	if( pcbd ) {
		{
			int *val = (int*)psv;
			if( val )
				*val = TRUE;
			else
				if( pcbd->done_value )
					( *pcbd->done_value ) = TRUE;
		}
		if( pcbd->event )
			pcbd->event( pcbd->psv, pc, pcbd->done_value?*pcbd->done_value:0, pcbd->okay_value?*pcbd->okay_value:0 );
		else
			if( pcbd->thread )
				WakeThread( pcbd->thread );
	}
}
//---------------------------------------------------------------------------
PSI_PROC( void, InitCommonButton )( PSI_CONTROL pc, int *value )
{
   //ConfigButton( pc, NULL, ButtonOkay, (uintptr_t)value );
}
//---------------------------------------------------------------------------
void SetCommonButtons( PSI_CONTROL pf
                     , int *pdone
                     , int *pokay )
{
	if( pf )
	{
		PPSI_COMMON_BUTTON_DATA pcbd;
		SetButtonPushMethod( GetControl( pf, BTN_ABORT ), ButtonOkay, (uintptr_t)NULL );
		pcbd = &pf->pCommonButtonData;
		if( !pcbd->okay_value ) {
			PSI_CONTROL pc = GetControl( pf, BTN_OKAY );
			if( pc ) {
				SetButtonPushMethod( pc, ButtonOkay, (uintptr_t)pokay );
				pcbd->okay_value = pokay;
			}
		}
		if( !pcbd->done_value ) {
			PSI_CONTROL pc = GetControl( pf, BTN_CANCEL );
			if( pc ) {
				SetButtonPushMethod( pc, ButtonOkay, (uintptr_t)pdone );
				pcbd->done_value = pdone;
			}
		}
	}
}
void AddCommonButtonsEx( PSI_CONTROL pf
                       , int *done, CTEXTSTR donetext
                       , int *okay, CTEXTSTR okaytext )
{
	if( pf )
	{
		// scaled!
//FrameBorderX( pf->BorderType );
		int w = pf->rect.width;
//FrameBorderY( pf, pf->BorderType, NULL );
		int h = pf->rect.height;
		PPSI_COMMON_BUTTON_DATA pcbd;
		PSI_CONTROL pc;
		int x, x2;
		int y;
		//  lprintf( "Buttons will be added at... %d, %d"
		//		   , w //pf->surface_rect.width - FrameBorderX( pf->BorderType )
		//		   , h //pf->surface_rect.height - FrameBorderY( pf, pf->BorderType, NULL )
		//		  );
		if( done && okay )
		{
			x = w - ( 2*COMMON_BUTTON_PAD + ScaleValue( &pf->scalex, (COMMON_BUTTON_WIDTH+COMMON_BUTTON_WIDTH) ) );
			x2 = x + ( ScaleValue( &pf->scalex, COMMON_BUTTON_WIDTH  ) + COMMON_BUTTON_PAD );
		}
		else if( (done&&donetext) || (okay&& okaytext) )
		{
			x = w - ( ScaleValue( &pf->scalex, (COMMON_BUTTON_WIDTH) ) + COMMON_BUTTON_PAD );
			x2 = x;
		}
		else
			return;
		y = h - ( COMMON_BUTTON_PAD + ScaleValue( &pf->scaley, COMMON_BUTTON_HEIGHT ) );
		x = InverseScaleValue( &pf->scalex, x );
		x2 = InverseScaleValue( &pf->scalex, x2 );
		y = InverseScaleValue( &pf->scaley, y );
		pcbd = &pf->pCommonButtonData;
		pcbd->okay_value = okay;
		pcbd->done_value = done;
		pcbd->thread = 0;
		if( okay && okaytext )
		{
			pc = MakeButton( pf
								, x, y
								, COMMON_BUTTON_WIDTH, COMMON_BUTTON_HEIGHT
								, BTN_OKAY, okaytext, 0, ButtonOkay, (uintptr_t)okay );
			//SetCommonUserData( pc, (uintptr_t)pcbd );
		}
		if( done && donetext )
		{
			pc = MakeButton( pf
						  , x2, y
						  , COMMON_BUTTON_WIDTH, COMMON_BUTTON_HEIGHT
						  , BTN_CANCEL, donetext, 0, ButtonOkay, (uintptr_t)done );
			//SetCommonUserData( pc, (uintptr_t)pcbd );
		}
	}
}
//---------------------------------------------------------------------------
void AddCommonButtons( PSI_CONTROL pf, int *done, int *okay )
{
	AddCommonButtonsEx( pf, done, "Cancel", okay, "OK" );
}
//---------------------------------------------------------------------------
_MOUSE_NAMESPACE
PSI_PROC( int, InvokeDefaultButton )( PSI_CONTROL pcNear, int bCancel )
{
	PSI_CONTROL pcf = GetFrame( pcNear );
	if( pcf )
	{
		PPHYSICAL_DEVICE pf = pcf->device;
		//ValidatedControlData( PFRAME, CONTROL_FRAME, pf, pcf );
		PSI_CONTROL pc;
		if( !pf )
			return 0;
		if( bCancel )
			pc = GetControl( pcf, pf->nIDDefaultCancel );
		else
			pc = GetControl( pcf, pf->nIDDefaultOK );
		if( pc )
		{
			//extern void InvokeButton( PSI_CONTROL );
			InvokeButton( pc );
			return 1;
		}
	}
	return 0;
}
int InvokeDefault( PSI_CONTROL pc, int type )
{
	return InvokeDefaultButton( pc, type );
}
_MOUSE_NAMESPACE_END
//---------------------------------------------------------------------------
void SetNoFocus( PSI_CONTROL pc )
{
	if( pc )
		pc->flags.bNoFocus = TRUE;
}
//---------------------------------------------------------------------------
void *ControlExtraData( PSI_CONTROL pc )
{
	return (void*)(pc+1);
}
//---------------------------------------------------------------------------
#undef GetFrame
// get top level frame... the root of all frames.
PSI_PROC( PSI_CONTROL, GetFrame )( PSI_CONTROL pc )
//#define GetFrame(c) GetFrame((PSI_CONTROL)c)
{
	while( pc )
	{
		if( ( !pc->parent || (pc->device) || (!pc->Window->pParent) ) && !pc->flags.bDestroy )
			return pc;
		pc = pc->parent;
	}
	return NULL;
}
//---------------------------------------------------------------------------
#undef GetCommonParent
// this should ge depricated; for bad syntax
PSI_CONTROL GetCommonParent( PSI_CONTROL pc )
{
	if( pc )
		return pc->parent;
	return NULL;
}
//---------------------------------------------------------------------------
PSI_CONTROL GetParentControl( PSI_CONTROL pc )
{
	if( pc )
		return pc->parent;
	return NULL;
}
//---------------------------------------------------------------------------
PSI_CONTROL GetFirstChildControl( PSI_CONTROL pc )
{
	if( pc )
		return pc->child;
	return NULL;
}
//---------------------------------------------------------------------------
PSI_CONTROL GetNextControl( PSI_CONTROL pc )
{
	if( pc )
		return pc->next;
	return NULL;
}
//---------------------------------------------------------------------------
PSI_PROC( void, ProcessControlMessages )( void )
{
	Idle();
}
//---------------------------------------------------------------------------
#undef CommonLoop
PSI_PROC( void, CommonLoop )( int *done, int *okay )
{
	lprintf( "COMMON LOOP IS DEPRECATED, PLEASE UPDATE TO ASYNC METHODS" );
	PPSI_COMMON_BUTTON_DATA pcbd;
	//AddWait( pc );
	pcbd = New( PSI_COMMON_BUTTON_DATA );
	pcbd->okay_value = okay;
	pcbd->done_value = done;
	pcbd->thread = MakeThread();
	pcbd->flags.bWaitOnEdit = 0;
 //!pc->flags.bDestroy
	while(
			!( ( pcbd->okay_value )?( *pcbd->okay_value ):0 )
			&& !( ( pcbd->done_value )?( *pcbd->done_value ):0 )
		  )
		if( !Idle() )
		{
			// this is a legtitimate condition, that does not fail.
			//lprintf( "Sleeping forever, cause I'm not doing anything else..." );
			WakeableSleep( SLEEP_FOREVER );
		}
	pcbd->thread = NULL;
}
//---------------------------------------------------------------------------
 // a frame in edit mode, once edit mode done, continue
PSI_PROC( void, CommonWaitEndEdit)( PSI_CONTROL *pf )
{
	lprintf( "COMMON LOOP IS DEPRECATED, PLEASE UPDATE TO ASYNC METHODS" );
	PPSI_COMMON_BUTTON_DATA pcbd;
	AddWait( (*pf) );
	pcbd = &(*pf)->pCommonButtonData;
	pcbd->thread = MakeThread();
	pcbd->flags.bWaitOnEdit = 1;
	while( !(*pf)->flags.bDestroy
			&& ( pcbd->flags.bWaitOnEdit )
		  )
		if( !Idle() )
		{
			//lprintf( "Sleeping forever, cause I'm not doing anything else..>" );
			WakeableSleep( SLEEP_FOREVER );
		}
	pcbd->thread = NULL;
	DeleteWaitEx( pf DBG_SRC );
}
 // perhaps give a callback for within the loop?
PSI_PROC( void, PSI_HandleStatusEvent )( PSI_CONTROL pc, void (*f)( uintptr_t psv, PSI_CONTROL pc, int done, int okay ), uintptr_t psv ) {
	PPSI_COMMON_BUTTON_DATA pcbd;
	AddWait( pc );
	pcbd = &pc->pCommonButtonData;
	pcbd->thread = MakeThread();
	pcbd->flags.bWaitOnEdit = 0;
	pcbd->event = f;
   pcbd->psv = psv;
	pcbd->thread = NULL;
}
 // perhaps give a callback for within the loop?
PSI_PROC( void, CommonWait)( PSI_CONTROL pc )
{
	lprintf( "COMMON LOOP IS DEPRECATED, PLEASE UPDATE TO ASYNC METHODS" );
	if( pc )
	{
		PPSI_COMMON_BUTTON_DATA pcbd;
		AddWait( pc );
		pcbd = &pc->pCommonButtonData;
		pcbd->thread = MakeThread();
		pcbd->flags.bWaitOnEdit = 0;
		while( !pc->flags.bDestroy
				&& !( ( pcbd->okay_value )?( *pcbd->okay_value ):0 )
				&& !( ( pcbd->done_value )?( *pcbd->done_value ):0 )
			  )
		{
			//lprintf( "not done..." );
			if( !Idle() )
			{
				//lprintf( "Sleeping forever, cause I'm not doing anything else..." );
				WakeableSleep( SLEEP_FOREVER );
			}
			else
			{
				// is thread, did a relinq... but it's UI so we can sleep a little
				WakeableSleep( 25 );
			}
		}
		pcbd->thread = NULL;
		DeleteWait( pc );
	}
}
//---------------------------------------------------------------------------
PSI_PROC( void, OrphanCommonEx )( PSI_CONTROL pc, LOGICAL bDraw )
{
	// Removes the control from relation with it's parent...
	PSI_CONTROL pParent;
	if( !pc || !pc->parent )
		return;
	{
		PPHYSICAL_DEVICE pf = GetFrame(pc)->device;
		//ValidatedControlData( PFRAME, CONTROL_FRAME, pf, GetFrame( pc ) );
		if( pf )
		{
			pf->flags.bCurrentOwns = FALSE;
			pf->pCurrent = NULL;
		}
	}
	pParent = pc->parent;
	if( pc->next )
		pc->next->prior = pc->prior;
	if( pc->prior )
		pc->prior->next = pc->next;
	else
		if( pc->parent )
			pc->parent->child = pc->next;
	pc->parent = NULL;
	pc->next = NULL;
	pc->prior = NULL;
	OrphanSubImage( pc->Window );
	if( bDraw )
	{
 // and of course all sub controls
		UpdateCommonEx( pParent, bDraw DBG_SRC );
	}
	else
	{
		// tell the parent that we're needing an update here...
		//SmudgeSomeControls( pParent, (IMAGE_RECTANGLE*)pc->Window );
	}
}
PSI_PROC( void, OrphanCommon )( PSI_CONTROL pc )
{
	OrphanCommonEx( pc, FALSE );
}
//---------------------------------------------------------------------------
PSI_PROC( void, AdoptCommonEx )( PSI_CONTROL pFoster, PSI_CONTROL pElder, PSI_CONTROL pOrphan, LOGICAL bDraw )
{
	// Puts a control under control of a new parent...
	if( ( !pFoster || !pOrphan
 // has a parent...
	    || pOrphan->parent
 // might have been seperated cause of DetachChildFrames
	    ) && !pOrphan->device
 // is a master level frame - no good.
	  )
	{
		//lprintf( "Failing adopt: %p %p %p %d"
		//       , pFoster, pOrphan
		//       , pOrphan?pOrphan->parent:NULL
		//       , pOrphan?pOrphan->nType:-1 );
		if( !pOrphan->device )
			return;
	}
	// foster has adopted a child...
	// and therefore this child cannot be saved (directly)
	// areas that this applies to include Sheet controls.
	// sheets are saved in separate files from the parent frame.
	if( pOrphan->device )
		DetachFrameFromRenderer( pOrphan );
// adopted children are saved as subsections of XML(?) sub files(?)
	pFoster->flags.bAdoptedChild = 1;
	if( !pOrphan->parent )
		LinkInNewControl( pFoster, pElder, pOrphan );
	if( pOrphan->Window )
	{
		if( pOrphan->Surface )
			OrphanSubImage( pOrphan->Surface );
		UnmakeImageFile( pOrphan->Window );
		pOrphan->Window = NULL;
	}
	if( !pOrphan->Window )
	{
		// its original-rect might have been messed up - so fall back to detached which was saved
		if( pOrphan->flags.detached )
			pOrphan->Window = MakeSubImage( pFoster->Surface
				, pOrphan->detached_at.x, pOrphan->detached_at.y
				, pOrphan->detached_at.width, pOrphan->detached_at.height
				);
		else
			pOrphan->Window = MakeSubImage( pFoster->Surface
				, ScaleValue( &pOrphan->scalex, pOrphan->original_rect.x )
				, ScaleValue( &pOrphan->scaley, pOrphan->original_rect.y )
				, ScaleValue( &pOrphan->scalex, pOrphan->original_rect.width )
				, ScaleValue( &pOrphan->scaley, pOrphan->original_rect.height )
			);
	}
	if( pOrphan->Surface )
		AdoptSubImage( pOrphan->Window, pOrphan->Surface );
	else
	{
		lprintf( "!!!!!!!! No Surface on control!?" );
	}
	ApplyRescale( pOrphan );
	if( !g.flags.always_draw )
		if( bDraw )
 // and of course all sub controls
			UpdateCommonEx( pFoster, bDraw DBG_SRC );
}
//---------------------------------------------------------------------------
PSI_PROC( void, AdoptCommon )( PSI_CONTROL pFoster, PSI_CONTROL pElder, PSI_CONTROL pOrphan )
{
	AdoptCommonEx( pFoster, pElder, pOrphan, TRUE );
}
//---------------------------------------------------------------------------
PSI_CONTROL CreateControlExx( PSI_CONTROL pFrame
								  , uint32_t attr
								  , int x, int y
								  , int w, int h
								  , int nID
								  , int BorderType
								  , int extra
								  , ControlInitProc InitProc
								  , uintptr_t psvInit
									DBG_PASS )
{
	return NULL;
}
//---------------------------------------------------------------------------
void DestroyFrameEx( PSI_CONTROL pc DBG_PASS )
{
	DestroyCommon( &pc );
}
//---------------------------------------------------------------------------
void DestroyControlEx(PSI_CONTROL pc DBG_PASS )
{
	DestroyCommon( &pc );
}
//---------------------------------------------------------------------------
void GetPhysicalCoordinate( PSI_CONTROL relative_to, int32_t *_x, int32_t *_y, int include_surface )
{
	int32_t x = (*_x);
	int32_t y = (*_y);
	int32_t wx, wy;
	PSI_CONTROL frame = GetFrame( relative_to );
	if( frame->device && frame->device->pActImg )
		GetDisplayPosition( frame->device->pActImg, &wx, &wy, NULL, NULL );
	else
	{
		wx = 0;
		wy = 0;
	}
	x += wx;
	y += wy;
	while( relative_to )
	{
		if( include_surface )
			x += relative_to->surface_rect.x;
		if( relative_to->parent )
			x += relative_to->rect.x;
		if( include_surface )
			y += relative_to->surface_rect.y;
		if( relative_to->parent )
			y += relative_to->rect.y;
		relative_to = relative_to->parent;
		include_surface = 1;
	}
	(*_x) = x;
	(*_y) = y;
}
PRENDERER GetFrameRenderer( PSI_CONTROL pcf )
{
	if( pcf )
	{
		PPHYSICAL_DEVICE pf = GetFrame( pcf )->device;
		//ValidatedControlData( PFRAME, CONTROL_FRAME, pf, pcf );
		if( pf )
			return pf->pActImg;
	}
	return NULL;
}
//---------------------------------------------------------------------------
PSI_CONTROL GetFrameFromRenderer( PRENDERER renderer )
{
	INDEX idx;
	PSI_CONTROL pc;
	LIST_FORALL( g.shown_frames, idx, PSI_CONTROL, pc )
	{
		if( pc->device && pc->device->pActImg == renderer )
			break;
	}
	return pc;
}
//---------------------------------------------------------------------------
void AddCommonDraw( PSI_CONTROL pc
						, int (CPROC*Draw)( PSI_CONTROL pc ) )
{
	if( Draw )
	{
		pc->_DrawThySelf = (__DrawThySelf*)Reallocate( pc->_DrawThySelf, ( pc->n_DrawThySelf + 1 ) * sizeof( pc->_DrawThySelf[0] ) );
		pc->_DrawThySelf[pc->n_DrawThySelf++] = Draw;
	}
}
//---------------------------------------------------------------------------
void SetCommonDraw( PSI_CONTROL pc
									  , int (CPROC*Draw)( PSI_CONTROL pc ) )
{
	if( Draw )
	{
		pc->_DrawThySelf = (__DrawThySelf*)Preallocate( pc->_DrawThySelf, ( pc->n_DrawThySelf + 1 ) * sizeof( pc->_DrawThySelf[0] ) );
		pc->_DrawThySelf[0] = Draw;
		pc->n_DrawThySelf++;
	}
}
//---------------------------------------------------------------------------
void SetCommonDrawDecorations( PSI_CONTROL pc
									  , __DrawDecorations DrawDecorations )
{
	if( DrawDecorations )
	{
		pc->_DrawDecorations = (__DrawDecorations*)Preallocate( pc->_DrawDecorations, ( pc->n_DrawDecorations + 1 ) * sizeof( pc->_DrawDecorations[0] ) );
		pc->_DrawDecorations[0] = DrawDecorations;
		pc->n_DrawDecorations++;
	}
}
//---------------------------------------------------------------------------
void AddCommonMouse( PSI_CONTROL pc
									  , int (CPROC*MouseMethod)(PSI_CONTROL, int32_t x, int32_t y, uint32_t b ) )
{
	if( MouseMethod )
	{
		pc->_MouseMethod = (__MouseMethod*)Reallocate( pc->_MouseMethod, ( pc->n_MouseMethod + 1 ) * sizeof( pc->_MouseMethod[0] ) );
		pc->_MouseMethod[pc->n_MouseMethod++] = MouseMethod;
	}
}
//---------------------------------------------------------------------------
void SetCommonMouse( PSI_CONTROL pc
									  , int (CPROC*MouseMethod)(PSI_CONTROL, int32_t x, int32_t y, uint32_t b ) )
{
	if( MouseMethod )
	{
		pc->_MouseMethod = (__MouseMethod*)Preallocate( pc->_MouseMethod, ( pc->n_MouseMethod + 1 ) * sizeof( pc->_MouseMethod[0] ) );
		pc->_MouseMethod[0] = MouseMethod;
		pc->n_MouseMethod++;
	}
}
//---------------------------------------------------------------------------
void AddCommonAcceptDroppedFiles( PSI_CONTROL pc
									  , _AcceptDroppedFiles AcceptDroppedFiles )
{
	if( AcceptDroppedFiles )
	{
		pc->AcceptDroppedFiles = (_AcceptDroppedFiles*)Reallocate( pc->AcceptDroppedFiles, ( pc->nAcceptDroppedFiles + 1 ) * sizeof( pc->AcceptDroppedFiles[0] ) );
		pc->AcceptDroppedFiles[pc->nAcceptDroppedFiles++] = AcceptDroppedFiles;
	}
}
//---------------------------------------------------------------------------
void SetCommonAcceptDroppedFiles( PSI_CONTROL pc
									  , _AcceptDroppedFiles AcceptDroppedFiles )
{
	if( AcceptDroppedFiles )
	{
		pc->AcceptDroppedFiles = (_AcceptDroppedFiles*)Preallocate( pc->AcceptDroppedFiles, ( pc->nAcceptDroppedFiles + 1 ) * sizeof( pc->AcceptDroppedFiles[0] ) );
		pc->AcceptDroppedFiles[0] = AcceptDroppedFiles;
		pc->nAcceptDroppedFiles++;
	}
}
//---------------------------------------------------------------------------
void AddCommonKey( PSI_CONTROL pc
									 ,int (CPROC*Key)(PSI_CONTROL,uint32_t) )
{
	if( Key )
	{
		pc->_KeyProc = (__KeyProc*)Reallocate( pc->_KeyProc, ( pc->n_KeyProc + 1 ) * sizeof( pc->_KeyProc[0] ) );
		pc->_KeyProc[pc->n_KeyProc++] = Key;
	}
}
//---------------------------------------------------------------------------
void SetCommonKey( PSI_CONTROL pc
									 ,int (CPROC*Key)(PSI_CONTROL,uint32_t) )
{
	if( Key )
	{
		pc->_KeyProc = (__KeyProc*)Preallocate( pc->_KeyProc, ( pc->n_KeyProc + 1 ) * sizeof( pc->_KeyProc[0] ) );
		pc->_KeyProc[0] = Key;
		pc->n_KeyProc++;
	}
}
//---------------------------------------------------------------------------
void SetCommonText(PSI_CONTROL pc, CTEXTSTR text )
{
	SetControlText( pc, text );
}
#undef ControlType
INDEX ControlType( PSI_CONTROL pc )
{
	if( pc )
		return pc->nType;
	return INVALID_INDEX;
}
//---------------------------------------------------------------------------
void SetControlTransparent( PSI_CONTROL pc, LOGICAL bTransparent )
{
	if( pc )
	{
		// if we are setting to transparent NO, then remove OriginalImage
		if( !(pc->flags.bTransparent = bTransparent ) )
		{
			//lprintf( "Turning off tansparency, so we don't need the background image now" );
			if( pc->OriginalSurface )
			{
				lprintf( "Early destruction of original surface image..." );
				UnmakeImageFile( pc->OriginalSurface );
				pc->OriginalSurface = NULL;
			}
		}
	}
}
//---------------------------------------------------------------------------
PSI_PROC( void, GetFramePosition )( PSI_CONTROL pf, int32_t *x, int32_t *y )
{
	if( pf )
	{
		PPHYSICAL_DEVICE pfd = pf->device;
		//ValidatedControlData( PFRAME, CONTROL_FRAME, pf, pcf );
		if( pfd )
		{
			GetDisplayPosition( pfd->pActImg, x, y, NULL, NULL );
			return;
		}
		if( x )
			(*x) = pf->original_rect.x;
		if( y )
			(*y) = pf->original_rect.y;
	}
}
//---------------------------------------------------------------------------
PSI_PROC( void, GetFrameSize )( PSI_CONTROL pf, uint32_t *w, uint32_t *h )
{
	if( pf )
	{
		PPHYSICAL_DEVICE pfd = pf->device;
		//ValidatedControlData( PFRAME, CONTROL_FRAME, pf, pcf );
		if( pfd )
		{
			GetDisplayPosition( pfd->pActImg, NULL, NULL, w, h );
			(*w) -= FrameBorderX( pf, pf->BorderType );
			(*h) -= FrameBorderY( pf, pf->BorderType, GetText( pf->caption.text ) );
			return;
		}
		if( w )
			(*w) = pf->original_rect.width;
		if( h )
			(*h) = pf->original_rect.height;
	}
}
CTEXTSTR GetControlTypeName( PSI_CONTROL pc )
{
	TEXTCHAR mydef[32];
	if( !pc->pTypeName ) {
		tnprintf( mydef, sizeof( mydef ), PSI_ROOT_REGISTRY "/control/%d", pc->nType );
		return GetRegisteredValueExx( mydef, NULL, "type", FALSE );
	}
	else return pc->pTypeName;
}
void BeginUpdate( PSI_CONTROL pc )
{
	if( pc )
		pc->flags.bDirectUpdating = 1;
}
void EndUpdate( PSI_CONTROL pc )
{
	if( pc )
		pc->flags.bDirectUpdating = 0;
}
void SetCaptionChangedMethod( PSI_CONTROL frame, void (CPROC*_CaptionChanged)    (struct psi_common_control_frame *) )
{
	frame->CaptionChanged = _CaptionChanged;
}
void SetFrameDetachHandler( PSI_CONTROL pc, void ( CPROC*frameDetached )( struct psi_common_control_frame * pc ) ) {
	if( pc && pc->device ) {
		pc->device->EditState.frameDetached = frameDetached;
	}
}
void SetFrameEditDoneHandler( PSI_CONTROL pc, void ( CPROC*editDone )( struct psi_common_control_frame * pc ) ) {
	if( pc && pc->device ) {
		pc->device->EditState.frameEditDone = editDone;
	}
}
PSI_NAMESPACE_END
//---------------------------------------------------------------------------
//#define DEBUG_BORDER_FLAGS
/* this flag is defined in controlstruc.h...
 *
 * #define DEBUG_BORDER_DRAWING
 * #define QUICK_DEBUG_BORDER_FLAGS // simple set - tracks who sets border where
 *
 */
#define USE_INTERFACE_MANAGER
PSI_NAMESPACE
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
void DrawNormalFrameInset( PSI_CONTROL pc, Image window, int bInvert, int align )
{
}
//---------------------------------------------------------------------------
void CPROC DrawFancyFrame( PSI_CONTROL pc )
{
	int tmp;
	Image window = pc->Window;
	PFrameBorder border = pc->border;
	if( !window ) return;
//#undef ALPHA_TRANSPARENT
//#define ALPHA_TRANSPARENT 1
	if( pc->flags.bInitial || pc->flags.bHidden )
	{
#ifdef DEBUG_BORDER_DRAWING
		lprintf( "Hidden or initial, aborting fancy frame..." );
#endif
		return;
	}
#ifdef DEBUG_BORDER_DRAWING
	lprintf( "Drawing fancy border... no add of update region here..." );
#endif
	switch( border->Border.bAnchorTop )
	{
	default:
 // none, just scale
	case 0:
		BlotScaledImageSizedToAlpha( window, border->BorderSegment[SEGMENT_TOP]
									, pc->surface_rect.x, 0
									, pc->surface_rect.width, border->BorderHeight
									, ALPHA_TRANSPARENT );
		break;
 // left
	case 1:
		tmp = border->BorderSegment[SEGMENT_TOP]->width;
		if( SUS_LT( pc->surface_rect.width, IMAGE_SIZE_COORDINATE, tmp, int ) )
			tmp = pc->surface_rect.width;
		BlotScaledImageSizedEx( window, border->BorderSegment[SEGMENT_TOP]
									, pc->surface_rect.x, 0
									, pc->surface_rect.width, border->BorderHeight
									, 0, 0
									, tmp, border->BorderHeight
									, ALPHA_TRANSPARENT, BLOT_COPY );
		break;
 // center
	case 2:
		tmp = border->BorderSegment[SEGMENT_TOP]->width;
		if( SUS_LT( pc->surface_rect.width, IMAGE_SIZE_COORDINATE, tmp, int ) )
			tmp = pc->surface_rect.width;
		BlotScaledImageSizedEx( window, border->BorderSegment[SEGMENT_TOP]
									, pc->surface_rect.x, 0
									, pc->surface_rect.width, border->BorderHeight
									, (border->BorderSegment[SEGMENT_TOP]->width - tmp )/2, 0
									, tmp, border->BorderHeight
									, ALPHA_TRANSPARENT, BLOT_COPY );
		break;
 // right
	case 3:
		tmp = border->BorderSegment[SEGMENT_TOP]->width;
		if( SUS_LT( pc->surface_rect.width, IMAGE_SIZE_COORDINATE, tmp, int ) )
			tmp = pc->surface_rect.width;
		BlotScaledImageSizedEx( window, border->BorderSegment[SEGMENT_TOP]
									, pc->surface_rect.x, 0
									, pc->surface_rect.width, border->BorderHeight
									, border->BorderSegment[SEGMENT_TOP]->width - tmp, 0
									, tmp, border->BorderHeight
									, ALPHA_TRANSPARENT, BLOT_COPY );
		break;
	}
	switch( border->Border.bAnchorBottom )
	{
	default:
 // none, just scale
	case 0:
		BlotScaledImageSizedToAlpha( window, border->BorderSegment[SEGMENT_BOTTOM]
									, pc->surface_rect.x, pc->surface_rect.y + pc->surface_rect.height
									, pc->surface_rect.width, border->BorderHeight
									, ALPHA_TRANSPARENT );
		break;
 // left
	case 1:
		tmp = border->BorderSegment[SEGMENT_BOTTOM]->width;
		if( SUS_LT( pc->surface_rect.width, IMAGE_SIZE_COORDINATE, tmp, int ) )
			tmp = pc->surface_rect.width;
		BlotScaledImageSizedEx( window, border->BorderSegment[SEGMENT_BOTTOM]
									, pc->surface_rect.x, pc->surface_rect.y + pc->surface_rect.height
									, pc->surface_rect.width, border->BorderHeight
									, 0, 0
									, tmp, border->BorderHeight
									, ALPHA_TRANSPARENT, BLOT_COPY );
		break;
 // center
	case 2:
		tmp = border->BorderSegment[SEGMENT_BOTTOM]->width;
		if( SUS_LT( pc->surface_rect.width, IMAGE_SIZE_COORDINATE, tmp, int ) )
			tmp = pc->surface_rect.width;
		BlotScaledImageSizedEx( window, border->BorderSegment[SEGMENT_BOTTOM]
									, pc->surface_rect.x, pc->surface_rect.y + pc->surface_rect.height
									, pc->surface_rect.width, border->BorderHeight
									, (border->BorderSegment[SEGMENT_BOTTOM]->width - tmp )/2, 0
									, tmp, border->BorderHeight
									, ALPHA_TRANSPARENT, BLOT_COPY );
		break;
 // right
	case 3:
		tmp = border->BorderSegment[SEGMENT_BOTTOM]->width;
		if( SUS_LT( pc->surface_rect.width, IMAGE_SIZE_COORDINATE, tmp, int ) )
			tmp = pc->surface_rect.width;
		BlotScaledImageSizedEx( window, border->BorderSegment[SEGMENT_BOTTOM]
									, pc->surface_rect.x, pc->surface_rect.y + pc->surface_rect.height
									, pc->surface_rect.width, border->BorderHeight
									, border->BorderSegment[SEGMENT_BOTTOM]->width - tmp, 0
									, tmp, border->BorderHeight
									, ALPHA_TRANSPARENT, BLOT_COPY );
		break;
	}
	switch( border->Border.bAnchorLeft )
	{
	default:
 // none, just scale
	case 0:
		BlotScaledImageSizedToAlpha( window, border->BorderSegment[SEGMENT_LEFT]
											, 0, border->BorderHeight
											, border->BorderWidth, window->height - ( border->BorderHeight * 2 )
											, ALPHA_TRANSPARENT );
		break;
 // top
	case 1:
		tmp = border->BorderSegment[SEGMENT_LEFT]->height;
		if( ( window->height - 2 * border->BorderHeight ) < tmp )
			tmp = ( window->height - 2 * border->BorderHeight );
		BlotScaledImageSizedEx( window, border->BorderSegment[SEGMENT_LEFT]
									, 0, border->BorderHeight
									, border->BorderWidth, window->height - ( border->BorderHeight * 2 )
									, 0, 0
									, border->BorderWidth, tmp
									, ALPHA_TRANSPARENT, BLOT_COPY );
		break;
 // center
	case 2:
		tmp = border->BorderSegment[SEGMENT_LEFT]->height;
		if( ( window->height - 2 * border->BorderHeight ) < tmp )
			tmp = ( window->height - 2 * border->BorderHeight );
		BlotScaledImageSizedEx( window, border->BorderSegment[SEGMENT_LEFT]
									, 0, border->BorderHeight
									, border->BorderWidth, window->height - ( border->BorderHeight * 2 )
									, 0, (border->BorderSegment[SEGMENT_LEFT]->height - tmp )/2
									, tmp, border->BorderHeight
									, ALPHA_TRANSPARENT, BLOT_COPY );
		break;
 // bottom
	case 3:
		tmp = border->BorderSegment[SEGMENT_LEFT]->height;
		if( ( window->height - 2 * border->BorderHeight ) < tmp )
			tmp = ( window->height - 2 * border->BorderHeight );
		BlotScaledImageSizedEx( window, border->BorderSegment[SEGMENT_LEFT]
									, 0, border->BorderHeight
									, border->BorderWidth, window->height - ( border->BorderHeight * 2 )
									, 0, border->BorderSegment[SEGMENT_LEFT]->height - tmp
									, tmp, border->BorderHeight
									, ALPHA_TRANSPARENT, BLOT_COPY );
		break;
	}
	switch( border->Border.bAnchorRight )
	{
	default:
 // none, just scale
	case 0:
		BlotScaledImageSizedToAlpha( window, border->BorderSegment[SEGMENT_RIGHT]
											, pc->surface_rect.x + pc->surface_rect.width, border->BorderHeight
											, border->BorderWidth, window->height - ( border->BorderHeight * 2 )
											, ALPHA_TRANSPARENT );
		break;
 // top
	case 1:
		tmp = border->BorderSegment[SEGMENT_RIGHT]->height;
		if( ( window->height - 2 * border->BorderHeight ) < tmp )
			tmp = ( window->height - 2 * border->BorderHeight );
		BlotScaledImageSizedEx( window, border->BorderSegment[SEGMENT_RIGHT]
									, pc->surface_rect.x + pc->surface_rect.width, border->BorderHeight
									, border->BorderWidth, window->height - ( 2 * border->BorderHeight )
									, 0, 0
									, border->BorderWidth, tmp
									, ALPHA_TRANSPARENT, BLOT_COPY );
		break;
 // center
	case 2:
		tmp = border->BorderSegment[SEGMENT_RIGHT]->height;
		if( ( window->height - 2 * border->BorderHeight ) < tmp )
			tmp = ( window->height - 2 * border->BorderHeight );
		BlotScaledImageSizedEx( window, border->BorderSegment[SEGMENT_RIGHT]
									, pc->surface_rect.x + pc->surface_rect.width, border->BorderHeight
									, border->BorderWidth, window->height - ( 2 * border->BorderHeight )
									, 0, (border->BorderSegment[SEGMENT_RIGHT]->height - tmp )/2
									, tmp, border->BorderHeight
									, ALPHA_TRANSPARENT, BLOT_COPY );
		break;
 // bottom
	case 3:
		tmp = border->BorderSegment[SEGMENT_RIGHT]->height;
		if( ( window->height - 2 * border->BorderHeight ) < tmp )
			tmp = ( window->height - 2 * border->BorderHeight );
		BlotScaledImageSizedEx( window, border->BorderSegment[SEGMENT_RIGHT]
									, pc->surface_rect.x + pc->surface_rect.width, border->BorderHeight
									, border->BorderWidth, window->height - ( 2 * border->BorderHeight )
									, 0, border->BorderSegment[SEGMENT_RIGHT]->height - tmp
									, tmp, border->BorderHeight
									, ALPHA_TRANSPARENT, BLOT_COPY );
		break;
	}
	if( ( border->BorderSegment[SEGMENT_CENTER]->width > border->BorderWidth * 3 ) && (  pc->flags.bInitial || border->drawFill ) ) {
		BlotScaledImageSizedEx( window, border->BorderSegment[SEGMENT_CENTER]
			, pc->surface_rect.x, pc->surface_rect.y
			, pc->surface_rect.width, pc->surface_rect.height
			, 0, 0
			, border->BorderSegment[SEGMENT_CENTER]->width, border->BorderSegment[SEGMENT_CENTER]->height
			, ALPHA_TRANSPARENT, BLOT_COPY );
		border->drawFill = 0;
	}
	BlotImageAlpha( window, border->BorderSegment[SEGMENT_TOP_LEFT]
					  , 0, 0
					  , ALPHA_TRANSPARENT );
	BlotImageAlpha( window, border->BorderSegment[SEGMENT_TOP_RIGHT]
					  , border->BorderWidth + pc->surface_rect.width, 0
					  , ALPHA_TRANSPARENT );
	BlotImageAlpha( window, border->BorderSegment[SEGMENT_BOTTOM_LEFT]
					  , 0, window->height - border->BorderHeight
					  , ALPHA_TRANSPARENT );
	BlotImageAlpha( window, border->BorderSegment[SEGMENT_BOTTOM_RIGHT]
					  , border->BorderWidth + pc->surface_rect.width, window->height - border->BorderHeight
					  , ALPHA_TRANSPARENT );
	//lprintf( "Finished fancy border draw." );
}
//---------------------------------------------------------------------------
PSI_PROC( int, FrameBorderXOfs )( PSI_CONTROL pc, uint32_t BorderType )
{
   //lprintf( "Result border offset for %08x", BorderType );
    switch( BorderType & BORDER_TYPE )
    {
    case BORDER_NONE:
      return 0;
    case BORDER_NORMAL:
		 if( pc && pc->DrawBorder == DrawFancyFrame )
		 {
          return pc->border->BorderWidth;
		 }
		 /*
		 if( BorderType & BORDER_RESIZABLE )
		 {
			 return 8;
		 }
		 else
		 */
			 return (pc->border&&pc->border->BorderImage)?pc->border->BorderHeight:4;
	 case BORDER_THINNER:
		 return 2;
	 case BORDER_THIN:
		 return 1;
	 case BORDER_THICK_DENT:
		 return 8;
	 case BORDER_DENT:
		 return 3;
		 break;
	 case BORDER_THIN_DENT:
		 return 2;
	 }
	 // should actually compute this from facts known about pf
	 return 8;
}
//---------------------------------------------------------------------------
PSI_PROC( int, FrameBorderX )( PSI_CONTROL pc, uint32_t BorderType )
{
   //lprintf( "Result total for %08x", BorderType );
    switch( BorderType & BORDER_TYPE )
    {
    case BORDER_NONE:
      return 0;
    case BORDER_NORMAL:
		 if( pc && pc->DrawBorder == DrawFancyFrame )
		 {
          return pc->border->BorderWidth*2;
		 }
		 /*
        if( BorderType & BORDER_RESIZABLE )
            return 16;
        else
		*/
            return (pc->border&&pc->border->BorderImage)?pc->border->BorderWidth * 2:8;
    case BORDER_THINNER:
      return 4;
    case BORDER_THIN:
      return 2;
    case BORDER_THICK_DENT:
      return 16;
    case BORDER_DENT:
      return 6;
        break;
    case BORDER_THIN_DENT:
        return 2*2;
    }
    // should actually compute this from facts known about pf
    return 8;
}
//---------------------------------------------------------------------------
PSI_PROC( int, CaptionHeight )( PSI_CONTROL pf, CTEXTSTR text )
{
    // should resemble something like text height + 3 (top) + 3 (1 bottom, 2 frameline)
    // pf itself may have a different font - which
   // will then switch the height...
	if( pf->DrawCaption )
	{
		return pf->nCaptionHeight;
	}
	else if( pf->caption.image  )
	{
		return pf->caption.image->height + pf->caption.pad*2;
	}
	else if( text || ( pf &&
	    pf->caption.text &&
	    !(pf->BorderType & (BORDER_NOCAPTION|BORDER_WITHIN)) ) )
	{
		GetStringSizeFontEx( " ", 1, NULL, NULL, GetCommonFont( pf ) );
 // 5 above 5 below?
		return GetFontHeight( GetCommonFont(pf) ) + 10;
		//return 17; // should probably be more specific...
	}
	return 0;
}
//---------------------------------------------------------------------------
PSI_PROC( int, FrameBorderYOfs )( PSI_CONTROL pc, uint32_t BorderType, CTEXTSTR caption )
{
	int result = 0;
	if( !(BorderType & BORDER_NOCAPTION ) &&
		( (pc && pc->DrawBorder) || caption || pc->DrawCaption ) )
		result += CaptionHeight( pc, caption );
	//if( !pf )
	//  return CaptionHeight( caption, NULL ) + 4;
	switch( BorderType & BORDER_TYPE )
	{
	case BORDER_NONE:
		return result;
	case BORDER_NORMAL:
		if( pc && pc->DrawBorder == DrawFancyFrame )
		{
			return result + pc->border->BorderHeight;
		}
		/*
		if( BorderType & BORDER_RESIZABLE )
			return result + 8;
		else
		*/
			return result + ( ( ( (pc->border&&pc->border->BorderImage)?pc->border->BorderHeight:4)* 3 ) / 4 );
	case BORDER_THINNER:
		return result + 2;
	case BORDER_THIN:
		return result + 1;
	case BORDER_THICK_DENT:
		return result + 8;
	case BORDER_DENT:
		return result + 3;
	case BORDER_THIN_DENT:
		return result + 2;
	}
	// should actually compute this from facts known about pf
	return result + 2;
}
int FrameCaptionYOfs( PSI_CONTROL pc, uint32_t BorderType )
{
	int result = 0;
	//if( !pf )
	//  return CaptionHeight( caption, NULL ) + 4;
	switch( BorderType & BORDER_TYPE )
	{
	case BORDER_NONE:
		return 0;
	case BORDER_NORMAL:
		if( pc && pc->DrawBorder == DrawFancyFrame )
		{
			return result + pc->border->BorderHeight;
		}
		/*
		if( BorderType & BORDER_RESIZABLE )
			return result + 8;
		else
		*/
			return result + ( ( ((pc->border&&pc->border->BorderImage)?pc->border->BorderHeight:4)* 3 ) / 4 );
	case BORDER_THINNER:
		return result + 2;
	case BORDER_THIN:
		return result + 1;
	case BORDER_THICK_DENT:
		return result + 8;
	case BORDER_DENT:
		return result + 3;
	case BORDER_THIN_DENT:
		return result + 2;
	}
	// should actually compute this from facts known about pf
	return result + 2;
}
//---------------------------------------------------------------------------
PSI_PROC( int, FrameBorderY )( PSI_CONTROL pc, uint32_t BorderType, CTEXTSTR caption )
{
	int result = 0;
	if( !(BorderType & BORDER_NOCAPTION ) &&
		( ( pc && pc->DrawBorder ) || caption || pc->DrawCaption ) )
		result += CaptionHeight( pc, caption );
	//if( !pf )
	//  return CaptionHeight( pf, NULL ) + 8;
	switch( BorderType & BORDER_TYPE )
	{
	case BORDER_NONE:
		return result + 0;
	case BORDER_NORMAL:
		if( pc && pc->DrawBorder == DrawFancyFrame )
		{
			return result + pc->border->BorderHeight*2;
		}
		/*
		if( BorderType & BORDER_RESIZABLE )
		{
			return result + 16;
		}
		else
		*/
		{
			return result + (((pc->border&&pc->border->BorderImage)?pc->border->BorderHeight:4) * 7 / 4 );
		}
	case BORDER_THINNER:
		return result + 4;
	case BORDER_THIN:
		return result + 2;
	case BORDER_THICK_DENT:
		return result + 16;
	case BORDER_DENT:
		return result + 6;
	case BORDER_THIN_DENT:
		return result + 4;
	}
	// should actually compute this from facts known about pf
	return result + 4;
}
//---------------------------------------------------------------------------
void CPROC DrawThickFrame( PSI_CONTROL pc )
{
	Image window = pc->Window;
	uint32_t width = window->width;
	uint32_t height = window->height;
	int n, ofs;
	if( pc->flags.bInitial || pc->flags.bHidden ) return;
	for( ofs = 0, n = 0; n < 2; n++,ofs++ )
	{
		do_hline( window, ofs, ofs, width-(1+ofs), basecolor(pc)[NORMAL] );
		do_vline( window, ofs, ofs, height-(1+ofs), basecolor(pc)[NORMAL] );
		do_vline( window, width - (1+ofs), ofs, height-(1+ofs), basecolor(pc)[SHADOW] );
		do_hline( window, height- (1+ofs), ofs, width-(1+ofs), basecolor(pc)[SHADOW]);
	}
	for( n = 0; n < 2; n++,ofs++ )
	{
		do_hline( window, ofs, ofs, width-(1+ofs), basecolor(pc)[HIGHLIGHT] );
		do_vline( window, ofs, ofs, height-(1+ofs), basecolor(pc)[HIGHLIGHT] );
		do_vline( window, width - (1+ofs), ofs, height-(1+ofs), basecolor(pc)[SHADE] );
		do_hline( window, height- (1+ofs), ofs, width-(1+ofs), basecolor(pc)[SHADE]);
	}
	for( n = 0; n < 4; n++,ofs++ )
	{
		do_hline( window, ofs, ofs, width-(1+ofs), basecolor(pc)[NORMAL] );
		do_vline( window, ofs, ofs, height-(1+ofs), basecolor(pc)[NORMAL] );
		do_vline( window, width - (1+ofs), ofs, height-(1+ofs), basecolor(pc)[NORMAL] );
		do_hline( window, height- (1+ofs), ofs, width-(1+ofs), basecolor(pc)[NORMAL]);
	}
}
void CPROC DrawThickFrameInverted( PSI_CONTROL pc )
{
   Image window = pc->Window;
	uint32_t width = window->width;
	uint32_t height = window->height;
	int n, ofs;
   if( pc->flags.bInitial || pc->flags.bHidden ) return;
	for( ofs = 0, n = 0; n < 2; n++,ofs++ )
	{
		do_hline( window, ofs, ofs, width-(1+ofs), basecolor(pc)[SHADOW] );
		do_vline( window, ofs, ofs, height-(1+ofs), basecolor(pc)[SHADOW] );
		do_vline( window, width - (1+ofs), ofs, height-(1+ofs), basecolor(pc)[NORMAL] );
		do_hline( window, height- (1+ofs), ofs, width-(1+ofs), basecolor(pc)[NORMAL]);
	}
	for( n = 0; n < 2; n++,ofs++ )
	{
		do_hline( window, ofs, ofs, width-(1+ofs), basecolor(pc)[SHADE] );
		do_vline( window, ofs, ofs, height-(1+ofs), basecolor(pc)[SHADE] );
		do_vline( window, width - (1+ofs), ofs, height-(1+ofs), basecolor(pc)[HIGHLIGHT] );
		do_hline( window, height- (1+ofs), ofs, width-(1+ofs), basecolor(pc)[HIGHLIGHT]);
	}
	for( n = 0; n < 4; n++,ofs++ )
	{
		do_hline( window, ofs, ofs, width-(1+ofs), basecolor(pc)[NORMAL] );
		do_vline( window, ofs, ofs, height-(1+ofs), basecolor(pc)[NORMAL] );
		do_vline( window, width - (1+ofs), ofs, height-(1+ofs), basecolor(pc)[NORMAL] );
		do_hline( window, height- (1+ofs), ofs, width-(1+ofs), basecolor(pc)[NORMAL]);
	}
}
void CPROC DrawNormalFrame( PSI_CONTROL pc )
{
	Image window = pc->Window;
	uint32_t width = window->width;
	uint32_t height = window->height;
	if( pc->flags.bInitial || pc->flags.bHidden ) return;
	 do_hline( window, 0, 0, width-1, basecolor(pc)[NORMAL] );
	 do_hline( window, 1, 1, width-2, basecolor(pc)[HIGHLIGHT] );
	 do_hline( window, 2, 2, width-3, basecolor(pc)[NORMAL] );
	 do_hline( window, 3, 3, width-4, basecolor(pc)[NORMAL] );
	 do_vline( window, 0, 0, height-1, basecolor(pc)[NORMAL] );
	 do_vline( window, 1, 1, height-2, basecolor(pc)[HIGHLIGHT] );
	 do_vline( window, 2, 2, height-3, basecolor(pc)[NORMAL] );
	 do_vline( window, 3, 3, height-4, basecolor(pc)[NORMAL] );
	 do_vline( window, width -4, 3, height-4, basecolor(pc)[NORMAL] );
	 do_vline( window, width -3, 2, height-3, basecolor(pc)[NORMAL] );
	 do_vline( window, width -2, 1, height-2, basecolor(pc)[SHADE] );
	 do_vline( window, width -1, 0, height-1, basecolor(pc)[SHADOW] );
	 do_hline( window, height-4, 3, width-4, basecolor(pc)[NORMAL]);
	 do_hline( window, height-3, 2, width-3, basecolor(pc)[NORMAL] );
	 do_hline( window, height-2, 1, width-2, basecolor(pc)[SHADE] );
	 do_hline( window, height-1, 0, width-1, basecolor(pc)[SHADOW] );
}
void CPROC DrawNormalFrameInverted( PSI_CONTROL pc )
{
   Image window = pc->Window;
   uint32_t width = window->width;
    uint32_t height = window->height;
   if( pc->flags.bInitial || pc->flags.bHidden ) return;
	do_hline( window, 0, 0, width-1, basecolor(pc)[SHADOW] );
	do_hline( window, 1, 1, width-2, basecolor(pc)[SHADE] );
	do_hline( window, 2, 2, width-3, basecolor(pc)[NORMAL] );
	do_hline( window, 3, 3, width-4, basecolor(pc)[NORMAL] );
	do_vline( window, 0, 0, height-1, basecolor(pc)[SHADOW] );
	do_vline( window, 1, 1, height-2, basecolor(pc)[SHADE] );
	do_vline( window, 2, 2, height-3, basecolor(pc)[NORMAL] );
	do_vline( window, 3, 3, height-4, basecolor(pc)[NORMAL] );
	do_vline( window, width -4, 3, height-4, basecolor(pc)[NORMAL] );
	do_vline( window, width -3, 2, height-3, basecolor(pc)[NORMAL] );
	do_vline( window, width -2, 1, height-2, basecolor(pc)[HIGHLIGHT] );
	do_vline( window, width -1, 0, height-1, basecolor(pc)[NORMAL] );
	do_hline( window, height-4, 3, width-4, basecolor(pc)[NORMAL]);
	do_hline( window, height-3, 2, width-3, basecolor(pc)[NORMAL] );
	do_hline( window, height-2, 1, width-2, basecolor(pc)[HIGHLIGHT] );
	do_hline( window, height-1, 0, width-1, basecolor(pc)[NORMAL] );
}
//---------------------------------------------------------------------------
void CPROC DrawThinnerFrameImage( PSI_CONTROL pc, Image window )
{
   //Image window = pc->Window;
	uint32_t width = window->width;
	uint32_t height = window->height;
	do_hline( window, 0, 0, width-1, basecolor(pc)[HIGHLIGHT] );
	do_hline( window, 1, 1, width-2, basecolor(pc)[NORMAL] );
	do_vline( window, 0, 0, height-1, basecolor(pc)[HIGHLIGHT] );
	do_vline( window, 1, 1, height-2, basecolor(pc)[NORMAL] );
	do_vline( window, width -2, 1, height-2, basecolor(pc)[SHADE] );
	do_vline( window, width -1, 0, height-1, basecolor(pc)[SHADOW] );
	do_hline( window, height-2, 1, width-2, basecolor(pc)[SHADE] );
	do_hline( window, height-1, 0, width-1, basecolor(pc)[SHADOW] );
}
//---------------------------------------------------------------------------
void CPROC DrawThinnerFrame( PSI_CONTROL pc )
{
   Image window = pc->Window;
	uint32_t width = window->width;
	uint32_t height = window->height;
   if( pc->flags.bInitial || pc->flags.bHidden ) return;
	do_hline( window, 0, 0, width-1, basecolor(pc)[HIGHLIGHT] );
	do_hline( window, 1, 1, width-2, basecolor(pc)[NORMAL] );
	do_vline( window, 0, 0, height-1, basecolor(pc)[HIGHLIGHT] );
	do_vline( window, 1, 1, height-2, basecolor(pc)[NORMAL] );
	do_vline( window, width -2, 1, height-2, basecolor(pc)[SHADE] );
	do_vline( window, width -1, 0, height-1, basecolor(pc)[SHADOW] );
	do_hline( window, height-2, 1, width-2, basecolor(pc)[SHADE] );
	do_hline( window, height-1, 0, width-1, basecolor(pc)[SHADOW] );
}
void CPROC DrawThinnerFrameInverted( PSI_CONTROL pc )
{
	Image window = pc->Window;
	uint32_t width = window->width;
	uint32_t height = window->height;
	if( pc->flags.bInitial || pc->flags.bHidden ) return;
	do_hline( window, 0, 0, width-1, basecolor(pc)[SHADOW] );
	do_hline( window, 1, 1, width-2, basecolor(pc)[SHADE] );
	do_vline( window, 0, 0, height-1, basecolor(pc)[SHADOW] );
	do_vline( window, 1, 1, height-2, basecolor(pc)[SHADE] );
	do_vline( window, width -2, 1, height-2, basecolor(pc)[NORMAL] );
	do_vline( window, width -1, 0, height-1, basecolor(pc)[HIGHLIGHT] );
	do_hline( window, height-2, 1, width-2, basecolor(pc)[NORMAL] );
	do_hline( window, height-1, 0, width-1, basecolor(pc)[HIGHLIGHT] );
}
void CPROC DrawThinnerFrameInvertedImage( PSI_CONTROL pc, Image window )
{
	//Image window = pc->Window;
	uint32_t width = window->width;
	uint32_t height = window->height;
	do_hline( window, 0, 0, width-1, basecolor(pc)[SHADOW] );
	do_hline( window, 1, 1, width-2, basecolor(pc)[SHADE] );
	do_vline( window, 0, 0, height-1, basecolor(pc)[SHADOW] );
	do_vline( window, 1, 1, height-2, basecolor(pc)[SHADE] );
	do_vline( window, width -2, 1, height-2, basecolor(pc)[NORMAL] );
	do_vline( window, width -1, 0, height-1, basecolor(pc)[HIGHLIGHT] );
	do_hline( window, height-2, 1, width-2, basecolor(pc)[NORMAL] );
	do_hline( window, height-1, 0, width-1, basecolor(pc)[HIGHLIGHT] );
}
//---------------------------------------------------------------------------
void DrawThinnerFrameInset( PSI_CONTROL pc, Image window, int bInvert, int amount )
{
	uint32_t width = window->width;
    uint32_t height = window->height;
	if( !bInvert )
	{
		do_hline( window, amount+0, amount+0, width-(amount+1), basecolor(pc)[HIGHLIGHT] );
		do_hline( window, amount+1, amount+1, width-(amount+2), basecolor(pc)[NORMAL] );
		do_vline( window, amount+0, amount+0, height-(amount+1), basecolor(pc)[HIGHLIGHT] );
		do_vline( window, amount+1, amount+1, height-2, basecolor(pc)[NORMAL] );
		do_vline( window, width -(amount+2), amount+1, height-(amount+2), basecolor(pc)[SHADE] );
		do_vline( window, width -(amount+1), amount+0, height-(amount+1), basecolor(pc)[SHADOW] );
		do_hline( window, height-(amount+2), amount+1, width-(amount+2), basecolor(pc)[SHADE] );
		do_hline( window, height-(amount+1), amount+0, width-(amount+1), basecolor(pc)[SHADOW] );
	}
	else
	{
		do_hline( window, amount+0, amount+0, width-(amount+1), basecolor(pc)[SHADOW] );
		do_hline( window, amount+1, amount+1, width-(amount+2), basecolor(pc)[SHADE] );
		do_vline( window, amount+0, amount+0, height-(amount+1), basecolor(pc)[SHADOW] );
		do_vline( window, amount+1, amount+1, height-(amount+2), basecolor(pc)[SHADE] );
		do_vline( window, width -(amount+2), amount+1, height-(amount+2), basecolor(pc)[NORMAL] );
		do_vline( window, width -(amount+1), amount+0, height-(amount+1), basecolor(pc)[HIGHLIGHT] );
		do_hline( window, height-(amount+2), amount+1, width-(amount+2), basecolor(pc)[NORMAL] );
		do_hline( window, height-(amount+1), amount+0, width-(amount+1), basecolor(pc)[HIGHLIGHT] );
	}
}
//---------------------------------------------------------------------------
void CPROC DrawThinFrame( PSI_CONTROL pc )
{
	Image window = pc->Window;
	uint32_t width = window->width;
	uint32_t height = window->height;
 /*pc->flags.bInitial ||*/
	if( pc->flags.bHidden )
		return;
	//lprintf( "Draw thin frame: %08x %08x  %d %d", basecolor(pc)[SHADOW], basecolor(pc)[HIGHLIGHT], width, height );
	do_hline( window, 0, 0, width-1, basecolor(pc)[HIGHLIGHT] );
	do_vline( window, 0, 0, height-1, basecolor(pc)[HIGHLIGHT] );
	do_vline( window, width -1, 0, height-1, basecolor(pc)[SHADOW] );
	do_hline( window, height-1, 0, width-1, basecolor(pc)[SHADOW] );
}
//---------------------------------------------------------------------------
void CPROC DrawThinFrameInverted( PSI_CONTROL pc )
{
	Image window = pc->Window;
	uint32_t width = window->width;
	uint32_t height = window->height;
 /*pc->flags.bInitial ||*/
	if( pc->flags.bHidden ) return;
	//lprintf( "Draw thin frame Inverted: %08x %08x  %d %d", basecolor(pc)[SHADOW], basecolor(pc)[HIGHLIGHT], width, height );
	do_hline( window, 0, 0, width-1, basecolor(pc)[SHADOW] );
	do_vline( window, 0, 0, height-1, basecolor(pc)[SHADOW] );
	do_vline( window, width -1, 0, height-1, basecolor(pc)[HIGHLIGHT] );
	do_hline( window, height-1, 0, width-1, basecolor(pc)[HIGHLIGHT] );
}
//---------------------------------------------------------------------------
void CPROC DrawThinFrameInvertedImage( PSI_CONTROL pc, Image window )
{
	//Image window = pc->Window;
	uint32_t width = window->width;
	uint32_t height = window->height;
	do_hline( window, 0, 0, width-1, basecolor(pc)[SHADOW] );
	do_vline( window, 0, 0, height-1, basecolor(pc)[SHADOW] );
	do_vline( window, width -1, 0, height-1, basecolor(pc)[HIGHLIGHT] );
	do_hline( window, height-1, 0, width-1, basecolor(pc)[HIGHLIGHT] );
}
//---------------------------------------------------------------------------
void DrawThinFrameInset( PSI_CONTROL pc, Image window, int bInvert, int amount )
{
	uint32_t width = window->width;
	uint32_t height = window->height;
	if( !bInvert )
	{
		do_hline( window, amount, amount, width-(amount+1), basecolor(pc)[HIGHLIGHT] );
		do_vline( window, amount, amount, height-(amount+1), basecolor(pc)[HIGHLIGHT] );
		do_vline( window, width -(amount+1), amount, height-(amount+1), basecolor(pc)[SHADOW] );
		do_hline( window, height-(amount+1), amount, width-(amount+1), basecolor(pc)[SHADOW] );
	}
	else
	{
		do_hline( window, amount, amount, width-(amount+1), basecolor(pc)[SHADOW] );
		do_vline( window, amount, amount, height-(amount+1), basecolor(pc)[SHADOW] );
		do_vline( window, width -(amount+1), amount, height-(amount+1), basecolor(pc)[HIGHLIGHT] );
		do_hline( window, height-(amount+1), amount, width-(amount+1), basecolor(pc)[HIGHLIGHT] );
	}
}
//---------------------------------------------------------------------------
void DrawFrameCaption( PSI_CONTROL pc )
{
	if( !pc ) return;
 /*pc->flags.bInitial ||*/
	if( pc->flags.bHidden ) return;
	if( pc->BorderType & BORDER_NOCAPTION ) return;
	if( (pc->BorderType & BORDER_TYPE) == BORDER_NONE ) {
		if( !(pc->BorderType & BORDER_CAPTION ) )
			return;
	}
	{
		int h, w;
		uint32_t button_left;
		uint32_t width, height;
		uint32_t xofs = ( ( FrameBorderXOfs(pc, pc->BorderType) ) );
		uint32_t yofs = ( ( FrameCaptionYOfs(pc, pc->BorderType ) ) );
		Image out = NULL;
		h = CaptionHeight( pc, pc?GetText(pc->caption.text):NULL ) - 1;
 // no caption to...
		if( h <= 0 )
		{
			//lprintf( "But... there's no caption to render." );
			return;
		}
#ifdef DEBUG_BORDER_FLAGS
		xlprintf(LOG_NOISE+1)( "Rendering a caption %d high", h );
#endif
#define TEXT_INSET 5
		GetImageSize( pc->Window, &width, &height );
		w = width - (xofs + 2);
		if( pc->DrawCaption )
		{
			//lprintf( "Draw custom caption" );
			pc->DrawCaption( pc, pc->pCaptionImage );
		}
		else
		{
			if( pc->flags.bFocused )
			{
				if( g.FrameCaptionFocusedImage || g.FrameCaptionImage )
				{
					out = g.FrameCaptionFocusedImage;
					if( !out )
						out = g.FrameCaptionImage;
					{
						int32_t outx = 0;
						int32_t outy = 0;
						uint32_t outw = width - 2 *xofs;
						uint32_t outh = h+2;
						uint32_t routw = width - 2 *xofs;
						uint32_t routh = h+2;
						if( (h+2) < out->height )
							outh = h+2;
						else
							routh = out->height;
						if ( USS_LT( outw, uint32_t, out->width, int ) )
						{
							outx = out->width/2 - (outw)/2;
						}
						else
						{
							outw = out->width;
						}
						BlotScaledImageSizedEx( pc->Window, out, xofs, yofs, routw, routh, outx, outy, outw, outh, ALPHA_TRANSPARENT, BLOT_COPY );
					}
				}
				else
				{
					//lprintf( "Draw focused caption on pcWindow" );
					BlatColor( pc->Window
								, xofs+1, yofs+1
								, width - 2*(xofs+1)
								, h
								, basecolor(pc)[CAPTION] );
				}
				if( pc->caption.image )
				{
					BlotImageAlpha( pc->Window, pc->caption.image, xofs + pc->caption.pad, yofs + pc->caption.pad, ALPHA_TRANSPARENT );
				}
				else
				{
					PutStringFont( pc->Window
 // Bad choice - but... works for now...
									 , TEXT_INSET + xofs+2, (TEXT_INSET-2)+yofs+2
									 , basecolor(pc)[SHADOW], 0
									 , GetText( pc->caption.text )
									 , GetCommonFont(pc)
									 );
					PutStringFont( pc->Window
 // Bad choice - but... works for now...
									 , TEXT_INSET + xofs+3, (TEXT_INSET-2)+yofs+3
									 , basecolor(pc)[HIGHLIGHT], 0
									 , GetText( pc->caption.text )
									 , GetCommonFont(pc)
									 );
				}
				//      PutString( pc->Window
				//                       // bias the text towards the top?
				//                  , TEXT_INSET + xofs+1, (TEXT_INSET-2)+xofs+1 // Bad choice - but... works for now...
				//                  , basecolor(pc)[CAPTIONTEXTCOLOR], 0
				//                  , GetText( pc->caption.text ) );
				//h += yofs;
 // out is set when drawing a image...
				if( !out )
				{
					w = width - (yofs+1);
					do_hline( pc->Window
							  , yofs, xofs, w
							  , basecolor(pc)[SHADE] );
					do_vline( pc->Window
							  , xofs, yofs, yofs+h
							  , basecolor(pc)[SHADE] );
					do_hline( pc->Window
							  , yofs+h, xofs, w
							  , basecolor(pc)[HIGHLIGHT] );
					do_vline( pc->Window
							  , w, yofs, yofs+h
							  , basecolor(pc)[HIGHLIGHT] );
				}
			}
			else
			{
				//lprintf( "Draw unfocused caption on pcWindow" );
				if( g.FrameCaptionFocusedImage || g.FrameCaptionImage )
				{
					out = g.FrameCaptionImage;
					if( !out )
						out = g.FrameCaptionFocusedImage;
					{
						int32_t outx = 0;
						int32_t outy = 0;
						uint32_t outw = width - 2 *xofs;
						uint32_t outh = h+2;
						uint32_t routw = width - 2 *xofs;
						uint32_t routh = h+2;
						w = width - (xofs + 2);
						if( (h+2) < out->height )
							outh = h+2;
						else
							routh = out->height;
						if ( USS_LT( outw, uint32_t, out->width, int ) )
						{
							outx = out->width/2 - (outw)/2;
						}
						else
						{
							outw = out->width;
						}
						BlotScaledImageSizedEx( pc->Window, out, xofs, yofs, routw, routh, outx, outy, outw, outh, ALPHA_TRANSPARENT, BLOT_COPY );
					}
				}
				if( pc->caption.image )
				{
					BlotImageAlpha( pc->Window, pc->caption.image, xofs + pc->caption.pad, yofs + pc->caption.pad, ALPHA_TRANSPARENT );
				}
				else
				{
					BlatColor( pc->Window
								, xofs+1, yofs+1
								, width - 2*(xofs+1)
								, h
								, basecolor(pc)[INACTIVECAPTION] );
					PutStringFont( pc->Window
 // Bad choice - but... works for now...
										, TEXT_INSET + xofs+1, (TEXT_INSET-2)+yofs+1
										, basecolor(pc)[SHADOW], 0
										, GetText( pc->caption.text )
										, GetCommonFont(pc)
										);
					PutStringFont( pc->Window
 // Bad choice - but... works for now...
										, TEXT_INSET + xofs+2, (TEXT_INSET-2)+yofs+2
										, basecolor(pc)[HIGHLIGHT], 0
										, GetText( pc->caption.text )
										, GetCommonFont(pc)
										);
				}
				//      PutString( pc->Window
				//                  , TEXT_INSET + xofs+1, (TEXT_INSET-2)+xofs+1 // Bad choice - but... works for now...
				//                  , basecolor(pc)[INACTIVECAPTIONTEXTCOLOR], 0
				//                  , GetText( pc->caption.text ) );
				//h += yofs;
				if( !out )
				{
					w = width - (yofs+1);
					do_hline( pc->Window
							  , yofs, xofs, w
							  , basecolor(pc)[HIGHLIGHT] );
					do_vline( pc->Window
							  , xofs, yofs, yofs+h
							  , basecolor(pc)[HIGHLIGHT] );
					do_hline( pc->Window
							  , yofs+h, xofs, w
							  , basecolor(pc)[SHADE] );
					do_vline( pc->Window
							  , w, yofs, yofs+h
							  , basecolor(pc)[SHADE] );
				}
			}
		}
 /* + 3 */
		button_left = w - (h - 2) + pc->caption_button_x_ofs;
		if( pc->device )
		{
			INDEX idx;
			PCAPTION_BUTTON button;
			LIST_FORALL( pc->caption_buttons, idx, PCAPTION_BUTTON, button )
			{
				if( button->flags.hidden )
					continue;
				button->offset = button_left + button->extra_pad;
				if( button->is_pressed )
				{
					if( button->pressed )
						BlotScaledImageSizedToAlpha( pc->Window, button->pressed
								, button_left+ button->extra_pad
								, yofs + 1+ button->extra_pad + pc->caption_button_y_ofs
								, (h) - 2 - ( 2*button->extra_pad)
								, (h) - 2 - ( 2*button->extra_pad), ALPHA_TRANSPARENT );
				}
				else
				{
					if( button->normal )
						BlotScaledImageSizedToAlpha( pc->Window, button->normal
								, button_left + button->extra_pad
								, yofs + 1 + button->extra_pad + pc->caption_button_y_ofs
								, (h) - 2 - ( 2*button->extra_pad)
								, (h) - 2 - ( 2*button->extra_pad), ALPHA_TRANSPARENT );
				}
				if( button->flags.rollover && button->highlight )
				{
					BlotScaledImageSizedToAlpha( pc->Window, button->highlight
								, button_left + button->extra_pad
								, yofs + 1 + button->extra_pad + pc->caption_button_y_ofs
								, (h) - 2 - ( 2*button->extra_pad)
								, (h) - 2 - ( 2*button->extra_pad), ALPHA_TRANSPARENT );
				}
				button_left -= h - button->extra_pad*2;
			}
		}
	}
	//lprintf( "Is anything going to output this to the window?" );
}
//---------------------------------------------------------------------------
void CPROC DrawThickDent( PSI_CONTROL pc )
{
	if( pc->flags.bInitial || pc->flags.bHidden ) return;
	DrawNormalFrameInverted( pc );
	DrawNormalFrameInset( pc, pc->Window, FALSE, 4 );
}
//---------------------------------------------------------------------------
void CPROC DrawThickDentInverted( PSI_CONTROL pc )
{
	if( pc->flags.bInitial || pc->flags.bHidden ) return;
	DrawNormalFrame( pc );
	DrawNormalFrameInset( pc, pc->Window, TRUE, 4 );
}
//---------------------------------------------------------------------------
void CPROC DrawDent( PSI_CONTROL pc )
{
	if( pc->flags.bInitial || pc->flags.bHidden ) return;
	DrawThinnerFrameInverted( pc );
	DrawThinFrameInset( pc, pc->Window, FALSE, 2 );
}
//---------------------------------------------------------------------------
void CPROC DrawDentInverted( PSI_CONTROL pc )
{
	if( pc->flags.bInitial || pc->flags.bHidden ) return;
	DrawThinnerFrame( pc );
	DrawThinFrameInset( pc, pc->Window, TRUE, 2 );
}
//---------------------------------------------------------------------------
void CPROC DrawThinDent( PSI_CONTROL pc )
{
	if( pc->flags.bInitial || pc->flags.bHidden ) return;
	DrawThinFrameInverted( pc );
	DrawThinFrameInset( pc, pc->Window, FALSE, 1 );
}
//---------------------------------------------------------------------------
void CPROC DrawThinDentInverted( PSI_CONTROL pc )
{
   if( pc->flags.bInitial || pc->flags.bHidden ) return;
	DrawThinFrame( pc );
	DrawThinFrameInset( pc, pc->Window, TRUE, 1 );
}
//---------------------------------------------------------------------------
static void CPROC DrawCustomBorder( PSI_CONTROL pc )
{
	if( pc )
	{
		if( pc->BorderDrawProc )
         pc->BorderDrawProc( pc, pc->Window );
	}
}
//---------------------------------------------------------------------------
void CPROC SetDrawBorder( PSI_CONTROL pc )
{
	// psv unused...
	UpdateSurface( pc );
	switch( pc->BorderType & BORDER_TYPE )
	{
	case BORDER_USER_PROC:
		if( pc->BorderDrawProc )
         pc->DrawBorder = DrawCustomBorder;
      break;
	case BORDER_NONE:
		pc->DrawBorder = NULL;
		break;
	case BORDER_NORMAL:
		/*
		if( pc->BorderType & BORDER_RESIZABLE )
		{
			if( pc->BorderType & BORDER_INVERT )
				pc->DrawBorder = DrawThickFrameInverted;
			else
				pc->DrawBorder = DrawThickFrame;
		}
		else
		*/
		{
			if( pc->BorderType & BORDER_INVERT )
				pc->DrawBorder = DrawNormalFrameInverted;
			else
			{
				extern void TryLoadingFrameImage( void );
				if( !g.flags.system_color_set )
				{
					//TryLoadingFrameImage();
					pc->DrawBorder = (pc->border&&pc->border->BorderImage)?DrawFancyFrame:DrawNormalFrame;
				}
				else
					pc->DrawBorder = DrawNormalFrame;
			}
		}
		break;
	case BORDER_THINNER:
		if( pc->BorderType & BORDER_INVERT )
			pc->DrawBorder = DrawThinnerFrameInverted;
		else
			pc->DrawBorder = DrawThinnerFrame;
		break;
	case BORDER_THIN:
		if( pc->BorderType & BORDER_INVERT )
			pc->DrawBorder = DrawThinFrameInverted;
		else
			pc->DrawBorder = DrawThinFrame;
		break;
	case BORDER_THICK_DENT:
		if( pc->BorderType & BORDER_INVERT )
			pc->DrawBorder = DrawThickDentInverted;
		else
			pc->DrawBorder = DrawThickDent;
		break;
	case BORDER_DENT:
		if( pc->BorderType & BORDER_INVERT )
			pc->DrawBorder = DrawDentInverted;
		else
			pc->DrawBorder = DrawDent;
		break;
	case BORDER_THIN_DENT:
		if( pc->BorderType & BORDER_INVERT )
			pc->DrawBorder = DrawThinDentInverted;
		else
			pc->DrawBorder = DrawThinDent;
		break;
	}
	//if( !pc->nType )
	//{
	//   lprintf( "Draw frame caption...." );
	//}
	if( pc->flags.bInitial )
	{
#ifdef DEBUG_BORDER_FLAGS
		lprintf( "Initial set - return early." );
#endif
		return;
	}
	//lprintf( "Oka so the caption will be draw..." );
	if( !g.flags.always_draw )
	{
		if( ( pc->DrawBorder || pc->DrawCaption ) && pc->Window )
		{
#ifdef DEBUG_BORDER_DRAWING
			lprintf( "Calling drawing of the border" );
#endif
			ResetImageBuffers( pc->Window, TRUE );
			if( pc->DrawBorder )
				pc->DrawBorder( pc );
		}
		if( pc->device )
			DrawFrameCaption( pc );
	}
}
//---------------------------------------------------------------------------
void UpdateSurface( PSI_CONTROL pc )
{
	uint32_t border;
	uint32_t width, height;
	LOGICAL size_changed = FALSE;
	LOGICAL pos_changed = FALSE;
	//xlprintf(2100)( "Update Surface... %p  %08x", pc, pc->BorderType );
	border = pc->BorderType;
	width = pc->rect.width;
	height = pc->rect.height;
	if( ( pc->BorderType == BORDER_USER_PROC ) && pc->BorderMeasureProc )
	{
		int left, top, right,bottom;
		pc->BorderMeasureProc( pc, &left, &top, &right, &bottom );
		if( pc->surface_rect.x != left || pc->surface_rect.y != top )
		{
			pc->surface_rect.x = left;
			pc->surface_rect.y = top;
			pos_changed = TRUE;
		}
		if( ( pc->surface_rect.width != (width - right) ) || ( pc->surface_rect.height != (height-bottom) ) )
		{
			pc->surface_rect.width = width - right;
			pc->surface_rect.height = height - bottom;
			size_changed = TRUE;
		}
	}
	else
	{
		int left, top, right,bottom;
		left = FrameBorderXOfs(pc, border);
		top = FrameBorderYOfs(pc, border, GetText(pc->caption.text));
		right = FrameBorderX(pc, border);
		bottom = FrameBorderY(pc, border, GetText(pc->caption.text));
		if( pc->DrawCaption )
		{
			MoveImage( pc->pCaptionImage, left, FrameCaptionYOfs( pc, border ) );
			ResizeImage( pc->pCaptionImage, ( width - right ), pc->nCaptionHeight );
			//MoveImage( pc->pCaptionImage, left - 1, FrameCaptionYOfs( pc, border ) );
			//ResizeImage( pc->pCaptionImage, ( width - right ) + 2, pc->nCaptionHeight );
		}
		if( pc->surface_rect.x != left || pc->surface_rect.y != top )
		{
			pc->surface_rect.x = left;
			pc->surface_rect.y = top;
			pos_changed = TRUE;
		}
		if( ( pc->surface_rect.width != (width - right) ) || ( pc->surface_rect.height != (height-bottom) ) )
		{
			pc->surface_rect.width = width - (right);
			pc->surface_rect.height = height - (bottom);
			size_changed = TRUE;
		}
	}
	if( pc->Surface )
	{
#ifdef DEBUG_BORDER_FLAGS
		lprintf( "- - - -- -- -  -- - -  ---- position is like %d,%d  %d,%d"
				 , pc->surface_rect.x, pc->surface_rect.y
				 , pc->surface_rect.width, pc->surface_rect.height );
#endif
		MoveImage( pc->Surface, pc->surface_rect.x, pc->surface_rect.y );
		ResizeImage( pc->Surface, pc->surface_rect.width, pc->surface_rect.height );
	}
	else
	{
#ifdef DEBUG_BORDER_FLAGS
		lprintf( "--------------------------------- ");
#endif
		pc->Surface = MakeSubImage( pc->Window
										  , pc->surface_rect.x
										  , pc->surface_rect.y
										  , pc->surface_rect.width
										  , pc->surface_rect.height );
		//lprintf( "Resulting surface is %p in %p", pc->Surface, pc->Window );
	}
	if( pos_changed )
	{
		//if( pc-> )
		//pc->Move( pc, FALSE );
	}
	if( size_changed && pc->Surface )
	{
		if( pc->Resize )
			pc->Resize( pc, FALSE );
	}
}
PSI_PROC( void, SetCommonBorderEx )( PSI_CONTROL pc, uint32_t BorderType DBG_PASS )
{
	//_xlprintf((LOG_NOISE+2) DBG_RELAY)( "Setting border for %s to %08x(%08x,%08x) %08x %08x", pc->pTypeName, pc, pc->parent, pc->device, pc->BorderType, BorderType );
	if( pc->BorderType != BorderType )
	{
		pc->BorderType = BorderType;
		pc->flags.bSetBorderType = 1;
		if( BorderType & BORDER_FIXED )
		{
			MoveSizeCommon( pc, pc->original_rect.x, pc->original_rect.y, pc->original_rect.width, pc->original_rect.height );
		}
	}
	// this is also called when the surface changes....
	SetDrawBorder( pc );
}
PSI_PROC( void, PSI_SetCustomBorder )( PSI_CONTROL pc, void (CPROC*proc)(PSI_CONTROL,Image)
                                      , void (CPROC*measure_proc)( PSI_CONTROL,int *x_offset, int *y_offset, int *right_inset, int *bottom_inset )
												 )
{
	if( pc )
	{
		pc->BorderDrawProc = proc;
		pc->BorderMeasureProc = measure_proc;
      pc->BorderType = BORDER_USER_PROC;
	}
}
void SetCaptionHeight( PSI_CONTROL pc, int height )
{
	if( pc )
	{
		pc->nCaptionHeight = height;
		UpdateSurface( pc );
	}
}
PSI_NAMESPACE_END
PSI_NAMESPACE
   struct progress_bar_data
   {
       // declare some data that you want to have associated with your control.
       CDATA bar_color;
       CDATA back_color;
 // total range of progress bar
       uint32_t range;
 // current progress portion
	   uint32_t progress;
   };
//EasyRegisterControl( PROGRESS_BAR_CONTROL_NAME, sizeof( struct progress_bar_data ) );
static CONTROL_REGISTRATION progressBarControl= { PROGRESS_BAR_CONTROL_NAME
			, { 32, 32, sizeof( struct progress_bar_data ), BORDER_THINNER } };
PRELOAD( registerProgressBarcontrol ){ DoRegisterControl( &progressBarControl ); }
static uint32_t* pb_MyControlID = &progressBarControl.TypeID;
static int OnCreateCommon( PROGRESS_BAR_CONTROL_NAME )( PSI_CONTROL pc )
{
	ValidatedControlData( struct progress_bar_data *, pb_MyControlID[0], data, pc );
	if( data )
	{
		data->range = 100;
		data->progress = 0;
		data->bar_color = BASE_COLOR_BLUE;
		data->back_color = BASE_COLOR_DARKGREY;
	}
	return 1;
}
static int OnDrawCommon( PROGRESS_BAR_CONTROL_NAME )( PSI_CONTROL pc )
{
	ValidatedControlData( struct progress_bar_data *, pb_MyControlID[0], data, pc );
	if( data )
	{
		Image surface = GetControlSurface( pc );
		uint32_t c = (data->progress > 0)?(data->progress < data->range)?data->progress:data->range:0;
		uint32_t w = ( surface->width * c ) / data->range;
		BlatColor( surface, 0, 0, w, surface->height, data->bar_color );
		BlatColor( surface, w, 0, surface->width - w, surface->height, data->back_color );
		return 1;
	}
	return 0;
}
void ProgressBar_SetRange( PSI_CONTROL pc, int range )
{
	ValidatedControlData( struct progress_bar_data *, pb_MyControlID[0], data, pc );
	if( data )
	{
		data->range = range;
	}
}
void ProgressBar_SetProgress( PSI_CONTROL pc, int progress )
{
	ValidatedControlData( struct progress_bar_data *, pb_MyControlID[0], data, pc );
	if( data )
	{
		data->progress = progress;
		SmudgeCommon( pc );
	}
}
void ProgressBar_SetColors( PSI_CONTROL pc, CDATA background, CDATA foreground )
{
	ValidatedControlData( struct progress_bar_data *, pb_MyControlID[0], data, pc );
	if( data )
	{
		data->back_color = background;
		data->bar_color = foreground;
	}
}
void ProgressBar_EnableText( PSI_CONTROL pc, LOGICAL enable )
{
}
PSI_NAMESPACE_END
PSI_NAMESPACE
//---------------------------------------------------------------------------
static void CPROC StopThisProgram( PSI_CONTROL pc )
{
	PSI_CONTROL button;
	if( ( pc->device && pc->parent  && ( !(pc->BorderType & BORDER_WITHIN ) ) )
		|| ( pc->BorderType & BORDER_CAPTION_CLOSE_IS_DONE ) )
	{
		button = GetControl( pc, pc->device->nIDDefaultCancel );
		if( button )
			InvokeButton( button );
		else
		{
			button = GetControl( pc, pc->device->nIDDefaultOK );
			if( button )
				InvokeButton( button );
			else
				HideControl( pc );
		}
	}
	else
		BAG_Exit( (int)'exit' );
}
//---------------------------------------------------------------------------
PCAPTION_BUTTON AddCaptionButton( PSI_CONTROL frame, Image normal, Image pressed, Image highlight, int extra_pad, void (CPROC*event)(PSI_CONTROL) )
{
	if( !( frame->BorderType & BORDER_CAPTION_NO_CLOSE_BUTTON ) )
	{
		if( !frame->flags.bCloseButtonAdded
			&& ( frame->BorderType & BORDER_CAPTION_CLOSE_BUTTON ) )
		{
			frame->flags.bCloseButtonAdded = 1;
			AddCaptionButton( frame, (!event&&normal)?normal:g.StopButton
							, (!event&&pressed)?pressed:g.StopButtonPressed
							, (!event&&highlight)?highlight:NULL
							, (!event&&normal)?extra_pad:g.StopButtonPad, StopThisProgram );
		}
		else if( !event && frame->flags.bCloseButtonAdded )
		{
			PCAPTION_BUTTON close_button = (PCAPTION_BUTTON)GetLink( &frame->caption_buttons, 0 );
			close_button->normal = normal;
			close_button->pressed = pressed;
			close_button->extra_pad = extra_pad;
		}
	}
	if( frame && event )
	{
		PCAPTION_BUTTON button = New( CAPTION_BUTTON );
		button->normal = normal;
		button->pressed = pressed;
		button->highlight = highlight;
		button->pressed_event = event;
		button->flags.hidden = FALSE;
		button->flags.rollover = FALSE;
		button->is_pressed = FALSE;
		button->extra_pad = extra_pad;
		button->pc = frame;
		AddLink( &frame->caption_buttons, button );
		return button;
	}
	return NULL;
}
void SetCaptionButtonImages( struct physical_device_caption_button *caption_button, Image normal, Image pressed, Image rollover )
{
	if( caption_button )
	{
		caption_button->pressed = pressed;
		caption_button->normal = normal;
		caption_button->highlight = rollover;
		if( caption_button->pc->device )
		{
			int y = FrameCaptionYOfs( caption_button->pc, caption_button->pc->BorderType );
			LockRenderer( caption_button->pc->device->pActImg );
			DrawFrameCaption( caption_button->pc );
			UpdateDisplayPortion( caption_button->pc->device->pActImg, caption_button->pc->surface_rect.x - 1, y
										, caption_button->pc->surface_rect.width + 2
										, caption_button->pc->surface_rect.y - y );
			UnlockRenderer( caption_button->pc->device->pActImg );
		}
	}
}
static void RefreshCaption( PSI_CONTROL pc, PPHYSICAL_DEVICE device )
{
	//if( !g.flags.allow_threaded_draw )
	if( device->pActImg && !pc->flags.bOpeningFrameDisplay )
	{
		int y = FrameCaptionYOfs( pc, pc->BorderType );
		LockRenderer( device->pActImg );
		DrawFrameCaption( pc );
 // set during resize operation; don't output now.
		if( !pc->flags.bResizedDirty )
			UpdateDisplayPortion( device->pActImg, pc->surface_rect.x - 1, y
										, pc->surface_rect.width + 2
										, pc->surface_rect.y - y );
		UnlockRenderer( device->pActImg );
	}
	/*
	else
	{
		pc->flags.bResizedDirty = 1;
		Redraw( device->pActImg );
	}
	*/
}
void HideCaptionButton ( struct physical_device_caption_button *caption_button )
{
	if( caption_button )
	{
		caption_button->flags.hidden = TRUE;
		if( caption_button->pc->device )
		{
			RefreshCaption( caption_button->pc, caption_button->pc->device );
		}
	}
}
void ShowCaptionButton ( struct physical_device_caption_button *caption_button )
{
	if( caption_button )
	{
		caption_button->flags.hidden = FALSE;
		if( caption_button->pc->device )
		{
			RefreshCaption( caption_button->pc, caption_button->pc->device );
		}
	}
}
//---------------------------------------------------------------------------
void SetCaptionButtonOffset( PSI_CONTROL frame, int32_t x, int32_t y )
{
	if( frame )
	{
		frame->caption_button_x_ofs = x;
		frame->caption_button_y_ofs = y;
	}
}
//---------------------------------------------------------------------------
PSI_NAMESPACE_END
#ifndef FIRST_SYMBOL_VALUE
#define FIRST_SYMBOL_VALUE 1
#endif
#ifndef BUILD_NAMES
#  if !defined( NAME_ENUMERATION_DECLARED )
#    define FIRST_SYMNAME(name,control_type_name)    FIRST_SYMBOL = FIRST_SYMBOL_VALUE, name = FIRST_SYMBOL_VALUE
#    define SYMNAME(name,control_type_name)        , name
#    define SYMNAME_SKIP(prior, range, name,control_type_name)        , prior, name = prior+range
enum resource_enum {
#  endif
#endif
#if !defined( NAME_ENUMERATION_DECLARED ) || defined( BUILD_NAMES )
#undef BTN_OKAY
#undef BTN_CANCEL
FIRST_SYMNAME( BTN_OKAY, NORMAL_BUTTON_NAME )
SYMNAME(BTN_CANCEL,NORMAL_BUTTON_NAME)
SYMNAME( BTN_ABORT, NORMAL_BUTTON_NAME )
SYMNAME( EDT_X     , EDIT_FIELD_NAME )
SYMNAME( EDT_Y     , EDIT_FIELD_NAME )
SYMNAME( EDT_WIDTH , EDIT_FIELD_NAME )
SYMNAME( EDT_HEIGHT, EDIT_FIELD_NAME )
SYMNAME( EDT_CAPTION, EDIT_FIELD_NAME)
SYMNAME( EDT_ID     , EDIT_FIELD_NAME)
SYMNAME( EDT_IDNAME , EDIT_FIELD_NAME)
SYMNAME( LABEL_X    , STATIC_TEXT_NAME )
SYMNAME( LABEL_Y    , STATIC_TEXT_NAME)
SYMNAME( LABEL_WIDTH  , STATIC_TEXT_NAME)
SYMNAME( LABEL_HEIGHT , STATIC_TEXT_NAME)
SYMNAME( LABEL_CAPTION, STATIC_TEXT_NAME)
SYMNAME( LABEL_ID     , STATIC_TEXT_NAME)
SYMNAME( LISTBOX_IDS , LISTBOX_CONTROL_NAME  )
SYMNAME( SLD_GREENBAR    , SLIDER_CONTROL_NAME )
SYMNAME( PAL_COLORS      , "Color Matrix" )
 // define a preset
SYMNAME( BTN_PRESET      , NORMAL_BUTTON_NAME )
SYMNAME( CHK_ALPHA       , RADIO_BUTTON_NAME  )
SYMNAME( CST_SHADE       , "Shade Well" )
SYMNAME( CST_ZOOM        , "Shade Well" )
SYMNAME( CST_SHADE_RED   , "Shade Well" )
SYMNAME( CST_SHADE_BLUE  , "Shade Well" )
SYMNAME( CST_SHADE_GREEN , "Shade Well" )
		SYMNAME_SKIP( BTN_PRESET_BASE, 64, BTN_PRESET_LAST, CUSTOM_BUTTON_NAME )
#endif
#ifndef BUILD_NAMES
#  if !defined( NAME_ENUMERATION_DECLARED )
#  define NAME_ENUMERATION_DECLARED
};
#  endif
#endif
#undef SYMNAME
#undef FIRST_SYMNAME
#undef SYMNAME_SKIP
#undef BUILD_NAMES
#define DEBUG_UPDAATE_DRAW 4
//#define DEBUG_CREATE
PSI_NAMESPACE
static LOGICAL CPROC FileDroppedOnFrame( uintptr_t psvControl, CTEXTSTR filename, int32_t x, int32_t y )
{
	LOGICAL found = 0;
	PSI_CONTROL frame = (PSI_CONTROL)psvControl;
	if( frame )
	{
		x -= frame->surface_rect.x;
		y -= frame->surface_rect.y;
		{
			PSI_CONTROL current;
			for( current = frame->child; current; current = current->next )
			{
				if( current->flags.bHidden )
					continue;
				if( ( x < current->rect.x ) ||
					( y < current->rect.y ) ||
					( SUS_GT( x, int32_t, ( current->rect.x + current->rect.width ) , uint32_t ) ) ||
					( SUS_GT( y, int32_t, ( current->rect.y + current->rect.height ), uint32_t ) ) )
				{
					continue;
				}
				found = FileDroppedOnFrame( (uintptr_t)current, filename
						, x - (current->rect.x )
						, y - (current->rect.y ) );
			}
			if( !found )
			{
				InvokeResultingMethod( found, frame, AcceptDroppedFiles, (frame, filename, x, y ) );
			}
			///////////////
		}
	}
	return found;
}
//---------------------------------------------------------------------------
static void CPROC FrameClose( uintptr_t psv )
{
	PPHYSICAL_DEVICE device = (PPHYSICAL_DEVICE)psv;
	PSI_CONTROL common;
	device->pActImg = NULL;
	DeleteLink( &g.shown_frames, device->common );
	common = device->common;
	DestroyCommon( &common );
}
//---------------------------------------------------------------------------
void GetCurrentDisplaySurface( PPHYSICAL_DEVICE device ) {
	PSI_CONTROL pc = device->common;
	Image surface = pc->Surface;
	Image newsurface
		= device->pActImg ? GetDisplayImage( device->pActImg ) : MakeImageFile( pc->rect.width, pc->rect.height );
	if( pc->Window != newsurface ) {
		pc->flags.bDirty = 1;
		TransferSubImages( newsurface, pc->Window );
		if( pc->Window )
			UnmakeImageFile( pc->Window );
		pc->Window = newsurface;
	}
	if( pc->Window->width != pc->rect.width ) {
		pc->rect.width = pc->Window->width;
		pc->flags.bResizedDirty = 1;
		pc->flags.bDirty = 1;
	}
	if( pc->Window->height != pc->rect.height ) {
		pc->rect.height = pc->Window->height;
		pc->flags.bDirty = 1;
		pc->flags.bResizedDirty = 1;
	}
	if( pc->flags.bResizedDirty ) {
		PFRACTION ix, iy;
		GetCommonScale( pc, &ix, &iy );
		pc->original_rect.x = InverseScaleValue( ix, pc->rect.x );
		pc->original_rect.y = InverseScaleValue( iy, pc->rect.y );
		pc->original_rect.width = InverseScaleValue( ix, pc->rect.width - FrameBorderX( pc, pc->BorderType ) );
		pc->original_rect.height = InverseScaleValue( iy, pc->rect.height - FrameBorderY( pc, pc->BorderType, GetText( pc->caption.text ) ) );
	}
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
static void OnDisplaySizeChange( "PSI Controls" TARGETNAME ) ( uintptr_t psvFrame, int display, int32_t x, int32_t y, uint32_t width, uint32_t height )
{
	PPHYSICAL_DEVICE pf = (PPHYSICAL_DEVICE)psvFrame;
	if( pf )
	{
		PSI_CONTROL pc = pf->common;
		//SizeCommon( pc, width, height );
		if( display )
		{
			// only applies to windows on this display... (maybe should remove this)
		}
	}
}
//---------------------------------------------------------------------------
static void CPROC FrameRedraw( uintptr_t psvFrame, PRENDERER psvSelf )
{
	PPHYSICAL_DEVICE pf = (PPHYSICAL_DEVICE)psvFrame;
	uint32_t update = 0;
	PSI_CONTROL pc;
	//lprintf( "frame %p", pf );
	pc = pf->common;
	if( !g.updateThread )
		g.updateThread = MakeThread();
	//ResetImageBuffers( pc->Window );
 // might (and probalby isn't) attached to anything yet.
	if( !pc )
	{
#ifdef DEBUG_UPDAATE_DRAW
		if( g.flags.bLogDebugUpdate )
			Log( "no frame... early return" );
#endif
		return;
	}
#ifdef DEBUG_UPDAATE_DRAW
	if( g.flags.bLogDebugUpdate )
		lprintf( " ------------- BEGIN FRAME DRAW -----------------" );
#endif
	pc->flags.bShown = 1;
	GetCurrentDisplaySurface(pf);
	if( !pc->flags.bDirty && IsDisplayRedrawForced( pf->pActImg ) )
		pc->flags.bDirty = 1;
	if( g.flags.always_draw || pc->flags.bDirty || pc->flags.bResizedDirty )
	{
		pc->flags.bDirty = 1;
#ifdef DEBUG_UPDAATE_DRAW
		if( g.flags.bLogDebugUpdate )
			Log( "Redraw frame..." );
#endif
		AddUse( pc );
		if( !g.flags.always_draw && pc->flags.bTransparent && pc->flags.bFirstCleaning )
		{
			Image OldSurface;
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				lprintf( "!!Saving old image... (on frame)" );
#endif
			if( ( OldSurface = CopyOriginalSurface( pc, pc->OriginalSurface ) ) )
			{
				pc->OriginalSurface = OldSurface;
			}
			else
				if( pc->OriginalSurface )
				{
#ifdef DEBUG_UPDAATE_DRAW
					if( g.flags.bLogDebugUpdate )
						lprintf( "------------ Restoring old image..." );
					if( g.flags.bLogDebugUpdate )
						lprintf( "Restoring orignal background... " );
#endif
					BlotImage( pc->Surface, pc->OriginalSurface, 0, 0 );
				}
		}
		//pc->flags.bParentCleaned = 1; // has now drawn itself, and we must assume that it's not clean.
		// but then again...
		//update++; // what if we only moved, and the driver requires a refresh?
#ifdef __DISPLAY_NO_BUFFER__
		lprintf( "REDRAW?!" );
#endif
		// if using "displaylib"
		//if( update )
		if( g.flags.always_draw || pc->flags.bResizedDirty )
		{
			//lprintf( "Recomputing border..." );
			// fix up surface rect.
			if( pc->flags.bResizedDirty )
			{
				// recompute surface_rect
				extern void UpdateSurface( PSI_CONTROL pc );
				UpdateSurface( pc );
			}
			if( pc->DrawBorder )
			{
#ifdef DEBUG_BORDER_DRAWING
				lprintf( "Drawing border here too.." );
#endif
				if( pc->border && pc->border->hasFill )
					pc->border->drawFill = 1;
				DrawFrameCaption( pc );
				pc->DrawBorder( pc );
			}
			// probably should just invoke draw... but then we won't get marked
			// dirty - so redundant smudges wont be merged... and we'll do this all twice.
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				lprintf( "Smudging the form... %p", pc );
#endif
		}
		pc->flags.bResizedDirty = 0;
		//SmudgeCommon( pc );
		//else
#ifdef DEBUG_UPDAATE_DRAW
		if( g.flags.bLogDebugUpdate )
			lprintf( "delete use should refresh rectangle. %p", pc );
#endif
		UpdateCommonEx( pc, TRUE DBG_SRC );
		pc->flags.bRestoring = 0;
		if( !pc->flags.bDestroy )
		{
			PSI_CONTROL pc2;
			INDEX idx;
			LIST_FORALL( pf->pending_dirty_controls, idx, PSI_CONTROL, pc2 )
			{
				SetLink( &pf->pending_dirty_controls, idx, 0 );
			}
			pf->flags.sent_redraw = 0;
		}
		DeleteUse( pc );
	}
	else
	{
		if( pf->pending_dirty_controls )
		{
			PSI_CONTROL pc;
			INDEX idx;
			int loops = 0;
			LOGICAL updated;
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				lprintf( "sending update for each dirty control...." );
#endif
			do
			{
				loops++;
				if( loops > 5 )
				{
					lprintf( "Infinite recursion in drawing??" );
					break;
				}
				updated = FALSE;
#ifdef DEBUG_UPDAATE_DRAW
				if( g.flags.bLogDebugUpdate )
					lprintf( "scanning list of dirty controls..." );
#endif
				LIST_FORALL( pf->pending_dirty_controls, idx, PSI_CONTROL, pc )
				{
#ifdef DEBUG_UPDAATE_DRAW
					if( g.flags.bLogDebugUpdate )
						lprintf( "updating dirty control %p", pc );
#endif
					updated = TRUE;
					UpdateCommonEx( pc, TRUE DBG_SRC );
					SetLink( &pf->pending_dirty_controls, idx, 0 );
				}
			}
			while( updated );
			//lprintf( "done with with receiving sent redraw" );
			pf->flags.sent_redraw = 0;
		}
		else
		{
			PSI_CONTROL pcChild;
			for( pcChild = pc->child; pcChild; pcChild = pcChild->next )
				UpdateCommonEx( pcChild, FALSE DBG_SRC );
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				lprintf( "trusting that the frame is already drawn to the stable buffer..." );
#endif
			UpdateDisplay( pf->pActImg );
		}
		pc->flags.bRestoring = 0;
	}
}
//---------------------------------------------------------------------------
static void CPROC FrameFocusProc( uintptr_t psvFrame, PRENDERER loss )
{
	int added_use = 0;
	PPHYSICAL_DEVICE frame = (PPHYSICAL_DEVICE)psvFrame;
	//PFRAME frame = (PFRAME)psvFrame;
	PSI_CONTROL pc = frame->common;
	if( pc->flags.bShown )
	{
		added_use = 1;
		AddUse( pc );
	}
	GetCurrentDisplaySurface(frame);
	if( loss )
	{
		if( frame->pFocus )
			frame->pFocus->flags.bFocused = 0;
		pc->flags.bFocused = 0;
	}
	else
	{
		pc->flags.bFocused = 1;
		if( frame->pFocus && ( frame->pFocus != frame->common ) )
		{
			frame->pFocus->flags.bFocused = 1;
		}
	}
	if( pc->flags.bInitial )
	{
		// still in the middle of displaying... this is a false draw point.
		if( added_use )
			DeleteUse( pc );
		return;
	}
#ifdef DEBUG_UPDAATE_DRAW
	else
		if( g.flags.bLogDebugUpdate )
			lprintf( "Frame is not initial..." );
#endif
//#ifdef DEBUG_UPDAATE_DRAW
#ifdef DEBUG_FOCUS_STUFF
	if( g.flags.bLogDebugUpdate )
		Log1( "PSI Focus change called: %p", loss );
#endif
//#endif
	if( loss )
	{
		if( frame->pFocus && ( frame->pFocus != frame->common ) )
		{
#ifdef DEBUG_FOCUS_STUFF
			lprintf( "Dispatch to current focused control also?" );
#endif
			frame->pFocus->flags.bFocused = 0;
			if( frame->pFocus->ChangeFocus )
				frame->pFocus->ChangeFocus( frame->pFocus, FALSE );
		}
#ifdef DEBUG_FOCUS_STUFF
		lprintf( "Control lost focus. (the frame itself loses focus)" );
#endif
		pc->flags.bFocused = 0;
		if( pc->ChangeFocus )
			pc->ChangeFocus( pc, FALSE );
	}
	else
	{
		pc->flags.bFocused = 1;
#ifdef DEBUG_FOCUS_STUFF
		lprintf( "Control gains focus. (the frame itself gains focus)" );
#endif
		if( pc->ChangeFocus )
			pc->ChangeFocus( pc, TRUE );
		if( frame->pFocus && ( frame->pFocus != frame->common ) )
		{
			AddUse( frame->pFocus );
			// cause we need to unfocus it's control also
			// otherwise we get stupid cursors...
			frame->pFocus->flags.bFocused = 1;
#ifdef DEBUG_FOCUS_STUFF
			lprintf( "Dispatch to current focused control also?" );
#endif
			if( frame->pFocus->ChangeFocus )
				frame->pFocus->ChangeFocus( frame->pFocus, FALSE );
			DeleteUse( frame->pFocus );
		}
	}
	if( !pc->flags.bHidden )
	{
		if( !g.flags.always_draw && pc->DrawBorder )
		{
			// background fill?
			// pc->border->drawFill = 1; // otherwise MUST smudge instead of just draw.
			pc->DrawBorder( pc );
		}
		if( !g.flags.always_draw )
			DrawFrameCaption( pc );
		else
			SmudgeCommon( pc );
		// update just the caption portion?
		if( pc->surface_rect.y && !pc->flags.bRestoring )
		{
#ifdef DEBUG_FOCUS_STUFF
			lprintf( "Updating the frame caption..." );
			lprintf( "Update portion %d,%d to %d,%d", 0, 0, pc->rect.width, pc->surface_rect.y );
			lprintf( "Updating just the caption portion to the display" );
#endif
#ifdef DEBUG_UPDAATE_DRAW
			if( g.flags.bLogDebugUpdate )
				lprintf( "updating display portion %d,%d"
						 , pc->rect.width
						 , pc->surface_rect.y );
#endif
			UpdateDisplayPortion( frame->pActImg
									  , 0, 0
									  , pc->rect.width
									  , pc->surface_rect.y );
		}
		// and draw here...
	}
#ifdef DEBUG_UPDAATE_DRAW
	else
		if( g.flags.bLogDebugUpdate )
			lprintf( "Did not draw frame of hidden frame." );
#endif
	if( added_use )
		DeleteUse( pc );
}
//---------------------------------------------------------------------------
static int CPROC FrameKeyProc( uintptr_t psvFrame, uint32_t key )
{
	PPHYSICAL_DEVICE pf = (PPHYSICAL_DEVICE)psvFrame;
	//PFRAME pf = (PFRAME)psvFrame;
	PSI_CONTROL pc = pf->common;
	int result = 0;
	if( pc->flags.bDestroy )
		return 0;
	AddUse( pc );
	if( g.flags.bLogKeyEvents )
		lprintf( "Added use for a key %08" _32fx, key );
	{
		if( pf->EditState.flags.bActive && pf->EditState.pCurrent )
		{
			//if( pf->EditState.pCurrent->KeyProc )
			//	pf->EditState.pCurrent->KeyProc( pf->EditState.pCurrent->psvKey, key );
			AddUse( pf->EditState.pCurrent );
			if( g.flags.bLogKeyEvents )
				lprintf( "invoking control use... for %s", pc->pTypeName );
			InvokeResultingMethod( result, pf->EditState.pCurrent, _KeyProc, ( pf->EditState.pCurrent, key ) );
			if( g.flags.bLogKeyEvents )
				lprintf( "Result was %d", result );
			DeleteUse( pf->EditState.pCurrent );
		}
		else if( pf->pFocus )
		{
			// pf can get deleted during the key event, the frame will be locked
			PSI_CONTROL keep_focus = pf->pFocus;
			//if( pf->pFocus->KeyProc )
			//	pf->pFocus->KeyProc( pf->pFocus->psvKey, key );
			AddUse( keep_focus );
			if( g.flags.bLogKeyEvents )
				lprintf( "invoking control focus use...%p %p %s", pf, keep_focus, keep_focus->pTypeName );
			//	lprintf( "dispatch a key event to focused contro... " );
			InvokeResultingMethod( result, keep_focus, _KeyProc, ( keep_focus, key ) );
			if( g.flags.bLogKeyEvents )
				lprintf( "Result was %d", result );
			DeleteUse( keep_focus );
		}
	}
	// passed the key to the child window first...
   // if it did not process, then the frame can get a shot at it..
	if( !result && pc && pc->_KeyProc )
	{
		if( g.flags.bLogKeyEvents )
			lprintf( "Invoking control key method. %s", pc->pTypeName );
		InvokeResultingMethod( result, pc, _KeyProc, (pc,key));
		if( g.flags.bLogKeyEvents )
			lprintf( "Result was %d", result );
	}
	if( !result )
	{
		if( (KEY_CODE(key) == KEY_TAB) && (key & KEY_PRESSED))
		{
			//DebugBreak();
 // not control or alt...
			if( !(key & (KEY_ALT_DOWN|KEY_CONTROL_DOWN)) )
			{
 // shift-tab backwards
				if( key & KEY_SHIFT_DOWN )
				{
					FixFrameFocus( pf, FFF_BACKWARD );
					result = 1;
				}
				else
				{
					FixFrameFocus( pf, FFF_FORWARD );
					result = 1;
				}
			}
		}
		if( KEY_CODE(key) == KEY_ESCAPE && (key & KEY_PRESSED))
			result = InvokeDefault( pc, TRUE );
		if( KEY_CODE(key) == KEY_ENTER && (key & KEY_PRESSED))
			result = InvokeDefault( pc, FALSE );
	}
	DeleteUse( pc );
	return result;
}
//---------------------------------------------------------------------------
static int IsMeOrInMe( PSI_CONTROL isme, PSI_CONTROL pc )
{
	while( pc )
	{
		if( pc->child )
			if( IsMeOrInMe( isme, pc->child ) )
				return TRUE;
		if( isme == pc )
			return TRUE;
      pc = pc->next;
	}
   return FALSE;
}
//---------------------------------------------------------------------------
#ifndef NO_TOUCH
static struct {
	int prior_x, prior_y;
} touch_state;
static void HandleDefaultSingleTouch( PSI_CONTROL canvas, PINPUT_POINT touch1, PINPUT_POINT touch2 )
{
	if( touch1->flags.new_event || touch2->flags.new_event )
	{
		touch_state.prior_x = (int)(( (touch1->x + touch2->x) / 2 ) / 100);
		touch_state.prior_y = (int)(( (touch1->y + touch2->y) / 2 ) / 100);
	}
	else if( touch1->flags.end_event || touch2->flags.end_event )
	{
	}
 // touch is a motion, between down and up
	else
	{
		//int tmpx;
		//int tmpy;
		/*
		SetPageOffsetRelative( canvas->current_page
			, touch_state.prior_x - (tmpx=(( (touch1->x + touch2->x) / 2 ) /100))
			, touch_state.prior_y - (tmpy=(( (touch1->y + touch2->y) / 2 ) /100)));
		touch_state.prior_x = tmpx;
		touch_state.prior_y = tmpy;
		*/
	}
}
static int CPROC HandleTouch( uintptr_t psv, PINPUT_POINT pTouches, int nTouches )
{
	PPHYSICAL_DEVICE pf = (PPHYSICAL_DEVICE)psv;
	PSI_CONTROL pc = pf->common;
	if( !pc )
	{
		// maybe this was closed before it actually got the first message?
		return 0;
	}
	if( pc->flags.bDestroy )
	{
      // somehow we're being destroyed, but not everyone knows yet
		return 0;
	}
	AddUse( pc );
	if( nTouches == 2 )
	{
		HandleDefaultSingleTouch( pc, pTouches, pTouches + 1 );
		return TRUE;
	}
	return FALSE;
}
#endif
//---------------------------------------------------------------------------
void CPROC FrameHide( uintptr_t psv )
{
	PPHYSICAL_DEVICE pf = (PPHYSICAL_DEVICE)psv;
	PSI_CONTROL pc = pf->common;
   InvokeControlHidden( pc );
}
//---------------------------------------------------------------------------
void CPROC FrameRestore( uintptr_t psv )
{
	PPHYSICAL_DEVICE pf = (PPHYSICAL_DEVICE)psv;
	PSI_CONTROL pc = pf->common;
	InvokeControlRevealed( pc );
}
//---------------------------------------------------------------------------
PPHYSICAL_DEVICE OpenPhysicalDevice( PSI_CONTROL pc, PSI_CONTROL over, PRENDERER pActImg, PSI_CONTROL under )
{
	if( pc && !pc->device )
	{
		//Image surface;
		PPHYSICAL_DEVICE device = (PPHYSICAL_DEVICE)Allocate( sizeof( PHYSICAL_DEVICE ) );
		MemSet( device, 0, sizeof( PHYSICAL_DEVICE ) );
		device->common = pc;
		pc->device = device;
		device->nIDDefaultOK = BTN_OKAY;
		device->nIDDefaultCancel = BTN_CANCEL;
		//TryLoadingFrameImage();
		if( under )
			under = GetFrame( under );
		if( over )
			over = GetFrame( over );
		else
			if( pc->stack_parent )
			{
				over = pc->stack_parent;
				//DebugBreak();
				//OrphanCommon( pc );
				// some other method to save this?
				// for now I can guess...
				// pc->device->EditState.parent = parent ?
				// leave it otherwise linked into the stack of controls...
				pc->stack_parent = NULL;
			}
		if( !pActImg )
		{
#ifdef DEBUG_CREATE
			lprintf( "Creating a device to show this control on ... %d,%d %d,%d"
					 , pc->rect.x
					 , pc->rect.y
					 , pc->rect.width
					 , pc->rect.height );
#endif
			//lprintf( "Original show - extending frame bounds..." );
			//pc->original_rect.width += FrameBorderX(pc, pc->BorderType);
			//pc->original_rect.height += FrameBorderY(pc, pc->BorderType, GetText( pc->caption.text ) );
			// apply scale to rect from original...
			//lprintf( "Border X and Y is %d,%d", FrameBorderX(pc, pc->BorderType), FrameBorderY(pc, pc->BorderType, GetText( pc->caption.text ) ) );
			pc->rect.width += FrameBorderX(pc, pc->BorderType);
			pc->rect.height += FrameBorderY(pc, pc->BorderType, GetText( pc->caption.text ) );
			device->pActImg = OpenDisplayAboveUnderSizedAt( 0
																  , pc->rect.width
																  , pc->rect.height
																  , pc->rect.x
																  , pc->rect.y
																  , (over&&over->device)?over->device->pActImg:NULL
																 , (under&&under->device)?under->device->pActImg:NULL);
			if( device->pActImg )
			{
#ifdef WIN32
				WinShell_AcceptDroppedFiles( device->pActImg, FileDroppedOnFrame, (uintptr_t)pc );
#endif
				AddLink( &g.shown_frames, pc );
				SetRendererTitle( device->pActImg, GetText( pc->caption.text ) );
#ifdef DEBUG_CREATE
				lprintf( "Resulting with surface..." );
#endif
			}
		}
		else
		{
			// have to resize the frame then to this display...
#ifdef DEBUG_CREATE
			lprintf( "Using externally assigned render surface..." );
			lprintf( "Adjusting the frame to that size?!" );
#endif
			if( pc->rect.x && pc->rect.y )
				MoveDisplay( pActImg, pc->rect.x, pc->rect.y );
			if( pc->rect.width && pc->rect.height )
				SizeDisplay( pActImg, pc->rect.width, pc->rect.height );
			else
			{
				uint32_t width, height;
				GetDisplaySizeEx( 0, NULL, NULL, &width, &height );
				SizeCommon( pc, width, height );
			}
			device->pActImg = pActImg;
#ifdef WIN32
			WinShell_AcceptDroppedFiles( device->pActImg, FileDroppedOnFrame, (uintptr_t)pc );
#endif
			AddLink( &g.shown_frames, pc );
		}
 // mark this as outer frame... as a popup we still have 'parent'
		pc->BorderType |= BORDER_FRAME;
		GetCurrentDisplaySurface( device );
		// sets up the surface iamge...
		// computes it's offset based on border type and caption
		// characteristics...
		// readjusts surface (again) after adoption.
		//lprintf( "------------------- COMMON BORDER RE-SET on draw -----------------" );
		if( pc->border && pc->border->BorderImage )
			SetCommonTransparent( pc, TRUE );
		SetDrawBorder( pc );
		if( device->pActImg )
		{
			// this routine is in Mouse.c
			SetMouseHandler( device->pActImg, AltFrameMouse, (uintptr_t)device );
			SetHideHandler( device->pActImg, FrameHide, (uintptr_t)device );
			SetRestoreHandler( device->pActImg, FrameRestore, (uintptr_t)device );
			SetCloseHandler( device->pActImg, FrameClose, (uintptr_t)device );
			SetRedrawHandler( device->pActImg, FrameRedraw, (uintptr_t)device );
			SetKeyboardHandler( device->pActImg, FrameKeyProc, (uintptr_t)device );
			SetLoseFocusHandler( device->pActImg, FrameFocusProc, (uintptr_t)device );
#ifndef NO_TOUCH
			SetTouchHandler( device->pActImg, HandleTouch, (uintptr_t)device );
#endif
			// these methods should aready be set by the creation above...
			// have to attach the mouse events to this frame...
		}
		Redraw( device->pActImg );
	}
	if( pc )
		return pc->device;
   return NULL;
}
//---------------------------------------------------------------------------
void DetachFrameFromRenderer(PSI_CONTROL pc )
{
	if( pc->device )
	{
		PPHYSICAL_DEVICE pf = pc->device;
		//ValidatedControlData( PFRAME, CONTROL_FRAME, pf, pc );
		//lprintf( "Closing physical frame device..." );
		if( pf->EditState.flags.bActive )
		{
			// there may also be data in the edit state to take care of...
		}
		if( pf )
		{
			if( pf->pActImg ) SetMouseHandler( pf->pActImg, NULL, 0 );
			if( pf->pActImg ) SetRedrawHandler( pf->pActImg, NULL, 0 );
			if( pf->pActImg ) SetKeyboardHandler( pf->pActImg, NULL, 0 );
			if( pf->pActImg ) SetCloseHandler( pf->pActImg, NULL, 0 );
#ifndef NO_TOUCH
			if( pf->pActImg )
				SetTouchHandler( pf->pActImg, NULL, 0 );
#endif
			// closedevice
			OrphanSubImage( pc->Surface );
			//UnmakeImageFile( pc->Surface );
			if( pf->pActImg )
				CloseDisplay( pf->pActImg );
			// closing the main image closes all children?
			pc->Window = NULL;
			// this is a subimage of window, and as such, is invalid now.
			//pc->Surface = NULL;
			Release( pf );
			// and that's about it, eh?
		}
		pc->device = NULL;
	}
}
//---------------------------------------------------------------------------
PSI_PROC( PSI_CONTROL, AttachFrameToRenderer )( PSI_CONTROL pc, PRENDERER pActImg )
{
	OpenPhysicalDevice( pc
							, pc?pc->stack_parent:NULL
							, pActImg, NULL );
	return pc;
}
PSI_PROC( PSI_CONTROL, CreateFrameFromRenderer )( CTEXTSTR caption
                                           , uint32_t BorderTypeFlags
                                           , PRENDERER pActImg )
{
	PSI_CONTROL pc = NULL;
	int32_t x, y;
	uint32_t width, height;
#ifdef USE_INTERFACES
	GetMyInterface();
	if( !g.MyImageInterface )
		return NULL;
#endif
	GetDisplayPosition( pActImg, &x, &y, &width, &height );
	pc = MakeCaptionedControl( NULL, CONTROL_FRAME
									 , x, y, width, height
									 , 0
									 , caption
									 );
	AttachFrameToRenderer( pc, pActImg );
	SetCommonBorder( pc, BorderTypeFlags|((BorderTypeFlags & BORDER_WITHIN)?0:BORDER_FRAME) );
	return pc;
}
PSI_NAMESPACE_END
PSI_BUTTON_NAMESPACE
#define PutMenuString PutString
#define l buttonControlLocal
//------------------------------------------------------------------------------
typedef struct psi_button_local_tag
{
	struct {
		uint32_t bInited : 1;
		uint32_t bTouchDisplay : 1;
	} flags;
} LOCAL;
static LOCAL buttonControlLocal;
//------------------------------------------------------------------------------
typedef struct button {
	CTEXTSTR ClickMethodName;
	void (CPROC*ClickMethod)( uintptr_t, PSI_CONTROL );
	uintptr_t ClickData;
	uint32_t attr;
	struct {
		BIT_FIELD pressed : 1;
		BIT_FIELD rollover : 1;
	}buttonflags;
	CDATA color;
 // offset from center to draw...
	uint32_t centx;
 // offset from center to draw...
	int32_t ofs_x, ofs_y;
 // top of the caption...
	int32_t topy;
 // prior button states...
	uint32_t _b;
	Image pImage;
	Image pImage_pressed;
	Image pImage_focused;
	Image pImage_focused_pressed;
	Image pImage_rollover;
	Image pImage_rollover_pressed;
	SlicedImage pSlicedImage;
	SlicedImage pSlicedImage_pressed;
	SlicedImage pSlicedImage_focused;
	SlicedImage pSlicedImage_focused_pressed;
	SlicedImage pSlicedImage_rollover;
	SlicedImage pSlicedImage_rollover_pressed;
	CTEXTSTR DrawMethodName;
	void (CPROC*DrawMethod)( uintptr_t, PSI_CONTROL );
	uintptr_t DrawData;
} BUTTON, *PBUTTON;
typedef struct {
	struct {
		uint32_t bChecked:1;
		uint32_t pressed:1;
		uint32_t bCallChecked : 1;
		uint32_t bCallUnchecked : 1;
		uint32_t bCallAll : 1;
	} flags;
	int centx;
 // if is not zero - will work as a radio button
	int groupid;
	CTEXTSTR ClickMethodName;
	void (CPROC*ClickMethod)( uintptr_t, PSI_CONTROL );
	uintptr_t ClickData;
	Image pCheckWindow;
	Image pCheckSurface;
	int _b;
} CHECK, *PCHECK;
//---------------------------------------------------------------------------
static int Init( void )
{
	if( !buttonControlLocal.flags.bInited )
	{
		buttonControlLocal.flags.bTouchDisplay = IsTouchDisplay();
		buttonControlLocal.flags.bInited = TRUE;
	}
	return TRUE;
}
//---------------------------------------------------------------------------
void DrawButtonCaption( PSI_CONTROL pc, PBUTTON pb, int xofs, int yofs, CDATA color, uint32_t *yout, uint32_t *maxwout, SFTFont font )
{
	uint32_t y = 0;
	uint32_t w, h, maxw = 0;
	TEXTCHAR *start = GetText( pc->caption.text ), *end;
	//lprintf( "Drawing button caption: %s", start );
	if( !start )
		return;
	GetStringSizeFontEx( start, 1, NULL, &h, font );
	while( start )
	{
		end = strchr( start, '\n' );
		if( !end )
			end = start + strlen(start);
		if( end[0] )
			start = end+1;
		else
			start = NULL;
		y += h;
	}
	y = (pc->surface_rect.height - y)/2;
	start = GetText( pc->caption.text );
	while( start )
	{
		end = strchr( start, '\n' );
		if( !end )
		{
			end = start + strlen(start);
		}
		w = GetStringSizeFontEx( start, end-start, NULL, NULL, font );
		if( w > maxw )
			maxw = w;
		PutStringFontEx( pc->Surface
							, pb->ofs_x + xofs - w/2, pb->ofs_y + y + yofs
							, color, 0
							, start, end-start
							, font );
		if( end[0] )
			start = end+1;
		else
			start = NULL;
		y += h;
	}
	if( yout )
		*yout = y;
	if( maxwout )
		*maxwout = maxw;
}
//---------------------------------------------------------------------------
static int CPROC ButtonDraw( PSI_CONTROL pc )
{
	ValidatedControlData( PBUTTON, NORMAL_BUTTON, pb, pc );
	int x;
	if( !pb )
	{
		ValidatedControlData( PBUTTON, CUSTOM_BUTTON, pb2, pc );
		//lprintf( "Is not a NORMAL_BUTTON" );
		if( pb2 )
			pb = pb2;
		else
		{
			ValidatedControlData( PBUTTON, IMAGE_BUTTON, pb2, pc );
			//lprintf( "Is not a CUSTOM_BUTTON" );
			if( pb2 )
				pb = pb2;
			else
			{
				//lprintf( "Is not a IMAGE_BUTTON" );
				return 0;
			}
		}
	}
	//lprintf( "Button drawing..." );
	if( pb->buttonflags.pressed )
		pc->BorderType |= BORDER_INVERT;
	else
		pc->BorderType &= ~BORDER_INVERT;
	SetDrawBorder( pc );
	if( pc->DrawBorder ) pc->DrawBorder(pc);
	if( !pb->DrawMethod )
	{
		LOGICAL skip_line = FALSE;
		BlatColorAlpha( pc->Surface, 0, 0, pc->surface_rect.width, pc->surface_rect.height, pb->color?pb->color: basecolor( pc )[NORMAL] );
		//ClearImageTo( pc->Surface, pb->color );
		//lprintf( "drawing an image %p", pb->pImage );
		if( pb->buttonflags.pressed )
		{
			if( pb->pSlicedImage_pressed )
			{
				SlicedImage out = NULL;
				if( pc->flags.bFocused )
				{
					out = pb->pSlicedImage_focused_pressed;
					if( out ) skip_line = TRUE;
				}
				if( !out )
					out = pb->pSlicedImage_pressed;
				if( !out )
					out = pb->pSlicedImage;
				if( out )
				{
					if( pc->flags.bDisable )
						BlotSlicedImageEx( pc->Surface, out, 0, 0, pc->Surface->width, pc->Surface->height
									  , ALPHA_TRANSPARENT
									  , BLOT_MULTISHADE
									  , Color( 62, 62, 62 )
									  , Color( 67,67,67 )
									  , Color( 60, 60, 60 ) );
					else
						BlotSlicedImage( pc->Surface, out, 0, 0, pc->Surface->width, pc->Surface->height );
#if 0
					if( !skip_line && pc->flags.bFocused )
					{
						uint32_t width, height;
						GetImageSize( pc->Surface, &width, &height );
						do_line( pc->Surface, 2, height - 2
								 , width - 2, height - 2
								 , basecolor(pc)[SHADE] );
					}
#endif
				}
			}
			else
			{
				Image out = NULL;
				if( pc->flags.bFocused )
				{
					out = pb->pImage_focused_pressed;
					if( out ) skip_line = TRUE;
				}
				if( !out )
					out = pb->pImage_pressed;
				if( !out )
					out = pb->pImage;
				if( out )
				{
					if( pc->flags.bDisable )
						BlotScaledImageMultiShadedAlpha( pc->Surface, out
									  , ALPHA_TRANSPARENT
									  , Color( 62, 62, 62 )
									  , Color( 67,67,67 )
									  , Color( 60, 60, 60 ) );
					else
						BlotScaledImageAlpha( pc->Surface, out, ALPHA_TRANSPARENT );
#if 0
					if( !skip_line && pc->flags.bFocused )
					{
						uint32_t width, height;
						GetImageSize( out, &width, &height );
						do_line( pc->Surface, 2, height - 2
								 , width - 2, height - 2
								 , basecolor(pc)[SHADE] );
					}
#endif
				}
			}
		}
		else
		{
			if( pb->pSlicedImage_pressed )
			{
				SlicedImage out = NULL;
				if( pb->buttonflags.rollover )
				{
					out = pb->pSlicedImage_rollover;
					if( pc->flags.bFocused && out ) skip_line = TRUE;
				}
				if( !out && pc->flags.bFocused )
				{
					out = pb->pSlicedImage_focused;
					if( out ) skip_line = TRUE;
				}
				if( !out )
					out = pb->pSlicedImage;
				if( !out )
					out = pb->pSlicedImage_pressed;
				if( out )
				{
					if( pc->flags.bDisable )
						BlotSlicedImageEx( pc->Surface, out, 0, 0, pc->Surface->width, pc->Surface->height
									  , ALPHA_TRANSPARENT
									  , BLOT_MULTISHADE
									  , Color( 62, 62, 62 )
									  , Color( 67,67,67 )
									  , Color( 60, 60, 60 ) );
					else
						BlotSlicedImage( pc->Surface, out, 0, 0, pc->Surface->width, pc->Surface->height );
#if 0
					if( pc->flags.bFocused )
					{
						uint32_t width, height;
						GetImageSize( pc->Surface, &width, &height );
						do_line( pc->Surface, 2, height - 2
								 , width - 2, height - 2
								 , basecolor(pc)[SHADE] );
					}
#endif
				}
			}
			else
			{
				Image out = NULL;
				LOGICAL skip_line = FALSE;
				if( pb->buttonflags.rollover )
				{
					out = pb->pImage_rollover;
					if( pc->flags.bFocused && out ) skip_line = TRUE;
				}
				if( !out && pc->flags.bFocused )
				{
					out = pb->pImage_focused;
					if( out ) skip_line = TRUE;
				}
				if( !out )
					out = pb->pImage;
				if( !out )
					out = pb->pImage_pressed;
				if( out )
				{
					if( pc->flags.bDisable )
						BlotScaledImageMultiShadedAlpha( pc->Surface, out
									  , ALPHA_TRANSPARENT
									  , Color( 62, 62, 62 )
									  , Color( 67,67,67 )
									  , Color( 60, 60, 60 ) );
					else
						BlotScaledImageAlpha( pc->Surface, out, ALPHA_TRANSPARENT );
#if 0
					if( !skip_line && pc->flags.bFocused )
					{
						uint32_t width, height;
						GetImageSize( pb->pImage, &width, &height );
						do_line( pc->Surface, 2, height - 2
								 , width - 2, height - 2
								 , basecolor(pc)[SHADE] );
					}
#endif
				}
			}
		}
		if( pc->caption.text )
		{
			SFTFont font = GetFrameFont( pc );
			if( pb->buttonflags.pressed )
				x = pc->surface_rect.width/2 + 1;
			else
				x = pc->surface_rect.width/2;
			if( !pc->flags.bDisable )
			{
				uint32_t y, maxw;
				DrawButtonCaption( pc, pb, x, 0, basecolor(pc)[TEXTCOLOR], &y, &maxw, font );
				if( pc->flags.bFocused )
				{
					LOGICAL handled = FALSE;
					if( pb->buttonflags.pressed )
					{
						if( pb->pImage_focused_pressed )
							handled = TRUE;
					}
					else
					{
						if( pb->pImage_focused )
							handled = TRUE;
					}
					if( !skip_line && !handled )
					{
						do_hline( pc->Surface, y-1, x-maxw/2-1, x+maxw/2+1, basecolor(pc)[SHADE] );
						do_hline( pc->Surface, y, x-maxw/2, x+maxw/2, basecolor(pc)[HIGHLIGHT] );
					}
				}
			}
			else
			{
				DrawButtonCaption( pc, pb, x, 0, basecolor(pc)[SHADOW], NULL, NULL, font );
				DrawButtonCaption( pc, pb, x+1, 1, basecolor(pc)[HIGHLIGHT], NULL, NULL, font );
			}
		}
	}
  //( pb->DrawMethod )
	else
	{
		//lprintf( "Calling application's custom draw routine for a button! ------------------" );
		pb->DrawMethod( pb->DrawData, pc );
	}
	return 1;
}
//---------------------------------------------------------------------------
static void CPROC ButtonCaptionChange( PSI_CONTROL pc )
{
	uint32_t height;
	SFTFont font;
	ValidatedControlData( PBUTTON, NORMAL_BUTTON, pb, pc );
	if( !pb )
	{
		ValidatedControlData( PBUTTON, CUSTOM_BUTTON, pb2, pc );
		pb = pb2;
	}
	if( !pb )
	{
		ValidatedControlData( PBUTTON, IMAGE_BUTTON, pb2, pc );
		pb = pb2;
	}
	font = GetFrameFont( pc );
	GetStringSizeFont( GetText( pc->caption.text ), &pb->centx, &height, font );
	pb->centx/=2;
	pb->topy = ( (signed)pc->surface_rect.height - (signed)height ) / 2;
	if( pb->topy < 0 )
		pb->topy = 0;
}
//---------------------------------------------------------------------------
void InvokeButton( PSI_CONTROL pc )
{
	if( pc->nType == NORMAL_BUTTON ||
	    pc->nType == CUSTOM_BUTTON ||
		pc->nType == IMAGE_BUTTON ||
		pc->nType == RADIO_BUTTON
	  )
	{
		PBUTTON  pb = ControlData( PBUTTON, pc );
		//lprintf( "&*&**&**&*&*&*&*&*&*&*&*& button clicked ");
		if( pb->ClickMethod )
		{
			pb->ClickMethod( pb->ClickData, pc );
		}
		{
			int (CPROC *f)(PSI_CONTROL);
			TEXTCHAR mydef[256];
			CTEXTSTR name;
			PCLASSROOT data = NULL;
			tnprintf( mydef, sizeof( mydef ), PSI_ROOT_REGISTRY "/control/rtti/%d/extra click", pc->nType );
			for( name = GetFirstRegisteredName( mydef, &data );
				 name;
				  name = GetNextRegisteredName( &data ) )
			{
				f = GetRegisteredProcedureExx((PCLASSROOT)data,(CTEXTSTR)NULL,int,name,(PSI_CONTROL));
				if( f )
					f( pc );
			}
		}
	}
}
static int CPROC ButtonMouse( PSI_CONTROL pc, int32_t x, int32_t y, uint32_t b )
{
	ValidatedControlData( PBUTTON, NORMAL_BUTTON, pb, pc );
	if( !pb )
	{
		ValidatedControlData( PBUTTON, CUSTOM_BUTTON, pb2, pc );
		//lprintf( "Is not a NORMAL_BUTTON" );
		if( pb2 )
			pb = pb2;
		else
		{
			ValidatedControlData( PBUTTON, IMAGE_BUTTON, pb2, pc );
			//lprintf( "Is not a CUSTOM_BUTTON" );
			if( pb2 )
				pb = pb2;
			else
			{
				//lprintf( "Is not a IMAGE_BUTTON" );
				return 0;
			}
		}
	}
	//lprintf( "mouse on a button..." );
 // ignore mouse on these...
	if( pc->flags.bDisable )
		return 0;
	if( b == -1 )
	{
		if( pb->buttonflags.pressed )
		{
			lprintf( "releaseing press state sorta..." );
			pb->buttonflags.pressed = FALSE;
			SmudgeCommon( pc );
		}
		pb->_b = 0;
		return 1;
	}
	if( x < 0
		 || y < 0
		 || SUS_GT( x,int32_t,pc->rect.width,uint32_t)
		 || SUS_GT( y,int32_t,pc->rect.height,uint32_t) )
	{
		if( pb->buttonflags.pressed )
		{
			//lprintf( "Releasing button." );
			pb->buttonflags.pressed = FALSE;
			SmudgeCommon( pc );
		}
 // pretend no mouse buttons..
		pb->_b = 0;
		return 0;
	}
	if( b & MK_LBUTTON )
	{
		if( !(pb->_b & MK_LBUTTON ) )
		{
			if( !pb->buttonflags.pressed )
			{
				pb->buttonflags.pressed = TRUE;
				SmudgeCommon( pc );
			}
			if( buttonControlLocal.flags.bTouchDisplay )
				InvokeButton( pc );
		}
	}
	else
	{
		if( ( pb->_b != INVALID_INDEX ) && (pb->_b & MK_LBUTTON ) )
		{
			pb->_b = b;
			if( pb->buttonflags.pressed )
			{
				pb->buttonflags.pressed = FALSE;
				SmudgeCommon( pc );
			}
			if( !buttonControlLocal.flags.bTouchDisplay )
				InvokeButton( pc );
		}
	}
	pb->_b = b;
	return 1;
}
//---------------------------------------------------------------------------
static void HandleRollover( PSI_CONTROL pc, LOGICAL enter )
{
	ValidatedControlData( PBUTTON, NORMAL_BUTTON, pb, pc );
	if( !pb )
	{
		ValidatedControlData( PBUTTON, CUSTOM_BUTTON, pb2, pc );
		//lprintf( "Is not a NORMAL_BUTTON" );
		if( pb2 )
			pb = pb2;
		else
		{
			ValidatedControlData( PBUTTON, IMAGE_BUTTON, pb2, pc );
			//lprintf( "Is not a CUSTOM_BUTTON" );
			if( pb2 )
				pb = pb2;
			else
			{
				//lprintf( "Is not a IMAGE_BUTTON" );
				return;
			}
		}
	}
	if( pb->buttonflags.rollover != enter )
	{
		pb->buttonflags.rollover = enter;
		SmudgeCommon( pc );
	}
}
static void OnControlRollover( NORMAL_BUTTON_NAME )( PSI_CONTROL pc, LOGICAL enter )
{
	HandleRollover( pc, enter );
}
static void OnControlRollover( IMAGE_BUTTON_NAME )( PSI_CONTROL pc, LOGICAL enter )
{
	HandleRollover( pc, enter );
}
//---------------------------------------------------------------------------
static void ToggleButtonCheck( PSI_CONTROL pCom )
{
	ValidatedControlData( PCHECK, RADIO_BUTTON, pc, pCom );
	if( pc->groupid && pCom->parent )
	{
				// this should handle recursiveness...
				// but for now we can go just one up, and back down to the
				// start of the list...
				PSI_CONTROL pcCheck = pCom->parent->child;
				PCHECK pcheck;
				while( ( pcheck = ControlData( PCHECK, pcCheck ) ) )
				{
					if( pCom->nType == RADIO_BUTTON )
					{
						int bChanged = 0;
						if( pcheck->groupid == pc->groupid )
						{
							if( pcheck == pc )
							{
								if( !pcheck->flags.bChecked )
								{
									bChanged = RADIO_CALL_CHECKED;
									pcheck->flags.bChecked = TRUE;
								}
								SmudgeCommon( pcCheck );
							}
							else
							{
								if( pcheck->flags.bChecked )
								{
									bChanged = RADIO_CALL_UNCHECKED;
									pcheck->flags.bChecked = FALSE;
									SmudgeCommon( pcCheck );
								}
							}
						}
						if( pc->flags.bCallAll ||
						    ( pc->flags.bCallChecked && bChanged == RADIO_CALL_CHECKED ) ||
						    ( pc->flags.bCallUnchecked && bChanged == RADIO_CALL_UNCHECKED ) )
						{
							if( pc->ClickMethod )
								pc->ClickMethod( pc->ClickData, pCom );
						}
					}
					pcCheck = pcCheck->next;
				}
			}
			else
			{
				pc->flags.bChecked = !pc->flags.bChecked;
				if( pc->ClickMethod )
					pc->ClickMethod( pc->ClickData, pCom );
				SmudgeCommon( pCom );
			}
}
//---------------------------------------------------------------------------
static int CPROC ButtonKeyProc( PSI_CONTROL pc, uint32_t key )
{
	//printf( "Key: %08x\n", key );
	if( key & 0x80000000 )
	{
		int keymod = KEY_MOD( key );
		if( !keymod &&
			( ( key & 0xFF ) == KEY_SPACE ) ||
			( ( key & 0xFF ) == KEY_ENTER ) )
		{
			InvokeButton( pc );
			return 1;
		}
	}
	return 0;
}
//---------------------------------------------------------------------------
#define BTN_PROPERTY_LISTBOX 1000
static PSI_CONTROL CONTROL_PROPERTIES( Button )( PSI_CONTROL pc )
{
	PSI_CONTROL page = CreateFrame( "Button"
									 , 0, 0
									 , PROP_WIDTH, PROP_HEIGHT
									 , BORDER_NONE|BORDER_WITHIN
									 , NULL );
	if( page )
	{
		PCLASSROOT data = NULL;
		PSI_CONTROL pList;
		CTEXTSTR name;
		//PCLASSROOT pcr = GetClassRoot( PSI_ROOT_REGISTRY "/control/Button/Click" );
		MakeTextControl( page, PROP_PAD, PROP_PAD, 116, 12, TXT_STATIC, "Click Method", 0 );
		//MakeTextControl( page, 0, PROP_PAD, PROP_PAD, 116, 12, TXT_STATIC, "Click Method" );
		pList = MakeListBox( page, PROP_PAD, PROP_PAD + 16, PROP_WIDTH - 2*PROP_PAD, 120, BTN_PROPERTY_LISTBOX, 0 );
		//pList = MakeListBox( page, 0, PROP_PAD, PROP_PAD + 16, PROP_WIDTH - 2*PROP_PAD, 120, LISTBOX );
		for( name = GetFirstRegisteredName( PSI_ROOT_REGISTRY "/control/Button/Click", &data ); name; name = GetNextRegisteredName( &data ) )
		{
			PLISTITEM pli = AddListItem( pList, name );
			SetItemData( pli, (uintptr_t)GetRegisteredProcedure( PSI_ROOT_REGISTRY "/control/Button/Click", int, name, (uintptr_t, PSI_CONTROL) ) );
		}
		// maybe a list box or some junk like that....
	}
	return page;
}
//---------------------------------------------------------------------------
static void OnPropertyEditOkay( "Button" )( PSI_CONTROL pControl, PSI_CONTROL page )
{
	// read the dialog...
	// destruction will happen shortly after this
	// but this should not care fore that...
	PLISTITEM pli = GetSelectedItem( GetControl( page, BTN_PROPERTY_LISTBOX ) );
	((PBUTTON)pControl)->ClickMethod = (void (CPROC*)(uintptr_t,PSI_CONTROL))GetItemData( pli );
}
CTEXTSTR GetMethodName( POINTER Method, CTEXTSTR type, CTEXTSTR method )
{
	CTEXTSTR name;
	PCLASSROOT data = NULL;
	TEXTCHAR buffer[256];
	if( !Method )
		return NULL;
	tnprintf( buffer, sizeof( buffer ), PSI_ROOT_REGISTRY "/methods/%s/%s", type, method );
	for( name = GetFirstRegisteredName( buffer, &data );
		 name;
		  name = GetNextRegisteredName( &data ) )
	{
		POINTER p;
		//lprintf( "Checking method name %s %s", buffer, name );
		p = (POINTER)GetRegisteredProcedureExxx( (PCLASSROOT)NULL, buffer
											  , "void"
											  , name
											  , "(uintptr_t, PSI_CONTROL)" );
		//if( !p )
		//	lprintf( "Failed to get procedure ... %s", name );
		//else
		//	lprintf( "is %s p(%p) == check(%p)", name, p, Method );
		if( p == Method )
			break;
	}
	return name;
}
CTEXTSTR GetClickMethodName( void (CPROC*ClickMethod)(uintptr_t psv, PSI_CONTROL pc) )
{
	return (CTEXTSTR)GetMethodName( (POINTER)ClickMethod, "Button", "Click" );
}
CTEXTSTR GetDrawMethodName( void (CPROC*DrawMethod)(uintptr_t psv, PSI_CONTROL pc) )
{
	return GetMethodName( (POINTER)DrawMethod, "Button", "Draw" );
}
CTEXTSTR GetCheckMethodName( void (CPROC*CheckMethod)(uintptr_t psv, PSI_CONTROL pc) )
{
	return GetMethodName( (POINTER)CheckMethod, "Button", "Check" );
}
//---------------------------------------------------------------------------
void CPROC ButtonText( PSI_CONTROL pc, PVARTEXT pvt )
{
	ValidatedControlData( PBUTTON, NORMAL_BUTTON, pb, pc );
	if( !pb )
	{
		ValidatedControlData( PBUTTON, CUSTOM_BUTTON, pb2, pc );
		pb = pb2;
	}
	if( !pb )
	{
		ValidatedControlData( PBUTTON, IMAGE_BUTTON, pb2, pc );
		pb = pb2;
	}
	vtprintf( pvt ,"#%08x", pb->color );
	{
		CTEXTSTR name;
		name = pb->ClickMethodName;
		if( name )
			vtprintf( pvt, " C\'%s\'", name );
		name = pb->DrawMethodName;
		if( name )
			vtprintf( pvt, " D\'%s\'", name );
	}
}
//---------------------------------------------------------------------------
void CPROC ButtonLoad( PSI_CONTROL pc, CTEXTSTR line )
{
	//ValidatedControlData( PBUTTON, NORMAL_BUTTON, pb, pc );
	//PBUTTON pb = (PBUTTON)pc;
	DebugBreak();
	//sscanf( line ,"#%"_32fs "", &pb->color );
}
//---------------------------------------------------------------------------
//#undef MakeButton
CONTROL_PROC_DEF_EX( NORMAL_BUTTON, BUTTON, Button, (void) )
{
	ValidatedControlData( PBUTTON, NORMAL_BUTTON, pb, pc );
	Init();
	if( pb )
	{
		// this bit of code needs to go away...
		SetCommonTransparent( pc, TRUE );
		pb->buttonflags.pressed = FALSE;
		pb->color = 0;
		pb->_b = 0;
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------------
int CPROC ConfigureCustomDrawnButton( PSI_CONTROL pc )
{
	ValidatedControlData( PBUTTON, CUSTOM_BUTTON, pb, pc );
	//ARG( uint32_t, attr );
	//FP_ARG( void, DrawMethod,(uintptr_t psv, PSI_CONTROL pc) );
	//FP_ARG( void, PushMethod,(uintptr_t psv, PSI_CONTROL pc) );
	//ARG( uintptr_t, Data );
	Init();
#if 0
	if( pb )
	{
		pb->ClickMethod = PushMethod;
		pb->ClickData = Data;
		pb->ClickMethodName = GetClickMethodName( PushMethod );
		if( !pb->ClickMethodName )
		{
			//lprintf( "!!! Click method is not registered, loading this frame will not result in a link for this method..." );
		}
		pb->DrawMethod = DrawMethod;
		pb->DrawMethodName = GetDrawMethodName( DrawMethod );
		if( !pb->DrawMethodName )
		{
			//lprintf( "!!! Draw method is not registered, loading this frame will not result in a link for this method..." );
		}
		if( attr & BUTTON_NO_BORDER )
			SetCommonBorder( pc, BORDER_NONE );
	}
#endif
	if( pb )
	{
		SetCommonTransparent( pc, TRUE );
		pc->CaptionChanged = ButtonCaptionChange;
		pb->color = 0;
		pb->buttonflags.pressed = FALSE;
		pb->_b = 0;
		return 1;
	}
	return 0;
}
//---------------------------------------------------------------------------
int CPROC ConfigureImageButton( PSI_CONTROL pc )
{
	//ARG( Image, pImage );
	//ARG( uint32_t, attr );
	//FP_ARG( void CPROC,PushMethod,(uintptr_t psv, PSI_CONTROL pc) );
	//ARG( uintptr_t, Data );
	ValidatedControlData( PBUTTON, IMAGE_BUTTON, pb, pc );
	Init();
	if( pb )
	{
		//if( attr & BUTTON_NO_BORDER )
		//   SetCommonBorder( pc, BORDER_NONE );
		//pb->ClickMethod = PushMethod;
		//pb->ClickData = Data;
		//pb->pImage = pImage;
		pb->color = 0;
		pb->buttonflags.pressed = FALSE;
		pc->CaptionChanged = ButtonCaptionChange;
		return TRUE;
	}
	return FALSE;
}
PSI_PROC( PSI_CONTROL, SetButtonImage )( PSI_CONTROL pc, Image pImage )
{
	ValidatedControlData( PBUTTON, IMAGE_BUTTON, pb, pc );
	if( !pb )
	{
		ValidatedControlData( PBUTTON, NORMAL_BUTTON, pb2, pc );
		pb = pb2;
	}
	if( pb )
	{
		pb->pImage = pImage;
		pb->pSlicedImage = NULL;
	}
	return pc;
}
PSI_PROC( PSI_CONTROL, SetButtonSlicedImages )( PSI_CONTROL pc, SlicedImage normal_image, SlicedImage pressed_image )
{
	ValidatedControlData( PBUTTON, IMAGE_BUTTON, pb, pc );
	if( !pb )
	{
		ValidatedControlData( PBUTTON, NORMAL_BUTTON, pb2, pc );
		pb = pb2;
	}
	if( pb )
	{
		pb->pImage = NULL;
		pb->pImage_pressed = NULL;
		pb->pSlicedImage = normal_image;
		pb->pSlicedImage_pressed = pressed_image;
	}
	return pc;
}
PSI_PROC( PSI_CONTROL, SetButtonImages )( PSI_CONTROL pc, Image pImage, Image pImage_pressed )
{
	ValidatedControlData( PBUTTON, IMAGE_BUTTON, pb, pc );
	if( !pb )
	{
		ValidatedControlData( PBUTTON, NORMAL_BUTTON, pb2, pc );
		pb = pb2;
	}
	if( pb )
	{
		pb->pImage = pImage;
		pb->pImage_pressed = pImage_pressed;
		pb->pSlicedImage = NULL;
		pb->pSlicedImage_pressed = NULL;
	}
	return pc;
}
PSI_PROC( PSI_CONTROL, SetButtonRolloverImages )( PSI_CONTROL pc, Image pRollover, Image pRollover_pressed )
{
	ValidatedControlData( PBUTTON, IMAGE_BUTTON, pb, pc );
	if( !pb )
	{
		ValidatedControlData( PBUTTON, NORMAL_BUTTON, pb2, pc );
		pb = pb2;
	}
	if( pb )
	{
		pb->pImage_rollover = pRollover;
		pb->pImage_rollover_pressed = pRollover_pressed;
		pb->pSlicedImage_rollover = NULL;
		pb->pSlicedImage_rollover_pressed = NULL;
	}
	return pc;
}
PSI_PROC( PSI_CONTROL, SetButtonSlicedRolloverImages )( PSI_CONTROL pc, SlicedImage pRollover, SlicedImage pRollover_pressed )
{
	ValidatedControlData( PBUTTON, IMAGE_BUTTON, pb, pc );
	if( !pb )
	{
		ValidatedControlData( PBUTTON, NORMAL_BUTTON, pb2, pc );
		pb = pb2;
	}
	if( pb )
	{
		pb->pSlicedImage_rollover = pRollover;
		pb->pSlicedImage_rollover_pressed = pRollover_pressed;
		pb->pImage_rollover = NULL;
		pb->pImage_rollover_pressed = NULL;
	}
	return pc;
}
PSI_PROC( PSI_CONTROL, SetButtonFocusedImages )( PSI_CONTROL pc, Image pImage, Image pImage_pressed )
{
	ValidatedControlData( PBUTTON, IMAGE_BUTTON, pb, pc );
	if( !pb )
	{
		ValidatedControlData( PBUTTON, NORMAL_BUTTON, pb2, pc );
		pb = pb2;
	}
	if( pb )
	{
		pb->pImage_focused = pImage;
		pb->pImage_focused_pressed = pImage_pressed;
		pb->pSlicedImage_focused = NULL;
		pb->pSlicedImage_focused_pressed = NULL;
	}
	return pc;
}
PSI_PROC( PSI_CONTROL, SetButtonSlicedFocusedImages )( PSI_CONTROL pc, SlicedImage pImage, SlicedImage pImage_pressed )
{
	ValidatedControlData( PBUTTON, IMAGE_BUTTON, pb, pc );
	if( !pb )
	{
		ValidatedControlData( PBUTTON, NORMAL_BUTTON, pb2, pc );
		pb = pb2;
	}
	if( pb )
	{
		pb->pImage_focused = NULL;
		pb->pImage_focused_pressed = NULL;
		pb->pSlicedImage_focused = pImage;
		pb->pSlicedImage_focused_pressed = pImage_pressed;
	}
	return pc;
}
PSI_PROC( PSI_CONTROL, SetButtonTextOffset )( PSI_CONTROL pc, int32_t x, int32_t y )
{
	ValidatedControlData( PBUTTON, IMAGE_BUTTON, pb, pc );
	if( !pb )
	{
		ValidatedControlData( PBUTTON, NORMAL_BUTTON, pb2, pc );
		pb = pb2;
	}
	if( pb )
	{
		pb->ofs_x = x;
		pb->ofs_y = y;
	}
	return pc;
}
//---------------------------------------------------------------------------
void PressButton( PSI_CONTROL pc, int bPressed )
{
	ValidatedControlData( PBUTTON, CUSTOM_BUTTON, pbc, pc );
	ValidatedControlData( PBUTTON, IMAGE_BUTTON, pbi, pc );
	ValidatedControlData( PBUTTON, NORMAL_BUTTON, pbn, pc );
	PBUTTON pb;
	pb = pbc?pbc:pbi?pbi:pbn?pbn:NULL;
	if( pb )
	{
		pb->buttonflags.pressed = bPressed;
		SmudgeCommon( pc );
	}
}
//------------------------------------------------------------------------------
int IsButtonPressed( PSI_CONTROL pc )
{
	ValidatedControlData( PBUTTON, CUSTOM_BUTTON, pb, pc );
	if( pb )
	{
		return pb->buttonflags.pressed;
	}
	return 0;
}
PSI_PROC( void, SetButtonColor )( PSI_CONTROL pc, CDATA color )
{
	ValidatedControlData( PBUTTON, NORMAL_BUTTON, pb, pc );
	if( pb )
	{
		pb->color = color;
		SmudgeCommon( pc );
	}
}
//------------------------------------------------------------------------------
//---------------------------------------------------------------------------
void CPROC RadioButtonText( PSI_CONTROL pc, PVARTEXT pvt )
{
	ValidatedControlData( PCHECK, RADIO_BUTTON, pb, pc );
	if( !pb )
	{
		return;
	}
	//vtprintf( pvt ,"#%08x", pb->color );
	{
		CTEXTSTR name;
		name = pb->ClickMethodName;
		if( name )
			vtprintf( pvt, " C\'%s\'", name );
	}
}
//---------------------------------------------------------------------------
static int CPROC DrawCheckButton( PSI_CONTROL pc )
{
	ValidatedControlData( PCHECK, RADIO_BUTTON, pchk, pc );
	uint32_t height = GetFontHeight( GetCommonFont( pc ) );
	ResizeImage( pchk->pCheckWindow, (height-2), (height-2) );
	ResizeImage( pchk->pCheckSurface, (height-4), (height-4) );
	// can be several flavors for check buttons
	// a> a box [ ]
	// b> a button <> which goes into a pressed state
	// c> the whole control si a button that locks down...
	if( pchk )
	{
		BlatColorAlpha( pc->Surface, 0, 0, pc->surface_rect.width, pc->surface_rect.height, basecolor(pc)[NORMAL] );
		if( pchk->flags.bChecked )
			BlatColorAlpha( pchk->pCheckSurface, 0, 0, pc->surface_rect.width, pc->surface_rect.height, basecolor(pc)[HIGHLIGHT] );
		else if( !pchk->flags.pressed )
			BlatColorAlpha( pchk->pCheckSurface, 0, 0, pc->surface_rect.width, pc->surface_rect.height, basecolor(pc)[SHADE] );
		//ClearImageTo( pc->Surface, basecolor(pc)[NORMAL] );
	}
	if( pchk->pCheckWindow )
		DrawThinFrameInvertedImage( pc, pchk->pCheckWindow );
	// this disables also...
	//ClearImageTo( pchk->pCheckSurface, basecolor(pc)[NORMAL]  );
	if( pchk->pCheckSurface )
	{
		if( !pchk->flags.pressed )
		{
			if( pchk->flags.bChecked )
				DrawThinnerFrameInvertedImage( pc, pchk->pCheckSurface );
			else
				DrawThinnerFrameImage( pc, pchk->pCheckSurface );
		}
	}
	if( pc->caption.text )
	{
		int x;
		x = height + (height/3);
		if( !pc->flags.bDisable )
		{
			PutStringFont( pc->Surface, x, 0, basecolor(pc)[TEXTCOLOR], 0, GetText( pc->caption.text), GetCommonFont( pc ) );
			if( pc->flags.bFocused )
			{
				uint32_t end, h;
				end = x + GetStringSizeFont( GetText( pc->caption.text), NULL, &h, GetCommonFont( pc ) );
				//h += ;
				do_line( pc->Surface, x, h-2, end, h-2, basecolor(pc)[SHADE] );
				do_line( pc->Surface, x, h-1, end, h-1, basecolor(pc)[HIGHLIGHT] );
			}
		}
		else
		{
			PutStringFont( pc->Surface, x+1, 1, basecolor(pc)[HIGHLIGHT], 0, GetText( pc->caption.text), GetCommonFont( pc ) );
			PutStringFont( pc->Surface, x, 0, basecolor(pc)[SHADOW], 0, GetText( pc->caption.text), GetCommonFont( pc ) );
		}
	}
	return 1;
}
//---------------------------------------------------------------------------
static int CPROC CheckKeyProc( PSI_CONTROL pc, uint32_t key )
{
	ValidatedControlData( PCHECK, RADIO_BUTTON, pchk, pc );
	PCHECK pb = pchk;
	//printf( "Key: %08x\n", key );
	if( key & 0x80000000 )
	{
		if( ( ( key & 0xFF ) == KEY_SPACE ) ||
		    ( ( key & 0xFF ) == KEY_ENTER ) )
		{
			ToggleButtonCheck( pc );
			return 1;
		}
	}
	return 0;
}
//---------------------------------------------------------------------------
static int CPROC MouseCheckButton( PSI_CONTROL pCom, int32_t x, int32_t y, uint32_t b )
{
	ValidatedControlData( PCHECK, RADIO_BUTTON, pc, pCom );
	if( !pc )
		return 0;
 // ignore mouse on these...
	if( pCom->flags.bDisable )
		return 0;
	if( b == -1 )
	{
		pc->flags.pressed = FALSE;
		SmudgeCommon( pCom );
		pc->_b = 0;
		return 1;
	}
	if( x < 0 || y < 0 || SUS_GT(x,int32_t, pCom->rect.width,uint32_t) || SUS_GT(y,int32_t, pCom->rect.height,uint32_t ) )
	{
		pc->flags.pressed = FALSE;
		SmudgeCommon( pCom );
 // pretend no mouse buttons..
		pc->_b = 0;
		return 1;
	}
	if( b & MK_LBUTTON )
	{
		if( !(pc->_b & MK_LBUTTON ) )
		{
			pc->flags.pressed = TRUE;
			SmudgeCommon( pCom );
		}
	}
	else
	{
		if( (pc->_b & MK_LBUTTON ) )
		{
			pc->flags.pressed = FALSE;
			ToggleButtonCheck( pCom );
		}
	}
	pc->_b = b;
	return 1;
}
//---------------------------------------------------------------------------
static void CPROC DestroyCheckButton( PSI_CONTROL pc )
{
	ValidatedControlData( PCHECK, RADIO_BUTTON, pchk, pc );
	if( pchk )
	{
		if( pchk->pCheckSurface )
			UnmakeImageFile( pchk->pCheckSurface );
		pchk->pCheckSurface = NULL;
		if( pchk->pCheckWindow )
			UnmakeImageFile( pchk->pCheckWindow );
		pchk->pCheckWindow = NULL;
	}
}
//---------------------------------------------------------------------------
PSI_CONTROL SetButtonGroupID(PSI_CONTROL pControl, int nGroupID )
{
	ValidatedControlData( PCHECK, RADIO_BUTTON, pc, pControl );
	if( pc )
	{
		pc->groupid = nGroupID;
	}
	return pControl;
}
PSI_CONTROL SetCheckButtonHandler( PSI_CONTROL pControl
														, void (CPROC*CheckProc)(uintptr_t psv, PSI_CONTROL pc)
														, uintptr_t psv )
{
	ValidatedControlData( PCHECK, RADIO_BUTTON, pc, pControl );
	if( pc )
	{
		pc->ClickMethod = CheckProc;
		pc->ClickMethodName = GetCheckMethodName( CheckProc );
		pc->ClickData = psv;
	}
	return pControl;
}
int CPROC ConfigureCheckButton( PSI_CONTROL pControl )
{
	//ARG( uint32_t, attr );
	//ARG( uint32_t, GroupID );
	//FP_ARG(  void CPROC,CheckProc,(uintptr_t psv, PSI_CONTROL pc ) );
	//ARG( uintptr_t, psv );
	ValidatedControlData( PCHECK, RADIO_BUTTON, pc, pControl );
	Init();
	if( pc )
	{
		uint32_t height = GetFontHeight( GetCommonFont( pControl ) );
		pc->pCheckWindow = MakeSubImage( pControl->Surface, 1, 1, (height-2), (height-2) );
		pc->pCheckSurface = MakeSubImage( pc->pCheckWindow, 1, 1, (height-4), (height-4) );
		//pc->ClickMethod = CheckProc;
		//pc->ClickMethodName = GetCheckMethodName( CheckProc );
		//pc->ClickData = psv;
		//pc->groupid = GroupID;
		/*
		if( !( attr & RADIO_CALL_CHANGED ) )
			pc->flags.bCallAll = 1;
		else
		{
			if( attr & RADIO_CALL_CHECKED )
				pc->flags.bCallChecked = 1;
			if( attr & RADIO_CALL_UNCHECKED )
				pc->flags.bCallUnchecked = 1;
		}
		*/
		return 1;
	}
	return 0;
}
//---------------------------------------------------------------------------
int GetCheckState( PSI_CONTROL pc )
{
	ValidatedControlData( PCHECK, RADIO_BUTTON, pchk, pc );
	if( pchk )
	{
		return pchk->flags.bChecked;
	}
	return 0;
}
//---------------------------------------------------------------------------
void SetCheckState( PSI_CONTROL pc, int nState )
{
	ValidatedControlData( PCHECK, RADIO_BUTTON, pchk, pc );
	if( pchk )
	{
		pchk->flags.bChecked = nState;
		SmudgeCommon( pc );
	}
}
//---------------------------------------------------------------------------
void GetButtonPushMethod( PSI_CONTROL pc, ButtonPushMethod *method, uintptr_t *psv )
{
	ValidatedControlData( PBUTTON, NORMAL_BUTTON, pb, pc );
	if( !pb )
	{
		ValidatedControlData( PBUTTON, CUSTOM_BUTTON, pb2, pc );
		//lprintf( "Is not a NORMAL_BUTTON" );
		if( pb2 )
			pb = pb2;
		else
		{
			ValidatedControlData( PBUTTON, IMAGE_BUTTON, pb2, pc );
			//lprintf( "Is not a CUSTOM_BUTTON" );
			if( pb2 )
				pb = pb2;
			else
			{
				//lprintf( "Is not a IMAGE_BUTTON" );
				return;
			}
		}
	}
	if( pb )
	{
		if( method )
			(*method) = pb->ClickMethod;
		if( psv )
			(*psv) = pb->ClickData;
	}
}
PSI_CONTROL SetButtonAttributes( PSI_CONTROL pCom, int attr )
{
	// BUTTON_ flags...
	if( attr & BUTTON_NO_BORDER )
		SetCommonBorder( pCom, BORDER_NONE );
	//else
	//	SetCommonBorder( pc, BORDER_DEFAULT_FOR_BUTTON ); // LOL - someday
	{
		ValidatedControlData( PCHECK, RADIO_BUTTON, pc, pCom );
		if( pc )
		{
			if( attr & RADIO_CALL_CHANGED )
				pc->flags.bCallAll = 1;
			else
			{
				if( attr & RADIO_CALL_CHECKED )
					pc->flags.bCallChecked = 1;
				if( attr & RADIO_CALL_UNCHECKED )
					pc->flags.bCallUnchecked = 1;
			}
		}
	}
	return pCom;
}
PSI_CONTROL SetButtonDrawMethod( PSI_CONTROL pc, ButtonPushMethod method, uintptr_t psv )
{
	ValidatedControlData( PBUTTON, NORMAL_BUTTON, pb, pc );
	if( !pb )
	{
		ValidatedControlData( PBUTTON, CUSTOM_BUTTON, pb2, pc );
		if( pb2 )
			pb = pb2;
	}
	if( pb )
	{
		pb->DrawMethod = method;
		pb->DrawData = psv;
	}
	return pc;
}
PSI_CONTROL SetButtonPushMethod( PSI_CONTROL pc, ButtonPushMethod method, uintptr_t psv )
{
	ValidatedControlData( PBUTTON, NORMAL_BUTTON, pb, pc );
	if( !pb )
	{
		ValidatedControlData( PBUTTON, CUSTOM_BUTTON, pb2, pc );
		//lprintf( "Is not a NORMAL_BUTTON" );
		if( pb2 )
			pb = pb2;
		else
		{
			ValidatedControlData( PBUTTON, IMAGE_BUTTON, pb2, pc );
			//lprintf( "Is not a CUSTOM_BUTTON" );
			if( pb2 )
				pb = pb2;
			else
			{
				ValidatedControlData( PCHECK, RADIO_BUTTON, pb2, pc );
				//lprintf( "Is not a CUSTOM_BUTTON" );
				if( pb2 )
				{
					pb2->ClickMethod = method;
					pb2->ClickData = psv;
					return pc;
				}
				else
				{
					//lprintf( "Is not a IMAGE_BUTTON" );
					return pc;
				}
			}
		}
	}
	if( pb )
	{
		pb->ClickMethod = method;
		pb->ClickData = psv;
	}
	return pc;
}
//---------------------------------------------------------------------------
CONTROL_REGISTRATION
normal_button = { NORMAL_BUTTON_NAME
					 , { {73, 21}, sizeof( BUTTON ), BORDER_THIN|BORDER_NOCAPTION }
					 , InitButton
					 , NULL
					 , ButtonDraw
					 , ButtonMouse
					 , ButtonKeyProc
 // destroy ( I have no private dynamic data == NULL )
					 , NULL
 //, GetButtonPropertyPage
					 , NULL
 //, ApplyButtonPropertyPage
					 , NULL
 // save...
					 , ButtonText
 // ButtonLoadProc
					 , NULL
},
image_button = { IMAGE_BUTTON_NAME
					, { {73, 21}, sizeof( BUTTON ), BORDER_THIN|BORDER_NOCAPTION }
// init
					, ConfigureImageButton
					, NULL
					, ButtonDraw
					, ButtonMouse
					, ButtonKeyProc
					, NULL
// getpage
					, NULL
// apply
					, NULL
 // save
					, NULL
 // load
					, NULL
},
custom_button = { CUSTOM_BUTTON_NAME
					 , { {73, 21}, sizeof( BUTTON ), BORDER_THIN|BORDER_NOCAPTION }
					 , ConfigureCustomDrawnButton
					 , NULL
					 , ButtonDraw
					 , ButtonMouse
					 , ButtonKeyProc
					 , NULL
					 , NULL
					 , NULL
 // save...
					 , ButtonText
},
radio_button = { RADIO_BUTTON_NAME
					, { {73, 21}, sizeof( CHECK ) + 100, BORDER_NONE|BORDER_NOCAPTION}
// init
					, ConfigureCheckButton
					, NULL
					, DrawCheckButton
					, MouseCheckButton
					, CheckKeyProc
					, DestroyCheckButton
					, NULL
					, NULL
					, RadioButtonText
};
static int OnCommonFocus( NORMAL_BUTTON_NAME )( PSI_CONTROL pc, LOGICAL bFocus )
{
	SmudgeCommon( pc );
	return 1;
}
PRIORITY_PRELOAD( register_buttons, PSI_PRELOAD_PRIORITY ) {
	GetMyInterface();
 // reverse click on down vs click on up
	buttonControlLocal.flags.bTouchDisplay = IsTouchDisplay();
	DoRegisterControl( &normal_button );
	DoRegisterControl( &image_button );
	DoRegisterControl( &custom_button );
	DoRegisterControl( &radio_button );
}
#undef l
PSI_BUTTON_NAMESPACE_END
//---------------------------------------------------------------------------
// $Log: ctlbutton.c,v $
// Revision 1.68  2005/07/05 17:50:55  d3x0r
// fixes to update local region - esp as related to popup menus
//
// Revision 1.67  2005/06/19 08:08:33  d3x0r
// Fix borders on buttons (somehow becaem border THINNER).  Also fix control update portion... was updating the surface x,y with the control width, height, overflowing...
//
// Revision 1.66  2005/05/25 16:50:18  d3x0r
// Synch with working repository.
//
// Revision 1.79  2005/03/22 12:41:58  panther
// Wow this transparency thing is going to rock! :) It was much closer than I had originally thought.  Need a new class of controls though to support click-masks.... oh yeah and buttons which have roundable scaleable edged based off of a dot/circle
//
// Revision 1.78  2005/03/21 20:41:34  panther
// Protect against super large fonts, remove edit frame from palette, and clean up some warnings.
//
// Revision 1.77  2005/03/07 00:47:01  panther
// Fix image buttons.
//
// Revision 1.22  2003/03/25 08:45:56  panther
// Added CVS logging tag
//
#define _INCLUDE_CLIPBOARD
PSI_NAMESPACE
struct listitem_tag
{
	TEXTCHAR *text;
	PSI_CONTROL within_list;
	uintptr_t data;
	// top == -1 if not show, or not shown yet
	// else top == pixel offset of the top of the item
 // top of the item in the listbox...
	int32_t top;
				// makes for quick rendering of custom items
				// also can use this to push current down
				// when inserting sorted items...
 // height of the line...
	uint32_t height;
 // level of the tree item...
	int nLevel;
	Image icon;
	struct {
		uint32_t bSelected :1;
		uint32_t bFocused  :1;
 // if open, show any items after this +1 level...
		uint32_t bOpen : 1;
	} flags;
	PMENU pPopup;
	void (CPROC*MenuProc)(uintptr_t,struct listitem_tag*,uint32_t);
	uintptr_t psvContextMenu;
	PLISTITEM next, prior;
};
typedef struct listitem_tag LISTITEM;
PSI_NAMESPACE_END
PSI_COMBOBOX_NAMESPACE
struct combobox {
	uint32_t data;
	LOGICAL first_item;
	LOGICAL first_show;
	PRENDERER popup_renderer;
	void (CPROC*OnPopup)( uintptr_t psvPopup, LOGICAL show );
	uintptr_t psvPopup;
	PSI_CONTROL self;
	PSI_CONTROL edit;
	PSI_CONTROL expand_button;
	uint32_t popup_width, popup_height;
	PSI_CONTROL popup_frame;
	PSI_CONTROL popup_frame_listbox;
	SelectionChanged OnSelect;
	uintptr_t psvOnSelect;
};
typedef struct combobox COMBOBOX, *PCOMBOBOX;
static void CPROC HandleLoseFocus( uintptr_t dwUser, PRENDERER pGain )
{
	PCOMBOBOX pcbx = (PCOMBOBOX)dwUser;
	lprintf( "combobox - HandleLoseFocus %p is gaining (we're losing) else we're gaining" , pGain );
	if( pGain && pGain != pcbx->popup_renderer )
	{
		HideControl( pcbx->popup_frame );
		if( pcbx->OnSelect )
			pcbx->OnSelect( pcbx->psvOnSelect, pcbx->self, NULL );
		if( pcbx->OnPopup )
			pcbx->OnPopup( pcbx->psvPopup, FALSE );
	}
}
static void CPROC ExpandButtonEvent(uintptr_t psvCbx, PSI_CONTROL pc )
{
	PCOMBOBOX pcbx = (PCOMBOBOX)psvCbx;
	int32_t x = 0, y = 0;
	SizeFrame( pcbx->popup_frame, pcbx->popup_width, pcbx->popup_height );
	SizeControl( pcbx->popup_frame_listbox, pcbx->popup_width, pcbx->popup_height );
	GetPhysicalCoordinate( pcbx->self, &x, &y, FALSE );
	MoveFrame( pcbx->popup_frame, x, y );
	if( pcbx->OnPopup )
		pcbx->OnPopup( pcbx->psvPopup, TRUE );
	DisplayFrameOver( pcbx->popup_frame, pc );
	if( !pcbx->first_show )
	{
		pcbx->popup_renderer = GetFrameRenderer( pcbx->popup_frame );
		SetLoseFocusHandler( pcbx->popup_renderer, HandleLoseFocus, (uintptr_t)pcbx );
		pcbx->first_show = TRUE;
	}
	//OwnMouse( GetFrameRenderer( pcbx->popup_frame ), TRUE );
	//CaptureCommonMouse( pcbx->popup_frame, TRUE );
	//CommonWait( pcbx->popup_frame );
}
static void PopupSelected( uintptr_t psvCbx, PSI_CONTROL pc, PLISTITEM hli )
{
	PCOMBOBOX pcbx = (PCOMBOBOX)psvCbx;
	TEXTCHAR buf[256];
	//OwnMouse( GetFrameRenderer( pc ), FALSE );
	HideControl( pcbx->popup_frame );
	GetItemText( hli, 256, buf );
	SetControlText( pcbx->edit, (CTEXTSTR)buf );
	if( pcbx->OnPopup )
		pcbx->OnPopup( pcbx->psvPopup, FALSE );
	if( pcbx->OnSelect )
		pcbx->OnSelect( pcbx->psvOnSelect, pcbx->self, hli );
}
static void ExpandButtonDraw( uintptr_t psv, PSI_CONTROL pc)
{
	Image surface = GetControlSurface( pc );
	int n;
	int y = ( surface->height / 2 ) - 3;
	CDATA c = GetControlColor( pc, SHADOW );
	for( n = 0; n < 7; n++ )
	{
		do_hline( surface, y + n, (surface->width/2) - ( 6-n ), (surface->width/2) + ( 6-n ) + 1, c );
	}
}
static int OnCreateCommon( "Combo Box" )( PSI_CONTROL pc )
{
	ValidatedControlData( PCOMBOBOX, COMBOBOX_CONTROL, pcbx, pc );
	Image surface = GetControlSurface( pc );
	pcbx->self = pc;
	pcbx->first_item = TRUE;
	pcbx->expand_button = MakeNamedControl( pc, NORMAL_BUTTON_NAME, surface->width - surface->height, 0, surface->height, surface->height, 0 );
	SetButtonDrawMethod( pcbx->expand_button, ExpandButtonDraw, 0 );
	SetButtonPushMethod( pcbx->expand_button, ExpandButtonEvent, (uintptr_t)pcbx );
	pcbx->edit = MakeNamedControl( pc, EDIT_FIELD_NAME, 0, 0, surface->width - surface->height, surface->height, 0 );
	SetEditControlReadOnly( pcbx->edit, TRUE );
	pcbx->popup_height = surface->width;
	pcbx->popup_width = surface->width;
	pcbx->popup_frame = CreateFrame( NULL, 0, 0, surface->width, surface->width, BORDER_THIN|BORDER_NOCAPTION, NULL );
	pcbx->popup_frame_listbox = MakeNamedControl( pcbx->popup_frame, LISTBOX_CONTROL_NAME, 0, 0, surface->width, surface->height, 0 );
	SetSelChangeHandler( pcbx->popup_frame_listbox, PopupSelected, (uintptr_t)pcbx );
	//ValidatedControlData( PCOMBOBOX, COMBOBOX_CONTROL, pcbx, pc );
	return TRUE;
}
static void OnSizeCommon( "Combo Box" )( PSI_CONTROL pc, LOGICAL start )
{
	ValidatedControlData( PCOMBOBOX, COMBOBOX_CONTROL, pcbx, pc );
	if( !start && pcbx )
	{
		Image surface = GetControlSurface( pc );
		MoveSizeCommon( pcbx->expand_button, surface->width - surface->height, 0, surface->height, surface->height );
		MoveSizeCommon( pcbx->edit, 0, 0, surface->width - surface->height, surface->height );
	}
}
void SetComboBoxPopupSize( PSI_CONTROL pc, uint32_t w, uint32_t h )
{
	ValidatedControlData( PCOMBOBOX, COMBOBOX_CONTROL, pcbx, pc );
	if( pcbx )
	{
		pcbx->popup_width = w;
		pcbx->popup_height = h;
	}
}
void ResetComboBox( PSI_CONTROL pc )
{
	ValidatedControlData( PCOMBOBOX, COMBOBOX_CONTROL, pcbx, pc );
	if( pcbx )
	{
		pcbx->first_item = TRUE;
		ResetList( pcbx->popup_frame_listbox );
		SetControlText( pcbx->edit, NULL );
	}
}
static int OnDrawCommon( "Combo Box" )( PSI_CONTROL pc )
{
	//ValidatedControlData( PCOMBOBOX, COMBOBOX_CONTROL, pcbx, pc );
	return TRUE;
}
CONTROL_REGISTRATION
combobox_control = { COMBOBOX_CONTROL_NAME
					, { {173, 24}, sizeof( COMBOBOX ), BORDER_INVERT_THIN }
};
PRIORITY_PRELOAD( RegisterComboBox, PSI_PRELOAD_PRIORITY )
{
	DoRegisterControl( &combobox_control );
	//RegisterAlias( PSI_ROOT_REGISTRY "/control/" EDIT_FIELD_NAME "/rtti", "psi/control/combobox/rtti" );
}
PLISTITEM AddComboBoxItem( PSI_CONTROL pc, CTEXTSTR text )
{
	ValidatedControlData( PCOMBOBOX, COMBOBOX_CONTROL, pcbx, pc );
	if( pcbx )
	{
		PLISTITEM pli;
		pli = AddListItem( pcbx->popup_frame_listbox, text );
		if( pcbx->first_item )
		{
			pcbx->first_item = FALSE;
			SetControlText( pcbx->edit, text );
			if( pcbx->OnSelect )
				pcbx->OnSelect( pcbx->psvOnSelect, pc, pli );
		}
		return pli;
	}
	return NULL;
}
void SetComboBoxSelChangeHandler( PSI_CONTROL pc, SelectionChanged proc, uintptr_t psvUser )
{
	ValidatedControlData( PCOMBOBOX, COMBOBOX_CONTROL, pcbx, pc );
	if( pcbx )
	{
		pcbx->OnSelect = proc;
		pcbx->psvOnSelect = psvUser;
	}
}
void SetComboBoxPopupEventCallback( PSI_CONTROL pc, void (CPROC*PopupEvent)( uintptr_t,LOGICAL ), uintptr_t psvEvent )
{
	ValidatedControlData( PCOMBOBOX, COMBOBOX_CONTROL, pcbx, pc );
	if( pcbx )
	{
		pcbx->OnPopup = PopupEvent;
		pcbx->psvPopup = psvEvent;
	}
}
void SetComboBoxSelectedItem( PSI_CONTROL pc, PLISTITEM hli )
{
	ValidatedControlData( PCOMBOBOX, COMBOBOX_CONTROL, pcbx, pc );
	if( pcbx )
	{
		SetSelectedItem( pcbx->popup_frame_listbox, hli );
		SetControlText( pcbx->edit, hli->text );
		if( pcbx->OnSelect )
			pcbx->OnSelect( pcbx->psvOnSelect, pc, hli );
	}
}
PSI_COMBOBOX_NAMESPACE_END
#define _INCLUDE_CLIPBOARD
//#include <actimg.h> // alias to device output independance(?)
PSI_EDIT_NAMESPACE
//------------------------------------------------------------------------------
//---------------------------------------------------------------------------
typedef struct edit {
	PSI_CONTROL pc;
	struct {
		BIT_FIELD insert:1;
 // hide data content.
		BIT_FIELD bPassword : 1;
		BIT_FIELD bFocused : 1;
		BIT_FIELD bInternalUpdate : 1;
		BIT_FIELD bReadOnly : 1;
		BIT_FIELD bSelectSet : 1;
		BIT_FIELD bInternalChange : 1;
	}flags;
 // our quick and dirty buffer...
	TEXTCHAR *content;
	size_t nCaptionSize, nCaptionUsed;
	size_t nCaptionDisplayableChars;
	int top_side_pad;
 // first character in edit control
	size_t Start;
 // cursor position
	size_t cursor_pos;
 // cursor position
	size_t cursor_pos_byte;
	size_t MaxShowLen;
	size_t select_anchor;
	size_t select_start, select_end;
} EDIT, *PEDIT;
#define LEFT_SIDE_PAD 2
//---------------------------------------------------------------------------
static CTEXTSTR GetString( PEDIT pe, CTEXTSTR text, size_t length )
{
	static size_t lastlen;
	static TEXTCHAR *temp;
	if( lastlen < length || !temp )
	{
		if( temp )
			Release( temp );
		temp = NewArray( TEXTCHAR, length+1 );
		lastlen = length;
	}
	if( pe->flags.bPassword )
	{
		size_t n;
		for( n = 0; text[n] && n < length; n++ )
		{
			temp[n] = '*';
		}
		temp[n] = 0;
		return temp;
	}
	return text;
}
//---------------------------------------------------------------------------
static int OnDrawCommon( EDIT_FIELD_NAME )( PSI_CONTROL pc )
{
	ValidatedControlData( PEDIT, EDIT_FIELD, pe, pc );
	SFTFont font;
	size_t ofs;
	int x, CursX;
	CTEXTSTR caption_text = GetText( pc->caption.text);
	CTEXTSTR output_string;
	int *stringsize;
	uint32_t height;
	BlatColorAlpha( pc->Surface, 0, 0, pc->surface_rect.width, pc->surface_rect.height, basecolor(pc)[EDIT_BACKGROUND] );
	//ClearImageTo( pc->Surface, basecolor(pc)[EDIT_BACKGROUND] );
	font = GetFrameFont( pc );
	// should probably figure some way to center the text vertical also...
	stringsize = NewArray( int, pe->nCaptionUsed + 1 );
	{
		int n;
		if( pe->flags.bPassword )
		{
			uint32_t w, h;
			GetStringSizeFontEx( "*", 1, &w, &h, font );
			for( n= 0; SUS_LTE( n, int, pe->nCaptionUsed, size_t ); n++ )
			{
				stringsize[n] = w * n;
			}
			height = h;
		}
		else
		{
			uint32_t w, h;
			for( n = 0; SUS_LTE( n, int, pe->nCaptionUsed, size_t ); n++ )
			{
				stringsize[n] = GetStringSizeFontEx(caption_text
					, GetDisplayableCharacterBytes( caption_text, n)
					, &w, &h, font );
				//lprintf( "size at %d = %d", n, stringsize[n] );
			}
			height = h;
		}
	}
	{
		int n;
		int	start_pos = (pe->Start?stringsize[pe->Start-1]:0);
		if( pe->cursor_pos )
		{
			// current
			if( ( stringsize[ pe->cursor_pos - 1 ]
			     - start_pos ) < 0 )
			{
				//lprintf( "cursor is off the left..." );
				pe->Start = pe->cursor_pos - 1;
			}
			if( ( stringsize[ pe->cursor_pos ]
			     - start_pos )
					 >= (int)( ( pc->surface_rect.width * 4 ) / 5 )  )
			{
				//lprintf( "cursor is off the right..." );
				for( n = (int)pe->cursor_pos; n; n-- )
				{
					if( ( stringsize[pe->cursor_pos] - stringsize[n] ) > (int)((pc->surface_rect.width *4)/ 5) )
					{
						//lprintf( "New start : %d", pe->Start );
						pe->Start = n+1;
						break;
					}
				}
			}
		}
		else
		{
			pe->Start = 0;
		}
		start_pos = (pe->Start?stringsize[pe->Start-1]:0);
		pe->MaxShowLen = GetDisplayableCharacterCount( caption_text, -1 );
		for( n = (int)pe->Start; n <= (int)pe->nCaptionUsed; n++ )
		{
			if( ( stringsize[n] - start_pos ) > (int)pc->surface_rect.width )
			{
				pe->MaxShowLen = ( n - 1 ) - pe->Start;
				break;
			}
		}
		//lprintf( "Max is %d %d", pe->MaxShowLen, pe->Start );
	}
	//pe->MaxShowLen = GetMaxStringLengthFont( pc->surface_rect.width, font );
	//lprintf( "drawing %d,%d,%d,%d", pe->Start, pe->cursor_pos, pe->MaxShowLen );
	output_string = GetString( pe, caption_text + pe->Start, pe->cursor_pos-pe->Start );
	CursX = (pe->cursor_pos?stringsize[pe->cursor_pos]:0) - (pe->Start?stringsize[pe->Start]:0);
	Release( stringsize );
	if( USS_LTE( height, uint32_t, pc->Surface->height, int ) )
		pe->top_side_pad = (pc->Surface->height - height) / 2;
	else
		pe->top_side_pad = 0;
	//lprintf( "------- CURSX = %d --- ", CursX );
	CursX += LEFT_SIDE_PAD;
	ofs = 0;
	x = LEFT_SIDE_PAD;
	// yuck - need to ... do this and that and the other...
	// if something is selected...
	if( pe->nCaptionUsed )
	{
		size_t nBytes;
		CTEXTSTR tmp;
		CTEXTSTR string;
		string = GetString( pe, GetText( pc->caption.text), pe->nCaptionUsed );
		//lprintf( "Caption used... %d %d %d"
		//		 , pc->flags.bFocused
		//		 , pe->select_start
		//		 , pe->select_end);
		if( pc->flags.bFocused && pe->flags.bSelectSet )
		{
			// this is a working copy of this variable
			// that steps through the ranges of marked-ness
			size_t Start = pe->Start;
			do
			{
				size_t nLen;
				// translate characters into *'s if password
				//lprintf( "%d %d %d", Start, pe->select_start, pe->select_end );
				if( !pe->flags.bSelectSet || ( Start < pe->select_start ) )
				{
					if( pe->flags.bSelectSet && ( pe->select_start - Start < pe->MaxShowLen ) )
						nLen = pe->select_start - Start;
					else
						nLen = pe->MaxShowLen - ofs;
					tmp = GetDisplayableCharactersAtCount( string, Start );
					nBytes = GetDisplayableCharacterBytes( tmp, nLen );
					//lprintf( "Showing %d of string in normal color before select...", nLen );
					PutStringFontEx( pc->Surface, x, pe->top_side_pad
											 , basecolor(pc)[EDIT_TEXT], basecolor(pc)[EDIT_BACKGROUND]
									, tmp, nBytes, font );
					x += GetStringSizeFontEx( tmp, nBytes, NULL, NULL, font );
				}
 // beyond the end of the display
				else if( Start > pe->select_end )
				{
					tmp = GetDisplayableCharactersAtCount( string, Start );
					nLen = pe->MaxShowLen - ofs;
					//lprintf( "Showing %d of string in normal color after select...", nLen );
					nBytes = GetDisplayableCharacterBytes( tmp, nLen );
					PutStringFontEx( pc->Surface, x, pe->top_side_pad
											 , basecolor(pc)[EDIT_TEXT], basecolor(pc)[EDIT_BACKGROUND]
											 , tmp, nBytes, font );
					x += GetStringSizeFontEx( tmp, nBytes, NULL, NULL, font );
				}
 // start is IN select start to select end...
				else
				{
					if( ( ofs + pe->select_end - Start ) < pe->MaxShowLen )
					{
						nLen = pe->select_end - Start + 1;
					}
					else
						nLen = pe->MaxShowLen - ofs;
					//lprintf( "Showing %d of string in selected color...", nLen );
					tmp = GetDisplayableCharactersAtCount( string, Start );
					nBytes = GetDisplayableCharacterBytes( tmp, nLen );
					PutStringFontEx( pc->Surface, x, pe->top_side_pad
											 , basecolor(pc)[SELECT_TEXT], basecolor(pc)[SELECT_BACK]
											 , tmp, nBytes, font );
					x += GetStringSizeFontEx( tmp, nBytes, NULL, NULL, font );
				}
				Start += nLen;
				ofs += nLen;
			} while( ofs < pe->MaxShowLen );
		}
		else
		{
			tmp = GetDisplayableCharactersAtCount( string, pe->Start );
			nBytes = GetDisplayableCharacterBytes( tmp, pe->MaxShowLen );
			PutStringFontEx( pc->Surface, x, pe->top_side_pad
								, basecolor(pc)[EDIT_TEXT], basecolor(pc)[EDIT_BACKGROUND]
								, tmp
								, nBytes
								, font
								);
			x += GetStringSizeFontEx( tmp, nBytes, NULL, NULL, font );
		}
	}
	//else
	//   lprintf( "NO caption used.") ;
	if( pc->flags.bFocused )
	{
		//lprintf( "Have focus in edit control - drawing cursor thingy at %d", CursX );
		do_line( pc->Surface, CursX
				 , 1
				 , CursX
				 , pc->surface_rect.height - 2
				 , Color( 255,255,255 ) );
		do_line( pc->Surface, CursX+1
				 , 1
				 , CursX+1
				 , pc->surface_rect.height - 2
				 , Color( 0,0,0 ) );
		do_line( pc->Surface, CursX-1
				 , 1
				 , CursX-1
				 , pc->surface_rect.height - 2
				 , Color( 0,0,0 ) );
	}
	//else
	//   lprintf( "have NO focus in edit control, not drawing anything..." );
	return TRUE;
}
//---------------------------------------------------------------------------
static int OnMouseCommon( EDIT_FIELD_NAME )( PSI_CONTROL pc, int32_t x, int32_t y, uint32_t b )
{
	static int _b;
	ValidatedControlData( PEDIT, EDIT_FIELD, pe, pc );
	int cx, cy;
	int found = 0;
	size_t len = pc->caption.text ? GetTextSize( pc->caption.text ) : 0;
	uint32_t width, _width = 0, height;
	LOGICAL moving_left, moving_right;
	SFTFont font = GetCommonFont( pc );
	//lprintf( "Edit mosue: %d %d %X", x, y, b );
	GetStringSizeFont( GetText(pc->caption.text), &width, &height, font );
	// how to find the line/character we're interested in....
	if( height )
		cy = (y - pe->top_side_pad) / height;
	else
		cy = 0;
	if( x < LEFT_SIDE_PAD )
	{
		found = 1;
		cx = -1;
	}
	else
	{
		CTEXTSTR caption_text = GetText( pc->caption.text);
		//cx = ( x - LEFT_SIDE_PAD ) / characters...
		// so given any font - variable size, we have to figure out which
		// character is on this line...
		if( len > pe->Start )
		{
			CTEXTSTR tmp_offset_caption_text = GetDisplayableCharactersAtCount( caption_text, pe->Start );
			for( cx = 1; ( SUS_LTE( cx, int, ( len - pe->Start ), size_t ) ); cx++ )
			{
				if( GetStringSizeFontEx( tmp_offset_caption_text
								, GetDisplayableCharacterBytes( tmp_offset_caption_text, cx ), &width, NULL, font ) )
				{
					//lprintf( "is %*.*s(%d) more than %d?"
					//		 , cx,cx,GetText(pc->caption.text)
					//		 , width
					//		 , x );
					if( USS_GT(( width + LEFT_SIDE_PAD ),uint32_t, x,int32_t) )
					{
						// left 1/3 of the currnet character sets the cursor to the left
						// of the character, otherwise cursor is set on(after) the
						// current character.
						// OOP! - previously this test was backwards resulting in seemingly
						// very erratic cursor behavior..
						if( ((width+LEFT_SIDE_PAD)-x) > (width - _width)/3 )
							cx = cx-1;
						//lprintf( "Why yes, yes it is." );
						found = 1;
						break;
					}
				}
				_width = width;
			}
		}
	}
	// cx will be strlen + 1 if past end
	// cx is 0 at beginning.
	if( !found )
	{
		cx = (int)len - (int)pe->Start;
		// cx max...
		//lprintf( "Past end of string..." );
	}
	moving_left = 0;
	moving_right = 0;
	if( b & MK_LBUTTON )
	{
		if( (cx+(int)pe->Start) >= 0 )
			if( pe->cursor_pos != (cx+pe->Start) )
			{
				// this updates the current cursor position.
				// this works very well.... (now)
				if( pe->cursor_pos > (cx+pe->Start) )
					moving_left = 1;
				else
					moving_right = 1;
				pe->cursor_pos = cx + pe->Start;
				SmudgeCommon( pc );
			}
	}
	{
		//lprintf( "current character: %d %d", cx, cy );
	}
	//lprintf( "alright we have %d,%d,%d,%d", pe->select_anchor, pe->Start, pe->select_start, cx );
	if( b & MK_LBUTTON )
	{
		//cx -= 1;
		if( !( _b & MK_LBUTTON ) )
		{
			// we're not really moving, we just started...
			pe->flags.bSelectSet = 0;
			moving_left = moving_right = 0;
			if( (cx+(int)pe->Start) >= 0 )
				if( (cx + pe->Start) < len )
				{
					//lprintf( "Setting select start, end at %d,%d,%d", cx + pe->Start, cx, pe->Start );
					pe->select_anchor = cx + pe->Start;
				}
				else
				{
					//lprintf( "Setting select start, end at %d,%d", len-1, len-1 );
					pe->select_anchor = len;
				}
			//lprintf( "--- Setting begin and end... hmm first button I guess Select..." );
			SmudgeCommon( pc );
		}
		else
		{
			//lprintf( "still have that mouse button down.... %d,%d,%d", moving_left, moving_right, cx );
			if( moving_left || moving_right )
			{
				if( (cx+(int)pe->Start) >= 0 )
					if( (cx+pe->Start) < pe->select_anchor )
					{
						pe->flags.bSelectSet = 1;
						pe->select_start = cx + pe->Start;
						pe->select_end = pe->select_anchor - 1;
					}
					else
					{
						pe->flags.bSelectSet = 1;
						pe->select_end = cx + pe->Start;
						pe->select_start = pe->select_anchor;
					}
				SmudgeCommon( pc );
			}
		}
	}
	_b = b;
	return 1;
}
//---------------------------------------------------------------------------
void CutEditText( PEDIT pe, PTEXT *caption )
{
	// any selected text is now deleted... the buffer is shortened...
	if( pe->flags.bSelectSet )
	{
		if( pe->select_end < GetTextSize( *caption ) )
		{
			pe->nCaptionUsed -= (pe->select_end - pe->select_start) + 1;
			if( pe->nCaptionUsed && pe->nCaptionUsed > pe->select_start )
			{
				MemCpy( GetText( *caption ) + pe->select_start
				      , GetText( *caption ) + pe->select_end+1
				      , pe->nCaptionUsed - pe->select_start );
				SetTextSize( *caption, pe->nCaptionUsed );
				GetText( *caption )[pe->nCaptionUsed] = 0;
			}
			else
			{
				SetTextSize( *caption, pe->nCaptionUsed );
				GetText( *caption )[pe->select_start] = 0;
			}
			pe->nCaptionDisplayableChars = GetDisplayableCharacterCount( GetText( *caption ), -1 );
			pe->cursor_pos = pe->select_start;
			if( pe->cursor_pos < pe->Start ) {
				pe->Start = pe->cursor_pos;
			}
		}
	}
	pe->flags.bSelectSet = 0;
}
static void InsertAChar( PEDIT pe, PTEXT *caption, TEXTCHAR ch )
{
	if( (pe->nCaptionUsed) >= pe->nCaptionSize )
	{
		PTEXT newtext;
		pe->nCaptionSize += 16;
		newtext = SegCreate( pe->nCaptionSize + 1 );
		StrCpyEx( GetText( newtext ), GetText( *caption )
 // include the NULL, the buffer will be large enough.
				 , (pe->nCaptionUsed+1) );
		SetTextSize( newtext, pe->nCaptionUsed );
		GetText( newtext )[pe->nCaptionUsed] = 0;
		LineRelease( *caption );
		*caption = newtext;
	}
	{
		size_t n;
		size_t cursor_bytes = pe->cursor_pos_byte;
		pe->nCaptionUsed++;
		for( n = pe->nCaptionUsed; ( n > cursor_bytes ); n-- )
		{
			GetText( *caption )[n] =
				GetText( *caption )[n-1];
		}
		GetText( *caption )[pe->cursor_pos_byte] = ch;
		pe->nCaptionDisplayableChars = GetDisplayableCharacterCount( GetText( *caption ), -1 );
		pe->cursor_pos_byte++;
	}
	SetTextSize( *caption, pe->nCaptionUsed );
}
void TypeIntoEditControl( PSI_CONTROL pc, CTEXTSTR text )
{
	ValidatedControlData( PEDIT, EDIT_FIELD, pe, pc );
	if( pc && pe )
	{
		int start_pos = (int)pe->cursor_pos_byte;
		if( pe->flags.bSelectSet )
			CutEditText( pe, &pc->caption.text );
		pe->cursor_pos_byte = GetDisplayableCharacterBytes( GetText( pc->caption.text ), pe->cursor_pos );
		while( text[0] )
		{
			InsertAChar( pe, &pc->caption.text, text[0] );
			text++;
		}
		pe->cursor_pos += GetDisplayableCharacterCount( GetText( pc->caption.text ) + start_pos
			, pe->cursor_pos_byte - start_pos );
		pe->flags.bInternalChange = 1;
		if( pc->CaptionChanged )
			pc->CaptionChanged( pc );
		pe->flags.bInternalChange = 0;
	}
	SmudgeCommon( pc );
}
//---------------------------------------------------------------------------
#ifdef _WIN32
static void GetMarkedText( PEDIT pe, PTEXT *caption, TEXTCHAR *buffer, size_t nSize )
{
	CTEXTSTR tmp;
	size_t bytes;
	if( pe->flags.bSelectSet )
	{
		if( USS_GT( nSize, size_t, (pe->select_end - pe->select_start) + 1, int ) )
		{
			nSize = (pe->select_end - pe->select_start) + 1;
		}
		else
 // leave room for the nul.
			nSize--;
		// otherwise nSize is maximal copy or correct amount to copy
		tmp = GetDisplayableCharactersAtCount( GetText( *caption ), pe->select_start );
		MemCpy( buffer
			, tmp
				, bytes = GetDisplayableCharacterBytes( tmp, nSize ) );
 // set nul terminator.
		buffer[bytes] = 0;
	}
	else
	{
		tmp = GetDisplayableCharactersAtCount( GetText( *caption ), pe->select_start );
		MemCpy( buffer
				, GetText( *caption ) + pe->select_start
				, bytes = GetDisplayableCharacterBytes( tmp, nSize )  );
 // set nul terminator.
		buffer[bytes] = 0;
	}
}
//---------------------------------------------------------------------------
static void Paste( PEDIT pe, PTEXT *caption )
{
	if( OpenClipboard(NULL) )
	{
		uint32_t format = 0;
		LOGICAL get_unicode = 0;
		// successful open...
		for( format = EnumClipboardFormats( format ); format; format =  EnumClipboardFormats( format ) )
			if( format == CF_UNICODETEXT )
				get_unicode = 1;
		format = EnumClipboardFormats( format );
		pe->cursor_pos_byte = GetDisplayableCharacterBytes( GetText( *caption ), pe->cursor_pos );
		if( pe->flags.bSelectSet )
			CutEditText( pe, caption );
		while( format )
		{
			if( format == CF_UNICODETEXT )
			{
				HANDLE hData = GetClipboardData( CF_UNICODETEXT );
				wchar_t *pData = (wchar_t*)GlobalLock( hData );
				{
					TEXTCHAR *_utf_8;
					TEXTCHAR *utf_8 = DupWideToText( pData );
					_utf_8 = utf_8;
					while( utf_8 && utf_8[0] )
					{
						InsertAChar( pe, caption, utf_8[0] );
						utf_8++;
					}
					pe->cursor_pos_byte = GetDisplayableCharacterBytes( GetText( *caption ), pe->cursor_pos );
					Release( _utf_8 );
				}
				break;
			}
			if( format == CF_TEXT && !get_unicode )
			{
				HANDLE hData = GetClipboardData( CF_TEXT );
				char *pData = (char*)GlobalLock( hData );
				{
					while( pData && pData[0] )
					{
						InsertAChar( pe, caption, pData[0] );
						pData++;
					}
					pe->cursor_pos_byte = GetDisplayableCharacterBytes( GetText( *caption ), pe->cursor_pos );
				}
				break;
			}
			format = EnumClipboardFormats( format );
		}
		CloseClipboard();
	}
	else
	{
		//DECLTEXT( msg, "Clipboard was not available" );
		//EnqueLink( &pdp->ps->Command->Output, &msg );
	}
}
//---------------------------------------------------------------------------
static void Copy( PEDIT pe, PTEXT *caption )
{
	TEXTCHAR data[1024];
	GetMarkedText( pe, caption, data, sizeof( data ) );
#ifndef UNDER_CE
	if( data[0] && OpenClipboard(NULL) )
	{
		size_t nLen = strlen( data ) + 1;
		HGLOBAL mem;
		EmptyClipboard();
		{
			wchar_t *unicode = DupTextToWide( data );
			int c;
			HGLOBAL mem;
			for( c = 0; unicode[c]; c++ );
			mem = GlobalAlloc(
	#ifndef _ARM_
				GMEM_MOVEABLE
	#else
					0
	#endif
				, (c+1) * sizeof( wchar_t ) );
			MemCpy( GlobalLock( mem ), unicode, (c+1) * sizeof( wchar_t ) );
			GlobalUnlock( mem );
			SetClipboardData( CF_UNICODETEXT, mem );
			//GlobalFree( mem );
		}
		mem = GlobalAlloc(
#ifndef _ARM_
			GMEM_MOVEABLE
#else
				0
#endif
			, nLen );
		MemCpy( GlobalLock( mem ), data, nLen );
		GlobalUnlock( mem );
		SetClipboardData( CF_TEXT, mem );
		//GlobalFree( mem );	CloseClipboard();
	}
#endif
}
//---------------------------------------------------------------------------
static void Cut( PEDIT pe, PTEXT *caption )
{
	Copy( pe, caption );
	if( pe->flags.bSelectSet )
		CutEditText( pe, caption );
	else
		SetControlText( (PSI_CONTROL)pe, NULL );
}
#endif
static int OnKeyCommon( EDIT_FIELD_NAME )( PSI_CONTROL pc, uint32_t key )
{
	ValidatedControlData( PEDIT, EDIT_FIELD, pe, pc );
	int used_key = 0;
	int updated = 0;
	const TEXTCHAR *ch;
	LOGICAL handled = FALSE;
	if( !pe || pe->flags.bReadOnly )
	{
		return 0;
	}
	if( KEY_CODE(key) == KEY_TAB ) {
		return 0;
	}
	if( key & KEY_PRESSED )
	{
		if( key & KEY_CONTROL_DOWN && !( key & (KEY_ALT_DOWN|KEY_SHIFT_DOWN) )  )
		{
			switch( KEY_CODE( key ) )
			{
#ifdef _WIN32
			case KEY_C:
				Copy( pe, &pc->caption.text );
				SmudgeCommon( pc );
				handled = TRUE;
				break;
			case KEY_X:
				Cut( pe, &pc->caption.text );
				SmudgeCommon( pc );
				handled = TRUE;
				break;
			case KEY_V:
				Paste( pe, &pc->caption.text );
				SmudgeCommon( pc );
				handled = TRUE;
				break;
#endif
			}
		}
		if( !handled )
		switch( KEY_CODE( key ) )
		{
		case KEY_LEFT:
			{
				size_t oldpos = pe->cursor_pos;
				if( pe->cursor_pos )
				{
					pe->cursor_pos--;
					if( ! ( key & KEY_SHIFT_DOWN ) )
					{
						pe->flags.bSelectSet = 0;
					}
					else
					{
						if( pe->flags.bSelectSet )
						{
							if( oldpos == pe->select_start )
								pe->select_start--;
							else if( pe->cursor_pos == pe->select_end )
								pe->select_end--;
							else
							{
								pe->select_start =
									pe->select_end = pe->cursor_pos;
								pe->flags.bSelectSet = 1;
							}
							if( pe->select_start > pe->select_end )
								pe->flags.bSelectSet = 0;
						}
						else
						{
							if( oldpos > 0 )
							{
								pe->select_start =
									pe->select_end = oldpos-1;
								pe->flags.bSelectSet = 1;
							}
						}
					}
					SmudgeCommon( pc );
				}
				used_key = 1;
				break;
			}
		case KEY_RIGHT:
			{
				size_t oldpos = pe->cursor_pos;
				if( pe->cursor_pos < pe->nCaptionDisplayableChars )
				{
					pe->cursor_pos++;
					if( !(key & KEY_SHIFT_DOWN ) )
					{
						pe->flags.bSelectSet = 0;
					}
					else
					{
						if( pe->flags.bSelectSet )
						{
							if( oldpos == (pe->select_end+1) )
							{
								pe->select_end++;
							}
							else if( oldpos == pe->select_start )
								pe->select_start++;
							else
							{
								pe->select_start =
									pe->select_end = oldpos;
								pe->flags.bSelectSet = 1;
							}
							if( pe->select_start > pe->select_end )
								pe->flags.bSelectSet = 0;
						}
						else
						{
							pe->select_start =
								pe->select_end = oldpos;
							pe->flags.bSelectSet = 1;
						}
					}
					SmudgeCommon( pc );
				}
				else
					pe->cursor_pos = pe->nCaptionDisplayableChars;
				used_key = 1;
				break;
			}
#ifndef __ANDROID__
		case KEY_END:
			if( key & KEY_SHIFT_DOWN )
			{
				if( !pe->flags.bSelectSet )
				{
					pe->select_start = pe->cursor_pos;
					pe->flags.bSelectSet = 1;
				}
				else
				{
					if( pe->select_end == pe->cursor_pos )
					{
					}
					else if( pe->select_start == pe->cursor_pos )
					{
						pe->select_start = pe->select_end;
					}
					else
					{
						pe->select_start = pe->cursor_pos;
					}
				}
				pe->select_end = pe->nCaptionDisplayableChars-1;
			}
			else
			{
				pe->flags.bSelectSet = 0;
			}
			pe->cursor_pos = pe->nCaptionDisplayableChars;
			SmudgeCommon( pc );
			used_key = 1;
			break;
		case KEY_HOME:
			if( key & KEY_SHIFT_DOWN )
			{
				if( pe->select_start == pe->cursor_pos )
				{
				}
				else if(  pe->select_end == pe->cursor_pos )
				{
					pe->select_end = pe->select_start;
				}
				else
				{
					pe->select_end = pe->cursor_pos-1;
				}
				pe->flags.bSelectSet = 1;
				pe->select_start = 0;
			}
			else
			{
				pe->flags.bSelectSet = 0;
			}
			pe->cursor_pos = 0;
			pe->Start = 0;
			SmudgeCommon( pc );
			used_key = 1;
			break;
		case KEY_DELETE:
			if( pe->flags.bSelectSet )
			{
				updated = 1;
				CutEditText( pe, &pc->caption.text );
			}
			else
			{
				pe->flags.bSelectSet = 1;
				pe->select_end =
					pe->select_start = pe->cursor_pos;
				CutEditText( pe, &pc->caption.text );
				updated = 1;
			}
			pe->flags.bInternalChange = 1;
			if( pc->CaptionChanged )
				pc->CaptionChanged( pc );
			pe->flags.bInternalChange = 0;
			if( updated )
				SmudgeCommon( pc );
			used_key = 1;
			break;
#endif
		case KEY_BACKSPACE:
			//Log( "Backspace?!" );
			if( pe->flags.bSelectSet )
			{
				updated = 1;
				CutEditText( pe, &pc->caption.text );
			}
			else
			{
				if( pe->cursor_pos )
				{
					pe->flags.bSelectSet = 1;
					pe->select_end =
						pe->select_start = pe->cursor_pos-1;
					CutEditText( pe, &pc->caption.text );
					updated = 1;
				}
			}
			pe->flags.bInternalChange = 1;
			if( pc->CaptionChanged )
				pc->CaptionChanged( pc );
			pe->flags.bInternalChange = 0;
			if( updated )
				SmudgeCommon( pc );
			used_key = 1;
			break;
#ifndef __ANDROID__
		case KEY_ESCAPE:
			InvokeDefault( (PSI_CONTROL)pc, INV_CANCEL );
			used_key = 1;
			break;
#endif
		case KEY_ENTER:
			InvokeDefault( (PSI_CONTROL)pc, INV_OKAY );
			used_key = 1;
			break;
		default:
			ch = GetKeyText( key );
			if( ch )
			{
				if( (unsigned char)ch[0] == 0xFF )
					ch = 0;
				pe->cursor_pos_byte = GetDisplayableCharacterBytes( GetText( pc->caption.text ), pe->cursor_pos );
				TypeIntoEditControl( pc, ch );
				pe->cursor_pos = GetDisplayableCharacterCount( GetText( pc->caption.text ), pe->cursor_pos_byte );
				SmudgeCommon( pc );
				//printf( "Key: %d(%c)\n", ch,ch );
				used_key = 1;
			}
			break;
		}
	}
	return used_key;
}
//---------------------------------------------------------------------------
PSI_CONTROL SetEditControlReadOnly( PSI_CONTROL pc, LOGICAL bEnable )
{
	ValidatedControlData( PEDIT, EDIT_FIELD, pe, pc );
	if( pe )
	{
		//lprintf( "Setting readonly attribut of control to %d", bEnable );
		pe->flags.bReadOnly = bEnable;
	}
	return pc;
}
//---------------------------------------------------------------------------
PSI_CONTROL SetEditControlPassword( PSI_CONTROL pc, LOGICAL bEnable )
{
	ValidatedControlData( PEDIT, EDIT_FIELD, pe, pc );
	if( pe )
	{
		//lprintf( "Setting readonly attribut of control to %d", bEnable );
		pe->flags.bPassword = bEnable;
	}
	return pc;
}
//---------------------------------------------------------------------------
static void OnChangeCaption( EDIT_FIELD_NAME )( PSI_CONTROL pc )
{
	ValidatedControlData( PEDIT, EDIT_FIELD, pe, pc );
	if( pe->flags.bInternalChange )
		return;
	if( !pc->caption.text )
	{
		pc->caption.text = SegCreate(1);
		SetTextSize( pc->caption.text, 0 );
	}
	if( GetTextSize( pc->caption.text ) )
//GetDisplayableCharacterCount( GetText( pc->caption.text ) );
		pe->cursor_pos = 0;
	else
		pe->cursor_pos = 0;
	pe->nCaptionSize = GetTextSize( pc->caption.text );
	pe->nCaptionUsed = pe->nCaptionSize;
	pe->nCaptionDisplayableChars = GetDisplayableCharacterCount( GetText( pc->caption.text ), -1 );
	// cursor set at end of line, but set position of string at 0...
	// select
	pe->Start = 0;
	pe->flags.bSelectSet = 1;
	pe->select_start = 0;
	pe->select_end = pe->nCaptionDisplayableChars-1;
	SmudgeCommon(pc);
}
void SetEditControlSelection( PSI_CONTROL pc, int start, int end ) {
	ValidatedControlData( PEDIT, EDIT_FIELD, pe, pc );
	if( pe ) {
		pe->select_start = start;
		if( end < 0 )
			pe->select_end = pe->nCaptionDisplayableChars - 1;
		else
			pe->select_end = end;
		pe->flags.bSelectSet = 1;
	}
}
//---------------------------------------------------------------------------
static int OnCommonFocus( EDIT_FIELD_NAME )( PSI_CONTROL pc, LOGICAL bFocused )
{
	ValidatedControlData( PEDIT, EDIT_FIELD, pe, pc );
	if( pe )
	{
		//lprintf( "Setting active focus here!" );
#ifdef __ANDROID__
		if( bFocused )
			SACK_Vidlib_ShowInputDevice();
		else
			SACK_Vidlib_HideInputDevice();
#endif
		pe->flags.bFocused = bFocused;
		if( pe->flags.bFocused )
		{
			size_t len = pc->caption.text ? GetDisplayableCharacterCount( GetText( pc->caption.text ), -1 ) : 0;
			pe->flags.bSelectSet = 1;
			pe->select_start = 0;
			pe->select_end = len - 1;
			pe->select_anchor = 0;
			pe->cursor_pos = len;
		}
		SmudgeCommon( pc );
	}
	return TRUE;
}
//---------------------------------------------------------------------------
#undef MakeEditControl
int CPROC InitEditControl( PSI_CONTROL pControl );
int CPROC ConfigEditControl( PSI_CONTROL pc )
{
	return InitEditControl(pc);
}
PSI_CONTROL CPROC MakeEditControl( PSI_CONTROL pFrame, int attr
									  , int x, int y, int w, int h
									  , uint32_t nID, TEXTCHAR *caption )
{
	return VMakeCaptionedControl( pFrame, EDIT_FIELD
										 , x, y, w, h
										 , nID, caption );
}
#define MakeEditControl(f,x,y,w,h,id,t,a) SetEditControlPassword( SetEditControlReadOnly( MakeCaptionedControl( f,EDIT_FIELD,x,y,w,h,id,t )	 , ( a & EDIT_READONLY)?TRUE:FALSE )	   , ( a & EDIT_PASSWORD)?TRUE:FALSE )
LOGICAL CPROC GrabFilename( PSI_CONTROL pc, CTEXTSTR name, int32_t x, int32_t y )
{
	SetControlText( pc, name );
	return TRUE;
}
int CPROC InitEditControl( PSI_CONTROL pc )
{
	ValidatedControlData( PEDIT, EDIT_FIELD, pe, pc );
	if( pe )
	{
		pe->pc = pc;
		AddCommonAcceptDroppedFiles( pc, GrabFilename );
		return TRUE;
	}
	return FALSE;
}
static int OnCreateCommon( EDIT_FIELD_NAME )( PSI_CONTROL pc )
{
	return InitEditControl( pc );
}
CONTROL_REGISTRATION
edit_control = { EDIT_FIELD_NAME
					, { {73, 21}, sizeof( EDIT ), BORDER_INVERT_THIN|BORDER_NOCAPTION }
 // InitEditControl
					, NULL
					, NULL
 //DrawEditControl
					, NULL
 //MouseEditControl
					, NULL
 //KeyEditControl
					, NULL
};
PRIORITY_PRELOAD( RegisterEdit, PSI_PRELOAD_PRIORITY )
{
	DoRegisterControl( &edit_control );
}
PSI_EDIT_NAMESPACE_END
/* basic image control - show a scaled image in the control space, no border */
#define _INCLUDE_CLIPBOARD
struct image_display {
	Image image;
};
typedef struct image_display IMAGE_DISPLAY, *PIMAGE_DISPLAY;
CONTROL_REGISTRATION
image_display_control = { IMAGE_DISPLAY_CONTROL_NAME
					, { { 64, 64}, sizeof( IMAGE_DISPLAY ), BORDER_NONE }
};
PRIORITY_PRELOAD( RegisterImageDisplay, PSI_PRELOAD_PRIORITY )
{
	DoRegisterControl( &image_display_control );
}
static int OnCreateCommon( IMAGE_DISPLAY_CONTROL_NAME )( PSI_CONTROL pc )
{
	SetCommonTransparent( pc, TRUE );
	return 1;
}
static int OnDrawCommon( IMAGE_DISPLAY_CONTROL_NAME )( PSI_CONTROL pc )
{
	ValidatedControlData( PIMAGE_DISPLAY, image_display_control.TypeID, image, pc );
	if( image )
	{
		Image surface = GetControlSurface( pc );
		BlotScaledImage( surface, image->image );
	}
	return 1;
}
void SetImageControlImage( PSI_CONTROL pc, Image show_image )
{
	ValidatedControlData( PIMAGE_DISPLAY, image_display_control.TypeID, image, pc );
	if( image )
	{
		image->image = show_image;
	}
}
#define LISTBOX_SOURCE
PSI_LISTBOX_NAMESPACE
// derefecing NULL pointers; the function wouldn't be called with a NULL.
// and partial expressions in lower precision
#pragma warning( disable:6011 26451)
typedef struct listcolumn_tag LISTCOL, *PLISTCOL;
struct listcolumn_tag
{
	struct {
		// this column label is meant ot be vertical.
		BIT_FIELD bVertical : 1;
	} flags;
	CTEXTSTR header;
 // previously stop (tab stop)
	int position;
};
struct listboxTabStops {
	int nTabstops;
	int* pTabstops;
};
typedef struct listbox_tag
{
	//uint32_t attr;
	Image  ListSurface;
 // first item
	PLISTITEM items
 // last item
				, last
  // this is the first line shown - always
				, header
 // current (focus cursor on this)
				, current
 // first item shown
				, firstshown
  // last item shown
				, lastshown
 // item the mouse first clicked on (for popup menu support)
				, mouseon
 // first item selected for shift-click multi-select
				, first_selected;
 // last state - used for dispatch item (which if deleted, needs to not resend)
	PLISTITEM _pli;
	struct {
 // alternative multiple selections can be made
		uint32_t bSingle : 1;
		uint32_t bDestroying : 1;
		uint32_t bNoUpdate : 1;
		uint32_t bTree : 1;
		uint32_t bInitial : 1;
 // sort least to most (top is least, bottom is most )
		uint32_t bSortNormal : 1;
		uint32_t bVertical_Column_abels : 1;
		uint32_t bSizable_Columns : 1;
		uint32_t bSortable_Columns : 1;
 // just click on item toggles state.
		uint32_t bLazyMulti : 1;
		uint32_t bHorizontalScroll : 1;
	} flags;
	PSI_CONTROL pcScroll;
	PSI_CONTROL pcHScroll;
	int nLastLevel;
	int TimeLastClick;
 // old mouse info;
	int x, y, b;
	struct listboxTabStopLevels {
		int count;
		struct listboxTabStops *tabStops;
	} tabStops;
  // horizontal scroll affect
	int nXOffset;
	SelectionChanged SelChangeHandler;
	uintptr_t psvSelChange;
	DoubleClicker DoubleClickHandler;
	uintptr_t psvDoubleClick;
	ListItemOpened ListItemOpenHandler;
	uintptr_t psvOpenClose;
} LISTBOX, *PLISTBOX;
//---------------------------------------------------------------------------
void CPROC SetListBoxTabStopsEx( PSI_CONTROL pc, int nLevel, int nStops, int *pStops )
{
	int n;
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( nLevel >= plb->tabStops.count ) {
		plb->tabStops.tabStops = (struct listboxTabStops*) Reallocate( plb->tabStops.tabStops, (nLevel+1) * sizeof( plb->tabStops.tabStops[0] ) );
		MemSet( plb->tabStops.tabStops + plb->tabStops.count
				, 0, ((nLevel+1) - plb->tabStops.count) * sizeof( plb->tabStops.tabStops[0] ) );
		plb->tabStops.count = nLevel+1;
	}
	if( plb->tabStops.tabStops[nLevel].pTabstops )
		Release( plb->tabStops.tabStops[nLevel].pTabstops );
	plb->tabStops.tabStops[nLevel].pTabstops = NewArray( int, nStops );
	for( n = 0; ( plb->tabStops.tabStops[nLevel].pTabstops[n] = pStops[n]),(n < nStops); n++ );
	plb->tabStops.tabStops[nLevel].nTabstops = nStops;
}
//---------------------------------------------------------------------------
void CPROC SetListBoxTabStops( PSI_CONTROL pc, int nStops, int* pStops )
{
	SetListBoxTabStopsEx( pc, 0, nStops, pStops );
}
//---------------------------------------------------------------------------
void DeleteListItem( PSI_CONTROL pc, PLISTITEM hli )
{
	PLISTITEM pli = (PLISTITEM)hli;
	PLISTITEM cur;
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
		cur = plb->items;
		while( cur )
		{
			if( cur == pli )
			break;
			cur = cur->next;
		}
		if( cur )
		{
			PLISTITEM pliNew;
			if( pli->prior )
				pli->prior->next = pli->next;
			else
				plb->items = cur->next;
			if( pli->next )
			{
				pli->next->prior = pli->prior;
				pliNew = pli->next;
			}
			else
			{
				plb->last = pli->prior;
				pliNew = pli->prior;
			}
			if( plb->firstshown == pli )
			{
				if( pli->next )
					plb->firstshown = pli->next;
				else if( pli->prior )
					plb->firstshown = pli->prior;
				else
					plb->firstshown = NULL;
			}
			if( plb->lastshown == pli )
				plb->lastshown = NULL;
			if( plb->current == pli )
			{
			// set current selection
				plb->current = pliNew;
			}
			Release( pli->text );
			Release( pli );
		}
		// if prior is closed don't refresh?
		if( !plb->flags.bDestroying )
			SmudgeCommon(pc);
	}
}
//---------------------------------------------------------------------------
PSI_PROC( void, ResetList )( PSI_CONTROL pc )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
 // fake it...
		plb->flags.bDestroying = 1;
		while( plb->items )
			DeleteListItem( pc, (PLISTITEM)plb->items );
 // okay we're not really ...
		plb->flags.bDestroying = 0;
		SmudgeCommon( pc );
	}
}
//---------------------------------------------------------------------------
static void CPROC DestroyListBox( PSI_CONTROL pc )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
		PLISTITEM pli, next;
		if( plb->header ) {
			// relesae headers
			next = plb->header;
			while( pli = next ) {
				next = pli->next;
				Release( pli->text );
				Release( pli );
			}
		}
		if( plb->tabStops.count ) {
			int n;
			for( n = 0; n < plb->tabStops.count; n++ )
				Release( plb->tabStops.tabStops[n].pTabstops );
			Release( plb->tabStops.tabStops );
		}
		plb->flags.bDestroying = TRUE;
		UnmakeImageFile( plb->ListSurface );
		while( plb->items ) {
			pli = plb->items;
			plb->items = pli->next;
			Release( pli->text );
			Release( pli );
		}
	}
}
//---------------------------------------------------------------------------
void ClearSelectedItems( PSI_CONTROL pc )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	PLISTITEM pli;
 // no selection
	plb->first_selected = NULL;
	pli = plb->items;
	while( pli )
	{
		pli->flags.bSelected = FALSE;
		pli = pli->next;
	}
	SmudgeCommon( pc );
}
//---------------------------------------------------------------------------
static void AdjustItemsIntoBox( PSI_CONTROL pc )
{
	// current item must be shown in the list...
	uint32_t w, h;
	int x, y, maxchars;
	PLISTITEM pli;
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	GetStringSize( " ", &w, &h );
	maxchars = ( pc->surface_rect.width - 8 ) / w;
	y = 2;
	x = 4;
	// if no current, then the cursor line need not be shown
	// in fact first shown is first item...
	if( plb->current )
	{
		plb->firstshown = plb->current;
		pli = plb->current;
		while( pli )
		{
			y += h;
			pli = pli->next;
		}
		// while there's stuff above current to show, and
		// current will still fit integrally on the listbox
		// back up firstshown....
		while( plb->firstshown->prior &&
				 ( SUS_LT( y, int, (pc->surface_rect.height - (h-1)),uint32_t) ) )
		{
			y += h;
			plb->firstshown = plb->firstshown->prior;
		}
	}
}
#define BRANCH_WIDTH  20
//---------------------------------------------------------------------------
static int MeasureRelationLines( PSI_CONTROL pc, PLISTITEM pli, int drawthis )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	int x;
	x = (int)(pli->nLevel * (1.75*pli->height) + (pli->height*1.75)/2);
	x -= plb->nXOffset;
	x = (int)(x + ((pli->height)*1.75 * 2) / 3);
	return x;
}
//---------------------------------------------------------------------------
static int RenderRelationLines( PSI_CONTROL pc, Image surface, PLISTITEM pli, int drawthis )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	PLISTITEM pliNextUpLevel;
	int x, y, ymin, ymax;
	pliNextUpLevel = pli->next;
	x = (int)(pli->nLevel * (1.75 * pli->height)
		+ (pli->height * 1.75) / 2);
	x -= plb->nXOffset;
	y = pli->top + (pli->height / 2);
	ymin = pli->top;
	ymax = pli->top + pli->height;
	if( pli->nLevel ) {
		PLISTITEM pliParent = pli->prior;
		while( pliParent && pliParent->nLevel >= pli->nLevel ) {
			pliParent = pliParent->prior;
		}
		if( pliParent && !pliParent->flags.bOpen ) {
			// parent is not open, therefore do not draw lines...
			// also - x offset is irrelavent return..
			return 0;
		}
	}
	if( drawthis ) {
		while( pliNextUpLevel && pliNextUpLevel->nLevel > pli->nLevel )
			pliNextUpLevel = pliNextUpLevel->prior;
		if( pliNextUpLevel && (pliNextUpLevel->nLevel == pli->nLevel) ) {
			do_hline( surface, y, x, (int)(x + ((pli->height * 1.75) / 2) - 1), basecolor( pc )[SHADE] );
// basecolor( pc )[SHADE] );
			do_vline( surface, x, ymin, ymax, BASE_COLOR_RED );
		}
		else {
			do_hline( surface, y, x, (int)(x + ((pli->height * 1.75) / 2) - 1), basecolor( pc )[SHADE] );
//basecolor( pc )[SHADE] );
			do_vline( surface, x, ymin, y, BASE_COLOR_GREEN );
		}
	}
	//x += ((pli->height * 1.75) / 2);
	pliNextUpLevel = pli;
	//x = (int)(x + ((pli->height) * 1.75 * 2) / 3);
	//x -= plb->nXOffset;
	while( pliNextUpLevel ) {
		while( pliNextUpLevel && pliNextUpLevel->nLevel >= pli->nLevel )
			pliNextUpLevel = pliNextUpLevel->prior;
		if( pliNextUpLevel ) {
			do_vline( surface
				, (int)((pliNextUpLevel->nLevel) * (pli->height * 1.75) + ((pli->height * 1.75) / 2)) - plb->nXOffset
				, ymin, ymax
				, basecolor( pc )[SHADE] );
		}
		pli = pliNextUpLevel;
	}
	return x;
}
//---------------------------------------------------------------------------
static int MeasureItemKnob( PSI_CONTROL pc, PLISTITEM pli )
{
	PLISTITEM pliNextUpLevel;
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
 // x, y of center...
	int x;
	int line_length = pli->height * 5 / 12;
	int line_length_inner = pli->height * 3 / 12;
	if( !pli->next || (pli->next->nLevel <= pli->nLevel) ) {
		// this is not an openable item, therefore
		// just draw some lines...
		x = MeasureRelationLines( pc, pli, TRUE );
	}
	else {
		// render lines to the left of here but not including here...
		x = MeasureRelationLines( pc, pli, FALSE );
	}
	pliNextUpLevel = pli->next;
	while( pliNextUpLevel && (pliNextUpLevel->nLevel > pli->nLevel) )
		pliNextUpLevel = pliNextUpLevel->prior;
	//x = (int)(pli->nLevel * (pli->height * 1.75) + ((pli->height * 1.75) / 2));
	//x -= plb->nXOffset;
// (int)(x + (pli->height * 1.75 * 2) / 3);
	return x;
}
//---------------------------------------------------------------------------
static int RenderItemKnob( PSI_CONTROL pc, Image surface, PLISTITEM pli )
{
	PLISTITEM pliNextUpLevel;
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
 // x, y of center...
	int x, y;
	int line_length = pli->height*5/12;
	int line_length_inner = pli->height*3/12;
	if( !pli->next || ( pli->next->nLevel <= pli->nLevel ) )
	{
		// this is not an openable item, therefore
		// just draw some lines...
		return RenderRelationLines( pc, surface, pli, TRUE )
			+ ((pli->height * 1.75) / 2);
	}
	else
	{
		// render lines to the left of here but not including here...
		x = RenderRelationLines( pc, surface, pli, FALSE );
	}
	pliNextUpLevel = pli->next;
	while( pliNextUpLevel && ( pliNextUpLevel->nLevel > pli->nLevel ) )
		pliNextUpLevel = pliNextUpLevel->prior;
	//x = (int)(pli->nLevel * (pli->height*1.75)
	//	+ ((pli->height*1.75)/2));
	//x -= plb->nXOffset;
	y = pli->top + ( pli->height / 2 );
	// this draws the box with a + in it...
	do_hlineAlpha(surface, y - line_length, x-line_length, x+line_length, basecolor(pc)[SHADE] );
	do_hlineAlpha( surface, y + line_length, x-line_length, x+line_length, basecolor(pc)[SHADE] );
	do_vlineAlpha( surface, x - line_length, y-line_length, y+line_length, basecolor(pc)[SHADE] );
	do_vlineAlpha( surface, x + line_length, y-line_length, y+line_length, basecolor(pc)[SHADE] );
	if( !pli->flags.bOpen )
	{
		// this is the plus
		do_hlineAlpha( surface, y, x-line_length_inner, x+line_length_inner, basecolor(pc)[SHADOW] );
		do_vlineAlpha( surface, x, y-line_length_inner, y+line_length_inner, basecolor(pc)[SHADOW] );
	}
	else
	{
		// this is the minus
		do_hlineAlpha( surface, y, x-line_length_inner, x+line_length_inner, basecolor(pc)[SHADOW] );
	}
	// draw line leading in (top) and out (right)
	do_vlineAlpha( surface, x, y - line_length, pli->top, basecolor(pc)[SHADE] );
	do_hlineAlpha( surface, y, x + line_length, (int)(x + ((pli->height*1.75)/2)-1), basecolor(pc)[SHADE] );
	// optionally draw line leading down (bottom)
	if( pliNextUpLevel && ( pliNextUpLevel->nLevel == pli->nLevel ) )
	{
		// next item is on this level, extend branch line down.
		do_vlineAlpha( surface, (pli->nLevel-1) * (pli->height*1.75) + (pli->height*1.75)/2 - plb->nXOffset, y - (pli->height+1)/2, pli->top + pli->height, basecolor(pc)[SHADE] );
	}
	return (int)(x + (pli->height*1.75*2)/3);
}
//---------------------------------------------------------------------------
//Ex
static void UpdateScrollForList
( PSI_CONTROL pc
 //DBG_PASS
)
//#define UpdateScrollForList(pc) UpdateScrollForListEx( pc DBG_SRC )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	int current = -1, onview = -1, count = 0;
	PLISTITEM pli = plb->items;
	if( plb->firstshown && plb->lastshown )
	{
		while( pli )
		{
			if( pli == plb->firstshown )
				current = count;
			if( current >= 0 && onview < 0 )
			{
				if( pli == plb->lastshown )
				{
					onview = count - current + 1;
				}
			}
			count++;
			if( !pli->flags.bOpen )
			{
				PLISTITEM skip = pli->next;
				while( skip && ( skip->nLevel > pli->nLevel ) )
					skip = skip->next;
				pli = skip;
			}
			else
				pli = pli->next;
		}
	}
	//lprintf( "Set scroll params %d %d %d %d", 0, current, onview, count );
	SetScrollParams( plb->pcScroll, 0, current, onview, count );
}
//---------------------------------------------------------------------------
static void DrawLine( PSI_CONTROL pc, PLISTBOX plb, PLISTITEM pli, int y, int h ) {
	TEXTCHAR* start = pli->text;
	TEXTCHAR* end;
	CDATA lineColor = GetControlColor( pc, SHADE );
	SFTFont font = GetFrameFont( pc );
	int32_t right = 0;
	int tab = 0;
	int knob = 0;
	int x = 0;
	Image pSurface = plb->ListSurface;
	if( plb->flags.bTree ) {
		knob = MeasureItemKnob( pc, pli );
	}
	pli->top = y;
	pli->height = h;
	while( start ) {
		uint32_t width = 0;
		int32_t column = 0;
		int32_t nextColumn = pSurface->width;
		int bRight = 0;
		if( plb->tabStops.count > pli->nLevel )
			if( tab < plb->tabStops.tabStops[pli->nLevel].nTabstops ) {
				column = plb->tabStops.tabStops[pli->nLevel].pTabstops[tab];
				nextColumn = plb->tabStops.tabStops[pli->nLevel].pTabstops[tab + 1];
				if( plb->tabStops.tabStops[pli->nLevel].pTabstops[tab] < 0 ) {
					bRight = 1;
					column = plb->tabStops.tabStops[pli->nLevel].pTabstops[tab + 1];
					if( column < 0 )
						column = -column;
				}
			}
		//lprintf( "tab stop was %d", column );
		ScaleCoords( pc, &column, NULL );
		ScaleCoords( pc, &nextColumn, NULL );
		//lprintf( "tab stop is %d", column );
		end = strchr( start, '\t' );
		if( !end )
			end = start + strlen( start );
		width = GetStringSizeFontEx( start, end - start, NULL, NULL, font );
		if( bRight ) {
			column -= width;
		}
		// results as max of either next tabstop or start plus stringlength
		if( SUS_GT( (nextColumn), int32_t, (width + column), uint32_t ) ) {
			if( nextColumn > right )
				right = nextColumn;
			x = ((nextColumn - column) - width) / 2;
		}
		else {
			x = 0;
			if( USS_GT( (x + width + column), uint32_t, right, int32_t ) )
				right = (x + width + column);
		}
		//xlprintf( 1 )( "show: %d %d %d %d %d %s %s", knob, x, column, nextColumn, width, start, end);
		PutStringFontEx( pSurface, knob + x + column, y, basecolor( pc )[EDIT_TEXT], 0, start, end - start, font );
		do_vline( pSurface, knob + nextColumn, y, y + h, lineColor );
		if( plb->tabStops.count > pli->nLevel ) {
			tab++;
			if( tab >= plb->tabStops.tabStops[pli->nLevel].nTabstops )
				tab = plb->tabStops.tabStops[pli->nLevel].nTabstops - 1;
		}
		if( end[0] )
			start = end + 1;
		else
			start = NULL;
	}
	do_hlineAlpha( pSurface, y + h + 1, knob, knob + right, lineColor );
}
int MeasureListboxItemEx( PSI_CONTROL pc, CTEXTSTR item, int asLevel ) {
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	CTEXTSTR start = item;
	CTEXTSTR end;
	SFTFont font = GetFrameFont( pc );
	int32_t right = 0;
	int tab = 0;
	int x;
	Image pSurface = plb->ListSurface;
	while( start ) {
		uint32_t width = 0;
		int32_t column;
		int32_t nextColumn;
		int bRight = 0;
		if( tab < plb->tabStops.tabStops[asLevel].nTabstops ) {
			column = plb->tabStops.tabStops[asLevel].pTabstops[tab];
			nextColumn = plb->tabStops.tabStops[asLevel].pTabstops[tab + 1];
			if( plb->tabStops.tabStops[asLevel].pTabstops[tab] < 0 ) {
				bRight = 1;
				column = plb->tabStops.tabStops[asLevel].pTabstops[tab + 1];
				if( column < 0 )
					column = -column;
			}
		}
		//lprintf( "tab stop was %d", column );
		ScaleCoords( pc, &column, NULL );
		ScaleCoords( pc, &nextColumn, NULL );
		//lprintf( "tab stop is %d", column );
		end = strchr( start, '\t' );
		tab++;
		if( tab >= plb->tabStops.tabStops[asLevel].nTabstops )
			tab = plb->tabStops.tabStops[asLevel].nTabstops - 1;
 // one single column, or no more columns...
		if( !end ) {
			end = start + strlen( start );
			width = GetStringSizeFontEx( start, end - start, NULL, NULL, font );
			if( bRight ) {
				column -= width;
			}
			if( SUS_GT( ( nextColumn - column ), int32_t, width, uint32_t) )
				x = ( ( nextColumn - column ) - width ) / 2;
			else
				x = 0;
			if( SUS_GT( column,int32_t, (right-(x+width)), uint32_t ) )
				right = ( x + width + column );
		}
		if( end[0] )
			start = end + 1;
		else
			start = NULL;
	}
	return right;
}
int MeasureListboxItem( PSI_CONTROL pc, CTEXTSTR item ) {
	return MeasureListboxItemEx( pc, item, 0 );
}
static int OnDrawCommon( LISTBOX_CONTROL_NAME )( PSI_CONTROL pc )
{
	int bFirstDraw;
	uint32_t w, h;
	int x, y, maxchars;
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	PLISTITEM pli, pliLastShown = plb->lastshown;
	SFTFont font;
	Image pSurface = plb->ListSurface;
	//lprintf( "Drawing listbox using font %p", GetFrameFont( pc ) );
	if( plb->flags.bInitial )
	{
		bFirstDraw = TRUE;
		plb->flags.bInitial = FALSE;
		plb->flags.bNoUpdate = FALSE;
	}
	else
		bFirstDraw = FALSE;
	if( !pSurface )
		return 0;
	BlatColorAlpha( plb->ListSurface, 0, 0, plb->ListSurface->width, plb->ListSurface->height, basecolor(pc)[EDIT_BACKGROUND] );
	//ClearImageTo( pSurface, basecolor(pc)[EDIT_BACKGROUND] );
	font = GetFrameFont( pc );
	GetStringSizeFont( "X", &w, &h, font );
	//lprintf( "Measure returned %d %d", w, h );
	maxchars = ( pc->surface_rect.width - 8 ) / w;
	y = 2;
	x = 4;
	w = pc->surface_rect.width;
	pli = plb->items;
	if( !plb->firstshown )
		plb->firstshown = plb->items;
	while( pli != plb->firstshown )
	{
		pli->top = -1;
		pli = pli->next;
	}
	//pli = plb->firstshown;
	if( plb->header ) {
		PLISTITEM pliHeader = plb->header;
		while( pliHeader ) {
			DrawLine( pc, plb, pliHeader, y, h );
			y += h;
			pliHeader = pliHeader->next;
		}
	}
	y += 2;
	while( pli && SUS_LT( y, int, pc->surface_rect.height, IMAGE_SIZE_COORDINATE ) )
	{
		TEXTCHAR *start = pli->text;
		TEXTCHAR *end;
		int tab = 0;
		pli->top = y;
		pli->height = h;
		if( plb->flags.bTree ) {
			x = RenderItemKnob( pc, plb->ListSurface, pli );
		}
		else
			x -= plb->nXOffset;
		if( pli->flags.bSelected )
		{
			BlatColorAlpha( pSurface, x-2, y, w-4, h, basecolor(pc)[SELECT_BACK] );
		}
		while( start ) {
			uint32_t width = 0;
			int bRight = 0;
			int32_t column = 0;
			if( plb->tabStops.count > pli->nLevel ) {
				column = plb->tabStops.tabStops[pli->nLevel].pTabstops[tab];
				if( plb->tabStops.tabStops[pli->nLevel].pTabstops[tab] < 0 ) {
					bRight = 1;
					column = plb->tabStops.tabStops[pli->nLevel].pTabstops[tab + 1];
					if( column < 0 )
						column = -column;
				}
			}
			//lprintf( "tab stop was %d", column );
			ScaleCoords( pc, &column, NULL );
			//lprintf( "tab stop is %d", column );
			end = strchr( start, '\t' );
			if( !end )
				end = start + strlen( start );
			if( bRight )
			{
				width = GetStringSizeFontEx( start, end-start, NULL, NULL, font );
				column -= width;
			}
			if( pli->flags.bSelected )
			{
				PutStringFontEx( pSurface, x + column, y, basecolor(pc)[SELECT_TEXT], 0, start, end-start, font );
			}
			else
			{
				PutStringFontEx( pSurface, x + column, y, basecolor(pc)[EDIT_TEXT], 0, start, end-start, font );
			}
			tab++;
			if( pli->nLevel < plb->tabStops.count ) {
				if( tab >= plb->tabStops.tabStops[pli->nLevel].nTabstops )
					tab = plb->tabStops.tabStops[pli->nLevel].nTabstops - 1;
			}
			if( end[0] )
				start = end+1;
			else
				start = NULL;
		}
		if( pc->flags.bFocused &&
			 plb->current == pli )
			do_line( pSurface, x + 1, y + h-2, w - 6, y + h - 2, basecolor(pc)[SHADE] );
		y += h;
		//xlprintf(LOG_ALWAYS)( "y is %ld and height is %ld", y , pSurface->height );
 // probably is only partially shown...
		if( y < pSurface->height  )
		{
			plb->lastshown = pli;
		}
		if( plb->flags.bTree && pli->flags.bOpen )
			pli = pli->next;
		else
		{
			PLISTITEM next = pli->next;
			while( next && next->nLevel > pli->nLevel )
			{
				next->top = -1;
				next = next->next;
			}
			pli = next;
		}
	}
	while( pli )
	{
		pli->top = -1;
		pli = pli->next;
	}
	if( bFirstDraw || ( plb->lastshown != pliLastShown ) )
	{
		UpdateScrollForList( pc );
	}
	return 1;
}
//---------------------------------------------------------------------------
static int GetItemIndex( PLISTBOX plb, PLISTITEM pli )
{
	PLISTITEM cur;
	int cnt = 0;
	cur = plb->items;
	while( cur )
	{
		if( pli == cur )
			break;
		cnt++;
		cur = cur->next;
	}
	if( cur )
		return cnt;
	return -1;
}
//---------------------------------------------------------------------------
void MoveListItemEx( PSI_CONTROL pc, PLISTITEM pli, int level_direction, int direction )
{
	if( pli )
	{
		int grouped_item_count = 0;
		PLISTITEM pliLast;
		ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
		int pliIndex = GetItemIndex( plb, pli );
		{
			// find start and end of group (may be a tree'd control and have levels on items)
			PLISTITEM pliGroupStart, pliGroupEnd;
			if( ( pli == plb->items ) && ( direction < 0 ) )
			{
				// item is already at the top of the list
				return;
			}
			pliGroupStart = pliGroupEnd = pli;
			// keep the prior end, which becomes the last item of the group.
			// (may be same as pli)
			grouped_item_count++;
			pliLast = pliGroupEnd;
			pliGroupEnd = pliGroupEnd->next;
			while( pliGroupEnd && pliGroupEnd->nLevel > pliGroupStart->nLevel )
			{
				grouped_item_count++;
				pliLast = pliGroupEnd;
				pliGroupEnd = pliGroupEnd->next;
			}
			if( !pliGroupEnd && direction > 0 )
			{
				// item is already at the end, cannot move any further down.
				return;
			}
			if( plb->firstshown == pli )
				plb->firstshown = pli->prior;
			if( plb->lastshown == pli )
				plb->lastshown = pliLast->next;
			if( pli->prior )
				pli->prior->next = pliGroupEnd;
			else
				plb->items = pliLast->next;
			if( pliGroupEnd )
				pliGroupEnd->prior = pli->prior;
 // nothing left - update end of list.
			if( !pliLast->next )
				plb->last = pli->prior;
			pli->prior = NULL;
			pliLast->next = NULL;
		}
		if( ( direction < 0 ) && (-direction >= pliIndex ) )
		{
			if( plb->items )
				plb->items->prior = pliLast;
			else
				plb->last = pliLast;
			pliLast->next = plb->items;
			if( plb->items == plb->firstshown )
				plb->firstshown = pli;
			plb->items = pli;
		}
		else
		{
			PLISTITEM pliInsertAfter = GetNthItem( pc, (int)(pliIndex + direction-1) );
			if( !pliInsertAfter )
			{
				// insert at end... overflow end...
				if( plb->last )
				{
					plb->last->next = pli;
					pli->prior = plb->last;
				}
				else
				{
					// list was empty - put group back in.
					plb->items = pli;
					plb->last = pliLast;
				}
			}
			else
			{
				PLISTITEM pliInsertBefore = pliInsertAfter;
				pliInsertBefore = pliInsertBefore->next;
				while( pliInsertBefore && (pliInsertBefore->nLevel > pliInsertAfter->nLevel) )
				{
					pliInsertBefore = pliInsertBefore->next;
				}
				if( pliInsertBefore )
				{
					pliInsertBefore->prior->next = pli;
					pli->prior = pliInsertBefore->prior;
					pliLast->next = pliInsertBefore;
					pliInsertBefore->prior = pliLast;
				}
				else
				{
					// insert at end of list after group of insertafter.
					if( plb->last )
					{
						pli->prior = plb->last;
						plb->last->next = pli;
						plb->last = pliLast;
					}
					else
					{
						// okay list became empty again - here we should
						// have already run across conditions which should have
						// handled this.
						plb->last = pliLast;
						plb->items = pli;
					}
				}
			}
		}
	}
	SmudgeCommon( pc );
}
//---------------------------------------------------------------------------
void MoveListItem( PSI_CONTROL pc, PLISTITEM pli, int direction )
{
	MoveListItemEx( pc, pli, 0, direction );
}
//---------------------------------------------------------------------------
// GetNthTreeItem searches under the item specified
// for the Nth item at level specified... ignoring child levels.
PLISTITEM GetNthTreeItem( PSI_CONTROL pc, PLISTITEM pli, int level, int idx )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	PLISTITEM _pli;
	lprintf( "This function is unfinished in implementation." );
	_pli = pli = plb->items;
	while( idx && pli )
	{
		idx--;
		_pli = pli;
		pli = pli->next;
		//if( !_pli->flags.bOpen )
		{
			while( pli && ( pli->nLevel > _pli->nLevel ) )
			{
				pli = pli->next;
			}
		}
	}
	//if( !pli )
	//	return (PLISTITEM)_pli;
	return (PLISTITEM)pli;
}
//---------------------------------------------------------------------------
PSI_PROC( PLISTITEM, GetNthItem )( PSI_CONTROL pc, int idx )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	PLISTITEM pli, _pli;
	_pli = pli = plb->items;
	while( idx && pli )
	{
		idx--;
		_pli = pli;
		pli = pli->next;
		if( !_pli->flags.bOpen )
		{
			while( pli && ( pli->nLevel > _pli->nLevel ) )
			{
				pli = pli->next;
			}
		}
	}
	//if( !pli )
	//	return (PLISTITEM)_pli;
	return (PLISTITEM)pli;
}
//---------------------------------------------------------------------------
int GetItemCount( PLISTBOX plb )
{
	PLISTITEM pli, next;
	int cnt = 0;
	pli = plb->items;
	while( pli )
	{
		cnt++;
		next = pli->next;
		if( !pli->flags.bOpen )
		{
			while( next && next->nLevel > pli->nLevel )
				next = next->next;
		}
		pli = next;
	}
	return cnt;
}
//---------------------------------------------------------------------------
static void CPROC ScrollBarUpdate( uintptr_t psvList, int type, int current )
{
	PSI_CONTROL pc = (PSI_CONTROL)psvList;
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( pc->nType == LISTBOX_CONTROL )
	{
		plb->firstshown = (PLISTITEM)GetNthItem( pc, current );
		SmudgeCommon( pc );
	}
}
//---------------------------------------------------------------------------
static void CPROC HScrollBarUpdate( uintptr_t psvList, int type, int current ) {
	PSI_CONTROL pc = (PSI_CONTROL)psvList;
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( pc->nType == LISTBOX_CONTROL ) {
		plb->nXOffset = current;
		SmudgeCommon( pc );
	}
}
static void DispatchSelectionChanged( PLISTBOX plb, PSI_CONTROL pc, PLISTITEM pli )
{
	//PLISTITEM _pli = plb->current;
	//do
	{
		if( plb->SelChangeHandler )
			plb->SelChangeHandler( plb->psvSelChange, pc, pli );
	}
	//while( pli && plb->current != _pli );
}
//---------------------------------------------------------------------------
static void SelectRange( PLISTBOX plb, PLISTITEM pli_start, PLISTITEM pli_end )
{
	PLISTITEM pli;
	LOGICAL bMark = FALSE;
	pli = plb->items;
	while( pli )
	{
		if( pli == pli_start || pli == pli_end )
		{
 // the first, and the last are both selected anyhow..
			pli->flags.bSelected = TRUE;
			bMark = !bMark;
		}
		else
			pli->flags.bSelected = bMark;
		pli = pli->next;
	}
}
//---------------------------------------------------------------------------
static int OnMouseCommon( LISTBOX_CONTROL_NAME )( PSI_CONTROL pc, int32_t x, int32_t y, uint32_t b )
{
	  ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
		if( b & MK_SCROLL_DOWN )
		{
			MoveScrollBar( plb->pcScroll, UPD_1DOWN );
		}
		if( b & MK_SCROLL_UP )
		{
			MoveScrollBar( plb->pcScroll, UPD_1UP );
		}
		 if( b & MK_LBUTTON )
		{
			if( !(plb->b & MK_LBUTTON ) )
			{
				PLISTITEM pli;
				pli = plb->firstshown;
				while( pli )
				{
					if( pli->top >= 0 &&
						 y >= pli->top &&
						 SUS_LT( y, int32_t, ( pli->top + pli->height ), uint32_t ) )
						break;
					pli = pli->next;
				}
				if( pli )
				{
					LOGICAL bWasSelected = pli->flags.bSelected;
					if( plb->flags.bTree
						&& pli->next
						&& ( pli->next->nLevel > pli->nLevel )
						&& ( x < ( ( pli->nLevel + 1) * (pli->height*1.75) ) ) )
					{
						pli->flags.bOpen = !pli->flags.bOpen;
						plb->current = pli;
						if( plb->ListItemOpenHandler )
						{
							int bDisable = DisableUpdateListBox( pc, TRUE );
							plb->ListItemOpenHandler( plb->psvOpenClose
															, pc
															, pli
															, pli->flags.bOpen );
							// restore prior disable state...
							// this sends a smudge if needed.
							DisableUpdateListBox( pc, bDisable );
						}
						else
							SmudgeCommon( pc );
						UpdateScrollForList( pc );
						goto record_prior_state;
					}
					if( !plb->flags.bLazyMulti && ( plb->flags.bSingle || !( ( b & (MK_SHIFT|MK_CONTROL) ) ) ) )
					{
						ClearSelectedItems( pc );
					}
					if( !plb->first_selected )
						plb->first_selected = pli;
					plb->current = pli;
					if( ( b & MK_SHIFT ) && plb->first_selected )
					{
						if( pli != plb->first_selected )
						{
							SelectRange( plb, plb->first_selected, pli );
						}
					}
 // with MK_CONTROL or not, toggle selection.  If not contol, then all itms have been cleared
					else
					{
						pli->flags.bSelected = !pli->flags.bSelected;
						// if item is NOT selected but it was not previously selected..
						//if( pli->flags.bSelected && !bWasSelected )
							DispatchSelectionChanged( plb, pc, pli );
					}
					if( ( timeGetTime() - plb->TimeLastClick ) < 250 )
					{
						if( plb->DoubleClickHandler )
							plb->DoubleClickHandler( plb->psvDoubleClick, pc, (PLISTITEM)plb->current );
						// what if double click handler changes the selection again?
						// then selchangehnadler will get called with both?
					}
					plb->TimeLastClick = timeGetTime();
					SmudgeCommon( pc );
				}
			}
		}
		if( b & MK_RBUTTON )
		{
			if( !(plb->b & MK_RBUTTON ) )
			{
				// first down...
				PLISTITEM pli;
				pli = plb->firstshown;
				while( pli )
				{
					if( pli->top >= 0 &&
						 y >= pli->top &&
						 SUS_LT( y, int32_t, ( pli->top + pli->height ), uint32_t ) )
						break;
					pli = pli->next;
				}
				plb->mouseon = pli;
			}
		}
		else
		{
			if( !(plb->b & MK_RBUTTON ) && plb->mouseon )
			{
				// last down...
				PLISTITEM pli;
				pli = plb->firstshown;
				while( pli )
				{
					if( pli->top >= 0 &&
						 y >= pli->top &&
						 SUS_LT( y, int32_t, ( pli->top + pli->height ), uint32_t ) )
						break;
					pli = pli->next;
				}
				if( pli == plb->mouseon )
				{
					if( pli->MenuProc && pli->pPopup )
					{
						// need to update the state NOW - may come back around
						// and have to deal with this...
						plb->mouseon = NULL;
						plb->x = x;
						plb->y = y;
						plb->b = b;
						{
							uint32_t result = TrackPopup( pli->pPopup, GetFrame( pc ) );
							if( result != (uint32_t)-1 )
								pli->MenuProc( pli->psvContextMenu, pli, result );
						}
						return 1;
					}
				}
			}
		}
	record_prior_state:
		plb->x = x;
		plb->y = y;
		plb->b = b;
	}
	return 1;
}
//---------------------------------------------------------------------------
static LOGICAL IsParentOpen( PLISTITEM pli )
{
	int myself = pli->nLevel;
	PLISTITEM prior;
	for( prior = pli->prior; prior; prior = prior->prior )
	{
		if( ( myself - prior->nLevel ) == 1 )
		{
			if( prior->flags.bOpen )
				return TRUE;
			else
				return FALSE;
		}
	}
	return TRUE;
}
static int OnKeyCommon( LISTBOX_CONTROL_NAME )( PSI_CONTROL pc, uint32_t key )
{
	int handled = 0;
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
		PLISTITEM pli;
		//printf( "%08x\n", key );
		if( key & 0x80000000 )
		{
			switch( key & 0xFF )
			{
			case KEY_LEFT:
				if( plb->flags.bTree )
				{
				}
				handled = 1;
				break;
			case KEY_RIGHT:
				if( plb->flags.bTree )
				{
				}
				handled = 1;
				break;
			case KEY_UP:
				pli = plb->current;
				if( GetItemIndex( plb, plb->current ) < GetItemIndex( plb, plb->firstshown ) )
						plb->firstshown = plb->current;
				if( GetItemIndex( plb, plb->current ) > GetItemIndex( plb, plb->lastshown ) )
					plb->firstshown = plb->current;
				if( plb->current && plb->current->prior )
				{
					if( plb->current == plb->firstshown )
					{
						plb->firstshown = plb->firstshown->prior;
					}
					pli = plb->current;
					do
					{
						pli = pli->prior;
					} while( pli && plb->flags.bTree && !IsParentOpen( pli ) );
					if( !pli )
						pli = plb->current;
				}
				else
					if( !plb->current )
						plb->current = plb->items;
				if( plb->flags.bSingle )
				{
					if( pli != plb->current )
					{
						if( plb->current )
							plb->current->flags.bSelected = 0;
						if( pli )
							pli->flags.bSelected = 1;
						plb->current = pli;
						DispatchSelectionChanged( plb, pc, pli );
					}
				}
				SmudgeCommon( pc );
				UpdateScrollForList( pc );
				handled = 1;
				break;
			case KEY_DOWN:
				pli = plb->current;
				if( GetItemIndex( plb, plb->current ) < GetItemIndex( plb, plb->firstshown ) )
					plb->firstshown = plb->current;
				if( GetItemIndex( plb, plb->current ) > GetItemIndex( plb, plb->lastshown ) )
					plb->firstshown = plb->current;
				if( plb->current && plb->current->next )
				{
					// scroll another item into the list.
					if( plb->current->next == plb->lastshown && ( plb->lastshown != plb->last ) )
						{
							plb->firstshown = plb->firstshown->next;
						}
					pli = plb->current;
					do
					{
						pli = pli->next;
					} while( pli && plb->flags.bTree && !IsParentOpen( pli ) );
					if( !pli )
						pli = plb->current;
				}
				else
					if( !plb->current )
						plb->current = plb->items;
				if( plb->flags.bSingle )
				{
					if( pli != plb->current )
					{
						if( plb->current )
							plb->current->flags.bSelected = 0;
						if( pli )
							pli->flags.bSelected = 1;
						plb->current = pli;
						DispatchSelectionChanged( plb, pc, pli );
					}
				}
				SmudgeCommon( pc );
				UpdateScrollForList( pc );
				handled = 1;
				break;
#ifndef __ANDROID__
			case KEY_PGUP:
				MoveScrollBar( plb->pcScroll, UPD_RANGEUP );
				handled = 1;
				break;
			case KEY_PGDN:
				MoveScrollBar( plb->pcScroll, UPD_RANGEDOWN );
				handled = 1;
				break;
#endif
			case KEY_SPACE:
				if( plb->current )
				{
					if( plb->flags.bSingle )
						ClearSelectedItems( pc );
					plb->current->flags.bSelected = !plb->current->flags.bSelected;
				}
				SmudgeCommon( pc );
				handled = 1;
				break;
			case KEY_ESCAPE:
				handled = InvokeDefault( pc, INV_CANCEL );
				break;
			case KEY_ENTER:
				handled = InvokeDefault( pc, INV_OKAY );
				break;
			}
		}
	}
	else
		lprintf( "No listbox?" );
	return handled;
}
//---------------------------------------------------------------------------
//CONTROL_PROC_DEF( LISTBOX_CONTROL, LISTBOX, ListBox, (uint32_t attr) )
int CPROC InitListBox( PSI_CONTROL pc )
{
	//ARG( uint32_t, attr );
	// there are no args to listbox...
	// there are options though - tree list, etc...
	// they should be passed!
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
		int32_t width = GetFontHeight( GetCommonFont( pc ) ) * 1.2;
		//ScaleCoords( (PSI_CONTROL)pc, &width, NULL );
		SetCommonTransparent( pc, TRUE );
		plb->ListSurface = MakeSubImage( pc->Surface
												 , 0, 0
												 , pc->surface_rect.width - width
												 , pc->surface_rect.height );
		//plb->attr = 0; //attr;
		// test options here... but for now
		// we only need SINGLE Select - which should
		// be a 0 flag when choice is made.
		//if( plb->attr & LISTOPT_TREE )
		//	plb->flags.bTree = TRUE;
		plb->flags.bSingle = TRUE;
		plb->flags.bNoUpdate = TRUE;
		plb->flags.bInitial = TRUE;
		plb->flags.bLazyMulti = FALSE;
		plb->pcScroll = MakePrivateControl( pc, SCROLLBAR_CONTROL
													 , pc->surface_rect.width-width, 0
													 , width, pc->surface_rect.height
													 , pc->nID );
		SetScrollUpdateMethod( plb->pcScroll, ScrollBarUpdate, (uintptr_t)pc );
		SetNoFocus( plb->pcScroll );
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------------
//CONTROL_PROC_DEF( LISTBOX_CONTROL, LISTBOX, ListBox, (uint32_t attr) )
PSI_PROC( PSI_CONTROL, SetListboxHorizontalScroll )( PSI_CONTROL pc, int bEnable, int max ) {
//ARG( uint32_t, attr );
	// there are no args to listbox...
	// there are options though - tree list, etc...
	// they should be passed!
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	int32_t width = GetFontHeight( GetCommonFont( pc ) ) * 1.2;
	if( plb && bEnable && !plb->pcHScroll ) {
		//ScaleCoords( (PSI_CONTROL)pc, &width, NULL );
		UnmakeImageFile( plb->ListSurface );
		plb->ListSurface = MakeSubImage( pc->Surface
			, 0, 0
			, pc->surface_rect.width - width
			, pc->surface_rect.height - width );
		plb->pcHScroll = MakePrivateControl( pc, SCROLLBAR_CONTROL
			, 0, pc->surface_rect.height - width
			, pc->surface_rect.width - width, width
			, pc->nID );
		SetScrollUpdateMethod( plb->pcHScroll, HScrollBarUpdate, (uintptr_t)pc );
		SetScrollParams( plb->pcHScroll, 0, 0, pc->surface_rect.width, max + width );
		SetNoFocus( plb->pcHScroll );
		plb->flags.bHorizontalScroll = 1;
		return pc;
	}
	else if( plb && bEnable && plb->pcHScroll ) {
		UnmakeImageFile( plb->ListSurface );
		plb->ListSurface = MakeSubImage( pc->Surface
			, 0, 0
			, pc->surface_rect.width - width
			, pc->surface_rect.height - width );
		SetScrollParams( plb->pcHScroll, 0, 0, pc->surface_rect.width, max + width );
		RevealCommon( plb->pcHScroll );
		plb->flags.bHorizontalScroll = 1;
		return pc;
	}
	else if( plb && !bEnable && plb->pcHScroll ) {
		UnmakeImageFile( plb->ListSurface );
		plb->ListSurface = MakeSubImage( pc->Surface
			, 0, 0
			, pc->surface_rect.width - width
			, pc->surface_rect.height );
		HideControl( plb->pcHScroll );
		plb->flags.bHorizontalScroll = 0;
		return pc;
	}
	return pc;
}
//---------------------------------------------------------------------------
PSI_PROC( PSI_CONTROL, SetListboxIsTree )( PSI_CONTROL pc, int bTree )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
		if( bTree )
			plb->flags.bTree = TRUE;
		else
			plb->flags.bTree = FALSE;
		SmudgeCommon( pc );
	}
	return pc;
}
//---------------------------------------------------------------------------
PLISTITEM InsertListItemEx( PSI_CONTROL pc, PLISTITEM pPrior, int nLevel, CTEXTSTR text )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
		PLISTITEM pli = (PLISTITEM)Allocate( sizeof( LISTITEM ) );
		pli->text = StrDup( text );
		pli->pPopup = NULL;
		pli->flags.bSelected = FALSE;
		pli->flags.bFocused = FALSE;
		pli->flags.bOpen = FALSE;
		pli->nLevel = nLevel;
		pli->data = 0;
		pli->within_list = pc;
		if( !pPrior )
		{
			if( ( pli->next = plb->items ) )
				plb->items->prior = pli;
			pli->prior = NULL;
			plb->items = pli;
			if( !plb->last )
			{
				plb->firstshown =
					plb->current =
					plb->last = plb->items;
				//pli->flags.bSelected = TRUE;
				//pli->flags.bFocused = TRUE;
			}
			else
			{
				plb->firstshown = NULL;
				plb->lastshown = NULL;
			}
		}
		else
		{
			if( !plb->last )
			{
				Log( "Hmm adding after an item in a list which has none?!" );
				DebugBreak();
			}
			if( ( pli->next = pPrior->next ) )
				pPrior->next->prior = pli;
			else
				plb->last = pli;
			pli->prior = pPrior;
			pPrior->next = pli;
		}
		if( !plb->flags.bNoUpdate && ( pPrior && pPrior->flags.bOpen ) )
		{
			//Log( "Added an item, therefore update this list?!" );
			// should only auto adjust when adding items...
			AdjustItemsIntoBox( pc );
			plb->flags.bInitial = TRUE;
			SmudgeCommon( pc );
		}
		return (PLISTITEM)pli;
	}
	return 0;
}
//---------------------------------------------------------------------------
PLISTITEM InsertListItem( PSI_CONTROL pc, PLISTITEM pPrior, CTEXTSTR text )
{
	return InsertListItemEx( pc, pPrior, 0, text );
}
//---------------------------------------------------------------------------
PLISTITEM AddAfterListItemEx( PSI_CONTROL pc, PLISTITEM pPrior, int nLevel, CTEXTSTR text )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb ) {
		PLISTITEM pli = (PLISTITEM)Allocate( sizeof( LISTITEM ) );
		pli->text = StrDup( text );
		pli->pPopup = NULL;
		pli->flags.bSelected = FALSE;
		pli->flags.bFocused = FALSE;
		pli->flags.bOpen = FALSE;
		pli->nLevel = nLevel;
		pli->data = 0;
		pli->within_list = pc;
		{
			PLISTITEM pliEnd;
			PLISTITEM pliFound = pPrior;
			for( pliEnd = pPrior->next; pliEnd; pliEnd = pliEnd->next ) {
				if( pliEnd->nLevel >= nLevel ) {
					pliFound = pliEnd;
					continue;
				}
				break;
			}
			pPrior = pliFound;
		}
		if( !pPrior ) {
			if( (pli->next = plb->items) )
				plb->items->prior = pli;
			pli->prior = NULL;
			plb->items = pli;
			if( !plb->last ) {
				plb->firstshown =
					plb->current =
					plb->last = plb->items;
				//pli->flags.bSelected = TRUE;
				//pli->flags.bFocused = TRUE;
			}
			else {
				plb->firstshown = NULL;
				plb->lastshown = NULL;
			}
		}
		else {
			if( !plb->last ) {
				Log( "Hmm adding after an item in a list which has none?!" );
				DebugBreak();
			}
			if( (pli->next = pPrior->next) )
				pPrior->next->prior = pli;
			else
				plb->last = pli;
			pli->prior = pPrior;
			pPrior->next = pli;
		}
		if( !plb->flags.bNoUpdate ) {
			//Log( "Added an item, therefore update this list?!" );
			// should only auto adjust when adding items...
			AdjustItemsIntoBox( pc );
			plb->flags.bInitial = TRUE;
			SmudgeCommon( pc );
		}
		return (PLISTITEM)pli;
	}
	return 0;
}
//---------------------------------------------------------------------------
PLISTITEM AddAfterListItem( PSI_CONTROL pc, PLISTITEM pPrior, CTEXTSTR text )
{
	PLISTITEM pli = AddAfterListItemEx( pc, pPrior, 0, text );
	pli->nLevel = 0;
	return pli;
}
//---------------------------------------------------------------------------
PLISTITEM SetListboxHeaderEx( PSI_CONTROL pc, const TEXTCHAR *text, int level )
{
	PLISTITEM pli = NULL;
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
		// sort by default.
		pli = (PLISTITEM)Allocate( sizeof( LISTITEM ) );
		pli->text = StrDup( text );
		pli->pPopup = NULL;
		pli->flags.bSelected = FALSE;
		pli->flags.bFocused = FALSE;
 // header items are always open(?)
		pli->flags.bOpen = TRUE;
		pli->nLevel = plb->nLastLevel;
		pli->data = 0;
		pli->nLevel = level;
		pli->next = NULL;
		pli->prior = NULL;
		pli->within_list = pc;
		if( !level ) {
			if( plb->header ) {
				// remove list itme plb->header
			}
			plb->header = pli;
		}
		else {
			PLISTITEM pliHeader = plb->header;
			while( pliHeader->next && pliHeader->next->nLevel < level )
				pliHeader = pliHeader->next;
			if( pli->next = pliHeader->next ) {
				pli->next->prior = pli;
			}
			pli->prior = pliHeader;
			pliHeader->next = pli;
		}
		return pli;
	}
	return 0;
}
PLISTITEM SetListboxHeader( PSI_CONTROL pc, const TEXTCHAR* text ) {
	return SetListboxHeaderEx( pc, text, 0 );
}
//---------------------------------------------------------------------------
PLISTITEM AddListItemEx( PSI_CONTROL pc, int nLevel, const TEXTCHAR *text ) {
	PLISTITEM pli = NULL;
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb ) {
		// sort by default.
		if( !plb->flags.bTree && plb->flags.bSortNormal ) {
			PLISTITEM find;
			find = plb->items;
			while( find ) {
				if( strcmp( find->text, text ) > 0 ) {
					pli = InsertListItem( pc, find->prior, text );
					break;
				}
				find = find->next;
			}
			if( !find )
				goto add_at_end;
		} else {
		add_at_end:
			pli = InsertListItem( pc, plb->last, text );
		}
		pli->nLevel = nLevel;
		if( !plb->flags.bNoUpdate ) {
			int bOpen = TRUE;
			if( nLevel ) {
				PLISTITEM parent;
				parent = pli->prior;
				while( parent && parent->nLevel >= nLevel )
					parent = parent->prior;
				if( parent )
					bOpen = parent->flags.bOpen;
				else
 // ROOT of tree is always open..
					bOpen = TRUE;
			}
			//Log( "Added an item, therefore update this list?!" );
			// should only auto adjust when adding items...
			if( bOpen ) {
				AdjustItemsIntoBox( pc );
				plb->flags.bInitial = TRUE;
			}
			SmudgeCommon( pc );
		}
		return (PLISTITEM)pli;
	}
	return 0;
}
//---------------------------------------------------------------------------
PLISTITEM AddListItem( PSI_CONTROL pc, CTEXTSTR text )
{
	PLISTITEM pli = AddListItemEx( pc, 0, text );
	return pli;
}
//---------------------------------------------------------------------------
void SetItemSelected( PSI_CONTROL pc, PLISTITEM pli, int bSelect )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
		if( !plb->flags.bLazyMulti && ( plb->flags.bSingle && bSelect ) )
			ClearSelectedItems( pc );
		if( pli )
		{
			if( pli->flags.bSelected != bSelect )
			{
				pli->flags.bSelected = bSelect;
				DispatchSelectionChanged( plb, pc, pli );
				SmudgeCommon( pc );
			}
		}
	}
}
//---------------------------------------------------------------------------
void SetSelectedItem( PSI_CONTROL pc, PLISTITEM hli )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
		if( !plb->flags.bLazyMulti && plb->flags.bSingle )
			ClearSelectedItems( pc );
		if( hli )
		{
			PLISTITEM pli = (PLISTITEM)hli;
			pli->flags.bSelected = TRUE;
			plb->current = pli;
			DispatchSelectionChanged( plb, pc, pli );
		}
		SmudgeCommon( pc );
	}
}
//---------------------------------------------------------------------------
void SetCurrentItem( PSI_CONTROL pc, PLISTITEM hli )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb && hli )
	{
		PLISTITEM pli = (PLISTITEM)hli;
		if( plb->current != pli )
		{
			plb->current = pli;
			SmudgeCommon( pc );
		}
	}
}
//---------------------------------------------------------------------------
PLISTITEM SetItemData( PLISTITEM hli, uintptr_t psv )
{
	PLISTITEM pli = (PLISTITEM)hli;
	if( hli )
		pli->data = psv;
	return hli;
}
//---------------------------------------------------------------------------
uintptr_t GetItemData( PLISTITEM hli )
{
	PLISTITEM pli = (PLISTITEM)hli;
	if( pli )
		return pli->data;
	return 0;
}
//---------------------------------------------------------------------------
PSI_PROC( void, SetItemContextMenu )( PLISTITEM pli, PMENU pMenu, void (CPROC*MenuProc)(uintptr_t, PLISTITEM, uint32_t menuopt ), uintptr_t psv )
{
	if( pli )
	{
		pli->psvContextMenu = psv;
		pli->pPopup = pMenu;
		pli->MenuProc = MenuProc;
	}
}
//---------------------------------------------------------------------------
PSI_PROC( PLISTITEM, GetSelectedItem )( PSI_CONTROL pc )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
		PLISTITEM pli;
		pli = plb->items;
		while( pli )
		{
			if( pli->flags.bSelected )
				return (PLISTITEM)pli;
			pli = pli->next;
		}
	}
	return 0;
}
//---------------------------------------------------------------------------
#undef GetItemText
PSI_PROC( void, GetListItemText )( PLISTITEM hli, TEXTSTR buffer, int bufsize )
{
	if( hli )
	{
		if( ((PLISTITEM)hli)->text )
			StrCpyEx( buffer, ((PLISTITEM)hli)->text, ((bufsize)/sizeof(TEXTCHAR))-1 );
		else
			buffer[0] = 0;
	}
}
PSI_PROC( void, GetItemText )( PLISTITEM hli, int bufsize, TEXTSTR buffer )
{
	GetListItemText( hli, buffer, bufsize );
}
//---------------------------------------------------------------------------
PSI_PROC( void, SetItemText )( PLISTITEM hli, CTEXTSTR buffer )
{
	if( hli )
	{
		if( hli->text )
			Release( hli->text );
		hli->text = StrDup( buffer );
		SmudgeCommon( hli->within_list );
	}
}
//---------------------------------------------------------------------------
PSI_PROC( int, GetSelectedItems )( PSI_CONTROL pc, PLISTITEM *pList, int *nSize )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
	}
	return 0;
}
//---------------------------------------------------------------------------
PSI_PROC( PLISTITEM, FindListItem )( PSI_CONTROL pc, CTEXTSTR text )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
		PLISTITEM pli = plb->items;
		while( pli )
		{
			if( !strcmp( pli->text, text ) )
				break;
			pli = pli->next;
		}
		return (PLISTITEM)pli;
	}
	return 0;
}
//---------------------------------------------------------------------------
PSI_PROC( void, SetSelChangeHandler)( PSI_CONTROL pc, SelectionChanged proc, uintptr_t psvUser )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
		plb->SelChangeHandler = proc;
		plb->psvSelChange = psvUser;
	}
}
//---------------------------------------------------------------------------
PSI_PROC( void, SetDoubleClickHandler )( PSI_CONTROL pc, DoubleClicker proc, uintptr_t psvUser )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
		plb->DoubleClickHandler = proc;
		plb->psvDoubleClick = psvUser;
	}
}
//---------------------------------------------------------------------------
PSI_PROC( int, DisableUpdateListBox )( PSI_CONTROL pc, LOGICAL bDisable )
{
	int bSaved = 0;
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
		bSaved = plb->flags.bNoUpdate;
		if( !bDisable && plb->flags.bNoUpdate )
		{
			//Log( "Reenabling scrollbar updates causes an update... " );
			// duh - must render before we know min/max/range...
			SmudgeCommon( pc );
			UpdateScrollForList( pc );
		}
		plb->flags.bNoUpdate = ( bDisable != FALSE );
	}
	return bSaved;
}
//---------------------------------------------------------------------------
void EnumSelectedListItems( PSI_CONTROL pc
								  , PLISTITEM pliStart
								  , void (CPROC *HandleListItem )(uintptr_t,PSI_CONTROL,PLISTITEM)
								  , uintptr_t psv )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb && plb->flags.bTree )
	{
		PLISTITEM pli = pliStart;
		int nLevel;
		if( !pli )
			pli =  plb->items;
		if( pli )
		{
			pli = pli->next;
			nLevel = pli->nLevel;
			while( pli )
			{
				if( pli->nLevel == nLevel )
				{
					if( pli->flags.bSelected )
						if( HandleListItem )
							HandleListItem( psv, pc, pli );
				}
				if( pli->nLevel < nLevel )
					break;
				pli = pli->next;
			}
		}
	}
	else if( plb )
	{
		PLISTITEM pli = pliStart;
		if( !pli )
			pli =  plb->items;
		if( pli )
		{
			while( pli )
			{
				if( pli->flags.bSelected )
					if( HandleListItem )
						HandleListItem( psv, pc, pli );
				pli = pli->next;
			}
		}
	}
}
//---------------------------------------------------------------------------
void EnumListItems( PSI_CONTROL pc
						, PLISTITEM pliStart
						, void (CPROC *HandleListItem )(uintptr_t,PSI_CONTROL,PLISTITEM)
						, uintptr_t psv )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb->flags.bTree )
	{
		PLISTITEM pli = pliStart;
		int nLevel;
		if( !pli )
			pli =  plb->items;
		if( pli )
		{
			pli = pli->next;
			nLevel = pli->nLevel;
			while( pli )
			{
				if( pli->nLevel == nLevel )
				{
					if( HandleListItem )
						HandleListItem( psv, pc, pli );
				}
				if( pli->nLevel < nLevel )
					break;
				pli = pli->next;
			}
		}
	}
	else
	{
		PLISTITEM pli = pliStart;
		if( !pli )
			pli =  plb->items;
		if( pli )
		{
			while( pli )
			{
				if( HandleListItem )
					HandleListItem( psv, pc, pli );
			}
		}
	}
}
//---------------------------------------------------------------------------
PSI_PROC( void, SetListItemLevel )( PSI_CONTROL pc, int nLevel )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
		plb->nLastLevel = nLevel;
}
//---------------------------------------------------------------------------
PSI_PROC( int, OpenListItem )( PLISTITEM pli, int bOpen )
{
	int prior;
	if( pli )
	{
		prior = pli->flags.bOpen;
		pli->flags.bOpen = ( bOpen != 0 );
		return prior;
	}
	return -1;
}
PSI_PROC( void, SetListItemOpenHandler )( PSI_CONTROL pc, ListItemOpened proc, uintptr_t psvUser )
{
	// this routine is called before the branch is actually opened and rendered...
	// allowing an application to fill in the tree dynamically....
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
		plb->ListItemOpenHandler = proc;
		plb->psvOpenClose = psvUser;
	}
}
//---------------------------------------------------------------------------
 // may someday add SORT_INVERSE?
PSI_CONTROL SetListboxSort( PSI_CONTROL pc, int bSortTrue )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
		plb->flags.bSortNormal = 0;
		if( bSortTrue == 1 )
		{
			plb->flags.bSortNormal = 1;
		}
	}
	return pc;
}
PSI_CONTROL SetListboxMultiSelectEx( PSI_CONTROL pc, int bEnable, int bLazy )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
		plb->flags.bSingle = !bEnable;
		plb->flags.bLazyMulti = bLazy;
	}
	return pc;
}
PSI_CONTROL SetListboxMultiSelect( PSI_CONTROL pc, int bEnable )
{
	return SetListboxMultiSelectEx( pc, bEnable, FALSE );
}
int GetListboxMultiSelectEx( PSI_CONTROL pc, int *multi, int *lazy )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	if( plb )
	{
		if( multi )
			(*multi) = !plb->flags.bSingle;
		if( lazy )
			(*lazy) = !plb->flags.bLazyMulti;
		return !plb->flags.bSingle;
	}
	return 0;
}
int GetListboxMultiSelect( PSI_CONTROL pc )
{
	return GetListboxMultiSelectEx( pc, NULL, NULL );
}
PSI_CONTROL GetItemListbox( PLISTITEM pli )
{
	if( pli )
		return pli->within_list;
	return NULL;
}
//---------------------------------------------------------------------------
static CONTROL_REGISTRATION
listbox = { LISTBOX_CONTROL_NAME
			 , { {110, 73}, sizeof( LISTBOX ), BORDER_INVERT_THIN|BORDER_NOCAPTION }
			 , InitListBox
			 , NULL
 //RenderListBox
			 , NULL
 //MouseListBox
			 , NULL
 //KeyListControl
			 , NULL
			 , DestroyListBox
};
static void OnSizeCommon( LISTBOX_CONTROL_NAME )( PSI_CONTROL pc, LOGICAL begin_move )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	//lprintf( "Resize listbox" );
	if( plb )
	{
		int32_t width = GetFontHeight( GetCommonFont( pc ) ) * 1.2;
		//ScaleCoords( (PSI_CONTROL)pc, &width, NULL );
		// resize the scrollbar accordingly...
		if( plb->flags.bHorizontalScroll ) {
			MoveSizeCommon( plb->pcHScroll, 0, pc->surface_rect.height - width
				, pc->surface_rect.width - width, width
			);
			ResizeImage( plb->ListSurface, pc->surface_rect.width - width
				, pc->surface_rect.height - width );
		} else {
			ResizeImage( plb->ListSurface, pc->surface_rect.width - width
				, pc->surface_rect.height );
		}
		MoveSizeCommon( plb->pcScroll, pc->surface_rect.width - width, 0
			, width, pc->surface_rect.height
		);
	}
}
static void OnScaleCommon( LISTBOX_CONTROL_NAME )( PSI_CONTROL pc )
{
	ValidatedControlData( PLISTBOX, LISTBOX_CONTROL, plb, pc );
	//lprintf( "Rescale listbox" );
	if( plb )
	{
		int32_t width = 15;
		ScaleCoords( (PSI_CONTROL)pc, &width, NULL );
		// resize the scrollbar accordingly...
		MoveSizeCommon( plb->pcScroll , pc->surface_rect.width-width, 0
						  , width, pc->surface_rect.height
						  );
	}
}
PRIORITY_PRELOAD( RegisterListbox, PSI_PRELOAD_PRIORITY )
{
	DoRegisterControl( &listbox );
}
PSI_LISTBOX_NAMESPACE_END
PSI_NAMESPACE
PSI_PROC( void, SimpleMessageBox )( PSI_CONTROL parent, CTEXTSTR title, CTEXTSTR content )
{
	PSI_CONTROL msg;
	CTEXTSTR start, end;
	TEXTCHAR msgtext[256];
	int okay = 0;
	int y = 5;
	uint32_t width, height;
	uint32_t title_width, greatest_width;
#ifdef USE_INTERFACES
	GetMyInterface();
#endif
	GetStringSize( content, &width, &height );
	title_width = GetStringSize( title, NULL, NULL );
	if( title_width > width )
		greatest_width = title_width;
	else
		greatest_width = width;
	msg = CreateFrame( title, 0, 0
						 , greatest_width + 10, height + (COMMON_BUTTON_PAD * 3) + COMMON_BUTTON_HEIGHT
						 , 0, parent );
	end = start = content;
	do
	{
		while( end[0] && end[0] != '\n' )
			end++;
		if( end[0] )
		{
			MemCpy( msgtext, (POINTER)start, end-start );
			msgtext[end-start] = 0;
			//end[0] = 0;
			MakeTextControl( msg, COMMON_BUTTON_PAD, y
							  , greatest_width, height
							  , -1, msgtext, 0 );
			//end[0] = '\n';
			end = start = end+1;
			y += height;
		}
		else
			MakeTextControl( msg, COMMON_BUTTON_PAD, y
							  , greatest_width, height
							  , -1, start, 0 );
	} while( end[0] );
	//AddExitButton( msg, &done );
	AddCommonButtons( msg, NULL, &okay );
	lprintf( "show message box" );
	DisplayFrame( msg );
	CommonWait( msg );
	DestroyFrame( &msg );
}
int SimpleUserQuery( TEXTSTR result, int reslen, CTEXTSTR question, PSI_CONTROL pAbove )
{
	return SimpleUserQueryEx( result, reslen, question, pAbove, NULL, 0 );
}
struct user_query_info{
 // frame
	PSI_CONTROL pf;
	PSI_CONTROL edit;
	int Done;
	int Okay;
	void (CPROC*query_success)(uintptr_t,LOGICAL);
	uintptr_t query_user_data;
	TEXTSTR result;
	int reslen;
};
static void query_success_trigger( void )
{
	//struct user_query_info *query_state = (struct user_query_info*)GetCommonUserData( pc );
}
static void CPROC OkayClicked( uintptr_t psv, PSI_CONTROL pc )
{
	struct user_query_info *query_state = (struct user_query_info *)psv;
	query_state->Okay = 1;
	query_state->Done = 1;
	GetControlText( query_state->edit, query_state->result, query_state->reslen );
	if( query_state->query_success )
	{
		query_state->query_success( query_state->query_user_data, TRUE );
		{
			PSI_CONTROL pf = GetFrame( pc );
			DestroyFrame( &pf );
		}
		Release( query_state );
	}
	//Release( query_state->result );
}
static void CPROC CancelClicked( uintptr_t psv, PSI_CONTROL pc )
{
	struct user_query_info *query_state = (struct user_query_info *)psv;
	query_state->Done = 1;
	if( query_state->query_success )
	{
		query_state->query_success( query_state->query_user_data, FALSE );
		{
			PSI_CONTROL pf = GetFrame( pc );
			DestroyFrame( &pf );
		}
		Release( query_state );
	}
	//Release( query_state->result );
}
int SimpleUserQueryEx( TEXTSTR result, int reslen, CTEXTSTR question, PSI_CONTROL pAbove, void (CPROC*query_success_callback)(uintptr_t, LOGICAL), uintptr_t query_user_data )
{
	PSI_CONTROL pf, pc;
	struct user_query_info *query_state = New( struct user_query_info );
	int32_t mouse_x, mouse_y;
	//int Done = FALSE, Okay = FALSE;
	pf = CreateFrame( NULL, 0, 0, 280, 70, 0, pAbove );
	SetControlUserData( pf, (uintptr_t)query_state );
	query_state->pf = pf;
	query_state->Done = FALSE;
	query_state->Okay = FALSE;
	query_state->result = result;
	query_state->reslen = reslen;
	pc = MakeTextControl( pf, 5, 2, 320, 18, TXT_STATIC, question, TEXT_NORMAL );
	query_state->edit = MakeEditControl( pf, 5, 23, 270, 20, TXT_STATIC, NULL, 0 );
	AddCommonButtons( pf, &query_state->Done, &query_state->Okay );
	SetButtonPushMethod( GetControl( pf, IDOK ), OkayClicked, (uintptr_t)query_state );
	SetButtonPushMethod( GetControl( pf, IDCANCEL ), CancelClicked, (uintptr_t)query_state );
	GetMousePosition( &mouse_x, &mouse_y );
	MoveFrame( pf, mouse_x - 140, mouse_y - 30 );
	//lprintf( "Show query...." );
	DisplayFrame( pf );
	SetCommonFocus( query_state->edit );
	query_state->query_success = query_success_callback;
	if( !query_success_callback )
	{
		int okay;
		CommonWait( pf );
		if( query_state->Okay )
		{
			GetControlText( query_state->edit, result, reslen );
		}
		DestroyFrame( &pf );
		okay = query_state->Okay;
		Release( query_state );
		return okay;
	}
	else
	{
		query_state->query_success = query_success_callback;
		query_state->query_user_data = query_user_data;
		return 0;
	}
}
void RegisterResource( CTEXTSTR appname, CTEXTSTR resource_name, int resource_name_id, int resource_name_range, CTEXTSTR type_name )
{
	static int nextID = 10000;
	if( !resource_name_id )
	{
		resource_name_id = nextID;
		if( !resource_name_range )
			resource_name_range = 1;
		nextID += resource_name_range;
	}
	{
		TEXTCHAR root[256];
		TEXTCHAR old_root[256];
		//lprintf( "resource name = %s", resource_names[n].type_name );
		//lprintf( "resource name = %s", resource_names[n].resource_name );
		tnprintf( root, sizeof( root ), PSI_ROOT_REGISTRY "/resources/" "%s/%s/%s"
				  , type_name
				  , appname
				  , resource_name
				  );
			RegisterIntValue( root
								 , "value"
								 , resource_name_id );
			RegisterIntValue( root
								 , "range"
								 , resource_name_range );
			tnprintf( root, sizeof( root ), PSI_ROOT_REGISTRY "/resources/" "%s" "/%s"
					, type_name
					  , appname
						);
			tnprintf( old_root, sizeof( old_root ), PSI_ROOT_REGISTRY "/resources/" "%s" "/%s"
					  , appname
					  , type_name
						);
			RegisterIntValue( root
								 , resource_name
								 , resource_name_id );
			RegisterClassAlias( root, old_root );
	}
}
PSI_NAMESPACE_END
PSI_PROP_NAMESPACE
extern ControlInitProc KnownControlInit[];
#ifndef FIRST_SYMBOL_VALUE
#define FIRST_SYMBOL_VALUE 1
#endif
#ifndef BUILD_NAMES
#  if !defined( NAME_ENUMERATION_DECLARED )
#    define FIRST_SYMNAME(name,control_type_name)    FIRST_SYMBOL = FIRST_SYMBOL_VALUE, name = FIRST_SYMBOL_VALUE
#    define SYMNAME(name,control_type_name)        , name
#    define SYMNAME_SKIP(prior, range, name,control_type_name)        , prior, name = prior+range
enum resource_enum {
#  endif
#endif
#if !defined( NAME_ENUMERATION_DECLARED ) || defined( BUILD_NAMES )
#undef BTN_OKAY
#undef BTN_CANCEL
FIRST_SYMNAME( BTN_OKAY, NORMAL_BUTTON_NAME )
SYMNAME(BTN_CANCEL,NORMAL_BUTTON_NAME)
SYMNAME( BTN_ABORT, NORMAL_BUTTON_NAME )
SYMNAME( EDT_X     , EDIT_FIELD_NAME )
SYMNAME( EDT_Y     , EDIT_FIELD_NAME )
SYMNAME( EDT_WIDTH , EDIT_FIELD_NAME )
SYMNAME( EDT_HEIGHT, EDIT_FIELD_NAME )
SYMNAME( EDT_CAPTION, EDIT_FIELD_NAME)
SYMNAME( EDT_ID     , EDIT_FIELD_NAME)
SYMNAME( EDT_IDNAME , EDIT_FIELD_NAME)
SYMNAME( LABEL_X    , STATIC_TEXT_NAME )
SYMNAME( LABEL_Y    , STATIC_TEXT_NAME)
SYMNAME( LABEL_WIDTH  , STATIC_TEXT_NAME)
SYMNAME( LABEL_HEIGHT , STATIC_TEXT_NAME)
SYMNAME( LABEL_CAPTION, STATIC_TEXT_NAME)
SYMNAME( LABEL_ID     , STATIC_TEXT_NAME)
SYMNAME( LISTBOX_IDS , LISTBOX_CONTROL_NAME  )
SYMNAME( SLD_GREENBAR    , SLIDER_CONTROL_NAME )
SYMNAME( PAL_COLORS      , "Color Matrix" )
 // define a preset
SYMNAME( BTN_PRESET      , NORMAL_BUTTON_NAME )
SYMNAME( CHK_ALPHA       , RADIO_BUTTON_NAME  )
SYMNAME( CST_SHADE       , "Shade Well" )
SYMNAME( CST_ZOOM        , "Shade Well" )
SYMNAME( CST_SHADE_RED   , "Shade Well" )
SYMNAME( CST_SHADE_BLUE  , "Shade Well" )
SYMNAME( CST_SHADE_GREEN , "Shade Well" )
		SYMNAME_SKIP( BTN_PRESET_BASE, 64, BTN_PRESET_LAST, CUSTOM_BUTTON_NAME )
#endif
#ifndef BUILD_NAMES
#  if !defined( NAME_ENUMERATION_DECLARED )
#  define NAME_ENUMERATION_DECLARED
};
#  endif
#endif
#undef SYMNAME
#undef FIRST_SYMNAME
#undef SYMNAME_SKIP
#undef BUILD_NAMES
/*
#define EDT_X       100
#define EDT_Y       101
#define EDT_WIDTH   102
#define EDT_HEIGHT  103
#define EDT_CAPTION 104
#define EDT_ID      105
#define LABEL_X       200
#define LABEL_Y       201
#define LABEL_WIDTH   202
#define LABEL_HEIGHT  203
#define LABEL_CAPTION 204
#define LABEL_ID      205
#define LISTBOX_IDS   300
*/
// this is a base - probably 100 is good
// space to have
#define MNU_ADDCONTROL 1000
#define MNU_EDITTHING  2000
#define MNU_DONE 2001
#define MNU_DELETETHING 2002
#define MNU_SAVEFRAME 2003
static PMENU pFrameEditMenu, pControlEditMenu;
//static PSI_CONTROL pEditProperties;
typedef struct edit_property_data_tag {
	PSI_CONTROL *ppFrame;
	PSI_CONTROL pEditCurrent;
	PSI_CONTROL pPropertySheet;
	int32_t x,y;
	int bDone, bOkay;
	PSI_CONTROL control, pSheet;
   PSI_CONTROL frame;
} EDIT_PROP_DATA, *PEDIT_PROP_DATA;
//---------------------------------------------------------------------------
#define DEFAULT_BUTTON_WIDTH  150
#define DEFAULT_BUTTON_HEIGHT 20
#define DEFAULT_BUTTON_BORDER BORDER_NORMAL
void CreateAControl( PSI_CONTROL frame, uint32_t type, PEDIT_PROP_DATA pepd )
{
	//if( type < USER_CONTROL )
	{
		int32_t x = pepd->x;
		int32_t y = pepd->y;
		//lprintf( "new control at %" _32fs ",%" _32fs " %" _32f ",%" _32f, x, y, frame->rect.x, frame->rect.y );
		PFRACTION ix, iy;
		GetCommonScale( frame, &ix, &iy );
		x = InverseScaleValue( ix, x );
		y = InverseScaleValue( iy, y );
		MakeControl( frame, type, x, y, 0, 0, -1 );
	}
}
//---------------------------------------------------------------------------
struct list_item_data
{
 // app name
	CTEXTSTR appname;
 // resource name
	CTEXTSTR resname;
 // control type name
	CTEXTSTR _typename;
	int value;
	int range;
};
void CPROC SetControlIDProperty( uintptr_t psv, PSI_CONTROL list, PLISTITEM item )
{
	struct list_item_data *data = (struct list_item_data*)GetItemData( item );
	if( data )
	{
		//uint32_t ID = GetItemData( item );
		PSI_CONTROL edit = GetNearControl( list, EDT_ID );
		if( edit )
		{
			TEXTCHAR buffer[32];
			if( data->range > 1 )
				tnprintf( buffer, sizeof( buffer ), "%d + %d", data->value, data->range );
			else
				tnprintf( buffer, sizeof( buffer ), "%d", data->value );
			SetControlText( edit, buffer );
			{
				TEXTCHAR buffer2[256];
				tnprintf( buffer2, sizeof( buffer ), "%s/%s/%s", data->appname, data->_typename, data->resname );
				SetControlText( GetNearControl( list, EDT_IDNAME ), buffer2 );
			}
		}
	}
}
int FillControlIDList( CTEXTSTR root, PSI_CONTROL listbox, PSI_CONTROL pc, int level, CTEXTSTR priorname )
{
	int status = FALSE;
	CTEXTSTR name;
	PCLASSROOT data = NULL;
	TEXTCHAR rootname[256];
	//lprintf( "Look for resoruces under %s at %d", root, level );
	tnprintf( rootname, sizeof( rootname ), PSI_ROOT_REGISTRY "/resources/%s%s%s"
			  , pc->pTypeName
			  , root?"/":""
			  , root?root:"" );
	for( name = GetFirstRegisteredName( rootname, &data );
		 name;
		  name = GetNextRegisteredName( &data ) )
	{
		if( !NameIsAlias( &data ) )
		{
			int value = (int)(uintptr_t)GetRegisteredValueExx( (CTEXTSTR)data, name, "value", TRUE );
			if( value )
			{
				struct list_item_data *itemdata = (struct list_item_data*)Allocate( sizeof( *itemdata ) );
				itemdata->appname = StrDup( root );
				itemdata->_typename = pc->pTypeName;
				itemdata->resname = name;
				/* ETHICALITY DISCLAIMED: this is an okay conversion, cause we're asking for an INT type anyhow...*/
				itemdata->value = (int)(uintptr_t)GetRegisteredValueExx( (CTEXTSTR)data, name, "value", TRUE );
				/* ETHICALITY DISCLAIMED: this is an okay conversion, cause we're asking for an INT type anyhow...*/
				itemdata->range = (int)(uintptr_t)GetRegisteredValueExx( (CTEXTSTR)data, name, "range", TRUE );
				//lprintf( "Found Name %s", name2 );
				SetItemData( AddListItemEx( listbox, level, name ), (uintptr_t)itemdata );
				status = TRUE;
			}
			else
			{
				PLISTITEM pli;
				if( !NameIsAlias( &data ) )
				{
					tnprintf( rootname, sizeof(rootname),"%s%s%s", root?root:"", root?"/":"", name );
					pli = AddListItemEx( listbox, level, name );
					if( !FillControlIDList( rootname, listbox, pc, level+1, name ) )
					{
						DeleteListItem( listbox, pli );
					}
					else
						status = TRUE;
				}
			}
		}
	}
	return status;
}
void InitFrameControls( PSI_CONTROL pcFrame, PSI_CONTROL pc )
{
	TEXTCHAR buffer[128];
	SetControlText( GetControl( pcFrame, LABEL_CAPTION ), "Caption" );
	SetControlText( GetControl( pcFrame, LABEL_X ), "X" );
	SetControlText( GetControl( pcFrame, LABEL_Y ), "Y" );
	SetControlText( GetControl( pcFrame, LABEL_WIDTH ), "Width" );
	SetControlText( GetControl( pcFrame, LABEL_HEIGHT ), "Height" );
	SetControlText( GetControl( pcFrame, LABEL_ID ), "ID" );
	tnprintf( buffer, sizeof( buffer ), "%s", pc->caption.text?GetText( pc->caption.text ):"" );
	SetControlText( GetControl( pcFrame, EDT_CAPTION ), buffer );
	tnprintf( buffer, sizeof( buffer ), "%" _32fs, pc->rect.x );
	SetControlText( GetControl( pcFrame, EDT_X ), buffer );
	tnprintf( buffer, sizeof( buffer ), "%" _32fs, pc->rect.y );
	SetControlText( GetControl( pcFrame, EDT_Y ), buffer );
	tnprintf( buffer, sizeof( buffer ), "%" _32f, pc->rect.width );
	SetControlText( GetControl( pcFrame, EDT_WIDTH ), buffer );
	tnprintf( buffer, sizeof( buffer ), "%" _32f, pc->rect.height );
	SetControlText( GetControl( pcFrame, EDT_HEIGHT ), buffer );
	tnprintf( buffer, sizeof( buffer ), "%d", pc->nID );
	SetControlText( GetControl( pcFrame, EDT_ID ), buffer );
	SetControlText( GetControl( pcFrame, EDT_IDNAME ), pc->pIDName );
	{
		PSI_CONTROL list = GetControl( pcFrame, LISTBOX_IDS );
		if( list )
		{
//cpg26dec2006 c:\work\sack\src\psilib\ctlprop.c(214): Warning! W202: Symbol 'name' has been defined, but not referenced
//cpg26dec2006 c:\work\sack\src\psilib\ctlprop.c(215): Warning! W202: Symbol 'data' has been defined, but not referenced
//cpg26dec2006			 CTEXTSTR name;
//cpg26dec2006			 POINTER data = NULL;
			SetListboxIsTree( list, TRUE );
			SetSelChangeHandler( list, SetControlIDProperty, (uintptr_t)pc );
			FillControlIDList( NULL, list, pc, 0, NULL );
#if 0
			for( name = GetFirstRegisteredName( PSI_ROOT_REGISTRY "/resources", &data );
				 name;
				  name = GetNextRegisteredName( &data ) )
			{
				{
					char rootname[256];
					CTEXTSTR name2;
					int first = 1;
					POINTER data2 = NULL;
					tnprintf( rootname, sizeof(rootname),PSI_ROOT_REGISTRY "/resources/%s/%s", name, pc->pTypeName );
					//lprintf( "newroot = %s", rootname );
					for( name2 = GetFirstRegisteredName( rootname, &data2 );
						 name2;
						  name2 = GetNextRegisteredName( &data2 ) )
					{
						struct list_item_data *data = (struct list_item_data*)Allocate( sizeof( *data ) );
						data->appname = name;
						data->_typename = pc->pTypeName;
						data->resname = name2;
						/* ETHICALITY DISCLAIMED: this is an okay conversion, cause we're asking for an INT type anyhow...*/
						data->value = (int)(long)GetRegisteredValueExx( (CTEXTSTR)data2, name2, "value", TRUE );
						/* ETHICALITY DISCLAIMED: this is an okay conversion, cause we're asking for an INT type anyhow...*/
						data->range = (int)(long)GetRegisteredValueExx( (CTEXTSTR)data2, name2, "range", TRUE );
						lprintf( "Found Name %s", name2 );
						if( first )
							AddListItemEx( list, 0, name );
						first = 0;
						SetItemData( AddListItemEx( list, 1, name2 ), (uintptr_t)data );
					}
				}
			}
#endif
		}
#if 0
		char rootname[256];
		void (CPROC*f)(uintptr_t);
		tnprintf( rootname, sizeof( rootname ), PSI_ROOT_REGISTRY "/resources/", button->pTypeName );
		f = GetRegisteredProcedure2( rootname, void, "button_destroy", (uintptr_t) );
		if( f )
			f(button->psvUser);
#endif
	}
}
// LOL that's pretty sexy, huh? LOL
#ifndef _MSC_VER
// vc8 pukes on statick initialziation here
static
#endif
TEXTCHAR control_property_frame_xml[] = {
//#define stuff(a) #a
"<control  border=\"4420\" caption=\"Page Properties\" position=\"0,0\" size=\"404,234\" type=\"Frame\">"
"<control IDName=\"ListBox/core/LISTBOX_IDS\" border=\"81\" caption=\"\" position=\"16,6\" size=\"331,95\" type=\"ListBox\"></control>"
"<control IDName=\"EditControl/core/EDT_CAPTION\" border=\"81\" caption=\"\" position=\"26,124\" size=\"321,21\" type=\"EditControl\"></control>"
"<control IDName=\"EditControl/core/EDT_ID\" border=\"81\" caption=\"\" position=\"28,154\" size=\"73,21\" type=\"EditControl\"></control>"
"<control IDName=\"EditControl/core/EDT_IDNAME\" border=\"81\" caption=\"\" position=\"106,154\" size=\"240,21\" type=\"EditControl\"></control>"
"</control>"
 };
static void  doneEvent( uintptr_t psv, PSI_CONTROL pf, int done, int okay ) {
	PEDIT_PROP_DATA pEditProps = (PEDIT_PROP_DATA)psv;
			if( pEditProps->bOkay )
			{
				PSI_CONTROL pc;
				int32_t x, y;
				uint32_t w, h, id;
				static TEXTCHAR buffer[32000];
				GetControlText( GetControl(pEditProps->pSheet, EDT_CAPTION ), buffer, sizeof( buffer ) );
				SetControlText( pEditProps->control, buffer );
				GetControlText( pc = GetControl(pEditProps->pSheet, EDT_X ), buffer, sizeof( buffer ) );
				if( pc )
					x = (int32_t)IntCreateFromText( buffer );
				if( pc )
				{
					GetControlText( pc = GetControl( pEditProps->pSheet, EDT_Y), buffer, sizeof( buffer ) );
					if( pc )
					{
						y = (int32_t)IntCreateFromText( buffer );
						MoveControl( pEditProps->control, x, y );
					}
				}
				GetControlText( pc = GetControl(pEditProps->pSheet, EDT_WIDTH ), buffer, sizeof( buffer ) );
				if( pc )
				{
					w = (uint32_t)IntCreateFromText( buffer );
					GetControlText( pc = GetControl(pEditProps->pSheet, EDT_HEIGHT ), buffer, sizeof( buffer ) );
					if( pc )
					{
						h = (uint32_t)IntCreateFromText( buffer );
						SizeControl( pEditProps->control, w, h );
					}
				}
				GetControlText( GetControl(pEditProps->pSheet, EDT_ID ), buffer, sizeof( buffer ) );
				id = (uint32_t)IntCreateFromText( buffer );
				SetControlID( (PSI_CONTROL)pEditProps->control, id );
				GetControlText( GetControl( pEditProps->pSheet, EDT_IDNAME ), buffer, sizeof( buffer ) );
				if( buffer[0] )
				{
					if( pEditProps->control->pIDName )
						Release( (POINTER)pEditProps->control->pIDName );
					pEditProps->control->pIDName = StrDup( buffer );
				}
				if( pEditProps->pPropertySheet )
				{
					TEXTCHAR classname[32];
					ApplyControlPropSheet Apply;
					tnprintf( classname, sizeof( classname ), PSI_ROOT_REGISTRY "/control/%d/rtti", pEditProps->control->nType );
					Apply = GetRegisteredProcedure( classname, void, read_property_page, (PSI_CONTROL, PSI_CONTROL) );
					if( Apply )
					{
						Apply( (PSI_CONTROL)pEditProps->pPropertySheet, (PSI_CONTROL)pc );
					}
				}
			}
			// not sure if this gets killed...
			//DestroyFrame( pEditProps->pSheet );
			DestroyCommon( &pEditProps->frame );
				{
					TEXTCHAR classname[32];
					DoneControlPropSheet Done;
					tnprintf( classname, sizeof( classname ), PSI_ROOT_REGISTRY "/control/%d/rtti", pEditProps->control->nType );
					Done = GetRegisteredProcedure( classname, void, done_property_page, (PSI_CONTROL) );
					if( Done )
					{
						Done( (PSI_CONTROL)pEditProps->pPropertySheet );
					}
				}
				Release( pEditProps );
}
static void popupCallback( uintptr_t psv, int select ) {
	PEDIT_PROP_DATA pEditProps = (PEDIT_PROP_DATA)psv;
	if( select < 0 )
		return;
	switch( select )
	{
	case MNU_DONE:
		EditFrame( GetFrame( pEditProps->control ), FALSE );
		break;
	case MNU_DELETETHING:
		DestroyCommon( &pEditProps->control );
		break;
	case MNU_EDITTHING:
		if( pEditProps )
		{
			pEditProps->bDone = FALSE;
			pEditProps->bOkay = FALSE;
			pEditProps->pEditCurrent = pEditProps->control;
		}
		//GetMousePosition( &pEditProps->x, &y );
		{
			PSI_CONTROL pf = CreateFrame( "Control Properties"
							 , (pEditProps->x - PROP_WIDTH/2)>0?(pEditProps->x - PROP_WIDTH/2):0, pEditProps->y
							 , PROP_WIDTH + 20
							 , PROP_HEIGHT + 20 + 25, BORDER_NORMAL, GetFrame( pEditProps->control ) );
			static int bAnotherLayer;
			PSI_CONTROL pcSheet = MakeSheetControl( pf
													, 5, 5
													, PROP_WIDTH+10, PROP_HEIGHT + 10
													, -1 );
			if( !bAnotherLayer )
			{
				bAnotherLayer++;
				pEditProps->pSheet = ParseXMLFrame( control_property_frame_xml, sizeof( control_property_frame_xml ) );
				if( !pEditProps->pSheet )
					pEditProps->pSheet = LoadXMLFrame( "Common Edit.Frame" );
				//DumpFrameContents( pEditProps->pSheet );
				bAnotherLayer--;
			}
			if( pEditProps->pSheet )
			{
				//lprintf( "****************" );
				InitFrameControls( pEditProps->pSheet, pEditProps->control );
			}
			else
			{
				pEditProps->pSheet = CreateFrame( "Common"
										  , 0, 0, PROP_WIDTH
										  , PROP_HEIGHT, BORDER_NONE|BORDER_WITHIN, NULL );
				if( pEditProps->pSheet )
				{
					TEXTCHAR buffer[256];
					MakeTextControl( pEditProps->pSheet, PROP_PAD, 05, 58, 14, TXT_STATIC, "Caption", 0 );
					MakeTextControl( pEditProps->pSheet, PROP_PAD, 21, 58, 14, TXT_STATIC, "X", 0 );
					MakeTextControl( pEditProps->pSheet, PROP_PAD, 37, 58, 14, TXT_STATIC, "Y", 0 );
					MakeTextControl( pEditProps->pSheet, PROP_PAD, 53, 58, 14, TXT_STATIC, "Width", 0 );
					MakeTextControl( pEditProps->pSheet, PROP_PAD, 69, 58, 14, TXT_STATIC, "Height", 0 );
					MakeTextControl( pEditProps->pSheet, PROP_PAD, 85, 58, 14, TXT_STATIC, "ID", 0 );
					MakeTextControl( pEditProps->pSheet, PROP_PAD, 101, 58, 14, TXT_STATIC, "ID Name", 0 );
					tnprintf( buffer, sizeof( buffer ), "%s", GetText( pEditProps->control->caption.text ) );
					MakeEditControl( pEditProps->pSheet, PROP_PAD + PROP_PAD + 58, 04, PROP_WIDTH-10-(58+5), 14, EDT_CAPTION, buffer, 0 );
					tnprintf( buffer, sizeof( buffer ), "%" _32fs, pEditProps->control->rect.x );
					MakeEditControl( pEditProps->pSheet, PROP_PAD + PROP_PAD + 58, 20, 56, 14, EDT_X, buffer, 0 );
					tnprintf( buffer, sizeof( buffer ), "%" _32fs, pEditProps->control->rect.y );
					MakeEditControl( pEditProps->pSheet, PROP_PAD + PROP_PAD + 58, 36, 56, 14, EDT_Y, buffer, 0 );
					tnprintf( buffer, sizeof( buffer ), "%" _32f, pEditProps->control->rect.width );
					MakeEditControl( pEditProps->pSheet, PROP_PAD + PROP_PAD + 58, 52, 56, 14, EDT_WIDTH, buffer, 0 );
					tnprintf( buffer, sizeof( buffer ), "%" _32f, pEditProps->control->rect.height );
					MakeEditControl( pEditProps->pSheet, PROP_PAD + PROP_PAD + 58, 68, 56, 14, EDT_HEIGHT, buffer, 0 );
					tnprintf( buffer, sizeof( buffer ), "%d", pEditProps->control->nID );
					MakeEditControl( pEditProps->pSheet, PROP_PAD + PROP_PAD + 58, 84, 56, 14, EDT_ID, buffer, 0 );
					tnprintf( buffer, sizeof( buffer ), "%s", pEditProps->control->pIDName );
					MakeEditControl( pEditProps->pSheet, PROP_PAD + PROP_PAD + 58, 84, 56, 14, EDT_IDNAME, buffer, 0 );
					MakeListBox( pEditProps->pSheet, PROP_PAD, 117, 400, 200, LISTBOX_IDS, 0 );
					//SaveXMLFrame( pSheet, "Common Edit.Frame" );
					InitFrameControls( pEditProps->pSheet, pEditProps->control );
					//DumpFrameContents( pSheet );
				}
			 }
			//DebugBreak();
			if( !pEditProps->pSheet )
			{
				//DebugBreak(); // there's more to cleanup here.
			}
			AddSheet( pcSheet, pEditProps->pSheet );
			{
				TEXTCHAR classname[32];
				GetControlPropSheet gcps;
				tnprintf( classname, sizeof( classname ), PSI_ROOT_REGISTRY "/control/%d/rtti", pEditProps->control->nType );
				gcps = GetRegisteredProcedure( classname, PSI_CONTROL, get_property_page, (PSI_CONTROL) );
				if( gcps )
				{
					PSI_CONTROL pCustomSheet;
					pCustomSheet = gcps( (PSI_CONTROL)pEditProps->control );
					lprintf( "Got the page..." );
					AddSheet( pcSheet
							  , (PSI_CONTROL)(pEditProps->pPropertySheet = pCustomSheet) );
				}
				else
					lprintf( "can't Get the page..." );
			}
			AddCommonButtons( pf, &pEditProps->bDone, &pEditProps->bOkay );
			DisplayFrame( pf );
			pEditProps->frame = pf;
			//EditFrame( pf, TRUE );
			//DumpFrameContents( pf );
			PSI_HandleStatusEvent( pf, doneEvent, (uintptr_t)pEditProps );
 // this returns instead of break, because it shouldn't release editprops
			return;
		}
		default:
			lprintf( "Unknown menu option chosen.  Custom control?" );
			break;
	}
	Release( pEditProps );
}
PSI_PROC( int, EditControlProperties )( PSI_CONTROL control )
{
	PEDIT_PROP_DATA pEditProps = (PEDIT_PROP_DATA)Allocate( sizeof( EDIT_PROP_DATA ) );
	PSI_CONTROL pf = NULL;
	pEditProps->control = control;
	GetMousePosition( &pEditProps->x, &pEditProps->y );
	TrackPopup_v2( pControlEditMenu, GetFrame( control ), popupCallback, (uintptr_t)pEditProps );
	return 1;
}
//---------------------------------------------------------------------------
static void framePropertyCallback( uintptr_t psv, PSI_CONTROL pf, int done, int okay ) {
	PEDIT_PROP_DATA pEditProps = (PEDIT_PROP_DATA)psv;
			TEXTCHAR buffer[128];
			if( pEditProps->bOkay )
			{
				int32_t x2, y2;
				uint32_t w, h, id;
				GetControlText( GetControl(pf, EDT_CAPTION ), buffer, sizeof( buffer ) );
				SetControlText( pEditProps->frame, buffer );
				GetControlText( GetControl(pf, EDT_X ), buffer, sizeof( buffer ) );
				x2 = (int32_t)IntCreateFromText( buffer );
				GetControlText( GetControl(pf, EDT_Y), buffer, sizeof( buffer ) );
				y2 = (int32_t)IntCreateFromText( buffer );
				MoveFrame( pEditProps->frame, x2, y2 );
				GetControlText( GetControl(pf, EDT_WIDTH ), buffer, sizeof( buffer ) );
				w = (uint32_t)IntCreateFromText( buffer );
				GetControlText( GetControl(pf, EDT_HEIGHT ), buffer, sizeof( buffer ) );
				h = (uint32_t)IntCreateFromText( buffer );
				SizeFrame( pEditProps->frame, w, h );
				GetControlText( GetControl(pf, EDT_ID ), buffer, sizeof( buffer ) );
				id = (uint32_t)IntCreateFromText( buffer );
				SetControlID( pEditProps->frame, id );
			}
			DestroyCommon( &pEditProps->frame );
			Release( pEditProps );
}
static void frameCallback( uintptr_t psv, int select ) {
	PEDIT_PROP_DATA pEditProps = (PEDIT_PROP_DATA)psv;
	if( select >= MNU_ADDCONTROL &&
		select < ( MNU_ADDCONTROL + 1000 ) )
	{
		CreateAControl( pEditProps->frame, select - MNU_ADDCONTROL, pEditProps );
	}
	else switch( select )
	{
	case MNU_DONE:
		EditFrame( pEditProps->frame, FALSE );
		break;
	case MNU_DELETETHING:
		{
			PTHREAD thread = pEditProps->frame->pCommonButtonData.thread;
			DestroyFrame( &pEditProps->frame );
			WakeThread( thread );
		}
		break;
	case MNU_SAVEFRAME:
		// should pick a file here...
		SaveXMLFrame( pEditProps->frame, NULL );
		break;
	case MNU_EDITTHING:
		if( pEditProps )
		{
			pEditProps->bDone = FALSE;
			pEditProps->bOkay = FALSE;
			pEditProps->pEditCurrent = (PSI_CONTROL)pEditProps->frame;
		}
		//GetMousePosition( &x, &y );
		PSI_CONTROL pf = CreateFrame( "Frame Properties"
							 , (pEditProps->x - PROP_WIDTH/2)>0?(pEditProps->x - PROP_WIDTH/2):0, pEditProps->y, PROP_WIDTH
							 , 120, BORDER_NORMAL, GetFrame( pEditProps->frame ) );
		if( pf )
		{
			TEXTCHAR buffer[128];
			MakeTextControl( pf, PROP_PAD, 05, 58, 12, TXT_STATIC, "Caption", 0 );
			MakeTextControl( pf, PROP_PAD, 21, 58, 12, TXT_STATIC, "X", 0 );
			MakeTextControl( pf, PROP_PAD, 37, 58, 12, TXT_STATIC, "Y", 0 );
			MakeTextControl( pf, PROP_PAD, 53, 58, 12, TXT_STATIC, "Width", 0 );
			MakeTextControl( pf, PROP_PAD, 69, 58, 12, TXT_STATIC, "Height", 0 );
			MakeTextControl( pf, PROP_PAD, 85, 58, 12, TXT_STATIC, "ID", 0 );
			tnprintf( buffer, sizeof( buffer ), "%s", GetText( pEditProps->frame->caption.text ) );
			MakeEditControl( pf
								, PROP_PAD + PROP_PAD + 58, 04
								, PROP_WIDTH-10-(58+5), 14
								, EDT_CAPTION, buffer, 0 );
			tnprintf( buffer, sizeof( buffer ), "%" _32fs, pEditProps->frame->rect.x );
			MakeEditControl( pf
								, PROP_PAD + PROP_PAD + 58, 20
								, 56, 14, EDT_X, buffer, 0 );
			tnprintf( buffer, sizeof( buffer ), "%" _32fs, pEditProps->frame->rect.y );
			MakeEditControl( pf
								, PROP_PAD + PROP_PAD + 58, 36
								, 56, 14, EDT_Y, buffer, 0 );
			tnprintf( buffer, sizeof( buffer ), "%" _32f, pEditProps->frame->rect.width );
			MakeEditControl( pf
								, PROP_PAD + PROP_PAD + 58, 52
								, 56, 14, EDT_WIDTH, buffer, 0 );
			tnprintf( buffer, sizeof( buffer ), "%" _32f, pEditProps->frame->rect.height );
			MakeEditControl( pf
								, PROP_PAD + PROP_PAD + 58, 68
								, 56, 14, EDT_HEIGHT, buffer, 0 );
			tnprintf( buffer, sizeof( buffer ), "%d", pEditProps->frame->nID );
			MakeEditControl( pf
								, PROP_PAD + PROP_PAD + 58, 84
								, 56, 14, EDT_ID, buffer, 0 );
			AddCommonButtons( pf, &pEditProps->bDone, &pEditProps->bOkay );
			DisplayFrame( pf );
			pEditProps->frame = pf;
            PSI_HandleStatusEvent( pf, framePropertyCallback, psv );
		}
 // this isn't a brak, because it should not release edit props...
		return;
	}
	Release( pEditProps );
}
PSI_PROC( int, EditFrameProperties )( PSI_CONTROL frame, int32_t x, int32_t y )
{
	PEDIT_PROP_DATA pEditProps = (PEDIT_PROP_DATA)Allocate( sizeof( EDIT_PROP_DATA ) );
	pEditProps->x = x - frame->surface_rect.x;
	pEditProps->y = y - frame->surface_rect.y;
	pEditProps->frame = frame;
	TrackPopup_v2( pFrameEditMenu, frame, frameCallback, (uintptr_t)pEditProps );
	return 1;
}
//---------------------------------------------------------------------------
void DetachChildFrames( PSI_CONTROL pc )
{
	// LOL this will be fun... watch the world fall to pieced
	if( pc && pc->child )
	{
		for( pc = pc->child; pc; pc = pc->next )
		{
			if( pc->BeginEdit )
			{
				// this allows the sheet control to detach the sheets before edit begins.
				pc->BeginEdit( pc );
			}
			DetachChildFrames( pc );
			if( !pc->flags.private_control &&
				 pc->nType == CONTROL_FRAME )
			{
				//DebugBreak();
				pc->detached_at = pc->original_rect;
				DisplayFrame( pc );
				EditFrame( pc, TRUE );
				pc->flags.detached = 1;
			}
		}
	}
}
//---------------------------------------------------------------------------
void RetachChildFrames( PSI_CONTROL pc )
{
	// LOL this will be fun... watch the world fall to pieced
	if( pc )
	{
		PSI_CONTROL parent = pc->parent;
		for( pc = pc; pc; pc = pc->next )
		{
			if( pc->child )
				RetachChildFrames( pc->child );
			if( pc->flags.detached )
			{
				uint32_t BorderType = pc->device->EditState.BorderType;
				// adopt should close the device, if any, and quietly
				// insert this control into it's parent
				if( parent )
					AdoptCommonEx( parent, NULL, pc, FALSE );
				SetCommonBorder( pc, BorderType );
				//DebugBreak(); // this is a crazy surface rect thing...
				MoveSizeCommon( pc
								  , pc->detached_at.x
								  , pc->detached_at.y
								  , pc->detached_at.width
								  , pc->detached_at.height);
				//DisplayFrame( pc );
				//EditFrame( pc, TRUE );
			}
			if( pc->EndEdit )
			{
				// this allows the sheet control to detach the sheets before edit begins.
				pc->EndEdit( pc );
			}
		}
	}
}
//---------------------------------------------------------------------------
PSI_PROC( void, EditFrame )( PSI_CONTROL pc, int bEnable )
{
	if( !pc || pc->flags.bNoEdit )
	{
		//lprintf( "!\n!\n!\n!\n!\n! XML SAVED FILE HAS EDIT=0 !\n!\n!\n!\n!\n!\n!\n!\n!" );
		return;
	}
	if( bEnable && pc->flags.detached )
	{
		xlprintf(LOG_NOISE+100)( "Already in edit mode, don't be stupid." );
		return;
	}
	if( !bEnable )
	{
		if( pc->flags.detached )
		{
 // && pc->device && pc->device->EditState.flags.bActive )
			while( pc && pc->parent)
				pc = pc->parent;
		}
	}
	if( bEnable )
	{
		// this is initialization code, and should be moved external....
		//
		if( bEnable && !pFrameEditMenu )
	{
			PMENU pControls;
			PMENU pCurrentControls;
			CTEXTSTR name;
			int nControls = 0;
			PCLASSROOT data = NULL;
			pFrameEditMenu = CreatePopup();
			pCurrentControls = pControls = CreatePopup();
			for( name = GetFirstRegisteredName( PSI_ROOT_REGISTRY "/control", &data );
				 name;
				  name = GetNextRegisteredName( &data ) )
			{
				PMENUITEM pli;
				TEXTCHAR text[256];
				int nItem;
				int n;
				for( n = 0; name[n]; n++ )
					if( name[n] < '0' || name[n] > '9' )
						break;
				if( name[n] )
				{
					tnprintf( text, sizeof( text ), PSI_ROOT_REGISTRY "/control/%s", name );
					nItem = GetRegisteredIntValue( text, "Type" );
					if( nControls == 10 )
					{
						PMENU tmp = CreatePopup();
						pli = AppendPopupItem( pCurrentControls, MF_POPUP, (uintptr_t)tmp, "More..." );
						pCurrentControls = tmp;
					}
					pli = AppendPopupItem( pCurrentControls, MF_BYCOMMAND, MNU_ADDCONTROL + nItem, (POINTER)name );
					nControls++;
					//SetItemData( pli, (uintptr_t)GetRegisteredProcedure( PSI_ROOT_REGISTRY "/control/Button/Click", int, name, (uintptr_t, PSI_CONTROL) ) );
				}
			}
			AppendPopupItem( pFrameEditMenu, MF_POPUP, (uintptr_t)pControls, "Add Control" );
			AppendPopupItem( pFrameEditMenu, MF_STRING, MNU_EDITTHING, "Properties" );
			AppendPopupItem( pFrameEditMenu, MF_STRING, MNU_SAVEFRAME, "Save" );
			AppendPopupItem( pFrameEditMenu, MF_STRING, MNU_DONE, "Done" );
			AppendPopupItem( pFrameEditMenu, MF_STRING, MNU_DELETETHING, "Cancel" );
		}
		if( bEnable && !pControlEditMenu )
		{
			pControlEditMenu = CreatePopup();
			AppendPopupItem( pControlEditMenu, MF_STRING, MNU_EDITTHING, "Properties" );
			AppendPopupItem( pControlEditMenu, MF_STRING, MNU_DELETETHING, "Delete" );
			AppendPopupItem( pControlEditMenu, MF_STRING, MNU_DONE, "Done" );
		}
	}
	{
		PPHYSICAL_DEVICE pf = pc->device;
		if( pf )
		{
			if( !bEnable )
			{
				if( pf->EditState.pCurrent )
				{
					lprintf( "Restoring keyproc to control." );
					pf->EditState.pCurrent->n_KeyProc = pf->EditState.n_KeyProc;
					pf->EditState.pCurrent->_KeyProc = pf->EditState._KeyProc;
				}
			}
		}
		else
		{
			pc->flags.bEditSet = TRUE;
			pc->flags.bNoEdit = !bEnable;
		}
	}
#if 0
	// this is code that is not init...
	if( bEnable )
	{
		// LOL this will be fun... watch the world fall to pieced
		DetachChildFrames( pc );
	}
	else
		RetachChildFrames( pc );
#endif
	if( bEnable && !pc->device )
	{
		if( !pc->flags.auto_opened )
		{
 // precondition this state...
			pc->flags.auto_opened = 1;
 // DIsplay frame will clear auto_opened....
			DisplayFrame( pc );
			pc->flags.auto_opened = 1;
		}
	}
	if( !bEnable && pc->device )
	{
		if( pc->flags.auto_opened )
		{
			DetachFrameFromRenderer( pc );
			pc->flags.auto_opened = 0;
		}
	}
	{
		PPHYSICAL_DEVICE pf = pc->device;
		if( pf )
		{
			//lprintf( "Border type for control is %08" _32fx, pc->BorderType );
			pf->EditState.BorderType = pc->BorderType;
			pf->EditState.flags.bActive = bEnable;
			if( bEnable )
			{
				SetCommonBorder( pc, BORDER_FRAME|BORDER_NORMAL|BORDER_RESIZABLE );
			}
			else
			{
				if( pc->pCommonButtonData.flags.bWaitOnEdit )
				{
					// clear wait.
					pc->pCommonButtonData.flags.bWaitOnEdit = 0;
					WakeThread( pc->pCommonButtonData.thread );
				}
			}
		}
		SmudgeCommon( pc );
	}
}
PSI_PROP_NAMESPACE_END
//---------------------------------------------------------------------------
//
// $Log: ctlprop.c,v $
// Revision 1.24  2005/03/12 23:31:21  panther
// Edit controls nearly works... have some issues with those dang popups.
//
// Revision 1.23  2005/03/07 00:03:04  panther
// Reformatting, removed a lot of superfluous logging statements.
//
// Revision 1.22  2005/02/09 21:23:44  panther
// Update macros and function definitions to follow the common MakeControl parameter ordering.
//
// Revision 1.21  2005/01/08 00:00:15  panther
// Break up submenus for adding controls, fix simple message box
//
// Revision 1.20  2004/12/20 19:45:15  panther
// Fixes for protected sheet control init
//
// Revision 1.19  2004/12/05 10:48:21  panther
// Fix palette result color.  Fix check button for set alpha.  To make a radio/check button, 4 parameters, not two are needed.  Edit controls respond to mouse better.  Copy and paste function returned, no right click on edit fields :(
//
// Revision 1.18  2004/12/05 00:22:44  panther
// Fix focus flag reference and edit controls begin to work.  Sheet controls are still flaky
//
// Revision 1.17  2004/10/24 20:09:47  d3x0r
// Sync to psilib2... stable enough to call it mainstream.
//
// Revision 1.6  2004/10/12 08:10:51  d3x0r
// checkpoint... frames are controls, and anything can be displayed...
//
// Revision 1.5  2004/10/07 04:37:16  d3x0r
// Okay palette and listbox seem to nearly work... controls draw, now about that mouse... looks like my prior way of cheating is harder to step away from than I thought.
//
// Revision 1.4  2004/10/06 09:52:16  d3x0r
// checkpoint... total conversion... now how does it work?
//
// Revision 1.3  2004/09/28 16:52:18  d3x0r
// compiles - might work... prolly not.
//
// Revision 1.2  2004/09/27 20:44:28  d3x0r
// Sweeping changes only a couple modules left...
//
// Revision 1.1  2004/09/19 19:22:31  d3x0r
// Begin version 2 psilib...
//
// Revision 1.15  2004/09/04 18:49:48  d3x0r
// Changes to support scaling and font selection of dialogs
//
// Revision 1.14  2004/08/25 15:01:06  d3x0r
// Checkpoint - more vc compat fixes
//
// Revision 1.13  2004/06/16 03:02:50  d3x0r
// checkpoint
//
// Revision 1.12  2004/05/23 09:50:44  d3x0r
// Updates to extend dynamic edit dialogs.
//
// Revision 1.11  2004/05/22 00:39:57  d3x0r
// Lots of progress on dynamic editing of frames.
//
// Revision 1.12  2004/05/22 00:42:20  jim
// Score - specific property pages will work also.
//
// Revision 1.11  2004/05/21 21:52:36  jim
// Create control code creates in the right place now.
//
// Revision 1.10  2004/05/21 18:12:59  jim
// Checkpoint, need to add registered functions to link to.
//
// Revision 1.9  2004/05/21 16:23:15  jim
// Fixed issues with load/save
//
// Revision 1.10  2004/05/21 15:39:38  d3x0r
// Fixed some warnings, other issues with loading controls.
//
// Revision 1.9  2004/05/21 07:48:10  d3x0r
// track popup takes a PSI_CONTROL NOT a PSI_CONTROL
//
// Revision 1.8  2004/01/31 01:30:20  d3x0r
// Mods to extend/test procreglib.
//
// Revision 1.7  2004/01/29 18:01:34  d3x0r
// Generalize get/set control text functions, reformat
//
// Revision 1.6  2004/01/29 11:17:46  d3x0r
// Generalized first registered names...
//
// Revision 1.5  2004/01/26 23:47:25  d3x0r
// Misc edits.  Fixed filemon.  Export net startup, added def to edit frame
//
// Revision 1.4  2004/01/16 17:02:35  d3x0r
// move frame/control save/load external - working on properties, editing
//
// Revision 1.3  2003/11/29 00:10:28  panther
// Minor fixes for typecast equation
//
// Revision 1.2  2003/09/18 12:14:49  panther
// MergeRectangle Added.  Seems Control edit near done (fixing move/size errors)
//
// Revision 1.1  2003/09/18 08:00:53  panther
// Fix ctlprop so it compiles...
//
//
#define BTN_LESS 100
#define BTN_MORE 101
//---------------------------------------------------------------------------
PSI_SCROLLBAR_NAMESPACE
typedef struct scrollbar_tag
{
   uint32_t attr;
 // this is the surface of the 'bar' itself
	Image   surface;
     // smallest value of bar
	int min
 // first line shown?
	  , current
     // highest value of var
	  , max
  // amount of distance the 'display' shows
	  , range;
	int x, y, b;
	int grabbed_x, grabbed_y;
	int top, bottom, width, height;
	struct {
		unsigned int bDragging : 1;
		unsigned int bHorizontal : 1;
	}scrollflags;
	PSI_CONTROL pcTopButton, pcBottomButton;
	void (CPROC*UpdatedPos)( uintptr_t psv, int type, int current);
	uintptr_t psvUpdate;
} SCROLLBAR, *PSCROLLBAR;
//---------------------------------------------------------------------------
//	if( pc->nType == SCROLLBAR_CONTROL )
//	{
//		PSCROLLBAR psb = (PSCROLLBAR)pc;
//	}
static int CPROC RenderScrollBar( PSI_CONTROL pc )
{
	ValidatedControlData( PSCROLLBAR, SCROLLBAR_CONTROL, psb, pc );
   //lprintf( "Drawing %p", pc );
	if( psb )
	{
		Image surface = psb->surface;
		int top, bottom;
		if( !surface )
			return 0;
		// render top button...
		if( psb->scrollflags.bHorizontal )
		{
			psb->width = pc->rect.width - 2*pc->rect.height;
			psb->height = pc->rect.height;
		}
		else
		{
			psb->width = pc->rect.width;
			psb->height = pc->rect.height - 2*pc->rect.width;
		}
		BlatColorAlpha( surface, 0, 0, surface->width, surface->height, basecolor(pc)[SCROLLBAR_BACK] );
		if( psb->range == 0 )
         return 1;
		top = psb->current - psb->min;
		bottom = top + psb->range;
		//Log3( "top: %d bottom: %d max: %d", top, bottom, psb->max );
	   if( psb->scrollflags.bHorizontal )
	   {
			   if( psb->max )
			   {
				top = ( psb->width * top ) / psb->max;
				bottom = ( (psb->width - 1) * bottom ) / psb->max;
			}
			else
			{
				top = 0;
				bottom = psb->width - 1;
			}
			BlatColorAlpha( surface, top, 0
								, bottom-top
								, psb->height, basecolor(pc)[NORMAL] );
	   }
	   else
	   {
			   if( psb->max )
			   {
				top = ( psb->height * top ) / psb->max;
				bottom = ( (psb->height - 1) * bottom ) / psb->max;
			}
			else
			{
				top = 0;
				bottom = psb->height - 1;
			}
			BlatColorAlpha( surface, 0, top
								, psb->width
								, bottom-top, basecolor(pc)[NORMAL] );
		}
		//Log2( "top: %d bottom: %d", top, bottom );
		psb->top = top;
		psb->bottom = bottom;
		DrawThinFrameInverted( pc );
		if( psb->scrollflags.bHorizontal )
		{
			do_vlineAlpha( surface, top, 1, psb->height-2, basecolor(pc)[HIGHLIGHT] );
			do_hlineAlpha( surface, 1, top, bottom, basecolor(pc)[HIGHLIGHT] );
			do_hlineAlpha( surface, psb->height-2, top, bottom, basecolor(pc)[SHADOW] );
			do_vlineAlpha( surface, bottom, 1, psb->height-2, basecolor(pc)[SHADOW] );
		}
		else
		{
			do_hlineAlpha( surface, top, 1, psb->width-2, basecolor(pc)[HIGHLIGHT] );
			do_vlineAlpha( surface, 1, top, bottom, basecolor(pc)[HIGHLIGHT] );
			do_vlineAlpha( surface, psb->width-2, top, bottom, basecolor(pc)[SHADOW] );
			do_hlineAlpha( surface, bottom, 1, psb->width-2, basecolor(pc)[SHADOW] );
		}
	}
	return 1;
}
//---------------------------------------------------------------------------
void MoveScrollBar( PSI_CONTROL pc, int type )
{
	ValidatedControlData( PSCROLLBAR, SCROLLBAR_CONTROL, psb, pc );
   //lprintf( "move scrollbar... %p", pc );
	if( psb )
	{
		switch( type )
		{
		case UPD_1UP:
			if( psb->current )
				psb->current--;
			break;
		case UPD_1DOWN:
			if( ( psb->current + psb->range ) < psb->max )
				psb->current++;
			break;
		case UPD_RANGEUP:
			if( psb->current > psb->range )
				psb->current -= psb->range;
			else
				psb->current = 0;
			break;
		case UPD_RANGEDOWN:
			psb->current += psb->range;
			if( ( psb->current + psb->range ) > psb->max )
            psb->current = psb->max - psb->range;
			break;
			//case UPD_THUMBTO:
		}
		if( psb->UpdatedPos )
			psb->UpdatedPos( psb->psvUpdate, type, psb->current );
		SmudgeCommon(pc);
	}
}
//---------------------------------------------------------------------------
static int CPROC ScrollBarMouse( PSI_CONTROL pc, int32_t x, int32_t y, uint32_t b )
{
	ValidatedControlData( PSCROLLBAR, SCROLLBAR_CONTROL, psb, pc );
	if( psb )
	{
		if( b & MK_SCROLL_DOWN )
		{
			MoveScrollBar( pc, UPD_1DOWN );
		}
		if( b & MK_SCROLL_UP )
		{
			MoveScrollBar( pc, UPD_1UP );
		}
		if( psb->scrollflags.bDragging )
		{
			if( !(b & MK_LBUTTON ) )
				psb->scrollflags.bDragging = FALSE;
			else
			{
				int desired_top;
				if( psb->scrollflags.bHorizontal )
				{
					// this is effectively -1 * the delta - so the scroll
					// goes 'increasing' to the right
					x -= psb->height;
					desired_top = ( x - psb->grabbed_x );
					desired_top = ( desired_top * psb->max ) / psb->width;
					if( desired_top > ( psb->max - psb->range ) )
						desired_top = psb->max - psb->range;
					else if( desired_top < psb->min )
						desired_top = psb->min;
					if( psb->current != desired_top )
					{
						psb->current = desired_top;
						MoveScrollBar( pc, UPD_THUMBTO );
					}
				}
				else
				{
					y -= psb->width;
					desired_top = ( y - psb->grabbed_y );
					desired_top = ( desired_top * psb->max ) / psb->height;
					if( desired_top > ( psb->max - psb->range ) )
						desired_top = psb->max - psb->range;
					else if( desired_top < psb->min )
						desired_top = psb->min;
					if( psb->current != desired_top )
					{
						psb->current = desired_top;
						MoveScrollBar( pc, UPD_THUMBTO );
					}
			   }
				// do something here...
			}
		}
		else if( ( b & MK_LBUTTON ) && !(psb->b & MK_LBUTTON ) )
		{
			if( psb->scrollflags.bHorizontal )
			{
 // width of arrow
				x -= psb->height;
				if( x < psb->top )
				{
					MoveScrollBar( pc, UPD_RANGEUP );
				} else if( x > psb->bottom )
				{
					MoveScrollBar( pc, UPD_RANGEDOWN );
				}
 // was on the thumb...
				else
				{
 // top/left *shrug*
					psb->grabbed_x = x - psb->top;
					psb->grabbed_y = y - psb->top;
					psb->scrollflags.bDragging = TRUE;
				}
			}
			else
			{
				y -= psb->width;
				if( y < psb->top )
				{
					MoveScrollBar( pc, UPD_RANGEUP );
				} else if( y > psb->bottom )
				{
					MoveScrollBar( pc, UPD_RANGEDOWN );
				}
 // was on the thumb...
				else
				{
 // top/left *shrug*
					psb->grabbed_x = x - psb->top;
					   psb->grabbed_y = y - psb->top;
					psb->scrollflags.bDragging = TRUE;
				}
			}
		}
		psb->x = x;
		psb->y = y;
		psb->b = b;
	}
	return 1;
}
//---------------------------------------------------------------------------
static void CPROC BottomPushed( uintptr_t psvBar, PSI_CONTROL pc )
{
   MoveScrollBar( (PSI_CONTROL)psvBar, UPD_1DOWN );
}
//---------------------------------------------------------------------------
static void CPROC DrawBottomButton( uintptr_t psv, PSI_CONTROL pc )
{
	Image surface = pc->Surface;
	if( surface )
	{
		int mx = pc->surface_rect.width/2;
		int cx = pc->surface_rect.width/4
		  , cy = pc->surface_rect.height/3;
		BlatColorAlpha( surface, 0, 0, surface->width, surface->height, basecolor(pc)[NORMAL] );
		if( IsButtonPressed( pc ) )
		{
			cx++;
			cy++;
		}
#define fline(s,x1,y1,x2,y2,c,a) do_lineAlpha(s,x1,y1,x2,y2,SetAlpha(c,a))
		fline( surface, mx, 2*cy+1, cx, cy+1, basecolor(pc)[SHADOW], 255 );
		fline( surface, mx, 2*cy+0, cx, cy+0, basecolor(pc)[SHADE], 128 );
		fline( surface, mx, 2*cy+2, cx, cy+2, basecolor(pc)[SHADE], 128 );
		fline( surface, mx, 2*cy+2, mx+(mx-cx)  , cy+2, basecolor(pc)[HIGHLIGHT], 255 );
		fline( surface, mx, 2*cy+0, mx+(mx-cx)  , cy+0, basecolor(pc)[SHADOW], 128 );
		fline( surface, mx, 2*cy+1, mx+(mx-cx)  , cy+1, basecolor(pc)[SHADE], 128 );
	}
}
//---------------------------------------------------------------------------
static void CPROC DrawRightButton( uintptr_t psv, PSI_CONTROL pc )
{
	Image surface = pc->Surface;
	if( surface )
	{
		int cx = pc->surface_rect.width/2
		  , cy = pc->surface_rect.height/2;
		BlatColorAlpha( surface, 0, 0, surface->width, surface->height, basecolor(pc)[NORMAL] );
		if( IsButtonPressed( pc ) )
			cx++;
		do_line( surface, cy - 2, cx - 3, cy + 1, cx  , basecolor(pc)[SHADE] );
		do_line( surface, cy - 2, cx - 4, cy + 2, cx  , basecolor(pc)[SHADOW] );
		do_line( surface, cy - 1, cx - 4, cy + 3, cx  , basecolor(pc)[SHADE] );
		do_line( surface, cy + 3, cx    , cy - 1, cx+4, basecolor(pc)[HIGHLIGHT] );
		do_line( surface, cy + 2, cx    , cy - 2, cx+4, basecolor(pc)[SHADE] );
		do_line( surface, cy + 1, cx    , cy - 2, cx+3, basecolor(pc)[SHADOW] );
	}
}
//---------------------------------------------------------------------------
static void CPROC TopPushed( uintptr_t psvBar, PSI_CONTROL pc )
{
	MoveScrollBar( (PSI_CONTROL)psvBar, UPD_1UP );
}
//---------------------------------------------------------------------------
static void CPROC DrawTopButton( uintptr_t psv, PSI_CONTROL pc )
{
	Image surface = pc->Surface;
	if( surface )
	{
		CDATA c;
		int mx = pc->surface_rect.width/2;
		int cx = pc->surface_rect.width/4
		  , cy = pc->surface_rect.height/3;
		BlatColorAlpha( surface, 0, 0, surface->width, surface->height, basecolor(pc)[NORMAL] );
		if( IsButtonPressed( pc ) )
			cx++;
		c = basecolor(pc)[SHADE];
		//c = SetAlpha( c, 128 );
		fline( surface, mx, cy+1, mx+(mx-cx), 2*cy+1, basecolor(pc)[SHADOW], 255 );
		fline( surface, mx, cy, mx+(mx-cx), 2*cy, basecolor(pc)[SHADE], 128 );
		fline( surface, mx, cy+2, mx+(mx-cx), 2*cy+2, basecolor(pc)[SHADE], 128 );
		fline( surface, mx, cy+2, cx, 2*cy+2, basecolor(pc)[HIGHLIGHT], 255 );
		fline( surface, mx, cy+0, cx, 2*cy+0, basecolor(pc)[SHADOW], 128 );
		fline( surface, mx, cy+1, cx, 2*cy+1, basecolor(pc)[SHADE], 128 );
	}
}
//---------------------------------------------------------------------------
static void CPROC DrawLeftButton( uintptr_t psv, PSI_CONTROL pc )
{
	Image surface = pc->Surface;
	if( surface )
	{
		int cx = pc->surface_rect.width/2
			, cy = pc->surface_rect.height/2;
      // hmm hope clearimage uses a blatalpha..
      BlatColorAlpha( surface, 0, 0, surface->width, surface->height, basecolor(pc)[NORMAL] );
		if( IsButtonPressed( pc ) )
			cx++;
		do_lineAlpha( surface, cy - 3, cx  , cy+1, cx+4, basecolor(pc)[SHADE] );
		do_lineAlpha( surface, cy - 2, cx  , cy+2, cx+4, basecolor(pc)[SHADOW] );
		do_lineAlpha( surface, cy - 1, cx  , cy+2, cx+3, basecolor(pc)[SHADE] );
		do_lineAlpha( surface, cy + 2, cx-3, cy-1, cx  , basecolor(pc)[HIGHLIGHT] );
		do_lineAlpha( surface, cy + 2, cx-4, cy-2, cx  , basecolor(pc)[SHADE] );
		do_lineAlpha( surface, cy + 1, cx-4, cy-3, cx  , basecolor(pc)[SHADOW] );
		//plot( surface, cx + 4, cy + 2, basecolor(pc)[HIGHLIGHT] );
	}
}
//---------------------------------------------------------------------------
void SetScrollParams( PSI_CONTROL pc, int min, int cur, int range, int max )
{
	int diffs = 0;
	ValidatedControlData( PSCROLLBAR, SCROLLBAR_CONTROL, psb, pc );
	if( psb )
	{
		int full_range = 0;
		if( max < min )
		{
			int tmp;
			tmp = min;
			min = max;
			max = tmp;
		}
		if( psb->range == ( psb->max - psb->min ) )
			full_range = 1;
		if( psb->min != min )
		{
			diffs++;
			psb->min = min;
		}
		if( psb->max != max )
		{
			diffs++;
			psb->max = max;
		}
		if( psb->range != range )
		{
			diffs++;
			psb->range = range;
		}
		if( diffs && full_range)
		{
			if( psb->range == ( psb->max - psb->min ) )
			{
				full_range = 1;
				diffs = 0;
			}
		}
		if( psb->current != cur)
		{
			if( !full_range )
				diffs++;
			psb->current = cur;
		}
		//Log( "Set scroll params - therefore render" );
		if( diffs )
			SmudgeCommon(pc);
	}
}
//---------------------------------------------------------------------------
PSI_CONTROL SetScrollBarAttributes( PSI_CONTROL pc, int attr )
{
	ValidatedControlData( PSCROLLBAR, SCROLLBAR_CONTROL, psb, pc );
	//lprintf( "Set scroll attributes..." );
	if( psb )
	{
		psb->attr = attr;
		if( attr & SCROLL_HORIZONTAL )
		{
			psb->scrollflags.bHorizontal = 1;
			MoveImage( psb->surface, pc->rect.height, 0 );
			ResizeImage( psb->surface
						  , psb->width = pc->rect.width - 2*pc->rect.height
						  , psb->height = pc->rect.height );
			MoveSizeCommon( psb->pcTopButton
							  , 0, 0
							  , pc->rect.height, pc->rect.height
							  );
			MoveSizeCommon( psb->pcBottomButton
							  , pc->rect.width - pc->rect.height, 0
							  , pc->rect.height, pc->rect.height
                       );
			SetButtonDrawMethod( psb->pcTopButton, DrawLeftButton, (uintptr_t)psb );
			SetButtonDrawMethod( psb->pcBottomButton, DrawRightButton, (uintptr_t)psb );
		}
		else
		{
			psb->scrollflags.bHorizontal = 0;
			MoveImage( psb->surface, 0, pc->rect.width );
			ResizeImage( psb->surface
						  , psb->width = pc->rect.width
						  , psb->height = pc->rect.height - 2*pc->rect.width );
			MoveSizeCommon( psb->pcTopButton
							  , 0, 0
							  , pc->rect.width, pc->rect.width
							  );
			MoveSizeCommon( psb->pcBottomButton
							  , 0, pc->rect.height-pc->rect.width
							  , pc->rect.width, pc->rect.width
                       );
			SetButtonDrawMethod( psb->pcBottomButton, DrawBottomButton, (uintptr_t)psb );
			SetButtonDrawMethod( psb->pcTopButton, DrawTopButton, (uintptr_t)psb );
		}
	}
   return pc;
}
//CONTROL_PROC_DEF( SCROLLBAR_CONTROL, SCROLLBAR, ScrollBar, ()  )
static int OnCreateCommon( SCROLLBAR_CONTROL_NAME )( PSI_CONTROL pc )
{
   //ARG( uint32_t, attr );
	ValidatedControlData( PSCROLLBAR, SCROLLBAR_CONTROL, psb, pc );
	if( psb )
	{
      //lprintf( "Creating %p", pc );
		psb->min = 0;
		psb->max = 1;
		psb->current = 0;
		psb->range = 1;
		{
			psb->surface = MakeSubImage( pc->Surface
												, 0, pc->rect.width
												, psb->width = pc->rect.width
												, psb->height = pc->rect.height - 2*pc->rect.width );
			psb->pcTopButton = MakePrivateControl( pc, CUSTOM_BUTTON
															 , 0, 0
															 , pc->rect.width, pc->rect.width
															 , BTN_LESS );
         SetButtonPushMethod( psb->pcTopButton, TopPushed, (uintptr_t)pc );
			psb->pcTopButton->flags.bNoFocus = TRUE;
			psb->pcBottomButton = MakePrivateControl( pc, CUSTOM_BUTTON
																 , 0, pc->rect.height-pc->rect.width
																 , pc->rect.width, pc->rect.width
																 , BTN_MORE );
         SetButtonPushMethod( psb->pcBottomButton, BottomPushed, (uintptr_t)pc );
			psb->pcBottomButton->flags.bNoFocus = TRUE;
         if( psb->width > psb->height )
				SetScrollBarAttributes( pc, SCROLL_HORIZONTAL );
         else
				SetScrollBarAttributes( pc, 0 );
		}
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------------
// flags may indicate - horizontal not vertical...
void SetScrollUpdateMethod( PSI_CONTROL pc
					, void (CPROC*UpdateProc)(uintptr_t psv, int type, int current)
					, uintptr_t data )
{
   ValidatedControlData( PSCROLLBAR, SCROLLBAR_CONTROL, psb, pc );
	if( psb )
	{
		psb->UpdatedPos = UpdateProc;
		psb->psvUpdate = data;
	}
}
static void OnSizeCommon( SCROLLBAR_CONTROL_NAME )( PSI_CONTROL pc, LOGICAL begin_sizing )
//static void CPROC ResizeScrollbar( PSI_CONTROL pc )
{
	ValidatedControlData( PSCROLLBAR, SCROLLBAR_CONTROL, psb, pc );
	//lprintf( "Resizing %p", pc );
	if( psb )
	{
		int32_t width = 15;
		//lprintf( "Resize called." );
		ScaleCoords( (PSI_CONTROL)pc, &width, NULL );
		// resize the scrollbar accordingly...
		//lprintf( "Getting a resize on the scrollbar..." );
		if( psb->attr & SCROLL_HORIZONTAL )
		{
			MoveImage( psb->surface, pc->rect.height, 0 );
			ResizeImage( psb->surface
						  , psb->width = pc->rect.width - 2*pc->rect.height
						  , psb->height = pc->rect.height );
			MoveSizeCommon( psb->pcTopButton, 0, 0
							  , pc->rect.height, pc->rect.height );
			MoveSizeCommon( psb->pcBottomButton, pc->rect.width - pc->rect.height, 0
							  , pc->rect.height, pc->rect.height );
		}
		else if( psb->surface )
		{
			MoveImage( psb->surface, 0, pc->rect.width );
			ResizeImage( psb->surface
						  , psb->width = pc->rect.width
						  , psb->height = pc->rect.height - 2*pc->rect.width );
			MoveSizeCommon( psb->pcTopButton, 0, 0
							  , pc->rect.width, pc->rect.width );
			MoveSizeCommon( psb->pcBottomButton, 0, pc->rect.height-pc->rect.width
							  , pc->rect.width, pc->rect.width );
		}
	 }
}
CONTROL_REGISTRATION
scroll_bar = { SCROLLBAR_CONTROL_NAME
				 , { { 18, 18 }, sizeof( SCROLLBAR ), BORDER_NONE }
 //ConfigureScrollBar
				 , NULL
				 , NULL
				 , RenderScrollBar
				 , ScrollBarMouse
};
PRIORITY_PRELOAD( RegisterScrollBar,PSI_PRELOAD_PRIORITY )
{
   DoRegisterControl( &scroll_bar );
	//SimpleRegisterMethod( PSI_ROOT_REGISTRY "/control/" SCROLLBAR_CONTROL_NAME "/rtti"
	//						  , ResizeScrollbar
	//						  , "void", "resize", "(PSI_CONTROL)" );
}
PSI_SCROLLBAR_NAMESPACE_END
//---------------------------------------------------------------------------
PSI_SHEETS_NAMESPACE
//#define DEBUG_SHEET
typedef struct sheet_tag SHEET, *PSHEET;
struct sheet_tag {
	struct {
		uint32_t bDisabled : 1;
		uint32_t bCustomColors : 1;
	} flags;
  // each content has an ID... so select by ID;
	PSI_CONTROL content;
	Image active_slices[3], inactive_slices[3];
	Image active, inactive;
	CDATA cActiveText, cInactiveText;
	uint32_t tab_width;
	uint32_t tab_pad;
	struct sheet_tag *next;struct sheet_tag **me;
	//DeclareLink( struct sheet_tag );
};
typedef struct multi_sheet_tag {
	struct {
		uint32_t bNoTabs : 1;
		uint32_t bCustomColors : 1;
	} flags;
	PSI_CONTROL mount_point;
	PSHEET sheets;
	PSHEET current;
	PSHEET prior_sheet;
	PSHEET first;
	Image active_slices[3], inactive_slices[3];
	Image active, inactive;
	CDATA cActiveText, cInactiveText;
 // the last may be the whole increment... so offset the first.
	uint32_t first_offset;
	uint32_t _b;
	uint32_t height;
 // this needs to be like some portion of the image..
	uint32_t tab_pad;
} SHEETCONTROL, *PSHEETCONTROL;
static void ComputeHeight( PSI_CONTROL pc )
{
	ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, pc );
	uint32_t TAB_HEIGHT, tmp1 = 0, tmp2 = 0;
	SFTFont font = GetFrameFont( pc );
	GetStringSizeFont( " ", NULL, &TAB_HEIGHT, font );
	TAB_HEIGHT += 4;
	if( psc->active )
		tmp1 = psc->active->height;
	if( psc->inactive )
		tmp2 = psc->inactive->height;
	if( tmp1 > TAB_HEIGHT )
	{
		if( tmp1 > tmp2 )
		{
			lprintf( "Settin tab height to %" _32f, tmp1 );
			TAB_HEIGHT = tmp1;
		}
		else
		{
			lprintf( "Settin tab height tox %" _32f, tmp2 );
			TAB_HEIGHT = tmp2;
		}
	}
	else if( tmp2 > TAB_HEIGHT )
	{
		lprintf( "Settin tab height to %" _32fs, tmp2 );
		TAB_HEIGHT = tmp2;
	}
	{
		// need to go through all the sheets
		// and check their tab image sizes also...
	}
	if( psc->active )
		if( USS_LT( TAB_HEIGHT, uint32_t, psc->active->height, int ) )
			TAB_HEIGHT = psc->active->height;
	if( psc->height != TAB_HEIGHT )
	{
		psc->height = TAB_HEIGHT;
#ifdef DEBUG_SHEET
		lprintf( "Moving the frame? to %d,%d", 0, psc->height );
#endif
		MoveSizeFrame( psc->mount_point, 0, psc->height
						 , pc->surface_rect.width
						 , pc->surface_rect.height - psc->height );
	}
}
static void BlotTab( Image surface, Image slices[3], int x, int width, int height )
{
	uint32_t w1, w2;
	w1 = slices[0]->width;
	w2 = slices[2]->width;
	if( SUS_LT( width, int, (w1+w2), uint32_t ) )
	{
		BlotScaledImageSizedToAlpha( surface, slices[0]
											, x, 0
											, width / 2, height
											, ALPHA_TRANSPARENT );
		// computation of width - (width/2) accounts for the rounding
		// error if width is odd...
		BlotScaledImageSizedToAlpha( surface, slices[2]
											, x + (width/2), 0
											, width - (width / 2), height
											, ALPHA_TRANSPARENT );
	}
	else
	{
		BlotScaledImageSizedToAlpha( surface, slices[0]
											, x, 0
											, w1, height
											, ALPHA_TRANSPARENT );
		//BlotImageAlpha( surface, slices[0], x, 0, ALPHA_TRANSPARENT );
		BlotScaledImageSizedToAlpha( surface, slices[2]
											, x + (width - w2), 0
											, w2, height
											, ALPHA_TRANSPARENT );
		//BlotImageAlpha( surface, slices[2]
		//				  , x + (width - w2), 0
		//				  , ALPHA_TRANSPARENT );
	// just scale center portion to width of tab
 // if equal or less, no reason to do this...
		if( USS_LT( ( w1+w2 ),uint32_t, width,int) )
			BlotScaledImageSizedToAlpha( surface, slices[1]
												, x + w1
												, 0
												, width - (w1+w2)
												, height
												, ALPHA_TRANSPARENT );
	}
}
static int CPROC DrawSheetControl( PSI_CONTROL pc )
{
	ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, pc );
	Image surface;
	PSHEET sheet;
	SFTFont font;
	if( !psc )
	{
		lprintf( "Control to draw is not a sheet control.");
		return 0;
	}
	//lprintf( "control surface is %p but we don't know the bit pointer"
	//		 , pc->Surface );
	surface = pc->Surface;
	// need to compute how big the tab is for the caption on the dialog... and
	// whether we need additionally some buttons present...
	//lprintf( "So yeah we clear the sufrace..." );
	//ClearImageTo( surface, basecolor(pc)[NORMAL] );
	//lprintf( "Get a font" );
	font = GetFrameFont( pc );
	{
		int x = -((int)psc->first_offset);
		sheet = psc->sheets;
		psc->first = sheet;
		ComputeHeight( pc );
		while( sheet )
		{
			uint32_t tab_width;
			uint32_t TAB_HEIGHT;
			GetStringSizeFont( GetText( sheet->content->caption.text)
								  , &sheet->tab_width, &TAB_HEIGHT, font );
			//lprintf( "x : %d next: %d", x, sheet->tab_width );
			if( sheet == psc->current )
			{
				//lprintf( "Surface height and my hight %d %d", surface->height, psc->height );
				if( sheet->active )
				{
					//sheet->tab_width += sheet->tab_pad; // 4 left, 4 right... good pad even for smallness
					BlotTab( surface, sheet->active_slices, x
							 , tab_width = sheet->tab_width + sheet->tab_pad, psc->height );
				}
				else if( psc->active )
				{
					//sheet->tab_width += psc->tab_pad; // 4 left, 4 right... good pad even for smallness
					BlotTab( surface, psc->active_slices, x
							 , tab_width = sheet->tab_width + psc->tab_pad, psc->height );
				}
				else
				{
					tab_width = sheet->tab_width + psc->tab_pad;
					BlatColor( surface, x, 0, tab_width, psc->height, basecolor(pc)[NORMAL] );
					do_vline( surface, x, 0, psc->height, basecolor(pc)[SHADE] );
					do_vline( surface, x+1, 0, psc->height, basecolor(pc)[HIGHLIGHT] );
					do_vline( surface, x + tab_width-1, 0, psc->height, basecolor(pc)[SHADE] );
					do_vline( surface, x + tab_width, 0, psc->height, basecolor(pc)[SHADOW] );
					do_hline( surface, 0, x+1, x + tab_width, basecolor(pc)[HIGHLIGHT] );
				}
				if( sheet->content->caption.text )
				{
					CDATA color;
					if( sheet->flags.bCustomColors )
						color = sheet->cActiveText;
					else if( psc->flags.bCustomColors )
						color = psc->cActiveText;
					else
						color = basecolor(pc)[TEXTCOLOR];
					//lprintf( "Putting string out at %d,%d %s", x + 4, 3, GetText( sheet->content->caption.text ) );
					PutStringFont( surface, x + ( tab_width - sheet->tab_width) / 2, (psc->height - TAB_HEIGHT)/2, color, 0
									 , GetText( sheet->content->caption.text), font );
				}
				//else
				//	lprintf( "no content caption text" );
			}
			else
			{
				if( sheet->inactive )
				{
					BlotTab( surface, sheet->inactive_slices, x
							 , tab_width = sheet->tab_width + sheet->tab_pad, psc->height );
				}
				else if( psc->inactive )
				{
					BlotTab( surface, psc->inactive_slices, x
							 , tab_width = sheet->tab_width + psc->tab_pad, psc->height );
				}
				else
				{
					tab_width = sheet->tab_width + psc->tab_pad;
				//lprintf( "Surface height and my hight %d %d", surface->height, psc->height );
					BlatColor( surface, x, 0, tab_width, psc->height, basecolor(pc)[NORMAL] );
					do_vline( surface, x, 0, psc->height, basecolor(pc)[SHADE] );
					do_vline( surface, x+1, 0, psc->height, basecolor(pc)[SHADOW] );
					do_vline( surface, x + tab_width-1, 0, psc->height, basecolor(pc)[SHADE] );
					do_vline( surface, x + tab_width, 0, psc->height, basecolor(pc)[HIGHLIGHT] );
					do_hline( surface, 0, x+1, x + tab_width, basecolor(pc)[SHADE] );
				}
				if( sheet->content->caption.text )
				{
					CDATA color;
					if( sheet->flags.bCustomColors )
						color = sheet->cInactiveText;
					else if( psc->flags.bCustomColors )
						color = psc->cInactiveText;
					else
						color = basecolor(pc)[SHADE];
					//lprintf( "Putting string out at %d,%d %s", x + 4, 3, GetText( sheet->content->caption.text ) );
					PutStringFont( surface, x + (tab_width-sheet->tab_width)/2, (psc->height - TAB_HEIGHT)/2, color, 0
									 , GetText( sheet->content->caption.text), font );
				}
				//else
				//	lprintf( "no content caption text" );
			}
			sheet->tab_width = tab_width;
// sheet->tab_width;
			x += sheet->tab_width;
			sheet = sheet->next;
		}
	}
	return 1;
}
static PSHEET GetSheetID( PSHEETCONTROL psc, uint32_t ID )
{
	PSHEET sheet = psc->sheets;
	while( sheet )
	{
		if( !sheet->content )
		{
			Log( "Sheet exists without content!?!?!?" );
			continue;
		}
		if( sheet->content->nID == ID )
		{
			return sheet;
		}
		sheet = sheet->next;
	}
	return NULL;
}
static void SetCurrentPage( PSI_CONTROL pControl, PSHEET sheet )
{
	ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, pControl );
	//lprintf( "Set a current page?" );
	if( sheet != psc->current )
	{
		// revert to prior sheet... if there was one?
		// what about the times I want to set NO page
		// guess I ahve to clear psc->prior_sheet
		if( !sheet &&
			 psc->prior_sheet &&
			!psc->prior_sheet->flags.bDisabled )
			sheet = psc->prior_sheet;
		if( psc->current &&
			!psc->current->flags.bDisabled )
			psc->prior_sheet = psc->current;
		if( psc->current )
		{
#ifdef DEBUG_SHEET
			lprintf( "Orphan control %p", psc->current->content );
#endif
			OrphanCommonEx( (PSI_CONTROL)psc->current->content, FALSE );
			if( !sheet )
				SmudgeCommon( pControl );
		}
		psc->current = sheet;
		if( sheet )
		{
#ifdef DEBUG_SHEET
			lprintf( "Adopt control into %p (%p) %p"
					 , psc->mount_point
					 , psc->mount_point->child
					 , sheet->content );
#endif
			AdoptCommonEx( (PSI_CONTROL)psc->mount_point, NULL, (PSI_CONTROL)sheet->content, FALSE );
			SmudgeCommon( pControl );
		}
	}
	else
	{
		// current is already current - that's good.
	}
}
static int CPROC MouseSheetControl( PSI_CONTROL pc, int32_t x, int32_t y, uint32_t b )
{
	ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, pc );
	PSHEET sheet;
	int check_x;
	if( b == MK_NO_BUTTON )
	{
		psc->_b = 0;
		return 0;
	}
	check_x = psc->first_offset;
	sheet = psc->first;
	//lprintf( "mouse: %d,%d ", x, y );
	if( y >= 0 && SUS_LTE( y, int32_t, psc->height, uint32_t ) )
	{
		while( sheet )
		{
			//lprintf( "Checking %d vs %d, %d", x, check_x, check_x + sheet->tab_width );
			if( !sheet->flags.bDisabled )
			{
				//lprintf( "Okay it's not disabled..." );
				if( x > check_x && SUS_LT( x, int32_t, ( check_x + sheet->tab_width ), uint32_t ) )
				{
					if( MAKE_NEWBUTTON( b, psc->_b ) & MK_LBUTTON )
					{
						SetCurrentPage( pc, sheet );
						break;
					}
				}
			}
			//else
			//	lprintf( "Disabled!" );
			check_x += sheet->tab_width;
			sheet = sheet->next;
		}
	}
	return 1;
}
static void CPROC DestroySheetControl( PSI_CONTROL pc )
{
	//ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, pc );
}
static void OnEditFrame( SHEET_CONTROL_NAME )(PSI_CONTROL pc )
{
	ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, pc );
	// my frame is having it's edit mode enabled.
	psc->prior_sheet = NULL;
	SetCurrentPage( pc, NULL );
	{
		PSHEET sheet;
		for( sheet = psc->sheets; sheet; sheet = sheet->next )
		{
			EditFrame( sheet->content, TRUE );
		}
	}
}
static void OnEditFrameDone( SHEET_CONTROL_NAME )( PSI_CONTROL pc )
{
	ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, pc );
	{
		PSHEET sheet;
		for( sheet = psc->sheets; sheet; sheet = sheet->next )
		{
			EditFrame( sheet->content, FALSE );
		}
	}
	SetCurrentPage( pc, psc->prior_sheet );
}
static void CPROC AddingSheet( PSI_CONTROL sheet, PSI_CONTROL page )
{
	ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, sheet );
	// if we haven't gotten a mount point yet, no use in
	// doing anything here.
	if( !psc->mount_point || sheet == psc->mount_point )
	{
		// this is within the tabs, and serves as
		// a container for child drawing...
		// don't remount our mount point...
		return;
	}
	SetCommonBorder( page, BORDER_NONE|BORDER_NOCAPTION );
#ifdef DEBUG_SHEET
	lprintf( "Inserting a control into the sheet control... promoting to a sheet.");
#endif
	OrphanCommonEx( page, FALSE );
	AddSheet( sheet, page );
	//(PSI_CONTROL)sheet->common.parent = NULL;
}
static int CPROC InitSheetControl( PSI_CONTROL pc )
{
	ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, pc );
	if( psc )
	{
		psc->mount_point = MakePrivateControl( pc, CONTROL_FRAME
 // starts with no height, as tabs are added, and measured, this is resized.
														 , 0, 0
														 , pc->rect.width
														 , pc->rect.height - psc->height
														 , 0 );
 // default font pad
		psc->tab_pad = 8;
		SetCommonBorder( psc->mount_point, BORDER_WITHIN|BORDER_THINNER|BORDER_INVERT );
		//pc->AddedControl = AddingSheet;
		ComputeHeight( pc );
		return TRUE;
	}
	return FALSE;
}
CONTROL_REGISTRATION
sheet_control = { SHEET_CONTROL_NAME
					 , { {240, 180}, sizeof( SHEETCONTROL ), BORDER_NONE }
// init
					 , InitSheetControl
 //load
					 , NULL
					 , DrawSheetControl
					 , MouseSheetControl
					 , NULL
					 , DestroySheetControl
// getpage
					 , NULL
// apply
					 , NULL
 // save
					 , NULL
					 , AddingSheet
};
PRIORITY_PRELOAD( register_sheet_control, PSI_PRELOAD_PRIORITY ) {
	DoRegisterControl( &sheet_control );
}
PSI_PROC( void, AddSheet )( PSI_CONTROL pControl, PSI_CONTROL contents )
{
	ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, pControl );
	PSHEET sheet;
	if( !psc )
	{
		Log( "Not adding to a sheet..." );
		return;
	}
	if( !contents )
	{
		Log( "Can't add no content" );
		return;
	}
	sheet = (PSHEET)Allocate( sizeof( SHEET ) );
	MemSet( sheet, 0, sizeof( SHEET ) );
	SetCommonBorder( contents, BORDER_NOCAPTION | BORDER_NONE );
	sheet->content = contents;
	//sheet->next = NULL;
	//sheet->me = NULL;
	if( sheet->content->caption.text )
	{
		SFTFont font = GetCommonFont( pControl );
		sheet->tab_width = GetStringSizeFont( GetText( sheet->content->caption.text ), NULL, NULL, font );
#ifdef DEBUG_SHEET
		Log1( "Tab width is %d", sheet->tab_width );
#endif
	}
	else
	{
		Log( "Sheet has no caption..." );
		sheet->tab_width = 0;
	}
 // 2 left, 2 right, 2 padd each side away from text?
	sheet->tab_width += 8;
	// can't use standard 'link thing' cause this links at end of list.
	if( psc->sheets )
	{
		PSHEET next = psc->sheets;
		while( next->next )
		{
			if( next->content->nID == sheet->content->nID )
			{
				Log( "Warning - sheet with ID already exists..." );
				Log( "Will not be able to select this sheet externally..." );
			}
			next = next->next;
		}
		next->next = sheet;
		sheet->me = &next->next;
	}
	else
	{
		//lprintf( "Adopting first sheet..." );
		psc->sheets = sheet;
		sheet->me = &psc->sheets;
		SetCurrentSheet( pControl, sheet->content->nID );
	}
}
PSI_PROC( int, RemoveSheet )( PSI_CONTROL pControl, uint32_t ID )
{
	ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, pControl );
	if( psc )
	{
		PSHEET sheet = psc->sheets;
		while( sheet )
		{
			if( !sheet->content )
			{
				Log( "Sheet exists without content!?!?!?" );
				continue;
			}
			if( sheet->content->nID == ID )
			{
				// keep the content - the application has the reponsibility
				// of freeing the controls.
				//DestroyCommon( &sheet->content );
				Release( sheet );
				UnlinkThing( sheet );
				return TRUE;
			}
			sheet = sheet->next;
		}
	}
	return FALSE;
}
PSI_PROC( void, SetCurrentSheet )( PSI_CONTROL pControl, uint32_t ID )
{
	ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, pControl );
	if( psc )
	{
		PSHEET sheet = GetSheetID( psc, ID );
		if( sheet )
			SetCurrentPage( pControl, sheet );
	}
}
PSI_PROC( int, GetSheetSize )( PSI_CONTROL pControl, uint32_t *width, uint32_t *height )
{
	ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, pControl );
	if( psc )
	{
		if( width )
			*width = psc->mount_point->surface_rect.width;
		if( height )
			*height = psc->mount_point->surface_rect.height;
		return 1;
	}
	return 0;
}
PSI_PROC( PSI_CONTROL, GetSheet )( PSI_CONTROL pControl, uint32_t ID )
{
	ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, pControl );
	if( psc )
	{
		PSHEET sheet = GetSheetID( psc, ID );
		if( sheet )
			return (PSI_CONTROL)sheet->content;
	}
	return NULL;
}
PSI_PROC( PSI_CONTROL, GetSheetControl )( PSI_CONTROL pControl
												 , uint32_t IDSheet
												 , uint32_t IDControl )
{
	ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, pControl );
	if( psc )
	{
		PSI_CONTROL sheet = GetSheet( pControl, IDSheet );
		return GetControl( sheet, IDControl );
	}
	return NULL;
}
PSI_PROC( PSI_CONTROL, GetCurrentSheet )( PSI_CONTROL pControl )
{
	ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, pControl );
	if( psc )
	{
		if( psc->current )
			return psc->current->content;
	}
	return NULL;
}
PSI_PROC( void, DisableSheet )( PSI_CONTROL pControl, uint32_t ID, LOGICAL bDisable )
{
	ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, pControl );
	if( psc )
	{
		PSHEET sheet = GetSheetID( psc, ID );
		if( sheet )
		{
			sheet->flags.bDisabled = bDisable;
			if( psc->current == sheet )
			{
				PSHEET check;
				for( check = psc->sheets; check; check = check->next )
					if( check == psc->prior_sheet )
					{
						SetCurrentPage( pControl, check );
						break;
					}
				if( !check )
				{
					SetCurrentPage( pControl, NULL );
				}
			}
		}
	}
}
//-------------------------------------------------------------------
static void SliceImages( Image image, Image slices[3] )
{
	int n;
	for( n = 0; n < 3; n++ )
		if( slices[n] )
		{
			UnmakeImageFile( slices[n] );
			slices[n] = NULL;
		}
	if( image )
	{
		uint32_t w = image->width;
		uint32_t mid;
		if( w & 1 )
		{
			w /= 2;
			mid = 1;
		}
		else
		{
			w = (w-1) / 2;
			mid = 2;
		}
		slices[0] = MakeSubImage( image, 0, 0, w, image->height );
		slices[1] = MakeSubImage( image, w, 0, mid, image->height );
		slices[2] = MakeSubImage( image, w+mid, 0, w, image->height );
	}
}
//-------------------------------------------------------------------
void SetTabImages( PSI_CONTROL pControl, Image active, Image inactive )
{
	ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, pControl );
	if( psc )
	{
		psc->active = active;
		psc->inactive = inactive;
		if( active )
			psc->tab_pad = active->width / 2;
		SliceImages( psc->active
					  , psc->active_slices );
		SliceImages( psc->inactive
					  , psc->inactive_slices );
		ComputeHeight( pControl );
		SmudgeCommon( pControl );
	}
}
//-------------------------------------------------------------------
// set tab images on a per-sheet basis, overriding the defaults specified.
void SetSheetTabImages( PSI_CONTROL pControl, uint32_t ID, Image active, Image inactive )
{
	ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, pControl );
	if( psc )
	{
		PSHEET sheet = GetSheetID( psc, ID );
		if( sheet )
		{
			sheet->active = active;
			sheet->inactive = inactive;
			sheet->tab_pad = active->width / 2;
			SliceImages( sheet->active
						  , sheet->active_slices );
			SliceImages( sheet->inactive
						  , sheet->inactive_slices );
			ComputeHeight( pControl );
			SmudgeCommon( pControl );
		}
	}
}
//-------------------------------------------------------------------
void SetTabTextColors( PSI_CONTROL pControl, CDATA cActive, CDATA cInactive )
{
	ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, pControl );
	if( psc )
	{
		psc->flags.bCustomColors = 1;
		psc->cActiveText = cActive;
		psc->cInactiveText = cInactive;
		SmudgeCommon( pControl );
	}
}
//-------------------------------------------------------------------
void SetSheetTabTextColors( PSI_CONTROL pControl, uint32_t ID, CDATA cActive, CDATA cInactive )
{
	ValidatedControlData( PSHEETCONTROL, SHEET_CONTROL, psc, pControl );
	if( psc )
	{
		PSHEET sheet = GetSheetID( psc, ID );
		if( sheet )
		{
			sheet->flags.bCustomColors = 1;
			sheet->cActiveText = cActive;
			sheet->cInactiveText = cInactive;
			SmudgeCommon( pControl );
		}
	}
}
PSI_SHEETS_NAMESPACE_END
//-------------------------------------------------------------------
// $Log: ctlsheet.c,v $
// Revision 1.30  2005/03/21 20:41:35  panther
// Protect against super large fonts, remove edit frame from palette, and clean up some warnings.
//
// Revision 1.29  2005/03/07 00:03:04  panther
// Reformatting, removed a lot of superfluous logging statements.
//
// Revision 1.28  2005/03/04 19:07:32  panther
// Define SetItemText
//
// Revision 1.27  2005/02/18 19:42:38  panther
// fix some update issues with hiding and revealing controls/frames... minor fixes for new API changes
//
// Revision 1.26  2005/02/01 02:20:23  panther
// Debugging added...
//
// Revision 1.25  2005/01/10 21:43:42  panther
// Unix-centralize makefiles, also modify set container handling of getmember index
//
// Revision 1.24  2004/12/20 19:41:00  panther
// Minor reformats and function protection changes (static)
//
// Revision 1.23  2004/12/05 00:22:44  panther
// Fix focus flag reference and edit controls begin to work.  Sheet controls are still flaky
//
// Revision 1.22  2004/11/29 11:29:53  panther
// Minor code cleanups, investigate incompatible display driver
//
// Revision 1.21  2004/10/24 20:09:47  d3x0r
// Sync to psilib2... stable enough to call it mainstream.
//
// Revision 1.7  2004/10/12 08:10:51  d3x0r
// checkpoint... frames are controls, and anything can be displayed...
//
// Revision 1.6  2004/10/08 01:21:17  d3x0r
// checkpoint
//
// Revision 1.5  2004/10/06 09:52:16  d3x0r
// checkpoint... total conversion... now how does it work?
//
// Revision 1.4  2004/10/05 00:20:29  d3x0r
// Break out these rather meaty parts from controls.c
//
// Revision 1.3  2004/09/28 16:52:18  d3x0r
// compiles - might work... prolly not.
//
// Revision 1.2  2004/09/27 20:44:28  d3x0r
// Sweeping changes only a couple modules left...
//
// Revision 1.1  2004/09/19 19:22:31  d3x0r
// Begin version 2 psilib...
//
// Revision 1.15  2004/09/03 14:43:48  d3x0r
// flexible frame reactions to font changes...
//
// Revision 1.14  2004/08/24 17:18:00  d3x0r
// Fix last couple c files for new control_proc_def macro
//
// Revision 1.13  2004/06/16 03:02:50  d3x0r
// checkpoint
//
// Revision 1.12  2003/12/03 11:06:42  panther
// Added extended draw options to orphan, adopt. Fixed sheet control issues
//
// Revision 1.11  2003/12/03 10:44:48  panther
// Implement OrphanEx, still have probs with sheets
//
//
PSI_SLIDER_NAMESPACE
//------------------------------------------------------------------------------
//---------------------------------------------------------------------------
typedef struct slider_tag
{
	struct {
 // vertical if not horizontal
		int bHorizontal:1;
 // clicked and held...
		int bDragging:1;
	}flags;
	int min, max, current;
 // prior button state;
	int _x, _y, _b;
	void (CPROC*SliderUpdated)( uintptr_t psvUser, PSI_CONTROL pc, int val );
   uintptr_t psvUser;
} SLIDER, *PSLIDER;
//---------------------------------------------------------------------------
static int OnDrawCommon( SLIDER_CONTROL_NAME )( PSI_CONTROL pc )
//int CPROC _DrawSlider( PSI_CONTROL pc )
{
	ValidatedControlData( PSLIDER, SLIDER_CONTROL, ps, pc );
	if( ps )
	{
      //BlatColorAlpha( pc->Surface, 0, 0, pc->surface_rect.width, pc->surface_rect.height, basecolor(pc)[NORMAL] );
		//ClearImageTo( pc->Surface, basecolor(pc)[NORMAL] );
		if( ps->flags.bHorizontal )
		{
			int midy;
			int fromx, tox;
			int caretx;
			int caretw, careth;
			careth = pc->surface_rect.height - 2;
			caretw = careth / 2;
			midy = pc->surface_rect.height / 2;
			fromx = 2+(caretw/2);
			tox = pc->surface_rect.width - (2+(caretw/2));
			do_line( pc->Surface, fromx+1, midy-1, tox-1, midy-1, basecolor(pc)[SHADOW] );
			do_line( pc->Surface, fromx, midy, tox, midy, basecolor(pc)[SHADE] );
			do_line( pc->Surface, fromx+1, midy+1, tox-1, midy+1, basecolor(pc)[HIGHLIGHT] );
			{
				int x;
				caretx = fromx + ( ps->current - ps->min ) * ( tox - fromx ) / ( ps->max - ps->min );
				for( x = -caretw/2; x <= caretw/2; x++ )
				{
					int y, c;
					if( x < 0 )
						y = -x;
					else
						y = x;
					if( x == -caretw/2 )
						c = basecolor(pc)[HIGHLIGHT];
					else if( x == caretw/2 )
						c = basecolor(pc)[SHADOW];
					else if( x == caretw/2 - 1 )
						c = basecolor(pc)[SHADE];
					else
						c = basecolor(pc)[NORMAL];
					do_line( pc->Surface, x + caretx, 1 + y, caretx + x, ( careth - 1 ) - y, c );
				}
				do_line( pc->Surface, caretx, 1,
						  caretx + caretw/2 - 1,  caretw/2, basecolor(pc)[SHADE] );
				do_line( pc->Surface, caretx - caretw/2, 1 + caretw/2
						 , caretx           , 1, basecolor(pc)[HIGHLIGHT] );
				do_line( pc->Surface, caretx - caretw/2, careth - 1 - caretw/2
								     , caretx, careth - 1, basecolor(pc)[SHADE] );
				do_line( pc->Surface, caretx, careth - 1
						 , caretx + caretw/2, careth - 1 - caretw/2, basecolor(pc)[SHADOW] );
				do_line( pc->Surface, caretx, careth - 2
						 , caretx + caretw/2 - 1, careth - 1 - caretw/2, basecolor(pc)[SHADE] );
			}
		}
		else
		{
			int midx;
			int fromy, toy, carety, careth, caretw;
			careth = pc->surface_rect.width - 2;
			caretw = careth / 2;
			midx = pc->surface_rect.width /2;
			fromy = 2 + (caretw/2);
			toy = pc->surface_rect.height - (2 + (caretw/2));
			do_line( pc->Surface, midx-1, fromy+1, midx-1, toy-1, basecolor(pc)[SHADOW] );
			do_line( pc->Surface, midx, fromy, midx, toy, basecolor(pc)[SHADE] );
			do_line( pc->Surface, midx+1, fromy+1, midx+1, toy-1, basecolor(pc)[HIGHLIGHT] );
			{
				int x;
				carety = fromy + ( ps->current - ps->min ) * ( toy - fromy ) / ( ps->max - ps->min );
				for( x = -caretw/2; x <= caretw/2; x++ )
				{
					int y, c;
					if( x < 0 )
						y = -x;
					else
						y = x;
					if( x == -caretw/2 )
						c = basecolor(pc)[HIGHLIGHT];
					else if( x == caretw/2 )
						c = basecolor(pc)[SHADOW];
					else if( x == caretw/2 - 1 )
						c = basecolor(pc)[SHADE];
					else
						c = basecolor(pc)[NORMAL];
					do_inv_line( pc->Surface, x + carety, 1 + y, carety + x, ( careth - 1 ) - y, c );
				}
				do_inv_line( pc->Surface, carety, 1,
								carety + caretw/2 - 1,  caretw/2, basecolor(pc)[SHADE] );
				do_inv_line( pc->Surface, carety - caretw/2, 1 + caretw/2
							  , carety           , 1, basecolor(pc)[HIGHLIGHT] );
				do_inv_line( pc->Surface, carety - caretw/2, careth - 1 - caretw/2
							  , carety, careth - 1, basecolor(pc)[SHADE] );
				do_inv_line( pc->Surface, carety, careth - 1
							  , carety + caretw/2, careth - 1 - caretw/2, basecolor(pc)[SHADOW] );
				do_inv_line( pc->Surface, carety, careth - 2
							  , carety + caretw/2 - 1, careth - 1 - caretw/2, basecolor(pc)[SHADE] );
			}
		}
	}
   return 1;
}
//---------------------------------------------------------------------------
static int OnMouseCommon( SLIDER_CONTROL_NAME )( PSI_CONTROL pc, int32_t x, int32_t y, uint32_t b )
//int CPROC _SliderMouse( PSI_CONTROL pc, int32_t x, int32_t y, uint32_t b )
{
	PSLIDER ps = ControlData( PSLIDER, pc );
	int pos, span;
	// see if the x/y is on the slider tab...
	if( b & MK_LBUTTON )
	{
 // already selected, update to this pos...
		if( ps->flags.bDragging )
		{
			int from, to, newcur;
			if( ps->flags.bHorizontal )
			{
				span = ( pc->surface_rect.height - 2 ) / 4;
				from = 2 + span;
				to = pc->surface_rect.width - (2 + span);
				pos = from + ( ps->current - ps->min ) * ( to - from ) / ( ps->max - ps->min );
				newcur = ( ( x - from ) * (ps->max-ps->min)/(to-from) ) + ps->min;
			}
			else
			{
				span = ( pc->surface_rect.width - 2 ) / 4;
				from = 2 + span;
				to = pc->surface_rect.height - (2 + span);
				pos = from + ( ps->current - ps->min ) * ( to - from ) / ( ps->max - ps->min );
				newcur = ( ( y - from ) * (ps->max-ps->min)/(to-from) ) + ps->min;
         }
			if( newcur != ps->current )
			{
				ps->current = newcur;
				if( ps->current < ps->min )
					ps->current = ps->min;
				if( ps->current > ps->max )
					ps->current = ps->max;
				if( ps->SliderUpdated )
					ps->SliderUpdated( ps->psvUser, pc, ps->current );
				SmudgeCommon( pc );
			}
		}
		else if( !(ps->_b & MK_LBUTTON ) )
		{
			int from, to, c;
			if( ps->flags.bHorizontal )
			{
				span = ( pc->surface_rect.height - 2 ) / 4;
				from = 2 + span;
				to = pc->surface_rect.width - (2 + span);
				pos = from + ( ps->current - ps->min ) * ( to - from ) / ( ps->max - ps->min );
				c = x;
			}
			else
			{
				int from, to;
				span = ( pc->surface_rect.width - 2 ) / 4;
				from = 2 + span;
				to = pc->surface_rect.height - (2 + span);
				pos = from + ( ps->current - ps->min ) * ( to - from ) / ( ps->max - ps->min );
				c = y;
			}
			if( c > ( pos + span ) )
			{
				int step;
				step = ( ps->max - ps->min ) / 10;
				ps->current += step;
				if( ps->current > ps->max )
					ps->current = ps->max;
				if( ps->SliderUpdated )
					ps->SliderUpdated( ps->psvUser, pc, ps->current );
            SmudgeCommon( pc );
			}
			else if( c < (pos - span ) )
			{
				int step;
				step = ( ps->max - ps->min ) / 10;
				ps->current -= step;
				if( ps->current < ps->min )
					ps->current = ps->min;
            //UpdateCommon(pc);
				if( ps->SliderUpdated )
					ps->SliderUpdated( ps->psvUser, pc, ps->current );
            SmudgeCommon( pc );
			}
 // on span of control...
			else
			{
				ps->flags.bDragging = TRUE;
				ps->_x = x;
				ps->_y = y;
			}
			if( 1 )
			{
			}
		}
	}
	else
	{
		ps->flags.bDragging = FALSE;
	}
	ps->_b = b;
	return 1;
}
//---------------------------------------------------------------------------
PSI_CONTROL SetSliderOptions( PSI_CONTROL pc, int attr )
{
	ValidatedControlData( PSLIDER, SLIDER_CONTROL, ps, pc );
	if( ps )
	{
		if( attr & SLIDER_HORIZ )
			ps->flags.bHorizontal = 1;
		else
			ps->flags.bHorizontal = 0;
      SmudgeCommon( pc );
	}
    return pc;
}
PSI_CONTROL SetSliderUpdateHandler( PSI_CONTROL pc, SliderUpdateProc SliderUpdated, uintptr_t psvUser )
{
	ValidatedControlData( PSLIDER, SLIDER_CONTROL, ps, pc );
	if( ps )
	{
		ps->SliderUpdated = SliderUpdated;
		ps->psvUser = psvUser;
	}
   return pc;
}
//#undef MakeSlider
static int OnCreateCommon( SLIDER_CONTROL_NAME )( PSI_CONTROL pc )
//CONTROL_PROC_DEF( SLIDER_CONTROL, SLIDER, Slider, (void)/* (CPROC*SliderUpdated)(uintptr_t psv, PSI_CONTROL pc, int val), uintptr_t psv)*/ )
{
	ValidatedControlData( PSLIDER, SLIDER_CONTROL, ps, pc );
	if( ps )
	{
		SetCommonTransparent( pc, TRUE );
		ps->min = 0;
		ps->max = 100;
		ps->current = 50;
		//if( args )
		{
			//FP_ARG( void CPROC, SliderUpdated,(uintptr_t psv, PSI_CONTROL pc, int val));
			//ARG( uintptr_t, psv );
         //ARG( uint32_t, attr );
			//ps->SliderUpdated = SliderUpdated;
			//ps->psvUser = psv;
			//if( attr & SLIDER_HORIZ )
         //   ps->flags.bHorizontal = 1;
		}
      return TRUE;
	}
   return FALSE;
}
//---------------------------------------------------------------------------
void SetSliderValues( PSI_CONTROL pc, int min, int current, int max )
{
	if( pc )
	{
		ValidatedControlData( PSLIDER, SLIDER_CONTROL, ps, pc );
		if( ps )
		{
			ps->min = min;
			if( current > max )
				current = max;
			if( current < min )
				current = min;
			ps->current = current;
			ps->max = max;
			if( ps->SliderUpdated )
				ps->SliderUpdated( ps->psvUser, pc, ps->current );
			SmudgeCommon(pc);
		}
	}
}
CONTROL_REGISTRATION
slider_control = { SLIDER_CONTROL_NAME
					  , { { 140, 20 }, sizeof( SLIDER ), BORDER_NONE }
 //InitSlider
					  , NULL
					  , NULL
 //_DrawSlider
					  , NULL
 //_SliderMouse
					  , NULL
};
PRIORITY_PRELOAD( RegisterSlider, PSI_PRELOAD_PRIORITY )
{
   DoRegisterControl( &slider_control );
}
PSI_SLIDER_NAMESPACE_END
// $Log: ctlslider.c,v $
// Revision 1.22  2005/03/30 11:36:38  panther
// Remove a lot of debugging messages...
//
// Revision 1.21  2005/03/22 12:41:58  panther
// Wow this transparency thing is going to rock! :) It was much closer than I had originally thought.  Need a new class of controls though to support click-masks.... oh yeah and buttons which have roundable scaleable edged based off of a dot/circle
//
// Revision 1.20  2004/12/14 14:40:23  panther
// Fix slider control to handle the attr flags again for direction.  Fixed font selector dialog to close coorectly, update between controls correctly, etc
//
// Revision 1.19  2004/12/13 11:26:53  panther
// Minor protection on update common, also fix registration of image to not have a destroy function... hmm maybe should though in order to release the image attached.
//
// Revision 1.18  2004/10/24 20:09:47  d3x0r
// Sync to psilib2... stable enough to call it mainstream.
//
// Revision 1.5  2004/10/08 01:21:17  d3x0r
// checkpoint
//
// Revision 1.4  2004/10/07 04:37:16  d3x0r
// Okay palette and listbox seem to nearly work... controls draw, now about that mouse... looks like my prior way of cheating is harder to step away from than I thought.
//
// Revision 1.3  2004/10/06 09:52:16  d3x0r
// checkpoint... total conversion... now how does it work?
//
// Revision 1.2  2004/09/27 20:44:28  d3x0r
// Sweeping changes only a couple modules left...
//
// Revision 1.1  2004/09/19 19:22:31  d3x0r
// Begin version 2 psilib...
//
// Revision 1.17  2004/09/07 07:05:46  d3x0r
// Stablized up to palette dialog, which is internal... may require recompile binary upgrade may not work.
//
// Revision 1.16  2004/09/03 14:43:48  d3x0r
// flexible frame reactions to font changes...
//
// Revision 1.15  2004/08/25 08:44:52  d3x0r
// Portability changes for MSVC... Updated projects, all projects build up to PSI, no display...
//
// Revision 1.14  2003/09/13 17:06:29  panther
// Okay - and now we use stdargs... ugly kinda but okay...
//
// Revision 1.13  2003/09/11 13:09:25  panther
// Looks like we maintained integrety while overhauling the Make/Create/Init/Config interface for controls
//
// Revision 1.12  2003/07/24 23:47:22  panther
// 3rd pass visit of CPROC(cdecl) updates for callbacks/interfaces
//
// Revision 1.11  2003/05/01 21:31:57  panther
// Cleaned up from having moved several methods into frame/control common space
//
// Revision 1.10  2003/03/25 08:45:56  panther
// Added CVS logging tag
//
PSI_TEXT_NAMESPACE
typedef struct text_tag {
 // centering field...
	uint32_t attr;
	struct {
		BIT_FIELD bShadow : 1;
	} flags;
	CDATA foreground, background;
 // text offset from text anchor position.
	int offset;
} TEXTCONTROL, *PTEXTCONTROL;
//------------------------------------------------------------------------------
PSI_CONTROL SetTextControlAttributes( PSI_CONTROL pc, int flags )
{
	ValidatedControlData( PTEXTCONTROL, STATIC_TEXT, ptc, pc );
	if( ptc )
	{
		ptc->attr = flags;
	}
	return pc;
}
void SetControlAlignment( PSI_CONTROL pc, int align )
{
	ValidatedControlData( PTEXTCONTROL, STATIC_TEXT, ptc, pc );
	//if( align & TEXT_INVERT )
	//	pc->flags.bInvert = 1;
	//else
	//	pc->flags.bInvert = 0;
	if( align & TEXT_VERTICAL )
		pc->flags.bVertical = 1;
	else
		pc->flags.bVertical = 0;
	if( align & TEXT_RIGHT )
		pc->flags.bAlign = 3;
	else if( align & TEXT_CENTER )
		pc->flags.bAlign = 2;
	else
		pc->flags.bAlign = 0;
	if( align & TEXT_SHADOW_TEXT )
		ptc->flags.bShadow = 1;
	SmudgeCommon( pc );
}
static int CPROC OnDrawCommon( STATIC_TEXT_NAME )( PSI_CONTROL pc )
{
	ValidatedControlData( PTEXTCONTROL, STATIC_TEXT, ptc, pc );
	//lprintf( "drawing a text control..." );
	if( ptc )
	{
		Image surface = GetControlSurface( pc );
		SFTFont font;
		uint32_t height, width;
		ptc->foreground = basecolor( pc )[TEXTCOLOR];
		if( ptc->background )
			ClearImageTo( surface, ptc->background );
		font = GetFrameFont( pc );
		GetStringSizeFont( GetText( pc->caption.text )
										 , &width, &height, font );
		if( pc->caption.text ) switch( pc->flags.bAlign )
		{
 // right align - default to left align for now.
		case 3:
			if( pc->flags.bVertical )
				PutStringVerticalFont( surface
											, ( (int)surface->width - (int)width ) / 2, ( (int)surface->height - (int)height )
											, ptc->foreground, 0
											, GetText( pc->caption.text ), font );
			else
				PutStringFont( surface
								 , (int)ptc->offset + (int)surface->width - (int)width, ( (int)surface->height - (int)height ) / 2
								 , ptc->foreground, 0
								 , GetText( pc->caption.text ), font );
			break;
		default:
 // default
		case 0:
 // left
		case 1:
			if( pc->flags.bVertical )
				PutStringVerticalFont( surface
											, ( (int)surface->width - (int)width ) / 2 , 0
											, ptc->foreground, 0
											, GetText( pc->caption.text ), font );
			else
				PutStringFont( surface
								 , ptc->offset, ( (int)surface->height - (int)height ) / 2
								 , ptc->foreground
								 , 0
								 , GetText( pc->caption.text ), font );
			break;
 // center
		case 2:
			{
				width = GetStringSizeFont( GetText( pc->caption.text )
												 , NULL, &height, font );
				if( pc->flags.bVertical )
					PutStringVerticalFont( surface
												, ( (int)surface->width - (int)height ) / 2
												, ptc->offset + ( (int)surface->height - (int)width ) / 2
												, ptc->foreground
												, 0
												, GetText( pc->caption.text ), font );
				else
				{
					//lprintf( "render string length %d at %d", width, ptc->offset + ( ( (int)surface->width - width ) / 2 ) );
					if( ptc->flags.bShadow )
					{
                  // okay we don't know how to get the shadow color have to extedn that
						PutStringFont( surface
										 , ptc->offset + ( ( (int)surface->width - (int)width ) / 2 )
										 , ( (int)surface->height - (int)height ) / 2
										 , ptc->foreground
										 , 0
										 , GetText( pc->caption.text ), font );
					}
					else
						PutStringFont( surface
										 , ptc->offset + ( ( (int)surface->width - (int)width ) / 2 )
										 , ( (int)surface->height - (int)height ) / 2
										 , ptc->foreground
										 , 0
										 , GetText( pc->caption.text ), font );
				}
			}
			break;
		}
	}
	return TRUE;
}
//---------------------------------------------------------------------------
//#undef MakeTextControl
CAPTIONED_CONTROL_PROC_DEF( STATIC_TEXT, TEXTCONTROL, TextControl, (int attr) )
{
	ValidatedControlData( PTEXTCONTROL, STATIC_TEXT, ptc, pc );
	if( ptc )
	{
		SetNoFocus( pc );
		ptc->foreground = basecolor(pc)[TEXTCOLOR];
//basecolor(pc)[NORMAL];
		ptc->background = 0;
		SetCommonTransparent( pc, TRUE );
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------------
PSI_PROC( void, SetTextControlColors )( PSI_CONTROL pc, CDATA fore, CDATA back )
{
	ValidatedControlData( PTEXTCONTROL, STATIC_TEXT, ptc, pc );
	if( (!ptc) )
		return;
	if( fore )
		SetControlColor( pc, TEXTCOLOR, fore );
	else
		ptc->foreground = basecolor(pc)[TEXTCOLOR];
	// if we don't allow the application to set the background to OFF
	// then it can't just be floating transparency text....
	//if( back )
		ptc->background = back;
	//else
	//	ptc->background = basecolor(pc)[NORMAL];
	SmudgeCommon( pc );
}
LOGICAL GetControlTextOffsetMinMax( PSI_CONTROL pc, int *min_offset, int *max_offset )
{
	ValidatedControlData( PTEXTCONTROL, STATIC_TEXT, ptc, pc );
	if( ptc )
	{
		int minofs;
		int maxofs;
		uint32_t height, width;
		int32_t _height, _width;
		Image surface = GetControlSurface( pc );
		SFTFont font = GetFrameFont( pc );
		width = GetStringSizeFont( GetText( pc->caption.text )
										 , NULL, &height, font );
		_width = (int)width;
		_height = (int)height;
		minofs = (-_width+1);
		switch(  pc->flags.bAlign )
		{
 // right align - default to left align for now.
		case 3:
			if( pc->flags.bVertical )
			{
				minofs =((surface->height -_width) -_width ) + 1;
				maxofs = (surface->height) - 1;
			}
			else
			{
				minofs =((surface->width -_width) -_width ) + 1;
				maxofs = (surface->width) - 1;
			}
			break;
		default:
 // default
		case 0:
 // left
		case 1:
			if( pc->flags.bVertical )
			{
				minofs = ( -_width ) + 1;
				maxofs = surface->height - 1;
			}
			else
			{
				minofs = ( -_width ) + 1;
				maxofs = surface->width - 1;
			}
			break;
 // center
		case 2:
			if( pc->flags.bVertical )
			{
				// okay center is (h/2 - w/2) for first pixel
				// min is this posisition minus the width minus this position
				minofs = ( -( _width  + ( ( surface->height - _width ) / 2 )) )+ 1;
				maxofs = ( surface->height-( (int)surface->height - _width )/2  )- 1;
			}
			else
			{
				minofs = ( -( _width  + ( ( surface->width - _width ) / 2 )) )+ 1;
				maxofs = ( surface->width-( (int)surface->width - _width )/2  )- 1;
			}
		}
		if( min_offset )
			(*min_offset) = minofs;
		if( max_offset )
			(*max_offset) = maxofs;
		//lprintf( "result was %d %d", minofs, maxofs );
		return TRUE;
	}
	return FALSE;
}
LOGICAL SetControlTextOffset( PSI_CONTROL pc, int offset )
{
	ValidatedControlData( PTEXTCONTROL, STATIC_TEXT, ptc, pc );
	if( ptc )
	{
		LOGICAL result = TRUE;
		ptc->offset = offset;
		{
			uint32_t height, width;
			int32_t _height, _width;
			Image surface = GetControlSurface( pc );
			SFTFont font = GetFrameFont( pc );
			width = GetStringSizeFont( GetText( pc->caption.text )
											 , NULL, &height, font );
			_width = (int)width;
			_height = (int)height;
			switch( pc->flags.bAlign )
			{
 // right align - default to left align for now.
			case 3:
				if( pc->flags.bVertical )
				{
					if( ( offset + ( (int)surface->height - _width ) > surface->height )
						|| ( offset + ( (int)surface->height - _width ) < 0 ) )
					{
						//lprintf( "false at %d %d %d %d",ptc->offset, _width, surface->width, ( ptc->offset + _width + ( (int)surface->width - _width )/2 ) );
						result = FALSE;
					}
				}
				else
				{
						if( ( ( offset + (int)surface->width - _width ) > surface->width )
							|| ( ( offset + (int)surface->width - _width ) < 0 ) )
						{
							//lprintf( "false at %d %d %d %d",ptc->offset, _width, surface->width, ( ptc->offset + _width + ( (int)surface->width - _width )/2 ) );
							result = FALSE;
						}
				}
				break;
			default:
 // default
			case 0:
 // left
			case 1:
				if( pc->flags.bVertical )
				{
					if( ( ( offset + ( surface->height - _width ) ) > surface->height )
						|| SUS_GT( ( offset + ( surface->height - _width ) ), int32_t, width, uint32_t ) )
						result = FALSE;
				}
				else
				{
					if( ( offset > surface->width )
						|| ( ( offset + _width ) < 0 ) )
						result = FALSE;
				}
				break;
 // center
			case 2:
				if( pc->flags.bVertical )
				{
					if( ( ( ( ptc->offset + ( surface->height - _width )/2 ) ) > surface->height )
						|| ( ( ptc->offset + _width + ( ( surface->height - _width )/2 ) ) < 0 ) )
					{
						result = FALSE;
					}
				}
				else
				{
					if( ( ( ( ptc->offset + ( (int)surface->width - _width )/2 ) ) > surface->width )
						|| ( ( ptc->offset + _width + ( ( (int)surface->width - _width )/2 ) ) < 0 ) )
					{
                  //lprintf( "false at %d %d %d %d",ptc->offset, _width, surface->width, ( ptc->offset + _width + ( (int)surface->width - _width )/2 ) );
						result = FALSE;
					}
				}
			}
		}
		SmudgeCommon( pc );
		return result;
	}
	return FALSE;
}
CONTROL_REGISTRATION
text_control = { STATIC_TEXT_NAME
               , { {73, 21}, sizeof( TEXTCONTROL ), BORDER_NOCAPTION | BORDER_NONE}
// init
               , InitTextControl
               , NULL
 //_DrawTextControl
               , NULL
               , NULL
               , NULL
};
PRIORITY_PRELOAD( register_text, PSI_PRELOAD_PRIORITY ) {
	DoRegisterControl( &text_control );
}
PSI_TEXT_NAMESPACE_END
//---------------------------------------------------------------------------
/* this should be used as a top-most mouse-hover... it should capture the mouse(?) and disappear on motion */
#define _INCLUDE_CLIPBOARD
struct tool_tip_display {
	CTEXTSTR text;
};
typedef struct tool_tip_display TOOL_TIP_DISPLAY, *PTOOL_TIP_DISPLAY;
CONTROL_REGISTRATION
tool_tip_display_control = { IMAGE_DISPLAY_CONTROL_NAME
					, { { 256, 32}, sizeof( TOOL_TIP_DISPLAY ), BORDER_THINNER }
};
PRIORITY_PRELOAD( RegisterToolTipDisplay, PSI_PRELOAD_PRIORITY )
{
	DoRegisterControl( &tool_tip_display_control );
}
void SetControlHoverTip( PSI_CONTROL pc, CTEXTSTR text )
{
}
//void __stdcall DebugBreak(void);
//void __stdcall Sleep( uint32_t time );
PSI_NAMESPACE
typedef struct fileopen_tag {
   TEXTCHAR basepath[280];
	TEXTCHAR currentmask[280];
   TEXTCHAR currentname[280];
   int okay, done;
} FILEOPENDATA;
#define LST_FILES    100
#define TXT_PATHNAME 101
void RedrawTemplate( uintptr_t psv )
{
}
PSI_CONTROL pLoading;
void CPROC AddFile( uintptr_t user, CTEXTSTR pathname, enum ScanFileProcessFlags flags )
{
	PLISTITEM newitem;
//cpg26dec2006 c:\work\sack\src\psilib\fileopen.c(34): Warning! W202: Symbol 'pfod' has been defined, but not referenced
//cpg26dec2006	FILEOPENDATA *pfod = (FILEOPENDATA *)user;
   //xlprintf( LOG_ALWAYS )("file is %s %lx", pathname, flags );
   if( flags & SFF_DRIVE )
   {
      TEXTCHAR buffer[10];
      tnprintf( buffer, sizeof( buffer ), "-%c-", pathname[0] );
      newitem = AddListItem( pLoading, buffer );
      SetItemData( newitem, (uintptr_t)flags );
   }
   else
   {
		CTEXTSTR name = pathrchr( pathname );
      if( name )
         name++;
      else
			name = pathname;
		if( flags & SFF_DIRECTORY )
		{
			TEXTCHAR buffer[256];
			tnprintf( buffer, sizeof( buffer ), "%s/", name );
			newitem = AddListItem( pLoading, buffer );
			SetItemData( newitem, (uintptr_t)flags );
		}
      else
		{
			newitem = AddListItem( pLoading, name );
			SetItemData( newitem, (uintptr_t)flags );
		}
   }
}
void LoadList( PSI_CONTROL list, FILEOPENDATA *pfod )
{
   void *stuff = NULL;
   while( pLoading ) Idle();
   pLoading = list;
   // this may do nothing on say a unix system... but we may have
	// drives - perhaps we could alias mount points to drive letters...
   SetControlText( GetNearControl( list, TXT_PATHNAME ), pfod->basepath );
	if( !pfod->basepath[0] )
	{
		ScanDrives( (void (CPROC *)( uintptr_t, CTEXTSTR, int))AddFile, (uintptr_t)pfod );
	}
	else
	{
      AddFile( (uintptr_t)pfod, "..", SFF_DIRECTORY );
		while( ScanFiles( pfod->basepath
								, pfod->currentmask
								, &stuff, AddFile, SFF_DIRECTORIES, (uintptr_t)pfod ) );
	}
	pLoading = 0;
}
void CPROC FileDouble( uintptr_t psv, PSI_CONTROL pc, PLISTITEM hli )
{
   uint32_t flags;
   TEXTCHAR name[256];
   if( hli )
   {
      flags = (uint32_t)GetItemData( hli );
      if( flags & SFF_DRIVE )
      {
         FILEOPENDATA *pfod = (FILEOPENDATA *)psv;
         GetListItemText( hli, name, 256 );
			pfod->basepath[0] = name[1];
         ResetList( pc );
         LoadList( pc, pfod );
      }
      else if( flags & SFF_DIRECTORY )
      {
         //char *newpath;
         FILEOPENDATA *pfod = (FILEOPENDATA *)psv;
         GetListItemText( hli, name, 256 );
         ResetList( pc );
         if( strcmp( name, "../" ) == 0 )
         {
            TEXTSTR trim = (TEXTSTR)pathrchr( pfod->basepath );
            if( trim )
            {
               if( trim != pfod->basepath &&
                   trim[-1] != ':' )
               {
 // kill this
                  trim[0] = 0;
               }
               else
                  trim[0] = 0;
				}
				else
				{
               pfod->basepath[0] = 0;
				}
         }
         else
			{
            name[strlen(name)-1] = 0;
            tnprintf( pfod->basepath, sizeof(pfod->basepath), "%s/%s", pfod->basepath, name );
         }
         LoadList( pc, pfod );
      }
      else
		{
			FILEOPENDATA *pfod = (FILEOPENDATA *)psv;
			//printf( "setting done?" );
			pfod->okay = TRUE;
      }
   }
}
void CPROC FileSingle( uintptr_t psv, PSI_CONTROL list, PLISTITEM hli )
{
	TEXTCHAR name[256];
	if( hli )
	{
		GetListItemText( hli, name, sizeof( name ) );
		SetControlText( GetNearControl( list, TXT_PATHNAME ), name );
	}
}
int PSI_PickFile( PSI_CONTROL parent, CTEXTSTR basepath, CTEXTSTR types, TEXTSTR result, uint32_t result_len, int Create )
{
	// auto configure open file dialog - well for now let us start at
	// the current working directory...
	int32_t x, y;
	PSI_CONTROL frame;
	PSI_CONTROL pcList;
	FILEOPENDATA fod;
	GetMousePosition( &x, &y );
	frame = CreateFrame( "Open File", x, y, 320, 200, BORDER_NORMAL, 0 );
	//char path[280];
	if( !basepath || (strcmp( basepath, "." )== 0) )
		GetCurrentPath(fod.basepath, sizeof( fod.basepath ) );
	else
		StrCpyEx( fod.basepath, basepath, sizeof( fod.basepath ) / sizeof(TEXTCHAR) );
	fod.done = 0;
	fod.okay = 0;
	MakeEditControl( frame, 5, 5, 240, 20, TXT_PATHNAME, NULL, 0 );
	//MakeTextControl( frame, 0, 5, 5, 240, 20, TXT_PATHNAME, NULL );
	pcList = MakeListBox( frame, 5, 25, 240, 150, LST_FILES, LISTOPT_SORT );
	SetDoubleClickHandler( pcList, FileDouble, (uintptr_t)&fod );
	SetSelChangeHandler( pcList, FileSingle, (uintptr_t)&fod );
	StrCpyEx( fod.currentmask, "*", sizeof( fod.currentmask ) / sizeof(TEXTCHAR) );
	LoadList( pcList, &fod );
	AddCommonButtons( frame, &fod.done, &fod.okay );
 // must be called - even though without it it's still drawn :/
	DisplayFrameOver( frame, parent );
ReLoop:
	CommonWait( frame );
	if( fod.okay )
	{
		// well suppose we should pull out our values before closing this frame...
		PLISTITEM hli = GetSelectedItem( pcList );
		uint32_t flags = (uint32_t)GetItemData( hli );
		if( !(flags & (SFF_DRIVE|SFF_DIRECTORY) ) )
		{
			GetControlText( GetControl( frame, TXT_PATHNAME ), fod.currentname, 280 );
			tnprintf( result, result_len, "%s/%s", fod.basepath, fod.currentname );
			DestroyCommon( &frame );
			return 1;
		}
		else
		{
			// show - invalid selection - no filename - is a directory...
			//printf( "Clearing done?" );
			fod.okay = 0;
			FileDouble( (uintptr_t)&fod, pcList, hli );
			goto ReLoop;
		}
	}
	DestroyCommon( &frame );
	return 0;
}
int PSI_OpenFile( CTEXTSTR basepath, CTEXTSTR types, TEXTSTR result )
//( PSI_CONTROL parent, CTEXTSTR basepath, CTEXTSTR types, TEXTSTR result, uint32_t result_len )
{
   return PSI_PickFile( NULL, basepath, types, result, 256, 0 );
}
PSI_NAMESPACE_END
// $Log: fileopen.c,v $
// Revision 1.21  2005/02/18 19:42:38  panther
// fix some update issues with hiding and revealing controls/frames... minor fixes for new API changes
//
// Revision 1.20  2005/02/10 16:55:51  panther
// Fixing warnings...
//
// Revision 1.19  2004/11/29 11:29:53  panther
// Minor code cleanups, investigate incompatible display driver
//
// Revision 1.18  2004/10/24 20:09:47  d3x0r
// Sync to psilib2... stable enough to call it mainstream.
//
// Revision 1.3  2004/10/07 04:37:16  d3x0r
// Okay palette and listbox seem to nearly work... controls draw, now about that mouse... looks like my prior way of cheating is harder to step away from than I thought.
//
// Revision 1.2  2004/10/06 09:52:16  d3x0r
// checkpoint... total conversion... now how does it work?
//
// Revision 1.1  2004/09/19 19:22:31  d3x0r
// Begin version 2 psilib...
//
// Revision 1.17  2003/11/29 00:10:28  panther
// Minor fixes for typecast equation
//
// Revision 1.16  2003/09/22 10:45:08  panther
// Implement tree behavior in standard list control
//
// Revision 1.15  2003/08/27 07:58:39  panther
// Lots of fixes from testing null pointers in listbox, font generation exception protection
//
// Revision 1.14  2003/07/24 23:47:22  panther
// 3rd pass visit of CPROC(cdecl) updates for callbacks/interfaces
//
// Revision 1.13  2003/05/01 21:31:57  panther
// Cleaned up from having moved several methods into frame/control common space
//
// Revision 1.12  2003/04/08 11:41:26  panther
// Don't define a global frame variable in fileopen
//
// Revision 1.11  2003/03/25 08:45:56  panther
// Added CVS logging tag
//
//#include <ft2build.h>
//#ifdef FT_FREETYPE_H
#if 1
//#include FT_FREETYPE_H
#ifndef FONT_GLOBAL_INCLUDED
#define FONT_GLOBAL_INCLUDED
/*
 *  sha1.h
 *
 *  Description:
 *      This is the header file for code which implements the Secure
 *      Hashing Algorithm 1 as defined in FIPS PUB 180-1 published
 *      April 17, 1995.
 *
 *      Many of the variable names in this code, especially the
 *      single character names, were used because those were the names
 *      used in the publication.
 *
 *      Please read the file sha1.c for more information.
 *
 */
#ifndef INCLUDED_SHA1_H_
#define INCLUDED_SHA1_H_
#ifdef SHA1_SOURCE
#define SHA1_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SHA1_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#if !defined(  HAS_STDINT )
#ifndef __WATCOMC__
	typedef unsigned long uint32_t;
	typedef short int_least16_t;
	typedef unsigned char uint8_t;
#else
#endif
//typedef unsigned char uint8_t;
//typedef int int_least16_t;
#endif
/*
 * If you do not have the ISO standard stdint.h header file, then you
 * must typdef the following:
 *    name              meaning
 *  uint32_t         unsigned 32 bit integer
 *  uint8_t          unsigned 8 bit integer (i.e., unsigned char)
 *  int_least16_t    integer of >= 16 bits
 *
 */
#ifndef _SHA_enum_
#define _SHA_enum_
enum
{
    shaSuccess = 0,
    shaNull,
    shaInputTooLong,
    shaStateError
};
#endif
#define SHA1HashSize 20
/*
 *  This structure will hold context information for the SHA-1
 *  hashing operation
 */
typedef struct SHA1Context
{
    uint32_t Intermediate_Hash[SHA1HashSize/4];
    uint32_t Length_Low;
    uint32_t Length_High;
                               /* Index into message block array   */
    int_least16_t Message_Block_Index;
    uint8_t Message_Block[64];
    int Computed;
    int Corrupted;
} SHA1Context;
/*
 *  Function Prototypes
 */
SHA1_PROC( int, SHA1Reset )(  SHA1Context *);
SHA1_PROC( int, SHA1Input )(  SHA1Context *,
                const uint8_t *,
                size_t);
SHA1_PROC( int, SHA1Result )( SHA1Context *,
                uint8_t Message_Digest[SHA1HashSize]);
#endif
// $Log: $
#ifndef STRUCT_ONLY
/***************************************************************************/
/*                                                                         */
/*  ft2build.h                                                             */
/*                                                                         */
/*    FreeType 2 build and setup macros.                                   */
/*                                                                         */
/*  Copyright 1996-2017 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* This is the `entry point' for FreeType header file inclusions.  It is */
  /* the only header file which should be included directly; all other     */
  /* FreeType header files should be accessed with macro names (after      */
  /* including `ft2build.h').                                              */
  /*                                                                       */
  /* A typical example is                                                  */
  /*                                                                       */
  /*   #include <ft2build.h>                                               */
  /*   #include FT_FREETYPE_H                                              */
  /*                                                                       */
  /*************************************************************************/
#ifndef FT2BUILD_H_
#define FT2BUILD_H_
#ifdef FT2_BUILD_LIBRARY
#  define NO_OPEN_MACRO
#endif
#define NO_UNICODE_C
/***************************************************************************/
/*                                                                         */
/*  ftheader.h                                                             */
/*                                                                         */
/*    Build macros of the FreeType 2 library.                              */
/*                                                                         */
/*  Copyright 1996-2017 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
#ifndef FTHEADER_H_
#define FTHEADER_H_
  /*@***********************************************************************/
  /*                                                                       */
  /* <Macro>                                                               */
  /*    FT_BEGIN_HEADER                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This macro is used in association with @FT_END_HEADER in header    */
  /*    files to ensure that the declarations within are properly          */
  /*    encapsulated in an `extern "C" { .. }' block when included from a  */
  /*    C++ compiler.                                                      */
  /*                                                                       */
#ifdef __cplusplus
#define FT_BEGIN_HEADER  extern "C" {
#else
#define FT_BEGIN_HEADER
#endif
  /*@***********************************************************************/
  /*                                                                       */
  /* <Macro>                                                               */
  /*    FT_END_HEADER                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This macro is used in association with @FT_BEGIN_HEADER in header  */
  /*    files to ensure that the declarations within are properly          */
  /*    encapsulated in an `extern "C" { .. }' block when included from a  */
  /*    C++ compiler.                                                      */
  /*                                                                       */
#ifdef __cplusplus
#define FT_END_HEADER  }
#else
#define FT_END_HEADER
#endif
  /*************************************************************************/
  /*                                                                       */
  /* Aliases for the FreeType 2 public and configuration files.            */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    header_file_macros                                                 */
  /*                                                                       */
  /* <Title>                                                               */
  /*    Header File Macros                                                 */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*    Macro definitions used to #include specific header files.          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The following macros are defined to the name of specific           */
  /*    FreeType~2 header files.  They can be used directly in #include    */
  /*    statements as in:                                                  */
  /*                                                                       */
  /*    {                                                                  */
  /*      #include FT_FREETYPE_H                                           */
  /*      #include FT_MULTIPLE_MASTERS_H                                   */
  /*      #include FT_GLYPH_H                                              */
  /*    }                                                                  */
  /*                                                                       */
  /*    There are several reasons why we are now using macros to name      */
  /*    public header files.  The first one is that such macros are not    */
  /*    limited to the infamous 8.3~naming rule required by DOS (and       */
  /*    `FT_MULTIPLE_MASTERS_H' is a lot more meaningful than `ftmm.h').   */
  /*                                                                       */
  /*    The second reason is that it allows for more flexibility in the    */
  /*    way FreeType~2 is installed on a given system.                     */
  /*                                                                       */
  /*************************************************************************/
  /* configuration files */
  /*************************************************************************
   *
   * @macro:
   *   FT_CONFIG_CONFIG_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing
   *   FreeType~2 configuration data.
   *
   */
#ifndef FT_CONFIG_CONFIG_H
#define FT_CONFIG_CONFIG_H  <freetype/config/ftconfig.h>
#endif
  /*************************************************************************
   *
   * @macro:
   *   FT_CONFIG_STANDARD_LIBRARY_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing
   *   FreeType~2 interface to the standard C library functions.
   *
   */
#ifndef FT_CONFIG_STANDARD_LIBRARY_H
#define FT_CONFIG_STANDARD_LIBRARY_H  <freetype/config/ftstdlib.h>
#endif
  /*************************************************************************
   *
   * @macro:
   *   FT_CONFIG_OPTIONS_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing
   *   FreeType~2 project-specific configuration options.
   *
   */
#ifndef FT_CONFIG_OPTIONS_H
#define FT_CONFIG_OPTIONS_H  <freetype/config/ftoption.h>
#endif
  /*************************************************************************
   *
   * @macro:
   *   FT_CONFIG_MODULES_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   list of FreeType~2 modules that are statically linked to new library
   *   instances in @FT_Init_FreeType.
   *
   */
#ifndef FT_CONFIG_MODULES_H
#define FT_CONFIG_MODULES_H  <freetype/config/ftmodule.h>
#endif
  /* */
  /* public headers */
  /*************************************************************************
   *
   * @macro:
   *   FT_FREETYPE_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   base FreeType~2 API.
   *
   */
#define FT_FREETYPE_H  <freetype/freetype.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_ERRORS_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   list of FreeType~2 error codes (and messages).
   *
   *   It is included by @FT_FREETYPE_H.
   *
   */
#define FT_ERRORS_H  <freetype/fterrors.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_MODULE_ERRORS_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   list of FreeType~2 module error offsets (and messages).
   *
   */
#define FT_MODULE_ERRORS_H  <freetype/ftmoderr.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_SYSTEM_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 interface to low-level operations (i.e., memory management
   *   and stream i/o).
   *
   *   It is included by @FT_FREETYPE_H.
   *
   */
#define FT_SYSTEM_H  <freetype/ftsystem.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_IMAGE_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing type
   *   definitions related to glyph images (i.e., bitmaps, outlines,
   *   scan-converter parameters).
   *
   *   It is included by @FT_FREETYPE_H.
   *
   */
#define FT_IMAGE_H  <freetype/ftimage.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_TYPES_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   basic data types defined by FreeType~2.
   *
   *   It is included by @FT_FREETYPE_H.
   *
   */
#define FT_TYPES_H  <freetype/fttypes.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_LIST_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   list management API of FreeType~2.
   *
   *   (Most applications will never need to include this file.)
   *
   */
#define FT_LIST_H  <freetype/ftlist.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_OUTLINE_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   scalable outline management API of FreeType~2.
   *
   */
#define FT_OUTLINE_H  <freetype/ftoutln.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_SIZES_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   API which manages multiple @FT_Size objects per face.
   *
   */
#define FT_SIZES_H  <freetype/ftsizes.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_MODULE_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   module management API of FreeType~2.
   *
   */
#define FT_MODULE_H  <freetype/ftmodapi.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_RENDER_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   renderer module management API of FreeType~2.
   *
   */
#define FT_RENDER_H  <freetype/ftrender.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_AUTOHINTER_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing
   *   structures and macros related to the auto-hinting module.
   *
   */
#define FT_AUTOHINTER_H  <freetype/ftautoh.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_CFF_DRIVER_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing
   *   structures and macros related to the CFF driver module.
   *
   */
#define FT_CFF_DRIVER_H  <freetype/ftcffdrv.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_TRUETYPE_DRIVER_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing
   *   structures and macros related to the TrueType driver module.
   *
   */
#define FT_TRUETYPE_DRIVER_H  <freetype/ftttdrv.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_PCF_DRIVER_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing
   *   structures and macros related to the PCF driver module.
   *
   */
#define FT_PCF_DRIVER_H  <freetype/ftpcfdrv.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_TYPE1_TABLES_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   types and API specific to the Type~1 format.
   *
   */
#define FT_TYPE1_TABLES_H  <freetype/t1tables.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_TRUETYPE_IDS_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   enumeration values which identify name strings, languages, encodings,
   *   etc.  This file really contains a _large_ set of constant macro
   *   definitions, taken from the TrueType and OpenType specifications.
   *
   */
#define FT_TRUETYPE_IDS_H  <freetype/ttnameid.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_TRUETYPE_TABLES_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   types and API specific to the TrueType (as well as OpenType) format.
   *
   */
#define FT_TRUETYPE_TABLES_H  <freetype/tttables.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_TRUETYPE_TAGS_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   definitions of TrueType four-byte `tags' which identify blocks in
   *   SFNT-based font formats (i.e., TrueType and OpenType).
   *
   */
#define FT_TRUETYPE_TAGS_H  <freetype/tttags.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_BDF_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   definitions of an API which accesses BDF-specific strings from a
   *   face.
   *
   */
#define FT_BDF_H  <freetype/ftbdf.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_CID_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   definitions of an API which access CID font information from a
   *   face.
   *
   */
#define FT_CID_H  <freetype/ftcid.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_GZIP_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   definitions of an API which supports gzip-compressed files.
   *
   */
#define FT_GZIP_H  <freetype/ftgzip.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_LZW_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   definitions of an API which supports LZW-compressed files.
   *
   */
#define FT_LZW_H  <freetype/ftlzw.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_BZIP2_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   definitions of an API which supports bzip2-compressed files.
   *
   */
#define FT_BZIP2_H  <freetype/ftbzip2.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_WINFONTS_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   definitions of an API which supports Windows FNT files.
   *
   */
#define FT_WINFONTS_H   <freetype/ftwinfnt.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_GLYPH_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   API of the optional glyph management component.
   *
   */
#define FT_GLYPH_H  <freetype/ftglyph.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_BITMAP_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   API of the optional bitmap conversion component.
   *
   */
#define FT_BITMAP_H  <freetype/ftbitmap.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_BBOX_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   API of the optional exact bounding box computation routines.
   *
   */
#define FT_BBOX_H  <freetype/ftbbox.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_CACHE_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   API of the optional FreeType~2 cache sub-system.
   *
   */
#define FT_CACHE_H  <freetype/ftcache.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_CACHE_IMAGE_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   `glyph image' API of the FreeType~2 cache sub-system.
   *
   *   It is used to define a cache for @FT_Glyph elements.  You can also
   *   use the API defined in @FT_CACHE_SMALL_BITMAPS_H if you only need to
   *   store small glyph bitmaps, as it will use less memory.
   *
   *   This macro is deprecated.  Simply include @FT_CACHE_H to have all
   *   glyph image-related cache declarations.
   *
   */
#define FT_CACHE_IMAGE_H  FT_CACHE_H
  /*************************************************************************
   *
   * @macro:
   *   FT_CACHE_SMALL_BITMAPS_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   `small bitmaps' API of the FreeType~2 cache sub-system.
   *
   *   It is used to define a cache for small glyph bitmaps in a relatively
   *   memory-efficient way.  You can also use the API defined in
   *   @FT_CACHE_IMAGE_H if you want to cache arbitrary glyph images,
   *   including scalable outlines.
   *
   *   This macro is deprecated.  Simply include @FT_CACHE_H to have all
   *   small bitmaps-related cache declarations.
   *
   */
#define FT_CACHE_SMALL_BITMAPS_H  FT_CACHE_H
  /*************************************************************************
   *
   * @macro:
   *   FT_CACHE_CHARMAP_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   `charmap' API of the FreeType~2 cache sub-system.
   *
   *   This macro is deprecated.  Simply include @FT_CACHE_H to have all
   *   charmap-based cache declarations.
   *
   */
#define FT_CACHE_CHARMAP_H  FT_CACHE_H
  /*************************************************************************
   *
   * @macro:
   *   FT_MAC_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   Macintosh-specific FreeType~2 API.  The latter is used to access
   *   fonts embedded in resource forks.
   *
   *   This header file must be explicitly included by client applications
   *   compiled on the Mac (note that the base API still works though).
   *
   */
#define FT_MAC_H  <freetype/ftmac.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_MULTIPLE_MASTERS_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   optional multiple-masters management API of FreeType~2.
   *
   */
#define FT_MULTIPLE_MASTERS_H  <freetype/ftmm.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_SFNT_NAMES_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   optional FreeType~2 API which accesses embedded `name' strings in
   *   SFNT-based font formats (i.e., TrueType and OpenType).
   *
   */
#define FT_SFNT_NAMES_H  <freetype/ftsnames.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_OPENTYPE_VALIDATE_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   optional FreeType~2 API which validates OpenType tables (BASE, GDEF,
   *   GPOS, GSUB, JSTF).
   *
   */
#define FT_OPENTYPE_VALIDATE_H  <freetype/ftotval.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_GX_VALIDATE_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   optional FreeType~2 API which validates TrueTypeGX/AAT tables (feat,
   *   mort, morx, bsln, just, kern, opbd, trak, prop).
   *
   */
#define FT_GX_VALIDATE_H  <freetype/ftgxval.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_PFR_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 API which accesses PFR-specific data.
   *
   */
#define FT_PFR_H  <freetype/ftpfr.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_STROKER_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 API which provides functions to stroke outline paths.
   */
#define FT_STROKER_H  <freetype/ftstroke.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_SYNTHESIS_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 API which performs artificial obliquing and emboldening.
   */
#define FT_SYNTHESIS_H  <freetype/ftsynth.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_FONT_FORMATS_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 API which provides functions specific to font formats.
   */
#define FT_FONT_FORMATS_H  <freetype/ftfntfmt.h>
  /* deprecated */
#define FT_XFREE86_H  FT_FONT_FORMATS_H
  /*************************************************************************
   *
   * @macro:
   *   FT_TRIGONOMETRY_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 API which performs trigonometric computations (e.g.,
   *   cosines and arc tangents).
   */
#define FT_TRIGONOMETRY_H  <freetype/fttrigon.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_LCD_FILTER_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 API which performs color filtering for subpixel rendering.
   */
#define FT_LCD_FILTER_H  <freetype/ftlcdfil.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_UNPATENTED_HINTING_H
   *
   * @description:
   *   Deprecated.
   */
#define FT_UNPATENTED_HINTING_H  <freetype/ttunpat.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_INCREMENTAL_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 API which performs incremental glyph loading.
   */
#define FT_INCREMENTAL_H  <freetype/ftincrem.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_GASP_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 API which returns entries from the TrueType GASP table.
   */
#define FT_GASP_H  <freetype/ftgasp.h>
  /*************************************************************************
   *
   * @macro:
   *   FT_ADVANCES_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 API which returns individual and ranged glyph advances.
   */
#define FT_ADVANCES_H  <freetype/ftadvanc.h>
  /* */
#define FT_ERROR_DEFINITIONS_H  <freetype/fterrdef.h>
  /* The internals of the cache sub-system are no longer exposed.  We */
  /* default to FT_CACHE_H at the moment just in case, but we know of */
  /* no rogue client that uses them.                                  */
  /*                                                                  */
#define FT_CACHE_MANAGER_H           <freetype/ftcache.h>
#define FT_CACHE_INTERNAL_MRU_H      <freetype/ftcache.h>
#define FT_CACHE_INTERNAL_MANAGER_H  <freetype/ftcache.h>
#define FT_CACHE_INTERNAL_CACHE_H    <freetype/ftcache.h>
#define FT_CACHE_INTERNAL_GLYPH_H    <freetype/ftcache.h>
#define FT_CACHE_INTERNAL_IMAGE_H    <freetype/ftcache.h>
#define FT_CACHE_INTERNAL_SBITS_H    <freetype/ftcache.h>
#define FT_INCREMENTAL_H          <freetype/ftincrem.h>
#define FT_TRUETYPE_UNPATENTED_H  <freetype/ttunpat.h>
  /*
   * Include internal headers definitions from <internal/...>
   * only when building the library.
   */
#ifdef FT2_BUILD_LIBRARY
#define  FT_INTERNAL_INTERNAL_H  <freetype/internal/internal.h>
/***************************************************************************/
/*                                                                         */
/*  internal.h                                                             */
/*                                                                         */
/*    Internal header files (specification only).                          */
/*                                                                         */
/*  Copyright 1996-2017 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* This file is automatically included by `ft2build.h'.                  */
  /* Do not include it manually!                                           */
  /*                                                                       */
  /*************************************************************************/
#define FT_INTERNAL_OBJECTS_H             <freetype/internal/ftobjs.h>
#define FT_INTERNAL_PIC_H                 <freetype/internal/ftpic.h>
#define FT_INTERNAL_STREAM_H              <freetype/internal/ftstream.h>
#define FT_INTERNAL_MEMORY_H              <freetype/internal/ftmemory.h>
#define FT_INTERNAL_DEBUG_H               <freetype/internal/ftdebug.h>
#define FT_INTERNAL_CALC_H                <freetype/internal/ftcalc.h>
#define FT_INTERNAL_HASH_H                <freetype/internal/fthash.h>
#define FT_INTERNAL_DRIVER_H              <freetype/internal/ftdriver.h>
#define FT_INTERNAL_TRACE_H               <freetype/internal/fttrace.h>
#define FT_INTERNAL_GLYPH_LOADER_H        <freetype/internal/ftgloadr.h>
#define FT_INTERNAL_SFNT_H                <freetype/internal/sfnt.h>
#define FT_INTERNAL_SERVICE_H             <freetype/internal/ftserv.h>
#define FT_INTERNAL_RFORK_H               <freetype/internal/ftrfork.h>
#define FT_INTERNAL_VALIDATE_H            <freetype/internal/ftvalid.h>
#define FT_INTERNAL_TRUETYPE_TYPES_H      <freetype/internal/tttypes.h>
#define FT_INTERNAL_TYPE1_TYPES_H         <freetype/internal/t1types.h>
#define FT_INTERNAL_POSTSCRIPT_AUX_H      <freetype/internal/psaux.h>
#define FT_INTERNAL_POSTSCRIPT_HINTS_H    <freetype/internal/pshints.h>
#define FT_INTERNAL_AUTOHINT_H            <freetype/internal/autohint.h>
#if defined( _MSC_VER )
  /* We disable the warning `conditional expression is constant' here */
  /* in order to compile cleanly with the maximum level of warnings.  */
  /* In particular, the warning complains about stuff like `while(0)' */
  /* which is very useful in macro definitions.  There is no benefit  */
  /* in having it enabled.                                            */
#pragma warning( disable : 4127 )
#endif
/* END */
#endif
#endif
/* END */
#endif
/* END */
#ifdef FT_FREETYPE_H
/***************************************************************************/
/*                                                                         */
/*  freetype.h                                                             */
/*                                                                         */
/*    FreeType high-level API and common types (specification only).       */
/*                                                                         */
/*  Copyright 1996-2017 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
#ifndef FREETYPE_H_
#define FREETYPE_H_
#ifndef FT_FREETYPE_H
#error "`ft2build.h' hasn't been included yet!"
#error "Please always use macros to include FreeType header files."
#error "Example:"
#error "  #include <ft2build.h>"
#error "  #include FT_FREETYPE_H"
#endif
/***************************************************************************/
/*                                                                         */
/*  ftconfig.h                                                             */
/*                                                                         */
/*    ANSI-specific configuration file (specification only).               */
/*                                                                         */
/*  Copyright 1996-2017 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* This header file contains a number of macro definitions that are used */
  /* by the rest of the engine.  Most of the macros here are automatically */
  /* determined at compile time, and you should not need to change it to   */
  /* port FreeType, except to compile the library with a non-ANSI          */
  /* compiler.                                                             */
  /*                                                                       */
  /* Note however that if some specific modifications are needed, we       */
  /* advise you to place a modified copy in your build directory.          */
  /*                                                                       */
  /* The build directory is usually `builds/<system>', and contains        */
  /* system-specific files that are always included first when building    */
  /* the library.                                                          */
  /*                                                                       */
  /* This ANSI version should stay in `include/config/'.                   */
  /*                                                                       */
  /*************************************************************************/
#ifndef FTCONFIG_H_
#define FTCONFIG_H_
/***************************************************************************/
/*                                                                         */
/*  ftoption.h                                                             */
/*                                                                         */
/*    User-selectable configuration macros (specification only).           */
/*                                                                         */
/*  Copyright 1996-2017 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
#ifndef FTOPTION_H_
#define FTOPTION_H_
FT_BEGIN_HEADER
  /*************************************************************************/
  /*                                                                       */
  /*                 USER-SELECTABLE CONFIGURATION MACROS                  */
  /*                                                                       */
  /* This file contains the default configuration macro definitions for    */
  /* a standard build of the FreeType library.  There are three ways to    */
  /* use this file to build project-specific versions of the library:      */
  /*                                                                       */
  /*  - You can modify this file by hand, but this is not recommended in   */
  /*    cases where you would like to build several versions of the        */
  /*    library from a single source directory.                            */
  /*                                                                       */
  /*  - You can put a copy of this file in your build directory, more      */
  /*    precisely in `$BUILD/freetype/config/ftoption.h', where `$BUILD'   */
  /*    is the name of a directory that is included _before_ the FreeType  */
  /*    include path during compilation.                                   */
  /*                                                                       */
  /*    The default FreeType Makefiles and Jamfiles use the build          */
  /*    directory `builds/<system>' by default, but you can easily change  */
  /*    that for your own projects.                                        */
  /*                                                                       */
  /*  - Copy the file <ft2build.h> to `$BUILD/ft2build.h' and modify it    */
  /*    slightly to pre-define the macro FT_CONFIG_OPTIONS_H used to       */
  /*    locate this file during the build.  For example,                   */
  /*                                                                       */
  /*      #define FT_CONFIG_OPTIONS_H  <myftoptions.h>                     */
  /*      #include <freetype/config/ftheader.h>                            */
  /*                                                                       */
  /*    will use `$BUILD/myftoptions.h' instead of this file for macro     */
  /*    definitions.                                                       */
  /*                                                                       */
  /*    Note also that you can similarly pre-define the macro              */
  /*    FT_CONFIG_MODULES_H used to locate the file listing of the modules */
  /*    that are statically linked to the library at compile time.  By     */
  /*    default, this file is <freetype/config/ftmodule.h>.                */
  /*                                                                       */
  /* We highly recommend using the third method whenever possible.         */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /****                                                                 ****/
  /**** G E N E R A L   F R E E T Y P E   2   C O N F I G U R A T I O N ****/
  /****                                                                 ****/
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* If you enable this configuration option, FreeType recognizes an       */
  /* environment variable called `FREETYPE_PROPERTIES', which can be used  */
  /* to control the various font drivers and modules.  The controllable    */
  /* properties are listed in the section `Controlling FreeType Modules'   */
  /* in the reference's table of contents; currently there are properties  */
  /* for the auto-hinter (file `ftautoh.h'), CFF (file `ftcffdrv.h'),      */
  /* TrueType (file `ftttdrv.h'), and PCF (file `ftpcfdrv.h').             */
  /*                                                                       */
  /* `FREETYPE_PROPERTIES' has the following syntax form (broken here into */
  /* multiple lines for better readability).                               */
  /*                                                                       */
  /*   <optional whitespace>                                               */
  /*   <module-name1> ':'                                                  */
  /*   <property-name1> '=' <property-value1>                              */
  /*   <whitespace>                                                        */
  /*   <module-name2> ':'                                                  */
  /*   <property-name2> '=' <property-value2>                              */
  /*   ...                                                                 */
  /*                                                                       */
  /* Example:                                                              */
  /*                                                                       */
  /*   FREETYPE_PROPERTIES=truetype:interpreter-version=35 \               */
  /*                       cff:no-stem-darkening=1 \                       */
  /*                       autofitter:warping=1                            */
  /*                                                                       */
#define FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
  /*************************************************************************/
  /*                                                                       */
  /* Uncomment the line below if you want to activate sub-pixel rendering  */
  /* (a.k.a. LCD rendering, or ClearType) in this build of the library.    */
  /*                                                                       */
  /* Note that this feature is covered by several Microsoft patents        */
  /* and should not be activated in any default build of the library.      */
  /*                                                                       */
  /* This macro has no impact on the FreeType API, only on its             */
  /* _implementation_.  For example, using FT_RENDER_MODE_LCD when calling */
  /* FT_Render_Glyph still generates a bitmap that is 3 times wider than   */
  /* the original size in case this macro isn't defined; however, each     */
  /* triplet of subpixels has R=G=B.                                       */
  /*                                                                       */
  /* This is done to allow FreeType clients to run unmodified, forcing     */
  /* them to display normal gray-level anti-aliased glyphs.                */
  /*                                                                       */
/* #define FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
  /*************************************************************************/
  /*                                                                       */
  /* Many compilers provide a non-ANSI 64-bit data type that can be used   */
  /* by FreeType to speed up some computations.  However, this will create */
  /* some problems when compiling the library in strict ANSI mode.         */
  /*                                                                       */
  /* For this reason, the use of 64-bit integers is normally disabled when */
  /* the __STDC__ macro is defined.  You can however disable this by       */
  /* defining the macro FT_CONFIG_OPTION_FORCE_INT64 here.                 */
  /*                                                                       */
  /* For most compilers, this will only create compilation warnings when   */
  /* building the library.                                                 */
  /*                                                                       */
  /* ObNote: The compiler-specific 64-bit integers are detected in the     */
  /*         file `ftconfig.h' either statically or through the            */
  /*         `configure' script on supported platforms.                    */
  /*                                                                       */
#undef FT_CONFIG_OPTION_FORCE_INT64
  /*************************************************************************/
  /*                                                                       */
  /* If this macro is defined, do not try to use an assembler version of   */
  /* performance-critical functions (e.g. FT_MulFix).  You should only do  */
  /* that to verify that the assembler function works properly, or to      */
  /* execute benchmark tests of the various implementations.               */
/* #define FT_CONFIG_OPTION_NO_ASSEMBLER */
  /*************************************************************************/
  /*                                                                       */
  /* If this macro is defined, try to use an inlined assembler version of  */
  /* the `FT_MulFix' function, which is a `hotspot' when loading and       */
  /* hinting glyphs, and which should be executed as fast as possible.     */
  /*                                                                       */
  /* Note that if your compiler or CPU is not supported, this will default */
  /* to the standard and portable implementation found in `ftcalc.c'.      */
  /*                                                                       */
#define FT_CONFIG_OPTION_INLINE_MULFIX
  /*************************************************************************/
  /*                                                                       */
  /* LZW-compressed file support.                                          */
  /*                                                                       */
  /*   FreeType now handles font files that have been compressed with the  */
  /*   `compress' program.  This is mostly used to parse many of the PCF   */
  /*   files that come with various X11 distributions.  The implementation */
  /*   uses NetBSD's `zopen' to partially uncompress the file on the fly   */
  /*   (see src/lzw/ftgzip.c).                                             */
  /*                                                                       */
  /*   Define this macro if you want to enable this `feature'.             */
  /*                                                                       */
#define FT_CONFIG_OPTION_USE_LZW
  /*************************************************************************/
  /*                                                                       */
  /* Gzip-compressed file support.                                         */
  /*                                                                       */
  /*   FreeType now handles font files that have been compressed with the  */
  /*   `gzip' program.  This is mostly used to parse many of the PCF files */
  /*   that come with XFree86.  The implementation uses `zlib' to          */
  /*   partially uncompress the file on the fly (see src/gzip/ftgzip.c).   */
  /*                                                                       */
  /*   Define this macro if you want to enable this `feature'.  See also   */
  /*   the macro FT_CONFIG_OPTION_SYSTEM_ZLIB below.                       */
  /*                                                                       */
#define FT_CONFIG_OPTION_USE_ZLIB
  /*************************************************************************/
  /*                                                                       */
  /* ZLib library selection                                                */
  /*                                                                       */
  /*   This macro is only used when FT_CONFIG_OPTION_USE_ZLIB is defined.  */
  /*   It allows FreeType's `ftgzip' component to link to the system's     */
  /*   installation of the ZLib library.  This is useful on systems like   */
  /*   Unix or VMS where it generally is already available.                */
  /*                                                                       */
  /*   If you let it undefined, the component will use its own copy        */
  /*   of the zlib sources instead.  These have been modified to be        */
  /*   included directly within the component and *not* export external    */
  /*   function names.  This allows you to link any program with FreeType  */
  /*   _and_ ZLib without linking conflicts.                               */
  /*                                                                       */
  /*   Do not #undef this macro here since the build system might define   */
  /*   it for certain configurations only.                                 */
  /*                                                                       */
/* #define FT_CONFIG_OPTION_SYSTEM_ZLIB */
  /*************************************************************************/
  /*                                                                       */
  /* Bzip2-compressed file support.                                        */
  /*                                                                       */
  /*   FreeType now handles font files that have been compressed with the  */
  /*   `bzip2' program.  This is mostly used to parse many of the PCF      */
  /*   files that come with XFree86.  The implementation uses `libbz2' to  */
  /*   partially uncompress the file on the fly (see src/bzip2/ftbzip2.c). */
  /*   Contrary to gzip, bzip2 currently is not included and need to use   */
  /*   the system available bzip2 implementation.                          */
  /*                                                                       */
  /*   Define this macro if you want to enable this `feature'.             */
  /*                                                                       */
/* #define FT_CONFIG_OPTION_USE_BZIP2 */
  /*************************************************************************/
  /*                                                                       */
  /* Define to disable the use of file stream functions and types, FILE,   */
  /* fopen() etc.  Enables the use of smaller system libraries on embedded */
  /* systems that have multiple system libraries, some with or without     */
  /* file stream support, in the cases where file stream support is not    */
  /* necessary such as memory loading of font files.                       */
  /*                                                                       */
/* #define FT_CONFIG_OPTION_DISABLE_STREAM_SUPPORT */
  /*************************************************************************/
  /*                                                                       */
  /* PNG bitmap support.                                                   */
  /*                                                                       */
  /*   FreeType now handles loading color bitmap glyphs in the PNG format. */
  /*   This requires help from the external libpng library.  Uncompressed  */
  /*   color bitmaps do not need any external libraries and will be        */
  /*   supported regardless of this configuration.                         */
  /*                                                                       */
  /*   Define this macro if you want to enable this `feature'.             */
  /*                                                                       */
/* #define FT_CONFIG_OPTION_USE_PNG */
  /*************************************************************************/
  /*                                                                       */
  /* HarfBuzz support.                                                     */
  /*                                                                       */
  /*   FreeType uses the HarfBuzz library to improve auto-hinting of       */
  /*   OpenType fonts.  If available, many glyphs not directly addressable */
  /*   by a font's character map will be hinted also.                      */
  /*                                                                       */
  /*   Define this macro if you want to enable this `feature'.             */
  /*                                                                       */
/* #define FT_CONFIG_OPTION_USE_HARFBUZZ */
  /*************************************************************************/
  /*                                                                       */
  /* DLL export compilation                                                */
  /*                                                                       */
  /*   When compiling FreeType as a DLL, some systems/compilers need a     */
  /*   special keyword in front OR after the return type of function       */
  /*   declarations.                                                       */
  /*                                                                       */
  /*   Two macros are used within the FreeType source code to define       */
  /*   exported library functions: FT_EXPORT and FT_EXPORT_DEF.            */
  /*                                                                       */
  /*     FT_EXPORT( return_type )                                          */
  /*                                                                       */
  /*       is used in a function declaration, as in                        */
  /*                                                                       */
  /*         FT_EXPORT( FT_Error )                                         */
  /*         FT_Init_FreeType( FT_Library*  alibrary );                    */
  /*                                                                       */
  /*                                                                       */
  /*     FT_EXPORT_DEF( return_type )                                      */
  /*                                                                       */
  /*       is used in a function definition, as in                         */
  /*                                                                       */
  /*         FT_EXPORT_DEF( FT_Error )                                     */
  /*         FT_Init_FreeType( FT_Library*  alibrary )                     */
  /*         {                                                             */
  /*           ... some code ...                                           */
  /*           return FT_Err_Ok;                                           */
  /*         }                                                             */
  /*                                                                       */
  /*   You can provide your own implementation of FT_EXPORT and            */
  /*   FT_EXPORT_DEF here if you want.  If you leave them undefined, they  */
  /*   will be later automatically defined as `extern return_type' to      */
  /*   allow normal compilation.                                           */
  /*                                                                       */
  /*   Do not #undef these macros here since the build system might define */
  /*   them for certain configurations only.                               */
  /*                                                                       */
/* #define FT_EXPORT(x)      extern x */
/* #define FT_EXPORT_DEF(x)  x */
  /*************************************************************************/
  /*                                                                       */
  /* Glyph Postscript Names handling                                       */
  /*                                                                       */
  /*   By default, FreeType 2 is compiled with the `psnames' module.  This */
  /*   module is in charge of converting a glyph name string into a        */
  /*   Unicode value, or return a Macintosh standard glyph name for the    */
  /*   use with the TrueType `post' table.                                 */
  /*                                                                       */
  /*   Undefine this macro if you do not want `psnames' compiled in your   */
  /*   build of FreeType.  This has the following effects:                 */
  /*                                                                       */
  /*   - The TrueType driver will provide its own set of glyph names,      */
  /*     if you build it to support postscript names in the TrueType       */
  /*     `post' table.                                                     */
  /*                                                                       */
  /*   - The Type 1 driver will not be able to synthesize a Unicode        */
  /*     charmap out of the glyphs found in the fonts.                     */
  /*                                                                       */
  /*   You would normally undefine this configuration macro when building  */
  /*   a version of FreeType that doesn't contain a Type 1 or CFF driver.  */
  /*                                                                       */
#define FT_CONFIG_OPTION_POSTSCRIPT_NAMES
  /*************************************************************************/
  /*                                                                       */
  /* Postscript Names to Unicode Values support                            */
  /*                                                                       */
  /*   By default, FreeType 2 is built with the `PSNames' module compiled  */
  /*   in.  Among other things, the module is used to convert a glyph name */
  /*   into a Unicode value.  This is especially useful in order to        */
  /*   synthesize on the fly a Unicode charmap from the CFF/Type 1 driver  */
  /*   through a big table named the `Adobe Glyph List' (AGL).             */
  /*                                                                       */
  /*   Undefine this macro if you do not want the Adobe Glyph List         */
  /*   compiled in your `PSNames' module.  The Type 1 driver will not be   */
  /*   able to synthesize a Unicode charmap out of the glyphs found in the */
  /*   fonts.                                                              */
  /*                                                                       */
#define FT_CONFIG_OPTION_ADOBE_GLYPH_LIST
  /*************************************************************************/
  /*                                                                       */
  /* Support for Mac fonts                                                 */
  /*                                                                       */
  /*   Define this macro if you want support for outline fonts in Mac      */
  /*   format (mac dfont, mac resource, macbinary containing a mac         */
  /*   resource) on non-Mac platforms.                                     */
  /*                                                                       */
  /*   Note that the `FOND' resource isn't checked.                        */
  /*                                                                       */
#define FT_CONFIG_OPTION_MAC_FONTS
  /*************************************************************************/
  /*                                                                       */
  /* Guessing methods to access embedded resource forks                    */
  /*                                                                       */
  /*   Enable extra Mac fonts support on non-Mac platforms (e.g.           */
  /*   GNU/Linux).                                                         */
  /*                                                                       */
  /*   Resource forks which include fonts data are stored sometimes in     */
  /*   locations which users or developers don't expected.  In some cases, */
  /*   resource forks start with some offset from the head of a file.  In  */
  /*   other cases, the actual resource fork is stored in file different   */
  /*   from what the user specifies.  If this option is activated,         */
  /*   FreeType tries to guess whether such offsets or different file      */
  /*   names must be used.                                                 */
  /*                                                                       */
  /*   Note that normal, direct access of resource forks is controlled via */
  /*   the FT_CONFIG_OPTION_MAC_FONTS option.                              */
  /*                                                                       */
#ifdef FT_CONFIG_OPTION_MAC_FONTS
#define FT_CONFIG_OPTION_GUESSING_EMBEDDED_RFORK
#endif
  /*************************************************************************/
  /*                                                                       */
  /* Allow the use of FT_Incremental_Interface to load typefaces that      */
  /* contain no glyph data, but supply it via a callback function.         */
  /* This is required by clients supporting document formats which         */
  /* supply font data incrementally as the document is parsed, such        */
  /* as the Ghostscript interpreter for the PostScript language.           */
  /*                                                                       */
#define FT_CONFIG_OPTION_INCREMENTAL
  /*************************************************************************/
  /*                                                                       */
  /* The size in bytes of the render pool used by the scan-line converter  */
  /* to do all of its work.                                                */
  /*                                                                       */
#define FT_RENDER_POOL_SIZE  16384L
  /*************************************************************************/
  /*                                                                       */
  /* FT_MAX_MODULES                                                        */
  /*                                                                       */
  /*   The maximum number of modules that can be registered in a single    */
  /*   FreeType library object.  32 is the default.                        */
  /*                                                                       */
#define FT_MAX_MODULES  32
  /*************************************************************************/
  /*                                                                       */
  /* Debug level                                                           */
  /*                                                                       */
  /*   FreeType can be compiled in debug or trace mode.  In debug mode,    */
  /*   errors are reported through the `ftdebug' component.  In trace      */
  /*   mode, additional messages are sent to the standard output during    */
  /*   execution.                                                          */
  /*                                                                       */
  /*   Define FT_DEBUG_LEVEL_ERROR to build the library in debug mode.     */
  /*   Define FT_DEBUG_LEVEL_TRACE to build it in trace mode.              */
  /*                                                                       */
  /*   Don't define any of these macros to compile in `release' mode!      */
  /*                                                                       */
  /*   Do not #undef these macros here since the build system might define */
  /*   them for certain configurations only.                               */
  /*                                                                       */
/* #define FT_DEBUG_LEVEL_ERROR */
/* #define FT_DEBUG_LEVEL_TRACE */
  /*************************************************************************/
  /*                                                                       */
  /* Autofitter debugging                                                  */
  /*                                                                       */
  /*   If FT_DEBUG_AUTOFIT is defined, FreeType provides some means to     */
  /*   control the autofitter behaviour for debugging purposes with global */
  /*   boolean variables (consequently, you should *never* enable this     */
  /*   while compiling in `release' mode):                                 */
  /*                                                                       */
  /*     _af_debug_disable_horz_hints                                      */
  /*     _af_debug_disable_vert_hints                                      */
  /*     _af_debug_disable_blue_hints                                      */
  /*                                                                       */
  /*   Additionally, the following functions provide dumps of various      */
  /*   internal autofit structures to stdout (using `printf'):             */
  /*                                                                       */
  /*     af_glyph_hints_dump_points                                        */
  /*     af_glyph_hints_dump_segments                                      */
  /*     af_glyph_hints_dump_edges                                         */
  /*     af_glyph_hints_get_num_segments                                   */
  /*     af_glyph_hints_get_segment_offset                                 */
  /*                                                                       */
  /*   As an argument, they use another global variable:                   */
  /*                                                                       */
  /*     _af_debug_hints                                                   */
  /*                                                                       */
  /*   Please have a look at the `ftgrid' demo program to see how those    */
  /*   variables and macros should be used.                                */
  /*                                                                       */
  /*   Do not #undef these macros here since the build system might define */
  /*   them for certain configurations only.                               */
  /*                                                                       */
/* #define FT_DEBUG_AUTOFIT */
  /*************************************************************************/
  /*                                                                       */
  /* Memory Debugging                                                      */
  /*                                                                       */
  /*   FreeType now comes with an integrated memory debugger that is       */
  /*   capable of detecting simple errors like memory leaks or double      */
  /*   deletes.  To compile it within your build of the library, you       */
  /*   should define FT_DEBUG_MEMORY here.                                 */
  /*                                                                       */
  /*   Note that the memory debugger is only activated at runtime when     */
  /*   when the _environment_ variable `FT2_DEBUG_MEMORY' is defined also! */
  /*                                                                       */
  /*   Do not #undef this macro here since the build system might define   */
  /*   it for certain configurations only.                                 */
  /*                                                                       */
/* #define FT_DEBUG_MEMORY */
  /*************************************************************************/
  /*                                                                       */
  /* Module errors                                                         */
  /*                                                                       */
  /*   If this macro is set (which is _not_ the default), the higher byte  */
  /*   of an error code gives the module in which the error has occurred,  */
  /*   while the lower byte is the real error code.                        */
  /*                                                                       */
  /*   Setting this macro makes sense for debugging purposes only, since   */
  /*   it would break source compatibility of certain programs that use    */
  /*   FreeType 2.                                                         */
  /*                                                                       */
  /*   More details can be found in the files ftmoderr.h and fterrors.h.   */
  /*                                                                       */
#undef FT_CONFIG_OPTION_USE_MODULE_ERRORS
  /*************************************************************************/
  /*                                                                       */
  /* Position Independent Code                                             */
  /*                                                                       */
  /*   If this macro is set (which is _not_ the default), FreeType2 will   */
  /*   avoid creating constants that require address fixups.  Instead the  */
  /*   constants will be moved into a struct and additional intialization  */
  /*   code will be used.                                                  */
  /*                                                                       */
  /*   Setting this macro is needed for systems that prohibit address      */
  /*   fixups, such as BREW.  [Note that standard compilers like gcc or    */
  /*   clang handle PIC generation automatically; you don't have to set    */
  /*   FT_CONFIG_OPTION_PIC, which is only necessary for very special      */
  /*   compilers.]                                                         */
  /*                                                                       */
  /*   Note that FT_CONFIG_OPTION_PIC support is not available for all     */
  /*   modules (see `modules.cfg' for a complete list).  For building with */
  /*   FT_CONFIG_OPTION_PIC support, do the following.                     */
  /*                                                                       */
  /*     0. Clone the repository.                                          */
  /*     1. Define FT_CONFIG_OPTION_PIC.                                   */
  /*     2. Remove all subdirectories in `src' that don't have             */
  /*        FT_CONFIG_OPTION_PIC support.                                  */
  /*     3. Comment out the corresponding modules in `modules.cfg'.        */
  /*     4. Compile.                                                       */
  /*                                                                       */
/* #define FT_CONFIG_OPTION_PIC */
  /*************************************************************************/
  /*************************************************************************/
  /****                                                                 ****/
  /****        S F N T   D R I V E R    C O N F I G U R A T I O N       ****/
  /****                                                                 ****/
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* Define TT_CONFIG_OPTION_EMBEDDED_BITMAPS if you want to support       */
  /* embedded bitmaps in all formats using the SFNT module (namely         */
  /* TrueType & OpenType).                                                 */
  /*                                                                       */
#define TT_CONFIG_OPTION_EMBEDDED_BITMAPS
  /*************************************************************************/
  /*                                                                       */
  /* Define TT_CONFIG_OPTION_POSTSCRIPT_NAMES if you want to be able to    */
  /* load and enumerate the glyph Postscript names in a TrueType or        */
  /* OpenType file.                                                        */
  /*                                                                       */
  /* Note that when you do not compile the `PSNames' module by undefining  */
  /* the above FT_CONFIG_OPTION_POSTSCRIPT_NAMES, the `sfnt' module will   */
  /* contain additional code used to read the PS Names table from a font.  */
  /*                                                                       */
  /* (By default, the module uses `PSNames' to extract glyph names.)       */
  /*                                                                       */
#define TT_CONFIG_OPTION_POSTSCRIPT_NAMES
  /*************************************************************************/
  /*                                                                       */
  /* Define TT_CONFIG_OPTION_SFNT_NAMES if your applications need to       */
  /* access the internal name table in a SFNT-based format like TrueType   */
  /* or OpenType.  The name table contains various strings used to         */
  /* describe the font, like family name, copyright, version, etc.  It     */
  /* does not contain any glyph name though.                               */
  /*                                                                       */
  /* Accessing SFNT names is done through the functions declared in        */
  /* `ftsnames.h'.                                                         */
  /*                                                                       */
#define TT_CONFIG_OPTION_SFNT_NAMES
  /*************************************************************************/
  /*                                                                       */
  /* TrueType CMap support                                                 */
  /*                                                                       */
  /*   Here you can fine-tune which TrueType CMap table format shall be    */
  /*   supported.                                                          */
#define TT_CONFIG_CMAP_FORMAT_0
#define TT_CONFIG_CMAP_FORMAT_2
#define TT_CONFIG_CMAP_FORMAT_4
#define TT_CONFIG_CMAP_FORMAT_6
#define TT_CONFIG_CMAP_FORMAT_8
#define TT_CONFIG_CMAP_FORMAT_10
#define TT_CONFIG_CMAP_FORMAT_12
#define TT_CONFIG_CMAP_FORMAT_13
#define TT_CONFIG_CMAP_FORMAT_14
  /*************************************************************************/
  /*************************************************************************/
  /****                                                                 ****/
  /****    T R U E T Y P E   D R I V E R    C O N F I G U R A T I O N   ****/
  /****                                                                 ****/
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* Define TT_CONFIG_OPTION_BYTECODE_INTERPRETER if you want to compile   */
  /* a bytecode interpreter in the TrueType driver.                        */
  /*                                                                       */
  /* By undefining this, you will only compile the code necessary to load  */
  /* TrueType glyphs without hinting.                                      */
  /*                                                                       */
  /*   Do not #undef this macro here, since the build system might         */
  /*   define it for certain configurations only.                          */
  /*                                                                       */
#define TT_CONFIG_OPTION_BYTECODE_INTERPRETER
  /*************************************************************************/
  /*                                                                       */
  /* Define TT_CONFIG_OPTION_SUBPIXEL_HINTING if you want to compile       */
  /* subpixel hinting support into the TrueType driver.  This modifies the */
  /* TrueType hinting mechanism when anything but FT_RENDER_MODE_MONO is   */
  /* requested.                                                            */
  /*                                                                       */
  /* In particular, it modifies the bytecode interpreter to interpret (or  */
  /* not) instructions in a certain way so that all TrueType fonts look    */
  /* like they do in a Windows ClearType (DirectWrite) environment.  See   */
  /* [1] for a technical overview on what this means.  See `ttinterp.h'    */
  /* for more details on the LEAN option.                                  */
  /*                                                                       */
  /* There are three possible values.                                      */
  /*                                                                       */
  /* Value 1:                                                              */
  /*    This value is associated with the `Infinality' moniker,            */
  /*    contributed by an individual nicknamed Infinality with the goal of */
  /*    making TrueType fonts render better than on Windows.  A high       */
  /*    amount of configurability and flexibility, down to rules for       */
  /*    single glyphs in fonts, but also very slow.  Its experimental and  */
  /*    slow nature and the original developer losing interest meant that  */
  /*    this option was never enabled in default builds.                   */
  /*                                                                       */
  /*    The corresponding interpreter version is v38.                      */
  /*                                                                       */
  /* Value 2:                                                              */
  /*    The new default mode for the TrueType driver.  The Infinality code */
  /*    base was stripped to the bare minimum and all configurability      */
  /*    removed in the name of speed and simplicity.  The configurability  */
  /*    was mainly aimed at legacy fonts like Arial, Times New Roman, or   */
  /*    Courier.  Legacy fonts are fonts that modify vertical stems to     */
  /*    achieve clean black-and-white bitmaps.  The new mode focuses on    */
  /*    applying a minimal set of rules to all fonts indiscriminately so   */
  /*    that modern and web fonts render well while legacy fonts render    */
  /*    okay.                                                              */
  /*                                                                       */
  /*    The corresponding interpreter version is v40.                      */
  /*                                                                       */
  /* Value 3:                                                              */
  /*    Compile both, making both v38 and v40 available (the latter is the */
  /*    default).                                                          */
  /*                                                                       */
  /* By undefining these, you get rendering behavior like on Windows       */
  /* without ClearType, i.e., Windows XP without ClearType enabled and     */
  /* Win9x (interpreter version v35).  Or not, depending on how much       */
  /* hinting blood and testing tears the font designer put into a given    */
  /* font.  If you define one or both subpixel hinting options, you can    */
  /* switch between between v35 and the ones you define (using             */
  /* `FT_Property_Set').                                                   */
  /*                                                                       */
  /* This option requires TT_CONFIG_OPTION_BYTECODE_INTERPRETER to be      */
  /* defined.                                                              */
  /*                                                                       */
  /* [1] http://www.microsoft.com/typography/cleartype/truetypecleartype.aspx */
  /*                                                                       */
/* #define TT_CONFIG_OPTION_SUBPIXEL_HINTING  1         */
#define TT_CONFIG_OPTION_SUBPIXEL_HINTING  2
/* #define TT_CONFIG_OPTION_SUBPIXEL_HINTING  ( 1 | 2 ) */
  /*************************************************************************/
  /*                                                                       */
  /* Define TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED to compile the        */
  /* TrueType glyph loader to use Apple's definition of how to handle      */
  /* component offsets in composite glyphs.                                */
  /*                                                                       */
  /* Apple and MS disagree on the default behavior of component offsets    */
  /* in composites.  Apple says that they should be scaled by the scaling  */
  /* factors in the transformation matrix (roughly, it's more complex)     */
  /* while MS says they should not.  OpenType defines two bits in the      */
  /* composite flags array which can be used to disambiguate, but old      */
  /* fonts will not have them.                                             */
  /*                                                                       */
  /*   http://www.microsoft.com/typography/otspec/glyf.htm                 */
  /*   https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6glyf.html */
  /*                                                                       */
#undef TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED
  /*************************************************************************/
  /*                                                                       */
  /* Define TT_CONFIG_OPTION_GX_VAR_SUPPORT if you want to include         */
  /* support for Apple's distortable font technology (fvar, gvar, cvar,    */
  /* and avar tables).  This has many similarities to Type 1 Multiple      */
  /* Masters support.                                                      */
  /*                                                                       */
#define TT_CONFIG_OPTION_GX_VAR_SUPPORT
  /*************************************************************************/
  /*                                                                       */
  /* Define TT_CONFIG_OPTION_BDF if you want to include support for        */
  /* an embedded `BDF ' table within SFNT-based bitmap formats.            */
  /*                                                                       */
#define TT_CONFIG_OPTION_BDF
  /*************************************************************************/
  /*                                                                       */
  /* Option TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES controls the maximum     */
  /* number of bytecode instructions executed for a single run of the      */
  /* bytecode interpreter, needed to prevent infinite loops.  You don't    */
  /* want to change this except for very special situations (e.g., making  */
  /* a library fuzzer spend less time to handle broken fonts).             */
  /*                                                                       */
  /* It is not expected that this value is ever modified by a configuring  */
  /* script; instead, it gets surrounded with #ifndef ... #endif so that   */
  /* the value can be set as a preprocessor option on the compiler's       */
  /* command line.                                                         */
  /*                                                                       */
#ifndef TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES
#define TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES  1000000L
#endif
  /*************************************************************************/
  /*************************************************************************/
  /****                                                                 ****/
  /****      T Y P E 1   D R I V E R    C O N F I G U R A T I O N       ****/
  /****                                                                 ****/
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* T1_MAX_DICT_DEPTH is the maximum depth of nest dictionaries and       */
  /* arrays in the Type 1 stream (see t1load.c).  A minimum of 4 is        */
  /* required.                                                             */
  /*                                                                       */
#define T1_MAX_DICT_DEPTH  5
  /*************************************************************************/
  /*                                                                       */
  /* T1_MAX_SUBRS_CALLS details the maximum number of nested sub-routine   */
  /* calls during glyph loading.                                           */
  /*                                                                       */
#define T1_MAX_SUBRS_CALLS  16
  /*************************************************************************/
  /*                                                                       */
  /* T1_MAX_CHARSTRING_OPERANDS is the charstring stack's capacity.  A     */
  /* minimum of 16 is required.                                            */
  /*                                                                       */
  /* The Chinese font MingTiEG-Medium (CNS 11643 character set) needs 256. */
  /*                                                                       */
#define T1_MAX_CHARSTRINGS_OPERANDS  256
  /*************************************************************************/
  /*                                                                       */
  /* Define this configuration macro if you want to prevent the            */
  /* compilation of `t1afm', which is in charge of reading Type 1 AFM      */
  /* files into an existing face.  Note that if set, the T1 driver will be */
  /* unable to produce kerning distances.                                  */
  /*                                                                       */
#undef T1_CONFIG_OPTION_NO_AFM
  /*************************************************************************/
  /*                                                                       */
  /* Define this configuration macro if you want to prevent the            */
  /* compilation of the Multiple Masters font support in the Type 1        */
  /* driver.                                                               */
  /*                                                                       */
#undef T1_CONFIG_OPTION_NO_MM_SUPPORT
  /*************************************************************************/
  /*************************************************************************/
  /****                                                                 ****/
  /****         C F F   D R I V E R    C O N F I G U R A T I O N        ****/
  /****                                                                 ****/
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* Using CFF_CONFIG_OPTION_DARKENING_PARAMETER_{X,Y}{1,2,3,4} it is      */
  /* possible to set up the default values of the four control points that */
  /* define the stem darkening behaviour of the (new) CFF engine.  For     */
  /* more details please read the documentation of the                     */
  /* `darkening-parameters' property of the cff driver module (file        */
  /* `ftcffdrv.h'), which allows the control at run-time.                  */
  /*                                                                       */
  /* Do *not* undefine these macros!                                       */
  /*                                                                       */
#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1   500
#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1   400
#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2  1000
#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2   275
#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3  1667
#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3   275
#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4  2333
#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4     0
  /*************************************************************************/
  /*                                                                       */
  /* CFF_CONFIG_OPTION_OLD_ENGINE controls whether the pre-Adobe CFF       */
  /* engine gets compiled into FreeType.  If defined, it is possible to    */
  /* switch between the two engines using the `hinting-engine' property of */
  /* the cff driver module.                                                */
  /*                                                                       */
/* #define CFF_CONFIG_OPTION_OLD_ENGINE */
  /*************************************************************************/
  /*************************************************************************/
  /****                                                                 ****/
  /****         P C F   D R I V E R    C O N F I G U R A T I O N        ****/
  /****                                                                 ****/
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* There are many PCF fonts just called `Fixed' which look completely    */
  /* different, and which have nothing to do with each other.  When        */
  /* selecting `Fixed' in KDE or Gnome one gets results that appear rather */
  /* random, the style changes often if one changes the size and one       */
  /* cannot select some fonts at all.  This option makes the PCF module    */
  /* prepend the foundry name (plus a space) to the family name.           */
  /*                                                                       */
  /* We also check whether we have `wide' characters; all put together, we */
  /* get family names like `Sony Fixed' or `Misc Fixed Wide'.              */
  /*                                                                       */
  /* If this option is activated, it can be controlled with the            */
  /* `no-long-family-names' property of the pcf driver module.             */
  /*                                                                       */
/* #define PCF_CONFIG_OPTION_LONG_FAMILY_NAMES */
  /*************************************************************************/
  /*************************************************************************/
  /****                                                                 ****/
  /****    A U T O F I T   M O D U L E    C O N F I G U R A T I O N     ****/
  /****                                                                 ****/
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* Compile autofit module with CJK (Chinese, Japanese, Korean) script    */
  /* support.                                                              */
  /*                                                                       */
#define AF_CONFIG_OPTION_CJK
  /*************************************************************************/
  /*                                                                       */
  /* Compile autofit module with fallback Indic script support, covering   */
  /* some scripts that the `latin' submodule of the autofit module doesn't */
  /* (yet) handle.                                                         */
  /*                                                                       */
#define AF_CONFIG_OPTION_INDIC
  /*************************************************************************/
  /*                                                                       */
  /* Compile autofit module with warp hinting.  The idea of the warping    */
  /* code is to slightly scale and shift a glyph within a single dimension */
  /* so that as much of its segments are aligned (more or less) on the     */
  /* grid.  To find out the optimal scaling and shifting value, various    */
  /* parameter combinations are tried and scored.                          */
  /*                                                                       */
  /* This experimental option is active only if the rendering mode is      */
  /* FT_RENDER_MODE_LIGHT; you can switch warping on and off with the      */
  /* `warping' property of the auto-hinter (see file `ftautoh.h' for more  */
  /* information; by default it is switched off).                          */
  /*                                                                       */
#define AF_CONFIG_OPTION_USE_WARPER
  /*************************************************************************/
  /*                                                                       */
  /* Use TrueType-like size metrics for `light' auto-hinting.              */
  /*                                                                       */
  /* It is strongly recommended to avoid this option, which exists only to */
  /* help some legacy applications retain its appearance and behaviour     */
  /* with respect to auto-hinted TrueType fonts.                           */
  /*                                                                       */
  /* The very reason this option exists at all are GNU/Linux distributions */
  /* like Fedora that did not un-patch the following change (which was     */
  /* present in FreeType between versions 2.4.6 and 2.7.1, inclusive).     */
  /*                                                                       */
  /*   2011-07-16  Steven Chu  <steven.f.chu@gmail.com>                    */
  /*                                                                       */
  /*     [truetype] Fix metrics on size request for scalable fonts.        */
  /*                                                                       */
  /* This problematic commit is now reverted (more or less).               */
  /*                                                                       */
/* #define AF_CONFIG_OPTION_TT_SIZE_METRICS */
  /* */
  /*
   * This macro is obsolete.  Support has been removed in FreeType
   * version 2.5.
   */
/* #define FT_CONFIG_OPTION_OLD_INTERNALS */
  /*
   * This macro is defined if native TrueType hinting is requested by the
   * definitions above.
   */
#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
#define  TT_USE_BYTECODE_INTERPRETER
#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
#if TT_CONFIG_OPTION_SUBPIXEL_HINTING & 1
#define  TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
#endif
#if TT_CONFIG_OPTION_SUBPIXEL_HINTING & 2
#define  TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
#endif
#endif
#endif
  /*
   * Check CFF darkening parameters.  The checks are the same as in function
   * `cff_property_set' in file `cffdrivr.c'.
   */
#if CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1 < 0   ||     CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2 < 0   ||     CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3 < 0   ||     CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4 < 0   ||                                                           CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1 < 0   ||     CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2 < 0   ||     CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3 < 0   ||     CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4 < 0   ||                                                           CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1 >              CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2     ||     CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2 >              CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3     ||     CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3 >              CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4     ||                                                           CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1 > 500 ||     CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2 > 500 ||     CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3 > 500 ||     CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4 > 500
#error "Invalid CFF darkening parameters!"
#endif
FT_END_HEADER
#endif
/* END */
/***************************************************************************/
/*                                                                         */
/*  ftstdlib.h                                                             */
/*                                                                         */
/*    ANSI-specific library and header configuration file (specification   */
/*    only).                                                               */
/*                                                                         */
/*  Copyright 2002-2017 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* This file is used to group all #includes to the ANSI C library that   */
  /* FreeType normally requires.  It also defines macros to rename the     */
  /* standard functions within the FreeType source code.                   */
  /*                                                                       */
  /* Load a file which defines FTSTDLIB_H_ before this one to override it. */
  /*                                                                       */
  /*************************************************************************/
#ifndef FTSTDLIB_H_
#define FTSTDLIB_H_
#define ft_ptrdiff_t  ptrdiff_t
  /**********************************************************************/
  /*                                                                    */
  /*                           integer limits                           */
  /*                                                                    */
  /* UINT_MAX and ULONG_MAX are used to automatically compute the size  */
  /* of `int' and `long' in bytes at compile-time.  So far, this works  */
  /* for all platforms the library has been tested on.                  */
  /*                                                                    */
  /* Note that on the extremely rare platforms that do not provide      */
  /* integer types that are _exactly_ 16 and 32 bits wide (e.g. some    */
  /* old Crays where `int' is 36 bits), we do not make any guarantee    */
  /* about the correct behaviour of FT2 with all fonts.                 */
  /*                                                                    */
  /* In these case, `ftconfig.h' will refuse to compile anyway with a   */
  /* message like `couldn't find 32-bit type' or something similar.     */
  /*                                                                    */
  /**********************************************************************/
#define FT_CHAR_BIT    CHAR_BIT
#define FT_USHORT_MAX  USHRT_MAX
#define FT_INT_MAX     INT_MAX
#define FT_INT_MIN     INT_MIN
#define FT_UINT_MAX    UINT_MAX
#define FT_LONG_MIN    LONG_MIN
#define FT_LONG_MAX    LONG_MAX
#define FT_ULONG_MAX   ULONG_MAX
  /**********************************************************************/
  /*                                                                    */
  /*                 character and string processing                    */
  /*                                                                    */
  /**********************************************************************/
#define ft_memchr   memchr
#define ft_memcmp   memcmp
#define ft_memcpy   memcpy
#define ft_memmove  memmove
#define ft_memset   memset
#define ft_strcat   strcat
#define ft_strcmp   strcmp
#define ft_strcpy   strcpy
#define ft_strlen   strlen
#define ft_strncmp  strncmp
#define ft_strncpy  strncpy
#define ft_strrchr  strrchr
#define ft_strstr   strstr
  /**********************************************************************/
  /*                                                                    */
  /*                           file handling                            */
  /*                                                                    */
  /**********************************************************************/
#define FT_FILE     FILE
#define ft_fclose   fclose
#define ft_fopen    fopen
#define ft_fread    fread
#define ft_fseek    fseek
#define ft_ftell    ftell
#define ft_sprintf  sprintf
  /**********************************************************************/
  /*                                                                    */
  /*                             sorting                                */
  /*                                                                    */
  /**********************************************************************/
#define ft_qsort  qsort
  /**********************************************************************/
  /*                                                                    */
  /*                        memory allocation                           */
  /*                                                                    */
  /**********************************************************************/
#define ft_scalloc   calloc
#define ft_sfree     free
#define ft_smalloc   malloc
#define ft_srealloc  realloc
  /**********************************************************************/
  /*                                                                    */
  /*                          miscellaneous                             */
  /*                                                                    */
  /**********************************************************************/
#define ft_strtol  strtol
#define ft_getenv  getenv
  /**********************************************************************/
  /*                                                                    */
  /*                         execution control                          */
  /*                                                                    */
  /**********************************************************************/
#include <setjmp.h>
#define ft_jmp_buf     jmp_buf
                                /*       jmp_buf is defined as a macro  */
                                /*       on certain platforms           */
#define ft_longjmp     longjmp
#define ft_setjmp( b ) setjmp( *(ft_jmp_buf*) &(b) )
  /* the following is only used for debugging purposes, i.e., if */
  /* FT_DEBUG_LEVEL_ERROR or FT_DEBUG_LEVEL_TRACE are defined    */
#endif
/* END */
FT_BEGIN_HEADER
  /*************************************************************************/
  /*                                                                       */
  /*               PLATFORM-SPECIFIC CONFIGURATION MACROS                  */
  /*                                                                       */
  /* These macros can be toggled to suit a specific system.  The current   */
  /* ones are defaults used to compile FreeType in an ANSI C environment   */
  /* (16bit compilers are also supported).  Copy this file to your own     */
  /* `builds/<system>' directory, and edit it to port the engine.          */
  /*                                                                       */
  /*************************************************************************/
  /* There are systems (like the Texas Instruments 'C54x) where a `char' */
  /* has 16 bits.  ANSI C says that sizeof(char) is always 1.  Since an  */
  /* `int' has 16 bits also for this system, sizeof(int) gives 1 which   */
  /* is probably unexpected.                                             */
  /*                                                                     */
  /* `CHAR_BIT' (defined in limits.h) gives the number of bits in a      */
  /* `char' type.                                                        */
#ifndef FT_CHAR_BIT
#define FT_CHAR_BIT  CHAR_BIT
#endif
  /* The size of an `int' type.  */
#if                                 FT_UINT_MAX == 0xFFFFUL
#define FT_SIZEOF_INT  (16 / FT_CHAR_BIT)
#elif                               FT_UINT_MAX == 0xFFFFFFFFUL
#define FT_SIZEOF_INT  (32 / FT_CHAR_BIT)
#elif FT_UINT_MAX > 0xFFFFFFFFUL && FT_UINT_MAX == 0xFFFFFFFFFFFFFFFFUL
#define FT_SIZEOF_INT  (64 / FT_CHAR_BIT)
#else
#error "Unsupported size of `int' type!"
#endif
  /* The size of a `long' type.  A five-byte `long' (as used e.g. on the */
  /* DM642) is recognized but avoided.                                   */
#if                                  FT_ULONG_MAX == 0xFFFFFFFFUL
#define FT_SIZEOF_LONG  (32 / FT_CHAR_BIT)
#elif FT_ULONG_MAX > 0xFFFFFFFFUL && FT_ULONG_MAX == 0xFFFFFFFFFFUL
#define FT_SIZEOF_LONG  (32 / FT_CHAR_BIT)
#elif FT_ULONG_MAX > 0xFFFFFFFFUL && FT_ULONG_MAX == 0xFFFFFFFFFFFFFFFFUL
#define FT_SIZEOF_LONG  (64 / FT_CHAR_BIT)
#else
#error "Unsupported size of `long' type!"
#endif
  /* FT_UNUSED is a macro used to indicate that a given parameter is not  */
  /* used -- this is only used to get rid of unpleasant compiler warnings */
#ifndef FT_UNUSED
#define FT_UNUSED( arg )  ( (arg) = (arg) )
#endif
  /*************************************************************************/
  /*                                                                       */
  /*                     AUTOMATIC CONFIGURATION MACROS                    */
  /*                                                                       */
  /* These macros are computed from the ones defined above.  Don't touch   */
  /* their definition, unless you know precisely what you are doing.  No   */
  /* porter should need to mess with them.                                 */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* Mac support                                                           */
  /*                                                                       */
  /*   This is the only necessary change, so it is defined here instead    */
  /*   providing a new configuration file.                                 */
  /*                                                                       */
#if defined( __APPLE__ ) || ( defined( __MWERKS__ ) && defined( macintosh ) )
  /* no Carbon frameworks for 64bit 10.4.x */
  /* AvailabilityMacros.h is available since Mac OS X 10.2,        */
  /* so guess the system version by maximum errno before inclusion */
#ifdef ECANCELED
#include "AvailabilityMacros.h"
#endif
#if defined( __LP64__ ) &&     ( MAC_OS_X_VERSION_MIN_REQUIRED <= MAC_OS_X_VERSION_10_4 )
#undef FT_MACINTOSH
#endif
#elif defined( __SC__ ) || defined( __MRC__ )
  /* Classic MacOS compilers */
#include "ConditionalMacros.h"
#if TARGET_OS_MAC
#define FT_MACINTOSH 1
#endif
#endif
  /* Fix compiler warning with sgi compiler */
#if defined( __sgi ) && !defined( __GNUC__ )
#if defined( _COMPILER_VERSION ) && ( _COMPILER_VERSION >= 730 )
#pragma set woff 3505
#endif
#endif
  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    basic_types                                                        */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Int16                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for a 16bit signed integer type.                         */
  /*                                                                       */
  typedef signed short  FT_Int16;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_UInt16                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for a 16bit unsigned integer type.                       */
  /*                                                                       */
  typedef unsigned short  FT_UInt16;
  /* */
  /* this #if 0 ... #endif clause is for documentation purposes */
#if 0
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Int32                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for a 32bit signed integer type.  The size depends on    */
  /*    the configuration.                                                 */
  /*                                                                       */
  typedef signed XXX  FT_Int32;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_UInt32                                                          */
  /*                                                                       */
  /*    A typedef for a 32bit unsigned integer type.  The size depends on  */
  /*    the configuration.                                                 */
  /*                                                                       */
  typedef unsigned XXX  FT_UInt32;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Int64                                                           */
  /*                                                                       */
  /*    A typedef for a 64bit signed integer type.  The size depends on    */
  /*    the configuration.  Only defined if there is real 64bit support;   */
  /*    otherwise, it gets emulated with a structure (if necessary).       */
  /*                                                                       */
  typedef signed XXX  FT_Int64;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_UInt64                                                          */
  /*                                                                       */
  /*    A typedef for a 64bit unsigned integer type.  The size depends on  */
  /*    the configuration.  Only defined if there is real 64bit support;   */
  /*    otherwise, it gets emulated with a structure (if necessary).       */
  /*                                                                       */
  typedef unsigned XXX  FT_UInt64;
  /* */
#endif
#if FT_SIZEOF_INT == (32 / FT_CHAR_BIT)
  typedef signed int      FT_Int32;
  typedef unsigned int    FT_UInt32;
#elif FT_SIZEOF_LONG == (32 / FT_CHAR_BIT)
  typedef signed long     FT_Int32;
  typedef unsigned long   FT_UInt32;
#else
#error "no 32bit type found -- please check your configuration files"
#endif
  /* look up an integer type that is at least 32 bits */
#if FT_SIZEOF_INT >= (32 / FT_CHAR_BIT)
  typedef int            FT_Fast;
  typedef unsigned int   FT_UFast;
#elif FT_SIZEOF_LONG >= (32 / FT_CHAR_BIT)
  typedef long           FT_Fast;
  typedef unsigned long  FT_UFast;
#endif
  /* determine whether we have a 64-bit int type for platforms without */
  /* Autoconf                                                          */
#if FT_SIZEOF_LONG == (64 / FT_CHAR_BIT)
  /* FT_LONG64 must be defined if a 64-bit type is available */
#define FT_LONG64
#define FT_INT64   long
#define FT_UINT64  unsigned long
  /*************************************************************************/
  /*                                                                       */
  /* A 64-bit data type may create compilation problems if you compile     */
  /* in strict ANSI mode.  To avoid them, we disable other 64-bit data     */
  /* types if __STDC__ is defined.  You can however ignore this rule       */
  /* by defining the FT_CONFIG_OPTION_FORCE_INT64 configuration macro.     */
  /*                                                                       */
#elif !defined( __STDC__ ) || defined( FT_CONFIG_OPTION_FORCE_INT64 )
#if defined( __STDC_VERSION__ ) && __STDC_VERSION__ >= 199901L
#define FT_LONG64
#define FT_INT64   long long int
#define FT_UINT64  unsigned long long int
#elif defined( _MSC_VER ) && _MSC_VER >= 900
  /* this compiler provides the __int64 type */
#define FT_LONG64
#define FT_INT64   __int64
#define FT_UINT64  unsigned __int64
#elif defined( __BORLANDC__ )
  /* XXXX: We should probably check the value of __BORLANDC__ in order */
  /*       to test the compiler version.                               */
  /* this compiler provides the __int64 type */
#define FT_LONG64
#define FT_INT64   __int64
#define FT_UINT64  unsigned __int64
#elif defined( __WATCOMC__ )
  /* Watcom doesn't provide 64-bit data types */
#elif defined( __MWERKS__ )
#define FT_LONG64
#define FT_INT64   long long int
#define FT_UINT64  unsigned long long int
#elif defined( __GNUC__ )
  /* GCC provides the `long long' type */
#define FT_LONG64
#define FT_INT64   long long int
#define FT_UINT64  unsigned long long int
#endif
#endif
#ifdef FT_LONG64
  typedef FT_INT64   FT_Int64;
  typedef FT_UINT64  FT_UInt64;
#endif
#ifdef _WIN64
  /* only 64bit Windows uses the LLP64 data model, i.e., */
  /* 32bit integers, 64bit pointers                      */
#define FT_UINT_TO_POINTER( x ) (void*)(unsigned __int64)(x)
#else
#define FT_UINT_TO_POINTER( x ) (void*)(unsigned long)(x)
#endif
  /*************************************************************************/
  /*                                                                       */
  /* miscellaneous                                                         */
  /*                                                                       */
  /*************************************************************************/
#define FT_BEGIN_STMNT  do {
#define FT_END_STMNT    } while ( 0 )
#define FT_DUMMY_STMNT  FT_BEGIN_STMNT FT_END_STMNT
  /* typeof condition taken from gnulib's `intprops.h' header file */
#if ( ( defined( __GNUC__ ) && __GNUC__ >= 2 )                       ||       ( defined( __IBMC__ ) && __IBMC__ >= 1210 &&                              defined( __IBM__TYPEOF__ ) )                                 ||       ( defined( __SUNPRO_C ) && __SUNPRO_C >= 0x5110 && !__STDC__ ) )
#define FT_TYPEOF( type )  ( __typeof__ ( type ) )
#else
#define FT_TYPEOF( type )
#endif
#ifdef FT_MAKE_OPTION_SINGLE_OBJECT
#define FT_LOCAL( x )      static  x
#define FT_LOCAL_DEF( x )  static  x
#else
#ifdef __cplusplus
#define FT_LOCAL( x )      extern "C"  x
#define FT_LOCAL_DEF( x )  extern "C"  x
#else
#define FT_LOCAL( x )      extern  x
#define FT_LOCAL_DEF( x )  x
#endif
#endif
#define FT_LOCAL_ARRAY( x )      extern const  x
#define FT_LOCAL_ARRAY_DEF( x )  const  x
#ifndef FT_BASE
#ifdef __cplusplus
#define FT_BASE( x )  extern "C"  x
#else
#define FT_BASE( x )  extern  x
#endif
#endif
#ifndef FT_BASE_DEF
#ifdef __cplusplus
#define FT_BASE_DEF( x )  x
#else
#define FT_BASE_DEF( x )  x
#endif
#endif
#ifdef FREETYPE_SOURCE
#  define FT_EXPORT( x ) EXPORT_METHOD x
#  define FT_EXPORT_DEF( x ) EXPORT_METHOD x
#else
#  define FT_EXPORT( x ) IMPORT_METHOD x
#  define FT_EXPORT_DEF( x ) IMPORT_METHOD x
#endif
#ifndef FT_EXPORT
#ifdef __cplusplus
#define FT_EXPORT( x )  extern "C"  x
#else
#define FT_EXPORT( x )  extern  x
#endif
#endif
#ifndef FT_EXPORT_DEF
#ifdef __cplusplus
#define FT_EXPORT_DEF( x )  extern "C"  x
#else
#define FT_EXPORT_DEF( x )  extern  x
#endif
#endif
#ifndef FT_EXPORT_VAR
#ifdef __cplusplus
#define FT_EXPORT_VAR( x )  extern "C"  x
#else
#define FT_EXPORT_VAR( x )  extern  x
#endif
#endif
  /* The following macros are needed to compile the library with a   */
  /* C++ compiler and with 16bit compilers.                          */
  /*                                                                 */
  /* This is special.  Within C++, you must specify `extern "C"' for */
  /* functions which are used via function pointers, and you also    */
  /* must do that for structures which contain function pointers to  */
  /* assure C linkage -- it's not possible to have (local) anonymous */
  /* functions which are accessed by (global) function pointers.     */
  /*                                                                 */
  /*                                                                 */
  /* FT_CALLBACK_DEF is used to _define_ a callback function.        */
  /*                                                                 */
  /* FT_CALLBACK_TABLE is used to _declare_ a constant variable that */
  /* contains pointers to callback functions.                        */
  /*                                                                 */
  /* FT_CALLBACK_TABLE_DEF is used to _define_ a constant variable   */
  /* that contains pointers to callback functions.                   */
  /*                                                                 */
  /*                                                                 */
  /* Some 16bit compilers have to redefine these macros to insert    */
  /* the infamous `_cdecl' or `__fastcall' declarations.             */
  /*                                                                 */
#ifndef FT_CALLBACK_DEF
#ifdef __cplusplus
#define FT_CALLBACK_DEF( x )  extern "C"  x
#else
#define FT_CALLBACK_DEF( x )  static  x
#endif
#endif
#ifndef FT_CALLBACK_TABLE
#ifdef __cplusplus
#define FT_CALLBACK_TABLE      extern "C"
#define FT_CALLBACK_TABLE_DEF  extern "C"
#else
#define FT_CALLBACK_TABLE      extern
#define FT_CALLBACK_TABLE_DEF
#endif
#endif
FT_END_HEADER
#endif
/* END */
/***************************************************************************/
/*                                                                         */
/*  fttypes.h                                                              */
/*                                                                         */
/*    FreeType simple types definitions (specification only).              */
/*                                                                         */
/*  Copyright 1996-2017 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
#ifndef FTTYPES_H_
#define FTTYPES_H_
/***************************************************************************/
/*                                                                         */
/*  ftsystem.h                                                             */
/*                                                                         */
/*    FreeType low-level system interface definition (specification).      */
/*                                                                         */
/*  Copyright 1996-2017 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
#ifndef FTSYSTEM_H_
#define FTSYSTEM_H_
FT_BEGIN_HEADER
  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*   system_interface                                                    */
  /*                                                                       */
  /* <Title>                                                               */
  /*   System Interface                                                    */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*   How FreeType manages memory and i/o.                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*   This section contains various definitions related to memory         */
  /*   management and i/o access.  You need to understand this             */
  /*   information if you want to use a custom memory manager or you own   */
  /*   i/o streams.                                                        */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /*                  M E M O R Y   M A N A G E M E N T                    */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************
   *
   * @type:
   *   FT_Memory
   *
   * @description:
   *   A handle to a given memory manager object, defined with an
   *   @FT_MemoryRec structure.
   *
   */
  typedef struct FT_MemoryRec_*  FT_Memory;
  /*************************************************************************
   *
   * @functype:
   *   FT_Alloc_Func
   *
   * @description:
   *   A function used to allocate `size' bytes from `memory'.
   *
   * @input:
   *   memory ::
   *     A handle to the source memory manager.
   *
   *   size ::
   *     The size in bytes to allocate.
   *
   * @return:
   *   Address of new memory block.  0~in case of failure.
   *
   */
  typedef void*
  (*FT_Alloc_Func)( FT_Memory  memory,
                    long       size );
  /*************************************************************************
   *
   * @functype:
   *   FT_Free_Func
   *
   * @description:
   *   A function used to release a given block of memory.
   *
   * @input:
   *   memory ::
   *     A handle to the source memory manager.
   *
   *   block ::
   *     The address of the target memory block.
   *
   */
  typedef void
  (*FT_Free_Func)( FT_Memory  memory,
                   void*      block );
  /*************************************************************************
   *
   * @functype:
   *   FT_Realloc_Func
   *
   * @description:
   *   A function used to re-allocate a given block of memory.
   *
   * @input:
   *   memory ::
   *     A handle to the source memory manager.
   *
   *   cur_size ::
   *     The block's current size in bytes.
   *
   *   new_size ::
   *     The block's requested new size.
   *
   *   block ::
   *     The block's current address.
   *
   * @return:
   *   New block address.  0~in case of memory shortage.
   *
   * @note:
   *   In case of error, the old block must still be available.
   *
   */
  typedef void*
  (*FT_Realloc_Func)( FT_Memory  memory,
                      long       cur_size,
                      long       new_size,
                      void*      block );
  /*************************************************************************
   *
   * @struct:
   *   FT_MemoryRec
   *
   * @description:
   *   A structure used to describe a given memory manager to FreeType~2.
   *
   * @fields:
   *   user ::
   *     A generic typeless pointer for user data.
   *
   *   alloc ::
   *     A pointer type to an allocation function.
   *
   *   free ::
   *     A pointer type to an memory freeing function.
   *
   *   realloc ::
   *     A pointer type to a reallocation function.
   *
   */
  struct  FT_MemoryRec_
  {
    void*            user;
    FT_Alloc_Func    alloc;
    FT_Free_Func     free;
    FT_Realloc_Func  realloc;
  };
  /*************************************************************************/
  /*                                                                       */
  /*                       I / O   M A N A G E M E N T                     */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************
   *
   * @type:
   *   FT_Stream
   *
   * @description:
   *   A handle to an input stream.
   *
   * @also:
   *   See @FT_StreamRec for the publicly accessible fields of a given
   *   stream object.
   *
   */
  typedef struct FT_StreamRec_*  FT_Stream;
  /*************************************************************************
   *
   * @struct:
   *   FT_StreamDesc
   *
   * @description:
   *   A union type used to store either a long or a pointer.  This is used
   *   to store a file descriptor or a `FILE*' in an input stream.
   *
   */
  typedef union  FT_StreamDesc_
  {
    long   value;
    void*  pointer;
  } FT_StreamDesc;
  /*************************************************************************
   *
   * @functype:
   *   FT_Stream_IoFunc
   *
   * @description:
   *   A function used to seek and read data from a given input stream.
   *
   * @input:
   *   stream ::
   *     A handle to the source stream.
   *
   *   offset ::
   *     The offset of read in stream (always from start).
   *
   *   buffer ::
   *     The address of the read buffer.
   *
   *   count ::
   *     The number of bytes to read from the stream.
   *
   * @return:
   *   The number of bytes effectively read by the stream.
   *
   * @note:
   *   This function might be called to perform a seek or skip operation
   *   with a `count' of~0.  A non-zero return value then indicates an
   *   error.
   *
   */
  typedef unsigned long
  (*FT_Stream_IoFunc)( FT_Stream       stream,
                       unsigned long   offset,
                       unsigned char*  buffer,
                       unsigned long   count );
  /*************************************************************************
   *
   * @functype:
   *   FT_Stream_CloseFunc
   *
   * @description:
   *   A function used to close a given input stream.
   *
   * @input:
   *  stream ::
   *     A handle to the target stream.
   *
   */
  typedef void
  (*FT_Stream_CloseFunc)( FT_Stream  stream );
  /*************************************************************************
   *
   * @struct:
   *   FT_StreamRec
   *
   * @description:
   *   A structure used to describe an input stream.
   *
   * @input:
   *   base ::
   *     For memory-based streams, this is the address of the first stream
   *     byte in memory.  This field should always be set to NULL for
   *     disk-based streams.
   *
   *   size ::
   *     The stream size in bytes.
   *
   *     In case of compressed streams where the size is unknown before
   *     actually doing the decompression, the value is set to 0x7FFFFFFF.
   *     (Note that this size value can occur for normal streams also; it is
   *     thus just a hint.)
   *
   *   pos ::
   *     The current position within the stream.
   *
   *   descriptor ::
   *     This field is a union that can hold an integer or a pointer.  It is
   *     used by stream implementations to store file descriptors or `FILE*'
   *     pointers.
   *
   *   pathname ::
   *     This field is completely ignored by FreeType.  However, it is often
   *     useful during debugging to use it to store the stream's filename
   *     (where available).
   *
   *   read ::
   *     The stream's input function.
   *
   *   close ::
   *     The stream's close function.
   *
   *   memory ::
   *     The memory manager to use to preload frames.  This is set
   *     internally by FreeType and shouldn't be touched by stream
   *     implementations.
   *
   *   cursor ::
   *     This field is set and used internally by FreeType when parsing
   *     frames.
   *
   *   limit ::
   *     This field is set and used internally by FreeType when parsing
   *     frames.
   *
   */
  typedef struct  FT_StreamRec_
  {
    unsigned char*       base;
    unsigned long        size;
    unsigned long        pos;
    FT_StreamDesc        descriptor;
    FT_StreamDesc        pathname;
    FT_Stream_IoFunc     read;
    FT_Stream_CloseFunc  close;
    FT_Memory            memory;
    unsigned char*       cursor;
    unsigned char*       limit;
  } FT_StreamRec;
  /* */
FT_END_HEADER
#endif
/* END */
/***************************************************************************/
/*                                                                         */
/*  ftimage.h                                                              */
/*                                                                         */
/*    FreeType glyph image formats and default raster interface            */
/*    (specification).                                                     */
/*                                                                         */
/*  Copyright 1996-2017 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* Note: A `raster' is simply a scan-line converter, used to render      */
  /*       FT_Outlines into FT_Bitmaps.                                    */
  /*                                                                       */
  /*************************************************************************/
#ifndef FTIMAGE_H_
#define FTIMAGE_H_
  /* STANDALONE_ is from ftgrays.c */
#ifndef STANDALONE_
#endif
FT_BEGIN_HEADER
  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    basic_types                                                        */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Pos                                                             */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The type FT_Pos is used to store vectorial coordinates.  Depending */
  /*    on the context, these can represent distances in integer font      */
  /*    units, or 16.16, or 26.6 fixed-point pixel coordinates.            */
  /*                                                                       */
  typedef signed long  FT_Pos;
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Vector                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A simple structure used to store a 2D vector; coordinates are of   */
  /*    the FT_Pos type.                                                   */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    x :: The horizontal coordinate.                                    */
  /*    y :: The vertical coordinate.                                      */
  /*                                                                       */
  typedef struct  FT_Vector_
  {
    FT_Pos  x;
    FT_Pos  y;
  } FT_Vector;
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_BBox                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A structure used to hold an outline's bounding box, i.e., the      */
  /*    coordinates of its extrema in the horizontal and vertical          */
  /*    directions.                                                        */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    xMin :: The horizontal minimum (left-most).                        */
  /*                                                                       */
  /*    yMin :: The vertical minimum (bottom-most).                        */
  /*                                                                       */
  /*    xMax :: The horizontal maximum (right-most).                       */
  /*                                                                       */
  /*    yMax :: The vertical maximum (top-most).                           */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The bounding box is specified with the coordinates of the lower    */
  /*    left and the upper right corner.  In PostScript, those values are  */
  /*    often called (llx,lly) and (urx,ury), respectively.                */
  /*                                                                       */
  /*    If `yMin' is negative, this value gives the glyph's descender.     */
  /*    Otherwise, the glyph doesn't descend below the baseline.           */
  /*    Similarly, if `ymax' is positive, this value gives the glyph's     */
  /*    ascender.                                                          */
  /*                                                                       */
  /*    `xMin' gives the horizontal distance from the glyph's origin to    */
  /*    the left edge of the glyph's bounding box.  If `xMin' is negative, */
  /*    the glyph extends to the left of the origin.                       */
  /*                                                                       */
  typedef struct  FT_BBox_
  {
    FT_Pos  xMin, yMin;
    FT_Pos  xMax, yMax;
  } FT_BBox;
  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_Pixel_Mode                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    An enumeration type used to describe the format of pixels in a     */
  /*    given bitmap.  Note that additional formats may be added in the    */
  /*    future.                                                            */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_PIXEL_MODE_NONE ::                                              */
  /*      Value~0 is reserved.                                             */
  /*                                                                       */
  /*    FT_PIXEL_MODE_MONO ::                                              */
  /*      A monochrome bitmap, using 1~bit per pixel.  Note that pixels    */
  /*      are stored in most-significant order (MSB), which means that     */
  /*      the left-most pixel in a byte has value 128.                     */
  /*                                                                       */
  /*    FT_PIXEL_MODE_GRAY ::                                              */
  /*      An 8-bit bitmap, generally used to represent anti-aliased glyph  */
  /*      images.  Each pixel is stored in one byte.  Note that the number */
  /*      of `gray' levels is stored in the `num_grays' field of the       */
  /*      @FT_Bitmap structure (it generally is 256).                      */
  /*                                                                       */
  /*    FT_PIXEL_MODE_GRAY2 ::                                             */
  /*      A 2-bit per pixel bitmap, used to represent embedded             */
  /*      anti-aliased bitmaps in font files according to the OpenType     */
  /*      specification.  We haven't found a single font using this        */
  /*      format, however.                                                 */
  /*                                                                       */
  /*    FT_PIXEL_MODE_GRAY4 ::                                             */
  /*      A 4-bit per pixel bitmap, representing embedded anti-aliased     */
  /*      bitmaps in font files according to the OpenType specification.   */
  /*      We haven't found a single font using this format, however.       */
  /*                                                                       */
  /*    FT_PIXEL_MODE_LCD ::                                               */
  /*      An 8-bit bitmap, representing RGB or BGR decimated glyph images  */
  /*      used for display on LCD displays; the bitmap is three times      */
  /*      wider than the original glyph image.  See also                   */
  /*      @FT_RENDER_MODE_LCD.                                             */
  /*                                                                       */
  /*    FT_PIXEL_MODE_LCD_V ::                                             */
  /*      An 8-bit bitmap, representing RGB or BGR decimated glyph images  */
  /*      used for display on rotated LCD displays; the bitmap is three    */
  /*      times taller than the original glyph image.  See also            */
  /*      @FT_RENDER_MODE_LCD_V.                                           */
  /*                                                                       */
  /*    FT_PIXEL_MODE_BGRA ::                                              */
  /*      An image with four 8-bit channels per pixel, representing a      */
  /*      color image (such as emoticons) with alpha channel.  For each    */
  /*      pixel, the format is BGRA, which means, the blue channel comes   */
  /*      first in memory.  The color channels are pre-multiplied and in   */
  /*      the sRGB colorspace.  For example, full red at half-translucent  */
  /*      opacity will be represented as `00,00,80,80', not `00,00,FF,80'. */
  /*      See also @FT_LOAD_COLOR.                                         */
  /*                                                                       */
  typedef enum  FT_Pixel_Mode_
  {
    FT_PIXEL_MODE_NONE = 0,
    FT_PIXEL_MODE_MONO,
    FT_PIXEL_MODE_GRAY,
    FT_PIXEL_MODE_GRAY2,
    FT_PIXEL_MODE_GRAY4,
    FT_PIXEL_MODE_LCD,
    FT_PIXEL_MODE_LCD_V,
    FT_PIXEL_MODE_BGRA,
    FT_PIXEL_MODE_MAX
  } FT_Pixel_Mode;
  /* these constants are deprecated; use the corresponding `FT_Pixel_Mode' */
  /* values instead.                                                       */
#define ft_pixel_mode_none   FT_PIXEL_MODE_NONE
#define ft_pixel_mode_mono   FT_PIXEL_MODE_MONO
#define ft_pixel_mode_grays  FT_PIXEL_MODE_GRAY
#define ft_pixel_mode_pal2   FT_PIXEL_MODE_GRAY2
#define ft_pixel_mode_pal4   FT_PIXEL_MODE_GRAY4
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Bitmap                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A structure used to describe a bitmap or pixmap to the raster.     */
  /*    Note that we now manage pixmaps of various depths through the      */
  /*    `pixel_mode' field.                                                */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    rows         :: The number of bitmap rows.                         */
  /*                                                                       */
  /*    width        :: The number of pixels in bitmap row.                */
  /*                                                                       */
  /*    pitch        :: The pitch's absolute value is the number of bytes  */
  /*                    taken by one bitmap row, including padding.        */
  /*                    However, the pitch is positive when the bitmap has */
  /*                    a `down' flow, and negative when it has an `up'    */
  /*                    flow.  In all cases, the pitch is an offset to add */
  /*                    to a bitmap pointer in order to go down one row.   */
  /*                                                                       */
  /*                    Note that `padding' means the alignment of a       */
  /*                    bitmap to a byte border, and FreeType functions    */
  /*                    normally align to the smallest possible integer    */
  /*                    value.                                             */
  /*                                                                       */
  /*                    For the B/W rasterizer, `pitch' is always an even  */
  /*                    number.                                            */
  /*                                                                       */
  /*                    To change the pitch of a bitmap (say, to make it a */
  /*                    multiple of 4), use @FT_Bitmap_Convert.            */
  /*                    Alternatively, you might use callback functions to */
  /*                    directly render to the application's surface; see  */
  /*                    the file `example2.cpp' in the tutorial for a      */
  /*                    demonstration.                                     */
  /*                                                                       */
  /*    buffer       :: A typeless pointer to the bitmap buffer.  This     */
  /*                    value should be aligned on 32-bit boundaries in    */
  /*                    most cases.                                        */
  /*                                                                       */
  /*    num_grays    :: This field is only used with                       */
  /*                    @FT_PIXEL_MODE_GRAY; it gives the number of gray   */
  /*                    levels used in the bitmap.                         */
  /*                                                                       */
  /*    pixel_mode   :: The pixel mode, i.e., how pixel bits are stored.   */
  /*                    See @FT_Pixel_Mode for possible values.            */
  /*                                                                       */
  /*    palette_mode :: This field is intended for paletted pixel modes;   */
  /*                    it indicates how the palette is stored.  Not       */
  /*                    used currently.                                    */
  /*                                                                       */
  /*    palette      :: A typeless pointer to the bitmap palette; this     */
  /*                    field is intended for paletted pixel modes.  Not   */
  /*                    used currently.                                    */
  /*                                                                       */
  typedef struct  FT_Bitmap_
  {
    unsigned int    rows;
    unsigned int    width;
    int             pitch;
    unsigned char*  buffer;
    unsigned short  num_grays;
    unsigned char   pixel_mode;
    unsigned char   palette_mode;
    void*           palette;
  } FT_Bitmap;
  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    outline_processing                                                 */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Outline                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This structure is used to describe an outline to the scan-line     */
  /*    converter.                                                         */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    n_contours :: The number of contours in the outline.               */
  /*                                                                       */
  /*    n_points   :: The number of points in the outline.                 */
  /*                                                                       */
  /*    points     :: A pointer to an array of `n_points' @FT_Vector       */
  /*                  elements, giving the outline's point coordinates.    */
  /*                                                                       */
  /*    tags       :: A pointer to an array of `n_points' chars, giving    */
  /*                  each outline point's type.                           */
  /*                                                                       */
  /*                  If bit~0 is unset, the point is `off' the curve,     */
  /*                  i.e., a Bzier control point, while it is `on' if    */
  /*                  set.                                                 */
  /*                                                                       */
  /*                  Bit~1 is meaningful for `off' points only.  If set,  */
  /*                  it indicates a third-order Bzier arc control point; */
  /*                  and a second-order control point if unset.           */
  /*                                                                       */
  /*                  If bit~2 is set, bits 5-7 contain the drop-out mode  */
  /*                  (as defined in the OpenType specification; the value */
  /*                  is the same as the argument to the SCANMODE          */
  /*                  instruction).                                        */
  /*                                                                       */
  /*                  Bits 3 and~4 are reserved for internal purposes.     */
  /*                                                                       */
  /*    contours   :: An array of `n_contours' shorts, giving the end      */
  /*                  point of each contour within the outline.  For       */
  /*                  example, the first contour is defined by the points  */
  /*                  `0' to `contours[0]', the second one is defined by   */
  /*                  the points `contours[0]+1' to `contours[1]', etc.    */
  /*                                                                       */
  /*    flags      :: A set of bit flags used to characterize the outline  */
  /*                  and give hints to the scan-converter and hinter on   */
  /*                  how to convert/grid-fit it.  See @FT_OUTLINE_XXX.    */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The B/W rasterizer only checks bit~2 in the `tags' array for the   */
  /*    first point of each contour.  The drop-out mode as given with      */
  /*    @FT_OUTLINE_IGNORE_DROPOUTS, @FT_OUTLINE_SMART_DROPOUTS, and       */
  /*    @FT_OUTLINE_INCLUDE_STUBS in `flags' is then overridden.           */
  /*                                                                       */
  typedef struct  FT_Outline_
  {
    short       n_contours;
    short       n_points;
    FT_Vector*  points;
    char*       tags;
    short*      contours;
    int         flags;
  } FT_Outline;
  /* */
  /* Following limits must be consistent with */
  /* FT_Outline.{n_contours,n_points}         */
#define FT_OUTLINE_CONTOURS_MAX  SHRT_MAX
#define FT_OUTLINE_POINTS_MAX    SHRT_MAX
  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_OUTLINE_XXX                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A list of bit-field constants use for the flags in an outline's    */
  /*    `flags' field.                                                     */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_OUTLINE_NONE ::                                                 */
  /*      Value~0 is reserved.                                             */
  /*                                                                       */
  /*    FT_OUTLINE_OWNER ::                                                */
  /*      If set, this flag indicates that the outline's field arrays      */
  /*      (i.e., `points', `flags', and `contours') are `owned' by the     */
  /*      outline object, and should thus be freed when it is destroyed.   */
  /*                                                                       */
  /*    FT_OUTLINE_EVEN_ODD_FILL ::                                        */
  /*      By default, outlines are filled using the non-zero winding rule. */
  /*      If set to 1, the outline will be filled using the even-odd fill  */
  /*      rule (only works with the smooth rasterizer).                    */
  /*                                                                       */
  /*    FT_OUTLINE_REVERSE_FILL ::                                         */
  /*      By default, outside contours of an outline are oriented in       */
  /*      clock-wise direction, as defined in the TrueType specification.  */
  /*      This flag is set if the outline uses the opposite direction      */
  /*      (typically for Type~1 fonts).  This flag is ignored by the scan  */
  /*      converter.                                                       */
  /*                                                                       */
  /*    FT_OUTLINE_IGNORE_DROPOUTS ::                                      */
  /*      By default, the scan converter will try to detect drop-outs in   */
  /*      an outline and correct the glyph bitmap to ensure consistent     */
  /*      shape continuity.  If set, this flag hints the scan-line         */
  /*      converter to ignore such cases.  See below for more information. */
  /*                                                                       */
  /*    FT_OUTLINE_SMART_DROPOUTS ::                                       */
  /*      Select smart dropout control.  If unset, use simple dropout      */
  /*      control.  Ignored if @FT_OUTLINE_IGNORE_DROPOUTS is set.  See    */
  /*      below for more information.                                      */
  /*                                                                       */
  /*    FT_OUTLINE_INCLUDE_STUBS ::                                        */
  /*      If set, turn pixels on for `stubs', otherwise exclude them.      */
  /*      Ignored if @FT_OUTLINE_IGNORE_DROPOUTS is set.  See below for    */
  /*      more information.                                                */
  /*                                                                       */
  /*    FT_OUTLINE_HIGH_PRECISION ::                                       */
  /*      This flag indicates that the scan-line converter should try to   */
  /*      convert this outline to bitmaps with the highest possible        */
  /*      quality.  It is typically set for small character sizes.  Note   */
  /*      that this is only a hint that might be completely ignored by a   */
  /*      given scan-converter.                                            */
  /*                                                                       */
  /*    FT_OUTLINE_SINGLE_PASS ::                                          */
  /*      This flag is set to force a given scan-converter to only use a   */
  /*      single pass over the outline to render a bitmap glyph image.     */
  /*      Normally, it is set for very large character sizes.  It is only  */
  /*      a hint that might be completely ignored by a given               */
  /*      scan-converter.                                                  */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The flags @FT_OUTLINE_IGNORE_DROPOUTS, @FT_OUTLINE_SMART_DROPOUTS, */
  /*    and @FT_OUTLINE_INCLUDE_STUBS are ignored by the smooth            */
  /*    rasterizer.                                                        */
  /*                                                                       */
  /*    There exists a second mechanism to pass the drop-out mode to the   */
  /*    B/W rasterizer; see the `tags' field in @FT_Outline.               */
  /*                                                                       */
  /*    Please refer to the description of the `SCANTYPE' instruction in   */
  /*    the OpenType specification (in file `ttinst1.doc') how simple      */
  /*    drop-outs, smart drop-outs, and stubs are defined.                 */
  /*                                                                       */
#define FT_OUTLINE_NONE             0x0
#define FT_OUTLINE_OWNER            0x1
#define FT_OUTLINE_EVEN_ODD_FILL    0x2
#define FT_OUTLINE_REVERSE_FILL     0x4
#define FT_OUTLINE_IGNORE_DROPOUTS  0x8
#define FT_OUTLINE_SMART_DROPOUTS   0x10
#define FT_OUTLINE_INCLUDE_STUBS    0x20
#define FT_OUTLINE_HIGH_PRECISION   0x100
#define FT_OUTLINE_SINGLE_PASS      0x200
  /* these constants are deprecated; use the corresponding */
  /* `FT_OUTLINE_XXX' values instead                       */
#define ft_outline_none             FT_OUTLINE_NONE
#define ft_outline_owner            FT_OUTLINE_OWNER
#define ft_outline_even_odd_fill    FT_OUTLINE_EVEN_ODD_FILL
#define ft_outline_reverse_fill     FT_OUTLINE_REVERSE_FILL
#define ft_outline_ignore_dropouts  FT_OUTLINE_IGNORE_DROPOUTS
#define ft_outline_high_precision   FT_OUTLINE_HIGH_PRECISION
#define ft_outline_single_pass      FT_OUTLINE_SINGLE_PASS
  /* */
#define FT_CURVE_TAG( flag )  ( flag & 3 )
#define FT_CURVE_TAG_ON            1
#define FT_CURVE_TAG_CONIC         0
#define FT_CURVE_TAG_CUBIC         2
#define FT_CURVE_TAG_HAS_SCANMODE  4
#define FT_CURVE_TAG_TOUCH_X       8
#define FT_CURVE_TAG_TOUCH_Y      16
#define FT_CURVE_TAG_TOUCH_BOTH    ( FT_CURVE_TAG_TOUCH_X |                                      FT_CURVE_TAG_TOUCH_Y )
#define FT_Curve_Tag_On       FT_CURVE_TAG_ON
#define FT_Curve_Tag_Conic    FT_CURVE_TAG_CONIC
#define FT_Curve_Tag_Cubic    FT_CURVE_TAG_CUBIC
#define FT_Curve_Tag_Touch_X  FT_CURVE_TAG_TOUCH_X
#define FT_Curve_Tag_Touch_Y  FT_CURVE_TAG_TOUCH_Y
  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Outline_MoveToFunc                                              */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A function pointer type used to describe the signature of a `move  */
  /*    to' function during outline walking/decomposition.                 */
  /*                                                                       */
  /*    A `move to' is emitted to start a new contour in an outline.       */
  /*                                                                       */
  /* <Input>                                                               */
  /*    to   :: A pointer to the target point of the `move to'.            */
  /*                                                                       */
  /*    user :: A typeless pointer, which is passed from the caller of the */
  /*            decomposition function.                                    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Error code.  0~means success.                                      */
  /*                                                                       */
  typedef int
  (*FT_Outline_MoveToFunc)( const FT_Vector*  to,
                            void*             user );
#define FT_Outline_MoveTo_Func  FT_Outline_MoveToFunc
  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Outline_LineToFunc                                              */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A function pointer type used to describe the signature of a `line  */
  /*    to' function during outline walking/decomposition.                 */
  /*                                                                       */
  /*    A `line to' is emitted to indicate a segment in the outline.       */
  /*                                                                       */
  /* <Input>                                                               */
  /*    to   :: A pointer to the target point of the `line to'.            */
  /*                                                                       */
  /*    user :: A typeless pointer, which is passed from the caller of the */
  /*            decomposition function.                                    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Error code.  0~means success.                                      */
  /*                                                                       */
  typedef int
  (*FT_Outline_LineToFunc)( const FT_Vector*  to,
                            void*             user );
#define FT_Outline_LineTo_Func  FT_Outline_LineToFunc
  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Outline_ConicToFunc                                             */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A function pointer type used to describe the signature of a `conic */
  /*    to' function during outline walking or decomposition.              */
  /*                                                                       */
  /*    A `conic to' is emitted to indicate a second-order Bzier arc in   */
  /*    the outline.                                                       */
  /*                                                                       */
  /* <Input>                                                               */
  /*    control :: An intermediate control point between the last position */
  /*               and the new target in `to'.                             */
  /*                                                                       */
  /*    to      :: A pointer to the target end point of the conic arc.     */
  /*                                                                       */
  /*    user    :: A typeless pointer, which is passed from the caller of  */
  /*               the decomposition function.                             */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Error code.  0~means success.                                      */
  /*                                                                       */
  typedef int
  (*FT_Outline_ConicToFunc)( const FT_Vector*  control,
                             const FT_Vector*  to,
                             void*             user );
#define FT_Outline_ConicTo_Func  FT_Outline_ConicToFunc
  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Outline_CubicToFunc                                             */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A function pointer type used to describe the signature of a `cubic */
  /*    to' function during outline walking or decomposition.              */
  /*                                                                       */
  /*    A `cubic to' is emitted to indicate a third-order Bzier arc.      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    control1 :: A pointer to the first Bzier control point.           */
  /*                                                                       */
  /*    control2 :: A pointer to the second Bzier control point.          */
  /*                                                                       */
  /*    to       :: A pointer to the target end point.                     */
  /*                                                                       */
  /*    user     :: A typeless pointer, which is passed from the caller of */
  /*                the decomposition function.                            */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Error code.  0~means success.                                      */
  /*                                                                       */
  typedef int
  (*FT_Outline_CubicToFunc)( const FT_Vector*  control1,
                             const FT_Vector*  control2,
                             const FT_Vector*  to,
                             void*             user );
#define FT_Outline_CubicTo_Func  FT_Outline_CubicToFunc
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Outline_Funcs                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A structure to hold various function pointers used during outline  */
  /*    decomposition in order to emit segments, conic, and cubic Bziers. */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    move_to  :: The `move to' emitter.                                 */
  /*                                                                       */
  /*    line_to  :: The segment emitter.                                   */
  /*                                                                       */
  /*    conic_to :: The second-order Bzier arc emitter.                   */
  /*                                                                       */
  /*    cubic_to :: The third-order Bzier arc emitter.                    */
  /*                                                                       */
  /*    shift    :: The shift that is applied to coordinates before they   */
  /*                are sent to the emitter.                               */
  /*                                                                       */
  /*    delta    :: The delta that is applied to coordinates before they   */
  /*                are sent to the emitter, but after the shift.          */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The point coordinates sent to the emitters are the transformed     */
  /*    version of the original coordinates (this is important for high    */
  /*    accuracy during scan-conversion).  The transformation is simple:   */
  /*                                                                       */
  /*    {                                                                  */
  /*      x' = (x << shift) - delta                                        */
  /*      y' = (y << shift) - delta                                        */
  /*    }                                                                  */
  /*                                                                       */
  /*    Set the values of `shift' and `delta' to~0 to get the original     */
  /*    point coordinates.                                                 */
  /*                                                                       */
  typedef struct  FT_Outline_Funcs_
  {
    FT_Outline_MoveToFunc   move_to;
    FT_Outline_LineToFunc   line_to;
    FT_Outline_ConicToFunc  conic_to;
    FT_Outline_CubicToFunc  cubic_to;
    int                     shift;
    FT_Pos                  delta;
  } FT_Outline_Funcs;
  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    basic_types                                                        */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Macro>                                                               */
  /*    FT_IMAGE_TAG                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This macro converts four-letter tags to an unsigned long type.     */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Since many 16-bit compilers don't like 32-bit enumerations, you    */
  /*    should redefine this macro in case of problems to something like   */
  /*    this:                                                              */
  /*                                                                       */
  /*    {                                                                  */
  /*      #define FT_IMAGE_TAG( value, _x1, _x2, _x3, _x4 )  value         */
  /*    }                                                                  */
  /*                                                                       */
  /*    to get a simple enumeration without assigning special numbers.     */
  /*                                                                       */
#ifndef FT_IMAGE_TAG
#define FT_IMAGE_TAG( value, _x1, _x2, _x3, _x4 )            value = ( ( (unsigned long)_x1 << 24 ) |                     ( (unsigned long)_x2 << 16 ) |                     ( (unsigned long)_x3 << 8  ) |                       (unsigned long)_x4         )
#endif
  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_Glyph_Format                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    An enumeration type used to describe the format of a given glyph   */
  /*    image.  Note that this version of FreeType only supports two image */
  /*    formats, even though future font drivers will be able to register  */
  /*    their own format.                                                  */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_GLYPH_FORMAT_NONE ::                                            */
  /*      The value~0 is reserved.                                         */
  /*                                                                       */
  /*    FT_GLYPH_FORMAT_COMPOSITE ::                                       */
  /*      The glyph image is a composite of several other images.  This    */
  /*      format is _only_ used with @FT_LOAD_NO_RECURSE, and is used to   */
  /*      report compound glyphs (like accented characters).               */
  /*                                                                       */
  /*    FT_GLYPH_FORMAT_BITMAP ::                                          */
  /*      The glyph image is a bitmap, and can be described as an          */
  /*      @FT_Bitmap.  You generally need to access the `bitmap' field of  */
  /*      the @FT_GlyphSlotRec structure to read it.                       */
  /*                                                                       */
  /*    FT_GLYPH_FORMAT_OUTLINE ::                                         */
  /*      The glyph image is a vectorial outline made of line segments     */
  /*      and Bzier arcs; it can be described as an @FT_Outline; you      */
  /*      generally want to access the `outline' field of the              */
  /*      @FT_GlyphSlotRec structure to read it.                           */
  /*                                                                       */
  /*    FT_GLYPH_FORMAT_PLOTTER ::                                         */
  /*      The glyph image is a vectorial path with no inside and outside   */
  /*      contours.  Some Type~1 fonts, like those in the Hershey family,  */
  /*      contain glyphs in this format.  These are described as           */
  /*      @FT_Outline, but FreeType isn't currently capable of rendering   */
  /*      them correctly.                                                  */
  /*                                                                       */
  typedef enum  FT_Glyph_Format_
  {
    FT_IMAGE_TAG( FT_GLYPH_FORMAT_NONE, 0, 0, 0, 0 ),
    FT_IMAGE_TAG( FT_GLYPH_FORMAT_COMPOSITE, 'c', 'o', 'm', 'p' ),
    FT_IMAGE_TAG( FT_GLYPH_FORMAT_BITMAP,    'b', 'i', 't', 's' ),
    FT_IMAGE_TAG( FT_GLYPH_FORMAT_OUTLINE,   'o', 'u', 't', 'l' ),
    FT_IMAGE_TAG( FT_GLYPH_FORMAT_PLOTTER,   'p', 'l', 'o', 't' )
  } FT_Glyph_Format;
  /* these constants are deprecated; use the corresponding */
  /* `FT_Glyph_Format' values instead.                     */
#define ft_glyph_format_none       FT_GLYPH_FORMAT_NONE
#define ft_glyph_format_composite  FT_GLYPH_FORMAT_COMPOSITE
#define ft_glyph_format_bitmap     FT_GLYPH_FORMAT_BITMAP
#define ft_glyph_format_outline    FT_GLYPH_FORMAT_OUTLINE
#define ft_glyph_format_plotter    FT_GLYPH_FORMAT_PLOTTER
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****            R A S T E R   D E F I N I T I O N S                *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* A raster is a scan converter, in charge of rendering an outline into  */
  /* a bitmap.  This section contains the public API for rasters.          */
  /*                                                                       */
  /* Note that in FreeType 2, all rasters are now encapsulated within      */
  /* specific modules called `renderers'.  See `ftrender.h' for more       */
  /* details on renderers.                                                 */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    raster                                                             */
  /*                                                                       */
  /* <Title>                                                               */
  /*    Scanline Converter                                                 */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*    How vectorial outlines are converted into bitmaps and pixmaps.     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This section contains technical definitions.                       */
  /*                                                                       */
  /* <Order>                                                               */
  /*    FT_Raster                                                          */
  /*    FT_Span                                                            */
  /*    FT_SpanFunc                                                        */
  /*                                                                       */
  /*    FT_Raster_Params                                                   */
  /*    FT_RASTER_FLAG_XXX                                                 */
  /*                                                                       */
  /*    FT_Raster_NewFunc                                                  */
  /*    FT_Raster_DoneFunc                                                 */
  /*    FT_Raster_ResetFunc                                                */
  /*    FT_Raster_SetModeFunc                                              */
  /*    FT_Raster_RenderFunc                                               */
  /*    FT_Raster_Funcs                                                    */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Raster                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    An opaque handle (pointer) to a raster object.  Each object can be */
  /*    used independently to convert an outline into a bitmap or pixmap.  */
  /*                                                                       */
  typedef struct FT_RasterRec_*  FT_Raster;
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Span                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A structure used to model a single span of gray pixels when        */
  /*    rendering an anti-aliased bitmap.                                  */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    x        :: The span's horizontal start position.                  */
  /*                                                                       */
  /*    len      :: The span's length in pixels.                           */
  /*                                                                       */
  /*    coverage :: The span color/coverage, ranging from 0 (background)   */
  /*                to 255 (foreground).                                   */
  /*                                                                       */
  /* <Note>                                                                */
  /*    This structure is used by the span drawing callback type named     */
  /*    @FT_SpanFunc that takes the y~coordinate of the span as a          */
  /*    parameter.                                                         */
  /*                                                                       */
  /*    The coverage value is always between 0 and 255.  If you want less  */
  /*    gray values, the callback function has to reduce them.             */
  /*                                                                       */
  typedef struct  FT_Span_
  {
    short           x;
    unsigned short  len;
    unsigned char   coverage;
  } FT_Span;
  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_SpanFunc                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A function used as a call-back by the anti-aliased renderer in     */
  /*    order to let client applications draw themselves the gray pixel    */
  /*    spans on each scan line.                                           */
  /*                                                                       */
  /* <Input>                                                               */
  /*    y     :: The scanline's y~coordinate.                              */
  /*                                                                       */
  /*    count :: The number of spans to draw on this scanline.             */
  /*                                                                       */
  /*    spans :: A table of `count' spans to draw on the scanline.         */
  /*                                                                       */
  /*    user  :: User-supplied data that is passed to the callback.        */
  /*                                                                       */
  /* <Note>                                                                */
  /*    This callback allows client applications to directly render the    */
  /*    gray spans of the anti-aliased bitmap to any kind of surfaces.     */
  /*                                                                       */
  /*    This can be used to write anti-aliased outlines directly to a      */
  /*    given background bitmap, and even perform translucency.            */
  /*                                                                       */
  typedef void
  (*FT_SpanFunc)( int             y,
                  int             count,
                  const FT_Span*  spans,
                  void*           user );
#define FT_Raster_Span_Func  FT_SpanFunc
  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Raster_BitTest_Func                                             */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Deprecated, unimplemented.                                         */
  /*                                                                       */
  typedef int
  (*FT_Raster_BitTest_Func)( int    y,
                             int    x,
                             void*  user );
  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Raster_BitSet_Func                                              */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Deprecated, unimplemented.                                         */
  /*                                                                       */
  typedef void
  (*FT_Raster_BitSet_Func)( int    y,
                            int    x,
                            void*  user );
  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_RASTER_FLAG_XXX                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A list of bit flag constants as used in the `flags' field of a     */
  /*    @FT_Raster_Params structure.                                       */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_RASTER_FLAG_DEFAULT :: This value is 0.                         */
  /*                                                                       */
  /*    FT_RASTER_FLAG_AA      :: This flag is set to indicate that an     */
  /*                              anti-aliased glyph image should be       */
  /*                              generated.  Otherwise, it will be        */
  /*                              monochrome (1-bit).                      */
  /*                                                                       */
  /*    FT_RASTER_FLAG_DIRECT  :: This flag is set to indicate direct      */
  /*                              rendering.  In this mode, client         */
  /*                              applications must provide their own span */
  /*                              callback.  This lets them directly       */
  /*                              draw or compose over an existing bitmap. */
  /*                              If this bit is not set, the target       */
  /*                              pixmap's buffer _must_ be zeroed before  */
  /*                              rendering.                               */
  /*                                                                       */
  /*                              Direct rendering is only possible with   */
  /*                              anti-aliased glyphs.                     */
  /*                                                                       */
  /*    FT_RASTER_FLAG_CLIP    :: This flag is only used in direct         */
  /*                              rendering mode.  If set, the output will */
  /*                              be clipped to a box specified in the     */
  /*                              `clip_box' field of the                  */
  /*                              @FT_Raster_Params structure.             */
  /*                                                                       */
  /*                              Note that by default, the glyph bitmap   */
  /*                              is clipped to the target pixmap, except  */
  /*                              in direct rendering mode where all spans */
  /*                              are generated if no clipping box is set. */
  /*                                                                       */
#define FT_RASTER_FLAG_DEFAULT  0x0
#define FT_RASTER_FLAG_AA       0x1
#define FT_RASTER_FLAG_DIRECT   0x2
#define FT_RASTER_FLAG_CLIP     0x4
  /* these constants are deprecated; use the corresponding */
  /* `FT_RASTER_FLAG_XXX' values instead                   */
#define ft_raster_flag_default  FT_RASTER_FLAG_DEFAULT
#define ft_raster_flag_aa       FT_RASTER_FLAG_AA
#define ft_raster_flag_direct   FT_RASTER_FLAG_DIRECT
#define ft_raster_flag_clip     FT_RASTER_FLAG_CLIP
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Raster_Params                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A structure to hold the arguments used by a raster's render        */
  /*    function.                                                          */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    target      :: The target bitmap.                                  */
  /*                                                                       */
  /*    source      :: A pointer to the source glyph image (e.g., an       */
  /*                   @FT_Outline).                                       */
  /*                                                                       */
  /*    flags       :: The rendering flags.                                */
  /*                                                                       */
  /*    gray_spans  :: The gray span drawing callback.                     */
  /*                                                                       */
  /*    black_spans :: Unused.                                             */
  /*                                                                       */
  /*    bit_test    :: Unused.                                             */
  /*                                                                       */
  /*    bit_set     :: Unused.                                             */
  /*                                                                       */
  /*    user        :: User-supplied data that is passed to each drawing   */
  /*                   callback.                                           */
  /*                                                                       */
  /*    clip_box    :: An optional clipping box.  It is only used in       */
  /*                   direct rendering mode.  Note that coordinates here  */
  /*                   should be expressed in _integer_ pixels (and not in */
  /*                   26.6 fixed-point units).                            */
  /*                                                                       */
  /* <Note>                                                                */
  /*    An anti-aliased glyph bitmap is drawn if the @FT_RASTER_FLAG_AA    */
  /*    bit flag is set in the `flags' field, otherwise a monochrome       */
  /*    bitmap is generated.                                               */
  /*                                                                       */
  /*    If the @FT_RASTER_FLAG_DIRECT bit flag is set in `flags', the      */
  /*    raster will call the `gray_spans' callback to draw gray pixel      */
  /*    spans.  This allows direct composition over a pre-existing bitmap  */
  /*    through user-provided callbacks to perform the span drawing and    */
  /*    composition.    Not supported by the monochrome rasterizer.        */
  /*                                                                       */
  typedef struct  FT_Raster_Params_
  {
    const FT_Bitmap*        target;
    const void*             source;
    int                     flags;
    FT_SpanFunc             gray_spans;
    FT_SpanFunc             black_spans;
    FT_Raster_BitTest_Func  bit_test;
    FT_Raster_BitSet_Func   bit_set;
    void*                   user;
    FT_BBox                 clip_box;
  } FT_Raster_Params;
  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Raster_NewFunc                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A function used to create a new raster object.                     */
  /*                                                                       */
  /* <Input>                                                               */
  /*    memory :: A handle to the memory allocator.                        */
  /*                                                                       */
  /* <Output>                                                              */
  /*    raster :: A handle to the new raster object.                       */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Error code.  0~means success.                                      */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The `memory' parameter is a typeless pointer in order to avoid     */
  /*    un-wanted dependencies on the rest of the FreeType code.  In       */
  /*    practice, it is an @FT_Memory object, i.e., a handle to the        */
  /*    standard FreeType memory allocator.  However, this field can be    */
  /*    completely ignored by a given raster implementation.               */
  /*                                                                       */
  typedef int
  (*FT_Raster_NewFunc)( void*       memory,
                        FT_Raster*  raster );
#define FT_Raster_New_Func  FT_Raster_NewFunc
  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Raster_DoneFunc                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A function used to destroy a given raster object.                  */
  /*                                                                       */
  /* <Input>                                                               */
  /*    raster :: A handle to the raster object.                           */
  /*                                                                       */
  typedef void
  (*FT_Raster_DoneFunc)( FT_Raster  raster );
#define FT_Raster_Done_Func  FT_Raster_DoneFunc
  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Raster_ResetFunc                                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*    FreeType used to provide an area of memory called the `render      */
  /*    pool' available to all registered rasters.  This was not thread    */
  /*    safe however and now FreeType never allocates this pool.  NULL     */
  /*    is always passed in as pool_base.                                  */
  /*                                                                       */
  /*    This function is called each time the render pool changes, or just */
  /*    after a new raster object is created.                              */
  /*                                                                       */
  /* <Input>                                                               */
  /*    raster    :: A handle to the new raster object.                    */
  /*                                                                       */
  /*    pool_base :: The address in memory of the render pool.             */
  /*                                                                       */
  /*    pool_size :: The size in bytes of the render pool.                 */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Rasters should ignore the render pool and rely on dynamic or stack */
  /*    allocation if they want to (a handle to the memory allocator is    */
  /*    passed to the raster constructor).                                 */
  /*                                                                       */
  typedef void
  (*FT_Raster_ResetFunc)( FT_Raster       raster,
                          unsigned char*  pool_base,
                          unsigned long   pool_size );
#define FT_Raster_Reset_Func  FT_Raster_ResetFunc
  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Raster_SetModeFunc                                              */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This function is a generic facility to change modes or attributes  */
  /*    in a given raster.  This can be used for debugging purposes, or    */
  /*    simply to allow implementation-specific `features' in a given      */
  /*    raster module.                                                     */
  /*                                                                       */
  /* <Input>                                                               */
  /*    raster :: A handle to the new raster object.                       */
  /*                                                                       */
  /*    mode   :: A 4-byte tag used to name the mode or property.          */
  /*                                                                       */
  /*    args   :: A pointer to the new mode/property to use.               */
  /*                                                                       */
  typedef int
  (*FT_Raster_SetModeFunc)( FT_Raster      raster,
                            unsigned long  mode,
                            void*          args );
#define FT_Raster_Set_Mode_Func  FT_Raster_SetModeFunc
  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Raster_RenderFunc                                               */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Invoke a given raster to scan-convert a given glyph image into a   */
  /*    target bitmap.                                                     */
  /*                                                                       */
  /* <Input>                                                               */
  /*    raster :: A handle to the raster object.                           */
  /*                                                                       */
  /*    params :: A pointer to an @FT_Raster_Params structure used to      */
  /*              store the rendering parameters.                          */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Error code.  0~means success.                                      */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The exact format of the source image depends on the raster's glyph */
  /*    format defined in its @FT_Raster_Funcs structure.  It can be an    */
  /*    @FT_Outline or anything else in order to support a large array of  */
  /*    glyph formats.                                                     */
  /*                                                                       */
  /*    Note also that the render function can fail and return a           */
  /*    `FT_Err_Unimplemented_Feature' error code if the raster used does  */
  /*    not support direct composition.                                    */
  /*                                                                       */
  /*    XXX: For now, the standard raster doesn't support direct           */
  /*         composition but this should change for the final release (see */
  /*         the files `demos/src/ftgrays.c' and `demos/src/ftgrays2.c'    */
  /*         for examples of distinct implementations that support direct  */
  /*         composition).                                                 */
  /*                                                                       */
  typedef int
  (*FT_Raster_RenderFunc)( FT_Raster                raster,
                           const FT_Raster_Params*  params );
#define FT_Raster_Render_Func  FT_Raster_RenderFunc
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Raster_Funcs                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*   A structure used to describe a given raster class to the library.   */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    glyph_format  :: The supported glyph format for this raster.       */
  /*                                                                       */
  /*    raster_new    :: The raster constructor.                           */
  /*                                                                       */
  /*    raster_reset  :: Used to reset the render pool within the raster.  */
  /*                                                                       */
  /*    raster_render :: A function to render a glyph into a given bitmap. */
  /*                                                                       */
  /*    raster_done   :: The raster destructor.                            */
  /*                                                                       */
  typedef struct  FT_Raster_Funcs_
  {
    FT_Glyph_Format        glyph_format;
    FT_Raster_NewFunc      raster_new;
    FT_Raster_ResetFunc    raster_reset;
    FT_Raster_SetModeFunc  raster_set_mode;
    FT_Raster_RenderFunc   raster_render;
    FT_Raster_DoneFunc     raster_done;
  } FT_Raster_Funcs;
  /* */
FT_END_HEADER
#endif
/* END */
/* Local Variables: */
/* coding: utf-8    */
/* End:             */
FT_BEGIN_HEADER
  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    basic_types                                                        */
  /*                                                                       */
  /* <Title>                                                               */
  /*    Basic Data Types                                                   */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*    The basic data types defined by the library.                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This section contains the basic data types defined by FreeType~2,  */
  /*    ranging from simple scalar types to bitmap descriptors.  More      */
  /*    font-specific structures are defined in a different section.       */
  /*                                                                       */
  /* <Order>                                                               */
  /*    FT_Byte                                                            */
  /*    FT_Bytes                                                           */
  /*    FT_Char                                                            */
  /*    FT_Int                                                             */
  /*    FT_UInt                                                            */
  /*    FT_Int16                                                           */
  /*    FT_UInt16                                                          */
  /*    FT_Int32                                                           */
  /*    FT_UInt32                                                          */
  /*    FT_Int64                                                           */
  /*    FT_UInt64                                                          */
  /*    FT_Short                                                           */
  /*    FT_UShort                                                          */
  /*    FT_Long                                                            */
  /*    FT_ULong                                                           */
  /*    FT_Bool                                                            */
  /*    FT_Offset                                                          */
  /*    FT_PtrDist                                                         */
  /*    FT_String                                                          */
  /*    FT_Tag                                                             */
  /*    FT_Error                                                           */
  /*    FT_Fixed                                                           */
  /*    FT_Pointer                                                         */
  /*    FT_Pos                                                             */
  /*    FT_Vector                                                          */
  /*    FT_BBox                                                            */
  /*    FT_Matrix                                                          */
  /*    FT_FWord                                                           */
  /*    FT_UFWord                                                          */
  /*    FT_F2Dot14                                                         */
  /*    FT_UnitVector                                                      */
  /*    FT_F26Dot6                                                         */
  /*    FT_Data                                                            */
  /*                                                                       */
  /*    FT_MAKE_TAG                                                        */
  /*                                                                       */
  /*    FT_Generic                                                         */
  /*    FT_Generic_Finalizer                                               */
  /*                                                                       */
  /*    FT_Bitmap                                                          */
  /*    FT_Pixel_Mode                                                      */
  /*    FT_Palette_Mode                                                    */
  /*    FT_Glyph_Format                                                    */
  /*    FT_IMAGE_TAG                                                       */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Bool                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef of unsigned char, used for simple booleans.  As usual,   */
  /*    values 1 and~0 represent true and false, respectively.             */
  /*                                                                       */
  typedef unsigned char  FT_Bool;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_FWord                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A signed 16-bit integer used to store a distance in original font  */
  /*    units.                                                             */
  /*                                                                       */
  typedef signed short  FT_FWord;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_UFWord                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    An unsigned 16-bit integer used to store a distance in original    */
  /*    font units.                                                        */
  /*                                                                       */
  typedef unsigned short  FT_UFWord;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Char                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A simple typedef for the _signed_ char type.                       */
  /*                                                                       */
  typedef signed char  FT_Char;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Byte                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A simple typedef for the _unsigned_ char type.                     */
  /*                                                                       */
  typedef unsigned char  FT_Byte;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Bytes                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for constant memory areas.                               */
  /*                                                                       */
  typedef const FT_Byte*  FT_Bytes;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Tag                                                             */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for 32-bit tags (as used in the SFNT format).            */
  /*                                                                       */
  typedef FT_UInt32  FT_Tag;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_String                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A simple typedef for the char type, usually used for strings.      */
  /*                                                                       */
  typedef char  FT_String;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Short                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for signed short.                                        */
  /*                                                                       */
  typedef signed short  FT_Short;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_UShort                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for unsigned short.                                      */
  /*                                                                       */
  typedef unsigned short  FT_UShort;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Int                                                             */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for the int type.                                        */
  /*                                                                       */
  typedef signed int  FT_Int;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_UInt                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for the unsigned int type.                               */
  /*                                                                       */
  typedef unsigned int  FT_UInt;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Long                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for signed long.                                         */
  /*                                                                       */
  typedef signed long  FT_Long;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_ULong                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for unsigned long.                                       */
  /*                                                                       */
  typedef unsigned long  FT_ULong;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_F2Dot14                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A signed 2.14 fixed-point type used for unit vectors.              */
  /*                                                                       */
  typedef signed short  FT_F2Dot14;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_F26Dot6                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A signed 26.6 fixed-point type used for vectorial pixel            */
  /*    coordinates.                                                       */
  /*                                                                       */
  typedef signed long  FT_F26Dot6;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Fixed                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This type is used to store 16.16 fixed-point values, like scaling  */
  /*    values or matrix coefficients.                                     */
  /*                                                                       */
  typedef signed long  FT_Fixed;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Error                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The FreeType error code type.  A value of~0 is always interpreted  */
  /*    as a successful operation.                                         */
  /*                                                                       */
  typedef int  FT_Error;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Pointer                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A simple typedef for a typeless pointer.                           */
  /*                                                                       */
  typedef void*  FT_Pointer;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Offset                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This is equivalent to the ANSI~C `size_t' type, i.e., the largest  */
  /*    _unsigned_ integer type used to express a file size or position,   */
  /*    or a memory block size.                                            */
  /*                                                                       */
  typedef size_t  FT_Offset;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_PtrDist                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This is equivalent to the ANSI~C `ptrdiff_t' type, i.e., the       */
  /*    largest _signed_ integer type used to express the distance         */
  /*    between two pointers.                                              */
  /*                                                                       */
  typedef ft_ptrdiff_t  FT_PtrDist;
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_UnitVector                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A simple structure used to store a 2D vector unit vector.  Uses    */
  /*    FT_F2Dot14 types.                                                  */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    x :: Horizontal coordinate.                                        */
  /*                                                                       */
  /*    y :: Vertical coordinate.                                          */
  /*                                                                       */
  typedef struct  FT_UnitVector_
  {
    FT_F2Dot14  x;
    FT_F2Dot14  y;
  } FT_UnitVector;
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Matrix                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A simple structure used to store a 2x2 matrix.  Coefficients are   */
  /*    in 16.16 fixed-point format.  The computation performed is:        */
  /*                                                                       */
  /*       {                                                               */
  /*          x' = x*xx + y*xy                                             */
  /*          y' = x*yx + y*yy                                             */
  /*       }                                                               */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    xx :: Matrix coefficient.                                          */
  /*                                                                       */
  /*    xy :: Matrix coefficient.                                          */
  /*                                                                       */
  /*    yx :: Matrix coefficient.                                          */
  /*                                                                       */
  /*    yy :: Matrix coefficient.                                          */
  /*                                                                       */
  typedef struct  FT_Matrix_
  {
    FT_Fixed  xx, xy;
    FT_Fixed  yx, yy;
  } FT_Matrix;
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Data                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Read-only binary data represented as a pointer and a length.       */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    pointer :: The data.                                               */
  /*                                                                       */
  /*    length  :: The length of the data in bytes.                        */
  /*                                                                       */
  typedef struct  FT_Data_
  {
    const FT_Byte*  pointer;
    FT_Int          length;
  } FT_Data;
  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Generic_Finalizer                                               */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Describe a function used to destroy the `client' data of any       */
  /*    FreeType object.  See the description of the @FT_Generic type for  */
  /*    details of usage.                                                  */
  /*                                                                       */
  /* <Input>                                                               */
  /*    The address of the FreeType object that is under finalization.     */
  /*    Its client data is accessed through its `generic' field.           */
  /*                                                                       */
  typedef void  (*FT_Generic_Finalizer)(void*  object);
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Generic                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Client applications often need to associate their own data to a    */
  /*    variety of FreeType core objects.  For example, a text layout API  */
  /*    might want to associate a glyph cache to a given size object.      */
  /*                                                                       */
  /*    Some FreeType object contains a `generic' field, of type           */
  /*    FT_Generic, which usage is left to client applications and font    */
  /*    servers.                                                           */
  /*                                                                       */
  /*    It can be used to store a pointer to client-specific data, as well */
  /*    as the address of a `finalizer' function, which will be called by  */
  /*    FreeType when the object is destroyed (for example, the previous   */
  /*    client example would put the address of the glyph cache destructor */
  /*    in the `finalizer' field).                                         */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    data      :: A typeless pointer to any client-specified data. This */
  /*                 field is completely ignored by the FreeType library.  */
  /*                                                                       */
  /*    finalizer :: A pointer to a `generic finalizer' function, which    */
  /*                 will be called when the object is destroyed.  If this */
  /*                 field is set to NULL, no code will be called.         */
  /*                                                                       */
  typedef struct  FT_Generic_
  {
    void*                 data;
    FT_Generic_Finalizer  finalizer;
  } FT_Generic;
  /*************************************************************************/
  /*                                                                       */
  /* <Macro>                                                               */
  /*    FT_MAKE_TAG                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This macro converts four-letter tags that are used to label        */
  /*    TrueType tables into an unsigned long, to be used within FreeType. */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The produced values *must* be 32-bit integers.  Don't redefine     */
  /*    this macro.                                                        */
  /*                                                                       */
#define FT_MAKE_TAG( _x1, _x2, _x3, _x4 )           (FT_Tag)                                  ( ( (FT_ULong)_x1 << 24 ) |                 ( (FT_ULong)_x2 << 16 ) |                 ( (FT_ULong)_x3 <<  8 ) |                   (FT_ULong)_x4         )
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /*                    L I S T   M A N A G E M E N T                      */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    list_processing                                                    */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_ListNode                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*     Many elements and objects in FreeType are listed through an       */
  /*     @FT_List record (see @FT_ListRec).  As its name suggests, an      */
  /*     FT_ListNode is a handle to a single list element.                 */
  /*                                                                       */
  typedef struct FT_ListNodeRec_*  FT_ListNode;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_List                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a list record (see @FT_ListRec).                       */
  /*                                                                       */
  typedef struct FT_ListRec_*  FT_List;
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_ListNodeRec                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A structure used to hold a single list element.                    */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    prev :: The previous element in the list.  NULL if first.          */
  /*                                                                       */
  /*    next :: The next element in the list.  NULL if last.               */
  /*                                                                       */
  /*    data :: A typeless pointer to the listed object.                   */
  /*                                                                       */
  typedef struct  FT_ListNodeRec_
  {
    FT_ListNode  prev;
    FT_ListNode  next;
    void*        data;
  } FT_ListNodeRec;
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_ListRec                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A structure used to hold a simple doubly-linked list.  These are   */
  /*    used in many parts of FreeType.                                    */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    head :: The head (first element) of doubly-linked list.            */
  /*                                                                       */
  /*    tail :: The tail (last element) of doubly-linked list.             */
  /*                                                                       */
  typedef struct  FT_ListRec_
  {
    FT_ListNode  head;
    FT_ListNode  tail;
  } FT_ListRec;
  /* */
#define FT_IS_EMPTY( list )  ( (list).head == 0 )
#define FT_BOOL( x )  ( (FT_Bool)( x ) )
  /* concatenate C tokens */
#define FT_ERR_XCAT( x, y )  x ## y
#define FT_ERR_CAT( x, y )   FT_ERR_XCAT( x, y )
  /* see `ftmoderr.h' for descriptions of the following macros */
#define FT_ERR( e )  FT_ERR_CAT( FT_ERR_PREFIX, e )
#define FT_ERROR_BASE( x )    ( (x) & 0xFF )
#define FT_ERROR_MODULE( x )  ( (x) & 0xFF00U )
#define FT_ERR_EQ( x, e )                                                  ( FT_ERROR_BASE( x ) == FT_ERROR_BASE( FT_ERR( e ) ) )
#define FT_ERR_NEQ( x, e )                                                 ( FT_ERROR_BASE( x ) != FT_ERROR_BASE( FT_ERR( e ) ) )
FT_END_HEADER
#endif
/* END */
/***************************************************************************/
/*                                                                         */
/*  fterrors.h                                                             */
/*                                                                         */
/*    FreeType error code handling (specification).                        */
/*                                                                         */
/*  Copyright 1996-2017 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*   error_enumerations                                                  */
  /*                                                                       */
  /* <Title>                                                               */
  /*   Error Enumerations                                                  */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*   How to handle errors and error strings.                             */
  /*                                                                       */
  /* <Description>                                                         */
  /*   The header file `fterrors.h' (which is automatically included by    */
  /*   `freetype.h' defines the handling of FreeType's enumeration         */
  /*   constants.  It can also be used to generate error message strings   */
  /*   with a small macro trick explained below.                           */
  /*                                                                       */
  /*   *Error* *Formats*                                                   */
  /*                                                                       */
  /*   The configuration macro FT_CONFIG_OPTION_USE_MODULE_ERRORS can be   */
  /*   defined in `ftoption.h' in order to make the higher byte indicate   */
  /*   the module where the error has happened (this is not compatible     */
  /*   with standard builds of FreeType&nbsp;2, however).  See the file    */
  /*   `ftmoderr.h' for more details.                                      */
  /*                                                                       */
  /*   *Error* *Message* *Strings*                                         */
  /*                                                                       */
  /*   Error definitions are set up with special macros that allow client  */
  /*   applications to build a table of error message strings.  The        */
  /*   strings are not included in a normal build of FreeType&nbsp;2 to    */
  /*   save space (most client applications do not use them).              */
  /*                                                                       */
  /*   To do so, you have to define the following macros before including  */
  /*   this file.                                                          */
  /*                                                                       */
  /*   {                                                                   */
  /*     FT_ERROR_START_LIST                                               */
  /*   }                                                                   */
  /*                                                                       */
  /*   This macro is called before anything else to define the start of    */
  /*   the error list.  It is followed by several FT_ERROR_DEF calls.      */
  /*                                                                       */
  /*   {                                                                   */
  /*     FT_ERROR_DEF( e, v, s )                                           */
  /*   }                                                                   */
  /*                                                                       */
  /*   This macro is called to define one single error.  `e' is the error  */
  /*   code identifier (e.g., `Invalid_Argument'), `v' is the error's      */
  /*   numerical value, and `s' is the corresponding error string.         */
  /*                                                                       */
  /*   {                                                                   */
  /*     FT_ERROR_END_LIST                                                 */
  /*   }                                                                   */
  /*                                                                       */
  /*   This macro ends the list.                                           */
  /*                                                                       */
  /*   Additionally, you have to undefine `FTERRORS_H_' before #including  */
  /*   this file.                                                          */
  /*                                                                       */
  /*   Here is a simple example.                                           */
  /*                                                                       */
  /*   {                                                                   */
  /*     #undef FTERRORS_H_                                                */
  /*     #define FT_ERRORDEF( e, v, s )  { e, s },                         */
  /*     #define FT_ERROR_START_LIST     {                                 */
  /*     #define FT_ERROR_END_LIST       { 0, NULL } };                    */
  /*                                                                       */
  /*     const struct                                                      */
  /*     {                                                                 */
  /*       int          err_code;                                          */
  /*       const char*  err_msg;                                           */
  /*     } ft_errors[] =                                                   */
  /*                                                                       */
  /*     #include FT_ERRORS_H                                              */
  /*   }                                                                   */
  /*                                                                       */
  /*   Note that `FT_Err_Ok' is _not_ defined with `FT_ERRORDEF' but with  */
  /*   `FT_NOERRORDEF'; it is always zero.                                 */
  /*                                                                       */
  /*************************************************************************/
  /* */
  /* In previous FreeType versions we used `__FTERRORS_H__'.  However, */
  /* using two successive underscores in a non-system symbol name      */
  /* violates the C (and C++) standard, so it was changed to the       */
  /* current form.  In spite of this, we have to make                  */
  /*                                                                   */
  /*   #undefine __FTERRORS_H__                                        */
  /*                                                                   */
  /* work for backward compatibility.                                  */
  /*                                                                   */
#if !( defined( FTERRORS_H_ ) && defined ( __FTERRORS_H__ ) )
#define FTERRORS_H_
#define __FTERRORS_H__
  /* include module base error codes */
/***************************************************************************/
/*                                                                         */
/*  ftmoderr.h                                                             */
/*                                                                         */
/*    FreeType module error offsets (specification).                       */
/*                                                                         */
/*  Copyright 2001-2017 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* This file is used to define the FreeType module error codes.          */
  /*                                                                       */
  /* If the macro FT_CONFIG_OPTION_USE_MODULE_ERRORS in `ftoption.h' is    */
  /* set, the lower byte of an error value identifies the error code as    */
  /* usual.  In addition, the higher byte identifies the module.  For      */
  /* example, the error `FT_Err_Invalid_File_Format' has value 0x0003, the */
  /* error `TT_Err_Invalid_File_Format' has value 0x1303, the error        */
  /* `T1_Err_Invalid_File_Format' has value 0x1403, etc.                   */
  /*                                                                       */
  /* Note that `FT_Err_Ok', `TT_Err_Ok', etc. are always equal to zero,    */
  /* including the high byte.                                              */
  /*                                                                       */
  /* If FT_CONFIG_OPTION_USE_MODULE_ERRORS isn't set, the higher byte of   */
  /* an error value is set to zero.                                        */
  /*                                                                       */
  /* To hide the various `XXX_Err_' prefixes in the source code, FreeType  */
  /* provides some macros in `fttypes.h'.                                  */
  /*                                                                       */
  /*   FT_ERR( err )                                                       */
  /*     Add current error module prefix (as defined with the              */
  /*     `FT_ERR_PREFIX' macro) to `err'.  For example, in the BDF module  */
  /*     the line                                                          */
  /*                                                                       */
  /*       error = FT_ERR( Invalid_Outline );                              */
  /*                                                                       */
  /*     expands to                                                        */
  /*                                                                       */
  /*       error = BDF_Err_Invalid_Outline;                                */
  /*                                                                       */
  /*     For simplicity, you can always use `FT_Err_Ok' directly instead   */
  /*     of `FT_ERR( Ok )'.                                                */
  /*                                                                       */
  /*   FT_ERR_EQ( errcode, err )                                           */
  /*   FT_ERR_NEQ( errcode, err )                                          */
  /*     Compare error code `errcode' with the error `err' for equality    */
  /*     and inequality, respectively.  Example:                           */
  /*                                                                       */
  /*       if ( FT_ERR_EQ( error, Invalid_Outline ) )                      */
  /*         ...                                                           */
  /*                                                                       */
  /*     Using this macro you don't have to think about error prefixes.    */
  /*     Of course, if module errors are not active, the above example is  */
  /*     the same as                                                       */
  /*                                                                       */
  /*       if ( error == FT_Err_Invalid_Outline )                          */
  /*         ...                                                           */
  /*                                                                       */
  /*   FT_ERROR_BASE( errcode )                                            */
  /*   FT_ERROR_MODULE( errcode )                                          */
  /*     Get base error and module error code, respectively.               */
  /*                                                                       */
  /*                                                                       */
  /* It can also be used to create a module error message table easily     */
  /* with something like                                                   */
  /*                                                                       */
  /*   {                                                                   */
  /*     #undef FTMODERR_H_                                                */
  /*     #define FT_MODERRDEF( e, v, s )  { FT_Mod_Err_ ## e, s },         */
  /*     #define FT_MODERR_START_LIST     {                                */
  /*     #define FT_MODERR_END_LIST       { 0, 0 } };                      */
  /*                                                                       */
  /*     const struct                                                      */
  /*     {                                                                 */
  /*       int          mod_err_offset;                                    */
  /*       const char*  mod_err_msg                                        */
  /*     } ft_mod_errors[] =                                               */
  /*                                                                       */
  /*     #include FT_MODULE_ERRORS_H                                       */
  /*   }                                                                   */
  /*                                                                       */
  /*************************************************************************/
#ifndef FTMODERR_H_
#define FTMODERR_H_
  /*******************************************************************/
  /*******************************************************************/
  /*****                                                         *****/
  /*****                       SETUP MACROS                      *****/
  /*****                                                         *****/
  /*******************************************************************/
  /*******************************************************************/
#undef  FT_NEED_EXTERN_C
#ifndef FT_MODERRDEF
#ifdef FT_CONFIG_OPTION_USE_MODULE_ERRORS
#define FT_MODERRDEF( e, v, s )  FT_Mod_Err_ ## e = v,
#else
#define FT_MODERRDEF( e, v, s )  FT_Mod_Err_ ## e = 0,
#endif
#define FT_MODERR_START_LIST  enum {
#define FT_MODERR_END_LIST    FT_Mod_Err_Max };
#ifdef __cplusplus
#define FT_NEED_EXTERN_C
  extern "C" {
#endif
#endif
  /*******************************************************************/
  /*******************************************************************/
  /*****                                                         *****/
  /*****               LIST MODULE ERROR BASES                   *****/
  /*****                                                         *****/
  /*******************************************************************/
  /*******************************************************************/
#ifdef FT_MODERR_START_LIST
  FT_MODERR_START_LIST
#endif
  FT_MODERRDEF( Base,      0x000, "base module" )
  FT_MODERRDEF( Autofit,   0x100, "autofitter module" )
  FT_MODERRDEF( BDF,       0x200, "BDF module" )
  FT_MODERRDEF( Bzip2,     0x300, "Bzip2 module" )
  FT_MODERRDEF( Cache,     0x400, "cache module" )
  FT_MODERRDEF( CFF,       0x500, "CFF module" )
  FT_MODERRDEF( CID,       0x600, "CID module" )
  FT_MODERRDEF( Gzip,      0x700, "Gzip module" )
  FT_MODERRDEF( LZW,       0x800, "LZW module" )
  FT_MODERRDEF( OTvalid,   0x900, "OpenType validation module" )
  FT_MODERRDEF( PCF,       0xA00, "PCF module" )
  FT_MODERRDEF( PFR,       0xB00, "PFR module" )
  FT_MODERRDEF( PSaux,     0xC00, "PS auxiliary module" )
  FT_MODERRDEF( PShinter,  0xD00, "PS hinter module" )
  FT_MODERRDEF( PSnames,   0xE00, "PS names module" )
  FT_MODERRDEF( Raster,    0xF00, "raster module" )
  FT_MODERRDEF( SFNT,     0x1000, "SFNT module" )
  FT_MODERRDEF( Smooth,   0x1100, "smooth raster module" )
  FT_MODERRDEF( TrueType, 0x1200, "TrueType module" )
  FT_MODERRDEF( Type1,    0x1300, "Type 1 module" )
  FT_MODERRDEF( Type42,   0x1400, "Type 42 module" )
  FT_MODERRDEF( Winfonts, 0x1500, "Windows FON/FNT module" )
  FT_MODERRDEF( GXvalid,  0x1600, "GX validation module" )
#ifdef FT_MODERR_END_LIST
  FT_MODERR_END_LIST
#endif
  /*******************************************************************/
  /*******************************************************************/
  /*****                                                         *****/
  /*****                      CLEANUP                            *****/
  /*****                                                         *****/
  /*******************************************************************/
  /*******************************************************************/
#ifdef FT_NEED_EXTERN_C
  }
#endif
#undef FT_MODERR_START_LIST
#undef FT_MODERR_END_LIST
#undef FT_MODERRDEF
#undef FT_NEED_EXTERN_C
#endif
/* END */
  /*******************************************************************/
  /*******************************************************************/
  /*****                                                         *****/
  /*****                       SETUP MACROS                      *****/
  /*****                                                         *****/
  /*******************************************************************/
  /*******************************************************************/
#undef  FT_NEED_EXTERN_C
  /* FT_ERR_PREFIX is used as a prefix for error identifiers. */
  /* By default, we use `FT_Err_'.                            */
  /*                                                          */
#ifndef FT_ERR_PREFIX
#define FT_ERR_PREFIX  FT_Err_
#endif
  /* FT_ERR_BASE is used as the base for module-specific errors. */
  /*                                                             */
#ifdef FT_CONFIG_OPTION_USE_MODULE_ERRORS
#ifndef FT_ERR_BASE
#define FT_ERR_BASE  FT_Mod_Err_Base
#endif
#else
#undef FT_ERR_BASE
#define FT_ERR_BASE  0
#endif
  /* If FT_ERRORDEF is not defined, we need to define a simple */
  /* enumeration type.                                         */
  /*                                                           */
#ifndef FT_ERRORDEF
#define FT_ERRORDEF( e, v, s )  e = v,
#define FT_ERROR_START_LIST     enum {
#define FT_ERROR_END_LIST       FT_ERR_CAT( FT_ERR_PREFIX, Max ) };
#ifdef __cplusplus
#define FT_NEED_EXTERN_C
  extern "C" {
#endif
#endif
  /* this macro is used to define an error */
#define FT_ERRORDEF_( e, v, s )                                                       FT_ERRORDEF( FT_ERR_CAT( FT_ERR_PREFIX, e ), v + FT_ERR_BASE, s )
  /* this is only used for <module>_Err_Ok, which must be 0! */
#define FT_NOERRORDEF_( e, v, s )                                       FT_ERRORDEF( FT_ERR_CAT( FT_ERR_PREFIX, e ), v, s )
#ifdef FT_ERROR_START_LIST
  FT_ERROR_START_LIST
#endif
  /* now include the error codes */
/***************************************************************************/
/*                                                                         */
/*  fterrdef.h                                                             */
/*                                                                         */
/*    FreeType error codes (specification).                                */
/*                                                                         */
/*  Copyright 2002-2017 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*   error_code_values                                                   */
  /*                                                                       */
  /* <Title>                                                               */
  /*   Error Code Values                                                   */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*   All possible error codes returned by FreeType functions.            */
  /*                                                                       */
  /* <Description>                                                         */
  /*   The list below is taken verbatim from the file `fterrdef.h'         */
  /*   (loaded automatically by including `FT_FREETYPE_H').  The first     */
  /*   argument of the `FT_ERROR_DEF_' macro is the error label; by        */
  /*   default, the prefix `FT_Err_' gets added so that you get error      */
  /*   names like `FT_Err_Cannot_Open_Resource'.  The second argument is   */
  /*   the error code, and the last argument an error string, which is not */
  /*   used by FreeType.                                                   */
  /*                                                                       */
  /*   Within your application you should *only* use error names and       */
  /*   *never* its numeric values!  The latter might (and actually do)     */
  /*   change in forthcoming FreeType versions.                            */
  /*                                                                       */
  /*   Macro `FT_NOERRORDEF_' defines `FT_Err_Ok', which is always zero.   */
  /*   See the `Error Enumerations' subsection how to automatically        */
  /*   generate a list of error strings.                                   */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_Err_XXX                                                         */
  /*                                                                       */
  /*************************************************************************/
  /* generic errors */
  FT_NOERRORDEF_( Ok,                                        0x00,
                  "no error" )
  FT_ERRORDEF_( Cannot_Open_Resource,                        0x01,
                "cannot open resource" )
  FT_ERRORDEF_( Unknown_File_Format,                         0x02,
                "unknown file format" )
  FT_ERRORDEF_( Invalid_File_Format,                         0x03,
                "broken file" )
  FT_ERRORDEF_( Invalid_Version,                             0x04,
                "invalid FreeType version" )
  FT_ERRORDEF_( Lower_Module_Version,                        0x05,
                "module version is too low" )
  FT_ERRORDEF_( Invalid_Argument,                            0x06,
                "invalid argument" )
  FT_ERRORDEF_( Unimplemented_Feature,                       0x07,
                "unimplemented feature" )
  FT_ERRORDEF_( Invalid_Table,                               0x08,
                "broken table" )
  FT_ERRORDEF_( Invalid_Offset,                              0x09,
                "broken offset within table" )
  FT_ERRORDEF_( Array_Too_Large,                             0x0A,
                "array allocation size too large" )
  FT_ERRORDEF_( Missing_Module,                              0x0B,
                "missing module" )
  FT_ERRORDEF_( Missing_Property,                            0x0C,
                "missing property" )
  /* glyph/character errors */
  FT_ERRORDEF_( Invalid_Glyph_Index,                         0x10,
                "invalid glyph index" )
  FT_ERRORDEF_( Invalid_Character_Code,                      0x11,
                "invalid character code" )
  FT_ERRORDEF_( Invalid_Glyph_Format,                        0x12,
                "unsupported glyph image format" )
  FT_ERRORDEF_( Cannot_Render_Glyph,                         0x13,
                "cannot render this glyph format" )
  FT_ERRORDEF_( Invalid_Outline,                             0x14,
                "invalid outline" )
  FT_ERRORDEF_( Invalid_Composite,                           0x15,
                "invalid composite glyph" )
  FT_ERRORDEF_( Too_Many_Hints,                              0x16,
                "too many hints" )
  FT_ERRORDEF_( Invalid_Pixel_Size,                          0x17,
                "invalid pixel size" )
  /* handle errors */
  FT_ERRORDEF_( Invalid_Handle,                              0x20,
                "invalid object handle" )
  FT_ERRORDEF_( Invalid_Library_Handle,                      0x21,
                "invalid library handle" )
  FT_ERRORDEF_( Invalid_Driver_Handle,                       0x22,
                "invalid module handle" )
  FT_ERRORDEF_( Invalid_Face_Handle,                         0x23,
                "invalid face handle" )
  FT_ERRORDEF_( Invalid_Size_Handle,                         0x24,
                "invalid size handle" )
  FT_ERRORDEF_( Invalid_Slot_Handle,                         0x25,
                "invalid glyph slot handle" )
  FT_ERRORDEF_( Invalid_CharMap_Handle,                      0x26,
                "invalid charmap handle" )
  FT_ERRORDEF_( Invalid_Cache_Handle,                        0x27,
                "invalid cache manager handle" )
  FT_ERRORDEF_( Invalid_Stream_Handle,                       0x28,
                "invalid stream handle" )
  /* driver errors */
  FT_ERRORDEF_( Too_Many_Drivers,                            0x30,
                "too many modules" )
  FT_ERRORDEF_( Too_Many_Extensions,                         0x31,
                "too many extensions" )
  /* memory errors */
  FT_ERRORDEF_( Out_Of_Memory,                               0x40,
                "out of memory" )
  FT_ERRORDEF_( Unlisted_Object,                             0x41,
                "unlisted object" )
  /* stream errors */
  FT_ERRORDEF_( Cannot_Open_Stream,                          0x51,
                "cannot open stream" )
  FT_ERRORDEF_( Invalid_Stream_Seek,                         0x52,
                "invalid stream seek" )
  FT_ERRORDEF_( Invalid_Stream_Skip,                         0x53,
                "invalid stream skip" )
  FT_ERRORDEF_( Invalid_Stream_Read,                         0x54,
                "invalid stream read" )
  FT_ERRORDEF_( Invalid_Stream_Operation,                    0x55,
                "invalid stream operation" )
  FT_ERRORDEF_( Invalid_Frame_Operation,                     0x56,
                "invalid frame operation" )
  FT_ERRORDEF_( Nested_Frame_Access,                         0x57,
                "nested frame access" )
  FT_ERRORDEF_( Invalid_Frame_Read,                          0x58,
                "invalid frame read" )
  /* raster errors */
  FT_ERRORDEF_( Raster_Uninitialized,                        0x60,
                "raster uninitialized" )
  FT_ERRORDEF_( Raster_Corrupted,                            0x61,
                "raster corrupted" )
  FT_ERRORDEF_( Raster_Overflow,                             0x62,
                "raster overflow" )
  FT_ERRORDEF_( Raster_Negative_Height,                      0x63,
                "negative height while rastering" )
  /* cache errors */
  FT_ERRORDEF_( Too_Many_Caches,                             0x70,
                "too many registered caches" )
  /* TrueType and SFNT errors */
  FT_ERRORDEF_( Invalid_Opcode,                              0x80,
                "invalid opcode" )
  FT_ERRORDEF_( Too_Few_Arguments,                           0x81,
                "too few arguments" )
  FT_ERRORDEF_( Stack_Overflow,                              0x82,
                "stack overflow" )
  FT_ERRORDEF_( Code_Overflow,                               0x83,
                "code overflow" )
  FT_ERRORDEF_( Bad_Argument,                                0x84,
                "bad argument" )
  FT_ERRORDEF_( Divide_By_Zero,                              0x85,
                "division by zero" )
  FT_ERRORDEF_( Invalid_Reference,                           0x86,
                "invalid reference" )
  FT_ERRORDEF_( Debug_OpCode,                                0x87,
                "found debug opcode" )
  FT_ERRORDEF_( ENDF_In_Exec_Stream,                         0x88,
                "found ENDF opcode in execution stream" )
  FT_ERRORDEF_( Nested_DEFS,                                 0x89,
                "nested DEFS" )
  FT_ERRORDEF_( Invalid_CodeRange,                           0x8A,
                "invalid code range" )
  FT_ERRORDEF_( Execution_Too_Long,                          0x8B,
                "execution context too long" )
  FT_ERRORDEF_( Too_Many_Function_Defs,                      0x8C,
                "too many function definitions" )
  FT_ERRORDEF_( Too_Many_Instruction_Defs,                   0x8D,
                "too many instruction definitions" )
  FT_ERRORDEF_( Table_Missing,                               0x8E,
                "SFNT font table missing" )
  FT_ERRORDEF_( Horiz_Header_Missing,                        0x8F,
                "horizontal header (hhea) table missing" )
  FT_ERRORDEF_( Locations_Missing,                           0x90,
                "locations (loca) table missing" )
  FT_ERRORDEF_( Name_Table_Missing,                          0x91,
                "name table missing" )
  FT_ERRORDEF_( CMap_Table_Missing,                          0x92,
                "character map (cmap) table missing" )
  FT_ERRORDEF_( Hmtx_Table_Missing,                          0x93,
                "horizontal metrics (hmtx) table missing" )
  FT_ERRORDEF_( Post_Table_Missing,                          0x94,
                "PostScript (post) table missing" )
  FT_ERRORDEF_( Invalid_Horiz_Metrics,                       0x95,
                "invalid horizontal metrics" )
  FT_ERRORDEF_( Invalid_CharMap_Format,                      0x96,
                "invalid character map (cmap) format" )
  FT_ERRORDEF_( Invalid_PPem,                                0x97,
                "invalid ppem value" )
  FT_ERRORDEF_( Invalid_Vert_Metrics,                        0x98,
                "invalid vertical metrics" )
  FT_ERRORDEF_( Could_Not_Find_Context,                      0x99,
                "could not find context" )
  FT_ERRORDEF_( Invalid_Post_Table_Format,                   0x9A,
                "invalid PostScript (post) table format" )
  FT_ERRORDEF_( Invalid_Post_Table,                          0x9B,
                "invalid PostScript (post) table" )
  FT_ERRORDEF_( DEF_In_Glyf_Bytecode,                        0x9C,
                "found FDEF or IDEF opcode in glyf bytecode" )
  /* CFF, CID, and Type 1 errors */
  FT_ERRORDEF_( Syntax_Error,                                0xA0,
                "opcode syntax error" )
  FT_ERRORDEF_( Stack_Underflow,                             0xA1,
                "argument stack underflow" )
  FT_ERRORDEF_( Ignore,                                      0xA2,
                "ignore" )
  FT_ERRORDEF_( No_Unicode_Glyph_Name,                       0xA3,
                "no Unicode glyph name found" )
  FT_ERRORDEF_( Glyph_Too_Big,                               0xA4,
                "glyph too big for hinting" )
  /* BDF errors */
  FT_ERRORDEF_( Missing_Startfont_Field,                     0xB0,
                "`STARTFONT' field missing" )
  FT_ERRORDEF_( Missing_Font_Field,                          0xB1,
                "`FONT' field missing" )
  FT_ERRORDEF_( Missing_Size_Field,                          0xB2,
                "`SIZE' field missing" )
  FT_ERRORDEF_( Missing_Fontboundingbox_Field,               0xB3,
                "`FONTBOUNDINGBOX' field missing" )
  FT_ERRORDEF_( Missing_Chars_Field,                         0xB4,
                "`CHARS' field missing" )
  FT_ERRORDEF_( Missing_Startchar_Field,                     0xB5,
                "`STARTCHAR' field missing" )
  FT_ERRORDEF_( Missing_Encoding_Field,                      0xB6,
                "`ENCODING' field missing" )
  FT_ERRORDEF_( Missing_Bbx_Field,                           0xB7,
                "`BBX' field missing" )
  FT_ERRORDEF_( Bbx_Too_Big,                                 0xB8,
                "`BBX' too big" )
  FT_ERRORDEF_( Corrupted_Font_Header,                       0xB9,
                "Font header corrupted or missing fields" )
  FT_ERRORDEF_( Corrupted_Font_Glyphs,                       0xBA,
                "Font glyphs corrupted or missing fields" )
  /* */
/* END */
#ifdef FT_ERROR_END_LIST
  FT_ERROR_END_LIST
#endif
  /*******************************************************************/
  /*******************************************************************/
  /*****                                                         *****/
  /*****                      SIMPLE CLEANUP                     *****/
  /*****                                                         *****/
  /*******************************************************************/
  /*******************************************************************/
#ifdef FT_NEED_EXTERN_C
  }
#endif
#undef FT_ERROR_START_LIST
#undef FT_ERROR_END_LIST
#undef FT_ERRORDEF
#undef FT_ERRORDEF_
#undef FT_NOERRORDEF_
#undef FT_NEED_EXTERN_C
#undef FT_ERR_BASE
  /* FT_ERR_PREFIX is needed internally */
#ifndef FT2_BUILD_LIBRARY
#undef FT_ERR_PREFIX
#endif
#endif
/* END */
FT_BEGIN_HEADER
  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    header_inclusion                                                   */
  /*                                                                       */
  /* <Title>                                                               */
  /*    FreeType's header inclusion scheme                                 */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*    How client applications should include FreeType header files.      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    To be as flexible as possible (and for historical reasons),        */
  /*    FreeType uses a very special inclusion scheme to load header       */
  /*    files, for example                                                 */
  /*                                                                       */
  /*    {                                                                  */
  /*      #include <ft2build.h>                                            */
  /*                                                                       */
  /*      #include FT_FREETYPE_H                                           */
  /*      #include FT_OUTLINE_H                                            */
  /*    }                                                                  */
  /*                                                                       */
  /*    A compiler and its preprocessor only needs an include path to find */
  /*    the file `ft2build.h'; the exact locations and names of the other  */
  /*    FreeType header files are hidden by preprocessor macro names,      */
  /*    loaded by `ft2build.h'.  The API documentation always gives the    */
  /*    header macro name needed for a particular function.                */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    user_allocation                                                    */
  /*                                                                       */
  /* <Title>                                                               */
  /*    User allocation                                                    */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*    How client applications should allocate FreeType data structures.  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    FreeType assumes that structures allocated by the user and passed  */
  /*    as arguments are zeroed out except for the actual data.  In other  */
  /*    words, it is recommended to use `calloc' (or variants of it)       */
  /*    instead of `malloc' for allocation.                                */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /*                        B A S I C   T Y P E S                          */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    base_interface                                                     */
  /*                                                                       */
  /* <Title>                                                               */
  /*    Base Interface                                                     */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*    The FreeType~2 base font interface.                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This section describes the most important public high-level API    */
  /*    functions of FreeType~2.                                           */
  /*                                                                       */
  /* <Order>                                                               */
  /*    FT_Library                                                         */
  /*    FT_Face                                                            */
  /*    FT_Size                                                            */
  /*    FT_GlyphSlot                                                       */
  /*    FT_CharMap                                                         */
  /*    FT_Encoding                                                        */
  /*    FT_ENC_TAG                                                         */
  /*                                                                       */
  /*    FT_FaceRec                                                         */
  /*                                                                       */
  /*    FT_FACE_FLAG_SCALABLE                                              */
  /*    FT_FACE_FLAG_FIXED_SIZES                                           */
  /*    FT_FACE_FLAG_FIXED_WIDTH                                           */
  /*    FT_FACE_FLAG_HORIZONTAL                                            */
  /*    FT_FACE_FLAG_VERTICAL                                              */
  /*    FT_FACE_FLAG_COLOR                                                 */
  /*    FT_FACE_FLAG_SFNT                                                  */
  /*    FT_FACE_FLAG_CID_KEYED                                             */
  /*    FT_FACE_FLAG_TRICKY                                                */
  /*    FT_FACE_FLAG_KERNING                                               */
  /*    FT_FACE_FLAG_MULTIPLE_MASTERS                                      */
  /*    FT_FACE_FLAG_GLYPH_NAMES                                           */
  /*    FT_FACE_FLAG_EXTERNAL_STREAM                                       */
  /*    FT_FACE_FLAG_HINTER                                                */
  /*                                                                       */
  /*    FT_HAS_HORIZONTAL                                                  */
  /*    FT_HAS_VERTICAL                                                    */
  /*    FT_HAS_KERNING                                                     */
  /*    FT_HAS_FIXED_SIZES                                                 */
  /*    FT_HAS_GLYPH_NAMES                                                 */
  /*    FT_HAS_MULTIPLE_MASTERS                                            */
  /*    FT_HAS_COLOR                                                       */
  /*                                                                       */
  /*    FT_IS_SFNT                                                         */
  /*    FT_IS_SCALABLE                                                     */
  /*    FT_IS_FIXED_WIDTH                                                  */
  /*    FT_IS_CID_KEYED                                                    */
  /*    FT_IS_TRICKY                                                       */
  /*                                                                       */
  /*    FT_STYLE_FLAG_BOLD                                                 */
  /*    FT_STYLE_FLAG_ITALIC                                               */
  /*                                                                       */
  /*    FT_SizeRec                                                         */
  /*    FT_Size_Metrics                                                    */
  /*                                                                       */
  /*    FT_GlyphSlotRec                                                    */
  /*    FT_Glyph_Metrics                                                   */
  /*    FT_SubGlyph                                                        */
  /*                                                                       */
  /*    FT_Bitmap_Size                                                     */
  /*                                                                       */
  /*    FT_Init_FreeType                                                   */
  /*    FT_Done_FreeType                                                   */
  /*                                                                       */
  /*    FT_New_Face                                                        */
  /*    FT_Done_Face                                                       */
  /*    FT_Reference_Face                                                  */
  /*    FT_New_Memory_Face                                                 */
  /*    FT_Face_Properties                                                 */
  /*    FT_Open_Face                                                       */
  /*    FT_Open_Args                                                       */
  /*    FT_Parameter                                                       */
  /*    FT_Attach_File                                                     */
  /*    FT_Attach_Stream                                                   */
  /*                                                                       */
  /*    FT_Set_Char_Size                                                   */
  /*    FT_Set_Pixel_Sizes                                                 */
  /*    FT_Request_Size                                                    */
  /*    FT_Select_Size                                                     */
  /*    FT_Size_Request_Type                                               */
  /*    FT_Size_RequestRec                                                 */
  /*    FT_Size_Request                                                    */
  /*    FT_Set_Transform                                                   */
  /*    FT_Load_Glyph                                                      */
  /*    FT_Get_Char_Index                                                  */
  /*    FT_Get_First_Char                                                  */
  /*    FT_Get_Next_Char                                                   */
  /*    FT_Get_Name_Index                                                  */
  /*    FT_Load_Char                                                       */
  /*                                                                       */
  /*    FT_OPEN_MEMORY                                                     */
  /*    FT_OPEN_STREAM                                                     */
  /*    FT_OPEN_PATHNAME                                                   */
  /*    FT_OPEN_DRIVER                                                     */
  /*    FT_OPEN_PARAMS                                                     */
  /*                                                                       */
  /*    FT_LOAD_DEFAULT                                                    */
  /*    FT_LOAD_RENDER                                                     */
  /*    FT_LOAD_MONOCHROME                                                 */
  /*    FT_LOAD_LINEAR_DESIGN                                              */
  /*    FT_LOAD_NO_SCALE                                                   */
  /*    FT_LOAD_NO_HINTING                                                 */
  /*    FT_LOAD_NO_BITMAP                                                  */
  /*    FT_LOAD_NO_AUTOHINT                                                */
  /*    FT_LOAD_COLOR                                                      */
  /*                                                                       */
  /*    FT_LOAD_VERTICAL_LAYOUT                                            */
  /*    FT_LOAD_IGNORE_TRANSFORM                                           */
  /*    FT_LOAD_FORCE_AUTOHINT                                             */
  /*    FT_LOAD_NO_RECURSE                                                 */
  /*    FT_LOAD_PEDANTIC                                                   */
  /*                                                                       */
  /*    FT_LOAD_TARGET_NORMAL                                              */
  /*    FT_LOAD_TARGET_LIGHT                                               */
  /*    FT_LOAD_TARGET_MONO                                                */
  /*    FT_LOAD_TARGET_LCD                                                 */
  /*    FT_LOAD_TARGET_LCD_V                                               */
  /*                                                                       */
  /*    FT_LOAD_TARGET_MODE                                                */
  /*                                                                       */
  /*    FT_Render_Glyph                                                    */
  /*    FT_Render_Mode                                                     */
  /*    FT_Get_Kerning                                                     */
  /*    FT_Kerning_Mode                                                    */
  /*    FT_Get_Track_Kerning                                               */
  /*    FT_Get_Glyph_Name                                                  */
  /*    FT_Get_Postscript_Name                                             */
  /*                                                                       */
  /*    FT_CharMapRec                                                      */
  /*    FT_Select_Charmap                                                  */
  /*    FT_Set_Charmap                                                     */
  /*    FT_Get_Charmap_Index                                               */
  /*                                                                       */
  /*    FT_Get_FSType_Flags                                                */
  /*    FT_Get_SubGlyph_Info                                               */
  /*                                                                       */
  /*    FT_Face_Internal                                                   */
  /*    FT_Size_Internal                                                   */
  /*    FT_Slot_Internal                                                   */
  /*                                                                       */
  /*    FT_FACE_FLAG_XXX                                                   */
  /*    FT_STYLE_FLAG_XXX                                                  */
  /*    FT_OPEN_XXX                                                        */
  /*    FT_LOAD_XXX                                                        */
  /*    FT_LOAD_TARGET_XXX                                                 */
  /*    FT_SUBGLYPH_FLAG_XXX                                               */
  /*    FT_FSTYPE_XXX                                                      */
  /*                                                                       */
  /*    FT_HAS_FAST_GLYPHS                                                 */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Glyph_Metrics                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A structure to model the metrics of a single glyph.  The values    */
  /*    are expressed in 26.6 fractional pixel format; if the flag         */
  /*    @FT_LOAD_NO_SCALE has been used while loading the glyph, values    */
  /*    are expressed in font units instead.                               */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    width ::                                                           */
  /*      The glyph's width.                                               */
  /*                                                                       */
  /*    height ::                                                          */
  /*      The glyph's height.                                              */
  /*                                                                       */
  /*    horiBearingX ::                                                    */
  /*      Left side bearing for horizontal layout.                         */
  /*                                                                       */
  /*    horiBearingY ::                                                    */
  /*      Top side bearing for horizontal layout.                          */
  /*                                                                       */
  /*    horiAdvance ::                                                     */
  /*      Advance width for horizontal layout.                             */
  /*                                                                       */
  /*    vertBearingX ::                                                    */
  /*      Left side bearing for vertical layout.                           */
  /*                                                                       */
  /*    vertBearingY ::                                                    */
  /*      Top side bearing for vertical layout.  Larger positive values    */
  /*      mean further below the vertical glyph origin.                    */
  /*                                                                       */
  /*    vertAdvance ::                                                     */
  /*      Advance height for vertical layout.  Positive values mean the    */
  /*      glyph has a positive advance downward.                           */
  /*                                                                       */
  /* <Note>                                                                */
  /*    If not disabled with @FT_LOAD_NO_HINTING, the values represent     */
  /*    dimensions of the hinted glyph (in case hinting is applicable).    */
  /*                                                                       */
  /*    Stroking a glyph with an outside border does not increase          */
  /*    `horiAdvance' or `vertAdvance'; you have to manually adjust these  */
  /*    values to account for the added width and height.                  */
  /*                                                                       */
  /*    FreeType doesn't use the `VORG' table data for CFF fonts because   */
  /*    it doesn't have an interface to quickly retrieve the glyph height. */
  /*    The y~coordinate of the vertical origin can be simply computed as  */
  /*    `vertBearingY + height' after loading a glyph.                     */
  /*                                                                       */
  typedef struct  FT_Glyph_Metrics_
  {
    FT_Pos  width;
    FT_Pos  height;
    FT_Pos  horiBearingX;
    FT_Pos  horiBearingY;
    FT_Pos  horiAdvance;
    FT_Pos  vertBearingX;
    FT_Pos  vertBearingY;
    FT_Pos  vertAdvance;
  } FT_Glyph_Metrics;
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Bitmap_Size                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This structure models the metrics of a bitmap strike (i.e., a set  */
  /*    of glyphs for a given point size and resolution) in a bitmap font. */
  /*    It is used for the `available_sizes' field of @FT_Face.            */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    height :: The vertical distance, in pixels, between two            */
  /*              consecutive baselines.  It is always positive.           */
  /*                                                                       */
  /*    width  :: The average width, in pixels, of all glyphs in the       */
  /*              strike.                                                  */
  /*                                                                       */
  /*    size   :: The nominal size of the strike in 26.6 fractional        */
  /*              points.  This field is not very useful.                  */
  /*                                                                       */
  /*    x_ppem :: The horizontal ppem (nominal width) in 26.6 fractional   */
  /*              pixels.                                                  */
  /*                                                                       */
  /*    y_ppem :: The vertical ppem (nominal height) in 26.6 fractional    */
  /*              pixels.                                                  */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Windows FNT:                                                       */
  /*      The nominal size given in a FNT font is not reliable.  If the    */
  /*      driver finds it incorrect, it sets `size' to some calculated     */
  /*      values, and `x_ppem' and `y_ppem' to the pixel width and height  */
  /*      given in the font, respectively.                                 */
  /*                                                                       */
  /*    TrueType embedded bitmaps:                                         */
  /*      `size', `width', and `height' values are not contained in the    */
  /*      bitmap strike itself.  They are computed from the global font    */
  /*      parameters.                                                      */
  /*                                                                       */
  typedef struct  FT_Bitmap_Size_
  {
    FT_Short  height;
    FT_Short  width;
    FT_Pos    size;
    FT_Pos    x_ppem;
    FT_Pos    y_ppem;
  } FT_Bitmap_Size;
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /*                     O B J E C T   C L A S S E S                       */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Library                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a FreeType library instance.  Each `library' is        */
  /*    completely independent from the others; it is the `root' of a set  */
  /*    of objects like fonts, faces, sizes, etc.                          */
  /*                                                                       */
  /*    It also embeds a memory manager (see @FT_Memory), as well as a     */
  /*    scan-line converter object (see @FT_Raster).                       */
  /*                                                                       */
  /*    In multi-threaded applications it is easiest to use one            */
  /*    `FT_Library' object per thread.  In case this is too cumbersome,   */
  /*    a single `FT_Library' object across threads is possible also       */
  /*    (since FreeType version 2.5.6), as long as a mutex lock is used    */
  /*    around @FT_New_Face and @FT_Done_Face.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Library objects are normally created by @FT_Init_FreeType, and     */
  /*    destroyed with @FT_Done_FreeType.  If you need reference-counting  */
  /*    (cf. @FT_Reference_Library), use @FT_New_Library and               */
  /*    @FT_Done_Library.                                                  */
  /*                                                                       */
  typedef struct FT_LibraryRec_  *FT_Library;
  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    module_management                                                  */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Module                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a given FreeType module object.  A module can be a     */
  /*    font driver, a renderer, or anything else that provides services   */
  /*    to the former.                                                     */
  /*                                                                       */
  typedef struct FT_ModuleRec_*  FT_Module;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Driver                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a given FreeType font driver object.  A font driver    */
  /*    is a module capable of creating faces from font files.             */
  /*                                                                       */
  typedef struct FT_DriverRec_*  FT_Driver;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Renderer                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a given FreeType renderer.  A renderer is a module in  */
  /*    charge of converting a glyph's outline image to a bitmap.  It      */
  /*    supports a single glyph image format, and one or more target       */
  /*    surface depths.                                                    */
  /*                                                                       */
  typedef struct FT_RendererRec_*  FT_Renderer;
  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    base_interface                                                     */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Face                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a typographic face object.  A face object models a     */
  /*    given typeface, in a given style.                                  */
  /*                                                                       */
  /* <Note>                                                                */
  /*    A face object also owns a single @FT_GlyphSlot object, as well     */
  /*    as one or more @FT_Size objects.                                   */
  /*                                                                       */
  /*    Use @FT_New_Face or @FT_Open_Face to create a new face object from */
  /*    a given filepath or a custom input stream.                         */
  /*                                                                       */
  /*    Use @FT_Done_Face to destroy it (along with its slot and sizes).   */
  /*                                                                       */
  /*    An `FT_Face' object can only be safely used from one thread at a   */
  /*    time.  Similarly, creation and destruction of `FT_Face' with the   */
  /*    same @FT_Library object can only be done from one thread at a      */
  /*    time.  On the other hand, functions like @FT_Load_Glyph and its    */
  /*    siblings are thread-safe and do not need the lock to be held as    */
  /*    long as the same `FT_Face' object is not used from multiple        */
  /*    threads at the same time.                                          */
  /*                                                                       */
  /* <Also>                                                                */
  /*    See @FT_FaceRec for the publicly accessible fields of a given face */
  /*    object.                                                            */
  /*                                                                       */
  typedef struct FT_FaceRec_*  FT_Face;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Size                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to an object that models a face scaled to a given         */
  /*    character size.                                                    */
  /*                                                                       */
  /* <Note>                                                                */
  /*    An @FT_Face has one _active_ @FT_Size object that is used by       */
  /*    functions like @FT_Load_Glyph to determine the scaling             */
  /*    transformation that in turn is used to load and hint glyphs and    */
  /*    metrics.                                                           */
  /*                                                                       */
  /*    You can use @FT_Set_Char_Size, @FT_Set_Pixel_Sizes,                */
  /*    @FT_Request_Size or even @FT_Select_Size to change the content     */
  /*    (i.e., the scaling values) of the active @FT_Size.                 */
  /*                                                                       */
  /*    You can use @FT_New_Size to create additional size objects for a   */
  /*    given @FT_Face, but they won't be used by other functions until    */
  /*    you activate it through @FT_Activate_Size.  Only one size can be   */
  /*    activated at any given time per face.                              */
  /*                                                                       */
  /* <Also>                                                                */
  /*    See @FT_SizeRec for the publicly accessible fields of a given size */
  /*    object.                                                            */
  /*                                                                       */
  typedef struct FT_SizeRec_*  FT_Size;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_GlyphSlot                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a given `glyph slot'.  A slot is a container that can  */
  /*    hold any of the glyphs contained in its parent face.               */
  /*                                                                       */
  /*    In other words, each time you call @FT_Load_Glyph or               */
  /*    @FT_Load_Char, the slot's content is erased by the new glyph data, */
  /*    i.e., the glyph's metrics, its image (bitmap or outline), and      */
  /*    other control information.                                         */
  /*                                                                       */
  /* <Also>                                                                */
  /*    See @FT_GlyphSlotRec for the publicly accessible glyph fields.     */
  /*                                                                       */
  typedef struct FT_GlyphSlotRec_*  FT_GlyphSlot;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_CharMap                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a character map (usually abbreviated to `charmap').  A */
  /*    charmap is used to translate character codes in a given encoding   */
  /*    into glyph indexes for its parent's face.  Some font formats may   */
  /*    provide several charmaps per font.                                 */
  /*                                                                       */
  /*    Each face object owns zero or more charmaps, but only one of them  */
  /*    can be `active', providing the data used by @FT_Get_Char_Index or  */
  /*    @FT_Load_Char.                                                     */
  /*                                                                       */
  /*    The list of available charmaps in a face is available through the  */
  /*    `face->num_charmaps' and `face->charmaps' fields of @FT_FaceRec.   */
  /*                                                                       */
  /*    The currently active charmap is available as `face->charmap'.      */
  /*    You should call @FT_Set_Charmap to change it.                      */
  /*                                                                       */
  /* <Note>                                                                */
  /*    When a new face is created (either through @FT_New_Face or         */
  /*    @FT_Open_Face), the library looks for a Unicode charmap within     */
  /*    the list and automatically activates it.                           */
  /*                                                                       */
  /* <Also>                                                                */
  /*    See @FT_CharMapRec for the publicly accessible fields of a given   */
  /*    character map.                                                     */
  /*                                                                       */
  typedef struct FT_CharMapRec_*  FT_CharMap;
  /*************************************************************************/
  /*                                                                       */
  /* <Macro>                                                               */
  /*    FT_ENC_TAG                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This macro converts four-letter tags into an unsigned long.  It is */
  /*    used to define `encoding' identifiers (see @FT_Encoding).          */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Since many 16-bit compilers don't like 32-bit enumerations, you    */
  /*    should redefine this macro in case of problems to something like   */
  /*    this:                                                              */
  /*                                                                       */
  /*    {                                                                  */
  /*      #define FT_ENC_TAG( value, a, b, c, d )  value                   */
  /*    }                                                                  */
  /*                                                                       */
  /*    to get a simple enumeration without assigning special numbers.     */
  /*                                                                       */
#ifndef FT_ENC_TAG
#define FT_ENC_TAG( value, a, b, c, d )                   value = ( ( (FT_UInt32)(a) << 24 ) |                      ( (FT_UInt32)(b) << 16 ) |                      ( (FT_UInt32)(c) <<  8 ) |                        (FT_UInt32)(d)         )
#endif
  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_Encoding                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    An enumeration to specify character sets supported by charmaps.    */
  /*    Used in the @FT_Select_Charmap API function.                       */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Despite the name, this enumeration lists specific character        */
  /*    repertories (i.e., charsets), and not text encoding methods (e.g., */
  /*    UTF-8, UTF-16, etc.).                                              */
  /*                                                                       */
  /*    Other encodings might be defined in the future.                    */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_ENCODING_NONE ::                                                */
  /*      The encoding value~0 is reserved.                                */
  /*                                                                       */
  /*    FT_ENCODING_UNICODE ::                                             */
  /*      The Unicode character set.  This value covers all versions of    */
  /*      the Unicode repertoire, including ASCII and Latin-1.  Most fonts */
  /*      include a Unicode charmap, but not all of them.                  */
  /*                                                                       */
  /*      For example, if you want to access Unicode value U+1F028 (and    */
  /*      the font contains it), use value 0x1F028 as the input value for  */
  /*      @FT_Get_Char_Index.                                              */
  /*                                                                       */
  /*    FT_ENCODING_MS_SYMBOL ::                                           */
  /*      Microsoft Symbol encoding, used to encode mathematical symbols   */
  /*      and wingdings.  For more information, see                        */
  /*      `http://www.microsoft.com/typography/otspec/recom.htm',          */
  /*      `http://www.kostis.net/charsets/symbol.htm', and                 */
  /*      `http://www.kostis.net/charsets/wingding.htm'.                   */
  /*                                                                       */
  /*      This encoding uses character codes from the PUA (Private Unicode */
  /*      Area) in the range U+F020-U+F0FF.                                */
  /*                                                                       */
  /*    FT_ENCODING_SJIS ::                                                */
  /*      Shift JIS encoding for Japanese.  More info at                   */
  /*      `http://en.wikipedia.org/wiki/Shift_JIS'.  See note on           */
  /*      multi-byte encodings below.                                      */
  /*                                                                       */
  /*    FT_ENCODING_PRC ::                                                 */
  /*      Corresponds to encoding systems mainly for Simplified Chinese as */
  /*      used in People's Republic of China (PRC).  The encoding layout   */
  /*      is based on GB~2312 and its supersets GBK and GB~18030.          */
  /*                                                                       */
  /*    FT_ENCODING_BIG5 ::                                                */
  /*      Corresponds to an encoding system for Traditional Chinese as     */
  /*      used in Taiwan and Hong Kong.                                    */
  /*                                                                       */
  /*    FT_ENCODING_WANSUNG ::                                             */
  /*      Corresponds to the Korean encoding system known as Extended      */
  /*      Wansung (MS Windows code page 949).                              */
  /*      For more information see                                         */
  /*      `http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/bestfit949.txt'. */
  /*                                                                       */
  /*    FT_ENCODING_JOHAB ::                                               */
  /*      The Korean standard character set (KS~C 5601-1992), which        */
  /*      corresponds to MS Windows code page 1361.  This character set    */
  /*      includes all possible Hangul character combinations.             */
  /*                                                                       */
  /*    FT_ENCODING_ADOBE_LATIN_1 ::                                       */
  /*      Corresponds to a Latin-1 encoding as defined in a Type~1         */
  /*      PostScript font.  It is limited to 256 character codes.          */
  /*                                                                       */
  /*    FT_ENCODING_ADOBE_STANDARD ::                                      */
  /*      Adobe Standard encoding, as found in Type~1, CFF, and            */
  /*      OpenType/CFF fonts.  It is limited to 256 character codes.       */
  /*                                                                       */
  /*    FT_ENCODING_ADOBE_EXPERT ::                                        */
  /*      Adobe Expert encoding, as found in Type~1, CFF, and OpenType/CFF */
  /*      fonts.  It is limited to 256 character codes.                    */
  /*                                                                       */
  /*    FT_ENCODING_ADOBE_CUSTOM ::                                        */
  /*      Corresponds to a custom encoding, as found in Type~1, CFF, and   */
  /*      OpenType/CFF fonts.  It is limited to 256 character codes.       */
  /*                                                                       */
  /*    FT_ENCODING_APPLE_ROMAN ::                                         */
  /*      Apple roman encoding.  Many TrueType and OpenType fonts contain  */
  /*      a charmap for this 8-bit encoding, since older versions of Mac   */
  /*      OS are able to use it.                                           */
  /*                                                                       */
  /*    FT_ENCODING_OLD_LATIN_2 ::                                         */
  /*      This value is deprecated and was neither used nor reported by    */
  /*      FreeType.  Don't use or test for it.                             */
  /*                                                                       */
  /*    FT_ENCODING_MS_SJIS ::                                             */
  /*      Same as FT_ENCODING_SJIS.  Deprecated.                           */
  /*                                                                       */
  /*    FT_ENCODING_MS_GB2312 ::                                           */
  /*      Same as FT_ENCODING_PRC.  Deprecated.                            */
  /*                                                                       */
  /*    FT_ENCODING_MS_BIG5 ::                                             */
  /*      Same as FT_ENCODING_BIG5.  Deprecated.                           */
  /*                                                                       */
  /*    FT_ENCODING_MS_WANSUNG ::                                          */
  /*      Same as FT_ENCODING_WANSUNG.  Deprecated.                        */
  /*                                                                       */
  /*    FT_ENCODING_MS_JOHAB ::                                            */
  /*      Same as FT_ENCODING_JOHAB.  Deprecated.                          */
  /*                                                                       */
  /* <Note>                                                                */
  /*    By default, FreeType automatically synthesizes a Unicode charmap   */
  /*    for PostScript fonts, using their glyph name dictionaries.         */
  /*    However, it also reports the encodings defined explicitly in the   */
  /*    font file, for the cases when they are needed, with the Adobe      */
  /*    values as well.                                                    */
  /*                                                                       */
  /*    FT_ENCODING_NONE is set by the BDF and PCF drivers if the charmap  */
  /*    is neither Unicode nor ISO-8859-1 (otherwise it is set to          */
  /*    FT_ENCODING_UNICODE).  Use @FT_Get_BDF_Charset_ID to find out      */
  /*    which encoding is really present.  If, for example, the            */
  /*    `cs_registry' field is `KOI8' and the `cs_encoding' field is `R',  */
  /*    the font is encoded in KOI8-R.                                     */
  /*                                                                       */
  /*    FT_ENCODING_NONE is always set (with a single exception) by the    */
  /*    winfonts driver.  Use @FT_Get_WinFNT_Header and examine the        */
  /*    `charset' field of the @FT_WinFNT_HeaderRec structure to find out  */
  /*    which encoding is really present.  For example,                    */
  /*    @FT_WinFNT_ID_CP1251 (204) means Windows code page 1251 (for       */
  /*    Russian).                                                          */
  /*                                                                       */
  /*    FT_ENCODING_NONE is set if `platform_id' is @TT_PLATFORM_MACINTOSH */
  /*    and `encoding_id' is not `TT_MAC_ID_ROMAN' (otherwise it is set to */
  /*    FT_ENCODING_APPLE_ROMAN).                                          */
  /*                                                                       */
  /*    If `platform_id' is @TT_PLATFORM_MACINTOSH, use the function       */
  /*    @FT_Get_CMap_Language_ID to query the Mac language ID that may     */
  /*    be needed to be able to distinguish Apple encoding variants.  See  */
  /*                                                                       */
  /*      http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt  */
  /*                                                                       */
  /*    to get an idea how to do that.  Basically, if the language ID      */
  /*    is~0, don't use it, otherwise subtract 1 from the language ID.     */
  /*    Then examine `encoding_id'.  If, for example, `encoding_id' is     */
  /*    `TT_MAC_ID_ROMAN' and the language ID (minus~1) is                 */
  /*    `TT_MAC_LANGID_GREEK', it is the Greek encoding, not Roman.        */
  /*    `TT_MAC_ID_ARABIC' with `TT_MAC_LANGID_FARSI' means the Farsi      */
  /*    variant the Arabic encoding.                                       */
  /*                                                                       */
  typedef enum  FT_Encoding_
  {
    FT_ENC_TAG( FT_ENCODING_NONE, 0, 0, 0, 0 ),
    FT_ENC_TAG( FT_ENCODING_MS_SYMBOL, 's', 'y', 'm', 'b' ),
    FT_ENC_TAG( FT_ENCODING_UNICODE,   'u', 'n', 'i', 'c' ),
    FT_ENC_TAG( FT_ENCODING_SJIS,    's', 'j', 'i', 's' ),
    FT_ENC_TAG( FT_ENCODING_PRC,     'g', 'b', ' ', ' ' ),
    FT_ENC_TAG( FT_ENCODING_BIG5,    'b', 'i', 'g', '5' ),
    FT_ENC_TAG( FT_ENCODING_WANSUNG, 'w', 'a', 'n', 's' ),
    FT_ENC_TAG( FT_ENCODING_JOHAB,   'j', 'o', 'h', 'a' ),
    /* for backward compatibility */
    FT_ENCODING_GB2312     = FT_ENCODING_PRC,
    FT_ENCODING_MS_SJIS    = FT_ENCODING_SJIS,
    FT_ENCODING_MS_GB2312  = FT_ENCODING_PRC,
    FT_ENCODING_MS_BIG5    = FT_ENCODING_BIG5,
    FT_ENCODING_MS_WANSUNG = FT_ENCODING_WANSUNG,
    FT_ENCODING_MS_JOHAB   = FT_ENCODING_JOHAB,
    FT_ENC_TAG( FT_ENCODING_ADOBE_STANDARD, 'A', 'D', 'O', 'B' ),
    FT_ENC_TAG( FT_ENCODING_ADOBE_EXPERT,   'A', 'D', 'B', 'E' ),
    FT_ENC_TAG( FT_ENCODING_ADOBE_CUSTOM,   'A', 'D', 'B', 'C' ),
    FT_ENC_TAG( FT_ENCODING_ADOBE_LATIN_1,  'l', 'a', 't', '1' ),
    FT_ENC_TAG( FT_ENCODING_OLD_LATIN_2, 'l', 'a', 't', '2' ),
    FT_ENC_TAG( FT_ENCODING_APPLE_ROMAN, 'a', 'r', 'm', 'n' )
  } FT_Encoding;
  /* these constants are deprecated; use the corresponding `FT_Encoding' */
  /* values instead                                                      */
#define ft_encoding_none            FT_ENCODING_NONE
#define ft_encoding_unicode         FT_ENCODING_UNICODE
#define ft_encoding_symbol          FT_ENCODING_MS_SYMBOL
#define ft_encoding_latin_1         FT_ENCODING_ADOBE_LATIN_1
#define ft_encoding_latin_2         FT_ENCODING_OLD_LATIN_2
#define ft_encoding_sjis            FT_ENCODING_SJIS
#define ft_encoding_gb2312          FT_ENCODING_PRC
#define ft_encoding_big5            FT_ENCODING_BIG5
#define ft_encoding_wansung         FT_ENCODING_WANSUNG
#define ft_encoding_johab           FT_ENCODING_JOHAB
#define ft_encoding_adobe_standard  FT_ENCODING_ADOBE_STANDARD
#define ft_encoding_adobe_expert    FT_ENCODING_ADOBE_EXPERT
#define ft_encoding_adobe_custom    FT_ENCODING_ADOBE_CUSTOM
#define ft_encoding_apple_roman     FT_ENCODING_APPLE_ROMAN
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_CharMapRec                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The base charmap structure.                                        */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    face        :: A handle to the parent face object.                 */
  /*                                                                       */
  /*    encoding    :: An @FT_Encoding tag identifying the charmap.  Use   */
  /*                   this with @FT_Select_Charmap.                       */
  /*                                                                       */
  /*    platform_id :: An ID number describing the platform for the        */
  /*                   following encoding ID.  This comes directly from    */
  /*                   the TrueType specification and gets emulated for    */
  /*                   other formats.                                      */
  /*                                                                       */
  /*    encoding_id :: A platform specific encoding number.  This also     */
  /*                   comes from the TrueType specification and gets      */
  /*                   emulated similarly.                                 */
  /*                                                                       */
  typedef struct  FT_CharMapRec_
  {
    FT_Face      face;
    FT_Encoding  encoding;
    FT_UShort    platform_id;
    FT_UShort    encoding_id;
  } FT_CharMapRec;
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /*                 B A S E   O B J E C T   C L A S S E S                 */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Face_Internal                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    An opaque handle to an `FT_Face_InternalRec' structure that models */
  /*    the private data of a given @FT_Face object.                       */
  /*                                                                       */
  /*    This structure might change between releases of FreeType~2 and is  */
  /*    not generally available to client applications.                    */
  /*                                                                       */
  typedef struct FT_Face_InternalRec_*  FT_Face_Internal;
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_FaceRec                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    FreeType root face class structure.  A face object models a        */
  /*    typeface in a font file.                                           */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    num_faces           :: The number of faces in the font file.  Some */
  /*                           font formats can have multiple faces in     */
  /*                           a single font file.                         */
  /*                                                                       */
  /*    face_index          :: This field holds two different values.      */
  /*                           Bits 0-15 are the index of the face in the  */
  /*                           font file (starting with value~0).  They    */
  /*                           are set to~0 if there is only one face in   */
  /*                           the font file.                              */
  /*                                                                       */
  /*                           Bits 16-30 are relevant to GX and OpenType  */
  /*                           variation fonts only, holding the named     */
  /*                           instance index for the current face index   */
  /*                           (starting with value~1; value~0 indicates   */
  /*                           font access without a named instance).  For */
  /*                           non-variation fonts, bits 16-30 are         */
  /*                           ignored.  If we have the third named        */
  /*                           instance of face~4, say, `face_index' is    */
  /*                           set to 0x00030004.                          */
  /*                                                                       */
  /*                           Bit 31 is always zero (this is,             */
  /*                           `face_index' is always a positive value).   */
  /*                                                                       */
  /*    face_flags          :: A set of bit flags that give important      */
  /*                           information about the face; see             */
  /*                           @FT_FACE_FLAG_XXX for the details.          */
  /*                                                                       */
  /*    style_flags         :: The lower 16~bits contain a set of bit      */
  /*                           flags indicating the style of the face; see */
  /*                           @FT_STYLE_FLAG_XXX for the details.  Bits   */
  /*                           16-30 hold the number of named instances    */
  /*                           available for the current face if we have a */
  /*                           GX or OpenType variation (sub)font.  Bit 31 */
  /*                           is always zero (this is, `style_flags' is   */
  /*                           always a positive value).  Note that a      */
  /*                           variation font has always at least one      */
  /*                           named instance, namely the default          */
  /*                           instance.                                   */
  /*                                                                       */
  /*    num_glyphs          :: The number of glyphs in the face.  If the   */
  /*                           face is scalable and has sbits (see         */
  /*                           `num_fixed_sizes'), it is set to the number */
  /*                           of outline glyphs.                          */
  /*                                                                       */
  /*                           For CID-keyed fonts (not in an SFNT         */
  /*                           wrapper) this value gives the highest CID   */
  /*                           used in the font.                           */
  /*                                                                       */
  /*    family_name         :: The face's family name.  This is an ASCII   */
  /*                           string, usually in English, that describes  */
  /*                           the typeface's family (like `Times New      */
  /*                           Roman', `Bodoni', `Garamond', etc).  This   */
  /*                           is a least common denominator used to list  */
  /*                           fonts.  Some formats (TrueType & OpenType)  */
  /*                           provide localized and Unicode versions of   */
  /*                           this string.  Applications should use the   */
  /*                           format specific interface to access them.   */
  /*                           Can be NULL (e.g., in fonts embedded in a   */
  /*                           PDF file).                                  */
  /*                                                                       */
  /*                           In case the font doesn't provide a specific */
  /*                           family name entry, FreeType tries to        */
  /*                           synthesize one, deriving it from other name */
  /*                           entries.                                    */
  /*                                                                       */
  /*    style_name          :: The face's style name.  This is an ASCII    */
  /*                           string, usually in English, that describes  */
  /*                           the typeface's style (like `Italic',        */
  /*                           `Bold', `Condensed', etc).  Not all font    */
  /*                           formats provide a style name, so this field */
  /*                           is optional, and can be set to NULL.  As    */
  /*                           for `family_name', some formats provide     */
  /*                           localized and Unicode versions of this      */
  /*                           string.  Applications should use the format */
  /*                           specific interface to access them.          */
  /*                                                                       */
  /*    num_fixed_sizes     :: The number of bitmap strikes in the face.   */
  /*                           Even if the face is scalable, there might   */
  /*                           still be bitmap strikes, which are called   */
  /*                           `sbits' in that case.                       */
  /*                                                                       */
  /*    available_sizes     :: An array of @FT_Bitmap_Size for all bitmap  */
  /*                           strikes in the face.  It is set to NULL if  */
  /*                           there is no bitmap strike.                  */
  /*                                                                       */
  /*                           Note that FreeType tries to sanitize the    */
  /*                           strike data since they are sometimes sloppy */
  /*                           or incorrect, but this can easily fail.     */
  /*                                                                       */
  /*    num_charmaps        :: The number of charmaps in the face.         */
  /*                                                                       */
  /*    charmaps            :: An array of the charmaps of the face.       */
  /*                                                                       */
  /*    generic             :: A field reserved for client uses.  See the  */
  /*                           @FT_Generic type description.               */
  /*                                                                       */
  /*    bbox                :: The font bounding box.  Coordinates are     */
  /*                           expressed in font units (see                */
  /*                           `units_per_EM').  The box is large enough   */
  /*                           to contain any glyph from the font.  Thus,  */
  /*                           `bbox.yMax' can be seen as the `maximum     */
  /*                           ascender', and `bbox.yMin' as the `minimum  */
  /*                           descender'.  Only relevant for scalable     */
  /*                           formats.                                    */
  /*                                                                       */
  /*                           Note that the bounding box might be off by  */
  /*                           (at least) one pixel for hinted fonts.  See */
  /*                           @FT_Size_Metrics for further discussion.    */
  /*                                                                       */
  /*    units_per_EM        :: The number of font units per EM square for  */
  /*                           this face.  This is typically 2048 for      */
  /*                           TrueType fonts, and 1000 for Type~1 fonts.  */
  /*                           Only relevant for scalable formats.         */
  /*                                                                       */
  /*    ascender            :: The typographic ascender of the face,       */
  /*                           expressed in font units.  For font formats  */
  /*                           not having this information, it is set to   */
  /*                           `bbox.yMax'.  Only relevant for scalable    */
  /*                           formats.                                    */
  /*                                                                       */
  /*    descender           :: The typographic descender of the face,      */
  /*                           expressed in font units.  For font formats  */
  /*                           not having this information, it is set to   */
  /*                           `bbox.yMin'.  Note that this field is       */
  /*                           negative for values below the baseline.     */
  /*                           Only relevant for scalable formats.         */
  /*                                                                       */
  /*    height              :: This value is the vertical distance         */
  /*                           between two consecutive baselines,          */
  /*                           expressed in font units.  It is always      */
  /*                           positive.  Only relevant for scalable       */
  /*                           formats.                                    */
  /*                                                                       */
  /*                           If you want the global glyph height, use    */
  /*                           `ascender - descender'.                     */
  /*                                                                       */
  /*    max_advance_width   :: The maximum advance width, in font units,   */
  /*                           for all glyphs in this face.  This can be   */
  /*                           used to make word wrapping computations     */
  /*                           faster.  Only relevant for scalable         */
  /*                           formats.                                    */
  /*                                                                       */
  /*    max_advance_height  :: The maximum advance height, in font units,  */
  /*                           for all glyphs in this face.  This is only  */
  /*                           relevant for vertical layouts, and is set   */
  /*                           to `height' for fonts that do not provide   */
  /*                           vertical metrics.  Only relevant for        */
  /*                           scalable formats.                           */
  /*                                                                       */
  /*    underline_position  :: The position, in font units, of the         */
  /*                           underline line for this face.  It is the    */
  /*                           center of the underlining stem.  Only       */
  /*                           relevant for scalable formats.              */
  /*                                                                       */
  /*    underline_thickness :: The thickness, in font units, of the        */
  /*                           underline for this face.  Only relevant for */
  /*                           scalable formats.                           */
  /*                                                                       */
  /*    glyph               :: The face's associated glyph slot(s).        */
  /*                                                                       */
  /*    size                :: The current active size for this face.      */
  /*                                                                       */
  /*    charmap             :: The current active charmap for this face.   */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Fields may be changed after a call to @FT_Attach_File or           */
  /*    @FT_Attach_Stream.                                                 */
  /*                                                                       */
  /*    For an OpenType variation font, the values of the following fields */
  /*    can change after a call to @FT_Set_Var_Design_Coordinates (and     */
  /*    friends) if the font contains an `MVAR' table: `ascender',         */
  /*    `descender', `height', `underline_position', and                   */
  /*    `underline_thickness'.                                             */
  /*                                                                       */
  typedef struct  FT_FaceRec_
  {
    FT_Long           num_faces;
    FT_Long           face_index;
    FT_Long           face_flags;
    FT_Long           style_flags;
    FT_Long           num_glyphs;
    FT_String*        family_name;
    FT_String*        style_name;
    FT_Int            num_fixed_sizes;
    FT_Bitmap_Size*   available_sizes;
    FT_Int            num_charmaps;
    FT_CharMap*       charmaps;
    FT_Generic        generic;
    /*# The following member variables (down to `underline_thickness') */
    /*# are only relevant to scalable outlines; cf. @FT_Bitmap_Size    */
    /*# for bitmap fonts.                                              */
    FT_BBox           bbox;
    FT_UShort         units_per_EM;
    FT_Short          ascender;
    FT_Short          descender;
    FT_Short          height;
    FT_Short          max_advance_width;
    FT_Short          max_advance_height;
    FT_Short          underline_position;
    FT_Short          underline_thickness;
    FT_GlyphSlot      glyph;
    FT_Size           size;
    FT_CharMap        charmap;
    /*@private begin */
    FT_Driver         driver;
    FT_Memory         memory;
    FT_Stream         stream;
    FT_ListRec        sizes_list;
    FT_Generic        autohint;
    void*             extensions;
    FT_Face_Internal  internal;
    /*@private end */
  } FT_FaceRec;
  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_FACE_FLAG_XXX                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A list of bit flags used in the `face_flags' field of the          */
  /*    @FT_FaceRec structure.  They inform client applications of         */
  /*    properties of the corresponding face.                              */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_FACE_FLAG_SCALABLE ::                                           */
  /*      The face contains outline glyphs.  Note that a face can contain  */
  /*      bitmap strikes also, i.e., a face can have both this flag and    */
  /*      @FT_FACE_FLAG_FIXED_SIZES set.                                   */
  /*                                                                       */
  /*    FT_FACE_FLAG_FIXED_SIZES ::                                        */
  /*      The face contains bitmap strikes.  See also the                  */
  /*      `num_fixed_sizes' and `available_sizes' fields of @FT_FaceRec.   */
  /*                                                                       */
  /*    FT_FACE_FLAG_FIXED_WIDTH ::                                        */
  /*      The face contains fixed-width characters (like Courier, Lucida,  */
  /*      MonoType, etc.).                                                 */
  /*                                                                       */
  /*    FT_FACE_FLAG_SFNT ::                                               */
  /*      The face uses the SFNT storage scheme.  For now, this means      */
  /*      TrueType and OpenType.                                           */
  /*                                                                       */
  /*    FT_FACE_FLAG_HORIZONTAL ::                                         */
  /*      The face contains horizontal glyph metrics.  This should be set  */
  /*      for all common formats.                                          */
  /*                                                                       */
  /*    FT_FACE_FLAG_VERTICAL ::                                           */
  /*      The face contains vertical glyph metrics.  This is only          */
  /*      available in some formats, not all of them.                      */
  /*                                                                       */
  /*    FT_FACE_FLAG_KERNING ::                                            */
  /*      The face contains kerning information.  If set, the kerning      */
  /*      distance can be retrieved using the function @FT_Get_Kerning.    */
  /*      Otherwise the function always return the vector (0,0).  Note     */
  /*      that FreeType doesn't handle kerning data from the SFNT `GPOS'   */
  /*      table (as present in many OpenType fonts).                       */
  /*                                                                       */
  /*    FT_FACE_FLAG_FAST_GLYPHS ::                                        */
  /*      THIS FLAG IS DEPRECATED.  DO NOT USE OR TEST IT.                 */
  /*                                                                       */
  /*    FT_FACE_FLAG_MULTIPLE_MASTERS ::                                   */
  /*      The face contains multiple masters and is capable of             */
  /*      interpolating between them.  Supported formats are Adobe MM,     */
  /*      TrueType GX, and OpenType variation fonts.                       */
  /*                                                                       */
  /*      See the multiple-masters specific API for details.               */
  /*                                                                       */
  /*    FT_FACE_FLAG_GLYPH_NAMES ::                                        */
  /*      The face contains glyph names, which can be retrieved using      */
  /*      @FT_Get_Glyph_Name.  Note that some TrueType fonts contain       */
  /*      broken glyph name tables.  Use the function                      */
  /*      @FT_Has_PS_Glyph_Names when needed.                              */
  /*                                                                       */
  /*    FT_FACE_FLAG_EXTERNAL_STREAM ::                                    */
  /*      Used internally by FreeType to indicate that a face's stream was */
  /*      provided by the client application and should not be destroyed   */
  /*      when @FT_Done_Face is called.  Don't read or test this flag.     */
  /*                                                                       */
  /*    FT_FACE_FLAG_HINTER ::                                             */
  /*      The font driver has a hinting machine of its own.  For example,  */
  /*      with TrueType fonts, it makes sense to use data from the SFNT    */
  /*      `gasp' table only if the native TrueType hinting engine (with    */
  /*      the bytecode interpreter) is available and active.               */
  /*                                                                       */
  /*    FT_FACE_FLAG_CID_KEYED ::                                          */
  /*      The face is CID-keyed.  In that case, the face is not accessed   */
  /*      by glyph indices but by CID values.  For subsetted CID-keyed     */
  /*      fonts this has the consequence that not all index values are a   */
  /*      valid argument to @FT_Load_Glyph.  Only the CID values for which */
  /*      corresponding glyphs in the subsetted font exist make            */
  /*      `FT_Load_Glyph' return successfully; in all other cases you get  */
  /*      an `FT_Err_Invalid_Argument' error.                              */
  /*                                                                       */
  /*      Note that CID-keyed fonts that are in an SFNT wrapper (this is,  */
  /*      all OpenType/CFF fonts) don't have this flag set since the       */
  /*      glyphs are accessed in the normal way (using contiguous          */
  /*      indices); the `CID-ness' isn't visible to the application.       */
  /*                                                                       */
  /*    FT_FACE_FLAG_TRICKY ::                                             */
  /*      The face is `tricky', this is, it always needs the font format's */
  /*      native hinting engine to get a reasonable result.  A typical     */
  /*      example is the old Chinese font `mingli.ttf' (but not            */
  /*      `mingliu.ttc') that uses TrueType bytecode instructions to move  */
  /*      and scale all of its subglyphs.                                  */
  /*                                                                       */
  /*      It is not possible to auto-hint such fonts using                 */
  /*      @FT_LOAD_FORCE_AUTOHINT; it will also ignore                     */
  /*      @FT_LOAD_NO_HINTING.  You have to set both @FT_LOAD_NO_HINTING   */
  /*      and @FT_LOAD_NO_AUTOHINT to really disable hinting; however, you */
  /*      probably never want this except for demonstration purposes.      */
  /*                                                                       */
  /*      Currently, there are about a dozen TrueType fonts in the list of */
  /*      tricky fonts; they are hard-coded in file `ttobjs.c'.            */
  /*                                                                       */
  /*    FT_FACE_FLAG_COLOR ::                                              */
  /*      The face has color glyph tables.  To access color glyphs use     */
  /*      @FT_LOAD_COLOR.                                                  */
  /*                                                                       */
#define FT_FACE_FLAG_SCALABLE          ( 1L <<  0 )
#define FT_FACE_FLAG_FIXED_SIZES       ( 1L <<  1 )
#define FT_FACE_FLAG_FIXED_WIDTH       ( 1L <<  2 )
#define FT_FACE_FLAG_SFNT              ( 1L <<  3 )
#define FT_FACE_FLAG_HORIZONTAL        ( 1L <<  4 )
#define FT_FACE_FLAG_VERTICAL          ( 1L <<  5 )
#define FT_FACE_FLAG_KERNING           ( 1L <<  6 )
#define FT_FACE_FLAG_FAST_GLYPHS       ( 1L <<  7 )
#define FT_FACE_FLAG_MULTIPLE_MASTERS  ( 1L <<  8 )
#define FT_FACE_FLAG_GLYPH_NAMES       ( 1L <<  9 )
#define FT_FACE_FLAG_EXTERNAL_STREAM   ( 1L << 10 )
#define FT_FACE_FLAG_HINTER            ( 1L << 11 )
#define FT_FACE_FLAG_CID_KEYED         ( 1L << 12 )
#define FT_FACE_FLAG_TRICKY            ( 1L << 13 )
#define FT_FACE_FLAG_COLOR             ( 1L << 14 )
  /*************************************************************************
   *
   * @macro:
   *   FT_HAS_HORIZONTAL( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains
   *   horizontal metrics (this is true for all font formats though).
   *
   * @also:
   *   @FT_HAS_VERTICAL can be used to check for vertical metrics.
   *
   */
#define FT_HAS_HORIZONTAL( face )           ( (face)->face_flags & FT_FACE_FLAG_HORIZONTAL )
  /*************************************************************************
   *
   * @macro:
   *   FT_HAS_VERTICAL( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains real
   *   vertical metrics (and not only synthesized ones).
   *
   */
#define FT_HAS_VERTICAL( face )           ( (face)->face_flags & FT_FACE_FLAG_VERTICAL )
  /*************************************************************************
   *
   * @macro:
   *   FT_HAS_KERNING( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains kerning
   *   data that can be accessed with @FT_Get_Kerning.
   *
   */
#define FT_HAS_KERNING( face )           ( (face)->face_flags & FT_FACE_FLAG_KERNING )
  /*************************************************************************
   *
   * @macro:
   *   FT_IS_SCALABLE( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains a scalable
   *   font face (true for TrueType, Type~1, Type~42, CID, OpenType/CFF,
   *   and PFR font formats).
   *
   */
#define FT_IS_SCALABLE( face )           ( (face)->face_flags & FT_FACE_FLAG_SCALABLE )
  /*************************************************************************
   *
   * @macro:
   *   FT_IS_SFNT( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains a font
   *   whose format is based on the SFNT storage scheme.  This usually
   *   means: TrueType fonts, OpenType fonts, as well as SFNT-based embedded
   *   bitmap fonts.
   *
   *   If this macro is true, all functions defined in @FT_SFNT_NAMES_H and
   *   @FT_TRUETYPE_TABLES_H are available.
   *
   */
#define FT_IS_SFNT( face )           ( (face)->face_flags & FT_FACE_FLAG_SFNT )
  /*************************************************************************
   *
   * @macro:
   *   FT_IS_FIXED_WIDTH( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains a font face
   *   that contains fixed-width (or `monospace', `fixed-pitch', etc.)
   *   glyphs.
   *
   */
#define FT_IS_FIXED_WIDTH( face )           ( (face)->face_flags & FT_FACE_FLAG_FIXED_WIDTH )
  /*************************************************************************
   *
   * @macro:
   *   FT_HAS_FIXED_SIZES( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains some
   *   embedded bitmaps.  See the `available_sizes' field of the
   *   @FT_FaceRec structure.
   *
   */
#define FT_HAS_FIXED_SIZES( face )           ( (face)->face_flags & FT_FACE_FLAG_FIXED_SIZES )
  /*************************************************************************
   *
   * @macro:
   *   FT_HAS_FAST_GLYPHS( face )
   *
   * @description:
   *   Deprecated.
   *
   */
#define FT_HAS_FAST_GLYPHS( face )  0
  /*************************************************************************
   *
   * @macro:
   *   FT_HAS_GLYPH_NAMES( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains some glyph
   *   names that can be accessed through @FT_Get_Glyph_Name.
   *
   */
#define FT_HAS_GLYPH_NAMES( face )           ( (face)->face_flags & FT_FACE_FLAG_GLYPH_NAMES )
  /*************************************************************************
   *
   * @macro:
   *   FT_HAS_MULTIPLE_MASTERS( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains some
   *   multiple masters.  The functions provided by @FT_MULTIPLE_MASTERS_H
   *   are then available to choose the exact design you want.
   *
   */
#define FT_HAS_MULTIPLE_MASTERS( face )           ( (face)->face_flags & FT_FACE_FLAG_MULTIPLE_MASTERS )
  /*************************************************************************
   *
   * @macro:
   *   FT_IS_NAMED_INSTANCE( face )
   *
   * @description:
   *   A macro that returns true whenever a face object is a named instance
   *   of a GX or OpenType variation font.
   *
   */
#define FT_IS_NAMED_INSTANCE( face )           ( (face)->face_index & 0x7FFF0000L )
  /*************************************************************************
   *
   * @macro:
   *   FT_IS_CID_KEYED( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains a CID-keyed
   *   font.  See the discussion of @FT_FACE_FLAG_CID_KEYED for more
   *   details.
   *
   *   If this macro is true, all functions defined in @FT_CID_H are
   *   available.
   *
   */
#define FT_IS_CID_KEYED( face )           ( (face)->face_flags & FT_FACE_FLAG_CID_KEYED )
  /*************************************************************************
   *
   * @macro:
   *   FT_IS_TRICKY( face )
   *
   * @description:
   *   A macro that returns true whenever a face represents a `tricky' font.
   *   See the discussion of @FT_FACE_FLAG_TRICKY for more details.
   *
   */
#define FT_IS_TRICKY( face )           ( (face)->face_flags & FT_FACE_FLAG_TRICKY )
  /*************************************************************************
   *
   * @macro:
   *   FT_HAS_COLOR( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains
   *   tables for color glyphs.
   *
   */
#define FT_HAS_COLOR( face )           ( (face)->face_flags & FT_FACE_FLAG_COLOR )
  /*************************************************************************/
  /*                                                                       */
  /* <Const>                                                               */
  /*    FT_STYLE_FLAG_XXX                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A list of bit flags to indicate the style of a given face.  These  */
  /*    are used in the `style_flags' field of @FT_FaceRec.                */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_STYLE_FLAG_ITALIC ::                                            */
  /*      The face style is italic or oblique.                             */
  /*                                                                       */
  /*    FT_STYLE_FLAG_BOLD ::                                              */
  /*      The face is bold.                                                */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The style information as provided by FreeType is very basic.  More */
  /*    details are beyond the scope and should be done on a higher level  */
  /*    (for example, by analyzing various fields of the `OS/2' table in   */
  /*    SFNT based fonts).                                                 */
  /*                                                                       */
#define FT_STYLE_FLAG_ITALIC  ( 1 << 0 )
#define FT_STYLE_FLAG_BOLD    ( 1 << 1 )
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Size_Internal                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    An opaque handle to an `FT_Size_InternalRec' structure, used to    */
  /*    model private data of a given @FT_Size object.                     */
  /*                                                                       */
  typedef struct FT_Size_InternalRec_*  FT_Size_Internal;
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Size_Metrics                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The size metrics structure gives the metrics of a size object.     */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    x_ppem       :: The width of the scaled EM square in pixels, hence */
  /*                    the term `ppem' (pixels per EM).  It is also       */
  /*                    referred to as `nominal width'.                    */
  /*                                                                       */
  /*    y_ppem       :: The height of the scaled EM square in pixels,      */
  /*                    hence the term `ppem' (pixels per EM).  It is also */
  /*                    referred to as `nominal height'.                   */
  /*                                                                       */
  /*    x_scale      :: A 16.16 fractional scaling value to convert        */
  /*                    horizontal metrics from font units to 26.6         */
  /*                    fractional pixels.  Only relevant for scalable     */
  /*                    font formats.                                      */
  /*                                                                       */
  /*    y_scale      :: A 16.16 fractional scaling value to convert        */
  /*                    vertical metrics from font units to 26.6           */
  /*                    fractional pixels.  Only relevant for scalable     */
  /*                    font formats.                                      */
  /*                                                                       */
  /*    ascender     :: The ascender in 26.6 fractional pixels, rounded up */
  /*                    to an integer value.  See @FT_FaceRec for the      */
  /*                    details.                                           */
  /*                                                                       */
  /*    descender    :: The descender in 26.6 fractional pixels, rounded   */
  /*                    down to an integer value.  See @FT_FaceRec for the */
  /*                    details.                                           */
  /*                                                                       */
  /*    height       :: The height in 26.6 fractional pixels, rounded to   */
  /*                    an integer value.  See @FT_FaceRec for the         */
  /*                    details.                                           */
  /*                                                                       */
  /*    max_advance  :: The maximum advance width in 26.6 fractional       */
  /*                    pixels, rounded to an integer value.  See          */
  /*                    @FT_FaceRec for the details.                       */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The scaling values, if relevant, are determined first during a     */
  /*    size changing operation.  The remaining fields are then set by the */
  /*    driver.  For scalable formats, they are usually set to scaled      */
  /*    values of the corresponding fields in @FT_FaceRec.  Some values    */
  /*    like ascender or descender are rounded for historical reasons;     */
  /*    more precise values (for outline fonts) can be derived by scaling  */
  /*    the corresponding @FT_FaceRec values manually.                     */
  /*                                                                       */
  /*    Note that due to glyph hinting and the selected rendering mode     */
  /*    these values are usually not exact; consequently, they must be     */
  /*    treated as unreliable with an error margin of at least one pixel!  */
  /*                                                                       */
  /*    Indeed, the only way to get the exact metrics is to render _all_   */
  /*    glyphs.  As this would be a definite performance hit, it is up to  */
  /*    client applications to perform such computations.                  */
  /*                                                                       */
  /*    The `FT_Size_Metrics' structure is valid for bitmap fonts also.    */
  /*                                                                       */
  typedef struct  FT_Size_Metrics_
  {
    FT_UShort  x_ppem;
    FT_UShort  y_ppem;
    FT_Fixed   x_scale;
    FT_Fixed   y_scale;
    FT_Pos     ascender;
    FT_Pos     descender;
    FT_Pos     height;
    FT_Pos     max_advance;
  } FT_Size_Metrics;
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_SizeRec                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    FreeType root size class structure.  A size object models a face   */
  /*    object at a given size.                                            */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    face    :: Handle to the parent face object.                       */
  /*                                                                       */
  /*    generic :: A typeless pointer, unused by the FreeType library or   */
  /*               any of its drivers.  It can be used by client           */
  /*               applications to link their own data to each size        */
  /*               object.                                                 */
  /*                                                                       */
  /*    metrics :: Metrics for this size object.  This field is read-only. */
  /*                                                                       */
  typedef struct  FT_SizeRec_
  {
    FT_Face           face;
    FT_Generic        generic;
    FT_Size_Metrics   metrics;
    FT_Size_Internal  internal;
  } FT_SizeRec;
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_SubGlyph                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The subglyph structure is an internal object used to describe      */
  /*    subglyphs (for example, in the case of composites).                */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The subglyph implementation is not part of the high-level API,     */
  /*    hence the forward structure declaration.                           */
  /*                                                                       */
  /*    You can however retrieve subglyph information with                 */
  /*    @FT_Get_SubGlyph_Info.                                             */
  /*                                                                       */
  typedef struct FT_SubGlyphRec_*  FT_SubGlyph;
  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Slot_Internal                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    An opaque handle to an `FT_Slot_InternalRec' structure, used to    */
  /*    model private data of a given @FT_GlyphSlot object.                */
  /*                                                                       */
  typedef struct FT_Slot_InternalRec_*  FT_Slot_Internal;
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_GlyphSlotRec                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    FreeType root glyph slot class structure.  A glyph slot is a       */
  /*    container where individual glyphs can be loaded, be they in        */
  /*    outline or bitmap format.                                          */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    library           :: A handle to the FreeType library instance     */
  /*                         this slot belongs to.                         */
  /*                                                                       */
  /*    face              :: A handle to the parent face object.           */
  /*                                                                       */
  /*    next              :: In some cases (like some font tools), several */
  /*                         glyph slots per face object can be a good     */
  /*                         thing.  As this is rare, the glyph slots are  */
  /*                         listed through a direct, single-linked list   */
  /*                         using its `next' field.                       */
  /*                                                                       */
  /*    generic           :: A typeless pointer unused by the FreeType     */
  /*                         library or any of its drivers.  It can be     */
  /*                         used by client applications to link their own */
  /*                         data to each glyph slot object.               */
  /*                                                                       */
  /*    metrics           :: The metrics of the last loaded glyph in the   */
  /*                         slot.  The returned values depend on the last */
  /*                         load flags (see the @FT_Load_Glyph API        */
  /*                         function) and can be expressed either in 26.6 */
  /*                         fractional pixels or font units.              */
  /*                                                                       */
  /*                         Note that even when the glyph image is        */
  /*                         transformed, the metrics are not.             */
  /*                                                                       */
  /*    linearHoriAdvance :: The advance width of the unhinted glyph.      */
  /*                         Its value is expressed in 16.16 fractional    */
  /*                         pixels, unless @FT_LOAD_LINEAR_DESIGN is set  */
  /*                         when loading the glyph.  This field can be    */
  /*                         important to perform correct WYSIWYG layout.  */
  /*                         Only relevant for outline glyphs.             */
  /*                                                                       */
  /*    linearVertAdvance :: The advance height of the unhinted glyph.     */
  /*                         Its value is expressed in 16.16 fractional    */
  /*                         pixels, unless @FT_LOAD_LINEAR_DESIGN is set  */
  /*                         when loading the glyph.  This field can be    */
  /*                         important to perform correct WYSIWYG layout.  */
  /*                         Only relevant for outline glyphs.             */
  /*                                                                       */
  /*    advance           :: This shorthand is, depending on               */
  /*                         @FT_LOAD_IGNORE_TRANSFORM, the transformed    */
  /*                         (hinted) advance width for the glyph, in 26.6 */
  /*                         fractional pixel format.  As specified with   */
  /*                         @FT_LOAD_VERTICAL_LAYOUT, it uses either the  */
  /*                         `horiAdvance' or the `vertAdvance' value of   */
  /*                         `metrics' field.                              */
  /*                                                                       */
  /*    format            :: This field indicates the format of the image  */
  /*                         contained in the glyph slot.  Typically       */
  /*                         @FT_GLYPH_FORMAT_BITMAP,                      */
  /*                         @FT_GLYPH_FORMAT_OUTLINE, or                  */
  /*                         @FT_GLYPH_FORMAT_COMPOSITE, but other values  */
  /*                         are possible.                                 */
  /*                                                                       */
  /*    bitmap            :: This field is used as a bitmap descriptor     */
  /*                         when the slot format is                       */
  /*                         @FT_GLYPH_FORMAT_BITMAP.  Note that the       */
  /*                         address and content of the bitmap buffer can  */
  /*                         change between calls of @FT_Load_Glyph and a  */
  /*                         few other functions.                          */
  /*                                                                       */
  /*    bitmap_left       :: The bitmap's left bearing expressed in        */
  /*                         integer pixels.  Only valid if the format is  */
  /*                         @FT_GLYPH_FORMAT_BITMAP, this is, if the      */
  /*                         glyph slot contains a bitmap.                 */
  /*                                                                       */
  /*    bitmap_top        :: The bitmap's top bearing expressed in integer */
  /*                         pixels.  This is the distance from the        */
  /*                         baseline to the top-most glyph scanline,      */
  /*                         upwards y~coordinates being *positive*.       */
  /*                                                                       */
  /*    outline           :: The outline descriptor for the current glyph  */
  /*                         image if its format is                        */
  /*                         @FT_GLYPH_FORMAT_OUTLINE.  Once a glyph is    */
  /*                         loaded, `outline' can be transformed,         */
  /*                         distorted, emboldened, etc.  However, it must */
  /*                         not be freed.                                 */
  /*                                                                       */
  /*    num_subglyphs     :: The number of subglyphs in a composite glyph. */
  /*                         This field is only valid for the composite    */
  /*                         glyph format that should normally only be     */
  /*                         loaded with the @FT_LOAD_NO_RECURSE flag.     */
  /*                                                                       */
  /*    subglyphs         :: An array of subglyph descriptors for          */
  /*                         composite glyphs.  There are `num_subglyphs'  */
  /*                         elements in there.  Currently internal to     */
  /*                         FreeType.                                     */
  /*                                                                       */
  /*    control_data      :: Certain font drivers can also return the      */
  /*                         control data for a given glyph image (e.g.    */
  /*                         TrueType bytecode, Type~1 charstrings, etc.). */
  /*                         This field is a pointer to such data; it is   */
  /*                         currently internal to FreeType.               */
  /*                                                                       */
  /*    control_len       :: This is the length in bytes of the control    */
  /*                         data.  Currently internal to FreeType.        */
  /*                                                                       */
  /*    other             :: Reserved.                                     */
  /*                                                                       */
  /*    lsb_delta         :: The difference between hinted and unhinted    */
  /*                         left side bearing while auto-hinting is       */
  /*                         active.  Zero otherwise.                      */
  /*                                                                       */
  /*    rsb_delta         :: The difference between hinted and unhinted    */
  /*                         right side bearing while auto-hinting is      */
  /*                         active.  Zero otherwise.                      */
  /*                                                                       */
  /* <Note>                                                                */
  /*    If @FT_Load_Glyph is called with default flags (see                */
  /*    @FT_LOAD_DEFAULT) the glyph image is loaded in the glyph slot in   */
  /*    its native format (e.g., an outline glyph for TrueType and Type~1  */
  /*    formats).                                                          */
  /*                                                                       */
  /*    This image can later be converted into a bitmap by calling         */
  /*    @FT_Render_Glyph.  This function searches the current renderer for */
  /*    the native image's format, then invokes it.                        */
  /*                                                                       */
  /*    The renderer is in charge of transforming the native image through */
  /*    the slot's face transformation fields, then converting it into a   */
  /*    bitmap that is returned in `slot->bitmap'.                         */
  /*                                                                       */
  /*    Note that `slot->bitmap_left' and `slot->bitmap_top' are also used */
  /*    to specify the position of the bitmap relative to the current pen  */
  /*    position (e.g., coordinates (0,0) on the baseline).  Of course,    */
  /*    `slot->format' is also changed to @FT_GLYPH_FORMAT_BITMAP.         */
  /*                                                                       */
  /*    Here is a small pseudo code fragment that shows how to use         */
  /*    `lsb_delta' and `rsb_delta' to do fractional positioning of        */
  /*    glyphs:                                                            */
  /*                                                                       */
  /*    {                                                                  */
  /*      FT_GlyphSlot  slot     = face->glyph;                            */
  /*      FT_Pos        origin_x = 0;                                      */
  /*                                                                       */
  /*                                                                       */
  /*      for all glyphs do                                                */
  /*        <load glyph with `FT_Load_Glyph'>                              */
  /*                                                                       */
  /*        FT_Outline_Translate( slot->outline, origin_x & 63, 0 );       */
  /*                                                                       */
  /*        <save glyph image, or render glyph, or ...>                    */
  /*                                                                       */
  /*        <compute kern between current and next glyph                   */
  /*         and add it to `origin_x'>                                     */
  /*                                                                       */
  /*        origin_x += slot->advance.x;                                   */
  /*        origin_x += slot->rsb_delta - slot->lsb_relta;                 */
  /*      endfor                                                           */
  /*    }                                                                  */
  /*                                                                       */
  /*    Here is another small pseudo code fragment that shows how to use   */
  /*    `lsb_delta' and `rsb_delta' to improve integer positioning of      */
  /*    glyphs:                                                            */
  /*                                                                       */
  /*    {                                                                  */
  /*      FT_GlyphSlot  slot           = face->glyph;                      */
  /*      FT_Pos        origin_x       = 0;                                */
  /*      FT_Pos        prev_rsb_delta = 0;                                */
  /*                                                                       */
  /*                                                                       */
  /*      for all glyphs do                                                */
  /*        <compute kern between current and previous glyph               */
  /*         and add it to `origin_x'>                                     */
  /*                                                                       */
  /*        <load glyph with `FT_Load_Glyph'>                              */
  /*                                                                       */
  /*        if ( prev_rsb_delta - slot->lsb_delta >= 32 )                  */
  /*          origin_x -= 64;                                              */
  /*        else if ( prev_rsb_delta - slot->lsb_delta < -32 )             */
  /*          origin_x += 64;                                              */
  /*                                                                       */
  /*        prev_rsb_delta = slot->rsb_delta;                              */
  /*                                                                       */
  /*        <save glyph image, or render glyph, or ...>                    */
  /*                                                                       */
  /*        origin_x += slot->advance.x;                                   */
  /*      endfor                                                           */
  /*    }                                                                  */
  /*                                                                       */
  /*    If you use strong auto-hinting, you *must* apply these delta       */
  /*    values!  Otherwise you will experience far too large inter-glyph   */
  /*    spacing at small rendering sizes in most cases.  Note that it      */
  /*    doesn't harm to use the above code for other hinting modes also,   */
  /*    since the delta values are zero then.                              */
  /*                                                                       */
  typedef struct  FT_GlyphSlotRec_
  {
    FT_Library        library;
    FT_Face           face;
    FT_GlyphSlot      next;
    FT_UInt           reserved;
    FT_Generic        generic;
    FT_Glyph_Metrics  metrics;
    FT_Fixed          linearHoriAdvance;
    FT_Fixed          linearVertAdvance;
    FT_Vector         advance;
    FT_Glyph_Format   format;
    FT_Bitmap         bitmap;
    FT_Int            bitmap_left;
    FT_Int            bitmap_top;
    FT_Outline        outline;
    FT_UInt           num_subglyphs;
    FT_SubGlyph       subglyphs;
    void*             control_data;
    long              control_len;
    FT_Pos            lsb_delta;
    FT_Pos            rsb_delta;
    void*             other;
    FT_Slot_Internal  internal;
  } FT_GlyphSlotRec;
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /*                         F U N C T I O N S                             */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Init_FreeType                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Initialize a new FreeType library object.  The set of modules      */
  /*    that are registered by this function is determined at build time.  */
  /*                                                                       */
  /* <Output>                                                              */
  /*    alibrary :: A handle to a new library object.                      */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    In case you want to provide your own memory allocating routines,   */
  /*    use @FT_New_Library instead, followed by a call to                 */
  /*    @FT_Add_Default_Modules (or a series of calls to @FT_Add_Module)   */
  /*    and @FT_Set_Default_Properties.                                    */
  /*                                                                       */
  /*    See the documentation of @FT_Library and @FT_Face for              */
  /*    multi-threading issues.                                            */
  /*                                                                       */
  /*    If you need reference-counting (cf. @FT_Reference_Library), use    */
  /*    @FT_New_Library and @FT_Done_Library.                              */
  /*                                                                       */
  /*    If compilation option FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES is   */
  /*    set, this function reads the `FREETYPE_PROPERTIES' environment     */
  /*    variable to control driver properties.  See sections @auto_hinter, */
  /*    @cff_driver, @pcf_driver, and @tt_driver for more.                 */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Init_FreeType( FT_Library  *alibrary );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Done_FreeType                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Destroy a given FreeType library object and all of its children,   */
  /*    including resources, drivers, faces, sizes, etc.                   */
  /*                                                                       */
  /* <Input>                                                               */
  /*    library :: A handle to the target library object.                  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Done_FreeType( FT_Library  library );
  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_OPEN_XXX                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A list of bit field constants used within the `flags' field of the */
  /*    @FT_Open_Args structure.                                           */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_OPEN_MEMORY   :: This is a memory-based stream.                 */
  /*                                                                       */
  /*    FT_OPEN_STREAM   :: Copy the stream from the `stream' field.       */
  /*                                                                       */
  /*    FT_OPEN_PATHNAME :: Create a new input stream from a C~path        */
  /*                        name.                                          */
  /*                                                                       */
  /*    FT_OPEN_DRIVER   :: Use the `driver' field.                        */
  /*                                                                       */
  /*    FT_OPEN_PARAMS   :: Use the `num_params' and `params' fields.      */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The `FT_OPEN_MEMORY', `FT_OPEN_STREAM', and `FT_OPEN_PATHNAME'     */
  /*    flags are mutually exclusive.                                      */
  /*                                                                       */
#define FT_OPEN_MEMORY    0x1
#define FT_OPEN_STREAM    0x2
#define FT_OPEN_PATHNAME  0x4
#define FT_OPEN_DRIVER    0x8
#define FT_OPEN_PARAMS    0x10
  /* these constants are deprecated; use the corresponding `FT_OPEN_XXX' */
  /* values instead                                                      */
#define ft_open_memory    FT_OPEN_MEMORY
#define ft_open_stream    FT_OPEN_STREAM
#define ft_open_pathname  FT_OPEN_PATHNAME
#define ft_open_driver    FT_OPEN_DRIVER
#define ft_open_params    FT_OPEN_PARAMS
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Parameter                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A simple structure to pass more or less generic parameters to      */
  /*    @FT_Open_Face and @FT_Face_Properties.                             */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    tag  :: A four-byte identification tag.                            */
  /*                                                                       */
  /*    data :: A pointer to the parameter data.                           */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The ID and function of parameters are driver-specific.  See the    */
  /*    various FT_PARAM_TAG_XXX flags for more information.               */
  /*                                                                       */
  typedef struct  FT_Parameter_
  {
    FT_ULong    tag;
    FT_Pointer  data;
  } FT_Parameter;
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Open_Args                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A structure to indicate how to open a new font file or stream.  A  */
  /*    pointer to such a structure can be used as a parameter for the     */
  /*    functions @FT_Open_Face and @FT_Attach_Stream.                     */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    flags       :: A set of bit flags indicating how to use the        */
  /*                   structure.                                          */
  /*                                                                       */
  /*    memory_base :: The first byte of the file in memory.               */
  /*                                                                       */
  /*    memory_size :: The size in bytes of the file in memory.            */
  /*                                                                       */
  /*    pathname    :: A pointer to an 8-bit file pathname.                */
  /*                                                                       */
  /*    stream      :: A handle to a source stream object.                 */
  /*                                                                       */
  /*    driver      :: This field is exclusively used by @FT_Open_Face;    */
  /*                   it simply specifies the font driver to use for      */
  /*                   opening the face.  If set to NULL, FreeType tries   */
  /*                   to load the face with each one of the drivers in    */
  /*                   its list.                                           */
  /*                                                                       */
  /*    num_params  :: The number of extra parameters.                     */
  /*                                                                       */
  /*    params      :: Extra parameters passed to the font driver when     */
  /*                   opening a new face.                                 */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The stream type is determined by the contents of `flags' that      */
  /*    are tested in the following order by @FT_Open_Face:                */
  /*                                                                       */
  /*    If the @FT_OPEN_MEMORY bit is set, assume that this is a           */
  /*    memory file of `memory_size' bytes, located at `memory_address'.   */
  /*    The data are not copied, and the client is responsible for         */
  /*    releasing and destroying them _after_ the corresponding call to    */
  /*    @FT_Done_Face.                                                     */
  /*                                                                       */
  /*    Otherwise, if the @FT_OPEN_STREAM bit is set, assume that a        */
  /*    custom input stream `stream' is used.                              */
  /*                                                                       */
  /*    Otherwise, if the @FT_OPEN_PATHNAME bit is set, assume that this   */
  /*    is a normal file and use `pathname' to open it.                    */
  /*                                                                       */
  /*    If the @FT_OPEN_DRIVER bit is set, @FT_Open_Face only tries to     */
  /*    open the file with the driver whose handler is in `driver'.        */
  /*                                                                       */
  /*    If the @FT_OPEN_PARAMS bit is set, the parameters given by         */
  /*    `num_params' and `params' is used.  They are ignored otherwise.    */
  /*                                                                       */
  /*    Ideally, both the `pathname' and `params' fields should be tagged  */
  /*    as `const'; this is missing for API backward compatibility.  In    */
  /*    other words, applications should treat them as read-only.          */
  /*                                                                       */
  typedef struct  FT_Open_Args_
  {
    FT_UInt         flags;
    const FT_Byte*  memory_base;
    FT_Long         memory_size;
    FT_String*      pathname;
    FT_Stream       stream;
    FT_Module       driver;
    FT_Int          num_params;
    FT_Parameter*   params;
  } FT_Open_Args;
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_New_Face                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Call @FT_Open_Face to open a font by its pathname.                 */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    library    :: A handle to the library resource.                    */
  /*                                                                       */
  /* <Input>                                                               */
  /*    pathname   :: A path to the font file.                             */
  /*                                                                       */
  /*    face_index :: See @FT_Open_Face for a detailed description of this */
  /*                  parameter.                                           */
  /*                                                                       */
  /* <Output>                                                              */
  /*    aface      :: A handle to a new face object.  If `face_index' is   */
  /*                  greater than or equal to zero, it must be non-NULL.  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Use @FT_Done_Face to destroy the created @FT_Face object (along    */
  /*    with its slot and sizes).                                          */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_New_Face( FT_Library   library,
               const char*  filepathname,
               FT_Long      face_index,
               FT_Face     *aface );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_New_Memory_Face                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Call @FT_Open_Face to open a font that has been loaded into        */
  /*    memory.                                                            */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    library    :: A handle to the library resource.                    */
  /*                                                                       */
  /* <Input>                                                               */
  /*    file_base  :: A pointer to the beginning of the font data.         */
  /*                                                                       */
  /*    file_size  :: The size of the memory chunk used by the font data.  */
  /*                                                                       */
  /*    face_index :: See @FT_Open_Face for a detailed description of this */
  /*                  parameter.                                           */
  /*                                                                       */
  /* <Output>                                                              */
  /*    aface      :: A handle to a new face object.  If `face_index' is   */
  /*                  greater than or equal to zero, it must be non-NULL.  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    You must not deallocate the memory before calling @FT_Done_Face.   */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_New_Memory_Face( FT_Library      library,
                      const FT_Byte*  file_base,
                      FT_Long         file_size,
                      FT_Long         face_index,
                      FT_Face        *aface );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Open_Face                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Create a face object from a given resource described by            */
  /*    @FT_Open_Args.                                                     */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    library    :: A handle to the library resource.                    */
  /*                                                                       */
  /* <Input>                                                               */
  /*    args       :: A pointer to an `FT_Open_Args' structure that must   */
  /*                  be filled by the caller.                             */
  /*                                                                       */
  /*    face_index :: This field holds two different values.  Bits 0-15    */
  /*                  are the index of the face in the font file (starting */
  /*                  with value~0).  Set it to~0 if there is only one     */
  /*                  face in the font file.                               */
  /*                                                                       */
  /*                  Bits 16-30 are relevant to GX and OpenType variation */
  /*                  fonts only, specifying the named instance index for  */
  /*                  the current face index (starting with value~1;       */
  /*                  value~0 makes FreeType ignore named instances).  For */
  /*                  non-variation fonts, bits 16-30 are ignored.         */
  /*                  Assuming that you want to access the third named     */
  /*                  instance in face~4, `face_index' should be set to    */
  /*                  0x00030004.  If you want to access face~4 without    */
  /*                  variation handling, simply set `face_index' to       */
  /*                  value~4.                                             */
  /*                                                                       */
  /*                  `FT_Open_Face' and its siblings can be used to       */
  /*                  quickly check whether the font format of a given     */
  /*                  font resource is supported by FreeType.  In general, */
  /*                  if the `face_index' argument is negative, the        */
  /*                  function's return value is~0 if the font format is   */
  /*                  recognized, or non-zero otherwise.  The function     */
  /*                  allocates a more or less empty face handle in        */
  /*                  `*aface' (if `aface' isn't NULL); the only two       */
  /*                  useful fields in this special case are               */
  /*                  `face->num_faces' and `face->style_flags'.  For any  */
  /*                  negative value of `face_index', `face->num_faces'    */
  /*                  gives the number of faces within the font file.  For */
  /*                  the negative value `-(N+1)' (with `N' a non-negative */
  /*                  16-bit value), bits 16-30 in `face->style_flags'     */
  /*                  give the number of named instances in face `N' if we */
  /*                  have a variation font (or zero otherwise).  After    */
  /*                  examination, the returned @FT_Face structure should  */
  /*                  be deallocated with a call to @FT_Done_Face.         */
  /*                                                                       */
  /* <Output>                                                              */
  /*    aface      :: A handle to a new face object.  If `face_index' is   */
  /*                  greater than or equal to zero, it must be non-NULL.  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Unlike FreeType 1.x, this function automatically creates a glyph   */
  /*    slot for the face object that can be accessed directly through     */
  /*    `face->glyph'.                                                     */
  /*                                                                       */
  /*    Each new face object created with this function also owns a        */
  /*    default @FT_Size object, accessible as `face->size'.               */
  /*                                                                       */
  /*    One @FT_Library instance can have multiple face objects, this is,  */
  /*    @FT_Open_Face and its siblings can be called multiple times using  */
  /*    the same `library' argument.                                       */
  /*                                                                       */
  /*    See the discussion of reference counters in the description of     */
  /*    @FT_Reference_Face.                                                */
  /*                                                                       */
  /*    To loop over all faces, use code similar to the following snippet  */
  /*    (omitting the error handling).                                     */
  /*                                                                       */
  /*    {                                                                  */
  /*      ...                                                              */
  /*      FT_Face  face;                                                   */
  /*      FT_Long  i, num_faces;                                           */
  /*                                                                       */
  /*                                                                       */
  /*      error = FT_Open_Face( library, args, -1, &face );                */
  /*      if ( error ) { ... }                                             */
  /*                                                                       */
  /*      num_faces = face->num_faces;                                     */
  /*      FT_Done_Face( face );                                            */
  /*                                                                       */
  /*      for ( i = 0; i < num_faces; i++ )                                */
  /*      {                                                                */
  /*        ...                                                            */
  /*        error = FT_Open_Face( library, args, i, &face );               */
  /*        ...                                                            */
  /*        FT_Done_Face( face );                                          */
  /*        ...                                                            */
  /*      }                                                                */
  /*    }                                                                  */
  /*                                                                       */
  /*    To loop over all valid values for `face_index', use something      */
  /*    similar to the following snippet, again without error handling.    */
  /*    The code accesses all faces immediately (thus only a single call   */
  /*    of `FT_Open_Face' within the do-loop), with and without named      */
  /*    instances.                                                         */
  /*                                                                       */
  /*    {                                                                  */
  /*      ...                                                              */
  /*      FT_Face  face;                                                   */
  /*                                                                       */
  /*      FT_Long  num_faces     = 0;                                      */
  /*      FT_Long  num_instances = 0;                                      */
  /*                                                                       */
  /*      FT_Long  face_idx     = 0;                                       */
  /*      FT_Long  instance_idx = 0;                                       */
  /*                                                                       */
  /*                                                                       */
  /*      do                                                               */
  /*      {                                                                */
  /*        FT_Long  id = ( instance_idx << 16 ) + face_idx;               */
  /*                                                                       */
  /*                                                                       */
  /*        error = FT_Open_Face( library, args, id, &face );              */
  /*        if ( error ) { ... }                                           */
  /*                                                                       */
  /*        num_faces     = face->num_faces;                               */
  /*        num_instances = face->style_flags >> 16;                       */
  /*                                                                       */
  /*        ...                                                            */
  /*                                                                       */
  /*        FT_Done_Face( face );                                          */
  /*                                                                       */
  /*        if ( instance_idx < num_instances )                            */
  /*          instance_idx++;                                              */
  /*        else                                                           */
  /*        {                                                              */
  /*          face_idx++;                                                  */
  /*          instance_idx = 0;                                            */
  /*        }                                                              */
  /*                                                                       */
  /*      } while ( face_idx < num_faces )                                 */
  /*    }                                                                  */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Open_Face( FT_Library           library,
                const FT_Open_Args*  args,
                FT_Long              face_index,
                FT_Face             *aface );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Attach_File                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Call @FT_Attach_Stream to attach a file.                           */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face         :: The target face object.                            */
  /*                                                                       */
  /* <Input>                                                               */
  /*    filepathname :: The pathname.                                      */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Attach_File( FT_Face      face,
                  const char*  filepathname );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Attach_Stream                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    `Attach' data to a face object.  Normally, this is used to read    */
  /*    additional information for the face object.  For example, you can  */
  /*    attach an AFM file that comes with a Type~1 font to get the        */
  /*    kerning values and other metrics.                                  */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face       :: The target face object.                              */
  /*                                                                       */
  /* <Input>                                                               */
  /*    parameters :: A pointer to @FT_Open_Args that must be filled by    */
  /*                  the caller.                                          */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The meaning of the `attach' (i.e., what really happens when the    */
  /*    new file is read) is not fixed by FreeType itself.  It really      */
  /*    depends on the font format (and thus the font driver).             */
  /*                                                                       */
  /*    Client applications are expected to know what they are doing       */
  /*    when invoking this function.  Most drivers simply do not implement */
  /*    file or stream attachments.                                        */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Attach_Stream( FT_Face        face,
                    FT_Open_Args*  parameters );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Reference_Face                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A counter gets initialized to~1 at the time an @FT_Face structure  */
  /*    is created.  This function increments the counter.  @FT_Done_Face  */
  /*    then only destroys a face if the counter is~1, otherwise it simply */
  /*    decrements the counter.                                            */
  /*                                                                       */
  /*    This function helps in managing life-cycles of structures that     */
  /*    reference @FT_Face objects.                                        */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face :: A handle to a target face object.                          */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Since>                                                               */
  /*    2.4.2                                                              */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Reference_Face( FT_Face  face );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Done_Face                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Discard a given face object, as well as all of its child slots and */
  /*    sizes.                                                             */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face :: A handle to a target face object.                          */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    See the discussion of reference counters in the description of     */
  /*    @FT_Reference_Face.                                                */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Done_Face( FT_Face  face );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Select_Size                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Select a bitmap strike.  To be more precise, this function sets    */
  /*    the scaling factors of the active @FT_Size object in a face so     */
  /*    that bitmaps from this particular strike are taken by              */
  /*    @FT_Load_Glyph and friends.                                        */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face         :: A handle to a target face object.                  */
  /*                                                                       */
  /* <Input>                                                               */
  /*    strike_index :: The index of the bitmap strike in the              */
  /*                    `available_sizes' field of @FT_FaceRec structure.  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    For bitmaps embedded in outline fonts it is common that only a     */
  /*    subset of the available glyphs at a given ppem value is available. */
  /*    FreeType silently uses outlines if there is no bitmap for a given  */
  /*    glyph index.                                                       */
  /*                                                                       */
  /*    For GX and OpenType variation fonts, a bitmap strike makes sense   */
  /*    only if the default instance is active (this is, no glyph          */
  /*    variation takes place); otherwise, FreeType simply ignores bitmap  */
  /*    strikes.  The same is true for all named instances that are        */
  /*    different from the default instance.                               */
  /*                                                                       */
  /*    Don't use this function if you are using the FreeType cache API.   */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Select_Size( FT_Face  face,
                  FT_Int   strike_index );
  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_Size_Request_Type                                               */
  /*                                                                       */
  /* <Description>                                                         */
  /*    An enumeration type that lists the supported size request types,   */
  /*    i.e., what input size (in font units) maps to the requested output */
  /*    size (in pixels, as computed from the arguments of                 */
  /*    @FT_Size_Request).                                                 */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_SIZE_REQUEST_TYPE_NOMINAL ::                                    */
  /*      The nominal size.  The `units_per_EM' field of @FT_FaceRec is    */
  /*      used to determine both scaling values.                           */
  /*                                                                       */
  /*      This is the standard scaling found in most applications.  In     */
  /*      particular, use this size request type for TrueType fonts if     */
  /*      they provide optical scaling or something similar.  Note,        */
  /*      however, that `units_per_EM' is a rather abstract value which    */
  /*      bears no relation to the actual size of the glyphs in a font.    */
  /*                                                                       */
  /*    FT_SIZE_REQUEST_TYPE_REAL_DIM ::                                   */
  /*      The real dimension.  The sum of the `ascender' and (minus of)    */
  /*      the `descender' fields of @FT_FaceRec is used to determine both  */
  /*      scaling values.                                                  */
  /*                                                                       */
  /*    FT_SIZE_REQUEST_TYPE_BBOX ::                                       */
  /*      The font bounding box.  The width and height of the `bbox' field */
  /*      of @FT_FaceRec are used to determine the horizontal and vertical */
  /*      scaling value, respectively.                                     */
  /*                                                                       */
  /*    FT_SIZE_REQUEST_TYPE_CELL ::                                       */
  /*      The `max_advance_width' field of @FT_FaceRec is used to          */
  /*      determine the horizontal scaling value; the vertical scaling     */
  /*      value is determined the same way as                              */
  /*      @FT_SIZE_REQUEST_TYPE_REAL_DIM does.  Finally, both scaling      */
  /*      values are set to the smaller one.  This type is useful if you   */
  /*      want to specify the font size for, say, a window of a given      */
  /*      dimension and 80x24 cells.                                       */
  /*                                                                       */
  /*    FT_SIZE_REQUEST_TYPE_SCALES ::                                     */
  /*      Specify the scaling values directly.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The above descriptions only apply to scalable formats.  For bitmap */
  /*    formats, the behaviour is up to the driver.                        */
  /*                                                                       */
  /*    See the note section of @FT_Size_Metrics if you wonder how size    */
  /*    requesting relates to scaling values.                              */
  /*                                                                       */
  typedef enum  FT_Size_Request_Type_
  {
    FT_SIZE_REQUEST_TYPE_NOMINAL,
    FT_SIZE_REQUEST_TYPE_REAL_DIM,
    FT_SIZE_REQUEST_TYPE_BBOX,
    FT_SIZE_REQUEST_TYPE_CELL,
    FT_SIZE_REQUEST_TYPE_SCALES,
    FT_SIZE_REQUEST_TYPE_MAX
  } FT_Size_Request_Type;
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Size_RequestRec                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A structure to model a size request.                               */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    type           :: See @FT_Size_Request_Type.                       */
  /*                                                                       */
  /*    width          :: The desired width, given as a 26.6 fractional    */
  /*                      point value (with 72pt = 1in).                   */
  /*                                                                       */
  /*    height         :: The desired height, given as a 26.6 fractional   */
  /*                      point value (with 72pt = 1in).                   */
  /*                                                                       */
  /*    horiResolution :: The horizontal resolution (dpi, i.e., pixels per */
  /*                      inch).  If set to zero, `width' is treated as a  */
  /*                      26.6 fractional *pixel* value, which gets        */
  /*                      internally rounded to an integer.                */
  /*                                                                       */
  /*    vertResolution :: The vertical resolution (dpi, i.e., pixels per   */
  /*                      inch).  If set to zero, `height' is treated as a */
  /*                      26.6 fractional *pixel* value, which gets        */
  /*                      internally rounded to an integer.                */
  /*                                                                       */
  /* <Note>                                                                */
  /*    If `width' is zero, the horizontal scaling value is set equal      */
  /*    to the vertical scaling value, and vice versa.                     */
  /*                                                                       */
  /*    If `type' is FT_SIZE_REQUEST_TYPE_SCALES, `width' and `height' are */
  /*    interpreted directly as 16.16 fractional scaling values, without   */
  /*    any further modification, and both `horiResolution' and            */
  /*    `vertResolution' are ignored.                                      */
  /*                                                                       */
  typedef struct  FT_Size_RequestRec_
  {
    FT_Size_Request_Type  type;
    FT_Long               width;
    FT_Long               height;
    FT_UInt               horiResolution;
    FT_UInt               vertResolution;
  } FT_Size_RequestRec;
  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Size_Request                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a size request structure.                              */
  /*                                                                       */
  typedef struct FT_Size_RequestRec_  *FT_Size_Request;
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Request_Size                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Resize the scale of the active @FT_Size object in a face.          */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face :: A handle to a target face object.                          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    req  :: A pointer to a @FT_Size_RequestRec.                        */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Although drivers may select the bitmap strike matching the         */
  /*    request, you should not rely on this if you intend to select a     */
  /*    particular bitmap strike.  Use @FT_Select_Size instead in that     */
  /*    case.                                                              */
  /*                                                                       */
  /*    The relation between the requested size and the resulting glyph    */
  /*    size is dependent entirely on how the size is defined in the       */
  /*    source face.  The font designer chooses the final size of each     */
  /*    glyph relative to this size.  For more information refer to        */
  /*    `https://www.freetype.org/freetype2/docs/glyphs/glyphs-2.html'.    */
  /*                                                                       */
  /*    Contrary to @FT_Set_Char_Size, this function doesn't have special  */
  /*    code to normalize zero-valued widths, heights, or resolutions      */
  /*    (which lead to errors in most cases).                              */
  /*                                                                       */
  /*    Don't use this function if you are using the FreeType cache API.   */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Request_Size( FT_Face          face,
                   FT_Size_Request  req );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Set_Char_Size                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Call @FT_Request_Size to request the nominal size (in points).     */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face            :: A handle to a target face object.               */
  /*                                                                       */
  /* <Input>                                                               */
  /*    char_width      :: The nominal width, in 26.6 fractional points.   */
  /*                                                                       */
  /*    char_height     :: The nominal height, in 26.6 fractional points.  */
  /*                                                                       */
  /*    horz_resolution :: The horizontal resolution in dpi.               */
  /*                                                                       */
  /*    vert_resolution :: The vertical resolution in dpi.                 */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    While this function allows fractional points as input values, the  */
  /*    resulting ppem value for the given resolution is always rounded to */
  /*    the nearest integer.                                               */
  /*                                                                       */
  /*    If either the character width or height is zero, it is set equal   */
  /*    to the other value.                                                */
  /*                                                                       */
  /*    If either the horizontal or vertical resolution is zero, it is set */
  /*    equal to the other value.                                          */
  /*                                                                       */
  /*    A character width or height smaller than 1pt is set to 1pt; if     */
  /*    both resolution values are zero, they are set to 72dpi.            */
  /*                                                                       */
  /*    Don't use this function if you are using the FreeType cache API.   */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Set_Char_Size( FT_Face     face,
                    FT_F26Dot6  char_width,
                    FT_F26Dot6  char_height,
                    FT_UInt     horz_resolution,
                    FT_UInt     vert_resolution );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Set_Pixel_Sizes                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Call @FT_Request_Size to request the nominal size (in pixels).     */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face         :: A handle to the target face object.                */
  /*                                                                       */
  /* <Input>                                                               */
  /*    pixel_width  :: The nominal width, in pixels.                      */
  /*                                                                       */
  /*    pixel_height :: The nominal height, in pixels.                     */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    You should not rely on the resulting glyphs matching or being      */
  /*    constrained to this pixel size.  Refer to @FT_Request_Size to      */
  /*    understand how requested sizes relate to actual sizes.             */
  /*                                                                       */
  /*    Don't use this function if you are using the FreeType cache API.   */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Set_Pixel_Sizes( FT_Face  face,
                      FT_UInt  pixel_width,
                      FT_UInt  pixel_height );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Load_Glyph                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Load a glyph into the glyph slot of a face object.                 */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face        :: A handle to the target face object where the glyph  */
  /*                   is loaded.                                          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    glyph_index :: The index of the glyph in the font file.  For       */
  /*                   CID-keyed fonts (either in PS or in CFF format)     */
  /*                   this argument specifies the CID value.              */
  /*                                                                       */
  /*    load_flags  :: A flag indicating what to load for this glyph.  The */
  /*                   @FT_LOAD_XXX constants can be used to control the   */
  /*                   glyph loading process (e.g., whether the outline    */
  /*                   should be scaled, whether to load bitmaps or not,   */
  /*                   whether to hint the outline, etc).                  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The loaded glyph may be transformed.  See @FT_Set_Transform for    */
  /*    the details.                                                       */
  /*                                                                       */
  /*    For subsetted CID-keyed fonts, `FT_Err_Invalid_Argument' is        */
  /*    returned for invalid CID values (this is, for CID values that      */
  /*    don't have a corresponding glyph in the font).  See the discussion */
  /*    of the @FT_FACE_FLAG_CID_KEYED flag for more details.              */
  /*                                                                       */
  /*    If you receive `FT_Err_Glyph_Too_Big', try getting the glyph       */
  /*    outline at EM size, then scale it manually and fill it as a        */
  /*    graphics operation.                                                */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Load_Glyph( FT_Face   face,
                 FT_UInt   glyph_index,
                 FT_Int32  load_flags );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Load_Char                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Load a glyph into the glyph slot of a face object, accessed by its */
  /*    character code.                                                    */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face        :: A handle to a target face object where the glyph    */
  /*                   is loaded.                                          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    char_code   :: The glyph's character code, according to the        */
  /*                   current charmap used in the face.                   */
  /*                                                                       */
  /*    load_flags  :: A flag indicating what to load for this glyph.  The */
  /*                   @FT_LOAD_XXX constants can be used to control the   */
  /*                   glyph loading process (e.g., whether the outline    */
  /*                   should be scaled, whether to load bitmaps or not,   */
  /*                   whether to hint the outline, etc).                  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    This function simply calls @FT_Get_Char_Index and @FT_Load_Glyph.  */
  /*                                                                       */
  /*    Many fonts contain glyphs that can't be loaded by this function    */
  /*    since its glyph indices are not listed in any of the font's        */
  /*    charmaps.                                                          */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Load_Char( FT_Face   face,
                FT_ULong  char_code,
                FT_Int32  load_flags );
  /*************************************************************************
   *
   * @enum:
   *   FT_LOAD_XXX
   *
   * @description:
   *   A list of bit field constants for @FT_Load_Glyph to indicate what
   *   kind of operations to perform during glyph loading.
   *
   * @values:
   *   FT_LOAD_DEFAULT ::
   *     Corresponding to~0, this value is used as the default glyph load
   *     operation.  In this case, the following happens:
   *
   *     1. FreeType looks for a bitmap for the glyph corresponding to the
   *        face's current size.  If one is found, the function returns.
   *        The bitmap data can be accessed from the glyph slot (see note
   *        below).
   *
   *     2. If no embedded bitmap is searched for or found, FreeType looks
   *        for a scalable outline.  If one is found, it is loaded from
   *        the font file, scaled to device pixels, then `hinted' to the
   *        pixel grid in order to optimize it.  The outline data can be
   *        accessed from the glyph slot (see note below).
   *
   *     Note that by default the glyph loader doesn't render outlines into
   *     bitmaps.  The following flags are used to modify this default
   *     behaviour to more specific and useful cases.
   *
   *   FT_LOAD_NO_SCALE ::
   *     Don't scale the loaded outline glyph but keep it in font units.
   *
   *     This flag implies @FT_LOAD_NO_HINTING and @FT_LOAD_NO_BITMAP, and
   *     unsets @FT_LOAD_RENDER.
   *
   *     If the font is `tricky' (see @FT_FACE_FLAG_TRICKY for more), using
   *     FT_LOAD_NO_SCALE usually yields meaningless outlines because the
   *     subglyphs must be scaled and positioned with hinting instructions.
   *     This can be solved by loading the font without FT_LOAD_NO_SCALE and
   *     setting the character size to `font->units_per_EM'.
   *
   *   FT_LOAD_NO_HINTING ::
   *     Disable hinting.  This generally generates `blurrier' bitmap glyphs
   *     when the glyph are rendered in any of the anti-aliased modes.  See
   *     also the note below.
   *
   *     This flag is implied by @FT_LOAD_NO_SCALE.
   *
   *   FT_LOAD_RENDER ::
   *     Call @FT_Render_Glyph after the glyph is loaded.  By default, the
   *     glyph is rendered in @FT_RENDER_MODE_NORMAL mode.  This can be
   *     overridden by @FT_LOAD_TARGET_XXX or @FT_LOAD_MONOCHROME.
   *
   *     This flag is unset by @FT_LOAD_NO_SCALE.
   *
   *   FT_LOAD_NO_BITMAP ::
   *     Ignore bitmap strikes when loading.  Bitmap-only fonts ignore this
   *     flag.
   *
   *     @FT_LOAD_NO_SCALE always sets this flag.
   *
   *   FT_LOAD_VERTICAL_LAYOUT ::
   *     Load the glyph for vertical text layout.  In particular, the
   *     `advance' value in the @FT_GlyphSlotRec structure is set to the
   *     `vertAdvance' value of the `metrics' field.
   *
   *     In case @FT_HAS_VERTICAL doesn't return true, you shouldn't use
   *     this flag currently.  Reason is that in this case vertical metrics
   *     get synthesized, and those values are not always consistent across
   *     various font formats.
   *
   *   FT_LOAD_FORCE_AUTOHINT ::
   *     Prefer the auto-hinter over the font's native hinter.  See also
   *     the note below.
   *
   *   FT_LOAD_PEDANTIC ::
   *     Make the font driver perform pedantic verifications during glyph
   *     loading.  This is mostly used to detect broken glyphs in fonts.
   *     By default, FreeType tries to handle broken fonts also.
   *
   *     In particular, errors from the TrueType bytecode engine are not
   *     passed to the application if this flag is not set; this might
   *     result in partially hinted or distorted glyphs in case a glyph's
   *     bytecode is buggy.
   *
   *   FT_LOAD_NO_RECURSE ::
   *     Don't load composite glyphs recursively.  Instead, the font
   *     driver should set the `num_subglyph' and `subglyphs' values of
   *     the glyph slot accordingly, and set `glyph->format' to
   *     @FT_GLYPH_FORMAT_COMPOSITE.  The description of subglyphs can
   *     then be accessed with @FT_Get_SubGlyph_Info.
   *
   *     This flag implies @FT_LOAD_NO_SCALE and @FT_LOAD_IGNORE_TRANSFORM.
   *
   *   FT_LOAD_IGNORE_TRANSFORM ::
   *     Ignore the transform matrix set by @FT_Set_Transform.
   *
   *   FT_LOAD_MONOCHROME ::
   *     This flag is used with @FT_LOAD_RENDER to indicate that you want to
   *     render an outline glyph to a 1-bit monochrome bitmap glyph, with
   *     8~pixels packed into each byte of the bitmap data.
   *
   *     Note that this has no effect on the hinting algorithm used.  You
   *     should rather use @FT_LOAD_TARGET_MONO so that the
   *     monochrome-optimized hinting algorithm is used.
   *
   *   FT_LOAD_LINEAR_DESIGN ::
   *     Keep  `linearHoriAdvance' and `linearVertAdvance' fields of
   *     @FT_GlyphSlotRec in font units.  See @FT_GlyphSlotRec for
   *     details.
   *
   *   FT_LOAD_NO_AUTOHINT ::
   *     Disable the auto-hinter.  See also the note below.
   *
   *   FT_LOAD_COLOR ::
   *     Load embedded color bitmap images.  The resulting color bitmaps,
   *     if available, will have the @FT_PIXEL_MODE_BGRA format.  If the
   *     flag is not set and color bitmaps are found, they are converted
   *     to 256-level gray bitmaps transparently, using the
   *     @FT_PIXEL_MODE_GRAY format.
   *
   *   FT_LOAD_COMPUTE_METRICS ::
   *     Compute glyph metrics from the glyph data, without the use of
   *     bundled metrics tables (for example, the `hdmx' table in TrueType
   *     fonts).  This flag is mainly used by font validating or font
   *     editing applications, which need to ignore, verify, or edit those
   *     tables.
   *
   *     Currently, this flag is only implemented for TrueType fonts.
   *
   *   FT_LOAD_BITMAP_METRICS_ONLY ::
   *     Request loading of the metrics and bitmap image information of a
   *     (possibly embedded) bitmap glyph without allocating or copying
   *     the bitmap image data itself.  No effect if the target glyph is
   *     not a bitmap image.
   *
   *     This flag unsets @FT_LOAD_RENDER.
   *
   *   FT_LOAD_CROP_BITMAP ::
   *     Ignored.  Deprecated.
   *
   *   FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ::
   *     Ignored.  Deprecated.
   *
   * @note:
   *   By default, hinting is enabled and the font's native hinter (see
   *   @FT_FACE_FLAG_HINTER) is preferred over the auto-hinter.  You can
   *   disable hinting by setting @FT_LOAD_NO_HINTING or change the
   *   precedence by setting @FT_LOAD_FORCE_AUTOHINT.  You can also set
   *   @FT_LOAD_NO_AUTOHINT in case you don't want the auto-hinter to be
   *   used at all.
   *
   *   See the description of @FT_FACE_FLAG_TRICKY for a special exception
   *   (affecting only a handful of Asian fonts).
   *
   *   Besides deciding which hinter to use, you can also decide which
   *   hinting algorithm to use.  See @FT_LOAD_TARGET_XXX for details.
   *
   *   Note that the auto-hinter needs a valid Unicode cmap (either a native
   *   one or synthesized by FreeType) for producing correct results.  If a
   *   font provides an incorrect mapping (for example, assigning the
   *   character code U+005A, LATIN CAPITAL LETTER Z, to a glyph depicting a
   *   mathematical integral sign), the auto-hinter might produce useless
   *   results.
   *
   */
#define FT_LOAD_DEFAULT                      0x0
#define FT_LOAD_NO_SCALE                     ( 1L << 0 )
#define FT_LOAD_NO_HINTING                   ( 1L << 1 )
#define FT_LOAD_RENDER                       ( 1L << 2 )
#define FT_LOAD_NO_BITMAP                    ( 1L << 3 )
#define FT_LOAD_VERTICAL_LAYOUT              ( 1L << 4 )
#define FT_LOAD_FORCE_AUTOHINT               ( 1L << 5 )
#define FT_LOAD_CROP_BITMAP                  ( 1L << 6 )
#define FT_LOAD_PEDANTIC                     ( 1L << 7 )
#define FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH  ( 1L << 9 )
#define FT_LOAD_NO_RECURSE                   ( 1L << 10 )
#define FT_LOAD_IGNORE_TRANSFORM             ( 1L << 11 )
#define FT_LOAD_MONOCHROME                   ( 1L << 12 )
#define FT_LOAD_LINEAR_DESIGN                ( 1L << 13 )
#define FT_LOAD_NO_AUTOHINT                  ( 1L << 15 )
  /* Bits 16-19 are used by `FT_LOAD_TARGET_' */
#define FT_LOAD_COLOR                        ( 1L << 20 )
#define FT_LOAD_COMPUTE_METRICS              ( 1L << 21 )
#define FT_LOAD_BITMAP_METRICS_ONLY          ( 1L << 22 )
  /* */
  /* used internally only by certain font drivers */
#define FT_LOAD_ADVANCE_ONLY                 ( 1L << 8 )
#define FT_LOAD_SBITS_ONLY                   ( 1L << 14 )
  /**************************************************************************
   *
   * @enum:
   *   FT_LOAD_TARGET_XXX
   *
   * @description:
   *   A list of values to select a specific hinting algorithm for the
   *   hinter.  You should OR one of these values to your `load_flags'
   *   when calling @FT_Load_Glyph.
   *
   *   Note that a font's native hinters may ignore the hinting algorithm
   *   you have specified (e.g., the TrueType bytecode interpreter).  You
   *   can set @FT_LOAD_FORCE_AUTOHINT to ensure that the auto-hinter is
   *   used.
   *
   * @values:
   *   FT_LOAD_TARGET_NORMAL ::
   *     The default hinting algorithm, optimized for standard gray-level
   *     rendering.  For monochrome output, use @FT_LOAD_TARGET_MONO
   *     instead.
   *
   *   FT_LOAD_TARGET_LIGHT ::
   *     A lighter hinting algorithm for gray-level modes.  Many generated
   *     glyphs are fuzzier but better resemble their original shape.  This
   *     is achieved by snapping glyphs to the pixel grid only vertically
   *     (Y-axis), as is done by FreeType's new CFF engine or Microsoft's
   *     ClearType font renderer.  This preserves inter-glyph spacing in
   *     horizontal text.  The snapping is done either by the native font
   *     driver, if the driver itself and the font support it, or by the
   *     auto-hinter.
   *
   *     Advance widths are rounded to integer values; however, using the
   *     `lsb_delta' and `rsb_delta' fields of @FT_GlyphSlotRec, it is
   *     possible to get fractional advance widths for sub-pixel positioning
   *     (which is recommended to use).
   *
   *     If configuration option AF_CONFIG_OPTION_TT_SIZE_METRICS is active,
   *     TrueType-like metrics are used to make this mode behave similarly
   *     as in unpatched FreeType versions between 2.4.6 and 2.7.1
   *     (inclusive).
   *
   *   FT_LOAD_TARGET_MONO ::
   *     Strong hinting algorithm that should only be used for monochrome
   *     output.  The result is probably unpleasant if the glyph is rendered
   *     in non-monochrome modes.
   *
   *   FT_LOAD_TARGET_LCD ::
   *     A variant of @FT_LOAD_TARGET_LIGHT optimized for horizontally
   *     decimated LCD displays.
   *
   *   FT_LOAD_TARGET_LCD_V ::
   *     A variant of @FT_LOAD_TARGET_NORMAL optimized for vertically
   *     decimated LCD displays.
   *
   * @note:
   *   You should use only _one_ of the FT_LOAD_TARGET_XXX values in your
   *   `load_flags'.  They can't be ORed.
   *
   *   If @FT_LOAD_RENDER is also set, the glyph is rendered in the
   *   corresponding mode (i.e., the mode that matches the used algorithm
   *   best).  An exception is FT_LOAD_TARGET_MONO since it implies
   *   @FT_LOAD_MONOCHROME.
   *
   *   You can use a hinting algorithm that doesn't correspond to the same
   *   rendering mode.  As an example, it is possible to use the `light'
   *   hinting algorithm and have the results rendered in horizontal LCD
   *   pixel mode, with code like
   *
   *     {
   *       FT_Load_Glyph( face, glyph_index,
   *                      load_flags | FT_LOAD_TARGET_LIGHT );
   *
   *       FT_Render_Glyph( face->glyph, FT_RENDER_MODE_LCD );
   *     }
   *
   *   In general, you should stick with one rendering mode.  For example,
   *   switching between @FT_LOAD_TARGET_NORMAL and @FT_LOAD_TARGET_MONO
   *   enforces a lot of recomputation for TrueType fonts, which is slow.
   *   Another reason is caching: Selecting a different mode usually causes
   *   changes in both the outlines and the rasterized bitmaps; it is thus
   *   necessary to empty the cache after a mode switch to avoid false hits.
   *
   */
#define FT_LOAD_TARGET_( x )   ( (FT_Int32)( (x) & 15 ) << 16 )
#define FT_LOAD_TARGET_NORMAL  FT_LOAD_TARGET_( FT_RENDER_MODE_NORMAL )
#define FT_LOAD_TARGET_LIGHT   FT_LOAD_TARGET_( FT_RENDER_MODE_LIGHT  )
#define FT_LOAD_TARGET_MONO    FT_LOAD_TARGET_( FT_RENDER_MODE_MONO   )
#define FT_LOAD_TARGET_LCD     FT_LOAD_TARGET_( FT_RENDER_MODE_LCD    )
#define FT_LOAD_TARGET_LCD_V   FT_LOAD_TARGET_( FT_RENDER_MODE_LCD_V  )
  /**************************************************************************
   *
   * @macro:
   *   FT_LOAD_TARGET_MODE
   *
   * @description:
   *   Return the @FT_Render_Mode corresponding to a given
   *   @FT_LOAD_TARGET_XXX value.
   *
   */
#define FT_LOAD_TARGET_MODE( x )  ( (FT_Render_Mode)( ( (x) >> 16 ) & 15 ) )
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Set_Transform                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Set the transformation that is applied to glyph images when they   */
  /*    are loaded into a glyph slot through @FT_Load_Glyph.               */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face   :: A handle to the source face object.                      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    matrix :: A pointer to the transformation's 2x2 matrix.  Use NULL  */
  /*              for the identity matrix.                                 */
  /*    delta  :: A pointer to the translation vector.  Use NULL for the   */
  /*              null vector.                                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The transformation is only applied to scalable image formats after */
  /*    the glyph has been loaded.  It means that hinting is unaltered by  */
  /*    the transformation and is performed on the character size given in */
  /*    the last call to @FT_Set_Char_Size or @FT_Set_Pixel_Sizes.         */
  /*                                                                       */
  /*    Note that this also transforms the `face.glyph.advance' field, but */
  /*    *not* the values in `face.glyph.metrics'.                          */
  /*                                                                       */
  FT_EXPORT( void )
  FT_Set_Transform( FT_Face     face,
                    FT_Matrix*  matrix,
                    FT_Vector*  delta );
  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_Render_Mode                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Render modes supported by FreeType~2.  Each mode corresponds to a  */
  /*    specific type of scanline conversion performed on the outline.     */
  /*                                                                       */
  /*    For bitmap fonts and embedded bitmaps the `bitmap->pixel_mode'     */
  /*    field in the @FT_GlyphSlotRec structure gives the format of the    */
  /*    returned bitmap.                                                   */
  /*                                                                       */
  /*    All modes except @FT_RENDER_MODE_MONO use 256 levels of opacity,   */
  /*    indicating pixel coverage.  Use linear alpha blending and gamma    */
  /*    correction to correctly render non-monochrome glyph bitmaps onto a */
  /*    surface; see @FT_Render_Glyph.                                     */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_RENDER_MODE_NORMAL ::                                           */
  /*      Default render mode; it corresponds to 8-bit anti-aliased        */
  /*      bitmaps.                                                         */
  /*                                                                       */
  /*    FT_RENDER_MODE_LIGHT ::                                            */
  /*      This is equivalent to @FT_RENDER_MODE_NORMAL.  It is only        */
  /*      defined as a separate value because render modes are also used   */
  /*      indirectly to define hinting algorithm selectors.  See           */
  /*      @FT_LOAD_TARGET_XXX for details.                                 */
  /*                                                                       */
  /*    FT_RENDER_MODE_MONO ::                                             */
  /*      This mode corresponds to 1-bit bitmaps (with 2~levels of         */
  /*      opacity).                                                        */
  /*                                                                       */
  /*    FT_RENDER_MODE_LCD ::                                              */
  /*      This mode corresponds to horizontal RGB and BGR sub-pixel        */
  /*      displays like LCD screens.  It produces 8-bit bitmaps that are   */
  /*      3~times the width of the original glyph outline in pixels, and   */
  /*      which use the @FT_PIXEL_MODE_LCD mode.                           */
  /*                                                                       */
  /*    FT_RENDER_MODE_LCD_V ::                                            */
  /*      This mode corresponds to vertical RGB and BGR sub-pixel displays */
  /*      (like PDA screens, rotated LCD displays, etc.).  It produces     */
  /*      8-bit bitmaps that are 3~times the height of the original        */
  /*      glyph outline in pixels and use the @FT_PIXEL_MODE_LCD_V mode.   */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The LCD-optimized glyph bitmaps produced by `FT_Render_Glyph' can  */
  /*    be filtered to reduce color-fringes by using                       */
  /*    @FT_Library_SetLcdFilter (not active in the default builds).  It   */
  /*    is up to the caller to either call `FT_Library_SetLcdFilter' (if   */
  /*    available) or do the filtering itself.                             */
  /*                                                                       */
  /*    The selected render mode only affects vector glyphs of a font.     */
  /*    Embedded bitmaps often have a different pixel mode like            */
  /*    @FT_PIXEL_MODE_MONO.  You can use @FT_Bitmap_Convert to transform  */
  /*    them into 8-bit pixmaps.                                           */
  /*                                                                       */
  typedef enum  FT_Render_Mode_
  {
    FT_RENDER_MODE_NORMAL = 0,
    FT_RENDER_MODE_LIGHT,
    FT_RENDER_MODE_MONO,
    FT_RENDER_MODE_LCD,
    FT_RENDER_MODE_LCD_V,
    FT_RENDER_MODE_MAX
  } FT_Render_Mode;
  /* these constants are deprecated; use the corresponding */
  /* `FT_Render_Mode' values instead                       */
#define ft_render_mode_normal  FT_RENDER_MODE_NORMAL
#define ft_render_mode_mono    FT_RENDER_MODE_MONO
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Render_Glyph                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Convert a given glyph image to a bitmap.  It does so by inspecting */
  /*    the glyph image format, finding the relevant renderer, and         */
  /*    invoking it.                                                       */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    slot        :: A handle to the glyph slot containing the image to  */
  /*                   convert.                                            */
  /*                                                                       */
  /* <Input>                                                               */
  /*    render_mode :: The render mode used to render the glyph image into */
  /*                   a bitmap.  See @FT_Render_Mode for a list of        */
  /*                   possible values.                                    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    To get meaningful results, font scaling values must be set with    */
  /*    functions like @FT_Set_Char_Size before calling `FT_Render_Glyph'. */
  /*                                                                       */
  /*    When FreeType outputs a bitmap of a glyph, it really outputs an    */
  /*    alpha coverage map.  If a pixel is completely covered by a         */
  /*    filled-in outline, the bitmap contains 0xFF at that pixel, meaning */
  /*    that 0xFF/0xFF fraction of that pixel is covered, meaning the      */
  /*    pixel is 100% black (or 0% bright).  If a pixel is only 50%        */
  /*    covered (value 0x80), the pixel is made 50% black (50% bright or a */
  /*    middle shade of grey).  0% covered means 0% black (100% bright or  */
  /*    white).                                                            */
  /*                                                                       */
  /*    On high-DPI screens like on smartphones and tablets, the pixels    */
  /*    are so small that their chance of being completely covered and     */
  /*    therefore completely black are fairly good.  On the low-DPI        */
  /*    screens, however, the situation is different.  The pixels are too  */
  /*    large for most of the details of a glyph and shades of gray are    */
  /*    the norm rather than the exception.                                */
  /*                                                                       */
  /*    This is relevant because all our screens have a second problem:    */
  /*    they are not linear.  1~+~1 is not~2.  Twice the value does not    */
  /*    result in twice the brightness.  When a pixel is only 50% covered, */
  /*    the coverage map says 50% black, and this translates to a pixel    */
  /*    value of 128 when you use 8~bits per channel (0-255).  However,    */
  /*    this does not translate to 50% brightness for that pixel on our    */
  /*    sRGB and gamma~2.2 screens.  Due to their non-linearity, they      */
  /*    dwell longer in the darks and only a pixel value of about 186      */
  /*    results in 50% brightness -- 128 ends up too dark on both bright   */
  /*    and dark backgrounds.  The net result is that dark text looks      */
  /*    burnt-out, pixely and blotchy on bright background, bright text    */
  /*    too frail on dark backgrounds, and colored text on colored         */
  /*    background (for example, red on green) seems to have dark halos or */
  /*    `dirt' around it.  The situation is especially ugly for diagonal   */
  /*    stems like in `w' glyph shapes where the quality of FreeType's     */
  /*    anti-aliasing depends on the correct display of grays.  On         */
  /*    high-DPI screens where smaller, fully black pixels reign supreme,  */
  /*    this doesn't matter, but on our low-DPI screens with all the gray  */
  /*    shades, it does.  0% and 100% brightness are the same things in    */
  /*    linear and non-linear space, just all the shades in-between        */
  /*    aren't.                                                            */
  /*                                                                       */
  /*    The blending function for placing text over a background is        */
  /*                                                                       */
  /*    {                                                                  */
  /*      dst = alpha * src + (1 - alpha) * dst    ,                       */
  /*    }                                                                  */
  /*                                                                       */
  /*    which is known as the OVER operator.                               */
  /*                                                                       */
  /*    To correctly composite an antialiased pixel of a glyph onto a      */
  /*    surface,                                                           */
  /*                                                                       */
  /*    1. take the foreground and background colors (e.g., in sRGB space) */
  /*       and apply gamma to get them in a linear space,                  */
  /*                                                                       */
  /*    2. use OVER to blend the two linear colors using the glyph pixel   */
  /*       as the alpha value (remember, the glyph bitmap is an alpha      */
  /*       coverage bitmap), and                                           */
  /*                                                                       */
  /*    3. apply inverse gamma to the blended pixel and write it back to   */
  /*       the image.                                                      */
  /*                                                                       */
  /*    Internal testing at Adobe found that a target inverse gamma of~1.8 */
  /*    for step~3 gives good results across a wide range of displays with */
  /*    an sRGB gamma curve or a similar one.                              */
  /*                                                                       */
  /*    This process can cost performance.  There is an approximation that */
  /*    does not need to know about the background color; see              */
  /*    https://bel.fi/alankila/lcd/ and                                   */
  /*    https://bel.fi/alankila/lcd/alpcor.html for details.               */
  /*                                                                       */
  /*    *ATTENTION*: Linear blending is even more important when dealing   */
  /*    with subpixel-rendered glyphs to prevent color-fringing!  A        */
  /*    subpixel-rendered glyph must first be filtered with a filter that  */
  /*    gives equal weight to the three color primaries and does not       */
  /*    exceed a sum of 0x100, see section @lcd_filtering.  Then the       */
  /*    only difference to gray linear blending is that subpixel-rendered  */
  /*    linear blending is done 3~times per pixel: red foreground subpixel */
  /*    to red background subpixel and so on for green and blue.           */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Render_Glyph( FT_GlyphSlot    slot,
                   FT_Render_Mode  render_mode );
  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_Kerning_Mode                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    An enumeration to specify the format of kerning values returned by */
  /*    @FT_Get_Kerning.                                                   */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_KERNING_DEFAULT  :: Return grid-fitted kerning distances in     */
  /*                           26.6 fractional pixels.                     */
  /*                                                                       */
  /*    FT_KERNING_UNFITTED :: Return un-grid-fitted kerning distances in  */
  /*                           26.6 fractional pixels.                     */
  /*                                                                       */
  /*    FT_KERNING_UNSCALED :: Return the kerning vector in original font  */
  /*                           units.                                      */
  /*                                                                       */
  /* <Note>                                                                */
  /*    FT_KERNING_DEFAULT returns full pixel values; it also makes        */
  /*    FreeType heuristically scale down kerning distances at small ppem  */
  /*    values so that they don't become too big.                          */
  /*                                                                       */
  /*    Both FT_KERNING_DEFAULT and FT_KERNING_UNFITTED use the current    */
  /*    horizontal scaling factor (as set e.g. with @FT_Set_Char_Size) to  */
  /*    convert font units to pixels.                                      */
  /*                                                                       */
  typedef enum  FT_Kerning_Mode_
  {
    FT_KERNING_DEFAULT = 0,
    FT_KERNING_UNFITTED,
    FT_KERNING_UNSCALED
  } FT_Kerning_Mode;
  /* these constants are deprecated; use the corresponding */
  /* `FT_Kerning_Mode' values instead                      */
#define ft_kerning_default   FT_KERNING_DEFAULT
#define ft_kerning_unfitted  FT_KERNING_UNFITTED
#define ft_kerning_unscaled  FT_KERNING_UNSCALED
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Get_Kerning                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return the kerning vector between two glyphs of the same face.     */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face        :: A handle to a source face object.                   */
  /*                                                                       */
  /*    left_glyph  :: The index of the left glyph in the kern pair.       */
  /*                                                                       */
  /*    right_glyph :: The index of the right glyph in the kern pair.      */
  /*                                                                       */
  /*    kern_mode   :: See @FT_Kerning_Mode for more information.          */
  /*                   Determines the scale and dimension of the returned  */
  /*                   kerning vector.                                     */
  /*                                                                       */
  /* <Output>                                                              */
  /*    akerning    :: The kerning vector.  This is either in font units,  */
  /*                   fractional pixels (26.6 format), or pixels for      */
  /*                   scalable formats, and in pixels for fixed-sizes     */
  /*                   formats.                                            */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Only horizontal layouts (left-to-right & right-to-left) are        */
  /*    supported by this method.  Other layouts, or more sophisticated    */
  /*    kernings, are out of the scope of this API function -- they can be */
  /*    implemented through format-specific interfaces.                    */
  /*                                                                       */
  /*    Kerning for OpenType fonts implemented in a `GPOS' table is not    */
  /*    supported; use @FT_HAS_KERNING to find out whether a font has data */
  /*    that can be extracted with `FT_Get_Kerning'.                       */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Get_Kerning( FT_Face     face,
                  FT_UInt     left_glyph,
                  FT_UInt     right_glyph,
                  FT_UInt     kern_mode,
                  FT_Vector  *akerning );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Get_Track_Kerning                                               */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return the track kerning for a given face object at a given size.  */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face       :: A handle to a source face object.                    */
  /*                                                                       */
  /*    point_size :: The point size in 16.16 fractional points.           */
  /*                                                                       */
  /*    degree     :: The degree of tightness.  Increasingly negative      */
  /*                  values represent tighter track kerning, while        */
  /*                  increasingly positive values represent looser track  */
  /*                  kerning.  Value zero means no track kerning.         */
  /*                                                                       */
  /* <Output>                                                              */
  /*    akerning   :: The kerning in 16.16 fractional points, to be        */
  /*                  uniformly applied between all glyphs.                */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Currently, only the Type~1 font driver supports track kerning,     */
  /*    using data from AFM files (if attached with @FT_Attach_File or     */
  /*    @FT_Attach_Stream).                                                */
  /*                                                                       */
  /*    Only very few AFM files come with track kerning data; please refer */
  /*    to Adobe's AFM specification for more details.                     */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Get_Track_Kerning( FT_Face    face,
                        FT_Fixed   point_size,
                        FT_Int     degree,
                        FT_Fixed*  akerning );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Get_Glyph_Name                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Retrieve the ASCII name of a given glyph in a face.  This only     */
  /*    works for those faces where @FT_HAS_GLYPH_NAMES(face) returns~1.   */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face        :: A handle to a source face object.                   */
  /*                                                                       */
  /*    glyph_index :: The glyph index.                                    */
  /*                                                                       */
  /*    buffer_max  :: The maximum number of bytes available in the        */
  /*                   buffer.                                             */
  /*                                                                       */
  /* <Output>                                                              */
  /*    buffer      :: A pointer to a target buffer where the name is      */
  /*                   copied to.                                          */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    An error is returned if the face doesn't provide glyph names or if */
  /*    the glyph index is invalid.  In all cases of failure, the first    */
  /*    byte of `buffer' is set to~0 to indicate an empty name.            */
  /*                                                                       */
  /*    The glyph name is truncated to fit within the buffer if it is too  */
  /*    long.  The returned string is always zero-terminated.              */
  /*                                                                       */
  /*    Be aware that FreeType reorders glyph indices internally so that   */
  /*    glyph index~0 always corresponds to the `missing glyph' (called    */
  /*    `.notdef').                                                        */
  /*                                                                       */
  /*    This function always returns an error if the config macro          */
  /*    `FT_CONFIG_OPTION_NO_GLYPH_NAMES' is not defined in `ftoption.h'.  */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Get_Glyph_Name( FT_Face     face,
                     FT_UInt     glyph_index,
                     FT_Pointer  buffer,
                     FT_UInt     buffer_max );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Get_Postscript_Name                                             */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Retrieve the ASCII PostScript name of a given face, if available.  */
  /*    This only works with PostScript, TrueType, and OpenType fonts.     */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face :: A handle to the source face object.                        */
  /*                                                                       */
  /* <Return>                                                              */
  /*    A pointer to the face's PostScript name.  NULL if unavailable.     */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The returned pointer is owned by the face and is destroyed with    */
  /*    it.                                                                */
  /*                                                                       */
  /*    For variation fonts, this string changes if you select a different */
  /*    instance, and you have to call `FT_Get_PostScript_Name' again to   */
  /*    retrieve it.  FreeType follows Adobe TechNote #5902, `Generating   */
  /*    PostScript Names for Fonts Using OpenType Font Variations'.        */
  /*                                                                       */
  /*      http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/font/pdfs/5902.AdobePSNameGeneration.html */
  /*                                                                       */
  FT_EXPORT( const char* )
  FT_Get_Postscript_Name( FT_Face  face );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Select_Charmap                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Select a given charmap by its encoding tag (as listed in           */
  /*    `freetype.h').                                                     */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face     :: A handle to the source face object.                    */
  /*                                                                       */
  /* <Input>                                                               */
  /*    encoding :: A handle to the selected encoding.                     */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    This function returns an error if no charmap in the face           */
  /*    corresponds to the encoding queried here.                          */
  /*                                                                       */
  /*    Because many fonts contain more than a single cmap for Unicode     */
  /*    encoding, this function has some special code to select the one    */
  /*    that covers Unicode best (`best' in the sense that a UCS-4 cmap is */
  /*    preferred to a UCS-2 cmap).  It is thus preferable to              */
  /*    @FT_Set_Charmap in this case.                                      */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Select_Charmap( FT_Face      face,
                     FT_Encoding  encoding );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Set_Charmap                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Select a given charmap for character code to glyph index mapping.  */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face    :: A handle to the source face object.                     */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charmap :: A handle to the selected charmap.                       */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    This function returns an error if the charmap is not part of       */
  /*    the face (i.e., if it is not listed in the `face->charmaps'        */
  /*    table).                                                            */
  /*                                                                       */
  /*    It also fails if an OpenType type~14 charmap is selected (which    */
  /*    doesn't map character codes to glyph indices at all).              */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Set_Charmap( FT_Face     face,
                  FT_CharMap  charmap );
  /*************************************************************************
   *
   * @function:
   *   FT_Get_Charmap_Index
   *
   * @description:
   *   Retrieve index of a given charmap.
   *
   * @input:
   *   charmap ::
   *     A handle to a charmap.
   *
   * @return:
   *   The index into the array of character maps within the face to which
   *   `charmap' belongs.  If an error occurs, -1 is returned.
   *
   */
  FT_EXPORT( FT_Int )
  FT_Get_Charmap_Index( FT_CharMap  charmap );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Get_Char_Index                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return the glyph index of a given character code.  This function   */
  /*    uses the currently selected charmap to do the mapping.             */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face     :: A handle to the source face object.                    */
  /*                                                                       */
  /*    charcode :: The character code.                                    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The glyph index.  0~means `undefined character code'.              */
  /*                                                                       */
  /* <Note>                                                                */
  /*    If you use FreeType to manipulate the contents of font files       */
  /*    directly, be aware that the glyph index returned by this function  */
  /*    doesn't always correspond to the internal indices used within the  */
  /*    file.  This is done to ensure that value~0 always corresponds to   */
  /*    the `missing glyph'.  If the first glyph is not named `.notdef',   */
  /*    then for Type~1 and Type~42 fonts, `.notdef' will be moved into    */
  /*    the glyph ID~0 position, and whatever was there will be moved to   */
  /*    the position `.notdef' had.  For Type~1 fonts, if there is no      */
  /*    `.notdef' glyph at all, then one will be created at index~0 and    */
  /*    whatever was there will be moved to the last index -- Type~42      */
  /*    fonts are considered invalid under this condition.                 */
  /*                                                                       */
  FT_EXPORT( FT_UInt )
  FT_Get_Char_Index( FT_Face   face,
                     FT_ULong  charcode );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Get_First_Char                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return the first character code in the current charmap of a given  */
  /*    face, together with its corresponding glyph index.                 */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face    :: A handle to the source face object.                     */
  /*                                                                       */
  /* <Output>                                                              */
  /*    agindex :: Glyph index of first character code.  0~if charmap is   */
  /*               empty.                                                  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The charmap's first character code.                                */
  /*                                                                       */
  /* <Note>                                                                */
  /*    You should use this function together with @FT_Get_Next_Char to    */
  /*    parse all character codes available in a given charmap.  The code  */
  /*    should look like this:                                             */
  /*                                                                       */
  /*    {                                                                  */
  /*      FT_ULong  charcode;                                              */
  /*      FT_UInt   gindex;                                                */
  /*                                                                       */
  /*                                                                       */
  /*      charcode = FT_Get_First_Char( face, &gindex );                   */
  /*      while ( gindex != 0 )                                            */
  /*      {                                                                */
  /*        ... do something with (charcode,gindex) pair ...               */
  /*                                                                       */
  /*        charcode = FT_Get_Next_Char( face, charcode, &gindex );        */
  /*      }                                                                */
  /*    }                                                                  */
  /*                                                                       */
  /*    Be aware that character codes can have values up to 0xFFFFFFFF;    */
  /*    this might happen for non-Unicode or malformed cmaps.  However,    */
  /*    even with regular Unicode encoding, so-called `last resort fonts'  */
  /*    (using SFNT cmap format 13, see function @FT_Get_CMap_Format)      */
  /*    normally have entries for all Unicode characters up to 0x1FFFFF,   */
  /*    which can cause *a lot* of iterations.                             */
  /*                                                                       */
  /*    Note that `*agindex' is set to~0 if the charmap is empty.  The     */
  /*    result itself can be~0 in two cases: if the charmap is empty or    */
  /*    if the value~0 is the first valid character code.                  */
  /*                                                                       */
  FT_EXPORT( FT_ULong )
  FT_Get_First_Char( FT_Face   face,
                     FT_UInt  *agindex );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Get_Next_Char                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return the next character code in the current charmap of a given   */
  /*    face following the value `char_code', as well as the corresponding */
  /*    glyph index.                                                       */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face      :: A handle to the source face object.                   */
  /*                                                                       */
  /*    char_code :: The starting character code.                          */
  /*                                                                       */
  /* <Output>                                                              */
  /*    agindex   :: Glyph index of next character code.  0~if charmap     */
  /*                 is empty.                                             */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The charmap's next character code.                                 */
  /*                                                                       */
  /* <Note>                                                                */
  /*    You should use this function with @FT_Get_First_Char to walk       */
  /*    over all character codes available in a given charmap.  See the    */
  /*    note for that function for a simple code example.                  */
  /*                                                                       */
  /*    Note that `*agindex' is set to~0 when there are no more codes in   */
  /*    the charmap.                                                       */
  /*                                                                       */
  FT_EXPORT( FT_ULong )
  FT_Get_Next_Char( FT_Face    face,
                    FT_ULong   char_code,
                    FT_UInt   *agindex );
  /*************************************************************************
   *
   * @function:
   *   FT_Face_Properties
   *
   * @description:
   *   Set or override certain (library or module-wide) properties on a
   *   face-by-face basis.  Useful for finer-grained control and avoiding
   *   locks on shared structures (threads can modify their own faces as
   *   they see fit).
   *
   *   Contrary to @FT_Property_Set, this function uses @FT_Parameter so
   *   that you can pass multiple properties to the target face in one call.
   *   Note that only a subset of the available properties can be
   *   controlled.
   *
   *   * Stem darkening (@FT_PARAM_TAG_STEM_DARKENING, corresponding to the
   *     property `no-stem-darkening' provided by the `autofit' and `cff'
   *     modules; see @no-stem-darkening[autofit] and
   *     @no-stem-darkening[cff]).
   *
   *   * LCD filter weights (@FT_PARAM_TAG_LCD_FILTER_WEIGHTS, corresponding
   *     to function @FT_Library_SetLcdFilterWeights).
   *
   *   * Seed value for the CFF `random' operator
   *     (@FT_PARAM_TAG_RANDOM_SEED, corresponding to the `random-seed'
   *     property provided by the `cff' module; see @random-seed).
   *
   *   Pass NULL as `data' in @FT_Parameter for a given tag to reset the
   *   option and use the library or module default again.
   *
   * @input:
   *   face ::
   *     A handle to the source face object.
   *
   *   num_properties ::
   *     The number of properties that follow.
   *
   *   properties ::
   *     A handle to an @FT_Parameter array with `num_properties' elements.
   *
   * @return:
   *   FreeType error code.  0~means success.
   *
   * @note:
   *   Here an example that sets three properties.  You must define
   *   FT_CONFIG_OPTION_SUBPIXEL_RENDERING to make the LCD filter examples
   *   work.
   *
   *   {
   *     FT_Parameter         property1;
   *     FT_Bool              darken_stems = 1;
   *
   *     FT_Parameter         property2;
   *     FT_LcdFiveTapFilter  custom_weight =
   *                            { 0x11, 0x44, 0x56, 0x44, 0x11 };
   *
   *     FT_Parameter         property3;
   *     FT_Int32             random_seed = 314159265;
   *
   *     FT_Parameter         properties[3] = { property1,
   *                                            property2,
   *                                            property3 };
   *
   *
   *     property1.tag  = FT_PARAM_TAG_STEM_DARKENING;
   *     property1.data = &darken_stems;
   *
   *     property2.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;
   *     property2.data = custom_weight;
   *
   *     property3.tag  = FT_PARAM_TAG_RANDOM_SEED;
   *     property3.data = &random_seed;
   *
   *     FT_Face_Properties( face, 3, properties );
   *   }
   *
   *   The next example resets a single property to its default value.
   *
   *   {
   *     FT_Parameter  property;
   *
   *
   *     property.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;
   *     property.data = NULL;
   *
   *     FT_Face_Properties( face, 1, &property );
   *   }
   *
   */
  FT_EXPORT( FT_Error )
  FT_Face_Properties( FT_Face        face,
                      FT_UInt        num_properties,
                      FT_Parameter*  properties );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Get_Name_Index                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return the glyph index of a given glyph name.                      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face       :: A handle to the source face object.                  */
  /*                                                                       */
  /*    glyph_name :: The glyph name.                                      */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The glyph index.  0~means `undefined character code'.              */
  /*                                                                       */
  FT_EXPORT( FT_UInt )
  FT_Get_Name_Index( FT_Face     face,
                     FT_String*  glyph_name );
  /*************************************************************************
   *
   * @macro:
   *   FT_SUBGLYPH_FLAG_XXX
   *
   * @description:
   *   A list of constants describing subglyphs.  Please refer to the
   *   `glyf' table description in the OpenType specification for the
   *   meaning of the various flags (which get synthesized for
   *   non-OpenType subglyphs).
   *
   * @values:
   *   FT_SUBGLYPH_FLAG_ARGS_ARE_WORDS ::
   *   FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES ::
   *   FT_SUBGLYPH_FLAG_ROUND_XY_TO_GRID ::
   *   FT_SUBGLYPH_FLAG_SCALE ::
   *   FT_SUBGLYPH_FLAG_XY_SCALE ::
   *   FT_SUBGLYPH_FLAG_2X2 ::
   *   FT_SUBGLYPH_FLAG_USE_MY_METRICS ::
   *
   */
#define FT_SUBGLYPH_FLAG_ARGS_ARE_WORDS          1
#define FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES      2
#define FT_SUBGLYPH_FLAG_ROUND_XY_TO_GRID        4
#define FT_SUBGLYPH_FLAG_SCALE                   8
#define FT_SUBGLYPH_FLAG_XY_SCALE             0x40
#define FT_SUBGLYPH_FLAG_2X2                  0x80
#define FT_SUBGLYPH_FLAG_USE_MY_METRICS      0x200
  /*************************************************************************
   *
   * @func:
   *   FT_Get_SubGlyph_Info
   *
   * @description:
   *   Retrieve a description of a given subglyph.  Only use it if
   *   `glyph->format' is @FT_GLYPH_FORMAT_COMPOSITE; an error is
   *   returned otherwise.
   *
   * @input:
   *   glyph ::
   *     The source glyph slot.
   *
   *   sub_index ::
   *     The index of the subglyph.  Must be less than
   *     `glyph->num_subglyphs'.
   *
   * @output:
   *   p_index ::
   *     The glyph index of the subglyph.
   *
   *   p_flags ::
   *     The subglyph flags, see @FT_SUBGLYPH_FLAG_XXX.
   *
   *   p_arg1 ::
   *     The subglyph's first argument (if any).
   *
   *   p_arg2 ::
   *     The subglyph's second argument (if any).
   *
   *   p_transform ::
   *     The subglyph transformation (if any).
   *
   * @return:
   *   FreeType error code.  0~means success.
   *
   * @note:
   *   The values of `*p_arg1', `*p_arg2', and `*p_transform' must be
   *   interpreted depending on the flags returned in `*p_flags'.  See the
   *   OpenType specification for details.
   *
   */
  FT_EXPORT( FT_Error )
  FT_Get_SubGlyph_Info( FT_GlyphSlot  glyph,
                        FT_UInt       sub_index,
                        FT_Int       *p_index,
                        FT_UInt      *p_flags,
                        FT_Int       *p_arg1,
                        FT_Int       *p_arg2,
                        FT_Matrix    *p_transform );
  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_FSTYPE_XXX                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A list of bit flags used in the `fsType' field of the OS/2 table   */
  /*    in a TrueType or OpenType font and the `FSType' entry in a         */
  /*    PostScript font.  These bit flags are returned by                  */
  /*    @FT_Get_FSType_Flags; they inform client applications of embedding */
  /*    and subsetting restrictions associated with a font.                */
  /*                                                                       */
  /*    See                                                                */
  /*    http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/FontPolicies.pdf */
  /*    for more details.                                                  */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_FSTYPE_INSTALLABLE_EMBEDDING ::                                 */
  /*      Fonts with no fsType bit set may be embedded and permanently     */
  /*      installed on the remote system by an application.                */
  /*                                                                       */
  /*    FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING ::                          */
  /*      Fonts that have only this bit set must not be modified, embedded */
  /*      or exchanged in any manner without first obtaining permission of */
  /*      the font software copyright owner.                               */
  /*                                                                       */
  /*    FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING ::                           */
  /*      The font may be embedded and temporarily loaded on the remote    */
  /*      system.  Documents containing Preview & Print fonts must be      */
  /*      opened `read-only'; no edits can be applied to the document.     */
  /*                                                                       */
  /*    FT_FSTYPE_EDITABLE_EMBEDDING ::                                    */
  /*      The font may be embedded but must only be installed temporarily  */
  /*      on other systems.  In contrast to Preview & Print fonts,         */
  /*      documents containing editable fonts may be opened for reading,   */
  /*      editing is permitted, and changes may be saved.                  */
  /*                                                                       */
  /*    FT_FSTYPE_NO_SUBSETTING ::                                         */
  /*      The font may not be subsetted prior to embedding.                */
  /*                                                                       */
  /*    FT_FSTYPE_BITMAP_EMBEDDING_ONLY ::                                 */
  /*      Only bitmaps contained in the font may be embedded; no outline   */
  /*      data may be embedded.  If there are no bitmaps available in the  */
  /*      font, then the font is unembeddable.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The flags are ORed together, thus more than a single value can be  */
  /*    returned.                                                          */
  /*                                                                       */
  /*    While the `fsType' flags can indicate that a font may be embedded, */
  /*    a license with the font vendor may be separately required to use   */
  /*    the font in this way.                                              */
  /*                                                                       */
#define FT_FSTYPE_INSTALLABLE_EMBEDDING         0x0000
#define FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING  0x0002
#define FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING   0x0004
#define FT_FSTYPE_EDITABLE_EMBEDDING            0x0008
#define FT_FSTYPE_NO_SUBSETTING                 0x0100
#define FT_FSTYPE_BITMAP_EMBEDDING_ONLY         0x0200
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Get_FSType_Flags                                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return the `fsType' flags for a font.                              */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face :: A handle to the source face object.                        */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The `fsType' flags, see @FT_FSTYPE_XXX.                            */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Use this function rather than directly reading the `fs_type' field */
  /*    in the @PS_FontInfoRec structure, which is only guaranteed to      */
  /*    return the correct results for Type~1 fonts.                       */
  /*                                                                       */
  /* <Since>                                                               */
  /*    2.3.8                                                              */
  /*                                                                       */
  FT_EXPORT( FT_UShort )
  FT_Get_FSType_Flags( FT_Face  face );
  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    glyph_variants                                                     */
  /*                                                                       */
  /* <Title>                                                               */
  /*    Unicode Variation Sequences                                        */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*    The FreeType~2 interface to Unicode Variation Sequences (UVS),     */
  /*    using the SFNT cmap format~14.                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Many characters, especially for CJK scripts, have variant forms.   */
  /*    They are a sort of grey area somewhere between being totally       */
  /*    irrelevant and semantically distinct; for this reason, the Unicode */
  /*    consortium decided to introduce Variation Sequences (VS),          */
  /*    consisting of a Unicode base character and a variation selector    */
  /*    instead of further extending the already huge number of            */
  /*    characters.                                                        */
  /*                                                                       */
  /*    Unicode maintains two different sets, namely `Standardized         */
  /*    Variation Sequences' and registered `Ideographic Variation         */
  /*    Sequences' (IVS), collected in the `Ideographic Variation          */
  /*    Database' (IVD).                                                   */
  /*                                                                       */
  /*      http://unicode.org/Public/UCD/latest/ucd/StandardizedVariants.txt */
  /*      http://unicode.org/reports/tr37/                                 */
  /*      http://unicode.org/ivd/                                          */
  /*                                                                       */
  /*    To date (January 2017), the character with the most ideographic    */
  /*    variations is U+9089, having 32 such IVS.                          */
  /*                                                                       */
  /*    Three Mongolian Variation Selectors have the values U+180B-U+180D; */
  /*    256 generic Variation Selectors are encoded in the ranges          */
  /*    U+FE00-U+FE0F and U+E0100-U+E01EF.  IVS currently use Variation    */
  /*    Selectors from the range U+E0100-U+E01EF only.                     */
  /*                                                                       */
  /*    A VS consists of the base character value followed by a single     */
  /*    Variation Selector.  For example, to get the first variation of    */
  /*    U+9089, you have to write the character sequence `U+9089 U+E0100'. */
  /*                                                                       */
  /*    Adobe and MS decided to support both standardized and ideographic  */
  /*    VS with a new cmap subtable (format~14).  It is an odd subtable    */
  /*    because it is not a mapping of input code points to glyphs, but    */
  /*    contains lists of all variations supported by the font.            */
  /*                                                                       */
  /*    A variation may be either `default' or `non-default' for a given   */
  /*    font.  A default variation is the one you will get for that code   */
  /*    point if you look it up in the standard Unicode cmap.  A           */
  /*    non-default variation is a different glyph.                        */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Face_GetCharVariantIndex                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return the glyph index of a given character code as modified by    */
  /*    the variation selector.                                            */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face ::                                                            */
  /*      A handle to the source face object.                              */
  /*                                                                       */
  /*    charcode ::                                                        */
  /*      The character code point in Unicode.                             */
  /*                                                                       */
  /*    variantSelector ::                                                 */
  /*      The Unicode code point of the variation selector.                */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The glyph index.  0~means either `undefined character code', or    */
  /*    `undefined selector code', or `no variation selector cmap          */
  /*    subtable', or `current CharMap is not Unicode'.                    */
  /*                                                                       */
  /* <Note>                                                                */
  /*    If you use FreeType to manipulate the contents of font files       */
  /*    directly, be aware that the glyph index returned by this function  */
  /*    doesn't always correspond to the internal indices used within      */
  /*    the file.  This is done to ensure that value~0 always corresponds  */
  /*    to the `missing glyph'.                                            */
  /*                                                                       */
  /*    This function is only meaningful if                                */
  /*      a) the font has a variation selector cmap sub table,             */
  /*    and                                                                */
  /*      b) the current charmap has a Unicode encoding.                   */
  /*                                                                       */
  /* <Since>                                                               */
  /*    2.3.6                                                              */
  /*                                                                       */
  FT_EXPORT( FT_UInt )
  FT_Face_GetCharVariantIndex( FT_Face   face,
                               FT_ULong  charcode,
                               FT_ULong  variantSelector );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Face_GetCharVariantIsDefault                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Check whether this variation of this Unicode character is the one  */
  /*    to be found in the `cmap'.                                         */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face ::                                                            */
  /*      A handle to the source face object.                              */
  /*                                                                       */
  /*    charcode ::                                                        */
  /*      The character codepoint in Unicode.                              */
  /*                                                                       */
  /*    variantSelector ::                                                 */
  /*      The Unicode codepoint of the variation selector.                 */
  /*                                                                       */
  /* <Return>                                                              */
  /*    1~if found in the standard (Unicode) cmap, 0~if found in the       */
  /*    variation selector cmap, or -1 if it is not a variation.           */
  /*                                                                       */
  /* <Note>                                                                */
  /*    This function is only meaningful if the font has a variation       */
  /*    selector cmap subtable.                                            */
  /*                                                                       */
  /* <Since>                                                               */
  /*    2.3.6                                                              */
  /*                                                                       */
  FT_EXPORT( FT_Int )
  FT_Face_GetCharVariantIsDefault( FT_Face   face,
                                   FT_ULong  charcode,
                                   FT_ULong  variantSelector );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Face_GetVariantSelectors                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return a zero-terminated list of Unicode variation selectors found */
  /*    in the font.                                                       */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face ::                                                            */
  /*      A handle to the source face object.                              */
  /*                                                                       */
  /* <Return>                                                              */
  /*    A pointer to an array of selector code points, or NULL if there is */
  /*    no valid variation selector cmap subtable.                         */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The last item in the array is~0; the array is owned by the         */
  /*    @FT_Face object but can be overwritten or released on the next     */
  /*    call to a FreeType function.                                       */
  /*                                                                       */
  /* <Since>                                                               */
  /*    2.3.6                                                              */
  /*                                                                       */
  FT_EXPORT( FT_UInt32* )
  FT_Face_GetVariantSelectors( FT_Face  face );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Face_GetVariantsOfChar                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return a zero-terminated list of Unicode variation selectors found */
  /*    for the specified character code.                                  */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face ::                                                            */
  /*      A handle to the source face object.                              */
  /*                                                                       */
  /*    charcode ::                                                        */
  /*      The character codepoint in Unicode.                              */
  /*                                                                       */
  /* <Return>                                                              */
  /*    A pointer to an array of variation selector code points that are   */
  /*    active for the given character, or NULL if the corresponding list  */
  /*    is empty.                                                          */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The last item in the array is~0; the array is owned by the         */
  /*    @FT_Face object but can be overwritten or released on the next     */
  /*    call to a FreeType function.                                       */
  /*                                                                       */
  /* <Since>                                                               */
  /*    2.3.6                                                              */
  /*                                                                       */
  FT_EXPORT( FT_UInt32* )
  FT_Face_GetVariantsOfChar( FT_Face   face,
                             FT_ULong  charcode );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Face_GetCharsOfVariant                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return a zero-terminated list of Unicode character codes found for */
  /*    the specified variation selector.                                  */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face ::                                                            */
  /*      A handle to the source face object.                              */
  /*                                                                       */
  /*    variantSelector ::                                                 */
  /*      The variation selector code point in Unicode.                    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    A list of all the code points that are specified by this selector  */
  /*    (both default and non-default codes are returned) or NULL if there */
  /*    is no valid cmap or the variation selector is invalid.             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The last item in the array is~0; the array is owned by the         */
  /*    @FT_Face object but can be overwritten or released on the next     */
  /*    call to a FreeType function.                                       */
  /*                                                                       */
  /* <Since>                                                               */
  /*    2.3.6                                                              */
  /*                                                                       */
  FT_EXPORT( FT_UInt32* )
  FT_Face_GetCharsOfVariant( FT_Face   face,
                             FT_ULong  variantSelector );
  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    computations                                                       */
  /*                                                                       */
  /* <Title>                                                               */
  /*    Computations                                                       */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*    Crunching fixed numbers and vectors.                               */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This section contains various functions used to perform            */
  /*    computations on 16.16 fixed-float numbers or 2d vectors.           */
  /*                                                                       */
  /* <Order>                                                               */
  /*    FT_MulDiv                                                          */
  /*    FT_MulFix                                                          */
  /*    FT_DivFix                                                          */
  /*    FT_RoundFix                                                        */
  /*    FT_CeilFix                                                         */
  /*    FT_FloorFix                                                        */
  /*    FT_Vector_Transform                                                */
  /*    FT_Matrix_Multiply                                                 */
  /*    FT_Matrix_Invert                                                   */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_MulDiv                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Compute `(a*b)/c' with maximum accuracy, using a 64-bit            */
  /*    intermediate integer whenever necessary.                           */
  /*                                                                       */
  /*    This function isn't necessarily as fast as some processor specific */
  /*    operations, but is at least completely portable.                   */
  /*                                                                       */
  /* <Input>                                                               */
  /*    a :: The first multiplier.                                         */
  /*                                                                       */
  /*    b :: The second multiplier.                                        */
  /*                                                                       */
  /*    c :: The divisor.                                                  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The result of `(a*b)/c'.  This function never traps when trying to */
  /*    divide by zero; it simply returns `MaxInt' or `MinInt' depending   */
  /*    on the signs of `a' and `b'.                                       */
  /*                                                                       */
  FT_EXPORT( FT_Long )
  FT_MulDiv( FT_Long  a,
             FT_Long  b,
             FT_Long  c );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_MulFix                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Compute `(a*b)/0x10000' with maximum accuracy.  Its main use is to */
  /*    multiply a given value by a 16.16 fixed-point factor.              */
  /*                                                                       */
  /* <Input>                                                               */
  /*    a :: The first multiplier.                                         */
  /*                                                                       */
  /*    b :: The second multiplier.  Use a 16.16 factor here whenever      */
  /*         possible (see note below).                                    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The result of `(a*b)/0x10000'.                                     */
  /*                                                                       */
  /* <Note>                                                                */
  /*    This function has been optimized for the case where the absolute   */
  /*    value of `a' is less than 2048, and `b' is a 16.16 scaling factor. */
  /*    As this happens mainly when scaling from notional units to         */
  /*    fractional pixels in FreeType, it resulted in noticeable speed     */
  /*    improvements between versions 2.x and 1.x.                         */
  /*                                                                       */
  /*    As a conclusion, always try to place a 16.16 factor as the         */
  /*    _second_ argument of this function; this can make a great          */
  /*    difference.                                                        */
  /*                                                                       */
  FT_EXPORT( FT_Long )
  FT_MulFix( FT_Long  a,
             FT_Long  b );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_DivFix                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Compute `(a*0x10000)/b' with maximum accuracy.  Its main use is to */
  /*    divide a given value by a 16.16 fixed-point factor.                */
  /*                                                                       */
  /* <Input>                                                               */
  /*    a :: The numerator.                                                */
  /*                                                                       */
  /*    b :: The denominator.  Use a 16.16 factor here.                    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The result of `(a*0x10000)/b'.                                     */
  /*                                                                       */
  FT_EXPORT( FT_Long )
  FT_DivFix( FT_Long  a,
             FT_Long  b );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_RoundFix                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Round a 16.16 fixed number.                                        */
  /*                                                                       */
  /* <Input>                                                               */
  /*    a :: The number to be rounded.                                     */
  /*                                                                       */
  /* <Return>                                                              */
  /*    `a' rounded to the nearest 16.16 fixed integer, halfway cases away */
  /*    from zero.                                                         */
  /*                                                                       */
  FT_EXPORT( FT_Fixed )
  FT_RoundFix( FT_Fixed  a );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_CeilFix                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Compute the smallest following integer of a 16.16 fixed number.    */
  /*                                                                       */
  /* <Input>                                                               */
  /*    a :: The number for which the ceiling function is to be computed.  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    `a' rounded towards plus infinity.                                 */
  /*                                                                       */
  FT_EXPORT( FT_Fixed )
  FT_CeilFix( FT_Fixed  a );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_FloorFix                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Compute the largest previous integer of a 16.16 fixed number.      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    a :: The number for which the floor function is to be computed.    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    `a' rounded towards minus infinity.                                */
  /*                                                                       */
  FT_EXPORT( FT_Fixed )
  FT_FloorFix( FT_Fixed  a );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Vector_Transform                                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Transform a single vector through a 2x2 matrix.                    */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    vector :: The target vector to transform.                          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    matrix :: A pointer to the source 2x2 matrix.                      */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The result is undefined if either `vector' or `matrix' is invalid. */
  /*                                                                       */
  FT_EXPORT( void )
  FT_Vector_Transform( FT_Vector*        vec,
                       const FT_Matrix*  matrix );
  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    version                                                            */
  /*                                                                       */
  /* <Title>                                                               */
  /*    FreeType Version                                                   */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*    Functions and macros related to FreeType versions.                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Note that those functions and macros are of limited use because    */
  /*    even a new release of FreeType with only documentation changes     */
  /*    increases the version number.                                      */
  /*                                                                       */
  /* <Order>                                                               */
  /*    FT_Library_Version                                                 */
  /*                                                                       */
  /*    FREETYPE_MAJOR                                                     */
  /*    FREETYPE_MINOR                                                     */
  /*    FREETYPE_PATCH                                                     */
  /*                                                                       */
  /*    FT_Face_CheckTrueTypePatents                                       */
  /*    FT_Face_SetUnpatentedHinting                                       */
  /*                                                                       */
  /*    FREETYPE_XXX                                                       */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************
   *
   * @enum:
   *   FREETYPE_XXX
   *
   * @description:
   *   These three macros identify the FreeType source code version.
   *   Use @FT_Library_Version to access them at runtime.
   *
   * @values:
   *   FREETYPE_MAJOR :: The major version number.
   *   FREETYPE_MINOR :: The minor version number.
   *   FREETYPE_PATCH :: The patch level.
   *
   * @note:
   *   The version number of FreeType if built as a dynamic link library
   *   with the `libtool' package is _not_ controlled by these three
   *   macros.
   *
   */
#define FREETYPE_MAJOR  2
#define FREETYPE_MINOR  8
#define FREETYPE_PATCH  0
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Library_Version                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return the version of the FreeType library being used.  This is    */
  /*    useful when dynamically linking to the library, since one cannot   */
  /*    use the macros @FREETYPE_MAJOR, @FREETYPE_MINOR, and               */
  /*    @FREETYPE_PATCH.                                                   */
  /*                                                                       */
  /* <Input>                                                               */
  /*    library :: A source library handle.                                */
  /*                                                                       */
  /* <Output>                                                              */
  /*    amajor  :: The major version number.                               */
  /*                                                                       */
  /*    aminor  :: The minor version number.                               */
  /*                                                                       */
  /*    apatch  :: The patch version number.                               */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The reason why this function takes a `library' argument is because */
  /*    certain programs implement library initialization in a custom way  */
  /*    that doesn't use @FT_Init_FreeType.                                */
  /*                                                                       */
  /*    In such cases, the library version might not be available before   */
  /*    the library object has been created.                               */
  /*                                                                       */
  FT_EXPORT( void )
  FT_Library_Version( FT_Library   library,
                      FT_Int      *amajor,
                      FT_Int      *aminor,
                      FT_Int      *apatch );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Face_CheckTrueTypePatents                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Deprecated, does nothing.                                          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face :: A face handle.                                             */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Always returns false.                                              */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Since May 2010, TrueType hinting is no longer patented.            */
  /*                                                                       */
  /* <Since>                                                               */
  /*    2.3.5                                                              */
  /*                                                                       */
  FT_EXPORT( FT_Bool )
  FT_Face_CheckTrueTypePatents( FT_Face  face );
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Face_SetUnpatentedHinting                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Deprecated, does nothing.                                          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face  :: A face handle.                                            */
  /*                                                                       */
  /*    value :: New boolean setting.                                      */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Always returns false.                                              */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Since May 2010, TrueType hinting is no longer patented.            */
  /*                                                                       */
  /* <Since>                                                               */
  /*    2.3.5                                                              */
  /*                                                                       */
  FT_EXPORT( FT_Bool )
  FT_Face_SetUnpatentedHinting( FT_Face  face,
                                FT_Bool  value );
  /* */
FT_END_HEADER
#endif
/* END */
#endif
#endif
#define fg (*global_font_data)
SACK_NAMESPACE
_IMAGE_NAMESPACE
//#ifndef FONT_CACHE_STRUCTS
/* Describes an alternate file location for this font. During
   the building of the cache, the same fonts may exist on a
   system multiple times.                                     */
/* <combine sack::image::alt_size_file_tag>
   \ \                                      */
typedef struct alt_size_file_tag
{
   /* path of the file. */
   TEXTCHAR *path;
	/* more alternate files. */
	struct alt_size_file_tag *pAlternate;
   /* the filename appended to this structure. */
   TEXTCHAR file[1];
} ALT_SIZE_FILE, *PALT_SIZE_FILE;
/* Describes size information about a font family, style, and
   the file instance specified.                               */
/* <combine sack::image::size_tag>
   \ \                             */
/* <combine sack::image::size_tag>
   \ \                             */
typedef struct size_tag
{
	/* <combine sack::image::size_tag::flags>
	   \ \                                    */
	/* flags to describe the state of this size entry. Sometimes
	   specific sizes of a font in a file cannot be rendered.    */
	struct {
		/* This font file was found to be unusable. This is mostly used
		   during the building of the font cache.                       */
		uint32_t unusable : 1;
	} flags;
	/* The height of the character (in uhmm something like PELS or
	   dots)                                                       */
	int16_t width;
	/* The height of the character (in uhmm something like PELS or
	   dots)                                                       */
	int16_t height;
	/* Next size. A SizeFile actually contains an array of lists of
      size entries. There may be more than one size entry base, but
      then each might point at another. (like if a font had an 8x8,
      9x12, 11x15 sizes, but also has -1x-1 scalable size, the
      first three will be a list, and then the scalable indicator)  */
	struct size_tag *next;
} SIZES, *PSIZES;
/* <link sack::image::font_global_tag::pFontCache, GetGlobalFont()-\>pFontCache> */
/* <combine sack::image::file_size_tag>
   \ \                                  */
/* <combine sack::image::file_size_tag>
   \ \                                  */
typedef struct file_size_tag
{
	/* Flags to indicate statuses about this font cache entry. */
	/* <combine sack::image::file_size_tag::flags>
	   \ \                                         */
	struct {
		/* This font file was found to be unusable. This is mostly used
		   during the building of the font cache.                       */
		uint32_t unusable : 1;
	} flags;
	/* pointer to the path where the file is found */
	TEXTCHAR *path;
	/* name of the file itself */
	TEXTCHAR *file;
	/* number of alternate files specified. */
	uint32_t   nAlternate;
	/* list of alternates for this font */
	PALT_SIZE_FILE pAlternate;
	/* sizes that are in this file */
	uint32_t   nSizes;
 // scaled and fixed sizes available in this file.
	PSIZES sizes;
} SIZE_FILE, *PSIZE_FILE;
/* describes a style of a font family. */
/* <combine sack::image::font_style_t>
   \ \                                 */
typedef struct font_style_t
{
	/* <combine sack::image::font_style_t::flags>
	   \ \                                        */
	/* Flags describing characteristics of this style, and all sizes
	   contained.                                                    */
	struct {
		/* The font from here and all sizes is mono-spaced. */
		uint32_t mono : 1;
		/* This font file was found to be unusable. This is mostly used
		   during the building of the font cache.                       */
		uint32_t unusable : 1;
		/* set italic attribute when rendering. */
		uint32_t italic : 1;
		/* set bold attribute when rendering. */
		uint32_t bold : 1;
	} flags;
	/* name of this style. This is appended directly to the
	   structure to avoid any allocation overhead.          */
	TEXTCHAR        *name;
	/* number of files in the array of files. */
	uint32_t          nFiles;
	/* pointer to array of SIZE_FILE s. */
	PSIZE_FILE   files;
} FONT_STYLE, *PFONT_STYLE;
/* <combine sack::image::font_entry_tag>
   \ \                                   */
/* <combine sack::image::font_entry_tag>
   \ \                                   */
typedef struct font_entry_tag
{
	/* Flags about this font family. Currently only 'unusable' that
	   the font failed to load... or there are no styles that
	   loaded?                                                      */
	/* <combine sack::image::font_entry_tag::flags@1>
	   \ \                                            */
	struct {
		/* This font file was found to be unusable. This is mostly used
		   during the building of the font cache.                       */
		uint32_t unusable : 1;
	} flags;
  // name of this font family.
	TEXTCHAR   *name;
 // number of styles in the styles array.
	uint32_t          nStyles;
 // array of nStyles
	PFONT_STYLE  styles;
	//PLIST styles;
} FONT_ENTRY, *PFONT_ENTRY;
//#else
typedef struct cache_build_tag
{
	struct {
		uint32_t initialized : 1;
		uint32_t show_mono_only : 1;
		uint32_t show_prop_only : 1;
	} flags;
	// this really has no sorting
	// just a list of FONT_ENTRYs
	//SHA1Context Sha1Build;
	// PDICTs... (scratch build)
	PTREEROOT pPaths;
	PTREEROOT pFiles;
	PTREEROOT pFamilies;
	PTREEROOT pStyles;
	PTREEROOT pFontCache;
	// when we read the cache from disk - use these....
	uint32_t nPaths;
	TEXTCHAR* *pPathList;
 // slab of ALL names?
	TEXTCHAR *pPathNames;
	uint32_t nFiles;
	TEXTCHAR* *pFileList;
 // slab of ALL names?
	TEXTCHAR *pFileNames;
	uint32_t nStyles;
	TEXTCHAR* *pStyleList;
 // slab of ALL names?
	TEXTCHAR *pStyleNames;
	uint32_t nFamilies;
	TEXTCHAR* *pFamilyList;
 // slab of ALL names?
	TEXTCHAR *pFamilyNames;
	PFONT_STYLE pStyleSlab;
	uint32_t nStyle;
	PSIZE_FILE pSizeFileSlab;
	uint32_t nSizeFile;
	PSIZES pSizeSlab;
	uint32_t nSize;
	PALT_SIZE_FILE pAltSlab;
	uint32_t nAlt;
} CACHE_BUILD, *PCACHE_BUILD;
//#endif
#if defined( NO_FONT_GLOBAL )
#else
/* Global information kept by the specific font subsystem. This
   was seperated from the guts of Image Global, because PSI SFTFont
   Picker dialog wants to get information from here (to browse
   the font cache for instance).                                 */
typedef struct font_global_tag
{
#if defined( STRUCT_ONLY )
	uintptr_t library;
#else
	/* This is the freetype instance variable that font rendering
	   uses. Thread access to rendering is controlled, only a single
	   thread may render using this instance at a time.              */
	FT_Library   library;
#endif
	/* \ \  */
	uint32_t          nFonts;
	/* \ \
	   Description
	   This is an overview of the internal font cache. The
	   Fonts.cache file is a semi-compressed quick reference table
	   of compressed strings.
	   The cache is an array of PFONT_ENTRY. Each entry has a name;
	   it is the name of the font as described by the font file.
	   each PFONT_ENTRY has an array of PFONT_STYLE. Each style has
	   a name; it is usually something like Regular, Bold, Italic...
	   Styles also have a flag whether it is mono spaced.
	   each PFONT_STYLE has an array of PSIZE_FILE. Each size_file entry
	   has an array of PSIZES. Each size_file also has a path and
	   filename associated. At this point, the file may be
	   different. It may also have a link to alternate files which
	   are the same font (style name and family name match...).
	   each PSIZES describes a possible rendering size of the font. If
	   it is -1,-1, the font is scalable, otherwise specific x by y
	   needs to be specified.
	   So To Reiterate
	   <code lang="c++">
	      FONT_ENTRY
	         FONT_STYLE
	             SIZE_FILE
	                SIZES
	   </code>
	   I really don't want to give you the loop to iterate this, but
	   I must if anyone else is to write font choice methods.
	   Example
	   See src/psilib/fntdlg.c                                           */
	//struct font_cache_style_t  *pFontCache;
	FONT_ENTRY  *pFontCache;
	/* Critical section protecting global */
	CRITICALSECTION cs;
	struct {
		BIT_FIELD OpeningFontStatus : 1;
		BIT_FIELD bScanningFonts : 1;
	} flags;
	PTHREAD font_status_open_thread;
	PTHREAD font_status_timer_thread;
	uint64_t fontcachetime;
	struct cache_build_tag *_build;
	TEXTCHAR font_cache_path[256];
} FONT_GLOBAL;
#define build _build[0]
#endif
/* These are symbols used for 'magic' in PFONTDATA and
   PRENDER_FONTDATA.                                   */
enum FontMagicIdentifiers{
   MAGIC_PICK_FONT = 'PICK',
   MAGIC_RENDER_FONT = 'FONT'
};
/* This is the internal structure used to define the font cache,
   and data structures used to track renderings of fonts. Structures
   include desired size of the font in pixels. This data
   structure can be requested from the image library and can be
   used to recreate the font again in the future. This font came
   from a font choice dialog and includes all the IDs of the
   options selected.                                                 */
struct font_data_tag {
   /* A magic identifier from FontMagicIdentifiers. This structure
      might be pointed to as a RENDER_FONTDATA instead, and its
      magic identifier would be different.                         */
   uint32_t magic;
	/* this is the family index in the internal font cache. */
	uint32_t nFamily;
	/* This is the index into the font cache of this style. */
	uint32_t nStyle;
	/* This is the file index in the font cache. */
	uint32_t nFile;
	/* How wide to render the font in pixels. */
	uint32_t nWidth;
	/* Height of the font to render output in pixels. */
	uint32_t nHeight;
   /* This is the flags that the font was created with. Think only
      the low 2 bits are used to determine resolution of the font
      as 1, 2, or 8 bits.                                          */
	uint32_t flags;
	/* This is the timestamp of the cache file. If these don't
	   match, the names are used to create the font.           */
	uint64_t cachefile_time;
   /* these is a list of names to create the font if the indexes
      are different. Think all names are concated together with a
      single '\\0' between and a double '\\0\\0' at the end.      */
	TEXTCHAR names[1];
};
// defines FONTDATA for internal usage.
typedef struct font_data_tag  FONTDATA;
/* This is used to define the data usable to recreate a font
   being rendered right now. This is the data that would result
   from calling
   <link sack::image::InternalRenderFontFile@CTEXTSTR@int32_t@int32_t@uint32_t, RenderFontFile>,
   and would be used in future uses of <link sack::image::RenderScaledFontData@PFONTDATA@PFRACTION@PFRACTION, RenderScaledFontData>. */
typedef struct render_font_data_tag {
   /* A magic identifier from FontMagicIdentifiers. This structure
      might be pointed to as a FONTDATA instead, and its
      magic identifier would be different.                         */
	uint32_t magic;
	/* How wide to render the font in pixels. */
	uint32_t nWidth;
	/* Height of the font to render output in pixels. */
	uint32_t nHeight;
   /* This is the flags that the font was created with. Think only
      the low 2 bits are used to determine resolution of the font
      as 1, 2, or 8 bits.                                          */
	uint32_t flags;
   /* this is the filename that was used to create the font.  The filename is relative to where the image service is running from. */
	TEXTCHAR filename[1];
} RENDER_FONTDATA;
/* internal function to load fonts */
void IMGVER(LoadAllFonts)( void );
/* internal function to unload fonts */
void IMGVER(UnloadAllFonts)( void );
//#undef DumpFontFile
//void DumpFontFile( CTEXTSTR name, SFTFont font_to_dump );
#ifndef STRUCT_ONLY
int OpenFontFile( CTEXTSTR name, POINTER *font_memory, FT_Face *face, int face_idx, LOGICAL fallback_to_cache );
#endif
#if !defined( NO_FONT_GLOBAL )
static FONT_GLOBAL *global_font_data;
//#define fg (*global_font_data)
#endif
IMAGE_NAMESPACE_END
// $Log: fntglobal.h,v $
// Revision 1.8  2004/12/15 03:00:19  panther
// Begin coding to only show valid, renderable fonts in dialog, and update cache, turns out that we'll have to postprocess the cache to remove unused dictionary entries
//
// Revision 1.7  2004/10/24 20:09:47  d3x0r
// Sync to psilib2... stable enough to call it mainstream.
//
// Revision 1.1  2004/09/19 19:22:31  d3x0r
// Begin version 2 psilib...
//
// Revision 1.6  2003/10/07 00:37:34  panther
// Prior commit in error - Begin render fonts in multi-alpha.
//
// Revision 1.5  2003/10/07 00:32:08  panther
// Fix default font.  Add bit size flag to font
//
// Revision 1.4  2003/06/16 10:17:42  panther
// Export nearly usable renderfont routine... filename, size
//
// Revision 1.3  2003/03/25 08:45:56  panther
// Added CVS logging tag
//
#endif
#ifndef FIRST_SYMBOL_VALUE
#define FIRST_SYMBOL_VALUE 1
#endif
#ifndef BUILD_NAMES
#  if !defined( NAME_ENUMERATION_DECLARED )
#    define FIRST_SYMNAME(name,control_type_name)    FIRST_SYMBOL = FIRST_SYMBOL_VALUE, name = FIRST_SYMBOL_VALUE
#    define SYMNAME(name,control_type_name)        , name
#    define SYMNAME_SKIP(prior, range, name,control_type_name)        , prior, name = prior+range
enum resource_enum {
#  endif
#endif
#if !defined( NAME_ENUMERATION_DECLARED ) || defined( BUILD_NAMES )
#undef BTN_OKAY
#undef BTN_CANCEL
FIRST_SYMNAME( BTN_OKAY, NORMAL_BUTTON_NAME )
SYMNAME(BTN_CANCEL,NORMAL_BUTTON_NAME)
SYMNAME( BTN_ABORT, NORMAL_BUTTON_NAME )
SYMNAME( EDT_X     , EDIT_FIELD_NAME )
SYMNAME( EDT_Y     , EDIT_FIELD_NAME )
SYMNAME( EDT_WIDTH , EDIT_FIELD_NAME )
SYMNAME( EDT_HEIGHT, EDIT_FIELD_NAME )
SYMNAME( EDT_CAPTION, EDIT_FIELD_NAME)
SYMNAME( EDT_ID     , EDIT_FIELD_NAME)
SYMNAME( EDT_IDNAME , EDIT_FIELD_NAME)
SYMNAME( LABEL_X    , STATIC_TEXT_NAME )
SYMNAME( LABEL_Y    , STATIC_TEXT_NAME)
SYMNAME( LABEL_WIDTH  , STATIC_TEXT_NAME)
SYMNAME( LABEL_HEIGHT , STATIC_TEXT_NAME)
SYMNAME( LABEL_CAPTION, STATIC_TEXT_NAME)
SYMNAME( LABEL_ID     , STATIC_TEXT_NAME)
SYMNAME( LISTBOX_IDS , LISTBOX_CONTROL_NAME  )
SYMNAME( SLD_GREENBAR    , SLIDER_CONTROL_NAME )
SYMNAME( PAL_COLORS      , "Color Matrix" )
 // define a preset
SYMNAME( BTN_PRESET      , NORMAL_BUTTON_NAME )
SYMNAME( CHK_ALPHA       , RADIO_BUTTON_NAME  )
SYMNAME( CST_SHADE       , "Shade Well" )
SYMNAME( CST_ZOOM        , "Shade Well" )
SYMNAME( CST_SHADE_RED   , "Shade Well" )
SYMNAME( CST_SHADE_BLUE  , "Shade Well" )
SYMNAME( CST_SHADE_GREEN , "Shade Well" )
		SYMNAME_SKIP( BTN_PRESET_BASE, 64, BTN_PRESET_LAST, CUSTOM_BUTTON_NAME )
#endif
#ifndef BUILD_NAMES
#  if !defined( NAME_ENUMERATION_DECLARED )
#  define NAME_ENUMERATION_DECLARED
};
#  endif
#endif
#undef SYMNAME
#undef FIRST_SYMNAME
#undef SYMNAME_SKIP
#undef BUILD_NAMES
PSI_FONTS_NAMESPACE
#define DIALOG_WIDTH 420+50
#define DIALOG_HEIGHT 300+200
#define MAX_FONT_HEIGHT 250
enum {
	LST_FONT_NAMES = 100
	  , LST_FONT_STYLES
	  , LST_FONT_SIZES
	  , CHK_MONO_SPACE
	  , CHK_PROP_SPACE
	  , CHK_BOTH_SPACE
	  , CHK_MONO
	  , CHK_2BIT
	  , CHK_8BIT
	  , CST_FONT_SAMPLE
	  , CST_CHAR_SIZE
	  , SLD_WIDTH
	  , SLD_HEIGHT
};
typedef struct font_dialog_tag
{
	struct {
		uint32_t show_mono_only : 1;
		uint32_t show_prop_only : 1;
		uint32_t showing_scalable : 1;
		uint32_t render_depth : 2;
	} flags;
	PSI_CONTROL pFrame;
	PSI_CONTROL pSample, pHorSlider, pVerSlider;
	PSI_CONTROL pVerValue, pVerLabel;
	PSI_CONTROL pHorValue, pHorLabel;
   // temp font for drawing sample
	SFTFont pFont;
	int done, okay;
	PFONT_ENTRY pFontEntry;
	int nFontEntry;
	PFONT_STYLE pFontStyle;
	int nFontStyle;
	PSIZE_FILE  pSizeFile;
	int nSizeFile;
	TEXTCHAR *filename;
	int32_t nWidth, nSliderWidth;
	int32_t nHeight, nSliderHeight;
	PFRACTION width_scale, height_scale;
	void (CPROC* Update)(uintptr_t,SFTFont);
	uintptr_t psvUpdate;
} FONT_DIALOG, *PFONT_DIALOG;
//-------------------------------------------------------------------------
PRIORITY_PRELOAD( InitFontDialogGlobal, IMAGE_PRELOAD_PRIORITY + 2 )
{
	// static variable.
#define fg (*global_font_data)
	SimpleRegisterAndCreateGlobal( global_font_data );
	if( !fg.library )
	{
		lprintf( "image library didn't load?" );
	}
}
typedef struct font_info_tag
{
	// should contain enough information to
	// recreate any font selected with the dialog...
 char unused;
} FONT_INFO, *PFONT_INFO;
//-------------------------------------------------------------------------
static int HasMonoSpacing( PFONT_ENTRY pfe )
{
	INDEX idx;
	PFONT_STYLE pfs;
	for( idx = 0; idx < pfe->nStyles; idx++ )
	{
		pfs = pfe->styles + idx;
		if( pfs->flags.mono )
			return TRUE;
	}
	return FALSE;
}
//-------------------------------------------------------------------------
static int HasPropSpacing( PFONT_ENTRY pfe )
{
	INDEX idx;
	PFONT_STYLE pfs;
	for( idx = 0; idx < pfe->nStyles; idx++ )
	{
		pfs = pfe->styles + idx;
		if( !pfs->flags.mono )
			return TRUE;
	}
	return FALSE;
}
//-------------------------------------------------------------------------
static int CPROC UpdateSample( PSI_CONTROL pc )
{
	Image surface = GetControlSurface( pc );
	PFONT_DIALOG pfd = (PFONT_DIALOG)GetFrameUserData( GetFrame( pc ) );
	if( pfd->pFont )
	{
		if( pfd->Update )
			pfd->Update( pfd->psvUpdate, pfd->pFont );
		ClearImageTo( surface, Color( 92, 91, 42 ) );
		PutStringFont( surface
						 , 5, 5
						 , Color( 255,255,255 ), Color( 82, 82, 82 )
						 , "The Quick Brown Fox"
						 , pfd->pFont );
	}
	return 1;
}
//-------------------------------------------------------------------------
int UpdateSampleFont( PFONT_DIALOG pfd )
{
	if( pfd->pFont )
	{
		UnloadFont( pfd->pFont );
		pfd->pFont = NULL;
	}
	if( pfd->pFontEntry && pfd->pFontStyle && pfd->pSizeFile )
	{
		// need to build this into a structure that can be resulted to render a font
		pfd->pFont = InternalRenderFont( (uint32_t)(pfd->pFontEntry - fg.pFontCache)
												 , (uint32_t)(pfd->nFontStyle)
												 , (uint32_t)(pfd->nSizeFile)
												 , pfd->nWidth
												 , pfd->nHeight
												 , (pfd->width_scale)
												 , (pfd->height_scale)
/*FONT_FLAG_8BIT*/
/*FONT_FLAG_2BIT*/
/*FONT_FLAG_MONO*/
												 , (pfd->flags.render_depth == 3)?2:(pfd->flags.render_depth==2)?1:0 );
		if( !pfd->pFont )
		{
			return FALSE;
		}
		SmudgeCommon( pfd->pSample );
	}
	else
	{
		pfd->pFont = RenderFontFile( pfd->filename
											, pfd->nWidth
											, pfd->nHeight
											, pfd->flags.render_depth );
		SmudgeCommon( pfd->pSample );
	}
	return TRUE;
}
//-------------------------------------------------------------------------
static int CPROC DrawCharacterSize( PSI_CONTROL pc )
{
	int x, y;
	int32_t width, height;
	PFONT_DIALOG pfd = (PFONT_DIALOG)GetFrameUserData( GetFrame( pc ) );
	Image surface = GetControlSurface( pc );
	//lprintf( "Drawing character size control..." );
	ClearImageTo( surface, Color( 92, 91, 42 ) );
	if( pfd->width_scale )
		(width = ScaleValue( pfd->width_scale, pfd->nSliderWidth ) );
	else
		(width = pfd->nSliderWidth);
	if( width <= surface->width )
		x = (surface->width - width )/ 2;
	else
		x = 0;
	if( pfd->height_scale )
		(height = ScaleValue( pfd->height_scale, pfd->nSliderHeight) );
	else
		(height = pfd->nSliderHeight);
	if( height < surface->height )
		y = (surface->height - height )/ 2;
	else
		y = 0;
	BlatColor( surface, x, y
				, width
				, height, Color( 0, 0, 0 ) );
	return 1;
}
//-------------------------------------------------------------------------
void CPROC UpdateCharRect( uintptr_t psv, PSI_CONTROL pc, int val )
{
	PFONT_DIALOG pfd = (PFONT_DIALOG)psv;
	if( GetControlID( pc ) == SLD_WIDTH )
	{
		if( pfd->nSliderWidth != val ) {
			pfd->nSliderWidth = val;
			{
				char buf[12];
				snprintf( buf, 12, "%d", val );
				SetEditControlSelection( pfd->pHorValue, 0, -1 );
				TypeIntoEditControl( pfd->pHorValue, buf );
			}
		}
		if( pfd->flags.showing_scalable )
			pfd->nWidth = pfd->nSliderWidth;
	}
	else if( GetControlID( pc ) == SLD_HEIGHT )
	{
		if( pfd->nSliderHeight != -val ) {
			pfd->nSliderHeight = -val;
			{
				char buf[12];
				snprintf( buf, 12, "%d", -val );
				SetEditControlSelection( pfd->pVerValue, 0, -1 );
				TypeIntoEditControl( pfd->pVerValue, buf );
			}
		}
		if( pfd->flags.showing_scalable )
			pfd->nHeight = pfd->nSliderHeight;
	}
	//lprintf( "Updated slider value - update control..." );
	if( pfd->flags.showing_scalable )
		UpdateSampleFont( pfd );
	SmudgeCommon( GetNearControl( pc, CST_CHAR_SIZE ) );
}
//-------------------------------------------------------------------------
static void CPROC SizeSelected( uintptr_t psv, PSI_CONTROL pc, PLISTITEM pli )
{
	PFONT_DIALOG pfd = (PFONT_DIALOG)psv;
// = (PSIZE_FILE)GetItemData( pli );
	PSIZE_FILE psf;
	pfd->nSizeFile = (int)GetItemData( pli );
	psf = pfd->pSizeFile = pfd->pFontStyle?(pfd->pFontStyle->files + pfd->nSizeFile):NULL;
	if( psf )
	{
		TEXTCHAR size[15], *tmp;
		int32_t width, height;
		GetListItemText( pli, size, sizeof( size ) );
		if( ( tmp = strchr( size, '(' ) ) )
			*tmp = 0;
#ifdef __cplusplus_cli
	char *mybuf = CStrDup( size );
#define SCANBUF mybuf
#else
#define SCANBUF size
#endif
#ifdef UNICODE
	swscanf
#else
	sscanf
#endif
		( size, "%" _32f "x%" _32f "", &width, &height );
#ifdef __cplusplus_cli
	Release( mybuf );
#endif
	// need to pull this info from the size sliiders...
	if( width == -1 )
	{
		pfd->flags.showing_scalable = 1;
		pfd->nWidth = pfd->nSliderWidth;
		pfd->nHeight = pfd->nSliderHeight;
	}
	else
	{
		pfd->flags.showing_scalable = 0;
		pfd->nWidth = width;
		pfd->nHeight = height;
	}
	if( !UpdateSampleFont( pfd ) )
	{
		DeleteListItem( pc, pli );
		if( !GetNthItem( pc, 0 ) )
		{
			PSI_CONTROL pcStyle;
			lprintf( "------------------------------------------------" );
			lprintf( "setting size_file as unuable.... rendering got us no data." );
			psf->flags.unusable = 1;
			pcStyle = GetNearControl( pc, LST_FONT_STYLES );
			lprintf( "Selecting tyle..." );
			SetSelectedItem( pcStyle, GetSelectedItem( pcStyle ) );
		}
	}
	}
	else
	{
		pfd->nWidth = pfd->nSliderWidth;
		pfd->nHeight = pfd->nSliderHeight;
		pfd->flags.showing_scalable = 1;
		UpdateSampleFont( pfd );
	}
}
//-------------------------------------------------------------------------
static void CPROC StyleSelected( uintptr_t psv, PSI_CONTROL pc, PLISTITEM pli )
{
	PFONT_DIALOG pfd = (PFONT_DIALOG)psv;
	PSI_CONTROL pcSizes;
	int npfs = (int)GetItemData( pli );
	PFONT_STYLE pfs = pfd->pFontEntry?(pfd->pFontEntry->styles + npfs):NULL;
	ResetList( pcSizes = GetNearControl( pc, LST_FONT_SIZES ) );
	pfd->pFontStyle = pfs;
	pfd->nFontStyle = npfs;
	if( pfs )
	{
		INDEX idx;
		PSIZE_FILE psf;
		int bAdded = 0;
		//lprintf( "Style selected, filling in sizes..." );
		for( idx = 0; psf = pfs->files + idx, idx < pfs->nFiles; idx++ )
		{
			TEXTCHAR entry[12];
			PLISTITEM hli;
			PSIZES size;
			INDEX idx2;
			if( psf->flags.unusable )
				continue;
			for( idx2 = 0; idx2 < psf->nSizes; idx2++ )
			{
				size = psf->sizes + idx2;
				if( size->flags.unusable )
				{
					lprintf( "Size is unusable..." );
					continue;
				}
				if( pfd->flags.show_mono_only ||
					pfd->flags.show_prop_only )
				{
					tnprintf( entry, 12, "%dx%d"
							  , size->width, size->height );
				}
				else
				{
					tnprintf( entry, 12, "%dx%d%s"
							  , size->width, size->height
							  , (pfs->flags.mono)?"(m)":"" );
				}
				bAdded++;
				hli =	AddListItem( pcSizes, entry );
				SetItemData( hli, (uintptr_t)idx );
			}
		}
		if( !bAdded )
		{
			PSI_CONTROL pcFamily;
			lprintf( "Hmm had no sizes, have to remove my own item also." );
			pfs->flags.unusable = 1;
			DeleteListItem( pc, pli );
			pcFamily = GetNearControl( pc, LST_FONT_NAMES );
			SetSelectedItem( pcFamily, GetSelectedItem( pcFamily ) );
			return;
		}
		SetSelectedItem( pcSizes, GetNthItem( pcSizes, 0 ) );
	}
	else
	{
		SetSelectedItem( pcSizes, AddListItem( pcSizes, "only size" ) );
	}
}
//-------------------------------------------------------------------------
static void CPROC FamilySelected( uintptr_t psv, PSI_CONTROL pc, PLISTITEM pli )
{
	int npfe = GetItemData( pli );
	PFONT_ENTRY pfe = fg.pFontCache + npfe;
	PFONT_DIALOG pfd = (PFONT_DIALOG)psv;
	INDEX idx;
	int selected = 0;
	PFONT_STYLE pfs;
	PSI_CONTROL pcStyle;
	int bAdded = 0;
	ResetList( pcStyle = GetNearControl( pc, LST_FONT_STYLES ) );
	DisableUpdateListBox( GetNearControl( pc, LST_FONT_SIZES ), TRUE );
	DisableUpdateListBox( pcStyle, TRUE );
	pfd->pFontEntry = pfe;
	pfd->nFontEntry = npfe;
	if( pfe )
	{
		for( idx = 0; idx < pfe->nStyles; idx++ )
		{
			PLISTITEM hli;
			pfs = pfe->styles + idx;
			if( pfs->flags.unusable )
				continue;
			if( pfs->flags.mono && pfd->flags.show_prop_only )
				continue;
			if( !pfs->flags.mono && pfd->flags.show_mono_only )
				continue;
			bAdded++;
			hli = AddListItem( pcStyle, pfs->name );
			SetItemData( hli, (uintptr_t)idx );
			if( pfd->pFontStyle == pfs )
			{
				SetSelectedItem( pcStyle, hli );
				selected = 1;
			}
		}
		if( !bAdded )
		{
			lprintf( "No styles, deleting my family name from the list... and then uhmm something" );
			DeleteListItem( pc, pli );
			SetSelectedItem( pc, GetNthItem( pc, 0 ) );
			pfe->flags.unusable = 1;
			return;
		}
	}
	else
	{
		SetSelectedItem( pcStyle, AddListItem( pcStyle, "only style" ) );
		selected = 1;
	}
	if( !selected )
		SetSelectedItem( pcStyle, GetNthItem( pcStyle, 0 ) );
	DisableUpdateListBox( GetNearControl( pc, LST_FONT_SIZES ), FALSE );
	DisableUpdateListBox( pcStyle, FALSE );
}
//-------------------------------------------------------------------------
static void CPROC FillFamilyList( PFONT_DIALOG pfd )
{
	PLISTITEM pliSelect = NULL;
	PSI_CONTROL pc = GetControl( pfd->pFrame, LST_FONT_NAMES );
	DisableUpdateListBox( pc, TRUE );
	{
		PFONT_ENTRY pfe;
		INDEX idx;
		ResetList( pc );
		for( idx = 0; idx < fg.nFonts; idx++ )
		{
			PLISTITEM hli = NULL;
			pfe = fg.pFontCache + idx;
			if( pfe->flags.unusable )
				continue;
			if	( pfd->flags.show_mono_only )
			{
				if( HasMonoSpacing( pfe ) )
					hli = AddListItem( pc, pfe->name );
			}
			else if( pfd->flags.show_prop_only )
			{
				if( HasPropSpacing( pfe ) )
					hli = AddListItem( pc, pfe->name );
			}
			else
			{
				hli = AddListItem( pc, pfe->name );
			}
			if( hli )
				SetItemData( hli, (uintptr_t)idx );
		}
		if( pfd->filename )
			pliSelect = AddListItem( pc, "DEFAULT" );
	}
	if( !pliSelect )
	{
		//lprintf( "attempt select %d", pfd->pFontEntry?((uint32_t)(pfd->pFontEntry - fg.pFontCache)):0 );
		pliSelect = GetNthItem( pc
									 , pfd->pFontEntry?((uint32_t)(pfd->pFontEntry - fg.pFontCache)):0 );
	}
	SetSelectedItem( pc, pliSelect );
	DisableUpdateListBox( pc, FALSE );
}
//-------------------------------------------------------------------------
static void CPROC SetFontSpacingSelection( uintptr_t psv, PSI_CONTROL pc )
{
	PFONT_DIALOG pfd = (PFONT_DIALOG)psv;
	switch( GetControlID( pc ) )
	{
	case CHK_MONO_SPACE:
		pfd->flags.show_mono_only = 1;
		pfd->flags.show_prop_only = 0;
		break;
	case CHK_PROP_SPACE:
		pfd->flags.show_mono_only = 0;
		pfd->flags.show_prop_only = 1;
		break;
	case CHK_BOTH_SPACE:
		pfd->flags.show_mono_only = 0;
		pfd->flags.show_prop_only = 0;
		break;
	}
	pfd->pFontEntry = NULL;
	FillFamilyList( pfd );
}
//-------------------------------------------------------------------------
static void CPROC SetFontAlphaSelection( uintptr_t psv, PSI_CONTROL pc )
{
	PFONT_DIALOG pfd = (PFONT_DIALOG)psv;
	switch( GetControlID( pc ) )
	{
	case CHK_MONO:
		pfd->flags.render_depth = 1;
		break;
	case CHK_2BIT:
		pfd->flags.render_depth = 2;
		break;
	case CHK_8BIT:
		pfd->flags.render_depth = 3;
		break;
	}
	UpdateSampleFont( pfd );
}
//-------------------------------------------------------------------------
int CPROC SampleMouse( PSI_CONTROL pc, int32_t x, int32_t y, uint32_t b )
{
	return 0;
//  PFONT_DIALOG pfd = (PFONT_DIALOG)psv;
}
//-------------------------------------------------------------------------
static void CPROC ButtonApply( uintptr_t psvControl, PSI_CONTROL pc )
{
	PFONT_DIALOG pfd = (PFONT_DIALOG)GetFrameUserData( GetFrame( pc ) );
	// should duplicate or add a font reference or something...
	// next rendering is going to invalidate this...
	if( pfd->Update )
		pfd->Update( pfd->psvUpdate, pfd->pFont );
}
//-------------------------------------------------------------------------
extern CONTROL_REGISTRATION font_sample;
int CPROC InitFontSample( PSI_CONTROL pc, va_list args )
{
	return 1;
}
int CPROC InitFontSizer( PSI_CONTROL pc, va_list args )
{
	return 1;
}
//-------------------------------------------------------------------------
CONTROL_REGISTRATION font_sample = { "Font Sample", { { DIALOG_WIDTH - 10, DIALOG_HEIGHT - 245 }, 0, BORDER_THIN|BORDER_INVERT }
 // InitFont
											  , NULL
											  , NULL
											  , UpdateSample
											  , SampleMouse
};
CONTROL_REGISTRATION char_size = { "Font Size Control", { { 80, 80 }, 0, BORDER_THIN|BORDER_INVERT }
 // InitFont
											  , NULL
											  , NULL
											  , DrawCharacterSize
											  , NULL
};
PRIORITY_PRELOAD( RegisterFont, PSI_PRELOAD_PRIORITY )
{
	DoRegisterControl( &font_sample );
	DoRegisterControl( &char_size );
}
void CPROC heightChanged( PSI_CONTROL pc ) {
	static int fixing;
	FONT_DIALOG  *pfdData = (FONT_DIALOG*)GetFrameUserData( GetParentControl( pc ) );
	char buf[12];
	int n;
	if( fixing ) return;
	GetControlText( pc, buf, 12 );
	n = (int)IntCreateFromText( buf );
	if( pfdData->nSliderHeight == n )
		return;
	if( n > MAX_FONT_HEIGHT ) {
		n = MAX_FONT_HEIGHT;
		snprintf( buf, 12, "%d", n );
		SetEditControlSelection( pc, 0, -1 );
		fixing = 1;
		TypeIntoEditControl( pc, buf );
		fixing = 0;
	}
	if( n )
	{
		//pfdData->nHeight = n;
		pfdData->nSliderHeight = n;
		SetSliderValues( pfdData->pVerSlider, -MAX_FONT_HEIGHT, -n, 0 );
		if( pfdData->flags.showing_scalable )
			UpdateSampleFont( pfdData );
		SmudgeCommon( GetNearControl( pc, CST_CHAR_SIZE ) );
	}
}
void CPROC widthChanged( PSI_CONTROL pc ) {
	static int fixing;
	FONT_DIALOG  *pfdData = (FONT_DIALOG*)GetFrameUserData( GetParentControl( pc ) );
	char buf[12];
	int n;
	if( fixing ) return;
	GetControlText( pc, buf, 12 );
	n = (int)IntCreateFromText( buf );
	if( pfdData->nSliderWidth == n )
		return;
	if( n > MAX_FONT_HEIGHT ) {
		n = MAX_FONT_HEIGHT;
		snprintf( buf, 12, "%d", n );
		SetEditControlSelection( pc, 0, -1 );
		fixing = 1;
		TypeIntoEditControl( pc, buf );
		fixing = 0;
	}
	if( n )
	{
		pfdData->nSliderWidth = n;
		SetSliderValues( pfdData->pHorSlider, 0, n, MAX_FONT_HEIGHT );
			//pfdData->nWidth = n;
		if( pfdData->flags.showing_scalable )
			UpdateSampleFont( pfdData );
		SmudgeCommon( GetNearControl( pc, CST_CHAR_SIZE ) );
	}
}
//-------------------------------------------------------------------------
PSI_FONTS_NAMESPACE_END
IMAGE_NAMESPACE
	  extern uint64_t fontcachetime;
IMAGE_NAMESPACE_END
PSI_FONTS_NAMESPACE
SFTFont PickScaledFontWithUpdate( int32_t x, int32_t y
														, PFRACTION width_scale
														, PFRACTION height_scale
														, size_t *pFontDataSize
														 // resulting parameters for the data and size of data
														 // which may be passe dto RenderFontData
														, POINTER *pFontData
														, PSI_CONTROL pAbove
														, void (CPROC *UpdateFont)( uintptr_t psv, SFTFont font )
														, uintptr_t psvUpdate )
{
	PSI_CONTROL pc;
	FONT_DIALOG fdData;
	//Log( "Picking a font..." );
	LoadAllFonts();
#ifdef USE_INTERFACES
	GetMyInterface();
#endif
	//SetControlInterface( GetDisplayInterface() );
	//SetControlImageInterface( GetImageInterface() );
	//fdData.pFont = GetDefaultFont();
	MemSet( &fdData, 0, sizeof( fdData ) );
	// attempt to see if passed in data is reasonable
	// then try and use it as default dialogdata...
	if( pFontData
		&& (*pFontData )
		&& pFontDataSize
		&& ( (*pFontDataSize) > sizeof( RENDER_FONTDATA ) )
		&& ( (*pFontDataSize) < sizeof( FONTDATA ) + 4096 ) )
	{
		PFONTDATA pResult = (PFONTDATA)(*pFontData);
		if( ( pResult->magic != MAGIC_PICK_FONT ) && ( pResult->magic != MAGIC_RENDER_FONT ) )
		{
			if( strncmp( (char*)pResult, "pick,", 5 ) == 0 )
			{
				PFONTDATA pfd = New( FONTDATA );
				lprintf( "Recover pick font data..." );
				pfd->magic = MAGIC_PICK_FONT;
				{
					int family, style, file, width, height, flags;
					sscanf( (((char*)pResult) + 5), "%d,%d,%d,%d,%d,%d"
							, &family, &style, &file
							, &width, &height, &flags );
					lprintf( "%d,%d,%d,%d", family, style, file, flags );
					pfd->nWidth = width;
					pfd->nHeight = height;
					pfd->flags = flags;
					pfd->nFamily = family;
					pfd->nStyle = style;
					pfd->nFile = file;
				}
				pResult = pfd;
			}
			else
			{
				PRENDER_FONTDATA prfd;
				CTEXTSTR tail = StrRChr( (TEXTSTR)pResult, ',' );
				if( tail )
					tail++;
				else
					tail = "";
				prfd = NewPlus( RENDER_FONTDATA, (StrLen( tail ) + 1)*sizeof(TEXTCHAR) );
				StrCpy( prfd->filename, tail );
				prfd->magic = MAGIC_RENDER_FONT;
				{
					int width, height, flags;
					sscanf( (char*)pResult, "%d,%d,%d", &width, &height, &flags );
					prfd->nWidth = width;
					prfd->nHeight = height;
					prfd->flags = flags;
				}
				pResult = (PFONTDATA)prfd;
			}
		}
		if( pResult->magic == MAGIC_PICK_FONT )
		{
			if( pResult->nFamily < fg.nFonts )
			{
				fdData.pFontEntry = fg.pFontCache + pResult->nFamily;
				if( pResult->nStyle < fdData.pFontEntry->nStyles )
				{
					fdData.pFontStyle = fdData.pFontEntry->styles + pResult->nStyle;
					fdData.nFontStyle = pResult->nStyle;
					if( pResult->nFile < fdData.pFontStyle->nFiles )
						fdData.pSizeFile = fdData.pFontStyle->files + pResult->nFile;
				}
				fdData.flags.render_depth = pResult->flags;
			}
		}
		else
		{
			PRENDER_FONTDATA pResult = (PRENDER_FONTDATA)(*pFontData);
			lprintf( "wasn't a pick font stuct..." );
			fdData.flags.render_depth = pResult->flags;
			fdData.filename = pResult->filename;
		}
		fdData.nSliderWidth = pResult->nWidth;
		fdData.nSliderHeight = pResult->nHeight ;
	}
	else
	{
		fdData.nSliderWidth = 10;
		fdData.nSliderHeight = 14;
	}
	fdData.width_scale = width_scale;
	fdData.height_scale = height_scale;
	fdData.pFrame = CreateFrame( "Choose Font"
										, 0, 0
										, DIALOG_WIDTH, DIALOG_HEIGHT
										, 0
										, pAbove );
	if( !fdData.pFrame )
		return NULL;
	SetFrameUserData( fdData.pFrame, (uintptr_t)&fdData );
	MakeEditControl( fdData.pFrame, 5, 5
						, 210, 15, TXT_STATIC, "name...", 0 );
	pc = MakeListBox( fdData.pFrame, 5, 25
						 , 210, 210, LST_FONT_NAMES, 0 );
	SetSelChangeHandler( pc, FamilySelected, (uintptr_t)&fdData );
	pc = MakeListBox( fdData.pFrame
						 , 220, 25
						 , 125, 58, LST_FONT_STYLES, 0 );
	SetSelChangeHandler( pc, StyleSelected, (uintptr_t)&fdData );
	pc = MakeListBox( fdData.pFrame
						 , 350, 25
						 , 65, 58, LST_FONT_SIZES, 0 );
	SetSelChangeHandler( pc, SizeSelected, (uintptr_t)&fdData );
	MakeRadioButton( fdData.pFrame
						, 220, 88
						, 95, 15
						, CHK_MONO_SPACE, "Fixed", 1
						, RADIO_CALL_CHECKED
						, SetFontSpacingSelection, (uintptr_t)&fdData );
	MakeRadioButton( fdData.pFrame
						, 220, 102
						, 95, 15
						, CHK_PROP_SPACE, "Variable", 1
						, RADIO_CALL_CHECKED
						, SetFontSpacingSelection, (uintptr_t)&fdData );
	pc = MakeRadioButton( fdData.pFrame
						, 220, 116
						, 95, 15
							  , CHK_BOTH_SPACE, "Both", 1
								, RADIO_CALL_CHECKED
							  , SetFontSpacingSelection, (uintptr_t)&fdData );
	pc = MakeRadioButton( fdData.pFrame
						, 320, 88
						, 95, 15
						, CHK_8BIT, "8 bit", 1
						 , RADIO_CALL_CHECKED
						, SetFontAlphaSelection, (uintptr_t)&fdData );
	if( fdData.flags.render_depth == 3 )
		SetCheckState( pc, TRUE );
	pc = MakeRadioButton( fdData.pFrame
						, 320, 102
						, 95, 15
						, CHK_2BIT, "2 bit", 1
						 , RADIO_CALL_CHECKED
						, SetFontAlphaSelection, (uintptr_t)&fdData );
	if( fdData.flags.render_depth == 2 )
		SetCheckState( pc, TRUE );
	pc = MakeRadioButton( fdData.pFrame
							  , 320, 116
							  , 95, 15
							  , CHK_MONO, "mono", 1
								, RADIO_CALL_CHECKED
							  , SetFontAlphaSelection, (uintptr_t)&fdData );
	if( fdData.flags.render_depth == 0 ||
		fdData.flags.render_depth == 1 )
		SetCheckState( pc, TRUE );
	fdData.pSample = MakeNamedControl( fdData.pFrame, "Font Sample"
												 , 5, 240
												, DIALOG_WIDTH - 10, DIALOG_HEIGHT - 245
												, CST_FONT_SAMPLE );
	pc = MakeNamedControl( fdData.pFrame, "Font Size Control"
								, 220, 135
								, 80, 80
								, CST_CHAR_SIZE );
	//SetControlDraw( fdData.pVerSlider, DrawCharacterSize, 0 );
	fdData.pHorSlider = MakeSlider( fdData.pFrame
											, 220,  215
											, 80, 20
											, SLD_WIDTH
											 , SLIDER_HORIZ
											, UpdateCharRect, (uintptr_t)&fdData  );
	fdData.pVerSlider = MakeSlider( fdData.pFrame
											, 300,  135
											, 20, 80
											, SLD_HEIGHT
											 , SLIDER_VERT
											, UpdateCharRect, (uintptr_t)&fdData );
	// this makes the slider behave in a natural way
	fdData.pHorLabel = MakeTextControl( fdData.pFrame, 325, 161, 80, 20, TXT_STATIC, "Width", 0 );
	fdData.pHorValue = MakeEditControl( fdData.pFrame, 405, 161, 80, 20, TXT_STATIC, NULL, 0 );
	SetCaptionChangedMethod( fdData.pHorValue, widthChanged );
	//SetTextChan
	fdData.pVerLabel = MakeTextControl( fdData.pFrame, 325, 136, 80, 20, TXT_STATIC, "Height", 0 );
	fdData.pVerValue = MakeEditControl( fdData.pFrame, 405, 136, 80, 20, TXT_STATIC, NULL, 0 );
	SetCaptionChangedMethod( fdData.pVerValue, heightChanged );
	SetSliderValues( fdData.pHorSlider, 1, fdData.nSliderWidth, MAX_FONT_HEIGHT );
	SetSliderValues( fdData.pVerSlider, -MAX_FONT_HEIGHT, -fdData.nSliderHeight, -1 );
	AddCommonButtons( fdData.pFrame, &fdData.done, &fdData.okay );
	{
		PFRACTION sx, sy;
		PSI_CONTROL pc = GetControl( fdData.pFrame, BTN_OKAY );
		GetCommonScale( pc, &sx, &sy );
#define COMMON_BUTTON_HEIGHT 19
		MoveSizeCommon( pc
						  , ScaleValue( sx, DIALOG_WIDTH - 60 ), ScaleValue( sy, 240 - ( ( COMMON_BUTTON_HEIGHT + 5 ) * 2 ) )
						  , ScaleValue( sx, 55 ), ScaleValue( sy, COMMON_BUTTON_HEIGHT ) );
		pc = GetControl( fdData.pFrame, BTN_CANCEL );
		MoveSizeCommon( pc
						  , ScaleValue( sx, DIALOG_WIDTH - 60 ), ScaleValue( sy, 240 - ( COMMON_BUTTON_HEIGHT + 5 ) )
						  , ScaleValue( sx, 55 ), ScaleValue( sy, COMMON_BUTTON_HEIGHT ) );
		fdData.Update = UpdateFont;
		fdData.psvUpdate = psvUpdate;
		if( fdData.Update )
		{
			MakeButton( fdData.pFrame, DIALOG_WIDTH-60, 240 - ( ( COMMON_BUTTON_HEIGHT + 5 ) * 3 )
						 , 55, COMMON_BUTTON_HEIGHT, -1, "Apply", 0
						 , ButtonApply, 0 );
		}
#if 0
		MakeButton( fdData.pFrame
					 , DIALOG_WIDTH - 60, 240 - ( ( COMMON_BUTTON_HEIGHT + 5 ) * 2 )
					 , 55, COMMON_BUTTON_HEIGHT
					 , BTN_OKAY, "OK", 0, ButtonOkay, (uintptr_t)&fdData.okay );
		MakeButton( fdData.pFrame
					 , DIALOG_WIDTH - 60, 240 - ( COMMON_BUTTON_HEIGHT + 5 )
					 , 55, COMMON_BUTTON_HEIGHT
					 , BTN_CANCEL, "Cancel", 0, ButtonOkay, (uintptr_t)&fdData.done );
#endif
	}
	FillFamilyList( &fdData );
	DisplayFrameOver( fdData.pFrame, pAbove );
	while( 1 )
	{
		CommonWait( fdData.pFrame );
		if( fdData.done || fdData.okay )
		{
#ifdef _DEBUG
			//DumpLoadedFontCache();
#endif
			if( fdData.okay )
			{
				//if( pFontData )
				{
					if( fdData.pFontEntry )
					{
						size_t l1, l2, l3, l4;
						size_t resultsize = sizeof(FONTDATA)
							+ (l1=StrLen( fdData.pFontEntry->name ))
							+ (l2=StrLen( fdData.pFontStyle->name ))
							+ (l3=StrLen( fdData.pSizeFile->path ))
							+ (l4=StrLen( fdData.pSizeFile->file ))
							+ 4;
						TEXTCHAR buf[128];
// = (PFONTDATA)Allocate( resultsize );
						PFONTDATA pResult;
						snprintf( buf, 256, "pick,%d,%d,%d,%d,%d,%d,%s/%s"
								  , (int)(fdData.nFontEntry)
								  , (int)(fdData.nFontStyle)
								  , (int)(fdData.nSizeFile)
								  , (int)fdData.nWidth
								  , (int)fdData.nHeight
								  , (int)fdData.flags.render_depth
								  , fdData.pSizeFile->path
								  , fdData.pSizeFile->file
								  );
						resultsize = StrLen( buf );
						pResult = (PFONTDATA)StrDup( buf );
						/*
						pResult->magic = MAGIC_PICK_FONT;
						pResult->cachefile_time = fontcachetime;
						pResult->nFamily = (uint32_t)(fdData.pFontEntry - fg.pFontCache);
						pResult->nStyle = (uint32_t)(fdData.pFontStyle - fdData.pFontEntry->styles);
						pResult->nFile = (uint32_t)(fdData.pSizeFile - fdData.pFontStyle->files);
						//fdData.pFontStyle->flags.mono
						pResult->flags = fdData.flags.render_depth;
						pResult->nWidth = fdData.nWidth;
						pResult->nHeight = fdData.nHeight;
						offset = 0;
						StrCpyEx( pResult->names + offset, fdData.pFontEntry->name, l1+1 );
						offset += l1 + 1;
						StrCpyEx( pResult->names + offset, fdData.pFontStyle->name, l2+1 );
						offset += l2 + 1;
						offset += tnprintf( pResult->names + offset*sizeof(TEXTCHAR), l3+l4+2, "%s/%s"
											  , fdData.pSizeFile->path
											  , fdData.pSizeFile->file
											  );
						*/
						//if( *pFontData )
						//{
						// unsafe to do, but we result in a memory leak otherwise...
						//	Release( *pFontData );
						//}
						if( pFontData )
							*pFontData = (POINTER)pResult;
						if( pFontDataSize )
							*pFontDataSize = resultsize;
						SetFontRendererData( fdData.pFont, pResult, resultsize );
					}
					else
					{
						TEXTCHAR buf[256];
						snprintf( buf, 256, "%d,%d,%d,%s"
								  , fdData.nWidth
								  , fdData.nHeight
								  , fdData.flags.render_depth
									, fdData.filename
								  );
						*pFontData = (POINTER)StrDup( buf );
						*pFontDataSize = strlen( buf ) + 1;
						/*
						size_t chars;
						size_t resultsize = sizeof(RENDER_FONTDATA)
							+ (chars=StrLen( fdData.filename ) + 1)*sizeof(TEXTCHAR);
						PRENDER_FONTDATA pResult = (PRENDER_FONTDATA)Allocate( resultsize );
						pResult->magic = MAGIC_RENDER_FONT;
						StrCpyEx( pResult->filename, fdData.filename, chars );
						pResult->flags = fdData.flags.render_depth;
						pResult->nWidth = fdData.nWidth;
						pResult->nHeight = fdData.nHeight;
						//if( *pFontData )
						//{
						// unsafe to do, but we result in a memory leak otherwise...
						//	Release( *pFontData );
						//}
						*pFontData = (POINTER)pResult;
						if( pFontDataSize )
						*pFontDataSize = resultsize;
						*/
						SetFontRendererData( fdData.pFont, *pFontData, *pFontDataSize );
					}
				}
			}
			else
			{
				if( fdData.pFont )
				{
					UnloadFont( fdData.pFont );
					fdData.pFont = NULL;
				}
			}
			break;
		}
		fdData.okay = 0;
		fdData.done = 0;
	}
	DestroyFrame( &fdData.pFrame );
	UnloadAllFonts();
	return fdData.pFont;
}
//-------------------------------------------------------------------------
PSI_PROC( SFTFont, PickFontWithUpdate )( int32_t x, int32_t y
										  , size_t *pFontDataSize
											// resulting parameters for the data and size of data
											// which may be passe dto RenderFontData
										  , POINTER *pFontData
										  , PSI_CONTROL pAbove
										  , void (CPROC *UpdateFont)( uintptr_t psv, SFTFont font )
										  , uintptr_t psvUpdate )
{
	return PickScaledFontWithUpdate( x, y, NULL, NULL, pFontDataSize, pFontData, pAbove, UpdateFont, psvUpdate );
}
void CPROC UpdateCommonFont( uintptr_t psvCommon, SFTFont font )
{
	SetCommonFont( (PSI_CONTROL)psvCommon, font );
}
PSI_PROC( SFTFont, PickFontFor )( int32_t x, int32_t y
									  , size_t *pFontDataSize
										// resulting parameters for the data and size of data
										// which may be passe dto RenderFontData
									  , POINTER *pFontData
									  , PSI_CONTROL pAbove
									  , PSI_CONTROL pUpdateFontFor )
{
	return PickFontWithUpdate( x, y, pFontDataSize, pFontData, pAbove, UpdateCommonFont, (uintptr_t)pUpdateFontFor );
}
PSI_PROC( SFTFont, PickFont )( int32_t x, int32_t y
								  , size_t * pFontDataSize
									// resulting parameters for the data and size of data
									// which may be passe dto RenderFontData
								  , POINTER *pFontData
								  , PSI_CONTROL pAbove )
{
	return PickFontWithUpdate( x, y, pFontDataSize, pFontData, pAbove, NULL, 0 );
}
#else
PSI_PROC( SFTFont, PickFont )( int32_t x, int32_t y
								  , size_t * size, POINTER *pFontData
								  , PFRAME pAbove )
{
	return NULL;
}
#endif
PSI_FONTS_NAMESPACE_END
//#define DEBUG_FOCUS
//#define HOTSPOT_DEBUG
//#define DEBUG_ADD_DELETEUSE
//#define EDIT_MOUSE_DEBUG
//#define DETAILED_MOUSE_DEBUG
//#define SUPER_DETAILED_MOUSE_DEBUG
//#define DEBUG_MOUSE_SMUDGE
//---------------------------------------------------------------------------
PSI_NAMESPACE
	void UpdateSomeControls( PSI_CONTROL pfc, P_IMAGE_RECTANGLE pRect );
PSI_NAMESPACE_END
PSI_MOUSE_NAMESPACE
//---------------------------------------------------------------------------
static void DrawHotSpotEx( PSI_CONTROL pc, P_IMAGE_POINT bias, P_IMAGE_POINT point, int hot DBG_PASS )
#define DrawHotSpot(pc,bias,point,hot) DrawHotSpotEx(pc,bias,point,hot DBG_SRC)
{
	Image surface = pc->Window;
	do_hline( surface, bias[1] + point[1] - SPOT_SIZE, bias[0] + point[0] - SPOT_SIZE, bias[0] + point[0] + SPOT_SIZE, Color( 0, 0, 0 ) );
	do_hline( surface, bias[1] + point[1] + SPOT_SIZE, bias[0] + point[0] - SPOT_SIZE, bias[0] + point[0] + SPOT_SIZE, Color( 0, 0, 0 ) );
	do_vline( surface, bias[0] + point[0] - SPOT_SIZE, bias[1] + point[1] - SPOT_SIZE, bias[1] + point[1] + SPOT_SIZE, Color( 0, 0, 0 ) );
	do_vline( surface, bias[0] + point[0] + SPOT_SIZE, bias[1] + point[1] - SPOT_SIZE, bias[1] + point[1] + SPOT_SIZE, Color( 0, 0, 0 ) );
	//_lprintf(DBG_RELAY)( "color %d %d %d %d %d %d", bias[0], bias[1], point[0], point[1], surface->width, surface->height );
	BlatColor( surface
				, bias[0] + point[0] - (SPOT_SIZE-1)
				, bias[1] + point[1] - (SPOT_SIZE-1)
				// one would fiture that this would be -2 (one for left, one for right)
				// but we have to add back in 1 for here cause we're based at here+ and here-
				, (SPOT_SIZE*2)-1, (SPOT_SIZE*2)-1
				, hot?Color( 255, 0, 0 ):Color(255,255,255) );
}
//---------------------------------------------------------------------------
void DrawHotSpotsEx( PSI_CONTROL pf, PEDIT_STATE pEditState, PSI_CONTROL pcChild DBG_PASS )
//#define DrawHotSpots(pf,pe) DrawHotSpotsEx(pf,pe DBG_SRC)
{
	int n;
	if( !pEditState->flags.bHotSpotsActive )
		return;
#ifdef HOTSPOT_DEBUG
	lprintf( "Drawing hotspots. %d,%d", pEditState->bias[0], pEditState->bias[1] );
#endif
	if( !pcChild || pcChild == pEditState->pCurrent ) {
		for( n = 0; n < 9; n++ ) {
			DrawHotSpotEx( pf
				, pEditState->bias
				, pEditState->hotspot[n]
				, (n + 1 == pEditState->flags.fLocked)
				DBG_RELAY );
		}
		/* this function updates the surface of a control.... */
		UpdateFrame( pf, 0, 0, pf->surface_rect.width, pf->surface_rect.height );
	}
	//UpdateFrame( pf
	//			, 0, 0, pf->pDevice->common->rect.width, pf->common->rect.height );
				//, pEditState->bound.position[0] + pEditState->bias[0]
				//, pEditState->bound.position[1] + pEditState->bias[1]
				//, pEditState->bound.size[0], pEditState->bound.size[1] );
}
//---------------------------------------------------------------------------
void SetupHotSpots( PEDIT_STATE pEditState )
{
	int bias_x = 0, bias_y = 0;
	PSI_CONTROL pCom;
	if( pCom = (PSI_CONTROL)pEditState->pCurrent )
	{
		do
		{
			bias_x += pCom->surface_rect.x;
			bias_y += pCom->surface_rect.y;
#ifdef HOTSPOT_DEBUG
			lprintf( "Bias is %d,%d", bias_x, bias_y );
#endif
			if( pCom && pCom->parent )
			{
				bias_x += pCom->rect.x;
				bias_y += pCom->rect.y;
#ifdef HOTSPOT_DEBUG
				lprintf( "Bias IS %d,%d", bias_x, bias_y );
#endif
			}
			pCom = pCom->parent;
		}
		while( pCom );
		pEditState->bias[0] = bias_x - (SPOT_SIZE);
		pEditState->bias[1] = bias_y - (SPOT_SIZE);
#ifdef HOTSPOT_DEBUG
		lprintf( "Setup hotspots for control %p (%d,%d)"
				, pEditState->pCurrent
				, pEditState->bias[0], pEditState->bias[1] );
#endif
		pEditState->hotspot[0][0] = 0;
		pEditState->hotspot[0][1] = 0;
		pEditState->hotspot[1][0] = 0 + (pEditState->pCurrent->rect.width) / 2;
		pEditState->hotspot[1][1] = 0;
		pEditState->hotspot[2][0] = 0 + (pEditState->pCurrent->rect.width);
		pEditState->hotspot[2][1] = 0;
		pEditState->hotspot[3][0] = 0;
		pEditState->hotspot[3][1] = 0 + (SPOT_SIZE + pEditState->pCurrent->rect.height) / 2;
		pEditState->hotspot[4][0] = 0 + (pEditState->pCurrent->rect.width) / 2;
		pEditState->hotspot[4][1] = 0 + (SPOT_SIZE + pEditState->pCurrent->rect.height) / 2;
		pEditState->hotspot[5][0] = 0 + (pEditState->pCurrent->rect.width);
		pEditState->hotspot[5][1] = 0 + (SPOT_SIZE + pEditState->pCurrent->rect.height) / 2;
		pEditState->hotspot[6][0] = 0;
		pEditState->hotspot[6][1] = 0 + (SPOT_SIZE + pEditState->pCurrent->rect.height) - 1;
		pEditState->hotspot[7][0] = 0 + (pEditState->pCurrent->rect.width) / 2;
		pEditState->hotspot[7][1] = 0 + (SPOT_SIZE + pEditState->pCurrent->rect.height) - 1;
		pEditState->hotspot[8][0] = 0 + (pEditState->pCurrent->rect.width);
		pEditState->hotspot[8][1] = 0 + (SPOT_SIZE + pEditState->pCurrent->rect.height) - 1;
		{
			int n;
			for( n = 0; n < 9; n++ )
			{
#ifdef HOTSPOT_DEBUG
				lprintf( "Hotspot %d is %d,%d"
						, n
						, pEditState->hotspot[n][0]
						, pEditState->hotspot[n][1] );
#endif
			}
		}
		pEditState->bound.position[0] = 0 - SPOT_SIZE;
		pEditState->bound.position[1] = 0 - SPOT_SIZE;
		pEditState->bound.size[0] = pEditState->pCurrent->rect.width + (SPOT_SIZE * 2);
		pEditState->bound.size[1] = pEditState->pCurrent->rect.height + (SPOT_SIZE * 2);
		pEditState->flags.bHotSpotsActive = 1;
	}
}
//---------------------------------------------------------------------------
static int MouseInHotSpot( PEDIT_STATE pEditState, int x, int y DBG_PASS )
#define MouseInHotSpot( pes, x, y ) MouseInHotSpot( pes, x, y DBG_SRC )
{
	int n;
	if( !pEditState->flags.bActive || !pEditState->flags.bHotSpotsActive )
		return 0;
#ifdef HOTSPOT_DEBUG
	_xlprintf( 1 DBG_RELAY )( "Detecting mouse at %d,%d in spot...", x, y );
	lprintf( "			mouse at %d,%d in spot...", x, y );
#endif
	if( pEditState->flags.fLocked )
	{
		int delx = x - pEditState->_x;
		int dely = y - pEditState->_y;
#ifdef HOTSPOT_DEBUG
		lprintf( "x %d y %d", x, y );
		lprintf( "pesx %d pesy %d", pEditState->_x, pEditState->_y);
		lprintf( "delx %d dely %d", delx, dely );
#endif
		if( delx > 0 )
			pEditState->delxaccum ++;
		else if( delx < 0 )
			pEditState->delxaccum--;
		if( dely > 0 )
			pEditState->delyaccum ++;
		else if( dely < 0 )
			pEditState->delyaccum--;
#ifdef HOTSPOT_DEBUG
		lprintf( "delxacc %d delyacc %d"
				, pEditState->delxaccum
				, pEditState->delyaccum );
#endif
#define LOCK_THRESHOLD 4
		if( pEditState->delxaccum <= -LOCK_THRESHOLD
			|| pEditState->delxaccum >= LOCK_THRESHOLD
			|| pEditState->delyaccum <= -LOCK_THRESHOLD
			|| pEditState->delyaccum >= LOCK_THRESHOLD )
		{
#ifdef HOTSPOT_DEBUG
			lprintf( "excessive threshold, unlock." );
#endif
			//return 0;// pEditState->flags.fLocked = FALSE;
		}
		else
		{
#ifdef HOTSPOT_DEBUG
			lprintf( "remain in same spot" );
#endif
			return pEditState->flags.fLocked;
		}
	}
	for( n = 0; n < 9; n++ )
	{
		if( ( pEditState->hotspot[n][0] - SPOT_SIZE ) <= x &&
			( pEditState->hotspot[n][0] + SPOT_SIZE ) >= x &&
			( pEditState->hotspot[n][1] - SPOT_SIZE ) <= y &&
			( pEditState->hotspot[n][1] + SPOT_SIZE ) >= y )
		{
#ifdef HOTSPOT_DEBUG
			_xlprintf( 1 DBG_RELAY )( "Detected mouse at %d,%d in spot %d", x, y, n );
#endif
			{
				pEditState->_x = pEditState->hotspot[n][0];
				pEditState->_y = pEditState->hotspot[n][1];
				pEditState->delxaccum = 0;
				pEditState->delyaccum = 0;
			}
			return n + 1;
		}
	}
	//_xlprintf( 1 DBG_RELAY )( "No spot at %d,%d...", x, y );
	return 0;
}
//---------------------------------------------------------------------------
static int CPROC EditControlKeyProc( PSI_CONTROL pc, uint32_t key )
{
	PPHYSICAL_DEVICE pf = GetFrame(pc)->device;
#ifdef HOTSPOT_DEBUG
	lprintf( "Edit control key proc..." );
#endif
	//ValidatedControlData( PFRAME, CONTROL_FRAME, pf, pc );
	if( pf )
	{
		PEDIT_STATE pEditState = &pf->EditState;
		if( key & KEY_PRESSED )
		{
			switch( KEY_CODE( key ) )
			{
			case KEY_LEFT:
				if( !( key & KEY_SHIFT_DOWN ) )
					MoveControlRel( pEditState->pCurrent, -1, 0 );
				else
					SizeControlRel( pEditState->pCurrent, -1, 0 );
				break;
			case KEY_RIGHT:
				if( !( key & KEY_SHIFT_DOWN ) )
					MoveControlRel( pEditState->pCurrent, 1, 0 );
				else
					SizeControlRel( pEditState->pCurrent, 1, 0 );
				break;
			case KEY_DOWN:
				if( !( key & KEY_SHIFT_DOWN ) )
					MoveControlRel( pEditState->pCurrent, 0, 1 );
				else
					SizeControlRel( pEditState->pCurrent, 0, 1 );
				break;
			case KEY_UP:
				if( !( key & KEY_SHIFT_DOWN ) )
					MoveControlRel( pEditState->pCurrent, 0, -1 );
				else
					SizeControlRel( pEditState->pCurrent, 0, -1 );
				break;
			default:
//#define InvokeMethod(pc,name,args)
				lprintf( "Passing keys default causes infinite loops..." );
				if(0 )
				if( (pEditState) && pEditState->_KeyProc )
				{
					int n;
					for( n = 0; n < pEditState->n_KeyProc; n++ )
						if( pEditState->_KeyProc[n] && (EditControlKeyProc != pEditState->_KeyProc[n] ))
							if( pEditState->_KeyProc[n](pc,key) )
							{
								/*break*/
;
								// then what?!  shouldn't we be calling the function here? :)
							}
				}
			}
		}
	}
	return 0;
}
//static int (CPROC*EditControlList)(PSI_CONTROL,uint32_t) = { EditControlKeyProc };
//---------------------------------------------------------------------------
_MOUSE_NAMESPACE_END
void SetCommonFocus( PSI_CONTROL pc )
{
	PSI_CONTROL frame;
	if( pc && ( frame = GetFrame( pc ) ) )
	{
		PPHYSICAL_DEVICE pf = frame->device;
		//ValidatedControlData( PFRAME, CONTROL_FRAME, pf, GetFrame( pc ) );
		// don't allow THIS focus routine to focus the frame
		// as a control...
		if( pf )
			ForceDisplayFocus( pf->pActImg );
#ifdef DEBUG_FOCUS
		lprintf( "Set common focus... to control %p (%d)", pc, pc->nType );
#endif
		if( pc && pf &&
 // already is focus...
			( pf->pFocus != pc ) )
		{
			if( !pc->flags.bDisable && !pc->flags.bNoFocus )
			{
				PSI_CONTROL test;
				test = pc->parent;
				while( test )
				{
					if( test == pf->pFocus )
						break;
					test = test->parent;
				}
				// it's okay to set focus of a child of the
				// thing which currently has the focus...
				// the container does not need to (and should not)
				// lose focus
				if( test )
				{
#ifdef DEBUG_FOCUS
					lprintf( "Prior focused thing is the parent of control being focused." );
#endif
				}
#ifdef DEBUG_FOCUS
				else
					lprintf( "Prior is not parent of control being focused..." );
#endif
				if( !test && pf->pFocus )
				{
					//lprintf( "forcing focused to false (does that next anyway)" );
					pf->pFocus->flags.bFocused = FALSE;
					InvokeSingleMethod( pf->pFocus, ChangeFocus, (pf->pFocus, FALSE) );
#ifdef DETAILED_MOUSE_DEBUG
					if( g.flags.bLogDetailedMouse )
						lprintf( "Clearing prior focus, telling control to draw itself..." );
#endif
#ifdef DEBUG_MOUSE_SMUDGE
					lprintf( "------------- SMUDGE OLD CONTROL THAT WAS FOCUSED...." );
#endif
					//SmudgeCommon( pf->pFocus );
				}
				// but we can transfer focus to an internal thingy...
				// might revisit uhmm something.
				if( pf->pFocus != pf->common )
					pf->pFocus->flags.bFocused = FALSE;
				//lprintf( "Set frame focused control to: %p (from)%p (to)%p", pf, pf->pFocus, pc );
				pf->pFocus = pc;
				pc->flags.bFocused = TRUE;
#ifdef DETAILED_MOUSE_DEBUG
				if( g.flags.bLogDetailedMouse )
				{
					lprintf( "Instruct control to draw itself..." );
					lprintf( "This should probably just refresh the border... well focus causes display phenomenoon..." );
				}
#endif
				InvokeSingleMethod( pf->pFocus, ChangeFocus, (pf->pFocus, TRUE) );
				//SmudgeCommon( pf->pFocus );
			}
#ifdef DETAILED_MOUSE_DEBUG
			else if( g.flags.bLogDetailedMouse )
			{
				lprintf( "Control is disabled or has no focus?" );
			}
#endif
			if( !pf->common->flags.bFocused ) {
            // the rame should be focused if a control in it is...
				pf->common->flags.bFocused = TRUE;
				//InvokeSingleMethod( pf->common, ChangeFocus, (pf->pFocus, TRUE) );
			}
		}
#ifdef DETAILED_MOUSE_DEBUG
		else if( g.flags.bLogDetailedMouse )
		{
			lprintf( "%p or %p is null or %p == %p", pf, pc, pf, pc );
		}
#endif
	}
}
int IsControlFocused( PSI_CONTROL pc )
{
	if( pc && pc->flags.bFocused )
		return TRUE;
	return FALSE;
}
_MOUSE_NAMESPACE
//---------------------------------------------------------------------------
void AddUseEx( PSI_CONTROL pc DBG_PASS )
{
	pc->InUse++;
#ifdef DEBUG_ADD_DELETEUSE
	_xlprintf( 2 DBG_RELAY )( "(A)Use count is %d %p", pc->InUse, pc );
	if( pc->flags.bDirty )
	{
		lprintf( "----==-=-=-=-=--==  was already dirt at add use!" );
	}
#endif
}
//---------------------------------------------------------------------------
void DeleteUseEx( PSI_CONTROL *pc DBG_PASS )
{
	if( pc && *pc )
	{
#ifdef DEBUG_ADD_DELETEUSE
		_xlprintf( 2 DBG_RELAY )( "(D)Use count is %d %p", (*pc)->InUse, (*pc) );
#endif
		if( ((*pc)->InUse - (*pc)->NotInUse )== 1 )
		{
			if( !(*pc)->flags.bDestroy )
			{
				// do update with use still locked...
				PSI_CONTROL parent = *pc;
				//PSI_CONTROL update = NULL;
				if(0)
 /*&& (parent->flags.bTransparent || parent->flags.bDirty)*/
				while( parent && ( parent->parent && !parent->device ) )
				{
					if( parent->flags.bDirty )
						parent->parent->flags.children_cleaned = 0;
					//lprintf( "Final use check - is %p dirty?!", parent );
					//if( parent->flags.bDirty )
					//	update = parent;
					parent = parent->parent;
				}
#ifdef DEBUG_ADD_DELETEUSE
				lprintf( "Begin Update topmost parent from deleteUse: %p", (parent) );
				//#endif
#endif
				//if( update )
				if( (!(*pc)->flags.bInitial)
					&& (*pc)->child
					&& (!(*pc)->parent)
				// && !((*pc)->flags.bRestoring)
				)
				{
					//IntelligentFrameUpdateAllDirtyControls( (*pc) DBG_RELAY );
					//UpdateCommonEx( (*pc), FALSE DBG_RELAY );
				}
				//UpdateCommonEx( parent, FALSE DBG_RELAY );
			}
		}
		if( !(--(*pc)->InUse) && !(*pc)->InWait)
		{
			if( (*pc)->flags.bDestroy )
				DestroyCommon( pc );
		}
	}
	else
	{
		_xlprintf( 2 DBG_RELAY )( "Use delete for invalid control!" );
	}
}
//---------------------------------------------------------------------------
void ReleaseCommonUse( PSI_CONTROL pc )
{
// set fake decrement to this ...
// we can force the render code of deleteuse to run
	pc->NotInUse = pc->InUse;
	// add one use, delete use consumes it.
	pc->InUse++;
	DeleteUseEx( &pc DBG_SRC );
	// the fake not-in-use counter is not useful anymore
	// we've already forced deleteuse to do the draw work (if not delete)
	pc->NotInUse = 0;
}
static void InvokeRollover( PPHYSICAL_DEVICE pf, PSI_CONTROL pc )
{
	if( pf->pCurrent && pc != pf->pCurrent )
	{
		if( pf->pCurrent->Rollover )
			pf->pCurrent->Rollover( pf->pCurrent, FALSE );
	}
	if( pc != pf->pCurrent )
	{
		if( pc && pc->Rollover )
			pc->Rollover( pc, TRUE );
		pf->pCurrent = pc;
	}
}
//---------------------------------------------------------------------------
#ifdef __cplusplus
}
#endif
static void OwnCommonMouse( PSI_CONTROL pc, int bOwn )
//static void OwnCommonMouseEx( PSI_CONTROL pc, int bOwn DBG_PASS)
//#define OwnCommonMouse(pc,own) OwnCommonMouseEx( pc,own DBG_SRC )
{
	PSI_CONTROL pfc = GetFrame( pc );
	PPHYSICAL_DEVICE pf = pfc->device;
//#ifdef DETAILED_MOUSE_DEBUG
//	if( g.flags.bLogDetailedMouse )
		//lprintf( "Own Common Mouse called on %p %s", pc, bOwn?"OWN":"release" );
//#endif
	if( pf )
	{
		if( ( !bOwn && ( pf->flags.bCurrentOwns ) )
			|| ( bOwn && !( pf->flags.bCurrentOwns ) ) )
		{
			//_lprintf(DBG_VOIDRELAY)( "Own Common Mouse performed on %p %s", pc, bOwn?"OWN":"release" );
			if( bOwn )
			{
				//pf->pCurrent = pc;
				InvokeRollover( pf, pc );
			}
			pf->flags.bCurrentOwns = bOwn;
			pf->flags.bApplicationOwned = bOwn;
			OwnMouse( pf->pActImg, bOwn );
		}
		else if( bOwn && ( pf->pCurrent != pc ) )
		{
			//_lprintf(DBG_VOIDRELAY)( "overlapping mouse own" );
			OwnCommonMouse( pf->pCurrent, FALSE );
			OwnCommonMouse( pc, TRUE );
		}
	}
}
#ifdef __cplusplus
namespace _mouse {
#endif
//---------------------------------------------------------------------------
void AddWaitEx( PSI_CONTROL pc DBG_PASS )
{
	pc->InWait++;
#ifdef DEBUG_ADD_DELETEUSE
	_xlprintf( 2 DBG_RELAY )( "Use count is %d %p", pc->InWait, pc );
#endif
}
//---------------------------------------------------------------------------
void DeleteWaitEx( PSI_CONTROL *pc DBG_PASS )
{
	if( pc && *pc )
	{
#ifdef DEBUG_ADD_DELETEUSE
		_xlprintf( 2 DBG_RELAY )( "Use count is %d %p", (*pc)->InWait, (*pc) );
#endif
		if( !(--(*pc)->InWait) && !(*pc)->InUse )
		{
			if( (*pc)->flags.bDestroy )
				DestroyCommon( pc );
		}
	}
	else
	{
		_xlprintf( 2 DBG_RELAY )( "Use delete for invalid control!" );
	}
}
//---------------------------------------------------------------------------
static PSI_CONTROL FindControl( PSI_CONTROL pfc, PSI_CONTROL pc, int x, int y, int b )
{
	// input x, y relative to the current frame bias on input.
	// _x, _y are the saved input values to this function
	// they are not modified. __x, __y are used as a temporary save spot
	int _x = x, __x;
	int _y = y, __y;
	struct
	{
		uint32_t was_in_surface : 1;
	} flags;
	IMAGE_POINT _bias;
	PPHYSICAL_DEVICE pf = pfc->device;
	flags.was_in_surface = pf->CurrentBias.flags.bias_is_surface;
	_bias[0] = pf->CurrentBias.x;
	_bias[1] = pf->CurrentBias.y;
	//ValidatedControlData( PFRAME, CONTROL_FRAME, pf, pfc );
//	lprintf( "So the input to FindControl x, y look like they are biased to THIS control? %d,%d", x, y );
	if( !pc )
	{
#ifdef SUPER_DETAILED_MOUSE_DEBUG
		if( g.flags.bLogSuperDetailedMouse )
			lprintf( "No child control start found." );
#endif
		return NULL;
	}
	for( ; pc; pc = pc->next )
	{
		if( pc->flags.bHidden )
		{
#ifdef SUPER_DETAILED_MOUSE_DEBUG
			if( g.flags.bLogSuperDetailedMouse )
				lprintf( "Skipping hidden control..." );
#endif
			continue;
		}
		x = _x - pc->rect.x;
		y = _y - pc->rect.y;
#ifdef SUPER_DETAILED_MOUSE_DEBUG
		if( g.flags.bLogSuperDetailedMouse )
			lprintf( "%d,%d (%d,%d) Control %p rect = (%d,%d)  (%d,%d)"
					, x, y
					, _x, _y
					, pc,pc->rect.x, pc->rect.y
					, pc->rect.width, pc->rect.height );
#endif
		if( (int64_t)x >= 0 &&
			(int64_t)x < pc->rect.width &&
			(int64_t)y >= 0 &&
			(int64_t)y < pc->rect.height )
		{
#ifdef DETAILED_MOUSE_DEBUG
			if( g.flags.bLogDetailedMouse )
				lprintf( "Setting bias to input %d,%d  ... plus %d,%d"
						, _bias[0], _bias[1]
						, pc->rect.x, pc->rect.y );
#endif
			pf->CurrentBias.x = _bias[0] + pc->rect.x;
			pf->CurrentBias.y = _bias[1] + pc->rect.y;
			pf->CurrentBias.flags.bias_is_surface = 0;
			__x = x;
			__y = y;
#ifdef DETAILED_MOUSE_DEBUG
			if( g.flags.bLogDetailedMouse )
				lprintf( "Okay coordinate within a control..." );
#endif
			x -= pc->surface_rect.x;
			y -= pc->surface_rect.y;
			if( (int64_t)x >= 0 &&
				(int64_t)x < ( pc->surface_rect.width ) &&
				(int64_t)y >= 0 &&
				(int64_t)y < ( pc->surface_rect.height ) )
			{
#ifdef DETAILED_MOUSE_DEBUG
				if( g.flags.bLogDetailedMouse )
					lprintf( "Adding the surface of the thing to the bias... %d,%d", pc->surface_rect.x, pc->surface_rect.y );
#endif
				pf->CurrentBias.flags.bias_is_surface = 1;
				pf->CurrentBias.x += pc->surface_rect.x;
				pf->CurrentBias.y += pc->surface_rect.y;
				// there may be a control contained within
				// this control which actually gets mouse....
#ifdef DETAILED_MOUSE_DEBUG
				if( g.flags.bLogDetailedMouse )
					lprintf( "Coordinate within surface of control even..." );
#endif
				if( pc->child )
				{
					PSI_CONTROL child;
#ifdef DETAILED_MOUSE_DEBUG
					if( g.flags.bLogDetailedMouse )
						lprintf( "To find a child control... at %d,%d ", x, y );
#endif
					child = FindControl( pfc, pc->child
											, x, y
											, b );
					if( child )
					{
#ifdef DETAILED_MOUSE_DEBUG
						if( g.flags.bLogDetailedMouse )
							lprintf( "Returning a child control..." );
#endif
						return child;
					}
#ifdef DETAILED_MOUSE_DEBUG
					if( g.flags.bLogDetailedMouse )
						lprintf( "So this control is THE control, no child." );
#endif
				}
				// otherwise, this control is now the primary owner...
				// -or- this control has become current....
			}
			else
			{
#ifdef DETAILED_MOUSE_DEBUG
				if( g.flags.bLogDetailedMouse )
					lprintf( "Coordinate NOT within the surface...but definatly in control" );
#endif
				//continue;
			}
			// at this point, what do we know?
			// x, y are within pfc
			// pf->CurrentBias == offset of the control's surface
			// we were called since pf->flags.bCurrentOwns was not set
			// pfc may be equal to pf...
#ifdef DETAILED_MOUSE_DEBUG
			if( g.flags.bLogDetailedMouse )
				Log( "Now setting pCurrent on frame..." );
#endif
			//bias[0] = _bias[0];
			//bias[1] = _bias[1];
			InvokeRollover( pf, pc );
			if( MAKE_FIRSTBUTTON( b, pf->_b ) )
			{
#ifdef DETAILED_MOUSE_DEBUG
				if( g.flags.bLogDetailedMouse )
					lprintf( "Setting focus..." );
#endif
				SetCommonFocus( pc );
				OwnCommonMouse( pc, TRUE );
				//pf->flags.bCurrentOwns = TRUE;
			}
			// and now - what about editing controls?
			// now that we have the mouse within a current
			// then that current range actually extends somewhat beyond
			// the actual surface of the control...
			// and we do not change active controls until surpassing THAT bound
			{
				PSI_CONTROL parent_non_private = pc;
				while( parent_non_private && ( parent_non_private->BorderType & BORDER_NO_EXTRA_INIT ) )
				{
					parent_non_private = parent_non_private->parent;
				}
			if( pf->EditState.flags.bActive )
			{
				// YES do ugly thing here ... there is a 'pc' which is the common that was
				// found containing the mouse.  the 'pc' for this subsection is the top control
				// which does not have a private flag... could mass replace this code
				// to use 'parent_non_private' instead of 'pc' but I was lazy and clever tonight.
				PSI_CONTROL pc = parent_non_private;
#ifdef HOTSPOT_DEBUG
				lprintf( "edit state active... do some stuff... ");
#endif
  // don't set focus to the frame...
				if( pc->nType &&
					(PSI_CONTROL)pc != pf->EditState.pCurrent )
				{
					pf->EditState.pCurrent = (PSI_CONTROL)pc;
					SetupHotSpots( &pf->EditState );
					// setup which spot we're in now.
#ifdef HOTSPOT_DEBUG
					lprintf( "New hot spot check... %d,%d", _x, _y );
#endif
					pf->EditState.flags.fLocked = MouseInHotSpot( &pf->EditState
																			 , _x
																			 , _y );
#ifdef EDIT_MOUSE_DEBUG
					Log( "And now we draw new spots..." );
#endif
					// hotspots have to be drawn on the frame, so they have to be refreshed on the frame
					SmudgeCommon( pf->common );
					{
						// override the current key proc so arrows work...
#ifdef HOTSPOT_DEBUG
						lprintf( "overriding key method." );
#endif
						pf->EditState.n_KeyProc = pf->EditState.pCurrent->n_KeyProc;
						pf->EditState._KeyProc = pf->EditState.pCurrent->_KeyProc;
						pf->EditState.pCurrent->n_KeyProc = 1;
						{
							static __KeyProc *tmp;
							tmp = (__KeyProc *)Allocate( sizeof( __KeyProc ) );
							tmp[0] = EditControlKeyProc;
							pf->EditState.pCurrent->_KeyProc = tmp;
						}
					}
				}
			}
			}
			// at this point x, y will be relative to the
			// surface of the thing.  Always...
			// if the coordinates are < 0 or > width
				// then they're still on the control but are on the
			// rectangle (border) and not within the control...
			// so.... given that let's see - perhaps for frames this
			/// will be allowed, but the range checking for controls
			// will fail of beyond the borders..
			// If it's a frame, then the x, y are relative
			// to the whole window thing.
			break;
		}
	}
	return pc;
}
//---------------------------------------------------------------------------
#ifdef WIN32
static void UpdateCursor( PSI_CONTROL pc, int x, int y, int caption_height, int frame_height )
{
	if( pc->BorderType & BORDER_RESIZABLE )
	{
		if( y < pc->surface_rect.y )
		{
			if ( y < ( pc->surface_rect.y - caption_height ) )
  // very top edge
			{
				int do_drag = 0;
				if( pc->border && ( pc->border->BorderHeight > 10 ) )
					do_drag = 1;
 // left side edge
					if( x < pc->surface_rect.x )
					{
						SetDisplayCursor( IDC_SIZENWSE );
				}
				else if( (int64_t)x > ( ( pc->surface_rect.x
 // right side edge
										+ pc->surface_rect.width ) ) )
				{
					SetDisplayCursor( IDC_SIZENESW );
				}
 // center top edge
				else
				{
					if( do_drag )
					{
						SetDisplayCursor( IDC_HAND );
					}
					else
					{
						SetDisplayCursor( IDC_SIZENS );
					}
				}
			}
			else
  // top within caption band
			{
 // left side edge
					if( x < pc->surface_rect.x )
					{
						SetDisplayCursor( IDC_SIZENWSE );
				}
				else if( (int64_t)x > ( pc->surface_rect.x
								+ pc->surface_rect.width ) )
				{
					SetDisplayCursor( IDC_SIZENESW );
				}
 // center bottom edge
				else
				{
					INDEX idx;
					PCAPTION_BUTTON button = NULL;
					LIST_FORALL( pc->caption_buttons, idx, PCAPTION_BUTTON, button )
					{
						if( x > button->offset )
							break;
					}
					if( button )
					{
						SetDisplayCursor( IDC_ARROW );
					}
					else
						SetDisplayCursor( IDC_HAND );
				}
			}
		}
		else if( (int64_t)y >= ( ( pc->surface_rect.y
 // bottom side...
								+ pc->surface_rect.height ) ) )
  // very bottom band
		{
			int do_drag = 0;
			if( pc->border && ( pc->border->BorderHeight > 10 ) )
				do_drag = 1;
 // left side edge
			if( x < ( pc->surface_rect.x ) )
			{
				SetDisplayCursor( IDC_SIZENESW );
			}
			else if( (int64_t)x > ( ( pc->surface_rect.x
									+ pc->surface_rect.width ) ) )
			{
				SetDisplayCursor( IDC_SIZENWSE );
			}
 // center bottom edge
			else
			{
#ifdef DETAILED_MOUSE_DEBUG
				if( g.flags.bLogDetailedMouse )
					Log( "Setting size frame on bottom edge" );
#endif
				if( do_drag )
				{
					SetDisplayCursor( IDC_HAND );
				}
				else
				{
					SetDisplayCursor( IDC_SIZENS );
				}
			}
		}
 // between top and bottom border/caption
		else
		{
			int do_drag = 0;
			if( pc->border && ( pc->border->BorderHeight > 10 ) )
				do_drag = 1;
 // left side edge
			if( x < pc->surface_rect.x )
			{
				if( do_drag )
				{
					SetDisplayCursor( IDC_HAND );
				}
				else
				{
					SetDisplayCursor( IDC_SIZEWE );
				}
			}
			else if( (int64_t)x >= ( ( pc->surface_rect.x
// right side edge
									+ pc->surface_rect.width ) ) )
			{
				if( do_drag )
				{
					SetDisplayCursor( IDC_HAND );
				}
				else
				{
					SetDisplayCursor( IDC_SIZEWE );
				}
			}
			else
			{
				SetDisplayCursor( IDC_ARROW );
			}
		}
	}
	else
	{
		if( ( (int64_t)y >= pc->surface_rect.y )
			&& ( (int64_t)y < ( pc->surface_rect.y
 // bottom side...
								+ pc->surface_rect.height ) )
 // left side edge
			&& ( (int64_t)x >= pc->surface_rect.x )
			&& ( (int64_t)x < ( pc->surface_rect.x
// right side edge
								+ pc->surface_rect.width ) ) )
		{
			SetDisplayCursor( IDC_ARROW );
		}
		else
		{
			PCAPTION_BUTTON button = NULL;
			if( ( y < frame_height )
				&& ( y > ( frame_height - caption_height ) )
				&& ( x < (int)( pc->surface_rect.x + pc->surface_rect.width ) )
				)
			{
				SetDisplayCursor( IDC_ARROW );
			}
			if( !button && !( pc->BorderType & BORDER_NOMOVE ) && pc->device )
			{
				// otherwise set dragging... hmm
				SetDisplayCursor( IDC_HAND );
			}
			else
				SetDisplayCursor( IDC_ARROW );
		}
	}
}
#else
#define UpdateCursor(a,...)
#endif
//---------------------------------------------------------------------------
static void UpdateCaption( PPHYSICAL_DEVICE pf, PSI_CONTROL pc )
{
	int y = FrameCaptionYOfs( pc, pc->BorderType );
	DrawFrameCaption( pc );
	if( pc->surface_rect.x > 0 )
		UpdateDisplayPortion( pf->pActImg
									, pc->surface_rect.x - 1, y
									, pc->surface_rect.width + 2
									, pc->surface_rect.y - y );
	else
		UpdateDisplayPortion( pf->pActImg
			, pc->surface_rect.x, y
			, pc->surface_rect.width + 1
			, pc->surface_rect.y - y );
}
static int CPROC FirstFrameMouse( PPHYSICAL_DEVICE pf, int32_t x, int32_t y, uint32_t b, int bCallOriginal )
{
	PSI_CONTROL pc = pf->common;
	extern void DumpFrameContents( PSI_CONTROL pc );
	int result = 0;
	int caption_height = CaptionHeight( pc, GetText( pc->caption.text ) );
	int frame_height = FrameBorderYOfs( pc, pc->BorderType, NULL );
 //|| defined EDIT_MOUSE_DEBUG
#if defined DETAILED_MOUSE_DEBUG
	if( g.flags.bLogDetailedMouse )
		lprintf( "Mouse Event: %p %d %d %d", pf, x, y, b );
#endif
	if( ( pf->_b & MK_LBUTTON ) &&
		( b & MK_LBUTTON ) )
	{
#ifdef DETAILED_MOUSE_DEBUG
		if( g.flags.bLogDetailedMouse )
			lprintf( "Continued down on left button" );
#endif
		//lprintf( "continued mouse down..." );
		if( pc->pressed_caption_button )
		{
			if( ( x < pc->pressed_caption_button->offset )
				|| ( y >= ( frame_height - caption_height ) )
				|| ( y < frame_height )
				|| ( x > ( pc->pressed_caption_button->offset + ( caption_height ) ) )
				)
			{
				if( g.flags.bLogDetailedMouse )
					lprintf( "outside of button..." );
				if( pc->pressed_caption_button->is_pressed )
				{
					int y = FrameCaptionYOfs( pc, pc->BorderType );
					pc->pressed_caption_button->is_pressed = 0;
					DrawFrameCaption( pc );
					UpdateDisplayPortion( pf->pActImg
												, pc->surface_rect.x - 1, y
												, pc->surface_rect.width + 2
												, pc->surface_rect.y - y );
				}
			}
			else
			{
				if( g.flags.bLogDetailedMouse )
					lprintf( "inside of button..." );
				if( !pc->pressed_caption_button->is_pressed )
				{
					int y = FrameCaptionYOfs( pc, pc->BorderType );
					pc->pressed_caption_button->is_pressed = 1;
					DrawFrameCaption( pc );
					UpdateDisplayPortion( pf->pActImg
												, pc->surface_rect.x - 1, y
												, pc->surface_rect.width + 2
												, pc->surface_rect.y - y );
				}
			}
		}
		else if( pf->flags.bDragging )
		{
			int32_t winx, winy;
			int dx;
			int dy;
			GetDisplayPosition( pf->pActImg, &winx, &winy, NULL, NULL );
			dx = x - pf->drag_x + winx;
			dy = y - pf->drag_y + winy;
#ifdef DETAILED_MOUSE_DEBUG
			if( g.flags.bLogDetailedMouse )
			{
				lprintf( "Still dragging frame at %d,%d", winx, winy );
				lprintf( "moving to %d,%d(%d,%d)", dx, dy, x - pf->drag_x, y - pf->drag_y );
			}
#endif
			if( pc->Move )
				pc->Move( pc, TRUE );
			MoveDisplay( pf->pActImg, dx, dy );
			if( pc->Move )
				pc->Move( pc, FALSE );
			return TRUE;
		}
		else if( pf->flags.bSizing )
		{
			int dx = x - pf->_x;
			int dy = y - pf->_y;
#ifdef DETAILED_MOUSE_DEBUG
			if( g.flags.bLogDetailedMouse )
				lprintf( "sizing by %d,%d", dx, dy );
#endif
			pc->flags.bResizedDirty = 1;
			if( pf->flags.bSizing_left )
			{
				if( pf->flags.bSizing_top )
				{
					MoveSizeDisplayRel( pf->pActImg, dx, dy, -dx, -dy );
				}
				else if( pf->flags.bSizing_bottom )
				{
					pf->_y = y;
					MoveSizeDisplayRel( pf->pActImg, dx, 0, -dx, dy );
				}
				else
				{
					MoveSizeDisplayRel( pf->pActImg, dx, 0, -dx, 0 );
				}
			}
			else if( pf->flags.bSizing_right )
			{
 // update prior coord to 'here'
				pf->_x = x;
				if( pf->flags.bSizing_top )
				{
					MoveSizeDisplayRel( pf->pActImg, 0, dy, dx, -dy );
				}
				else if( pf->flags.bSizing_bottom )
				{
					pf->_y = y;
					SizeDisplayRel( pf->pActImg, dx, dy );
				}
				else
				{
					SizeDisplayRel( pf->pActImg, dx, 0 );
				}
			}
			else
			{
				if( pf->flags.bSizing_top )
				{
					MoveSizeDisplayRel( pf->pActImg, 0, dy, 0, -dy );
				}
				else if( pf->flags.bSizing_bottom )
				{
					pf->_y = y;
					SizeDisplayRel( pf->pActImg, 0, dy );
				}
				else
				{
#ifdef DETAILED_MOUSE_DEBUG
					if( g.flags.bLogDetailedMouse )
						Log( "Sizing without a border!" );
#endif
					pf->flags.bSizing = 0;
				}
			}
			//DebugBreak();
			//SmudgeCommon( pc );
			return TRUE;
		}
		else
		{
#ifdef DETAILED_MOUSE_DEBUG
			if( g.flags.bLogDetailedMouse )
				lprintf( "Not moving, not sizing, pass mouse through..." );
#endif
			InvokeResultingMethod( result, pc, _MouseMethod, (pc
														, x - pc->surface_rect.x
														, y - pc->surface_rect.y
														, b ) );
		 }
	}
	else if( !( b & MK_LBUTTON ) )
	{
#ifdef DETAILED_MOUSE_DEBUG
		if( g.flags.bLogDetailedMouse )
			lprintf( "left is not down..." );
#endif
		OwnCommonMouse( pc, 0 );
		if( ( x > pc->surface_rect.x && x < (int)( pc->surface_rect.x + pc->surface_rect.width ) )
			&& ( y > pc->surface_rect.y && y < (int)( pc->surface_rect.y + pc->surface_rect.height ) ) )
		{
			if( pc->hover_caption_button )
			{
				pc->hover_caption_button->flags.rollover = 0;
				pc->hover_caption_button = NULL;
				UpdateCaption( pf, pc );
			}
			InvokeResultingMethod( result, pc, _MouseMethod, (pc
													 , x - pc->surface_rect.x
													 , y - pc->surface_rect.y
													 , b ) );
		}
		else
		{
			LOGICAL do_update = FALSE;
			INDEX idx;
			PCAPTION_BUTTON button;
 // left side edge
			if( ( x < (int)( pc->surface_rect.x + pc->surface_rect.width ) )
 // left side edge
				&& ( y < frame_height )
				&& ( y >= ( frame_height - caption_height ) ) )
			{
				LIST_FORALL( pc->caption_buttons, idx, PCAPTION_BUTTON, button )
				{
					if( button->flags.hidden )
						continue;
					if( x > button->offset )
					{
						if( pc->hover_caption_button != button )
						{
							if( pc->hover_caption_button )
								pc->hover_caption_button->flags.rollover = 0;
							button->flags.rollover = 1;
							pc->hover_caption_button = button;
							do_update = TRUE;
						}
						if( pc->pressed_caption_button && pc->pressed_caption_button == button )
						{
							button->is_pressed = FALSE;
							do_update = TRUE;
							button->pressed_event( pc );
						}
						break;
					}
				}
				if( !button )
				{
					if( pc->hover_caption_button )
					{
						pc->hover_caption_button->flags.rollover = 0;
						pc->hover_caption_button = NULL;
						do_update = 1;
					}
				}
			}
			else
			{
				if( pc->hover_caption_button )
				{
					pc->hover_caption_button->flags.rollover = 0;
					pc->hover_caption_button = NULL;
					do_update = 1;
				}
			}
			if( !pc->flags.bDestroy && pc->pressed_caption_button )
			{
				if( pc->pressed_caption_button->pressed )
				{
					pc->pressed_caption_button->is_pressed = FALSE;
					do_update = TRUE;
				}
				pc->pressed_caption_button = NULL;
			}
			if( do_update && !pc->flags.bDestroy )
			{
				UpdateCaption( pf, pc );
			}
		}
		if( !pc->flags.bDestroy )
		{
			pf->flags.bDragging = 0;
			pf->flags.bSizing = 0;
			pf->flags.bSizing_top = 0;
			pf->flags.bSizing_left = 0;
			pf->flags.bSizing_right = 0;
			pf->flags.bSizing_bottom = 0;
		}
	}
	else if( !(pf->_b & MK_LBUTTON )
 // check first down on dialog to drag
				&& ( b & MK_LBUTTON ) )
	{
		int caption_height = CaptionHeight( pc, GetText( pc->caption.text ) );
		int frame_height = FrameBorderYOfs( pc, pc->BorderType, NULL );
		 //Log( "No control, and last state was not pressed." );
		OwnCommonMouse( pc, 1 );
#ifdef DETAILED_MOUSE_DEBUG
		if( g.flags.bLogDetailedMouse )
			lprintf( "First left down (%d,%d) %08x", x, y , b );
#endif
		if( pc->BorderType & BORDER_RESIZABLE )
		{
				pf->_x = x;
				pf->_y = y;
				if( y < pc->surface_rect.y )
				{
					if ( y < ( pc->surface_rect.y - caption_height ) )
  // very top edge
					{
						int do_drag = 0;
						if( pc->border && ( pc->border->BorderHeight > 10 ) )
							do_drag = 1;
 // left side edge
						 if( x < pc->surface_rect.x )
						 {
#ifdef DETAILED_MOUSE_DEBUG
							 if( g.flags.bLogDetailedMouse )
								 Log( "Setting size frame on top/left edge" );
#endif
								pf->flags.bSizing_top = 1;
								pf->flags.bSizing_left = 1;
								pf->flags.bSizing = TRUE;
								result = 1;
						}
						else if( (int64_t)x > ( ( pc->surface_rect.x
 // right side edge
												+ pc->surface_rect.width ) ) )
						{
#ifdef DETAILED_MOUSE_DEBUG
							 if( g.flags.bLogDetailedMouse )
								 Log( "Setting size frame on top/right edge" );
#endif
								pf->flags.bSizing_top = 1;
								pf->flags.bSizing_right = 1;
								pf->flags.bSizing = TRUE;
								result = 1;
						}
 // center top edge
						else
						{
#ifdef DETAILED_MOUSE_DEBUG
							 if( g.flags.bLogDetailedMouse )
								 Log( "Setting size frame on top edge" );
#endif
							if( do_drag )
							{
								pf->flags.bDragging = 1;
								pf->drag_x = x;
								pf->drag_y = y;
							}
							else
							{
								pf->flags.bSizing_top = 1;
								pf->flags.bSizing = TRUE;
							}
							result = 1;
						}
					}
					else
  // top within caption band
					{
 // left side edge
						 if( x < pc->surface_rect.x )
						 {
#ifdef DETAILED_MOUSE_DEBUG
							 if( g.flags.bLogDetailedMouse )
								 Log( "Setting size frame on left edge(caption)" );
#endif
								pf->flags.bSizing_left = 1;
								pf->flags.bSizing_top = 1;
								pf->flags.bSizing = TRUE;
								result = 1;
							}
							else if( (int64_t)x > ( pc->surface_rect.x
											+ pc->surface_rect.width ) )
							{
#ifdef DETAILED_MOUSE_DEBUG
								if( g.flags.bLogDetailedMouse )
									Log( "Setting size frame on right edge(caption)" );
#endif
								pf->flags.bSizing_right = 1;
								pf->flags.bSizing_top = 1;
								pf->flags.bSizing = TRUE;
								result = 1;
							}
 // center bottom edge
							else
							{
								int on_button = 0;
#ifdef DETAILED_MOUSE_DEBUG
								if( g.flags.bLogDetailedMouse )
									Log( "Setting drag frame on caption" );
#endif
								if( !on_button && pc->caption_buttons )
								{
									PCAPTION_BUTTON button;
									INDEX idx;
									LIST_FORALL( pc->caption_buttons, idx, PCAPTION_BUTTON, button )
									{
										if( button->flags.hidden )
											continue;
										if( x > button->offset )
										{
											on_button = TRUE;
											break;
										}
									}
									if( button )
									{
										if( !button->is_pressed )
										{
											int y = FrameCaptionYOfs( pc, pc->BorderType );
											pc->pressed_caption_button = button;
											button->is_pressed = TRUE;
											DrawFrameCaption( pc );
											UpdateDisplayPortion( pf->pActImg, pc->surface_rect.x - 1, y
																		, pc->surface_rect.width + 2
																		, pc->surface_rect.y - y );
										}
									}
								}
								if( !on_button )
								{
									pf->flags.bDragging = TRUE;
									pf->drag_x = x;
									pf->drag_y = y;
								}
								result = 1;
							}
					}
				}
				else if( (int64_t)y >= ( ( pc->surface_rect.y
 // bottom side...
									 + pc->surface_rect.height ) ) )
  // very bottom band
				{
					int do_drag = 0;
					if( pc->border && ( pc->border->BorderHeight > 10 ) )
						do_drag = 1;
 // left side edge
					if( x < ( pc->surface_rect.x ) )
					{
#ifdef DETAILED_MOUSE_DEBUG
						if( g.flags.bLogDetailedMouse )
							Log( "Setting size frame on left/bottom edge" );
#endif
						 pf->flags.bSizing_left = 1;
						 pf->flags.bSizing_bottom = 1;
						 pf->flags.bSizing = TRUE;
						 result = 1;
					}
					else if( (int64_t)x > ( ( pc->surface_rect.x
										 + pc->surface_rect.width ) ) )
					{
#ifdef DETAILED_MOUSE_DEBUG
						if( g.flags.bLogDetailedMouse )
							Log( "Setting size frame on right/bottom edge" );
#endif
						 pf->flags.bSizing_right = 1;
						 pf->flags.bSizing_bottom = 1;
						 pf->flags.bSizing = TRUE;
						 result = 1;
					}
 // center bottom edge
					else
					{
#ifdef DETAILED_MOUSE_DEBUG
						if( g.flags.bLogDetailedMouse )
							Log( "Setting size frame on bottom edge" );
#endif
						if( do_drag )
						{
							pf->flags.bDragging = 1;
							pf->drag_x = x;
							pf->drag_y = y;
						}
						else
						{
							if( do_drag )
							{
								pf->flags.bDragging = 1;
								pf->drag_x = x;
								pf->drag_y = y;
							}
							else
							{
								pf->flags.bSizing_bottom = 1;
								pf->flags.bSizing = TRUE;
							}
						}
						result = 1;
					}
				}
 // between top and bottom border/caption
				else
				{
					int do_drag = 0;
					if( pc->border && ( pc->border->BorderHeight > 10 ) )
						do_drag = 1;
 // left side edge
					if( x < pc->surface_rect.x )
					{
#ifdef DETAILED_MOUSE_DEBUG
						if( g.flags.bLogDetailedMouse )
							Log( "Setting size frame on left edge" );
#endif
						if( do_drag )
						{
							pf->flags.bDragging = 1;
							pf->drag_x = x;
							pf->drag_y = y;
						}
						else
						{
							pf->flags.bSizing_left = 1;
							pf->flags.bSizing = TRUE;
						}
						result = 1;
					}
					else if( (int64_t)x >= ( ( pc->surface_rect.x
// right side edge
										 + pc->surface_rect.width ) ) )
					{
#ifdef DETAILED_MOUSE_DEBUG
						if( g.flags.bLogDetailedMouse )
							Log( "Setting size frame on right edge" );
#endif
						if( do_drag )
						{
							pf->flags.bDragging = 1;
							pf->drag_x = x;
							pf->drag_y = y;
						}
						else
						{
							pf->flags.bSizing_right = 1;
							pf->flags.bSizing = TRUE;
						}
						result = 1;
					}
					else
					{
						if( bCallOriginal )
							InvokeResultingMethod( result, pc, _MouseMethod, (pc
																	 , x - pc->surface_rect.x
																	 , y - pc->surface_rect.y
																	 , b ) );
					}
				}
		}
		else
		{
			if( ( (int64_t)y >= pc->surface_rect.y )
				&& ( (int64_t)y < ( pc->surface_rect.y
 // bottom side...
									+ pc->surface_rect.height ) )
 // left side edge
				&& ( (int64_t)x >= pc->surface_rect.x )
				&& ( (int64_t)x < ( pc->surface_rect.x
// right side edge
									+ pc->surface_rect.width ) ) )
			{
				// if within the surface, then forward to the real mouse proc...
#ifdef DETAILED_MOUSE_DEBUG
				if( g.flags.bLogDetailedMouse )
					lprintf( "dispatching mouse to frame mouse method %d,%d biased %d,%d", x, y
							, pc->surface_rect.x
							, pc->surface_rect.y );
#endif
				if( bCallOriginal )
					InvokeResultingMethod( result, pc, _MouseMethod, (pc
															, x - pc->surface_rect.x
															, y - pc->surface_rect.y
															, b ) );
			}
			else
			{
				PCAPTION_BUTTON button = NULL;
				if( ( y < frame_height )
					&& ( y >= ( frame_height - caption_height ) )
					&& ( x < (int)( pc->surface_rect.x + pc->surface_rect.width ) )
					)
				{
					INDEX idx;
					LIST_FORALL( pc->caption_buttons, idx, PCAPTION_BUTTON, button )
					{
						if( button->flags.hidden )
							continue;
						if( x > button->offset )
						{
							if( button != pc->hover_caption_button )
							{
								if( pc->hover_caption_button )
								{
								}
							}
							break;
						}
					}
					if( button )
					{
						int y = FrameCaptionYOfs( pc, pc->BorderType );
						pc->pressed_caption_button = button;
						button->is_pressed = TRUE;
						DrawFrameCaption( pc );
						UpdateDisplayPortion( pf->pActImg, pc->surface_rect.x - 1, y
													, pc->surface_rect.width + 2
													, pc->surface_rect.y - y );
					}
				}
				if( !button && !( pc->BorderType & BORDER_NOMOVE ) && pc->device )
				{
					// otherwise set dragging... hmm
#ifdef DETAILED_MOUSE_DEBUG
					if( g.flags.bLogDetailedMouse )
						lprintf( "Set drag on frame to %d,%d", x, y );
#endif
					pf->_x = x;
					pf->_y = y;
					pf->flags.bDragging = TRUE;
					pf->drag_x = x;
					pf->drag_y = y;
					result = 1;
				}
			}
		}
	}
 // unhandled mouse button transition/state
	else
	{
		int on_button = 0;
		if( BREAK_LASTBUTTON( b, pf->_b ) )
		{
			OwnCommonMouse( pc, 0 );
		}
#ifdef DETAILED_MOUSE_DEBUG
		if( g.flags.bLogDetailedMouse )
			Log( "release button drag frame on caption" );
#endif
		if( !on_button && pc->caption_buttons )
		{
			PCAPTION_BUTTON button;
			INDEX idx;
			LIST_FORALL( pc->caption_buttons, idx, PCAPTION_BUTTON, button )
			{
				if( button->flags.hidden )
					continue;
				if( x > button->offset )
				{
					on_button = TRUE;
					break;
				}
			}
			if( button )
			{
				if( !button->is_pressed )
				{
					int y = FrameCaptionYOfs( pc, pc->BorderType );
					pc->pressed_caption_button = button;
					button->is_pressed = TRUE;
					DrawFrameCaption( pc );
					UpdateDisplayPortion( pf->pActImg, pc->surface_rect.x - 1, y
												, pc->surface_rect.width + 2
												, pc->surface_rect.y - y );
				}
			}
		}
#ifdef DETAILED_MOUSE_DEBUG
		if( g.flags.bLogDetailedMouse )
			lprintf( "unhandled mouse state... see if there's a method" );
#endif
		if( pc->BorderType & BORDER_WANTMOUSE )
			InvokeResultingMethod( result, pc, _MouseMethod, (pc
													 , x - pc->surface_rect.x
													 , y - pc->surface_rect.y
													 , b ) );
	}
	//pf->_b = b;
	return result;
}
//---------------------------------------------------------------------------
PSI_PROC( void, SetFrameMousePosition )( PSI_CONTROL pfc, int x, int y )
{
	PPHYSICAL_DEVICE pf = pfc->device;
	//ValidatedControlData( PFRAME, CONTROL_FRAME, pf, pfc );
	if( !pf && pfc && pfc->parent && !pfc->device)
		SetFrameMousePosition( pfc->parent
									, x + pfc->surface_rect.x + pfc->rect.x
									, y + pfc->surface_rect.y + pfc->rect.y );
	else
	{
		if( 0 )
		{
			// know, the hotspot thing is too agressive anyway.
			SetMousePosition( pf->pActImg
								, x + pfc->surface_rect.x
								, y + pfc->surface_rect.y
								);
		}
	}
}
//---------------------------------------------------------------------------
int HandleEditStateMouse( PEDIT_STATE pEditState
								, PSI_CONTROL pfc
								, int32_t x
								, int32_t y
								, uint32_t b )
{
	PPHYSICAL_DEVICE pf = pfc->device;
	//ValidatedControlData( PFRAME, CONTROL_FRAME, pf, pfc );
	int spot;
	if( !pf )
		return 0;
	//lprintf( "handle edit mouse state at %d,%d", x, y );
	if( pEditState->flags.bActive )
	{
/*+pfc->surface_rect.x*/
		int dx = (x-(pEditState->bias[0])) - pEditState->_x
/*+pfc->surface_rect.y*/
		 , dy = (y-(pEditState->bias[1])) - pEditState->_y;
		if( pEditState->flags.bDragging )
		{
#ifdef DETAILED_MOUSE_DEBUG
			if( g.flags.bLogDetailedMouse )
				Log( "Having dragging set..." );
#endif
			if( BREAK_LASTBUTTON( b, pf->_b ) )
			{
				pEditState->flags.bDragging = 0;
 // no spot.
				spot = 0;
			}
			else
			{
#ifdef DETAILED_MOUSE_DEBUG
				if( g.flags.bLogDetailedMouse )
					Log( "Moving control.." );
#endif
				//lprintf( "moving control by %d,%d  (%d,%d)", dx, dy, x, y );
				MoveControlRel( pEditState->pCurrent
								 , dx, dy );
				spot = pEditState->flags.fLocked;
			}
		}
		else if( pEditState->flags.bSizing )
		{
			if( BREAK_LASTBUTTON( b, pf->_b ) )
			{
				pEditState->flags.bSizing = 0;
				pEditState->flags.bSizing_left = 0;
				pEditState->flags.bSizing_right = 0;
				pEditState->flags.bSizing_top = 0;
				pEditState->flags.bSizing_bottom = 0;
 // no spot selected...
				spot = 0;
			}
			else
			{
				//lprintf( "sizing control by %d,%d %d,%d %d,%d  (%d,%d)"
				//		, x, y
				//		 , pEditState->_x, pEditState->_y
				//		, dx, dy
				//		, x-pEditState->bias[0]
				//		, y-pEditState->bias[1] );
				if( pEditState->flags.bSizing_left )
				{
					if( pEditState->flags.bSizing_top )
					{
						MoveSizeControlRel( pEditState->pCurrent, dx, dy, -dx, -dy );
					}
					else if( pEditState->flags.bSizing_bottom )
					{
						//pEditState->_y = y;
						MoveSizeControlRel( pEditState->pCurrent, dx, 0, -dx, dy );
					}
					else
					{
						MoveSizeControlRel( pEditState->pCurrent, dx, 0, -dx, 0 );
					}
				}
				else if( pEditState->flags.bSizing_right )
				{
 // update prior coord to 'here'
					pEditState->_x = x;
					if( pEditState->flags.bSizing_top )
					{
						MoveSizeControlRel( pEditState->pCurrent, 0, dy, dx, -dy );
					}
					else if( pEditState->flags.bSizing_bottom )
					{
						//pEditState->_y = y;
						SizeControlRel( pEditState->pCurrent, dx, dy );
					}
					else
					{
						SizeControlRel( pEditState->pCurrent, dx, 0 );
					}
				}
				else
				{
					if( pEditState->flags.bSizing_top )
					{
						MoveSizeControlRel( pEditState->pCurrent, 0, dy, 0, -dy );
					}
					else if( pEditState->flags.bSizing_bottom )
					{
						//pEditState->_y = y;
						SizeControlRel( pEditState->pCurrent, 0, dy );
					}
				}
#ifdef HOTSPOT_DEBUG
				lprintf( "Set edit mouse to %d,%d", x, y );
#endif
				SetupHotSpots( pEditState );
				pEditState->_x = pEditState->hotspot[pEditState->flags.fLocked-1][0];
				pEditState->_y = pEditState->hotspot[pEditState->flags.fLocked-1][1];
				spot = pEditState->flags.fLocked;
			}
		}
		else
		{
			// wasn't previously dragging or sizing...
			// perhaps we should be now?
#ifdef HOTSPOT_DEBUG
			lprintf("check - current bias = %d,%d", pf->CurrentBias.x, pf->CurrentBias.y );
			lprintf("check - current bias = %d,%d", pEditState->bias[0], pEditState->bias[1] );
#endif
			spot = MouseInHotSpot( pEditState
//+pfc->surface_rect.x
										, x - (pEditState->bias[0]
												)
//+pfc->surface_rect.y
										, y - (pEditState->bias[1]
												)
										);
										//, x - pfc->surface_rect.x
										//, y - pfc->surface_rect.y );
			if( pEditState->flags.fLocked != spot )
			{
				// spot has changed.
#ifdef HOTSPOT_DEBUG
				Log( "Mark changed spots..." );
#endif
				pEditState->flags.fLocked = spot;
				DrawHotSpotsEx( pfc, pEditState, NULL DBG_SRC );
			}
			if( MAKE_FIRSTBUTTON( b, pf->_b ) )
			{
#ifdef DETAILED_MOUSE_DEBUG
				if( g.flags.bLogDetailedMouse )
					Log( "Checking edit state op based on current spot..." );
#endif
				if( pEditState->flags.bActive )
				{
					if( b & MK_RBUTTON )
					{
						if( spot && pEditState->pCurrent )
							return EditControlProperties( pEditState->pCurrent );
						else
							return EditFrameProperties( pfc
															 , x - (pfc->device?0:pfc->rect.x + pfc->surface_rect.x)
															 , y - (pfc->device?0:pfc->rect.y + pfc->surface_rect.y) );
					}
					else if( spot )
					{
#ifdef HOTSPOT_DEBUG
						lprintf( "Set edit mouse to %d,%d", x, y );
#endif
						pEditState->_x = pEditState->hotspot[pEditState->flags.fLocked-1][0];
						pEditState->_y = pEditState->hotspot[pEditState->flags.fLocked-1][1];
						//Log( "Setting spot operation..." );
						pEditState->flags.bSizing_left = 0;
						pEditState->flags.bSizing_right = 0;
						pEditState->flags.bSizing_top = 0;
						pEditState->flags.bSizing_bottom = 0;
						switch( spot )
						{
						case 1:
							pEditState->flags.bSizing_left = 1;
							pEditState->flags.bSizing_top = 1;
							pEditState->flags.bSizing = 1;
							break;
						case 2:
							pEditState->flags.bSizing_top = 1;
							pEditState->flags.bSizing = 1;
							break;
						case 3:
							pEditState->flags.bSizing_right = 1;
							pEditState->flags.bSizing_top = 1;
							pEditState->flags.bSizing = 1;
							break;
						case 4:
							pEditState->flags.bSizing_left = 1;
							pEditState->flags.bSizing = 1;
							break;
						case 5:
#ifdef DETAILED_MOUSE_DEBUG
							if( g.flags.bLogDetailedMouse )
								Log( "Setting dragging..." );
#endif
							pEditState->flags.bDragging = 1;
							break;
						case 6:
							pEditState->flags.bSizing_right = 1;
							pEditState->flags.bSizing = 1;
							break;
						case 7:
							pEditState->flags.bSizing_left = 1;
							pEditState->flags.bSizing_bottom = 1;
							pEditState->flags.bSizing = 1;
							break;
						case 8:
							pEditState->flags.bSizing_bottom = 1;
							pEditState->flags.bSizing = 1;
							break;
						case 9:
							pEditState->flags.bSizing_right = 1;
							pEditState->flags.bSizing_bottom = 1;
							pEditState->flags.bSizing = 1;
							break;
						}
					}
				}
			}
		}
		if( pEditState->flags.fLocked )
		{
			SetFrameMousePosition( pfc
										, pEditState->bias[0]
										+ pEditState->hotspot[pEditState->flags.fLocked-1][0]
										- pfc->surface_rect.x
										, pEditState->bias[1]
										+ pEditState->hotspot[pEditState->flags.fLocked-1][1]
										- pfc->surface_rect.y
										);
		}
#ifdef HOTSPOT_DEBUG
		 else
		{
			lprintf( "not locked." );
		}
#endif
	}
	else
		spot = 0;
	return spot;
}
//---------------------------------------------------------------------------
int InvokeMouseMethod( PSI_CONTROL pfc, int32_t x, int32_t y, uint32_t b )
{
	PPHYSICAL_DEVICE pf = pfc->device;
	PSI_CONTROL pCurrent;
	//ValidatedControlData( PFRAME, CONTROL_FRAME, pf, pfc );
	if( !pf )
		return 0;
#ifdef DETAILED_MOUSE_DEBUG
	if( g.flags.bLogDetailedMouse )
		lprintf( "mouse method received on %p", pfc );
#endif
	pCurrent = pf->pCurrent;
	if( !HandleEditStateMouse( &pf->EditState, pfc, x, y, b ) )
	{
		int result;
		pCurrent = pf->pCurrent;
		if( !pf->flags.bCaptured && ( pCurrent == (PSI_CONTROL)pfc ) )
		{
#ifdef DETAILED_MOUSE_DEBUG
			if( g.flags.bLogDetailedMouse )
				lprintf( "**** Calling frame's mouse... (%d,%d,%08x)", x, y, b );
#endif
			AddUse( pfc );
			result = FirstFrameMouse( pf, x, y, b, TRUE );
			DeleteUse( pfc );
			return result;
		}
		else if( pCurrent )
		{
			if( !pCurrent->flags.bDestroy && pCurrent->_MouseMethod )
			{
#ifdef DETAILED_MOUSE_DEBUG
				if( g.flags.bLogDetailedMouse )
					lprintf( "calling current, perhaps owned, mouseproc %p", pCurrent );
#endif
				AddUse( pCurrent );
				pfc->NotInUse = pfc->InUse;
				InvokeResultingMethod( result, pCurrent, _MouseMethod, (pCurrent
														 , x - pf->CurrentBias.x
														 , y - pf->CurrentBias.y
																						, b ) );
#ifdef DETAILED_MOUSE_DEBUG
				if( g.flags.bLogDetailedMouse )
					lprintf( "Result of resulting method is %d", result );
#endif
				pfc->NotInUse = 0;
				DeleteUse( pCurrent );
				return result;
			}
		}
#ifdef DETAILED_MOUSE_DEBUG
		else if( g.flags.bLogDetailedMouse )
		{
			lprintf( "No current!" );
		}
#endif
	}
	return 0;
}
//---------------------------------------------------------------------------
int IsMouseInCurrent( PSI_CONTROL pfc, int32_t x, int32_t y, uint32_t is_surface, uint32_t b )
{
	PPHYSICAL_DEVICE pf = pfc->device;
	//ValidatedControlData( PFRAME, CONTROL_FRAME, pf, pfc );
	IMAGE_POINT tolerance;
	if( !pf || !pf->pCurrent )
	{
#ifdef DETAILED_MOUSE_DEBUG
		if( g.flags.bLogDetailedMouse )
			lprintf( "no current..." );
#endif
		return FALSE;
	}
	// cannot be in a hidden control.
	if( pf->pCurrent->flags.bHidden )
		return FALSE;
	if( pf->EditState.flags.bActive &&
		(PSI_CONTROL)pf->EditState.pCurrent == (PSI_CONTROL)pf->pCurrent )
	{
		tolerance[0] = SPOT_SIZE;
		tolerance[1] = SPOT_SIZE;
	}
	else
	{
		tolerance[0] = 0;
		tolerance[1] = 0;
	}
	while( 1 )
	{
		if( pf->CurrentBias.flags.bias_is_surface )
		{
			// use tolerance to make the border wider
			if( (int64_t)x >= tolerance[0] && (int64_t)y >= tolerance[0] &&
				(int64_t)x < ( pf->pCurrent->surface_rect.width - 2*tolerance[0] ) &&
				(int64_t)y < ( pf->pCurrent->surface_rect.height - 2*tolerance[1] )  )
			{
				PSI_CONTROL pc;
#ifdef DETAILED_MOUSE_DEBUG
				if( g.flags.bLogDetailedMouse )
					lprintf( "Mouse (%d,%d) %08x is still in current control (%d,%d)-(%d,%d)... bias(%d,%d) let's see - does it have children? %p"
							, x, y, b
							, tolerance[0]
							, tolerance[0]
							, pf->pCurrent->surface_rect.width
							, pf->pCurrent->surface_rect.height
							, pf->CurrentBias.x
							, pf->CurrentBias.y
							, pf->pCurrent->child );
#endif
				//if( !pf->pCurrent->parent )
				// x, y are biased in this function to be relative to the control passed...
				pc = FindControl( pfc, pf->pCurrent->child, x, y, b );
				//else
				//	pc = FindControl( pfc, pf->pCurrent->child, x, y, b );
				if( pc )
				{
#ifdef DETAILED_MOUSE_DEBUG
					if( g.flags.bLogDetailedMouse )
						lprintf( "Found a control %p", pc );
#endif
				}
#ifdef DETAILED_MOUSE_DEBUG
				else
				{
					if( g.flags.bLogDetailedMouse )
						lprintf( "no sub-control found..." );
				}
#endif
			}
			else
			{
				// still is surface... now check against the suface without the tolerance...
				if( (int64_t)x < 0 || (int64_t)y < 0 || (int64_t)x > pf->pCurrent->surface_rect.width || (int64_t)y > pf->pCurrent->surface_rect.height )
				{
					// okay the mouse has moved outside the surface... re-set the current bias
					// and try this whole thing again.
					pf->CurrentBias.flags.bias_is_surface = 0;
					pf->CurrentBias.x -= pf->pCurrent->surface_rect.x;
					pf->CurrentBias.y -= pf->pCurrent->surface_rect.y;
					x += pf->pCurrent->surface_rect.x;
					y += pf->pCurrent->surface_rect.y;
					continue;
				}
				// otherwise it's still in the surface, and all is well...
			}
			// still within the surface of the control...
			return TRUE;
		}
		else
		{
			if( (int64_t)x < pf->pCurrent->surface_rect.x ||
				(int64_t)y < pf->pCurrent->surface_rect.y ||
				(int64_t)x > pf->pCurrent->surface_rect.width + pf->pCurrent->surface_rect.x ||
				(int64_t)y > pf->pCurrent->surface_rect.height + pf->pCurrent->surface_rect.y )
			{
				// still in control ( full tolerance is based on full rect.)
				if( (int64_t)x >= -tolerance[0] && (int64_t)y >= -tolerance[0] &&
					(int64_t)x < ( pf->pCurrent->rect.width + 2*tolerance[0] ) &&
					(int64_t)y < ( pf->pCurrent->rect.height + 2*tolerance[1] )  )
				{
#ifdef DETAILED_MOUSE_DEBUG
					if( g.flags.bLogDetailedMouse )
						lprintf( "Outside of control bounds... not in current." );
#endif
					if( pf->common->BorderType & BORDER_RESIZABLE )
						return FALSE;
					return TRUE;
				}
 // return FALSE.  the mouse has fallen well outside of tolerant distance.
				break;
			}
			else
			{
				// mouse is now within the surface...
				pf->CurrentBias.flags.bias_is_surface = 1;
				pf->CurrentBias.x += pf->pCurrent->surface_rect.x;
				pf->CurrentBias.y += pf->pCurrent->surface_rect.y;
				x -= pf->pCurrent->surface_rect.x;
				y -= pf->pCurrent->surface_rect.y;
				continue;
				// otherwise we've fallen off of this control (outside surface, beyond window)
			}
		}
	}
	// not in the surface rect anymore...
	return FALSE;
}
//---------------------------------------------------------------------------
// this is called directly from the renderer layer...
// therefore x, y are relative to the upper left corner of the
// renderer which a frame is attached.  THe psv passed is the frame
// which this refers to.
// First, if it's not focused, ignore the mouse ( mouse would have
// been locked to another? )
// Then, If no buttons are pressed, then any prior control which
// may have been the current owner of the mouse is no longer.
// Such a control does not receive notification of the de-press. (until later)
// Then, if there's still a control which has posession of the
// logical mouse, then its method is then called with the current state.
// Calls to a control are relative to its surface.  It should never be
// drawing within the frame itself... that is actually not part of
// its property.
// Then - find a control.
//	Act of finding a control shall
//---------------------------------------------------------------------------
uintptr_t CPROC AltFrameMouse( uintptr_t psvCommon, int32_t x, int32_t y, uint32_t b )
{
	PPHYSICAL_DEVICE pf = (PPHYSICAL_DEVICE)psvCommon;
	//PFRAME pf = (PFRAME)psvCommon;
	int result = 0;
	PSI_CONTROL pc = pf->common;
	PSI_CONTROL pcIn;
	extern void DumpFrameContents( PSI_CONTROL );
	if( !pc )
	{
		// maybe this was closed before it actually got the first message?
		return 0;
	}
#ifdef USE_IMAGE_INTERFACE
	if( !USE_IMAGE_INTERFACE )
	{
		// are we shutting down? did we fail to start?
		// somehow we have render events without an image.
		return 0;
	}
#endif
	if( pc->flags.bDestroy )
	{
		// somehow we're being destroyed, but not everyone knows yet
		return 0;
	}
	GetCurrentDisplaySurface(pf);
	//DumpFrameContents( pc );
#ifdef DETAILED_MOUSE_DEBUG
	if( g.flags.bLogDetailedMouse )
	{
		lprintf( "-------------------------------------------------" );
		lprintf( "Mouse event: (%d,%d) %08x bias is(%d,%d) %s"
				, x, y, b
				, pf->CurrentBias.x, pf->CurrentBias.y
				, pf->CurrentBias.flags.bias_is_surface?"surface":"frame"
				);
	}
#endif
	AddUse( (PSI_CONTROL)pc );
	{
		int caption_height = CaptionHeight( pc, GetText( pc->caption.text ) );
		int frame_height = FrameBorderYOfs( pc, pc->BorderType, NULL );
		UpdateCursor( pc, x, y, caption_height, frame_height );
	}
	if( pf->flags.bCaptured )
	{
#ifdef DETAILED_MOUSE_DEBUG
		if( g.flags.bLogDetailedMouse )
			lprintf( "Caputred mouse dispatch!" );
#endif
		if( !pc->flags.bDestroy )
		{
			result = InvokeMouseMethod( pc, x, y, b );
		}
		pf->_b = b;
		DeleteUse( pc );
		return result;
	}
	if( pf->flags.bCurrentOwns )
	{
#ifdef DETAILED_MOUSE_DEBUG
		if( g.flags.bLogDetailedMouse )
			lprintf( "Current owns flag is set?" );
#endif
		result = InvokeMouseMethod( pc, x, y, b );
		if( pf = pc->device )
		{
			if( pf->flags.bApplicationOwned && BREAK_LASTBUTTON( b, pf->_b ) )
			{
#ifdef DETAILED_MOUSE_DEBUG
				if( g.flags.bLogDetailedMouse )
					lprintf( "Well current no longer owns mouse.." );
#endif
				 OwnCommonMouse( pc, FALSE );
			}
			else
			{
#ifdef DETAILED_MOUSE_DEBUG
				if( g.flags.bLogDetailedMouse )
					lprintf( "Returning early... still owned..." );
#endif
			}
			pf->_b = b;
		}
		// no longer owned, but event was already dispatched.
		DeleteUse( pc );
		return result;
	}
	if( g.flags.bLogDetailedMouse )
		lprintf( "to test %d,%d  %d,%d", x, y, pf->CurrentBias.x, pf->CurrentBias.y );
	if( !pf->flags.bSizing
		&& !pf->flags.bDragging
		&& !pc->pressed_caption_button
		&& IsMouseInCurrent( pc
							 , x - pf->CurrentBias.x
							 , y - pf->CurrentBias.y
							 , pf->CurrentBias.flags.bias_is_surface
							 , b ) )
	{
#ifdef DETAILED_MOUSE_DEBUG
		if( g.flags.bLogDetailedMouse )
			lprintf( "Mouse is still in current (%d,%d)"
					, x - pf->CurrentBias.x
					, y - pf->CurrentBias.y );
#endif
		// although this should be part of InvokeMouseMethod
		// InvokeMethod doesn't have the pf to compare first button.
		if( MAKE_FIRSTBUTTON( b, pf->_b ) )
		{
#ifdef DETAILED_MOUSE_DEBUG
			if( g.flags.bLogDetailedMouse )
			{
				lprintf( "First left down %p (%d,%d) %08x", pf->pCurrent, x, y , b );
				lprintf( "Setting current owns..." );
			}
#endif
			OwnCommonMouse( pf->pCurrent, TRUE );
			//pf->flags.bCurrentOwns = TRUE;
			SetCommonFocus( pf->pCurrent );
		}
	retry1:
		// mouseincurrent invokes mouse...
		if( pf->pCurrent
			&& !( result = InvokeMouseMethod( pc, x, y, b ) )
			&& !pc->flags.bDestroy
			&& pc->device )
		{
#ifdef DETAILED_MOUSE_DEBUG
			if( g.flags.bLogDetailedMouse )
				lprintf( "!! Mouse was not used by control - try and find it's parent." );
#endif
			if( pf->CurrentBias.flags.bias_is_surface )
			{
				pf->CurrentBias.x -= pf->pCurrent->surface_rect.x;
				pf->CurrentBias.y -= pf->pCurrent->surface_rect.y;
			}
			pf->CurrentBias.x -= pf->pCurrent->rect.x;
			pf->CurrentBias.y -= pf->pCurrent->rect.y;
			pf->CurrentBias.flags.bias_is_surface = 1;
			//pf->pCurrent = pf->pCurrent->parent;
			InvokeRollover( pf, pf->pCurrent->parent );
			goto retry1;
		}
	}
	else
	{
#ifdef DETAILED_MOUSE_DEBUG
		if( g.flags.bLogDetailedMouse )
			lprintf( "Mouse is no longer in current (%d,%d) Setting new current control..."
					, x - pf->CurrentBias.x
					, y - pf->CurrentBias.y );
#endif
		//pf->pCurrent = pc;
		InvokeRollover( pf, pc );
		if( (int64_t)x < pc->surface_rect.x ||
			(int64_t)y < pc->surface_rect.y ||
			(int64_t)x > pc->surface_rect.x + pc->surface_rect.width ||
			(int64_t)y > pc->surface_rect.y + pc->surface_rect.height ||
			pf->flags.bSizing || pf->flags.bDragging || pc->pressed_caption_button )
		{
			// it's on the frame of this frame (redunant eh?)
			//lprintf( "Outside the surface, on border or frame... invoke frame handler." );
			result = FirstFrameMouse( pf, x, y, b, TRUE );
			pf->CurrentBias.x = 0;
			pf->CurrentBias.y = 0;
			pf->CurrentBias.flags.bias_is_surface = 0;
		}
		else
		{
#ifdef DETAILED_MOUSE_DEBUG
			if( g.flags.bLogDetailedMouse )
				lprintf( "Mouse on surface of frame, find a control." );
#endif
			pf->CurrentBias.x = pc->surface_rect.x;
			pf->CurrentBias.y = pc->surface_rect.y;
			pf->CurrentBias.flags.bias_is_surface = 1;
			pcIn = FindControl( pc, pc->child
									, x - pf->CurrentBias.x
									, y - pf->CurrentBias.y, b );
#ifdef DETAILED_MOUSE_DEBUG
			if( g.flags.bLogDetailedMouse )
				lprintf( "Found control %p %p in %p with bias %d,%d", pcIn, pcIn?pcIn->parent:NULL, pc
						, pf->CurrentBias.x, pf->CurrentBias.y );
#endif
			//ComputeFrameBias( pf, pcIn );
			if( pcIn )
			{
				// although this should be part of InvokeMouseMethod
				// InvokeMethod doesn't have the pf to compare first button.
				if( MAKE_FIRSTBUTTON( b, pf->_b ) )
				{
#ifdef DETAILED_MOUSE_DEBUG
					if( g.flags.bLogDetailedMouse )
						lprintf( "Setting current owns..." );
#endif
					OwnCommonMouse( pc, TRUE );
					//pf->flags.bCurrentOwns = TRUE;
					SetCommonFocus( pf->pCurrent );
				}
			retry:
				if( pf->pCurrent && !( result = InvokeMouseMethod( pc, x, y, b ) ) )
				{
#ifdef DETAILED_MOUSE_DEBUG
					if( g.flags.bLogDetailedMouse )
						lprintf( "!! Again - did not want the mouse... go back to parent." );
#endif
					if( pf->CurrentBias.flags.bias_is_surface )
					{
#ifdef DETAILED_MOUSE_DEBUG
						if( g.flags.bLogDetailedMouse )
							lprintf( "was on surface... so remove that." );
#endif
						if( pf->pCurrent )
						{
							pf->CurrentBias.x -= pf->pCurrent->surface_rect.x;
							pf->CurrentBias.y -= pf->pCurrent->surface_rect.y;
						}
					}
#ifdef DETAILED_MOUSE_DEBUG
					if( g.flags.bLogDetailedMouse )
						lprintf( "was on a control remove (%d,%d)", pf->pCurrent->rect.x, pf->pCurrent->rect.y );
#endif
					if( pf->pCurrent )
					{
						pf->CurrentBias.x -= pf->pCurrent->rect.x;
						pf->CurrentBias.y -= pf->pCurrent->rect.y;
						pf->CurrentBias.flags.bias_is_surface = 1;
						//pf->pCurrent = pf->pCurrent->parent;
						InvokeRollover( pf, pf->pCurrent->parent );
					}
					goto retry;
				}
				// else coordinates to a frame proc are raw ... at least the first level one
				// which handles resize and drag, then to the actual surface.
#ifdef DETAILED_MOUSE_DEBUG
				if( g.flags.bLogDetailedMouse )
					lprintf( "Resulting bias to (%d,%d) %s"
							, pf->CurrentBias.x, pf->CurrentBias.y
							, pf->CurrentBias.flags.bias_is_surface?"surface":"frame"
							);
#endif
			 }
			else
			{
#ifdef DETAILED_MOUSE_DEBUG
				if( g.flags.bLogDetailedMouse )
					lprintf( "no control found... see if there's a method...." );
#endif
				// although this should be part of InvokeMouseMethod
				// InvokeMethod doesn't have the pf to compare first button.
				if( MAKE_FIRSTBUTTON( b, pf->_b ) )
				{
#ifdef DETAILED_MOUSE_DEBUG
					if( g.flags.bLogDetailedMouse )
						lprintf( "Setting current owns..." );
#endif
					OwnCommonMouse( pc, TRUE );
					//pf->flags.bCurrentOwns = TRUE;
					SetCommonFocus( pf->pCurrent );
				}
			retry3:
				if( pf->pCurrent && !( result = InvokeMouseMethod( pc, x, y, b ) ) )
				{
#ifdef DETAILED_MOUSE_DEBUG
					if( g.flags.bLogDetailedMouse )
						lprintf( "!! Again - did not want the mouse... go back to parent." );
#endif
					if( pf->CurrentBias.flags.bias_is_surface )
					{
						pf->CurrentBias.x -= pf->pCurrent->surface_rect.x;
						pf->CurrentBias.y -= pf->pCurrent->surface_rect.y;
					}
					pf->CurrentBias.x -= pf->pCurrent->rect.x;
					pf->CurrentBias.y -= pf->pCurrent->rect.y;
					//pf->pCurrent = pf->pCurrent->parent;
					InvokeRollover( pf, pf->pCurrent->parent );
					goto retry3;
				}
				if( pc->BorderType & BORDER_WANTMOUSE )
				{
					result = InvokeMouseMethod( pc, x, y, b );
					pf = pc->device;
				}
			}
		}
	}
	if( pf && pc->device )
		 pf->_b = b;
	//lprintf("releasing %p", pc );
	DeleteUse( pc );
	return result;
}
//---------------------------------------------------------------------------
static int OnMouseCommon( "Frame" )( PSI_CONTROL pc, int32_t x, int32_t y, uint32_t b )
{
	// okay really frame mouse proc is JUST like every other
	// control proc- mouse coordinates are relative to the surface.
	PSI_CONTROL frame = GetFrame( pc );
	PPHYSICAL_DEVICE pf = frame?frame->device:NULL;
	if( !pf )
 //probably destroyed or something...
		return FALSE;
	//ValidatedControlData( PFRAME, CONTROL_FRAME, pf, pc );
	// if frame is marked NOMOVE, don't drag it...
	if( !( pc->BorderType & BORDER_NOMOVE ) )
	{
		if( ( b & MK_LBUTTON ) &&
			!( pf->_b & MK_LBUTTON ) )
		{
#ifdef SUPER_DETAILED_MOUSE_DEBUG
			if( g.flags.bLogSuperDetailedMouse )
				lprintf( "Default frame mouse recieved mouse biased to surface: %d,%d", x, y );
#endif
			pf->_x = x + pf->CurrentBias.x;
			pf->_y = y + pf->CurrentBias.y;
#ifdef DETAILED_MOUSE_DEBUG
			if( g.flags.bLogDetailedMouse )
				lprintf( "Setting drag at %d,%d + (%d,%d)==(%d,%d)?"
						, pf->_x
						, pf->_y
						, pc->surface_rect.x
						, pc->surface_rect.y
						, pf->CurrentBias.x, pf->CurrentBias.y );
#endif
			pf->flags.bDragging = TRUE;
			pf->drag_x = x + pf->CurrentBias.x;
			pf->drag_y = y + pf->CurrentBias.y;
		}
	}
	return TRUE;
}
//---------------------------------------------------------------------------
void CaptureCommonMouse( PSI_CONTROL pc, LOGICAL bCapture )
{
	PSI_CONTROL pf = GetFrame( pc );
	PPHYSICAL_DEVICE pd = pf?pf->device:NULL;
	if( pd )
	{
		PSI_CONTROL _pc;
		pd->flags.bCaptured = bCapture;
		//pd->pCurrent = pc;
		InvokeRollover( pd, pc );
		pd->CurrentBias.x = 0;
		pd->CurrentBias.y = 0;
		for( _pc = pc; _pc; _pc = _pc->parent )
		{
			pd->CurrentBias.x += _pc->surface_rect.x;
			pd->CurrentBias.y += _pc->surface_rect.y;
			if( _pc->parent )
			{
				pd->CurrentBias.x += _pc->rect.x;
				pd->CurrentBias.y += _pc->rect.y;
			}
		}
		OwnMouse( pd->pActImg, bCapture );
	}
}
void GetMouseButtons( PSI_CONTROL pc, uint32_t *buttons )
{
	if( buttons )
	{
		PSI_CONTROL frame = GetFrame( pc );
		PPHYSICAL_DEVICE pf = frame?frame->device:NULL;
		(*buttons) = pf->_b;
	}
}
PSI_MOUSE_NAMESPACE_END
 // for interfaces
//#include "controlstruc.h"
/* A header for doing .NET /CLR compatiblity changes. Things
   like fopen needing to be _fopen_s and junk.               */
#ifndef FILE_DOT_NET_COMPAT
/* Header multiple inclusion protection symbol. */
#define FILE_DOT_NET_COMPAT
#ifdef __cplusplus_cli
#define Fopen( result, name, opts ) { char *tmp1 = CStrDup( name ); char *tmp2 = CStrDup( opts ); result = fopen( tmp1, tmp2 ); Deallocate( char *, tmp1 ); Deallocate( char *, tmp2 ); }
#if asdfasdlfkajsdflkj
#define fputs( msg, file ) { char *tmp = CStrDup( msg ); fputs( tmp, file ); Release( tmp ); }
#define unlink( name ) { char *tmp = CStrDup( name ); unlink( tmp ); Release( tmp ); }
#define rename( name1, name2 ) { char *tmp1 = CStrDup( name1 ); char *tmp2 = CStrDup( name2 ); rename( tmp1, tmp2 ); Release( tmp1 ); Release( tmp2 ); }
#define fprintf Fprintf
#endif
//int Fprintf( FILE *file, CTEXTSTR fmt, ... );
/*
using namespace Win32;
#define CreateEvent(a,b,c,d) Win32::Kernel::CreateEvent((SECURITY_ATTRIBUTES)a,b,c,d)
#define OpenEvent(a,b,c)     Win32::Kernel::OpenEvent(a,b,c)
#define Sleep(a)             Win32::Kernel::Sleep(a)
#define GetTickCount()       Win32::Kernel::GetTickCount()
#define GetCurrentProcessId() Win32::Kernel::GetCurrentProcessId()
#define GetCurrentThreadId()  Win32::Kernel::GetCurrentThreadId()
#define GetLastError()  Win32::Kernel::GetLastError()
#define SetEvent(a) Win32::Kernel::SetEvent(a)
#define ResetEvent(a) Win32::Kernel::ResetEvent(a)
#define CloseHandle(a) Win32::Kernel::CloseHandle(a)
#define WaitForSingleObject(a,b) Win32::Kernel::WaitForSingleObject(a,b)
#define PeekMessage(a,b,c,d,e)  Win32::User::PeekMessage(a,b,c,d,e)
#define DispatchMessage(a)   Win32::User::DispatchMessage(a)
#define GetModuleFileName(a,b) Win32::Kernel::GetModuleFileName(a,b)
*/
#if 0
typedef struct MyFile MYFILE;
MYFILE *Fopen( CTEXTSTR filename, CTEXTSTR mode );
int Fread( POINTER data, int count, int size, MYFILE *file );
int Fwrite( POINTER data, int count, int size, MYFILE *file );
int Fclose( MYFILE *file );
int Fseek( MYFILE *file, int64_t pos, int whence );
uint64_t Ftell( MYFILE *file );
MYFILE *Fdopen( int fd, CTEXTSTR mode );
int Ferror( MYFILE *file );
int Fflush( MYFILE *file );
int Rewind( MYFILE *file );
int Fputc( int c, MYFILE *file );
int Fgets( TEXTSTR buf, int buflen, MYFILE *file );
int Fputs( CTEXTSTR but, MYFILE *file );
int Unlink( CTEXTSTR filename );
int Rename( CTEXTSTR from, CTEXTSTR to );
#define rename Rename
#define unlink Unlink
#define FILE MYFILE
#define fopen Fopen
#define fseek Fseek
#define fclose Fclose
#define fprintf Fprintf
#define ftell Ftell
#define fread Fread
#define fwrite Fwrite
//#define fdopen Fdopen
#define ferror Ferror
#define fflush Fflush
#define rewind Rewind
#define fputc Fputc
#define fgets Fgets
#define fputs Fputs
#endif
#else
/* A macro which can be translated into microsoft so-called safe
   methods.                                                      */
#define Fopen( result, name, opts ) result = sack_fopen( 0, name, opts )
//#define MYFILE  FILE
//#define Fopen   fopen
//#define Fread   fread
//#define Fwrite  fread
//#define Fclose  fclose
//#define Fprintf fprintf
//#define Fseek   fseek
//#define Ftell   ftell
#endif
#endif
// end with a newline please.
#ifndef FIRST_SYMBOL_VALUE
#define FIRST_SYMBOL_VALUE 1
#endif
#ifndef BUILD_NAMES
#  if !defined( NAME_ENUMERATION_DECLARED )
#    define FIRST_SYMNAME(name,control_type_name)    FIRST_SYMBOL = FIRST_SYMBOL_VALUE, name = FIRST_SYMBOL_VALUE
#    define SYMNAME(name,control_type_name)        , name
#    define SYMNAME_SKIP(prior, range, name,control_type_name)        , prior, name = prior+range
enum resource_enum {
#  endif
#endif
#if !defined( NAME_ENUMERATION_DECLARED ) || defined( BUILD_NAMES )
#undef BTN_OKAY
#undef BTN_CANCEL
FIRST_SYMNAME( BTN_OKAY, NORMAL_BUTTON_NAME )
SYMNAME(BTN_CANCEL,NORMAL_BUTTON_NAME)
SYMNAME( BTN_ABORT, NORMAL_BUTTON_NAME )
SYMNAME( EDT_X     , EDIT_FIELD_NAME )
SYMNAME( EDT_Y     , EDIT_FIELD_NAME )
SYMNAME( EDT_WIDTH , EDIT_FIELD_NAME )
SYMNAME( EDT_HEIGHT, EDIT_FIELD_NAME )
SYMNAME( EDT_CAPTION, EDIT_FIELD_NAME)
SYMNAME( EDT_ID     , EDIT_FIELD_NAME)
SYMNAME( EDT_IDNAME , EDIT_FIELD_NAME)
SYMNAME( LABEL_X    , STATIC_TEXT_NAME )
SYMNAME( LABEL_Y    , STATIC_TEXT_NAME)
SYMNAME( LABEL_WIDTH  , STATIC_TEXT_NAME)
SYMNAME( LABEL_HEIGHT , STATIC_TEXT_NAME)
SYMNAME( LABEL_CAPTION, STATIC_TEXT_NAME)
SYMNAME( LABEL_ID     , STATIC_TEXT_NAME)
SYMNAME( LISTBOX_IDS , LISTBOX_CONTROL_NAME  )
SYMNAME( SLD_GREENBAR    , SLIDER_CONTROL_NAME )
SYMNAME( PAL_COLORS      , "Color Matrix" )
 // define a preset
SYMNAME( BTN_PRESET      , NORMAL_BUTTON_NAME )
SYMNAME( CHK_ALPHA       , RADIO_BUTTON_NAME  )
SYMNAME( CST_SHADE       , "Shade Well" )
SYMNAME( CST_ZOOM        , "Shade Well" )
SYMNAME( CST_SHADE_RED   , "Shade Well" )
SYMNAME( CST_SHADE_BLUE  , "Shade Well" )
SYMNAME( CST_SHADE_GREEN , "Shade Well" )
		SYMNAME_SKIP( BTN_PRESET_BASE, 64, BTN_PRESET_LAST, CUSTOM_BUTTON_NAME )
#endif
#ifndef BUILD_NAMES
#  if !defined( NAME_ENUMERATION_DECLARED )
#  define NAME_ENUMERATION_DECLARED
};
#  endif
#endif
#undef SYMNAME
#undef FIRST_SYMNAME
#undef SYMNAME_SKIP
#undef BUILD_NAMES
PSI_COLORWELL_NAMESPACE
typedef struct colorwell {
	struct {
		uint32_t bPickColor : 1;
		uint32_t bPicking : 1;
	} flags;
	CDATA color;
	void(CPROC*UpdateProc)(uintptr_t,CDATA);
	uintptr_t psvUpdate;
} COLOR_WELL, *PCOLOR_WELL;
enum {
	SHADER_LIGTDARK
	  , SHADER_RED
	  , SHADER_BLUE
	  , SHADER_GREEN
};
typedef struct shadewell {
	//int nShaderType;
	CDATA color_min;
	CDATA color_mid;
	CDATA color_max;
} SHADE_WELL, *PSHADE_WELL;
extern CONTROL_REGISTRATION shade_well, color_well;
typedef struct PickColor_tag
{
	PSI_CONTROL frame;
	struct {
		BIT_FIELD bSettingShade : 1;
		BIT_FIELD bMatrixChanged : 1;
	} flags;
 // level of green...
	int nGreen;
	 // level of alpha...
	int Alpha;
	CDATA CurrentColor;
	CDATA Presets[36];
	PSI_CONTROL LastPreset;
	PSI_CONTROL pcZoom;
 // shade well data...
	PSI_CONTROL psw, pShadeRed, pShadeBlue, pShadeGreen;
	int bSetPreset;
	int ColorDialogDone, ColorDialogOkay;
 // fixed size image in local memory that is block copied for output.
	Image pColorMatrix;
} PICK_COLOR_DATA, *PPICK_COLOR_DATA;
void CPROC InitColorDataDefault( POINTER );
void SetShaderControls( PPICK_COLOR_DATA ppcd, PSI_CONTROL source );
PUBLIC_DATA( "Color Choice Data", PICK_COLOR_DATA, InitColorDataDefault, NULL );
#define nScale 4
#define xbias 1
#define ybias 1
#define xsize 133
#define ysize 133
#define COLOR Color( (255-red)*nScale, (255-green)*nScale, (blue)*nScale )
//----------------------------------------------------------------------------
static void UpdateImage( Image pImage, int nGreen )
{
	int red, blue, green=0;
	if( !pImage )
		return;
	ClearImageTo( pImage, Color( 0, 0, 0 ) );
	for( green = 0; green < nGreen/nScale; green++ )
	{
		blue = 0;
		for( red = 0; red < 256/nScale; red++ )
		{
			plot( pImage, xbias+red + blue+(blue&1), ybias+(green + 128/nScale) - red/2 + blue/2 , COLOR );
		}
		red = 255/nScale;
		for( blue = 0; blue < 256/nScale; blue++ )
		{
			plot( pImage, xbias+red+(red&1) + blue, ybias+(green + 128/nScale) - red/2 + blue/2 , COLOR );
		}
	}
	for( blue = 0; blue <= 255/nScale; blue++ )
	{
		for( red = 0; red <= 255/nScale; red++ )
		{
			plot( pImage, xbias+red + blue+(blue&1), ybias+(green + 128/nScale) - red/2 + blue/2 , COLOR );
		}
	}
	for( ; green <= 255/nScale; green++ )
	{
		blue = 255/nScale;
		for( red = 0; red <= 255/nScale; red++ )
		{
			plot( pImage, xbias+red + blue+(blue&1), ybias+(green + 128/nScale) - red/2 + blue/2 , COLOR );
		}
		red = 0;
		for( blue = 0; blue < 256/nScale; blue++ )
		{
			plot( pImage, xbias+red + blue, ybias+(green + 128/nScale) - red/2 + blue/2 , COLOR );
		}
	}
}
//----------------------------------------------------------------------------
static CDATA ScaleColor( CDATA original, CDATA new_color, int max, int cur )
{
	int orig_r = RedVal( original );
	int orig_g = GreenVal( original );
	int orig_b = BlueVal( original );
	int nr = RedVal( new_color );
	int ng = GreenVal( new_color );
	int nb = BlueVal( new_color );
	orig_r *= max-cur;
	orig_r /= max;
	orig_g *= max-cur;
	orig_g /= max;
	orig_b *= max-cur;
	orig_b /= max;
	nr *= cur;
	nr /= max;
	ng *= cur;
	ng /= max;
	nb *= cur;
	nb /= max;
	orig_r += nr;
	if( orig_r > 255 ) orig_r = 255;
	orig_g += ng;
	if( orig_g > 255 ) orig_g = 255;
	orig_b += nb;
	if( orig_b > 255 ) orig_b = 255;
	return Color( orig_r, orig_g, orig_b );
}
//----------------------------------------------------------------------------
static int OnDrawCommon("Shade Well") ( PSI_CONTROL pcShade )
{
	ValidatedControlData( PSHADE_WELL, shade_well.TypeID, psw, pcShade );
	uint32_t black;
	uint32_t width;
	uint32_t height;
	Image pSurface;
	if( psw )
	{
		pSurface = GetControlSurface( pcShade );
		width = pSurface->width;
		height = pSurface->height;
		//lprintf( "----------- DRAW SHADE CONTORL ------------------- %08x %08x %08x"
		//		 , psw->color_min
		//		 , psw->color_mid
		//		 , psw->color_max );
		for( black = 0; black < height/2; black++ )
		{
			BlatColor( pSurface, 0, black, width-1, 1, ScaleColor( psw->color_min, psw->color_mid, height/2, black ) );
			//do_hline( pSurface, black, 0, width-1, ScaleColor( psw->color_min, psw->color_mid, height/2, black ) );
		}
		for( black = height/2; black < height; black++ )
		{
			BlatColor( pSurface, 0, black, width-1, 1, ScaleColor( psw->color_mid, psw->color_max, height/2, black - height/2 ) );
			//do_hline( pSurface, black, 0, width-1, ScaleColor( psw->color_mid, psw->color_max, height/2, black - height/2 ) );
		}
		return TRUE;
	}
	return FALSE;
}
//----------------------------------------------------------------------------
#define PPCD(pc) (PPICK_COLOR_DATA)GetControlUserData( GetFrame( pc ) )
//----------------------------------------------------------------------------
static int OnMouseCommon( "Color Matrix" )( PSI_CONTROL pc, int32_t x, int32_t y, uint32_t buttons )
{
	PPICK_COLOR_DATA ppcd = PPCD(pc);
	if( buttons == -1 )
		return FALSE;
	if( buttons & MK_LBUTTON )
	{
		if( ppcd->psw )
		{
			//lprintf( "Setting new mid color... update... ------------------------- " );
			ppcd->CurrentColor = SetAlpha( getpixel( ppcd->pColorMatrix, x, y )
												  , ppcd->Alpha );
			SetShaderControls( ppcd, pc );
			//SetColorWell( ppcd->pcZoom, c );
		}
	}
	return TRUE;
}
//----------------------------------------------------------------------------
int CPROC DrawPalette( PSI_CONTROL pc )
{
	PPICK_COLOR_DATA ppcd = PPCD(pc);
	if( ppcd )
	{
		if( ppcd->flags.bMatrixChanged )
		{
// = GetControlSurface( pc );
			Image Surface
				= ppcd->pColorMatrix;
			UpdateImage( Surface, ppcd->nGreen );
			ppcd->flags.bMatrixChanged = 0;
		}
		BlotImage( GetControlSurface( pc ), ppcd->pColorMatrix, 0, 0 );
		if( GetCheckState( GetControl( ppcd->frame, CHK_ALPHA) ) )
		{
			Image Surface = GetControlSurface( pc );
			ppcd->CurrentColor = SetAlpha( ppcd->CurrentColor, ppcd->Alpha );
			BlatColorAlpha( Surface, 0, 0
							  , Surface->width
							  , Surface->height
							  , ppcd->CurrentColor );
		}
	}
	return TRUE;
}
//----------------------------------------------------------------------------
SLIDER_UPDATE( SetGreenLevel, (uintptr_t psv, PSI_CONTROL pc, int val) )
{
	//PPALETTE_CONTROL
	CDATA c;
	PPICK_COLOR_DATA ppcd  = PPCD(pc);
	if( GetCheckState( GetControl( ppcd->frame, CHK_ALPHA ) ) )
	{
		c = SetAlpha( ppcd->CurrentColor, val );
		ppcd->Alpha = val;
	}
	else
	{
		//c = SetGreen( ppcd->CurrentColor, val );
		ppcd->nGreen = val;
	}
	ppcd->flags.bMatrixChanged = 1;
	SmudgeCommon( GetControl( ppcd->frame, PAL_COLORS ) );
}
//----------------------------------------------------------------------------
static void LoadPresets( PPICK_COLOR_DATA ppcd )
{
	FILE *file;
	file = sack_fopen( 0, "Palette.Presets", "rt" );
	if( file )
	{
		int i;
		TEXTCHAR buf[64];
		for( i = 0; i < 36 && sack_fgets( buf, 64, file ); i++ )
		{
			int red, green, blue, alpha;
			if( tscanf( buf, "%d,%d,%d,%d\n", &red, &green, &blue, &alpha ) == 4 )
			{
				ppcd->Presets[i] = AColor( red, green, blue, alpha );
			}
			else
			{
				ppcd->Presets[i] = 0;
			}
		}
		sack_fclose( file );
	}
	else
	{
		int i;
		for( i = 0; i < 36; i++ )
		{
			ppcd->Presets[i] = 0;
		}
	}
}
//----------------------------------------------------------------------------
static void SavePresets( PPICK_COLOR_DATA ppcd )
{
	FILE *file;
	file = sack_fopen( 0, "Palette.Presets", "wt" );
	if( file )
	{
		int i;
		for( i = 0; i < 36; i++ )
		{
			int red = RedVal( ppcd->Presets[i] )
			  , green = GreenVal( ppcd->Presets[i] )
			  , blue = BlueVal( ppcd->Presets[i] )
			  , alpha = AlphaVal( ppcd->Presets[i] );
			sack_fprintf( file, "%d,%d,%d,%d\n", red, green, blue, alpha );
		}
		sack_fclose( file );
	}
}
//----------------------------------------------------------------------------
BUTTON_CLICK( PresetButton, ( uintptr_t psv, PSI_CONTROL pc ))
{
	// button was pressed...
	PPICK_COLOR_DATA ppcd = (PPICK_COLOR_DATA)psv;
	int idx = GetControlID(pc) - BTN_PRESET_BASE;
	if( ppcd->LastPreset )
		PressButton( ppcd->LastPreset, FALSE );
	if( ppcd->bSetPreset )
	{
		ppcd->Presets[idx] = ppcd->CurrentColor;
		ppcd->bSetPreset = FALSE;
		SavePresets( ppcd );
	}
	PressButton( pc, TRUE );
	ppcd->CurrentColor = ppcd->Presets[GetControlID(pc) - BTN_PRESET_BASE ];
	ppcd->Alpha = AlphaVal( ppcd->CurrentColor );
	// green level is backwards :(
	ppcd->flags.bSettingShade = 1;
	if( GetCheckState( GetControl( ppcd->frame, CHK_ALPHA ) ) )
		SetSliderValues( GetControl( ppcd->frame, SLD_GREENBAR ), 0, ppcd->Alpha, 255 );
	else
		SetSliderValues( GetControl( ppcd->frame, SLD_GREENBAR ), 0, 255-GreenVal(ppcd->CurrentColor ), 255 );
	SetShaderControls( ppcd, NULL );
	ppcd->flags.bSettingShade = 0;
	SmudgeCommon( GetControl( ppcd->frame, CST_ZOOM ) );
	ppcd->LastPreset = pc;
}
//----------------------------------------------------------------------------
BUTTON_DRAW( PresetDraw, ( uintptr_t psv, PSI_CONTROL pc ) )
{
	PPICK_COLOR_DATA ppcd = PPCD(pc);
	if( ppcd )
	{
		CDATA color = ppcd->Presets[GetControlID( pc ) - BTN_PRESET_BASE ];
		Image pSurface = GetControlSurface( pc );
		if( !AlphaVal( color ) )
			color = AColor( 0, 0, 0, 1 );
		ClearImageTo( pSurface, color );
	}
}
//----------------------------------------------------------------------------
BUTTON_CLICK( DefinePreset, ( uintptr_t unused, PSI_CONTROL pc ) )
{
	PPICK_COLOR_DATA ppcd = (PPICK_COLOR_DATA)unused;
	// put up a message box...
	ppcd->bSetPreset = TRUE;
}
//----------------------------------------------------------------------------
BUTTON_CHECK( AlphaPressed, ( uintptr_t unused, PSI_CONTROL pc ) )
{
	PPICK_COLOR_DATA ppcd = (PPICK_COLOR_DATA)unused;
	if( GetCheckState( pc ) )
	{
		SetSliderValues( GetControl( ppcd->frame, SLD_GREENBAR ), 0, ppcd->Alpha, 255 );
	}
	else
	{
		SetSliderValues( GetControl( ppcd->frame, SLD_GREENBAR ), 0, ppcd->nGreen, 255 );
	}
}
//----------------------------------------------------------------------------
int CPROC PaletteLoad( uintptr_t psv, PSI_CONTROL pf, uint32_t ID )
{
	// hmm don't think there's really anything special I need to...
	// okay yeah...
	((PPICK_COLOR_DATA)psv)->frame = pf;
	//SetFrameUserData( pf, psv );
	return TRUE;
}
//----------------------------------------------------------------------------
void CPROC InitColorData( PPICK_COLOR_DATA ppcd, CDATA original )
{
	ppcd->ColorDialogDone = ppcd->ColorDialogOkay = FALSE;
	ppcd->Alpha= AlphaVal( original );
	ppcd->nGreen = GreenVal( original );
	ppcd->flags.bMatrixChanged = 1;
	ppcd->CurrentColor = original;
	ppcd->LastPreset = NULL;
	ppcd->bSetPreset = FALSE;
	LoadPresets( ppcd );
}
void CPROC InitColorDataDefault( POINTER p )
{
	PPICK_COLOR_DATA ppcd = (PPICK_COLOR_DATA)p;
	InitColorData( ppcd, Color( 127, 127, 127 ) );
}
//----------------------------------------------------------------------------
void SetShaderControls( PPICK_COLOR_DATA ppcd, PSI_CONTROL source )
{
	if( source != ppcd->pShadeRed )
	{
		SetShadeMin( ppcd->pShadeRed, Color(   0, GreenVal(ppcd->CurrentColor), BlueVal( ppcd->CurrentColor ) ) );
		SetShadeMax( ppcd->pShadeRed, Color( 255, GreenVal(ppcd->CurrentColor), BlueVal( ppcd->CurrentColor ) ) );
		SetShadeMid( ppcd->pShadeRed, Color( 127, GreenVal(ppcd->CurrentColor), BlueVal( ppcd->CurrentColor ) ) );
	}
	if( source != ppcd->pShadeGreen )
	{
		SetShadeMin( ppcd->pShadeGreen, Color( RedVal(ppcd->CurrentColor),   0 , BlueVal( ppcd->CurrentColor ) ));
		SetShadeMax( ppcd->pShadeGreen, Color( RedVal(ppcd->CurrentColor), 255 , BlueVal( ppcd->CurrentColor ) ));
		SetShadeMid( ppcd->pShadeGreen, Color( RedVal(ppcd->CurrentColor), 127 , BlueVal( ppcd->CurrentColor ) ));
	}
	if( source != ppcd->pShadeBlue )
	{
		SetShadeMin( ppcd->pShadeBlue, Color( RedVal(ppcd->CurrentColor), GreenVal( ppcd->CurrentColor ),   0 ) );
		SetShadeMax( ppcd->pShadeBlue, Color( RedVal(ppcd->CurrentColor), GreenVal( ppcd->CurrentColor ), 255 ) );
		SetShadeMid( ppcd->pShadeBlue, Color( RedVal(ppcd->CurrentColor), GreenVal( ppcd->CurrentColor ), 127 ) );
	}
	if( source != ppcd->psw )
		SetShadeMid( ppcd->psw, ppcd->CurrentColor );
	SetColorWell( ppcd->pcZoom, ppcd->CurrentColor );
}
//----------------------------------------------------------------------------
// LOL that's pretty sexy, huh? LOL
static TEXTCHAR palette_frame_xml[] = {
//#define stuff(...) #__VA_ARGS__
//stuff(
"<control edit=\"1\" ID=\"-1\" caption=\"Color Select\" position=\"57,21\" size=\"280,259\" type=\"Frame\"><control ID=\"18\" border=\"81\" position=\"5,5\" size=\"133,133\" type=\"Color Matrix\"></control>"
"<control ID=\"17\" border=\"3\" position=\"141,1\" size=\"18,139\" type=\"Slider\"></control>"
"<control ID=\"21\" border=\"81\" position=\"171,5\" size=\"15,133\" type=\"Shade Well\"></control>"
"<control ID=\"23\" border=\"81\" position=\"189,5\" size=\"15,133\" type=\"Shade Well\"></control>"
"<control ID=\"24\" border=\"81\" position=\"207,5\" size=\"15,133\" type=\"Shade Well\"></control>"
"<control ID=\"25\" border=\"81\" position=\"225,5\" size=\"15,133\" type=\"Shade Well\"></control>"
"<control ID=\"22\" border=\"81\" position=\"243,5\" size=\"30,133\" type=\"Color Well\"></control>"
"<control ID=\"-1\" border=\"3\" caption=\"User-Defined Colors\" position=\"5,147\" size=\"150,12\" type=\"TextControl\"></control>"
"<control ID=\"26\" PrivateData=\"#ff356059\" border=\"2\" position=\"5,161\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"27\" PrivateData=\"#ff356059\" border=\"2\" position=\"23,161\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"28\" PrivateData=\"#ff356059\" border=\"2\" position=\"41,161\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"29\" PrivateData=\"#ff356059\" border=\"2\" position=\"59,161\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"30\" PrivateData=\"#ff356059\" border=\"2\" position=\"77,161\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"31\" PrivateData=\"#ff356059\" border=\"2\" position=\"95,161\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"32\" PrivateData=\"#ff356059\" border=\"2\" position=\"113,161\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"33\" PrivateData=\"#ff356059\" border=\"2\" position=\"131,161\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"34\" PrivateData=\"#ff356059\" border=\"2\" position=\"149,161\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"35\" PrivateData=\"#ff356059\" border=\"2\" position=\"167,161\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"36\" PrivateData=\"#ff356059\" border=\"2\" position=\"185,161\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"37\" PrivateData=\"#ff356059\" border=\"2\" position=\"203,161\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"38\" PrivateData=\"#ff356059\" border=\"2\" position=\"5,179\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"39\" PrivateData=\"#ff356059\" border=\"2\" position=\"23,179\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"40\" PrivateData=\"#ff356059\" border=\"2\" position=\"41,179\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"41\" PrivateData=\"#ff356059\" border=\"2\" position=\"59,179\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"42\" PrivateData=\"#ff356059\" border=\"2\" position=\"77,179\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"43\" PrivateData=\"#ff356059\" border=\"2\" position=\"95,179\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"44\" PrivateData=\"#ff356059\" border=\"2\" position=\"113,179\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"45\" PrivateData=\"#ff356059\" border=\"2\" position=\"131,179\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"46\" PrivateData=\"#ff356059\" border=\"2\" position=\"149,179\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"47\" PrivateData=\"#ff356059\" border=\"2\" position=\"167,179\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"48\" PrivateData=\"#ff356059\" border=\"2\" position=\"185,179\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"49\" PrivateData=\"#ff356059\" border=\"2\" position=\"203,179\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"50\" PrivateData=\"#ff356059\" border=\"2\" position=\"5,197\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"51\" PrivateData=\"#ff356059\" border=\"2\" position=\"23,197\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"52\" PrivateData=\"#ff356059\" border=\"2\" position=\"41,197\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"53\" PrivateData=\"#ff356059\" border=\"2\" position=\"59,197\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"54\" PrivateData=\"#ff356059\" border=\"2\" position=\"77,197\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"55\" PrivateData=\"#ff356059\" border=\"2\" position=\"95,197\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"56\" PrivateData=\"#ff356059\" border=\"2\" position=\"113,197\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"57\" PrivateData=\"#ff356059\" border=\"2\" position=\"131,197\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"58\" PrivateData=\"#ff356059\" border=\"2\" position=\"149,197\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"59\" PrivateData=\"#ff356059\" border=\"2\" position=\"167,197\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"60\" PrivateData=\"#ff356059\" border=\"2\" position=\"185,197\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"61\" PrivateData=\"#ff356059\" border=\"2\" position=\"203,197\" size=\"16,16\" type=\"CustomDrawnButton\"></control>"
"<control ID=\"19\" PrivateData=\"#ff356059\" border=\"1\" caption=\"Set Preset\" position=\"5,235\" size=\"95,19\" type=\"Button\"></control>"
"<control ID=\"20\" PrivateData=\" C'AlphaPressed'\" border=\"3\" caption=\"Set Alpha\" position=\"5,218\" size=\"95,14\" type=\"CheckButton\"></control>"
"<control ID=\"1\" PrivateData=\"#ff356059\" border=\"1\" caption=\"OK\" position=\"160,235\" size=\"55,19\" type=\"Button\"></control>"
"<control ID=\"2\" PrivateData=\"#ff356059\" border=\"1\" caption=\"Cancel\" position=\"220,235\" size=\"55,19\" type=\"Button\"></control></control>"
//    )
 };
PSI_PROC( int, PickColorEx )( CDATA *result, CDATA original, PSI_CONTROL hAbove, int x, int y )
{
	PSI_CONTROL pf = NULL;
	PICK_COLOR_DATA pcd;
	MemSet( &pcd, 0, sizeof( pcd ) );
	GetMyInterface();
	InitColorData( &pcd, original );
	// remove test for debugging save/load..
	// don't parse the NUL at the end.
	pf = ParseXMLFrame( palette_frame_xml, sizeof( palette_frame_xml ) - 1 );
	if( !pf )
 /*, NULL, PaletteLoad, (uintptr_t)&pcd*/
		pf = LoadXMLFrame( "palette.frame" );;
	if( pf )
	{
		int i;
		pcd.frame = pf;
		pcd.pColorMatrix = MakeImageFile( 128, 128 );
		SetFrameUserData( pf, (uintptr_t)&pcd );
		SetSliderValues( GetControl( pf, SLD_GREENBAR ), 0, 255-GreenVal( pcd.CurrentColor ), 255 );
		pcd.pcZoom =  GetControl( pf, CST_ZOOM );
		pcd.psw = GetControl( pf, CST_SHADE );
		pcd.pShadeRed = GetControl( pf, CST_SHADE_RED );
		pcd.pShadeGreen = GetControl( pf, CST_SHADE_GREEN );
		pcd.pShadeBlue = GetControl( pf, CST_SHADE_BLUE );
		SetButtonPushMethod( GetControl( pf, BTN_PRESET ), DefinePreset, (uintptr_t)&pcd );
		SetCheckButtonHandler( GetControl( pf, CHK_ALPHA ), AlphaPressed, (uintptr_t)&pcd );
		for( i = 0; i < 36; i++ )
		{
			PSI_CONTROL button = GetControl( pf, BTN_PRESET_BASE + i );
			if( button )
			{
				SetButtonDrawMethod( button, PresetDraw, (uintptr_t)&pcd );
				SetButtonPushMethod( button, PresetButton, (uintptr_t)&pcd );
			}
		}
		SetSliderUpdateHandler( GetControl( pf, SLD_GREENBAR ), SetGreenLevel, (uintptr_t)&pcd );
		SetCommonButtons( pf, &pcd.ColorDialogDone, &pcd.ColorDialogOkay );
		SetShaderControls( &pcd, NULL );
		SetSliderValues( GetControl( pf, SLD_GREENBAR ), 0, 255-GreenVal( pcd.CurrentColor ), 255 );
	}
#define SHADER_PAD 3
#define SHADER_WIDTH 15
#define FRAME_WIDTH 226 + ( 3 * ( SHADER_WIDTH + SHADER_PAD ) )
#define FRAME_HEIGHT 259
	if( !pf )
	{
		PSI_CONTROL pc;
		pf = CreateFrame( "Color Select"
							 , x - FRAME_WIDTH/2, y - FRAME_HEIGHT/2
							 , FRAME_WIDTH, FRAME_HEIGHT, BORDER_NORMAL, NULL );
		if( !pf )
			return FALSE;
		// the space for colormatrix to draw in.
		pcd.pColorMatrix = MakeImageFile( 128, 128 );
		pcd.flags.bMatrixChanged = 1;
		pcd.frame = pf;
		SetFrameUserData( pf, (uintptr_t)&pcd );
		//MoveFrame( pf, x - FRAME_WIDTH/2, y - FRAME_HEIGHT/2 );
		pc = MakeNamedControl( pf, "Color Matrix"
									, 5, 5, xsize, ysize
									, PAL_COLORS );
		MakeSlider( pf
					 , 5 + xsize + 3, 1
					 , 18, ysize + 6
					 , SLD_GREENBAR, SLIDER_VERT, SetGreenLevel, (uintptr_t)&pcd );
		//	MakeTextControl( pf, TEXT_VERTICAL, 8 + xsize + 15, 20, 88, 12, TXT_STATIC, "Green Level" );
		pcd.psw = MakeNamedControl( pf, "Shade Well", 8 + xsize + 18 + 12, 5
												 , SHADER_WIDTH, ysize
												 , CST_SHADE );
		pcd.pShadeRed = MakeNamedControl( pf, "Shade Well", 8 + xsize + 18 + 12 + (SHADER_WIDTH + SHADER_PAD), 5
												  , SHADER_WIDTH, ysize
												  , CST_SHADE_RED );
		pcd.pShadeBlue = MakeNamedControl( pf, "Shade Well", 8 + xsize + 18 + 12 + (SHADER_WIDTH + SHADER_PAD)*2, 5
													, SHADER_WIDTH, ysize
													, CST_SHADE_BLUE );
		pcd.pShadeGreen = MakeNamedControl( pf, "Shade Well", 8 + xsize + 18 + 12 + (SHADER_WIDTH + SHADER_PAD)*3, 5
													 , SHADER_WIDTH, ysize
													 , CST_SHADE_GREEN );
		pcd.pcZoom = MakeNamedControl( pf, "Color Well"
											  , 8 + xsize + 18 + 12 + (SHADER_WIDTH+SHADER_PAD)*4, 5
											  , 2 * SHADER_WIDTH, ysize
											  , CST_ZOOM
											  );
		MakeTextControl( pf, 5, ysize + 14, 150, 12, TXT_STATIC, "User-Defined Colors", 0 );
		{
			int i;
			PSI_CONTROL pc;
			for( i = 0; i < 12; i++ )
			{
				pc = MakeCustomDrawnButton( pf, 5 + 18 * i, ysize + 15 + 13     , 16, 16, BTN_PRESET_BASE+i, 0, PresetDraw, PresetButton, (uintptr_t)&pcd );
				SetCommonBorder( pc, BORDER_THINNER );
				SetNoFocus( pc );
			}
			for( i = 0; i < 12; i++ )
			{
				pc = MakeCustomDrawnButton( pf, 5 + 18 * i, ysize + 15 + 13 + 18, 16, 16, BTN_PRESET_BASE+i+12, 0, PresetDraw, PresetButton, (uintptr_t)&pcd );
				SetCommonBorder( pc, BORDER_THINNER );
				SetNoFocus( pc );
			}
			for( i = 0; i < 12; i++ )
			{
				pc = MakeCustomDrawnButton( pf, 5 + 18 * i, ysize + 15 + 13 + 36, 16, 16, BTN_PRESET_BASE+i+24, 0, PresetDraw, PresetButton, (uintptr_t)&pcd );
				SetCommonBorder( pc, BORDER_THINNER );
				SetNoFocus( pc );
			}
		}
		// button style normal button
		MakeCheckButton( pf, 5, 235, 95, 19
							, BTN_PRESET, "Set Preset"
							, 0, DefinePreset, (uintptr_t)&pcd );
		MakeCheckButton( pf, 5, 218, 95, 14
							, CHK_ALPHA, "Set Alpha"
							, 0, AlphaPressed, (uintptr_t)&pcd );
		AddCommonButtons( pf, &pcd.ColorDialogDone, &pcd.ColorDialogOkay );
		SetShaderControls( &pcd, NULL );
		SetSliderValues( GetControl( pf, SLD_GREENBAR ), 0, 255-GreenVal( pcd.CurrentColor ), 255 );
		SaveXMLFrame( pf, "palette.frame" );
	}
	DisplayFrameOver( pf, hAbove );
	EditFrame( pf, TRUE );
	CommonWait( pf );
	UnmakeImageFile( pcd.pColorMatrix );
	if( pcd.ColorDialogOkay )
	{
		//SaveFrame( pf, "palette.frame" );
		if( result )
			*result = pcd.CurrentColor;
		//lprintf( "------- Destroy common." );
		DestroyCommon( &pf );
		  return TRUE;
	}
	//lprintf( "------- Destroy common." );
	DestroyCommon( &pf );
	//lprintf( "Result to application." );
	return FALSE;
}
//----------------------------------------------------------------------------
PSI_PROC( int, PickColor )( CDATA *result, CDATA original, PSI_CONTROL hAbove )
{
	int32_t x, y;
	GetMyInterface();
	GetMousePosition( &x, &y );
	return PickColorEx( result, original, hAbove, x, y );
}
//----------------------------------------------------------------------------
static int CPROC ColorWellDraw( PSI_CONTROL pc )
{
	ValidatedControlData( PCOLOR_WELL, color_well.TypeID, pcw, pc );
	if( pcw )
	{
		Image surface = GetControlSurface( pc );
		CDATA color = pcw->color;
		if( !AlphaVal( color ) )
			color = SetAlpha( color, 1 );
		//lprintf( "Clear color well surface to %lX", pcw->color );
		ClearImageTo( surface, color );
	}
	return TRUE;
}
static int CPROC ColorWellMouse( PSI_CONTROL pc, int32_t x, int32_t y, uint32_t b )
{
	ValidatedControlData( PCOLOR_WELL, color_well.TypeID, pcw, pc );
	//if( pc->flags.bDisable ) // ignore mouse on these...
	//	return FALSE;
	if( b == -1 )
	{
		return FALSE;
	}
	if( pcw->flags.bPickColor )
	{
		if( b & ( MK_LBUTTON | MK_RBUTTON ) )
		{
			CDATA result = pcw->color;
			if( !pcw->flags.bPicking )
			{
				pcw->flags.bPicking = 1;
				lprintf( "PICK_COLOR" );
				if( PickColorEx( &result, pcw->color, GetFrame( pc ), x + FRAME_WIDTH, y + FRAME_WIDTH ) )
				{
					lprintf( "PICK_COLOR_DONE" );
				   lprintf( "Updating my color to %08" _32fx "", result );
					pcw->color = result;
					if( pcw->UpdateProc )
				      pcw->UpdateProc( pcw->psvUpdate, result );
					SmudgeCommon( pc );
				}
				else
				{
					lprintf( "Failing to set the color.." );
					lprintf( "PICK_COLOR_DONE2" );
				}
				//DebugBreak();
				pcw->flags.bPicking = 0;
			}
		}
	}
	return TRUE;
}
PSI_CONTROL EnableColorWellPick( PSI_CONTROL pc, LOGICAL bEnable )
{
	ValidatedControlData( PCOLOR_WELL, color_well.TypeID, pcw, pc );
	if( pcw )
		pcw->flags.bPickColor = bEnable;
	return pc;
}
PSI_CONTROL SetOnUpdateColorWell( PSI_CONTROL pc, void(CPROC*update_proc)(uintptr_t,CDATA), uintptr_t psvUpdate)
{
	ValidatedControlData( PCOLOR_WELL, color_well.TypeID, pcw, pc );
	if( pcw )
	{
		pcw->UpdateProc = update_proc;
		pcw->psvUpdate = psvUpdate;
	}
	return pc;
}
//----------------------------------------------------------------------------
static int CPROC ShadeWellMouse( PSI_CONTROL pc, int32_t x, int32_t y, uint32_t b )
{
	ValidatedControlData( PSHADE_WELL, shade_well.TypeID, psw, pc );
	if( b == -1 )
		return FALSE;
	if( y < 0 )
		return 0;
	if( psw && ( b & MK_LBUTTON ) )
	{
		PPICK_COLOR_DATA ppcd = PPCD(pc);
		CDATA c;
		uint32_t height;
		Image pSurface = GetControlSurface( pc );
		height = pSurface->height;
		//lprintf( "Setting new mid color... update... ------------------------- " );
		if( SUS_LT( y, int32_t, height/2, uint32_t ) )
		{
			c = ScaleColor( psw->color_min, psw->color_mid, height/2, y );
		}
		else
		{
			c = ScaleColor( psw->color_mid, psw->color_max, height/2, y - height/2 );
		}
		SetAlpha( c
				  , ppcd->Alpha );
		//SetColorWell( ppcd->pcZoom, c );
		ppcd->CurrentColor = c;
		ppcd->flags.bSettingShade = 1;
		SetShaderControls( ppcd, pc );
		SetSliderValues( GetNearControl( pc, SLD_GREENBAR ), 0, 255-GreenVal( c ), 255 );
		ppcd->flags.bSettingShade = 0;
		// update ppcd ... how do I get that?
		// it's attached to the frame, right?  so I just
		// have to indicicate that ppcd has changed...
		SmudgeCommon( pc );
	}
	return TRUE;
}
//----------------------------------------------------------------------------
PSI_PROC( void, SetShadeMin )( PSI_CONTROL pc, CDATA color )
{
	ValidatedControlData( PSHADE_WELL, shade_well.TypeID, psw, pc );
	if( psw )
	{
		psw->color_min = color;
		SmudgeCommon( pc );
	}
}
//----------------------------------------------------------------------------
PSI_PROC( void, SetShadeMax )( PSI_CONTROL pc, CDATA color )
{
	ValidatedControlData( PSHADE_WELL, shade_well.TypeID, psw, pc );
	if( psw )
	{
		psw->color_max = color;
		SmudgeCommon( pc );
	}
}
//----------------------------------------------------------------------------
PSI_PROC( void, SetShadeMid )( PSI_CONTROL pc, CDATA color )
{
	ValidatedControlData( PSHADE_WELL, shade_well.TypeID, psw, pc );
	if( psw )
	{
		psw->color_mid = color;
		SmudgeCommon( pc );
	}
}
//----------------------------------------------------------------------------
PSI_PROC( CDATA, GetColorFromWell )( PSI_CONTROL pc )
{
	ValidatedControlData( PCOLOR_WELL, color_well.TypeID, pcw, pc );
	if( pcw )
		return pcw->color;
	return 0;
}
//----------------------------------------------------------------------------
PSI_PROC( PSI_CONTROL, SetColorWell )( PSI_CONTROL pc, CDATA color )
{
	ValidatedControlData( PCOLOR_WELL, color_well.TypeID, pcw, pc );
	if( pcw )
	{
		pcw->color = color;
		SmudgeCommon( pc );
	}
	return pc;
}
//----------------------------------------------------------------------------
//CONTROL_PROC_DEF( COLOR_WELL, ColorWell, BORDER_THIN|BORDER_INVERT
//					 , CDATA color )
int CPROC InitColorWell( PSI_CONTROL pc )
{
	if( pc )
	{
		ValidatedControlData( PCOLOR_WELL, color_well.TypeID, pcw, pc );
		pcw->color = 0;
	}
	return TRUE;
}
//----------------------------------------------------------------------------
int CPROC InitShadeWell( PSI_CONTROL pc )
{
	SetShadeMin( pc, BASE_COLOR_BLACK );
	SetShadeMid( pc, BASE_COLOR_DARKGREY );
	SetShadeMax( pc, BASE_COLOR_WHITE );
	SetNoFocus( pc );
	return TRUE;
}
//----------------------------------------------------------------------------
int CPROC InitPalette( PSI_CONTROL pc )
{
	SetNoFocus( pc );
	{
		PPICK_COLOR_DATA ppcd = PPCD(pc);
	}
	return TRUE;
}
void CPROC ColorWellDestroy( PSI_CONTROL pc )
{
	ValidatedControlData( PCOLOR_WELL, color_well.TypeID, pcw, pc );
	if( pcw )
	{
		if( pcw->flags.bPicking )
		{
			lprintf( "Uhmm need to kill the parent color picking dialog!" );
		}
	}
}
//----------------------------------------------------------------------------
CONTROL_REGISTRATION color_well = { "Color Well"
											 , { {32, 32}, sizeof( COLOR_WELL ), BORDER_INVERT|BORDER_THIN }
											 , InitColorWell
											 , NULL
											 , ColorWellDraw
											 , ColorWellMouse
 // key
											 , NULL
 // if picking a color, destroy dialog
				                      , ColorWellDestroy
},
shade_well = { "Shade Well"
				 , { {32, 32}, sizeof( SHADE_WELL ), BORDER_INVERT|BORDER_THIN }
											 , InitShadeWell
											 , NULL
 //DrawShadeControl
											 , NULL
											 , ShadeWellMouse
											 , NULL
},
color_matrix_well = { "Color Matrix"
						  , { {xsize, ysize}, 0, BORDER_INVERT|BORDER_THIN }
											 , InitPalette
											 , NULL
											 , DrawPalette
 //PaletteMouse
											 , NULL
											 , NULL
}
;
PRIORITY_PRELOAD( register_well, PSI_PRELOAD_PRIORITY )
{
	DoRegisterControl( &color_well );
	DoRegisterControl( &shade_well );
	DoRegisterControl( &color_matrix_well );
}
PSI_COLORWELL_NAMESPACE_END
//#define DEBUG_DRAW_MENU
//#if !defined( WIN32 ) && !defined( _MSC_VER)
// haha - well at least under windows these menu issues can be resolved.
#ifndef _WIN32
#define DISABLE_NATIVE_POPUPS
#endif
#define CUSTOM_MENUS
//#endif
#define MENU_DRIVER_SOURCE
//#define NO_LOGGING
#define MENU_DRIVER_SOURCE
PSI_MENU_NAMESPACE
#ifdef CUSTOM_MENUS
// these are a little bigger than the actual thing drawn
// to give some padding around the text...
#define CHECK_WIDTH 12
#define SUB_WIDTH 16
// Should do something to disable infinite recursions
// Though they may be allowed, they really really are
// a bad idea when you can return selection data for all
// levels of submenus...
typedef struct menu_tag {
    struct {
        uint32_t changed:1;
        uint32_t tracking:1;
		  uint32_t abort:1;
		  uint32_t showing : 1;
		  uint32_t bSubmenuOpen : 1;
    }flags;
    struct menuitem_tag *items;
    intptr_t selection;
    struct menuitem_tag *selected;
    int16_t   height, width;
    struct {
 // display x and y
        int32_t    x, y;
    } display;
    SFTFont  font;
    PSI_CONTROL image;
    int _x, _y, _b;
 // currently shown child if any...
    struct menu_tag *child, *parent;
    Image surface;
	void (*callback)( uintptr_t psv, int menuStatus );
        uintptr_t psvParam;
} MENU;
typedef struct menuitemflags_tag {
 // pretty much no other data is useful...
	uint32_t bSeparator:1;
 // information is only useful to an external routine
	uint32_t bOwnerDraw:1;
   // text field valid...
	uint32_t bHasText:1;
	uint32_t bChecked:1;
 // current option shown...
	uint32_t bSelected:1;
 // sub menu with active popup shown
	uint32_t bOpen:1;
 // data content is a submenu.. else ID data
	uint32_t bSubMenu:1;
} ITEMFLAGS;
// duplicated in controls.h - applications need this structure...
/*
typedef struct draw_popup_item_tag  DRAWPOPUPITEM;
typedef struct draw_popup_item_tag  *PDRAWPOPUPITEM;
struct draw_popup_item_tag
{
	uintptr_t ID;
	struct {
		uint32_t selected : 1;
		uint32_t checked  : 1;
	} flags;
	union {
		struct {
			uint32_t width, height;
		} measure;
		struct {
			int32_t x, y;
			uint32_t width, height;
			Image image;
		} draw;
	};
};
*/
typedef void (*DrawPopupItemProc)( LOGICAL measure, PDRAWPOPUPITEM pdi );
typedef struct menuitem_tag {
	ITEMFLAGS  flags;
	union {
		struct {
// shortcut length save...
			size_t textlen;
 // use PutMenuString when rendering this...
			TEXTCHAR *text;
   // selected active Key...
			TEXTCHAR key;
		} text;
		struct {
	      DrawPopupItemProc DrawPopupItem;
		} owner;
	} data;
	union {
		  uintptr_t userdata;
		uintptr_t ID;
		PMENU menu;
	} value;
	int baseline;
 // not including +2 for above/below highlights
   uint32_t height;
 // reported from owner draw measuring...
   uint32_t width;
 // left offset (for check/icon space)
   uint32_t offset;
	struct menuitem_tag *next, **me;
} MENUITEM;
#else
//#define PMENU HMENU
//#define PMENUITEM int
//typedef int PMENU;
//typedef int PMENUITEM;
#endif
PSI_MENU_NAMESPACE_END
// $Log: menustruc.h,v $
// Revision 1.11  2005/03/12 23:31:21  panther
// Edit controls nearly works... have some issues with those dang popups.
//
// Revision 1.10  2004/10/24 20:09:47  d3x0r
// Sync to psilib2... stable enough to call it mainstream.
//
// Revision 1.3  2004/10/13 11:13:53  d3x0r
// Looks like this is cleaning up very nicely... couple more rough edges and it'll be good to go.
//
// Revision 1.2  2004/10/12 08:10:51  d3x0r
// checkpoint... frames are controls, and anything can be displayed...
//
// Revision 1.1  2004/09/19 19:22:31  d3x0r
// Begin version 2 psilib...
//
// Revision 1.9  2003/03/31 04:18:49  panther
// Okay - drawing dispatch seems to work now.  Client/Server timeouts occr... rapid submenus still fail
//
// Revision 1.8  2003/03/29 17:21:06  panther
// Focus problems, mouse message problems resolved... Focus works through to the client side now
//
// Revision 1.7  2003/03/27 00:23:14  panther
// Enable owner draw popup items - measure and draw
//
// Revision 1.6  2003/03/25 08:45:56  panther
// Added CVS logging tag
//
//#define DEBUG_MENUS
PSI_MENU_NAMESPACE
#define MENU_VERTPAD 5
#define MENU_HORZPAD 5
#define PutMenuStringFont PutStringFont
#define GetMenuStringSizeFontEx GetStringSizeFontEx
	static struct {
		struct {
			BIT_FIELD bCustomMenuEnable : 1;
			BIT_FIELD bDisplayBoundless : 1;
		} flags;
	} local_popup_data;
#ifdef CUSTOM_MENUS
static uint32_t last_buttons;
#endif
extern CONTROL_REGISTRATION menu;
//----------------------------------------------------------------------
//extern void GetMyInterface(void);
//----------------------------------------------------------------------
PSI_PROC( PMENU, CreatePopup )( void )
{
#ifndef PSI_SERVICE
#ifdef USE_INTERFACES
	if( !g.MyDisplayInterface )
	{
		GetMyInterface();
	}
#endif
#endif
#if defined( DISABLE_NATIVE_POPUPS )
	local_popup_data.flags.bCustomMenuEnable = 1;
#else
	local_popup_data.flags.bCustomMenuEnable = RequiresDrawAll();
	local_popup_data.flags.bDisplayBoundless = RequiresDrawAll();
#endif
#ifndef __NO_OPTIONS__
	local_popup_data.flags.bCustomMenuEnable = SACK_GetProfileIntEx( GetProgramName()
																						, "SACK/PSI/menus/Use Custom Popups"
																						, local_popup_data.flags.bCustomMenuEnable
																						, TRUE );
	local_popup_data.flags.bDisplayBoundless = SACK_GetProfileIntEx( GetProgramName()
																						, "SACK/PSI/menus/Do not clip to display"
																						, local_popup_data.flags.bDisplayBoundless
																						, TRUE );
#endif
	if( local_popup_data.flags.bCustomMenuEnable )
	{
		PMENU pm;
		PSI_CONTROL pc = MakeControl( NULL, menu.TypeID
											 , 0, 0
											 , 1, 1
											 , -1 );
		//= Allocate( sizeof( MENU ) );
		pm = ControlData( PMENU, pc );
		pm->image = pc;
		//								MemSet( menu, 0, sizeof( MENU ) );
		//pm->font = GetDefaultFont();
		return pm;
	}
#if !defined( DISABLE_NATIVE_POPUPS )
	else
	{
		return (PMENU)CreatePopupMenu();
	}
#endif
   return 0;
}
#ifdef CUSTOM_MENUS
//----------------------------------------------------------------------
void ShowMenu( PMENU pm, int x, int y, LOGICAL bWait, PSI_CONTROL parent );
void UnshowMenu( PMENU pm );
int CalculateMenuItems( PMENU pm )
{
	PMENUITEM pmi;
	uint32_t maxwidth, totalheight, hassubmenu = 0;
	pmi = pm->items;
	maxwidth = 0;
	 totalheight = MENU_VERTPAD;
	pm->font = GetCommonFont( pm->image );
	while( pmi )
	{
		pmi->baseline = totalheight;
		if( pmi->flags.bSubMenu )
		{
			hassubmenu |= 1;
		}
		if( pmi->flags.bSeparator )
		{
			pmi->height = ( GetFontHeight( pm->font ) ) / 2;
		}
		else if( pmi->flags.bHasText )
		{
			uint32_t width;
			GetMenuStringSizeFontEx( pmi->data.text.text
			                        , pmi->data.text.textlen
			                        , &width, &pmi->height
			                        , pm->font );
			if( width > maxwidth )
			    maxwidth = width;
		}
		else if( pmi->flags.bOwnerDraw )
		{
			  DrawPopupItemProc dmip = pmi->data.owner.DrawPopupItem;
			  DRAWPOPUPITEM dpi;
			    dpi.psvUser = pmi->value.userdata;
			  dpi.flags.selected = pmi->flags.bSelected;
			  dpi.flags.checked = pmi->flags.bChecked;
			  if( dmip )
				  dmip( TRUE, &dpi );
			  pmi->height = dpi.measure.height;
			  pmi->width = dpi.measure.width;
			  if( dpi.measure.width > maxwidth )
				  maxwidth = dpi.measure.width;
			// call owner proc to get the item size...
			//pmi->height += GetFontHeight( pm->font ) + 2;
		}
		totalheight += pmi->height + 2;
		pmi->offset = CHECK_WIDTH;
		pmi = pmi->next;
	}
	pm->height = (int16_t)(totalheight + MENU_VERTPAD);
	pm->width = (int16_t)(maxwidth
		+ 2*MENU_HORZPAD
		+ CHECK_WIDTH
							  + (hassubmenu?SUB_WIDTH:0));
#ifdef DEBUG_MENUS
	 lprintf( "Resize menu to %d,%d", pm->width, pm->height );
#endif
 //+ FrameBorderX( pm->image->BorderType )
	 SizeCommon( pm->image, pm->width
 //+ FrameBorderY( pm->image, pm->image->BorderType, NULL )
				  , pm->height
				  );
	pm->flags.changed = 0;
	return 1;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void DestroyItem( PMENUITEM pmi )
{
	if( pmi->flags.bHasText )
	{
		if( pmi->data.text.text )
			Release( pmi->data.text.text );
	}
	if( pmi->flags.bSubMenu )
		DestroyPopup( pmi->value.menu );
	*pmi->me = pmi->next;
	if( pmi->next )
		pmi->next->me = pmi->me;
	Release( pmi );
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/*
static void AddItem( PMENU pm, PMENUITEM pmi )
{
	PMENUITEM pmiafter;
	pmiafter = pm->items;
	while( pmiafter && pmiafter->next )
		pmiafter = pmiafter->next;
	if( !pmiafter )
	{
		pm->items = pmi;
		pmi->me = &pm->items;
	}
	else
	{
	  pmiafter->next = pmi;
	  pmi->me = &pmiafter->next;
	}
   pm->flags.changed = 1;
	}
*/
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void RenderItem( PMENU pm, PMENUITEM pmi )
{
   Image surface;
	if( !pm || !pmi || !pm->surface || !pm->image )
		 return;
	surface = GetControlSurface( pm->image );
	if( pmi->flags.bSeparator )
	{
		int height = pmi->height;
		int baseline = pmi->baseline + (height/2);
		do_hline( surface, baseline-1, 6, pm->width - 12, basecolor(pm->image)[SHADOW] );
		do_hline( surface, baseline  , 5, pm->width - 10, basecolor(pm->image)[SHADE] );
		do_hline( surface, baseline+1, 6, pm->width - 12, basecolor(pm->image)[HIGHLIGHT] );
		//pmi->baseline += height;
		//pmi->height = height;
	}
	else if( pmi->flags.bOwnerDraw )
	{
		  DrawPopupItemProc dmip = pmi->data.owner.DrawPopupItem;
		  DRAWPOPUPITEM dpi;
		  dpi.psvUser = pmi->value.userdata;
		  dpi.flags.selected = pmi->flags.bSelected;
		  dpi.flags.checked = pmi->flags.bChecked;
		  dpi.draw.height = pmi->height;
		  dpi.draw.width = pmi->width;
		  dpi.draw.image = surface;
		  dpi.draw.x = pmi->offset;
		  dpi.draw.y = pmi->baseline;
		  if( dmip )
			  dmip( FALSE, &dpi );
		//pmi->baseline += GetFontHeight( pm->font ) + 2;
	}
	else if( pmi->flags.bHasText )
	{
		BlatColor( surface
			      , 0, pmi->baseline
			      , pm->width, pmi->height + 2
			      , basecolor(pm->image)[NORMAL] );
		PutMenuStringFont( surface
			              , MENU_HORZPAD + CHECK_WIDTH, pmi->baseline + 1
			              , basecolor(pm->image)[TEXTCOLOR], 0
			              , pmi->data.text.text, pm->font );
		pmi->height = GetFontHeight( pm->font );
		if( pmi->flags.bSubMenu )
		{
			int width = pm->width - 4;
			            do_line( surface
			                    , width - 8, pmi->baseline + 1 + 2
			                    , width, pmi->baseline + 1 + (pmi->height/2)
			                    , basecolor(pm->image)[SHADOW] );
			            do_line( surface
			                    , width, pmi->baseline + 1 + (pmi->height/2)
			                    , width - 8, pmi->baseline + 1 + (pmi->height - 2)
			                    , basecolor(pm->image)[HIGHLIGHT] );
			do_line( surface
			                    , width - 8, pmi->baseline + 1 + 2
			                    , width - 8, pmi->baseline + 1 + ( pmi->height - 2 )
			                    , basecolor(pm->image)[SHADE] );
		  }
#ifdef DEBUG_DRAW_MENU
		  lprintf( "Item is %s",pmi->flags.bChecked?"checked":"unchecked" );
#endif
		if( pmi->flags.bChecked )
		{
			do_line( surface
			        , 3, pmi->baseline + 1
			        , 13, pmi->baseline + 11
			        , Color( 0, 0, 0 ) );
			do_line( surface
			        , 3, pmi->baseline + 11
			        , 13, pmi->baseline + 1
			        , Color( 0, 0, 0 ) );
		  }
		  else
		  {
			do_line( surface
			        , 3, pmi->baseline + 1
			        , 13, pmi->baseline + 11
			        , basecolor(pm->image)[NORMAL] );
			do_line( surface
			        , 3, pmi->baseline + 11
			        , 13, pmi->baseline + 1
						 , basecolor(pm->image)[NORMAL]);
		  }
	 }
	 //if( pmi->flags.bSelected )
	 //{
	 //   do_hline( pm->surface, pmi->baseline, 0, pm->width, basecolor(pm->image)[SHADOW] );
	 //   do_hline( pm->surface, pmi->baseline+pmi->height+2, 0, pm->width, basecolor(pm->image)[HIGHLIGHT] );
	 //}
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void RenderUnselect( PMENU pm, PMENUITEM pmi )
{
	do_hline( pm->surface, pmi->baseline, 0, pm->width, basecolor(pm->image)[NORMAL] );
	do_hline( pm->surface, pmi->baseline+pmi->height+2, 0, pm->width, basecolor(pm->image)[NORMAL] );
#ifdef DEBUG_DRAW_MENU
	lprintf( "Render unselect" );
#endif
	//SmudgeCommon( pm->image );
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void RenderSelect( PMENU pm, PMENUITEM pmi )
{
	do_hline( pm->surface, pmi->baseline, 0, pm->width-1, basecolor(pm->image)[SHADOW] );
	do_hline( pm->surface, pmi->baseline+pmi->height+2, 0, pm->width-1, basecolor(pm->image)[HIGHLIGHT] );
	do_vline( pm->surface, 0, pmi->baseline, pmi->baseline + pmi->height + 2, basecolor(pm->image)[SHADE] );
	do_vline( pm->surface, pm->width-1, pmi->baseline, pmi->baseline + pmi->height + 2, basecolor(pm->image)[HIGHLIGHT] );
#ifdef DEBUG_DRAW_MENU
	lprintf( "Render select" );
#endif
	//SmudgeCommon( pm->image );
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
static int CPROC RenderItems( PSI_CONTROL pc )
{
	//uintptr_t psv;
	//PRENDERER display;
	ValidatedControlData( PMENU, menu.TypeID, pm, pc );
	//PMENU pm = (PMENU);
	PMENUITEM pmi;
	if( pm )
	{
		//lprintf( "rendering a menu popup control thing..." );
		ClearImageTo( pc->Surface, basecolor(pm->image)[NORMAL] );
		pm->surface = pc->Surface;
		if( !pm->surface )
			return 0;
		pmi = pm->items;
		while( pmi )
		{
			RenderItem( pm, pmi );
			pmi = pmi->next;
		}
		//selection has to be drawn on top of all menu items rendered
	  // otherwise all is bad.
		pmi = pm->items;
		while( pmi )
		{
			if( pmi->flags.bSelected )
			{
				RenderSelect( pm, pmi );
				break;
			}
			pmi = pmi->next;
		}
	}
	return 1;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CPROC TimerProc( uintptr_t psv )
{
	// some timer fired ... useful when a mouse is on a popup item
	// and still for a time....
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
static int MenuMouse( PMENU pm, int32_t x, int32_t y, uint32_t b )
{
	PMENUITEM pmi;
#ifdef DEBUG_DRAW_MENU
	lprintf( "Mouse on menu... %d,%d %x", x, y, b );
	lprintf( "menu is %d by %d and has %p", pm->width, pm->height, pm->child );
#endif
	pmi = pm->items;
	if( x < 0 || y < 0 ||
		x > pm->width || y > pm->height )
	{
		PMENU parent = pm->parent;
		if( parent )
		{
			//lprintf( "Menu has a parent... check to see if it's still there." );
			MenuMouse( parent
						, pm->display.x - parent->display.x + x
						, pm->display.y - parent->display.y + y
						, b );
			last_buttons = b;
			return TRUE;
		}
		else
		{
#ifdef DEBUG_DRAW_MENU
			lprintf( "%08lx %08lx", b, last_buttons );
#endif
			if( MAKE_FIRSTBUTTON( b, last_buttons ) )
			{
#ifdef DEBUG_DRAW_MENU
				lprintf( "Click outside menu- close menu." );
#endif
				UnshowMenu( pm );
			}
			last_buttons = b;
			// but also check parent's to see if the mouse is on them...
			return FALSE;
		}
	}
	while( pmi )
	{
		if( y >= pmi->baseline &&
			 y <= (pmi->baseline + (int)pmi->height) )
		{
			//lprintf( "Finding item which has %d in it... starts at %d?", y, pmi->baseline );
			if( pmi->flags.bSeparator )
			{
				if( pm->selected )
				{
					if( pm->selected->flags.bSubMenu )
					{
						UnshowMenu( pm->selected->value.menu );
						pm->flags.bSubmenuOpen = 0;
					}
					//RenderUnselect( pm, pm->selected );
					SmudgeCommon( pm->image );
					pm->selected->flags.bSelected = FALSE;
				}
				pm->selected = NULL;
				pmi = NULL;
				break;
			}
			if( pmi->flags.bSelected )
			{
				break;
			}
			else
			{
				if( pm->selected )
				{
					if( pm->selected->flags.bSubMenu )
					{
						UnshowMenu( pm->selected->value.menu );
						pm->flags.bSubmenuOpen = 0;
					}
					//RenderUnselect( pm, pm->selected );
					pm->selected->flags.bSelected = FALSE;
				}
				//RenderSelect( pm, pmi );
				SmudgeCommon( pm->image );
#ifdef DEBUG_DRAW_MENU
				lprintf( "New selected %p", pmi );
#endif
				pmi->flags.bSelected = TRUE;
				pm->selected = pmi;
				if( pmi->flags.bSubMenu && pmi->value.menu )
				{
					pm->child = pmi->value.menu;
					pmi->value.menu->parent = pm;
					// release ownership so  that show mmeenu can  grrab it
					// is okay now - since we'll be owning our parent's mouse anyhow
					pm->flags.bSubmenuOpen = 1;
					ShowMenu( pmi->value.menu
								 , pm->display.x + pm->width - MENU_HORZPAD
								 , pm->display.y + pmi->baseline, FALSE, NULL );
					last_buttons = b;
					return TRUE;
				}
			}
		}
		pmi = pmi->next;
	}
	if( !( pm->_b & MK_LBUTTON ) &&
		 ( b & MK_LBUTTON ) )
	{
		if( x < 0 || x >= pm->width ||
			y < 0 || y >= pm->height )
		{
			//Log2( "Aborting Menu %" _32fs " %" _32fs "", x, y );
			pm->flags.abort = TRUE;
			UnshowMenu( pm );
		}
	}
	if( !( b & MK_LBUTTON  ) &&
	   (pm->_b & MK_LBUTTON ) )
	{
		if( pmi && !pmi->flags.bSubMenu )
		{
			Log1( "Returning Selection: %08" _PTRSZVALfx "", pmi->value.ID );
			pm->selection = pmi->value.ID;
			UnshowMenu( pm );
			last_buttons = b;
			return  TRUE;
		}
	}
	pm->_x = x;
	pm->_y = y;
	pm->_b = b;
	last_buttons = b;
	return TRUE;
}
static int OnMouseCommon( "Popup Menu" )( PSI_CONTROL pc, int32_t x, int32_t y, uint32_t b )
{
	ValidatedControlData( PMENU, menu.TypeID, pm, pc );
	if( pm )
	{
		MenuMouse( pm, x, y, b );
		return 1;
	}
	return 0;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void UnshowMenu( PMENU pm )
{
	PMENU passed_result = NULL;
#ifdef DEBUG_MENUS
	Log1( "Menu to unshow=%p", pm );
#endif
	if( !pm || !pm->flags.tracking )
	{
#ifdef DEBUG_MENUS
		if( pm )
			lprintf( "No pm or not tracking this menu why am I unshowing?" );
#endif
		return;
	}
#ifdef DEBUG_DRAW_MENU
	lprintf( "%p show menu (close children first)", pm );
#endif
	if( pm->child )
		UnshowMenu( pm->child );
#ifdef DEBUG_DRAW_MENU
	lprintf( "%p show menu (NOT tracking)", pm );
#endif
	pm->flags.tracking = FALSE;
	if( pm->selected )
		pm->selected->flags.bSelected = FALSE;
#ifdef DEBUG_MENUS
	lprintf( "Popup release capture" );
#endif
 // release ownership...
	CaptureCommonMouse( pm->image, 0 );
	//pm->flags.abort = TRUE;
	if( pm->parent )
	{
		if( pm->flags.abort )
		{
#ifdef DEBUG_MENUS
			Log( "Aboring the parent." );
#endif
			pm->parent->flags.abort = TRUE;
		}
		//pm->flags.abort = TRUE; // if we weren't previously we still need this..
//#ifdef DEBUG_MENUS
		Log1( "Telling parent that selection is: %08" _32fx "", pm->selection );
//#endif
		if( ( ( pm->parent->selection = pm->selection ) != -1 )
			|| pm->flags.abort)
			passed_result = pm->parent;
		// no longer is there a child menu..
		pm->parent->child = NULL;
		// give ownership back to parent...
#ifdef DEBUG_MENUS
		lprintf( "Popup capture capture" );
#endif
 // grab ownership again...
		CaptureCommonMouse( pm->parent->image, 1 );
	}
#ifdef DEBUG_MENUS
	else
	{
		Log1( "This menu doesn't have a parent? but this selection is %08" _PTRSZVALfx "", pm->selection );
	}
#endif
	HideControl( pm->image );
	pm->flags.showing = 0;
	//UnmakeImageFile( pm->surface );
	//pm->surface = NULL;
	//DestroyCommon( &pm->image );
	//pm->window = NULL;
	pm->surface = NULL;
	pm->parent = NULL;
	if( pm->callback ) {
		pm->callback( pm->psvParam, pm->selection );
	}
	if( passed_result )
		UnshowMenu( passed_result );
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
int CPROC FocusChanged( PSI_CONTROL pc, LOGICAL bFocus )
{
	ValidatedControlData( PMENU, menu.TypeID, pm, pc );
#define LosingFocus  (!pc->flags.bFocused )
	Log1( "Losing focus callback? %08" _32fx "", bFocus );
	if( !pm )
	{
		// if bFocus - refuse, if losefocus, accept.
#ifdef DEBUG_MENUS
		lprintf( "focus, but not on a menu?" );
#endif
		return !bFocus;
	}
	if( !pm->flags.tracking )
	{
#ifdef DEBUG_MENUS
		lprintf( "Not tracking this menu anymore - focus is irrelavant." );
#endif
		return !bFocus;
	}
	if( bFocus )
	{
		PSI_CONTROL child;
#ifdef DEBUG_MENUS
		Log1( "Menu selection = %" _PTRSZVALfs "", pm->selection );
#endif
		if( pm->selection != -1 || pm->flags.abort )
		{
			if( pm->parent && pm->flags.abort )
				pm->parent->flags.abort = TRUE;
#ifdef DEBUG_MENUS
			Log1( "menu = %p Removing newly focused menu...", pm );
#endif
			UnshowMenu( pm );
			return TRUE;
		}
		//if( pm->image == LosingFocus )
		//{
		//	Log( "This menu is about ot get focus? but it lost it but..." );
		//	return;
		//}
		 //if( pm->parent && ( pm->parent->image == LosingFocus )
			 // hmm can't check this yet since loss is issued and then
			 // set - on a windows platform anyhow...
			 /*HasFocus( pm->parent->image )*/
		//     )
		//{
		//	return; // not really losing focus...
		//}
		child = pc;
		while( child )
		{
			Log2( "Check  to see if child is gaining %p losing=%d ",
					 child, LosingFocus );
		 // actually LosingFocus is GainingFocus...
			if( child )
				break;
			child = child->child;
		}
		if( !child )
		{
			Log( "Truly lost focus and children are not gaining." );
			pm->flags.abort = TRUE;
			UnshowMenu( pm );
		}
	}
	else
	{
		if( pm && pm->selection != -1 )
		{
			Log( "Returning updated selection..." );
			UnshowMenu( pm );
			return TRUE;
		}
		else
		{
			if( !pm->flags.bSubmenuOpen )
			{
#ifdef DEBUG_MENUS
				lprintf( "Closing menu - lost focus, not to a child." );
#endif
				pm->flags.abort = 1;
				UnshowMenu( pm );
			}
		}
	}
	return TRUE;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
CONTROL_REGISTRATION menu = { "Popup Menu"
									 , { { 94, 120 }, sizeof( MENU ), BORDER_NORMAL }
 // init menu... bare control - I guess attach a device
									 , NULL
									 , NULL
			                , RenderItems
//MenuMouse
									 , NULL
 // key
									 , NULL
 // destroy
									 , NULL
 // prop_page
									 , NULL
 // apply_page
									 , NULL
 // save
									 , NULL
 // AddedControl
									 , NULL
 // caption changed
									 , NULL
 // focuschange
			                , FocusChanged
};
PRIORITY_PRELOAD( RegisterMenuPopup, PSI_PRELOAD_PRIORITY )
{
	DoRegisterControl( &menu );
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void ShowMenu( PMENU pm, int x, int y, LOGICAL bWait, PSI_CONTROL parent )
{
	int32_t cx, cy;
	int32_t dx, dy;
	PSI_CONTROL display_parent;
	if( pm->flags.showing )
	{
		lprintf( "Can only show one instance of a popup at a time." );
		return;
	}
#ifdef DEBUG_MENUS
	lprintf( "%p show menu (tracking)", pm );
#endif
	pm->flags.tracking = TRUE;
	pm->selection = -1;
	pm->flags.abort = FALSE;
 // nothing selected on initial draw...
	pm->selected = NULL;
#ifdef DEBUG_MENUS
	Log2( "ShowMenu %d,%d", x, y );
#endif
	if( pm->flags.changed )
	{
#ifdef DEBUG_MENUS
		lprintf( "Recalculate items" );
#endif
		CalculateMenuItems( pm );
	}
	if( !local_popup_data.flags.bDisplayBoundless )
	{
		GetDisplaySize( (uint32_t*)&cx, (uint32_t*)&cy );
		if( ( x + pm->width + FrameBorderX( pm->image, BORDER_NORMAL) ) >= cx )
		{
			if( pm->parent )
			{
				dx = pm->parent->display.x - pm->width;
			}
			else
			{
				dx = cx - ( pm->width  + FrameBorderX( pm->image, BORDER_NORMAL) );
			}
		}
		else
			dx = x;
		if( ( y + pm->height  + FrameBorderY( pm->image, BORDER_NORMAL, NULL) ) >= cy )
		{
			dy = cy - ( pm->height + FrameBorderY( pm->image, BORDER_NORMAL, NULL) );
		}
		else
			dy = y;
		pm->display.x = (uint16_t)dx;
		pm->display.y = (uint16_t)dy;
	}
	else
	{
		 pm->display.x = x;
		 pm->display.y = y;
	}
	MoveCommon( pm->image, pm->display.x, pm->display.y );
	if( pm->parent )
		display_parent = pm->parent->image;
	else
		display_parent = parent;
	pm->surface = pm->image->Surface;
#ifdef DEBUG_MENUS
	lprintf( "do the reveal to compliemnt the hide?" );
#endif
	//RevealCommon( pm->image );
	DisplayFrameOver( pm->image, display_parent );
#ifdef DEBUG_MENUS
	lprintf( "Popup capture capture" );
#endif
 // grab ownership again...
	CaptureCommonMouse( pm->image, 1 );
	pm->flags.showing = 1;
	// well should loop and wait for responces... guess I need
	// to invent a MouseHandler
	if( bWait )
	{
		while( pm->selection == -1 && !pm->flags.abort && pm->flags.showing )
		{
 // not a thread with work...
			if( Idle() < 0 )
			{
				WakeableSleep( SLEEP_FOREVER );
			}
		}
		if( pm->flags.showing )
			UnshowMenu( pm );
	}
}
//----------------------------------------------------------------------
#endif
// int DeleteMenu(...)
PSI_PROC( PMENUITEM, DeletePopupItem )( PMENU pm, uintptr_t dwID, uint32_t state )
{
	if( local_popup_data.flags.bCustomMenuEnable )
	{
	PMENUITEM pmi;
	pmi = pm->items;
	if( state & MF_BYPOSITION )
	{
		while( pmi && dwID )
		{
			pmi = pmi->next;
		 dwID--;
		}
		if( pmi )
		 DestroyItem( pmi );
	}
	else
	{
		while( pmi )
		{
			if( !pmi->flags.bSeparator )
			{
				if( pmi->value.ID == dwID )
				{
					DestroyItem( pmi );
					break;
				}
			}
			pmi = pmi->next;
		}
	}
   pm->flags.changed = 1;
	return 0;
	}
#if !defined( DISABLE_NATIVE_POPUPS )
	else
		return (PMENUITEM)(uintptr_t)DeleteMenu( (HMENU)pm, dwID, state );
#else
   return 0;
#endif
}
//----------------------------------------------------------------------
PSI_PROC( void, ResetPopup)( PMENU pm )
{
	if( local_popup_data.flags.bCustomMenuEnable )
	{
	if( !pm )
		return;
	if( pm->flags.tracking )
	{
		pm->flags.abort = TRUE;
		UnshowMenu( pm );
	}
	while( pm->items )
		DestroyItem( pm->items );
	}
}
//----------------------------------------------------------------------
// void DestroyMenu( HMENU );
PSI_PROC( void, DestroyPopup )( PMENU pm )
{
	if( local_popup_data.flags.bCustomMenuEnable )
	{
		if( !pm ) return;
		ResetPopup( pm );
		Release( pm );
	}
#if !defined( DISABLE_NATIVE_POPUPS )
	else
		DestroyMenu( (HMENU)pm );
#else
	return;
#endif
}
//----------------------------------------------------------------------
//HMENU GetSubMenu( HMENU, int nMenu );
PSI_PROC( void *, GetPopupData )( PMENU pm, int item )
{
	if( local_popup_data.flags.bCustomMenuEnable )
	{
		PMENUITEM pmi;
		if( !pm || item < 0 )
			return 0;
		pmi = pm->items;
		while( pmi && item--)
			pmi = pmi->next;
		if( pmi->flags.bSubMenu )
			return pmi->value.menu;
		return NULL;
	}
#if !defined( DISABLE_NATIVE_POPUPS )
	else
	{
		return GetSubMenu( (HMENU)pm, item );
	}
#else
   return NULL;
#endif
}
//----------------------------------------------------------------------
//int AppendMenu( HMENU, type, dwID, pData )
PSI_PROC( PMENUITEM, AppendPopupItem )( PMENU pm, int type, uintptr_t dwID, CPOINTER pData )
{
	if( local_popup_data.flags.bCustomMenuEnable )
	{
	PMENUITEM pmi;
	pmi = (PMENUITEM)Allocate( sizeof( MENUITEM ) );
   MemSet( pmi, 0, sizeof( MENUITEM ) );
	if( type & MF_SEPARATOR )
	{
	  pmi->flags.bSeparator = TRUE;
	}
	else if( type & MF_OWNERDRAW )
	{
	  pmi->flags.bOwnerDraw = TRUE;
		pmi->data.owner.DrawPopupItem = (DrawPopupItemProc)pData;
	  pmi->value.userdata = dwID;
	}
	else
	{
		if( pData )
		{
		 int len;
			pmi->flags.bHasText = TRUE;
			pmi->data.text.text = NewArray( TEXTCHAR, ( len = (int)( pmi->data.text.textlen = StrLen( (TEXTSTR)pData ) ) + 1));
			StrCpyEx( pmi->data.text.text, (CTEXTSTR)pData, len );
		}
		if( type & MF_POPUP )
		{
			pmi->flags.bSubMenu = TRUE;
			pmi->value.menu = (PMENU)dwID;
		}
		else
		{
			pmi->value.ID = dwID;
		}
	}
	if( type & MF_CHECKED )
	  pmi->flags.bChecked = TRUE;
	else
	  pmi->flags.bChecked = FALSE;
	{
		PMENUITEM last = pm->items;
		while( last && last->next )
			last = last->next;
		if( !last )
		{
			pm->items = pmi;
		 pmi->me = &pm->items;
		}
		else
		{
			last->next = pmi;
		 pmi->me = &last->next;
		}
	  //lprintf( "and mark changed..." );
		pm->flags.changed = TRUE;
	}
   //lprintf( "Added new menu item..." );
	return pmi;
	}
#if !defined( DISABLE_NATIVE_POPUPS )
	else
	{
	return (PMENUITEM)(uintptr_t)AppendMenu( (HMENU)pm, type, dwID,
#ifdef __cplusplus
			                    // override type cast here...
										  (TEXTCHAR const*)
#endif
										  pData );
	}
#endif
   return 0;
}
//----------------------------------------------------------------------
//int CheckMenuItem( HMENU, dwID, state )
PSI_PROC( PMENUITEM, CheckPopupItem )( PMENU pm, uintptr_t dwID, uint32_t state )
{
	if( local_popup_data.flags.bCustomMenuEnable )
	{
		PMENUITEM pmi = pm->items;
		if( !pm )
			return NULL;
#ifdef DEBUG_MENUS
		lprintf( "updating an item %" _32f " to %" _32fx, dwID, state );
#endif
	if( state & MF_BYPOSITION )
	{
		while( dwID-- && pmi )
			pmi = pmi->next;
	}
	else
	{
		while( pmi )
		{
			if( !pmi->flags.bSeparator )
			{
				if( pmi->value.ID == dwID )
				{
#ifdef DEBUG_MENUS
					lprintf( "Found item" );
#endif
					break;
				}
			}
		 pmi = pmi->next;
		}
	}
	if( pmi )
	{
		if( state & MF_CHECKED )
		{
#ifdef DEBUG_MENUS
			lprintf( "checked" );
#endif
			pmi->flags.bChecked = 1;
		}
		else
		{
#ifdef DEBUG_MENUS
			lprintf( "unchecked" );
#endif
			pmi->flags.bChecked = 0;
		}
				 if( pm->image )
				 {
#ifdef DEBUG_MENUS
					 lprintf( "update item..." );
#endif
					 RenderItem( pm, pmi );
				 }
	}
	return pmi;
	}
#if !defined( DISABLE_NATIVE_POPUPS )
	else
		return (PMENUITEM)(uintptr_t)CheckMenuItem( (HMENU)pm, dwID, state );
#else
   return 0;
#endif
}
//----------------------------------------------------------------------
struct trackerParams {
	PMENU hMenuSub; PSI_CONTROL parent; void (*callback)(uintptr_t psv, int menuStatus); uintptr_t psvParam;
};
static uintptr_t CPROC OldTrackerPopup( PTHREAD thread ) {
	uintptr_t param = GetThreadParam( thread );
	struct trackerParams* params = (struct trackerParams*)param;
	int result = TrackPopup( params->hMenuSub, params->parent );
	if( params->callback )
		params->callback( params->psvParam, result );
	Release( params );
	return 0;
}
PSI_PROC( void, TrackPopup_v2 )( PMENU hMenuSub, PSI_CONTROL parent, void (*callback)( uintptr_t psv, int menuStatus ), uintptr_t psvParam ) {
	if( local_popup_data.flags.bCustomMenuEnable )
	{
		int32_t x, y;
		if( !hMenuSub )
		{
			//Log( "Invalid menu handle." );
			callback( psvParam, -1 );
			return;
		}
		hMenuSub->callback = callback;
		hMenuSub->psvParam = psvParam;
		//GetMousePosition( &x, &y );
		GetMouseState( &x, &y, &last_buttons );
#ifdef DEBUG_MENUS
		lprintf( "Mouse position: %" _32fs ", %" _32fs " %p is the menu", x, y, hMenuSub );
#endif
		if( hMenuSub->flags.showing || hMenuSub->flags.tracking )
		{
#ifdef DEBUG_MENUS
			if( hMenuSub->flags.showing )
				Log( "Already showing menu..." );
			if( hMenuSub->flags.tracking )
				Log( "Already tracking the menu..." );
#endif
			callback( psvParam, -1 );
			return;
		}
		hMenuSub->parent = NULL;
		hMenuSub->child = NULL;
		ShowMenu( hMenuSub, x, y, FALSE, parent );
		//selection = (int)hMenuSub->selection;
#ifdef DEBUG_MENUS
		Log1( "Track popup return selection:%p %d", hMenuSub, hMenuSub->selection );
#endif
	}
	else {
		struct trackerParams* params = New( struct trackerParams );
		params->hMenuSub = hMenuSub;
		params->parent = parent;
		params->callback = callback;
		params->psvParam = psvParam;
		ThreadTo( OldTrackerPopup, (uintptr_t)params );
	}
}
PSI_PROC( int, TrackPopup )( PMENU hMenuSub, PSI_CONTROL parent )
{
	//lprintf( "TRACK POPUP IS DEPRECAED, USE CALLBACK VERSION INSTAEAD" );
	if( local_popup_data.flags.bCustomMenuEnable )
	{
		int32_t x, y;
		int selection;
		if( !hMenuSub )
		{
			Log( "Invalid menu handle." );
			return -1;
		}
		//GetMousePosition( &x, &y );
		GetMouseState( &x, &y, &last_buttons );
#ifdef DEBUG_MENUS
		lprintf( "Mouse position: %" _32fs ", %" _32fs " %p is the menu", x, y, hMenuSub );
#endif
		if( hMenuSub->flags.showing || hMenuSub->flags.tracking )
		{
#ifdef DEBUG_MENUS
			if( hMenuSub->flags.showing )
				Log( "Already showing menu..." );
			if( hMenuSub->flags.tracking )
				Log( "Already tracking the menu..." );
#endif
			return -1;
		}
		hMenuSub->parent = NULL;
		hMenuSub->child = NULL;
		ShowMenu( hMenuSub, x, y, TRUE, parent );
#ifdef DEBUG_MENUS
		lprintf( "Result of selection is: %d", hMenuSub->selection );
#endif
		selection = (int)hMenuSub->selection;
#ifdef DEBUG_MENUS
		Log1( "Track popup return selection: %d", selection );
#endif
		return selection;
	}
#if !defined( DISABLE_NATIVE_POPUPS )
	else
	{
		// this member shall be external... we need
		// knowledge of the porition of control which
		// is invoking this popup....
		HWND hWndLastFocus = GetActiveWindow();
		PRENDERER r = GetFrameRenderer( parent );
		int nCmd;
		POINT p;
#ifdef WIN32
		if( r )
			hWndLastFocus = (HWND)GetNativeHandle( r );
#endif
		GetCursorPos( &p );
		/*
		 #define TPM_CENTERALIGN	4
		 #define TPM_LEFTALIGN	0
		 #define TPM_RIGHTALIGN	8
		 #define TPM_LEFTBUTTON	0
		 #define TPM_RIGHTBUTTON	2
		 #define TPM_HORIZONTAL	0
		 #define TPM_VERTICAL	64
		 #define TPM_VCENTERALIGN 16
		 #define TPM_BOTTOMALIGN 32
		 */
#ifndef TPM_TOPALIGN
#define TPM_TOPALIGN 0
#endif
#ifndef TPM_NONOTIFY
#define TPM_NONOTIFY 128
#endif
#ifndef TPM_RETURNCMD
#define TPM_RETURNCMD 256
#endif
#ifdef UNDER_CE
#define TPM_RIGHTBUTTON 0
#endif
		nCmd = TrackPopupMenu( (HMENU)hMenuSub, TPM_CENTERALIGN
									 | TPM_TOPALIGN
									 | TPM_RETURNCMD
									 | TPM_RIGHTBUTTON
									 | TPM_NONOTIFY
									,p.x
									,p.y
									,0
									, hWndLastFocus
									, NULL);
		if( !nCmd ) {
			lprintf( "Canceled or was an error: %d", GetLastError() );
		}
		// hWndController	//("This line must be handled with a good window handle...\n") )
 // In my world.... 0 means in process, -1 is selected nothing, so we have to translate no selection
		if( nCmd == 0 )
			nCmd = -1;
		return nCmd;
	}
#endif
   return -1;
}
PSI_MENU_NAMESPACE_END
//--------------------------------------------
/* Copyright (c) 1998, 1999, 2000 Thai Open Source Software Center Ltd
   See the file COPYING for copying permission.
*/
#ifndef Expat_INCLUDED
#define Expat_INCLUDED 1
#ifdef __VMS
/*      0        1         2         3      0        1         2         3
        1234567890123456789012345678901     1234567890123456789012345678901 */
#define XML_SetProcessingInstructionHandler XML_SetProcessingInstrHandler
#define XML_SetUnparsedEntityDeclHandler    XML_SetUnparsedEntDeclHandler
#define XML_SetStartNamespaceDeclHandler    XML_SetStartNamespcDeclHandler
#define XML_SetExternalEntityRefHandlerArg  XML_SetExternalEntRefHandlerArg
#endif
/* Copyright (c) 1998, 1999, 2000 Thai Open Source Software Center Ltd
   See the file COPYING for copying permission.
*/
#ifndef Expat_External_INCLUDED
#define Expat_External_INCLUDED 1
/* External API definitions */
/* Expat tries very hard to make the API boundary very specifically
   defined.  There are two macros defined to control this boundary;
   each of these can be defined before including this header to
   achieve some different behavior, but doing so it not recommended or
   tested frequently.
   XMLCALL    - The calling convention to use for all calls across the
                "library boundary."  This will default to cdecl, and
                try really hard to tell the compiler that's what we
                want.
   XMLIMPORT  - Whatever magic is needed to note that a function is
                to be imported from a dynamically loaded library
                (.dll, .so, or .sl, depending on your platform).
   The XMLCALL macro was added in Expat 1.95.7.  The only one which is
   expected to be directly useful in client code is XMLCALL.
   Note that on at least some Unix versions, the Expat library must be
   compiled with the cdecl calling convention as the default since
   system headers may assume the cdecl convention.
*/
#ifndef XMLCALL
#if defined(_MSC_VER) || defined( __WATCOMC__ )
#define XMLCALL __cdecl
#elif defined(__GNUC__) && defined(__i386) && !defined(__INTEL_COMPILER)
#define XMLCALL __attribute__((cdecl))
#else
/* For any platform which uses this definition and supports more than
   one calling convention, we need to extend this definition to
   declare the convention used on that platform, if it's possible to
   do so.
   If this is the case for your platform, please file a bug report
   with information on how to identify your platform via the C
   pre-processor and how to specify the same calling convention as the
   platform's malloc() implementation.
*/
#define XMLCALL
#endif
#endif
#if !defined(XML_STATIC) && !defined(XMLIMPORT)
#ifndef XML_BUILDING_EXPAT
/* using Expat from an application */
#ifdef XML_USE_MSC_EXTENSIONS
#define XMLIMPORT __declspec(dllimport)
#endif
#endif
#endif
/* If we didn't define it above, define it away: */
#ifndef XMLIMPORT
#ifdef SEXPAT_SOURCE
#define XMLIMPORT EXPORT_METHOD
#else
#define XMLIMPORT IMPORT_METHOD
#endif
#endif
#define XMLPARSEAPI(type) XMLIMPORT type XMLCALL
#ifdef __cplusplus
extern "C" {
#endif
#ifdef XML_UNICODE_WCHAR_T
#define XML_UNICODE
#endif
#ifdef XML_UNICODE
#ifdef XML_UNICODE_WCHAR_T
typedef wchar_t XML_Char;
typedef wchar_t XML_LChar;
#else
typedef unsigned short XML_Char;
typedef char XML_LChar;
#endif
#else
typedef char XML_Char;
typedef char XML_LChar;
#endif
#ifdef XML_LARGE_SIZE
#if defined(XML_USE_MSC_EXTENSIONS) && _MSC_VER < 1400
typedef __int64 XML_Index;
typedef unsigned __int64 XML_Size;
#else
typedef long long XML_Index;
typedef unsigned long long XML_Size;
#endif
#else
typedef long XML_Index;
typedef unsigned long XML_Size;
#endif
#ifdef __cplusplus
}
#endif
#endif
#ifdef __cplusplus
extern "C" {
#endif
struct XML_ParserStruct;
typedef struct XML_ParserStruct *XML_Parser;
/* Should this be defined using stdbool.h when C99 is available? */
typedef unsigned char XML_Bool;
#define XML_TRUE   ((XML_Bool) 1)
#define XML_FALSE  ((XML_Bool) 0)
/* The XML_Status enum gives the possible return values for several
   API functions.  The preprocessor #defines are included so this
   stanza can be added to code that still needs to support older
   versions of Expat 1.95.x:
   #ifndef XML_STATUS_OK
   #define XML_STATUS_OK    1
   #define XML_STATUS_ERROR 0
   #endif
   Otherwise, the #define hackery is quite ugly and would have been
   dropped.
*/
enum XML_Status {
  XML_STATUS_ERROR = 0,
#define XML_STATUS_ERROR XML_STATUS_ERROR
  XML_STATUS_OK = 1,
#define XML_STATUS_OK XML_STATUS_OK
  XML_STATUS_SUSPENDED = 2
#define XML_STATUS_SUSPENDED XML_STATUS_SUSPENDED
};
enum XML_Error {
  XML_ERROR_NONE,
  XML_ERROR_NO_MEMORY,
  XML_ERROR_SYNTAX,
  XML_ERROR_NO_ELEMENTS,
  XML_ERROR_INVALID_TOKEN,
  XML_ERROR_UNCLOSED_TOKEN,
  XML_ERROR_PARTIAL_CHAR,
  XML_ERROR_TAG_MISMATCH,
  XML_ERROR_DUPLICATE_ATTRIBUTE,
  XML_ERROR_JUNK_AFTER_DOC_ELEMENT,
  XML_ERROR_PARAM_ENTITY_REF,
  XML_ERROR_UNDEFINED_ENTITY,
  XML_ERROR_RECURSIVE_ENTITY_REF,
  XML_ERROR_ASYNC_ENTITY,
  XML_ERROR_BAD_CHAR_REF,
  XML_ERROR_BINARY_ENTITY_REF,
  XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF,
  XML_ERROR_MISPLACED_XML_PI,
  XML_ERROR_UNKNOWN_ENCODING,
  XML_ERROR_INCORRECT_ENCODING,
  XML_ERROR_UNCLOSED_CDATA_SECTION,
  XML_ERROR_EXTERNAL_ENTITY_HANDLING,
  XML_ERROR_NOT_STANDALONE,
  XML_ERROR_UNEXPECTED_STATE,
  XML_ERROR_ENTITY_DECLARED_IN_PE,
  XML_ERROR_FEATURE_REQUIRES_XML_DTD,
  XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING,
  /* Added in 1.95.7. */
  XML_ERROR_UNBOUND_PREFIX,
  /* Added in 1.95.8. */
  XML_ERROR_UNDECLARING_PREFIX,
  XML_ERROR_INCOMPLETE_PE,
  XML_ERROR_XML_DECL,
  XML_ERROR_TEXT_DECL,
  XML_ERROR_PUBLICID,
  XML_ERROR_SUSPENDED,
  XML_ERROR_NOT_SUSPENDED,
  XML_ERROR_ABORTED,
  XML_ERROR_FINISHED,
  XML_ERROR_SUSPEND_PE,
  /* Added in 2.0. */
  XML_ERROR_RESERVED_PREFIX_XML,
  XML_ERROR_RESERVED_PREFIX_XMLNS,
  XML_ERROR_RESERVED_NAMESPACE_URI
};
enum XML_Content_Type {
  XML_CTYPE_EMPTY = 1,
  XML_CTYPE_ANY,
  XML_CTYPE_MIXED,
  XML_CTYPE_NAME,
  XML_CTYPE_CHOICE,
  XML_CTYPE_SEQ
};
enum XML_Content_Quant {
  XML_CQUANT_NONE,
  XML_CQUANT_OPT,
  XML_CQUANT_REP,
  XML_CQUANT_PLUS
};
/* If type == XML_CTYPE_EMPTY or XML_CTYPE_ANY, then quant will be
   XML_CQUANT_NONE, and the other fields will be zero or NULL.
   If type == XML_CTYPE_MIXED, then quant will be NONE or REP and
   numchildren will contain number of elements that may be mixed in
   and children point to an array of XML_Content cells that will be
   all of XML_CTYPE_NAME type with no quantification.
   If type == XML_CTYPE_NAME, then the name points to the name, and
   the numchildren field will be zero and children will be NULL. The
   quant fields indicates any quantifiers placed on the name.
   CHOICE and SEQ will have name NULL, the number of children in
   numchildren and children will point, recursively, to an array
   of XML_Content cells.
   The EMPTY, ANY, and MIXED types will only occur at top level.
*/
typedef struct XML_cp XML_Content;
struct XML_cp {
  enum XML_Content_Type         type;
  enum XML_Content_Quant        quant;
  XML_Char *                    name;
  unsigned int                  numchildren;
  XML_Content *                 children;
};
/* This is called for an element declaration. See above for
   description of the model argument. It's the caller's responsibility
   to free model when finished with it.
*/
typedef void (XMLCALL *XML_ElementDeclHandler) (void *userData,
                                                const XML_Char *name,
                                                XML_Content *model);
XMLPARSEAPI(void)
XML_SetElementDeclHandler(XML_Parser parser,
                          XML_ElementDeclHandler eldecl);
/* The Attlist declaration handler is called for *each* attribute. So
   a single Attlist declaration with multiple attributes declared will
   generate multiple calls to this handler. The "default" parameter
   may be NULL in the case of the "#IMPLIED" or "#REQUIRED"
   keyword. The "isrequired" parameter will be true and the default
   value will be NULL in the case of "#REQUIRED". If "isrequired" is
   true and default is non-NULL, then this is a "#FIXED" default.
*/
typedef void (XMLCALL *XML_AttlistDeclHandler) (
                                    void            *userData,
                                    const XML_Char  *elname,
                                    const XML_Char  *attname,
                                    const XML_Char  *att_type,
                                    const XML_Char  *dflt,
                                    int              isrequired);
XMLPARSEAPI(void)
XML_SetAttlistDeclHandler(XML_Parser parser,
                          XML_AttlistDeclHandler attdecl);
/* The XML declaration handler is called for *both* XML declarations
   and text declarations. The way to distinguish is that the version
   parameter will be NULL for text declarations. The encoding
   parameter may be NULL for XML declarations. The standalone
   parameter will be -1, 0, or 1 indicating respectively that there
   was no standalone parameter in the declaration, that it was given
   as no, or that it was given as yes.
*/
typedef void (XMLCALL *XML_XmlDeclHandler) (void           *userData,
                                            const XML_Char *version,
                                            const XML_Char *encoding,
                                            int             standalone);
XMLPARSEAPI(void)
XML_SetXmlDeclHandler(XML_Parser parser,
                      XML_XmlDeclHandler xmldecl);
typedef struct {
  void *(*malloc_fcn)(size_t size);
  void *(*realloc_fcn)(void *ptr, size_t size);
  void (*free_fcn)(void *ptr);
} XML_Memory_Handling_Suite;
/* Constructs a new parser; encoding is the encoding specified by the
   external protocol or NULL if there is none specified.
*/
XMLPARSEAPI(XML_Parser)
XML_ParserCreate(const XML_Char *encoding);
/* Constructs a new parser and namespace processor.  Element type
   names and attribute names that belong to a namespace will be
   expanded; unprefixed attribute names are never expanded; unprefixed
   element type names are expanded only if there is a default
   namespace. The expanded name is the concatenation of the namespace
   URI, the namespace separator character, and the local part of the
   name.  If the namespace separator is '\0' then the namespace URI
   and the local part will be concatenated without any separator.
   It is a programming error to use the separator '\0' with namespace
   triplets (see XML_SetReturnNSTriplet).
*/
XMLPARSEAPI(XML_Parser)
XML_ParserCreateNS(const XML_Char *encoding, XML_Char namespaceSeparator);
/* Constructs a new parser using the memory management suite referred to
   by memsuite. If memsuite is NULL, then use the standard library memory
   suite. If namespaceSeparator is non-NULL it creates a parser with
   namespace processing as described above. The character pointed at
   will serve as the namespace separator.
   All further memory operations used for the created parser will come from
   the given suite.
*/
XMLPARSEAPI(XML_Parser)
XML_ParserCreate_MM(const XML_Char *encoding,
                    const XML_Memory_Handling_Suite *memsuite,
                    const XML_Char *namespaceSeparator);
/* Prepare a parser object to be re-used.  This is particularly
   valuable when memory allocation overhead is disproportionatly high,
   such as when a large number of small documnents need to be parsed.
   All handlers are cleared from the parser, except for the
   unknownEncodingHandler. The parser's external state is re-initialized
   except for the values of ns and ns_triplets.
   Added in Expat 1.95.3.
*/
XMLPARSEAPI(XML_Bool)
XML_ParserReset(XML_Parser parser, const XML_Char *encoding);
/* atts is array of name/value pairs, terminated by 0;
   names and values are 0 terminated.
*/
typedef void (XMLCALL *XML_StartElementHandler) (void *userData,
                                                 const XML_Char *name,
                                                 const XML_Char **atts);
typedef void (XMLCALL *XML_EndElementHandler) (void *userData,
                                               const XML_Char *name);
/* s is not 0 terminated. */
typedef void (XMLCALL *XML_CharacterDataHandler) (void *userData,
                                                  const XML_Char *s,
                                                  int len);
/* target and data are 0 terminated */
typedef void (XMLCALL *XML_ProcessingInstructionHandler) (
                                                void *userData,
                                                const XML_Char *target,
                                                const XML_Char *data);
/* data is 0 terminated */
typedef void (XMLCALL *XML_CommentHandler) (void *userData,
                                            const XML_Char *data);
typedef void (XMLCALL *XML_StartCdataSectionHandler) (void *userData);
typedef void (XMLCALL *XML_EndCdataSectionHandler) (void *userData);
/* This is called for any characters in the XML document for which
   there is no applicable handler.  This includes both characters that
   are part of markup which is of a kind that is not reported
   (comments, markup declarations), or characters that are part of a
   construct which could be reported but for which no handler has been
   supplied. The characters are passed exactly as they were in the XML
   document except that they will be encoded in UTF-8 or UTF-16.
   Line boundaries are not normalized. Note that a byte order mark
   character is not passed to the default handler. There are no
   guarantees about how characters are divided between calls to the
   default handler: for example, a comment might be split between
   multiple calls.
*/
typedef void (XMLCALL *XML_DefaultHandler) (void *userData,
                                            const XML_Char *s,
                                            int len);
/* This is called for the start of the DOCTYPE declaration, before
   any DTD or internal subset is parsed.
*/
typedef void (XMLCALL *XML_StartDoctypeDeclHandler) (
                                            void *userData,
                                            const XML_Char *doctypeName,
                                            const XML_Char *sysid,
                                            const XML_Char *pubid,
                                            int has_internal_subset);
/* This is called for the start of the DOCTYPE declaration when the
   closing > is encountered, but after processing any external
   subset.
*/
typedef void (XMLCALL *XML_EndDoctypeDeclHandler)(void *userData);
/* This is called for entity declarations. The is_parameter_entity
   argument will be non-zero if the entity is a parameter entity, zero
   otherwise.
   For internal entities (<!ENTITY foo "bar">), value will
   be non-NULL and systemId, publicID, and notationName will be NULL.
   The value string is NOT nul-terminated; the length is provided in
   the value_length argument. Since it is legal to have zero-length
   values, do not use this argument to test for internal entities.
   For external entities, value will be NULL and systemId will be
   non-NULL. The publicId argument will be NULL unless a public
   identifier was provided. The notationName argument will have a
   non-NULL value only for unparsed entity declarations.
   Note that is_parameter_entity can't be changed to XML_Bool, since
   that would break binary compatibility.
*/
typedef void (XMLCALL *XML_EntityDeclHandler) (
                              void *userData,
                              const XML_Char *entityName,
                              int is_parameter_entity,
                              const XML_Char *value,
                              int value_length,
                              const XML_Char *base,
                              const XML_Char *systemId,
                              const XML_Char *publicId,
                              const XML_Char *notationName);
XMLPARSEAPI(void)
XML_SetEntityDeclHandler(XML_Parser parser,
                         XML_EntityDeclHandler handler);
/* OBSOLETE -- OBSOLETE -- OBSOLETE
   This handler has been superceded by the EntityDeclHandler above.
   It is provided here for backward compatibility.
   This is called for a declaration of an unparsed (NDATA) entity.
   The base argument is whatever was set by XML_SetBase. The
   entityName, systemId and notationName arguments will never be
   NULL. The other arguments may be.
*/
typedef void (XMLCALL *XML_UnparsedEntityDeclHandler) (
                                    void *userData,
                                    const XML_Char *entityName,
                                    const XML_Char *base,
                                    const XML_Char *systemId,
                                    const XML_Char *publicId,
                                    const XML_Char *notationName);
/* This is called for a declaration of notation.  The base argument is
   whatever was set by XML_SetBase. The notationName will never be
   NULL.  The other arguments can be.
*/
typedef void (XMLCALL *XML_NotationDeclHandler) (
                                    void *userData,
                                    const XML_Char *notationName,
                                    const XML_Char *base,
                                    const XML_Char *systemId,
                                    const XML_Char *publicId);
/* When namespace processing is enabled, these are called once for
   each namespace declaration. The call to the start and end element
   handlers occur between the calls to the start and end namespace
   declaration handlers. For an xmlns attribute, prefix will be
   NULL.  For an xmlns="" attribute, uri will be NULL.
*/
typedef void (XMLCALL *XML_StartNamespaceDeclHandler) (
                                    void *userData,
                                    const XML_Char *prefix,
                                    const XML_Char *uri);
typedef void (XMLCALL *XML_EndNamespaceDeclHandler) (
                                    void *userData,
                                    const XML_Char *prefix);
/* This is called if the document is not standalone, that is, it has an
   external subset or a reference to a parameter entity, but does not
   have standalone="yes". If this handler returns XML_STATUS_ERROR,
   then processing will not continue, and the parser will return a
   XML_ERROR_NOT_STANDALONE error.
   If parameter entity parsing is enabled, then in addition to the
   conditions above this handler will only be called if the referenced
   entity was actually read.
*/
typedef int (XMLCALL *XML_NotStandaloneHandler) (void *userData);
/* This is called for a reference to an external parsed general
   entity.  The referenced entity is not automatically parsed.  The
   application can parse it immediately or later using
   XML_ExternalEntityParserCreate.
   The parser argument is the parser parsing the entity containing the
   reference; it can be passed as the parser argument to
   XML_ExternalEntityParserCreate.  The systemId argument is the
   system identifier as specified in the entity declaration; it will
   not be NULL.
   The base argument is the system identifier that should be used as
   the base for resolving systemId if systemId was relative; this is
   set by XML_SetBase; it may be NULL.
   The publicId argument is the public identifier as specified in the
   entity declaration, or NULL if none was specified; the whitespace
   in the public identifier will have been normalized as required by
   the XML spec.
   The context argument specifies the parsing context in the format
   expected by the context argument to XML_ExternalEntityParserCreate;
   context is valid only until the handler returns, so if the
   referenced entity is to be parsed later, it must be copied.
   context is NULL only when the entity is a parameter entity.
   The handler should return XML_STATUS_ERROR if processing should not
   continue because of a fatal error in the handling of the external
   entity.  In this case the calling parser will return an
   XML_ERROR_EXTERNAL_ENTITY_HANDLING error.
   Note that unlike other handlers the first argument is the parser,
   not userData.
*/
typedef int (XMLCALL *XML_ExternalEntityRefHandler) (
                                    XML_Parser parser,
                                    const XML_Char *context,
                                    const XML_Char *base,
                                    const XML_Char *systemId,
                                    const XML_Char *publicId);
/* This is called in two situations:
   1) An entity reference is encountered for which no declaration
      has been read *and* this is not an error.
   2) An internal entity reference is read, but not expanded, because
      XML_SetDefaultHandler has been called.
   Note: skipped parameter entities in declarations and skipped general
         entities in attribute values cannot be reported, because
         the event would be out of sync with the reporting of the
         declarations or attribute values
*/
typedef void (XMLCALL *XML_SkippedEntityHandler) (
                                    void *userData,
                                    const XML_Char *entityName,
                                    int is_parameter_entity);
/* This structure is filled in by the XML_UnknownEncodingHandler to
   provide information to the parser about encodings that are unknown
   to the parser.
   The map[b] member gives information about byte sequences whose
   first byte is b.
   If map[b] is c where c is >= 0, then b by itself encodes the
   Unicode scalar value c.
   If map[b] is -1, then the byte sequence is malformed.
   If map[b] is -n, where n >= 2, then b is the first byte of an
   n-byte sequence that encodes a single Unicode scalar value.
   The data member will be passed as the first argument to the convert
   function.
   The convert function is used to convert multibyte sequences; s will
   point to a n-byte sequence where map[(unsigned char)*s] == -n.  The
   convert function must return the Unicode scalar value represented
   by this byte sequence or -1 if the byte sequence is malformed.
   The convert function may be NULL if the encoding is a single-byte
   encoding, that is if map[b] >= -1 for all bytes b.
   When the parser is finished with the encoding, then if release is
   not NULL, it will call release passing it the data member; once
   release has been called, the convert function will not be called
   again.
   Expat places certain restrictions on the encodings that are supported
   using this mechanism.
   1. Every ASCII character that can appear in a well-formed XML document,
      other than the characters
      $@\^`{}~
      must be represented by a single byte, and that byte must be the
      same byte that represents that character in ASCII.
   2. No character may require more than 4 bytes to encode.
   3. All characters encoded must have Unicode scalar values <=
      0xFFFF, (i.e., characters that would be encoded by surrogates in
      UTF-16 are  not allowed).  Note that this restriction doesn't
      apply to the built-in support for UTF-8 and UTF-16.
   4. No Unicode character may be encoded by more than one distinct
      sequence of bytes.
*/
typedef struct {
  int map[256];
  void *data;
  int (XMLCALL *convert)(void *data, const char *s);
  void (XMLCALL *release)(void *data);
} XML_Encoding;
/* This is called for an encoding that is unknown to the parser.
   The encodingHandlerData argument is that which was passed as the
   second argument to XML_SetUnknownEncodingHandler.
   The name argument gives the name of the encoding as specified in
   the encoding declaration.
   If the callback can provide information about the encoding, it must
   fill in the XML_Encoding structure, and return XML_STATUS_OK.
   Otherwise it must return XML_STATUS_ERROR.
   If info does not describe a suitable encoding, then the parser will
   return an XML_UNKNOWN_ENCODING error.
*/
typedef int (XMLCALL *XML_UnknownEncodingHandler) (
                                    void *encodingHandlerData,
                                    const XML_Char *name,
                                    XML_Encoding *info);
XMLPARSEAPI(void)
XML_SetElementHandler(XML_Parser parser,
                      XML_StartElementHandler start,
                      XML_EndElementHandler end);
XMLPARSEAPI(void)
XML_SetStartElementHandler(XML_Parser parser,
                           XML_StartElementHandler handler);
XMLPARSEAPI(void)
XML_SetEndElementHandler(XML_Parser parser,
                         XML_EndElementHandler handler);
XMLPARSEAPI(void)
XML_SetCharacterDataHandler(XML_Parser parser,
                            XML_CharacterDataHandler handler);
XMLPARSEAPI(void)
XML_SetProcessingInstructionHandler(XML_Parser parser,
                                    XML_ProcessingInstructionHandler handler);
XMLPARSEAPI(void)
XML_SetCommentHandler(XML_Parser parser,
                      XML_CommentHandler handler);
XMLPARSEAPI(void)
XML_SetCdataSectionHandler(XML_Parser parser,
                           XML_StartCdataSectionHandler start,
                           XML_EndCdataSectionHandler end);
XMLPARSEAPI(void)
XML_SetStartCdataSectionHandler(XML_Parser parser,
                                XML_StartCdataSectionHandler start);
XMLPARSEAPI(void)
XML_SetEndCdataSectionHandler(XML_Parser parser,
                              XML_EndCdataSectionHandler end);
/* This sets the default handler and also inhibits expansion of
   internal entities. These entity references will be passed to the
   default handler, or to the skipped entity handler, if one is set.
*/
XMLPARSEAPI(void)
XML_SetDefaultHandler(XML_Parser parser,
                      XML_DefaultHandler handler);
/* This sets the default handler but does not inhibit expansion of
   internal entities.  The entity reference will not be passed to the
   default handler.
*/
XMLPARSEAPI(void)
XML_SetDefaultHandlerExpand(XML_Parser parser,
                            XML_DefaultHandler handler);
XMLPARSEAPI(void)
XML_SetDoctypeDeclHandler(XML_Parser parser,
                          XML_StartDoctypeDeclHandler start,
                          XML_EndDoctypeDeclHandler end);
XMLPARSEAPI(void)
XML_SetStartDoctypeDeclHandler(XML_Parser parser,
                               XML_StartDoctypeDeclHandler start);
XMLPARSEAPI(void)
XML_SetEndDoctypeDeclHandler(XML_Parser parser,
                             XML_EndDoctypeDeclHandler end);
XMLPARSEAPI(void)
XML_SetUnparsedEntityDeclHandler(XML_Parser parser,
                                 XML_UnparsedEntityDeclHandler handler);
XMLPARSEAPI(void)
XML_SetNotationDeclHandler(XML_Parser parser,
                           XML_NotationDeclHandler handler);
XMLPARSEAPI(void)
XML_SetNamespaceDeclHandler(XML_Parser parser,
                            XML_StartNamespaceDeclHandler start,
                            XML_EndNamespaceDeclHandler end);
XMLPARSEAPI(void)
XML_SetStartNamespaceDeclHandler(XML_Parser parser,
                                 XML_StartNamespaceDeclHandler start);
XMLPARSEAPI(void)
XML_SetEndNamespaceDeclHandler(XML_Parser parser,
                               XML_EndNamespaceDeclHandler end);
XMLPARSEAPI(void)
XML_SetNotStandaloneHandler(XML_Parser parser,
                            XML_NotStandaloneHandler handler);
XMLPARSEAPI(void)
XML_SetExternalEntityRefHandler(XML_Parser parser,
                                XML_ExternalEntityRefHandler handler);
/* If a non-NULL value for arg is specified here, then it will be
   passed as the first argument to the external entity ref handler
   instead of the parser object.
*/
XMLPARSEAPI(void)
XML_SetExternalEntityRefHandlerArg(XML_Parser parser,
                                   void *arg);
XMLPARSEAPI(void)
XML_SetSkippedEntityHandler(XML_Parser parser,
                            XML_SkippedEntityHandler handler);
XMLPARSEAPI(void)
XML_SetUnknownEncodingHandler(XML_Parser parser,
                              XML_UnknownEncodingHandler handler,
                              void *encodingHandlerData);
/* This can be called within a handler for a start element, end
   element, processing instruction or character data.  It causes the
   corresponding markup to be passed to the default handler.
*/
XMLPARSEAPI(void)
XML_DefaultCurrent(XML_Parser parser);
/* If do_nst is non-zero, and namespace processing is in effect, and
   a name has a prefix (i.e. an explicit namespace qualifier) then
   that name is returned as a triplet in a single string separated by
   the separator character specified when the parser was created: URI
   + sep + local_name + sep + prefix.
   If do_nst is zero, then namespace information is returned in the
   default manner (URI + sep + local_name) whether or not the name
   has a prefix.
   Note: Calling XML_SetReturnNSTriplet after XML_Parse or
     XML_ParseBuffer has no effect.
*/
XMLPARSEAPI(void)
XML_SetReturnNSTriplet(XML_Parser parser, int do_nst);
/* This value is passed as the userData argument to callbacks. */
XMLPARSEAPI(void)
XML_SetUserData(XML_Parser parser, void *userData);
/* Returns the last value set by XML_SetUserData or NULL. */
#define XML_GetUserData(parser) (*(void **)(parser))
/* This is equivalent to supplying an encoding argument to
   XML_ParserCreate. On success XML_SetEncoding returns non-zero,
   zero otherwise.
   Note: Calling XML_SetEncoding after XML_Parse or XML_ParseBuffer
     has no effect and returns XML_STATUS_ERROR.
*/
XMLPARSEAPI(enum XML_Status)
XML_SetEncoding(XML_Parser parser, const XML_Char *encoding);
/* If this function is called, then the parser will be passed as the
   first argument to callbacks instead of userData.  The userData will
   still be accessible using XML_GetUserData.
*/
XMLPARSEAPI(void)
XML_UseParserAsHandlerArg(XML_Parser parser);
/* If useDTD == XML_TRUE is passed to this function, then the parser
   will assume that there is an external subset, even if none is
   specified in the document. In such a case the parser will call the
   externalEntityRefHandler with a value of NULL for the systemId
   argument (the publicId and context arguments will be NULL as well).
   Note: For the purpose of checking WFC: Entity Declared, passing
     useDTD == XML_TRUE will make the parser behave as if the document
     had a DTD with an external subset.
   Note: If this function is called, then this must be done before
     the first call to XML_Parse or XML_ParseBuffer, since it will
     have no effect after that.  Returns
     XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING.
   Note: If the document does not have a DOCTYPE declaration at all,
     then startDoctypeDeclHandler and endDoctypeDeclHandler will not
     be called, despite an external subset being parsed.
   Note: If XML_DTD is not defined when Expat is compiled, returns
     XML_ERROR_FEATURE_REQUIRES_XML_DTD.
*/
XMLPARSEAPI(enum XML_Error)
XML_UseForeignDTD(XML_Parser parser, XML_Bool useDTD);
/* Sets the base to be used for resolving relative URIs in system
   identifiers in declarations.  Resolving relative identifiers is
   left to the application: this value will be passed through as the
   base argument to the XML_ExternalEntityRefHandler,
   XML_NotationDeclHandler and XML_UnparsedEntityDeclHandler. The base
   argument will be copied.  Returns XML_STATUS_ERROR if out of memory,
   XML_STATUS_OK otherwise.
*/
XMLPARSEAPI(enum XML_Status)
XML_SetBase(XML_Parser parser, const XML_Char *base);
XMLPARSEAPI(const XML_Char *)
XML_GetBase(XML_Parser parser);
/* Returns the number of the attribute/value pairs passed in last call
   to the XML_StartElementHandler that were specified in the start-tag
   rather than defaulted. Each attribute/value pair counts as 2; thus
   this correspondds to an index into the atts array passed to the
   XML_StartElementHandler.
*/
XMLPARSEAPI(int)
XML_GetSpecifiedAttributeCount(XML_Parser parser);
/* Returns the index of the ID attribute passed in the last call to
   XML_StartElementHandler, or -1 if there is no ID attribute.  Each
   attribute/value pair counts as 2; thus this correspondds to an
   index into the atts array passed to the XML_StartElementHandler.
*/
XMLPARSEAPI(int)
XML_GetIdAttributeIndex(XML_Parser parser);
/* Parses some input. Returns XML_STATUS_ERROR if a fatal error is
   detected.  The last call to XML_Parse must have isFinal true; len
   may be zero for this call (or any other).
   Though the return values for these functions has always been
   described as a Boolean value, the implementation, at least for the
   1.95.x series, has always returned exactly one of the XML_Status
   values.
*/
XMLPARSEAPI(enum XML_Status)
XML_Parse(XML_Parser parser, const char *s, int len, int isFinal);
XMLPARSEAPI(void *)
XML_GetBuffer(XML_Parser parser, size_t len);
XMLPARSEAPI(enum XML_Status)
XML_ParseBuffer(XML_Parser parser, size_t len, int isFinal);
/* Stops parsing, causing XML_Parse() or XML_ParseBuffer() to return.
   Must be called from within a call-back handler, except when aborting
   (resumable = 0) an already suspended parser. Some call-backs may
   still follow because they would otherwise get lost. Examples:
   - endElementHandler() for empty elements when stopped in
     startElementHandler(),
   - endNameSpaceDeclHandler() when stopped in endElementHandler(),
   and possibly others.
   Can be called from most handlers, including DTD related call-backs,
   except when parsing an external parameter entity and resumable != 0.
   Returns XML_STATUS_OK when successful, XML_STATUS_ERROR otherwise.
   Possible error codes:
   - XML_ERROR_SUSPENDED: when suspending an already suspended parser.
   - XML_ERROR_FINISHED: when the parser has already finished.
   - XML_ERROR_SUSPEND_PE: when suspending while parsing an external PE.
   When resumable != 0 (true) then parsing is suspended, that is,
   XML_Parse() and XML_ParseBuffer() return XML_STATUS_SUSPENDED.
   Otherwise, parsing is aborted, that is, XML_Parse() and XML_ParseBuffer()
   return XML_STATUS_ERROR with error code XML_ERROR_ABORTED.
   *Note*:
   This will be applied to the current parser instance only, that is, if
   there is a parent parser then it will continue parsing when the
   externalEntityRefHandler() returns. It is up to the implementation of
   the externalEntityRefHandler() to call XML_StopParser() on the parent
   parser (recursively), if one wants to stop parsing altogether.
   When suspended, parsing can be resumed by calling XML_ResumeParser().
*/
XMLPARSEAPI(enum XML_Status)
XML_StopParser(XML_Parser parser, XML_Bool resumable);
/* Resumes parsing after it has been suspended with XML_StopParser().
   Must not be called from within a handler call-back. Returns same
   status codes as XML_Parse() or XML_ParseBuffer().
   Additional error code XML_ERROR_NOT_SUSPENDED possible.
   *Note*:
   This must be called on the most deeply nested child parser instance
   first, and on its parent parser only after the child parser has finished,
   to be applied recursively until the document entity's parser is restarted.
   That is, the parent parser will not resume by itself and it is up to the
   application to call XML_ResumeParser() on it at the appropriate moment.
*/
XMLPARSEAPI(enum XML_Status)
XML_ResumeParser(XML_Parser parser);
enum XML_Parsing {
  XML_INITIALIZED,
  XML_PARSING,
  XML_FINISHED,
  XML_SUSPENDED
};
typedef struct {
  enum XML_Parsing parsing;
  XML_Bool finalBuffer;
} XML_ParsingStatus;
/* Returns status of parser with respect to being initialized, parsing,
   finished, or suspended and processing the final buffer.
   XXX XML_Parse() and XML_ParseBuffer() should return XML_ParsingStatus,
   XXX with XML_FINISHED_OK or XML_FINISHED_ERROR replacing XML_FINISHED
*/
XMLPARSEAPI(void)
XML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status);
/* Creates an XML_Parser object that can parse an external general
   entity; context is a '\0'-terminated string specifying the parse
   context; encoding is a '\0'-terminated string giving the name of
   the externally specified encoding, or NULL if there is no
   externally specified encoding.  The context string consists of a
   sequence of tokens separated by formfeeds (\f); a token consisting
   of a name specifies that the general entity of the name is open; a
   token of the form prefix=uri specifies the namespace for a
   particular prefix; a token of the form =uri specifies the default
   namespace.  This can be called at any point after the first call to
   an ExternalEntityRefHandler so longer as the parser has not yet
   been freed.  The new parser is completely independent and may
   safely be used in a separate thread.  The handlers and userData are
   initialized from the parser argument.  Returns NULL if out of memory.
   Otherwise returns a new XML_Parser object.
*/
XMLPARSEAPI(XML_Parser)
XML_ExternalEntityParserCreate(XML_Parser parser,
                               const XML_Char *context,
                               const XML_Char *encoding);
enum XML_ParamEntityParsing {
  XML_PARAM_ENTITY_PARSING_NEVER,
  XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE,
  XML_PARAM_ENTITY_PARSING_ALWAYS
};
/* Controls parsing of parameter entities (including the external DTD
   subset). If parsing of parameter entities is enabled, then
   references to external parameter entities (including the external
   DTD subset) will be passed to the handler set with
   XML_SetExternalEntityRefHandler.  The context passed will be 0.
   Unlike external general entities, external parameter entities can
   only be parsed synchronously.  If the external parameter entity is
   to be parsed, it must be parsed during the call to the external
   entity ref handler: the complete sequence of
   XML_ExternalEntityParserCreate, XML_Parse/XML_ParseBuffer and
   XML_ParserFree calls must be made during this call.  After
   XML_ExternalEntityParserCreate has been called to create the parser
   for the external parameter entity (context must be 0 for this
   call), it is illegal to make any calls on the old parser until
   XML_ParserFree has been called on the newly created parser.
   If the library has been compiled without support for parameter
   entity parsing (ie without XML_DTD being defined), then
   XML_SetParamEntityParsing will return 0 if parsing of parameter
   entities is requested; otherwise it will return non-zero.
   Note: If XML_SetParamEntityParsing is called after XML_Parse or
      XML_ParseBuffer, then it has no effect and will always return 0.
*/
XMLPARSEAPI(int)
XML_SetParamEntityParsing(XML_Parser parser,
                          enum XML_ParamEntityParsing parsing);
/* If XML_Parse or XML_ParseBuffer have returned XML_STATUS_ERROR, then
   XML_GetErrorCode returns information about the error.
*/
XMLPARSEAPI(enum XML_Error)
XML_GetErrorCode(XML_Parser parser);
/* These functions return information about the current parse
   location.  They may be called from any callback called to report
   some parse event; in this case the location is the location of the
   first of the sequence of characters that generated the event.  When
   called from callbacks generated by declarations in the document
   prologue, the location identified isn't as neatly defined, but will
   be within the relevant markup.  When called outside of the callback
   functions, the position indicated will be just past the last parse
   event (regardless of whether there was an associated callback).
   They may also be called after returning from a call to XML_Parse
   or XML_ParseBuffer.  If the return value is XML_STATUS_ERROR then
   the location is the location of the character at which the error
   was detected; otherwise the location is the location of the last
   parse event, as described above.
*/
XMLPARSEAPI(XML_Size) XML_GetCurrentLineNumber(XML_Parser parser);
XMLPARSEAPI(XML_Size) XML_GetCurrentColumnNumber(XML_Parser parser);
XMLPARSEAPI(XML_Index) XML_GetCurrentByteIndex(XML_Parser parser);
/* Return the number of bytes in the current event.
   Returns 0 if the event is in an internal entity.
*/
XMLPARSEAPI(int)
XML_GetCurrentByteCount(XML_Parser parser);
/* If XML_CONTEXT_BYTES is defined, returns the input buffer, sets
   the integer pointed to by offset to the offset within this buffer
   of the current parse position, and sets the integer pointed to by size
   to the size of this buffer (the number of input bytes). Otherwise
   returns a NULL pointer. Also returns a NULL pointer if a parse isn't
   active.
   NOTE: The character pointer returned should not be used outside
   the handler that makes the call.
*/
XMLPARSEAPI(const char *)
XML_GetInputContext(XML_Parser parser,
                    int *offset,
                    int *size);
/* For backwards compatibility with previous versions. */
#define XML_GetErrorLineNumber   XML_GetCurrentLineNumber
#define XML_GetErrorColumnNumber XML_GetCurrentColumnNumber
#define XML_GetErrorByteIndex    XML_GetCurrentByteIndex
/* Frees the content model passed to the element declaration handler */
XMLPARSEAPI(void)
XML_FreeContentModel(XML_Parser parser, XML_Content *model);
/* Exposing the memory handling functions used in Expat */
XMLPARSEAPI(void *)
XML_MemMalloc(XML_Parser parser, size_t size);
XMLPARSEAPI(void *)
XML_MemRealloc(XML_Parser parser, void *ptr, size_t size);
XMLPARSEAPI(void)
XML_MemFree(XML_Parser parser, void *ptr);
/* Frees memory used by the parser. */
XMLPARSEAPI(void)
XML_ParserFree(XML_Parser parser);
/* Returns a string describing the error. */
XMLPARSEAPI(const XML_LChar *)
XML_ErrorString(enum XML_Error code);
/* Return a string containing the version number of this expat */
XMLPARSEAPI(const XML_LChar *)
XML_ExpatVersion(void);
typedef struct {
  int major;
  int minor;
  int micro;
} XML_Expat_Version;
/* Return an XML_Expat_Version structure containing numeric version
   number information for this version of expat.
*/
XMLPARSEAPI(XML_Expat_Version)
XML_ExpatVersionInfo(void);
/* Added in Expat 1.95.5. */
enum XML_FeatureEnum {
  XML_FEATURE_END = 0,
  XML_FEATURE_UNICODE,
  XML_FEATURE_UNICODE_WCHAR_T,
  XML_FEATURE_DTD,
  XML_FEATURE_CONTEXT_BYTES,
  XML_FEATURE_MIN_SIZE,
  XML_FEATURE_SIZEOF_XML_CHAR,
  XML_FEATURE_SIZEOF_XML_LCHAR,
  XML_FEATURE_NS,
  XML_FEATURE_LARGE_SIZE
  /* Additional features must be added to the end of this enum. */
};
typedef struct {
  enum XML_FeatureEnum  feature;
  const XML_LChar       *name;
  long int              value;
} XML_Feature;
XMLPARSEAPI(const XML_Feature *)
XML_GetFeatureList(void);
/* Expat follows the GNU/Linux convention of odd number minor version for
   beta/development releases and even number minor version for stable
   releases. Micro is bumped with each release, and set to 0 with each
   change to major or minor version.
*/
#define XML_MAJOR_VERSION 2
#define XML_MINOR_VERSION 0
#define XML_MICRO_VERSION 1
#ifdef __cplusplus
}
#endif
#endif
/*
 *  Creator: Jim Buckeyne
 *  Header for configscript.lib(bag.lib)
 *  Provides definitions for handling configuration files
 *  or any particular file which has machine generated
 *  characteristics, it can handle translators to decrypt
 *  encrypt.  Method of operation is to create a configuration
 *  evaluator, then AddConfiguratMethod()s to it.
 *  configuration methods are format descriptors for the lines
 *  and a routine which is called when such a line is matched.
 *  One might think of it as a trigger library for MUDs ( a
 *  way to trigger an event based on certain text input,
 *  variations in the text input may be assigned as variables
 *  to be used within the event.
 *
 *  More about configuration string parsing is available in
 *  $(SACK_BASE)/src/configlib/config.rules text file.
 *
 *  A vague attempt at providing a class to derrive a config-
 *  uration reader class, which may contain private data
 *  within such a class, or otherwise provide an object with
 *  simple namespace usage. ( add(), go() )
 *
 *  This library also imlements several PTEXT based methods
 *  which can evaluate text segments into valid binary types
 *  such as text to integer, float, color, etc.  Some of the type
 *  validators applied for the format argument matching of added
 *  methods are available for external reference.
 *
 */
#ifndef CONFIGURATION_SCRIPT_HANDLER
#define CONFIGURATION_SCRIPT_HANDLER
#ifdef CONFIGURATION_LIBRARY_SOURCE
#define CONFIGSCR_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define CONFIGSCR_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
SACK_NAMESPACE namespace config {
#endif
typedef char *__arg_list[1];
typedef __arg_list arg_list;
// declare 'va_list args = NULL;' to use successfully...
// the resulting thing is of type va_list.
typedef struct va_args_tag va_args;
enum configArgType {
	CONFIG_ARG_STRING,
	CONFIG_ARG_INT64,
	CONFIG_ARG_FLOAT,
	CONFIG_ARG_DATA,
	CONFIG_ARG_DATA_SIZE,
	CONFIG_ARG_LOGICAL,
	CONFIG_ARG_FRACTION,
	CONFIG_ARG_COLOR,
};
struct va_args_tag {
	int argsize; arg_list *args; arg_list *tmp_args; int argCount;
};
//#define va_args struct { int argsize; arg_list *args; arg_list *tmp_args; }
#define init_args(name) name.argCount = 0; name.argsize = 0; name.args = NULL;
  // 32 bits.
#define ARG_STACK_SIZE 4
#define PushArgument( argset, argType, type, arg )	                                 ((argset.args = (arg_list*)Preallocate( argset.args		                        , argset.argsize += ((sizeof( enum configArgType )				                 + sizeof( type )				                                   + (ARG_STACK_SIZE-1) )&-ARG_STACK_SIZE) ) )	        ?(argset.argCount++)	                                                        ,((*(enum configArgType*)(argset.args))=(argType))	                         ,(*(type*)((((uintptr_t)argset.args)+sizeof(enum configArgType)+ (ARG_STACK_SIZE-1) )&-ARG_STACK_SIZE) = (arg))	   ,0	                                                                        :0)
#define PopArguments( argset ) { Release( argset.args ); argset.args=NULL; }
#define pass_args(argset) (( (argset).tmp_args = (argset).args )	                        ,(*(arg_list*)(&argset.tmp_args)))
/*
 * Config methods are passed an arg_list
 * parameters from arg_list are retrieved using
 * PARAM( arg_list_param_name, arg_type, arg_name );
 * ex.
 *
 *   PARAM( args, char *, name );
 *    // results in a variable called name
 *    // initialized from the first argument in arg_list args;
 */
#define my_va_arg(ap,type)     ((ap)[0]+=        ((sizeof(enum configArgType)+sizeof(type)+ARG_STACK_SIZE-1)&~(ARG_STACK_SIZE-1)),        (*(type *)((ap)[0]-((sizeof(type)+ARG_STACK_SIZE-1)&~(ARG_STACK_SIZE-1)))))
#define my_va_arg_type(ap,type)     (         (*(type *)((ap)[0]-(sizeof(enum configArgType)+(sizeof(type)+ARG_STACK_SIZE-1)&~(ARG_STACK_SIZE-1)))))
//#define my_va_next_arg_type(ap,type)     (*(type *)((ap)[0]))
#define my_va_next_arg_type(ap)     ( ( *(enum configArgType *)((ap)[0]) ) )
#define PARAM_COUNT( args ) (((int*)(args+1))[0])
#define PARAM( args, type, name ) type name = my_va_arg( args, type )
#define PARAMEX( args, type, name, argTypeName ) type name = my_va_arg( args, type ); enum configArgType argTypeName = my_va_arg_type(args)
#define FP_PARAM( args, type, name, fa ) type (CPROC*name)fa = (type (CPROC*)fa)(my_va_arg( args, void *))
typedef struct config_file_tag* PCONFIG_HANDLER;
CONFIGSCR_PROC( PCONFIG_HANDLER, CreateConfigurationEvaluator )( void );
#define CreateConfigurationHandler CreateConfigurationEvaluator
CONFIGSCR_PROC( void, DestroyConfigurationEvaluator )( PCONFIG_HANDLER pch );
#define DestroyConfigurationHandler DestroyConfigurationEvaluator
// this pushes all prior state information about configuration file
// processing, and allows a new set of rules to be made...
CONFIGSCR_PROC( void, BeginConfiguration )( PCONFIG_HANDLER pch );
// begins a sub configuration, and marks to save it for future use
// so we don't have to always recreate the configuration states...
CONFIGSCR_PROC( LOGICAL, BeginNamedConfiguration )( PCONFIG_HANDLER pch, CTEXTSTR name );
// then, when you're done with the new set of rules (end of config section)
// use this to restore the prior configuration state.
CONFIGSCR_PROC( void, EndConfiguration )( PCONFIG_HANDLER pch );
typedef uintptr_t (CPROC*USER_CONFIG_HANDLER)( uintptr_t, arg_list args );
typedef uintptr_t( CPROC*USER_CONFIG_HANDLER_EX )(uintptr_t, uintptr_t, arg_list args);
CONFIGSCR_PROC( void, AddConfigurationEx )( PCONFIG_HANDLER pch
														, CTEXTSTR format
														, USER_CONFIG_HANDLER Process DBG_PASS );
CONFIGSCR_PROC( void, AddConfigurationExx )(PCONFIG_HANDLER pch
	, CTEXTSTR format
	, USER_CONFIG_HANDLER_EX Process, uintptr_t processHandler DBG_PASS);
//CONFIGSCR_PROC( void, AddConfiguration )( PCONFIG_HANDLER pch
//					, char *format
//													 , USER_CONFIG_HANDLER Process );
// make a nice wrapper - otherwise we get billions of complaints.
//#define AddConfiguration(pch,format,process) AddConfiguration( (pch), (format), process )
#define AddConfiguration(pch,f,pr) AddConfigurationEx(pch,f,pr DBG_SRC )
#define AddConfigurationMethod AddConfiguration
// FILTER receives a uintptr_t that was given at configuration (addition to handler)
// it receives a PTEXT block of (binary) data... and must result with
// PTEXT segments which are lines which may or may not have \r\n\\ all
// of which are removed before being resulted to the application.
//   POINTER* is a pointer to a pointer, this pointer may be used
//      for private state data.  The last line of the configuration will
//      call the filter chain with NULL to flush data...
typedef PTEXT (CPROC*USER_FILTER)( POINTER *, PTEXT );
CONFIGSCR_PROC( void, AddConfigurationFilter )( PCONFIG_HANDLER pch, USER_FILTER filter );
CONFIGSCR_PROC( void, ClearDefaultFilters )( PCONFIG_HANDLER pch );
CONFIGSCR_PROC( void, SetConfigurationEndProc )( PCONFIG_HANDLER pch, uintptr_t (CPROC *Process)( uintptr_t ) );
CONFIGSCR_PROC( void, SetConfigurationUnhandled )( PCONFIG_HANDLER pch
																, uintptr_t (CPROC *Process)( uintptr_t, CTEXTSTR ) );
CONFIGSCR_PROC( int, ProcessConfigurationFile )( PCONFIG_HANDLER pch
															  , CTEXTSTR name
															  , uintptr_t psv
															  );
CONFIGSCR_PROC( uintptr_t, ProcessConfigurationInput )( PCONFIG_HANDLER pch, CTEXTSTR block, size_t size, uintptr_t psv );
/*
 * TO BE IMPLEMENTED
 *
CONFIGSCR_PROC( int, vcsprintf )( PCONFIG_HANDLER pch, CTEXTSTR format, va_list args );
CONFIGSCR_PROC( int, csprintf )( PCONFIG_HANDLER pch, CTEXTSTR format, ... );
*/
CONFIGSCR_PROC( int, GetBooleanVar )( PTEXT *start, LOGICAL *data );
CONFIGSCR_PROC( int, GetColorVar )( PTEXT *start, CDATA *data );
//CONFIGSCR_PROC( int, IsBooleanVar )( PCONFIG_ELEMENT pce, PTEXT *start );
//CONFIGSCR_PROC( int, IsColorVar )( PCONFIG_ELEMENT pce, PTEXT *start );
// takes a binary block of data and creates a base64-like string which may be stored.
CONFIGSCR_PROC( void, EncodeBinaryConfig )( TEXTSTR *encode, POINTER data, size_t length );
// this isn't REALLY the same function that's used, but serves the same purpose...
CONFIGSCR_PROC( int, DecodeBinaryConfig )( CTEXTSTR String, POINTER *binary_buffer, size_t *buflen );
CONFIGSCR_PROC( CTEXTSTR, FormatColor )( CDATA color );
CONFIGSCR_PROC( void, StripConfigString )( TEXTSTR out, CTEXTSTR in );
CONFIGSCR_PROC( void, ExpandConfigString )( TEXTSTR out, CTEXTSTR in );
#ifdef __cplusplus
//typedef uintptr_t CPROC ::(*USER_CONFIG_METHOD)( ... );
typedef class config_reader {
   PCONFIG_HANDLER pch;
public:
	config_reader() {
      pch = CreateConfigurationEvaluator();
	}
	~config_reader() {
		if( pch ) DestroyConfigurationEvaluator( pch );
      pch = (PCONFIG_HANDLER)NULL;
	}
	inline void add( CTEXTSTR format, USER_CONFIG_HANDLER Process )
	{
      AddConfiguration( pch, format, Process );
	}
   /*
	inline void add( char *format, USER_CONFIG_METHOD Process )
	{
		union {
			struct {
				uint32_t junk;
            USER_CONFIG_HANDLER Process
			} c;
         USER_CONFIG_METHOD Process;
		} x;
      x.Process = Process;
      AddConfiguration( pch, format, x.c.Process );
		}
      */
	inline int go( CTEXTSTR file, POINTER p )
	{
		return ProcessConfigurationFile( pch, file, (uintptr_t)p );
	}
} CONFIG_READER;
#endif
#ifdef __cplusplus
 //namespace sack { namespace config {
}
SACK_NAMESPACE_END
using namespace sack::config;
#endif
#endif
// $Log: configscript.h,v $
// Revision 1.17  2004/12/05 15:32:06  panther
// Some minor cleanups fixed a couple memory leaks
//
// Revision 1.16  2004/08/13 16:48:19  d3x0r
// added ability to put filters on config script data read.
//
// Revision 1.15  2004/02/18 20:46:37  d3x0r
// Add some aliases for badly named routines
//
// Revision 1.14  2004/02/08 23:33:15  d3x0r
// Add a iList class for c++, public access to building parameter va_lists
//
// Revision 1.13  2003/12/09 16:15:56  panther
// Define unhnalded callback set
//
// Revision 1.12  2003/11/09 22:31:58  panther
// Fix CPROC indication on endconfig method
//
// Revision 1.11  2003/10/13 04:25:14  panther
// Fix configscript library... make sure types are consistant (watcom)
//
// Revision 1.10  2003/10/12 02:47:05  panther
// Cleaned up most var-arg stack abuse ARM seems to work.
//
// Revision 1.9  2003/09/24 02:53:58  panther
// Define c++ wrapper for config script library
//
// Revision 1.8  2003/07/24 22:49:01  panther
// Modify addconfig method macro to auto typecast - dangerous by simpler
//
// Revision 1.7  2003/07/24 16:56:41  panther
// Updates to expliclity define C procedure model for callbacks and assembly modules - incomplete
//
// Revision 1.6  2003/04/17 09:32:51  panther
// Added true/false result from processconfigfile.  Added default load from /etc to msgsvr and display
//
// Revision 1.5  2003/03/25 08:38:11  panther
// Add logging
//
// XML_SetUserData
// XML_GetUserData
//#define DEBUG_RESOURCE_NAME_LOOKUP
PSI_XML_NAMESPACE
// need to protect this ...
// ptu it in a structure...
static struct {
	CRITICALSECTION cs;
	void (CPROC*InitProc)(uintptr_t,PSI_CONTROL);
 // psvInitProc
	uintptr_t psv;
	PSI_CONTROL frame;
	struct {
		BIT_FIELD cs_initialized;
	} flags;
}l;
struct xml_userdata {
	XML_Parser xp;
	PSI_CONTROL pc;
};
static LOGICAL SetP( TEXTSTR *p, const XML_Char **atts )
{
	if( p[0] )
		Deallocate( TEXTSTR, p[0] );
	if( p[1] )
		Deallocate( TEXTSTR, p[1] );
	if( atts[0] )
	{
		p[0] = DupCStr( atts[0] );
		p[1] = DupCStr( atts[1] );
		return TRUE;
	}
	else
		return FALSE;
}
void XMLCALL start_tags( void *UserData
							  , const XML_Char *name
							  , const XML_Char **atts )
{
	struct xml_userdata *userdata = (struct xml_userdata *)UserData;
	uint32_t ID = -1;
	uint32_t x, y;
	uint32_t edit_set = 0;
	uint32_t disable_edit = 0;
	uint32_t width, height;
	TEXTSTR caption = NULL;
	uint32_t border = 0;
	LOGICAL border_set;
	TEXTSTR font = NULL;
	TEXTSTR control_data = NULL;
	TEXTSTR IDName = NULL;
	TEXTSTR type = NULL;
	PSI_CONTROL pc;
	TEXTSTR p[2];
	p[0] = NULL;
	p[1] = NULL;
	//CTEXTSTR *p = atts;
	//lprintf( "begin a tag %s with...", name );
	while( SetP( p, atts ) )
	{
		//lprintf( "begin a attrib %s=%s with...", p[0], p[1] );
		if( strcmp( p[0], "ID" ) == 0 )
		{
			ID = (int)IntCreateFromText( p[1] );
		}
		else if( strcmp( p[0], "IDName" ) == 0 )
		{
			IDName = StrDup( p[1] );
		}
		else if( strcmp( p[0], "border" ) == 0 )
		{
			border_set = TRUE;
			//border = (int)IntCreateFromText( p[1] );
			tscanf( p[1], "%" _32fx, &border );
		}
		else if( strcmp( p[0], "size" ) == 0 )
		{
			tscanf( p[1], "%" _32f "," "%" _32f, &width, &height );
		}
		else if( StrCmp( p[0], "position" ) == 0 )
		{
			tscanf( p[1], "%" _32f "," "%" _32f, &x, &y );
		}
		else if( strcmp( p[0], "caption" ) == 0 )
		{
			caption = StrDup( p[1] );
		}
		else if( strcmp( p[0], "font" ) == 0 )
		{
			font = StrDup( p[1] );
		}
		else if( strcmp( p[0], "PrivateData" ) == 0 )
		{
			control_data = StrDup( p[1] );
		}
		else if( strcmp( p[0], "type" ) == 0 )
		{
			type = StrDup( p[1] );
		}
		else if( strcmp( p[0], "edit" ) == 0 )
		{
			edit_set = 1;
			disable_edit = (int)IntCreateFromText( p[1] );
		}
		else
		{
			lprintf( "Unknown Att Pair = (%s=%s)", p[0], p[1] );
		}
		atts += 2;
	}
	if( IDName )
	{
		//lprintf( "Making a control... %s %s %s", type?type:"notype", caption?caption:"nocatpion", IDName );
		pc = MakeNamedCaptionedControlByName( userdata->pc
														, type
														, x, y
														, width, height
														, IDName
														, ID
														, caption );
		Release( IDName );
	}
	else
	{
		//lprintf( "Making a control... %s %s", type?type:"notype", caption?caption:"nocatpion" );
		pc = MakeNamedCaptionedControl( userdata->pc
														, type
														, x, y
														, width, height
														, ID
												, caption );
	}
	if( border ) {
		if( pc->parent )
			SetCommonBorder( pc, border | BORDER_NOCAPTION );
		else
			SetCommonBorder( pc, border );
	}
	//lprintf( "control done..." );
	if( pc )
	{
		if( edit_set )
 // mark that edit was loaded from the XML file.  the function of bEditSet can be used to fix setting edit before frame display.
			pc->flags.bEditLoaded = 1;
		pc->flags.bEditSet = edit_set;
		pc->flags.bNoEdit = disable_edit;
	}
	if( caption )
		Release( caption );
	if( type )
		Release( type );
	if( !l.frame )
 // mark this as the frame to return
		l.frame = pc;
	if( font )
	{
		POINTER fontbuf = NULL;
		size_t fontlen;
		if( DecodeBinaryConfig( font, &fontbuf, &fontlen ) )
			SetCommonFont( pc, RenderFontData( (PFONTDATA)fontbuf ) );
		Release( font );
	}
	if( control_data )
		Release( control_data );
	// SetCommonFont()
	//
	userdata->pc = pc;
}
void XMLCALL end_tags( void *UserData
							, const XML_Char *name )
{
	struct xml_userdata *userdata = (struct xml_userdata *)UserData;
	if( userdata->pc )
		userdata->pc = userdata->pc->parent;
}
//-------------------------------------------------------------------------
static struct {
	CTEXTSTR pFile;
	uint32_t nLine;
} current_loading;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
void * MyAllocate( size_t s ) { return AllocateEx( s, current_loading.pFile, current_loading.nLine ); }
#else
void * MyAllocate( size_t s ) { return AllocateEx( s ); }
#endif
void *MyReallocate( void *p, size_t s ) { return Reallocate( p, s ); }
void MyRelease( void *p ) { Release( p ); }
// = { MyAllocate, MyReallocate, MyRelease };
static XML_Memory_Handling_Suite XML_memhandler;
//-------------------------------------------------------------------------
// expected character buffer of appropriate size.
PSI_CONTROL ParseXMLFrameEx( POINTER buffer, size_t size DBG_PASS )
{
	POINTER xml_buffer;
	struct xml_userdata userdata;
	l.frame = NULL;
#  ifdef USE_INTERFACES
	GetMyInterface();
	if( !g.MyImageInterface )
		return NULL;
#endif
	//lprintf( "Beginning parse frame..." );
#if DBG_AVAILABLE
	current_loading.pFile = pFile;
	current_loading.nLine = nLine;
#endif
	XML_memhandler.malloc_fcn = MyAllocate;
	XML_memhandler.realloc_fcn = MyReallocate;
	XML_memhandler.free_fcn = MyRelease;
	userdata.xp = XML_ParserCreate_MM( NULL, &XML_memhandler, NULL );
	userdata.pc = NULL;
	XML_SetElementHandler( userdata.xp, start_tags, end_tags );
	XML_SetUserData( userdata.xp, &userdata );
	xml_buffer = XML_GetBuffer( userdata.xp, size );
	MemCpy( xml_buffer, buffer, size );
	if( XML_ParseBuffer( userdata.xp, size, TRUE ) == XML_STATUS_ERROR )
	{
		lprintf( "Error in XML parse %d  at line %" _size_f "(%" _size_f ")", XML_GetErrorCode( userdata.xp ),XML_GetCurrentLineNumber( userdata.xp ), XML_GetCurrentColumnNumber( userdata.xp ) );
	}
	XML_ParserFree( userdata.xp );
	userdata.xp = 0;
	//lprintf( "Parse done..." );
	return l.frame;
}
PSI_CONTROL LoadXMLFrameOverExx( PSI_CONTROL parent, CTEXTSTR file, LOGICAL create DBG_PASS )
//PSI_CONTROL  LoadXMLFrame( char *file )
{
	POINTER buffer;
	size_t size;
	TEXTSTR delete_filename = NULL;
 // assume this is the name until later
	TEXTSTR filename = (TEXTSTR)file;
	PSI_CONTROL frame;
	GetMyInterface();
#  ifdef USE_INTERFACES
	if( !g.MyImageInterface )
		return NULL;
#endif
	if( !l.flags.cs_initialized )
	{
		InitializeCriticalSec( &l.cs );
		l.flags.cs_initialized = 1;
	}
	EnterCriticalSec( &l.cs );
	// enter critical section!
	l.frame = NULL;
#if DBG_AVAILABLE
	current_loading.pFile = pFile;
	current_loading.nLine = nLine;
#endif
	size = 0;
//#ifdef UNDER_CE
	{
		FILE *file_read = sack_fopen( 0, file, "rb" );
		if( file_read )
		{
			size = sack_fsize( file_read );
			buffer = Allocate( size );
			sack_fread( buffer, size, 1, file_read );
			sack_fclose( file_read );
			//lprintf( "loaded frame blob %s %d %p", file, size, buffer );
		}
		else
			buffer = NULL;
	}
//#else
//	buffer = OpenSpace( NULL, file, &size );
//#endif
	if( !buffer || !size )
	{
		// attempt secondary open within frames/*
		size = 0;
		{
			INDEX group;
			FILE *file_read = sack_fopen( group = GetFileGroup( "PSI Frames", "./frames" ), file, "rb" );
			if( file_read )
			{
				size = sack_fsize( file_read );
				buffer = Allocate( size );
				sack_fread( buffer, size, 1, file_read );
				sack_fclose( file_read );
				//lprintf( "loaded font blob %s %d %p", file, zz, buffer );
			}
			else
				buffer = NULL;
		}
	}
	if( buffer && size )
	{
		ParseXMLFrame( buffer, size );
		Release( buffer );
	}
	if( create && !l.frame )
	{
		//create_editable_dialog:
		{
			PSI_CONTROL frame;
			frame = CreateFrame( file
									 , 0, 0
									 , 420, 250, 0, NULL );
			frame->save_name = StrDup( filename );
			DisplayFrameOver( frame, parent );
			EditFrame( frame, TRUE );
 // edit may result in destroying (cancelling) the whole thing
			CommonWaitEndEdit( &frame );
			if( frame )
			{
				// save it, and result with it...
				SaveXMLFrame( frame, filename );
				if( delete_filename )
					Release(delete_filename );
				LeaveCriticalSec( &l.cs );
				return frame;
			}
			if( delete_filename )
				Release(delete_filename );
			//DestroyControl( &frame );
			LeaveCriticalSec( &l.cs );
			return NULL;
		}
	}
	// yes this is an assignment
	if( frame = l.frame )
		l.frame->save_name = StrDup( filename );
	if( delete_filename )
		Release(delete_filename );
	LeaveCriticalSec( &l.cs );
	return frame;
}
PSI_CONTROL LoadXMLFrameOverEx( PSI_CONTROL parent, CTEXTSTR file DBG_PASS )
{
	return LoadXMLFrameOverExx( parent, file, TRUE DBG_RELAY );
}
PSI_CONTROL LoadXMLFrameEx( CTEXTSTR file DBG_PASS )
//PSI_CONTROL  LoadXMLFrame( char *file )
{
   return LoadXMLFrameOverEx( NULL, file DBG_RELAY );
}
PSI_XML_NAMESPACE_END
/*
 * genx - C-callable library for generating XML documents
 */
/*
 * Copyright (c) 2004 by Tim Bray and Sun Microsystems.  For copying
 *  permission, see http://www.tbray.org/ongoing/genx/COPYING
 */
#ifndef GENX_STUFF_DEFINED
#define GENX_STUFF_DEFINED
 // CPROC
#ifdef GENX_SOURCE
#define GENX_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define GENX_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
#define GENX_NAMESPACE extern "C" {
#define GENX_NAMESPACE_END }
#else
#define GENX_NAMESPACE
#define GENX_NAMESPACE_END
#endif
GENX_NAMESPACE
/*
 * Note on error handling: genx routines mostly return
 *  GENX_SUCCESS (guaranteed to be zero) in normal circumstances, one of
 *  these other GENX_ values on a memory allocation or I/O failure or if the
 *  call would result in non-well-formed output.
 * You can associate an error message with one of these codes explicitly
 *  or with the most recent error using genxGetErrorMessage() and
 *  genxLastErrorMessage(); see below.
 */
typedef enum
{
  GENX_SUCCESS = 0,
  GENX_BAD_UTF8,
  GENX_NON_XML_CHARACTER,
  GENX_BAD_NAME,
  GENX_ALLOC_FAILED,
  GENX_BAD_NAMESPACE_NAME,
  GENX_INTERNAL_ERROR,
  GENX_DUPLICATE_PREFIX,
  GENX_SEQUENCE_ERROR,
  GENX_NO_START_TAG,
  GENX_IO_ERROR,
  GENX_MISSING_VALUE,
  GENX_MALFORMED_COMMENT,
  GENX_XML_PI_TARGET,
  GENX_MALFORMED_PI,
  GENX_DUPLICATE_ATTRIBUTE,
  GENX_ATTRIBUTE_IN_DEFAULT_NAMESPACE,
  GENX_DUPLICATE_NAMESPACE,
  GENX_BAD_DEFAULT_DECLARATION
} genxStatus;
/* character types */
#define GENX_XML_CHAR 1
#define GENX_LETTER 2
#define GENX_NAMECHAR 4
/* a UTF-8 string */
#if defined( __cplusplus )
#define UTFTYPE char
#else
#define UTFTYPE unsigned char
#endif
typedef UTFTYPE * utf8;
typedef const UTFTYPE * constUtf8;
/*
 * genx's own types
 */
typedef struct genxWriter_rec * genxWriter;
typedef struct genxNamespace_rec * genxNamespace;
typedef struct genxElement_rec * genxElement;
typedef struct genxAttribute_rec * genxAttribute;
/*
 * Constructors, set/get
 */
/*
 * Create a new writer.  For generating multiple XML documents, it's most
 *  efficient to re-use the same genx object.  However, you can only write
 *  one document at a time with a writer.
 * Returns NULL if it fails, which can only be due to an allocation failure.
 */
GENX_PROC(genxWriter, genxNew)(void * (*alloc)(void * userData, int bytes),
		   void (* dealloc)(void * userData, void * data),
		   void * userData);
/*
 * Dispose of a writer, freeing all associated memory
 */
GENX_PROC(void, genxDispose)(genxWriter w);
/*
 * Set/get
 */
/*
 * The userdata pointer will be passed to memory-allocation
 *  and I/O callbacks. If not set, genx will pass NULL
 */
GENX_PROC(void, genxSetUserData)(genxWriter w, void * userData);
GENX_PROC(void *, genxGetUserData)(genxWriter w);
/*
 * User-provided memory allocator, if desired.  For example, if you were
 *  in an Apache module, you could arrange for genx to use ap_palloc by
 *  making the pool accessible via the userData call.
 * The "dealloc" is to be used to free memory allocated with "alloc".  If
 *  alloc is provided but dealloc is NULL, genx will not attempt to free
 *  the memory; this would be appropriate in an Apache context.
 * If "alloc" is not provided, genx routines use malloc() to allocate memory
 */
GENX_PROC(void, genxSetAlloc)(genxWriter w,
		  void * (* alloc)(void * userData, int bytes));
GENX_PROC(void, genxSetDealloc)(genxWriter w,
		    void (* dealloc)(void * userData, void * data));
void * (* genxGetAlloc(genxWriter w))(void * userData, int bytes);
void (* genxGetDealloc(genxWriter w))(void * userData, void * data);
/*
 * Get the prefix associated with a namespace
 */
GENX_PROC(utf8, genxGetNamespacePrefix)(genxNamespace ns);
/*
 * Declaration functions
 */
/*
 * Declare a namespace.  The provided prefix is the default but can be
 *  overridden by genxAddNamespace.  If no default prefiix is provided,
 *  genx will generate one of the form g-%d.
 * On error, returns NULL and signals via statusp
 */
GENX_PROC(genxNamespace, genxDeclareNamespace )(genxWriter w,
				   constUtf8 uri, constUtf8 prefix,
				   genxStatus * statusP);
/*
 * Declare an element
 * If something failed, returns NULL and sets the status code via statusP
 */
GENX_PROC(genxElement, genxDeclareElement )(genxWriter w,
			       genxNamespace ns, constUtf8 type,
			       genxStatus * statusP);
/*
 * Declare an attribute
 */
GENX_PROC(genxAttribute, genxDeclareAttribute )(genxWriter w,
				   genxNamespace ns,
				   constUtf8 name, genxStatus * statusP);
/*
 * Writing XML
 */
/*
 * Start a new document.
 */
GENX_PROC(genxStatus, genxStartDocFile )(genxWriter w, FILE * file);
/*
 * Caller-provided I/O package.
 * First form is for a null-terminated string.
 * for second, if you have s="abcdef" and want to send "abc", you'd call
 *  sendBounded(userData, s, s + 3)
 */
typedef struct
{
  genxStatus (* send)(void * userData, constUtf8 s);
  genxStatus (* sendBounded)(void * userData, constUtf8 start, constUtf8 end);
  genxStatus (* flush)(void * userData);
} genxSender;
GENX_PROC(genxStatus, genxStartDocSender )(genxWriter w, genxSender * sender);
/*
 * End a document.  Calls "flush"
 */
GENX_PROC(genxStatus, genxEndDocument )(genxWriter w);
/*
 * Write a comment
 */
GENX_PROC(genxStatus, genxComment )(genxWriter w, constUtf8 text);
/*
 * Write a PI
 */
GENX_PROC(genxStatus, genxPI )(genxWriter w, constUtf8 target, constUtf8 text);
/*
 * Start an element
 */
GENX_PROC(genxStatus, genxStartElementLiteral )(genxWriter w,
				   constUtf8 xmlns, constUtf8 type);
/*
 * Start a predeclared element
 * - element must have been declared
 */
GENX_PROC(genxStatus, genxStartElement )(genxElement e);
/*
 * Write an attribute
 */
GENX_PROC(genxStatus, genxAddAttributeLiteral )(genxWriter w, constUtf8 xmlns,
				   constUtf8 name, constUtf8 value);
/*
 * Write a predeclared attribute
 */
GENX_PROC(genxStatus, genxAddAttribute )(genxAttribute a, constUtf8 value);
/*
 * add a namespace declaration
 */
GENX_PROC(genxStatus, genxAddNamespace )(genxNamespace ns, utf8 prefix);
/*
 * Clear default namespace declaration
 */
GENX_PROC(genxStatus, genxUnsetDefaultNamespace )(genxWriter w);
/*
 * Write an end tag
 */
GENX_PROC(genxStatus, genxEndElement )(genxWriter w);
/*
 * Write some text
 * You can't write any text outside the root element, except with
 *  genxComment and genxPI
 */
GENX_PROC(genxStatus, genxAddText )(genxWriter w, constUtf8 start);
GENX_PROC(genxStatus, genxAddCountedText )(genxWriter w, constUtf8 start, int byteCount);
GENX_PROC(genxStatus, genxAddBoundedText )(genxWriter w, constUtf8 start, constUtf8 end);
/*
 * Write one character.  The integer value is the Unicode character
 *  value, as usually expressed in U+XXXX notation.
 */
GENX_PROC(genxStatus, genxAddCharacter )(genxWriter w, int c);
/*
 * Utility routines
 */
/*
 * Return the Unicode character encoded by the UTF-8 pointed-to by the
 *  argument, and advance the argument past the encoding of the character.
 * Returns -1 if the UTF-8 is malformed, in which case advances the
 *  argument to point at the first byte past the point past the malformed
 *  ones.
 */
GENX_PROC(int, genxNextUnicodeChar )(constUtf8 * sp);
/*
 * Scan a buffer allegedly full of UTF-8 encoded XML characters; return
 *  one of GENX_SUCCESS, GENX_BAD_UTF8, or GENX_NON_XML_CHARACTER
 */
GENX_PROC(genxStatus, genxCheckText )(genxWriter w, constUtf8 s);
/*
 * return character status, the OR of GENX_XML_CHAR,
 *  GENX_LETTER, and GENX_NAMECHAR
 */
GENX_PROC(int, genxCharClass )(genxWriter w, int c);
/*
 * Silently wipe any non-XML characters out of a chunk of text.
 * If you call this on a string before you pass it addText or
 *  addAttribute, you will never get an error from genx unless
 *  (a) there's a bug in your software, e.g. a malformed element name, or
 *  (b) there's a memory allocation or I/O error
 * The output can never be longer than the input.
 * Returns true if any changes were made.
 */
GENX_PROC(int, genxScrubText )(genxWriter w, constUtf8 in, utf8 out);
/*
 * return error messages
 */
GENX_PROC(const char *, genxGetErrorMessage )(genxWriter w, genxStatus status);
GENX_PROC(const char *, genxLastErrorMessage )(genxWriter w);
/*
 * return version
 */
GENX_PROC(const char *, genxGetVersion )();
GENX_NAMESPACE_END
#ifdef __cplusplus
//	using namespace sack::xml::gen;
#endif
#endif
PSI_XML_NAMESPACE
typedef struct context_tag
{
   // name of the file we're building..
	TEXTCHAR *name;
	PVARTEXT vt;
	uint32_t nChildren;
 // current control...
	PSI_CONTROL pc;
	genxWriter w;
	genxElement eControl;
	genxAttribute aPosition;
	genxAttribute aSize;
	genxAttribute aBorder;
	genxAttribute aChildren;
	genxAttribute aType, aID, aIDName, aCaption, aPrivate, aExtraPrivate;
	genxAttribute aEdit;
} XML_CONTEXT, *PXML_CONTEXT;
typedef struct psi_xml_local_tag
{
 // list of PXML_CONTEXTs
	PDATASTACK contexts;
	PXML_CONTEXT current_context;
	//char *file;
	PVARTEXT current_vt;
} PSI_XML_LOCAL;
#define l psiXmlLocal
static PSI_XML_LOCAL l;
void WriteCommonData( PSI_CONTROL pc )
{
	PVARTEXT out = VarTextCreateExx( 10000, 5000 );
	for( ; pc; pc = pc->next )
	{
		TEXTCHAR buf[256];
		// next please.
		if( pc->flags.private_control || pc->flags.bAdoptedChild )
			continue;
		l.current_context->pc = pc;
		genxAddText(l.current_context->w, (constUtf8)"\n");
		genxStartElement( l.current_context->eControl );
		tnprintf( buf, sizeof( buf ), PSI_ROOT_REGISTRY "/control/%d", pc->nType );
		genxAddAttribute( l.current_context->aType, (constUtf8)GetRegisteredValue( buf, "Type" ) );
		tnprintf( buf, sizeof( buf ), "%" _32f "," "%" _32f, pc->original_rect.x, pc->original_rect.y );
		genxAddAttribute( l.current_context->aPosition, (constUtf8)buf );
		tnprintf( buf, sizeof( buf ), "%" _32f "," "%" _32f, pc->original_rect.width, pc->original_rect.height );
		genxAddAttribute( l.current_context->aSize, (constUtf8)buf );
		if( pc->flags.bSetBorderType )
		{
			tnprintf( buf, sizeof( buf ), "%" _32fx "", pc->BorderType );
			genxAddAttribute( l.current_context->aBorder, (constUtf8)buf );
		}
		// Let's not write the number of this ID anymore...
		//sprintf( buf, "%d", pc->nID );
		//genxAddAttribute( l.current_context->aID, (constUtf8)buf );
		if( pc->pIDName )
		{
			PCLASSROOT pcr = GetClassRootEx( (PCLASSROOT)"psi/resources", pc->pIDName );
			TEXTCHAR buffer[256];
			TEXTSTR skip;
			GetClassPath( buffer, 256, pcr );
			skip = buffer + 15;
			genxAddAttribute( l.current_context->aIDName, (constUtf8)skip );
		}
		if( pc->flags.bEditLoaded )
		{
			tnprintf( buf, sizeof( buf ), "%d", pc->flags.bNoEdit );
			genxAddAttribute( l.current_context->aEdit, (constUtf8)buf);
		}
		if( pc->caption.text )
			genxAddAttribute( l.current_context->aCaption, (constUtf8)GetText( pc->caption.text ) );
		// call the control's custom data stuff...
		// which should start another tag within the control?
		{
			int (CPROC *Save)(PSI_CONTROL,PVARTEXT);
			TEXTCHAR id[32];
			PVARTEXT out = VarTextCreate();
			tnprintf( id, sizeof( id ), PSI_ROOT_REGISTRY "/control/%d/rtti", pc->nType );
			if( ( Save=GetRegisteredProcedure( id, int, save,(PSI_CONTROL,PVARTEXT)) ) )
			{
				PTEXT data;
				Save( pc, out );
				data = VarTextGet( out );
				if( data )
				{
					genxAddAttribute( l.current_context->aPrivate, (constUtf8)GetText( data ) );
					LineRelease( data );
				}
			}
			if( ( Save=GetRegisteredProcedure( id, int, extra save,(PSI_CONTROL,PVARTEXT)) ) )
			{
				PTEXT data;
				Save( pc, out );
				data = VarTextGet( out );
				if( data )
				{
					genxAddAttribute( l.current_context->aExtraPrivate, (constUtf8)GetText( data ) );
					LineRelease( data );
				}
			}
			VarTextDestroy( &out );
		}
		if( l.current_context->nChildren )
		{
			l.current_context->pc = pc;
			tnprintf( buf, sizeof( buf ), "%" _32f "", l.current_context->nChildren );
			genxAddAttribute( l.current_context->aChildren, (constUtf8)buf );
			l.current_context->nChildren = 0;
		}
		if( pc->child )
		{
			WriteCommonData( pc->child );
		}
		genxEndElement( l.current_context->w );
		//pc = pc->next;
	}
	VarTextDestroy( &out );
}
static genxStatus WriteBuffer( void *UserData, constUtf8 s )
{
	vtprintf( l.current_vt, "%s", s );
	return GENX_SUCCESS;
}
static genxStatus WriteBufferBounded( void *UserData, constUtf8 s, constUtf8 end )
{
	vtprintf( l.current_vt, "%*.*s", end-s, end-s, s );
	return GENX_SUCCESS;
}
static genxStatus Flush( void *UserData )
{
	return GENX_SUCCESS;
}
genxSender senderprocs = { WriteBuffer
								 , WriteBufferBounded
								 , Flush };
int SaveXMLFrame( PSI_CONTROL frame, CTEXTSTR file )
{
	//FILE *out = fopen( file, "wb" );
	XML_CONTEXT context;
	PXML_CONTEXT current_context;
	if( !file )
		file = frame->save_name;
	else {
		if( frame->save_name )
			Deallocate( char*, frame->save_name );
		frame->save_name = StrDup( file );
	}
	if( !file )
	{
		lprintf( "Failure to save XML Frame... no filename passed, no filename available." );
		return 0;
	}
	MemSet( &context, 0, sizeof( context ) );
	if( !l.contexts )
      l.contexts = CreateDataStack( sizeof( context ) );
	if( !file && ( current_context= (PXML_CONTEXT)PeekData( &l.contexts ) ) )
	{
		TEXTCHAR *ext = strrchr( current_context->name, '.' );
		PTEXT text;
		context.vt = VarTextCreateExx( 10000, 5000 );
		if( !ext )
			ext = current_context->name + StrLen( current_context->name );
		current_context->nChildren++;
		vtprintf( context.vt, "%*.*s.%d-%d-child-%d%s"
				  , ext - current_context->name
				  , ext - current_context->name
				  , current_context->name
              , current_context->pc->nType
              , current_context->pc->nID
              , current_context->nChildren
				  , ext );
      text = VarTextGet( context.vt );
      context.name = StrDup( GetText( text ) );
		LineRelease( text );
	}
	else
	{
		if( !file )
		{
			lprintf( "NULL filename passed to save frame.  Aborting." );
			return 0;
		}
		context.name = StrDup( file );
		context.vt = VarTextCreateExx( 10000, 5000 );
	}
	PushData( &l.contexts, &context );
	l.current_context = (PXML_CONTEXT)PeekData( &l.contexts );
	if( l.current_context )
		l.current_vt = l.current_context->vt;
	//if( out )
	{
		genxStatus status;
		//genxElement eFrame = genxDeclareElement( l.w, NULL, "frame", &status );
		if( !l.current_context->w )
		{
			l.current_context->w = genxNew(NULL,NULL,NULL);
			l.current_context->eControl = genxDeclareElement( l.current_context->w, NULL, (constUtf8)"control", &status );
			l.current_context->aPosition = genxDeclareAttribute( l.current_context->w, NULL, (constUtf8)"position", &status );
			l.current_context->aSize = genxDeclareAttribute( l.current_context->w, NULL, (constUtf8)"size", &status );
			l.current_context->aType = genxDeclareAttribute( l.current_context->w, NULL, (constUtf8)"type", &status );
			l.current_context->aEdit = genxDeclareAttribute( l.current_context->w, NULL, (constUtf8)"edit", &status );
			l.current_context->aBorder = genxDeclareAttribute( l.current_context->w, NULL, (constUtf8)"border", &status );
			l.current_context->aCaption = genxDeclareAttribute( l.current_context->w, NULL, (constUtf8)"caption", &status );
			l.current_context->aID = genxDeclareAttribute( l.current_context->w, NULL, (constUtf8)"ID", &status );
			l.current_context->aIDName = genxDeclareAttribute( l.current_context->w, NULL, (constUtf8)"IDName", &status );
			l.current_context->aPrivate = genxDeclareAttribute( l.current_context->w, NULL, (constUtf8)"PrivateData", &status );
			l.current_context->aExtraPrivate = genxDeclareAttribute( l.current_context->w, NULL, (constUtf8)"ExtraPrivateData", &status );
			l.current_context->aChildren = genxDeclareAttribute( l.current_context->w, NULL, (constUtf8)"children", &status );
		}
		//genxStartDocFile( l.w, out );
		genxStartDocSender( l.current_context->w, &senderprocs );
		WriteCommonData( frame );
		genxEndDocument( l.current_context->w );
		{
			FILE *out;
			out = sack_fopen( 0, l.current_context->name, "wt"
#ifdef _UNICODE
								  ", ccs=UNICODE"
#endif
								 );
			if( out )
			{
				PTEXT text = VarTextGet( l.current_vt );
				sack_fwrite( GetText( text ), GetTextSize( text ), sizeof( TEXTCHAR ), out );
				LineRelease( text );
				// this is just a shot hand copy
				//VarTextDestroy( &l.current_vt );
				sack_fclose( out );
			}
			else
			{
				SimpleMessageBox( frame, "FAILED TO OPEN", l.current_context->name );
			}
		}
		PopData( &l.contexts );
		Release( l.current_context->name );
		VarTextDestroy( &l.current_context->vt );
		genxDispose( l.current_context->w );
		if( ( l.current_context = (PXML_CONTEXT)PeekData( &l.contexts ) ) )
			l.current_vt = l.current_context->vt;
	}
   return 1;
}
#undef l
PSI_XML_NAMESPACE_END
#define DEFINE_DEFAULT_RENDER_INTERFACE
#ifndef WIN32
#define BTN_OKAY   1
#endif
#define DIA_X(x) x * 2
#define DIA_Y(y) y * 2
#define DIA_W(w) w * 2
#define DIA_H(h) h * 2
#ifndef __NO_GUI__
//#ifdef GRAPHIC_PROMPT
static void CPROC SetIntTRUE( uintptr_t psvInt, PSI_CONTROL unused )
{
	struct done_tag{
      PTHREAD me;
		int done;
	} *done = (struct done_tag*)psvInt;
	if( done )
	{
		done->done = TRUE;
		WakeThread( done->me );
	}
}
#endif
size_t _SQLPromptINIValue(			 CTEXTSTR lpszSection,
					 CTEXTSTR lpszEntry,
					 CTEXTSTR lpszDefault,
					 TEXTSTR lpszReturnBuffer,
					 size_t cbReturnBuffer,
					 CTEXTSTR filename
		)
{
#ifndef __NO_GUI__
	PSI_CONTROL frame;
	struct {
		PTHREAD me;
		int done;
	} done;
	TEXTCHAR text[256];
	done.me = MakeThread();
	done.done = 0;
	//if( blog )
	//	lprintf( "Dialog prompt for [%s] %s=%s in %s", lpszSection, lpszEntry, lpszDefault, filename );
	frame = CreateFrame( "INI Entry Error", DIA_X(59), DIA_Y(34), DIA_W(256) + 36, DIA_H(78), BORDER_NORMAL, NULL );
	if( frame )
	{
	MakeTextControl( frame, DIA_X(1), DIA_Y(2), DIA_W(254), DIA_H(16), -1, "The value below has not been found.  Please enter the correct value.", 0 );
	tnprintf( text, sizeof( text ), "%s\n   [%s]\n      %s =", filename, lpszSection, lpszEntry );
	MakeTextControl( frame, DIA_X(4), DIA_Y(18), DIA_W(248), DIA_H(28), 123, text, EDIT_READONLY );
	MakeEditControl( frame, DIA_X(4), DIA_Y(46), DIA_W(248), DIA_H(12), 124, lpszDefault, 0 );
	MakeButton( frame, DIA_X(4), DIA_Y(63), DIA_W(248), DIA_H(14), IDOK, "Ok", 0, SetIntTRUE, (uintptr_t)&done );
	DisplayFrame( frame );
	MakeTopmost( GetFrameRenderer( frame ) );
	while( !done.done )
	{
  // otherwise dispatched an idle, and we're dependant on someone else...
      if( !Idle() )
			WakeableSleep( 5000 );
	}
	GetControlText( GetControl( frame, 124 ), lpszReturnBuffer, cbReturnBuffer );
	//CryptoWritePrivateProfileString( lpszSection, lpszEntry, lpszReturnBuffer, hg_file[file].file_name );
    DestroyFrame( &frame );
	return StrLen( lpszReturnBuffer );
	}
	else
#endif
	{
		StrCpyEx( lpszReturnBuffer, lpszDefault, cbReturnBuffer );
	}
	return StrLen( lpszReturnBuffer );
}
#define CONTROL_SCROLL_KNOB_NAME "Scroll Knob"
typedef void (CPROC *KnobEvent)( uintptr_t psv, int ticks );
PSI_PROC( void, SetScrollKnobEvent )( PSI_CONTROL pc, KnobEvent event, uintptr_t psvEvent );
PSI_PROC( void, SetScrollKnobImageName )( PSI_CONTROL pc, CTEXTSTR image );
PSI_PROC( void, SetScrollKnobImage )( PSI_CONTROL pc, Image image );
// fixed is defined in image.h
// angle is a fixed scaled integer with 0x1 0000 0000 being the full circle.
PSI_PROC( void, SetScrollKnobImageZeroAngle )( PSI_CONTROL pc, fixed angle );
//---------------------------------------------------------------------------------
typedef struct scroll_knob
{
	struct knob_flags
	{
  // draw mouse-over updates
		BIT_FIELD draw_update_arc : 1;
	} flags;
	int _b;
	int last_arc;
	int _first_arc;
 // computed fixed delta between last and first
	int delta_arc;
	KnobEvent event_handler;
	uintptr_t psvEvent;
	Image knob_image;
	PSPRITE knob_sprite;
	CTEXTSTR knob_image_file;
	fixed zero_angle;
	fixed width_scale;
	fixed height_scale;
} ScrollKnob, *PScrollKnob;
//EasyRegisterControl( CONTROL_SCROLL_KNOB_NAME, sizeof( ScrollKnob ) );
static CONTROL_REGISTRATION scrollKnobControl= { CONTROL_SCROLL_KNOB_NAME
			, { 32, 32, sizeof( ScrollKnob ), BORDER_THINNER } };
PRELOAD( scrollKnobProgressBarcontrol ){ DoRegisterControl( &scrollKnobControl ); }
static uint32_t* sk_MyControlID = &scrollKnobControl.TypeID;
static int OnCreateCommon( CONTROL_SCROLL_KNOB_NAME )( PSI_CONTROL pc )
{
	PScrollKnob knob = ControlData( PScrollKnob, pc );
	knob->width_scale = 0x100000000ULL;
	knob->height_scale = 0x100000000ULL;
	return 1;
}
static int OnMouseCommon( CONTROL_SCROLL_KNOB_NAME )( PSI_CONTROL pc, int32_t x, int32_t y, uint32_t b )
{
	ValidatedControlData( PScrollKnob, sk_MyControlID[0], knob, pc );
	int arc;
	uint32_t w, h;
	Image surface;
	surface = GetControlSurface( pc );
	w = surface->width;
	h = surface->height;
	x = x - (w/2);
	y = y - (h/2);
	// center deadzone
	if( (x < 10) && (x > -10) && (y < 10) && (y > -10) )
		return 1;
	if( x >= 0 && y >= 0 )
	{
		if( y < x/2 )
		{
			arc = 0;
		}
		else if ( y > (x * 2) )
		{
			arc = 2;
		}
		else
			arc = 1;
	}
	if( x < 0 && y >= 0 )
	{
		x = -x;
		if( y < x/2 )
		{
			arc = 5-0;
		}
		else if ( y > (x * 2) )
		{
			arc = 5-2;
		}
		else
			arc = 5-1;
	}
	if( x < 0 && y < 0 )
	{
		x = -x;
		y = -y;
		if( y < x/2 )
		{
			arc = 6 + 0;
		}
		else if ( y > (x * 2) )
		{
			arc = 6 + 2;
		}
		else
			arc = 6 + 1;
	}
	if( x >= 0 && y < 0 )
	{
		y = -y;
		if( y < x/2 )
		{
			arc = 11 - 0;
		}
		else if ( y > (x * 2) )
		{
			arc = 11 - 2;
		}
		else
			arc = 11 - 1;
	}
	if( knob->_b & MK_LBUTTON )
	{
		knob->flags.draw_update_arc = 0;
		if( b & MK_LBUTTON )
		{
			if( ( knob->delta_arc + arc ) != knob->last_arc )
			{
				int forward = ( knob->delta_arc + arc ) - knob->last_arc;
				int backward = knob->last_arc - ( knob->delta_arc + arc );
				if( forward < 0 )
					forward += 12;
				if( backward < 0 )
					backward += 12;
				//lprintf( "arc : %d last:%d for: %d bak: %d", arc, knob->last_arc, forward, backward );
				if( forward < backward )
				{
					if( knob->event_handler )
						knob->event_handler( knob->psvEvent, forward );
				}
				else
				{
					if( knob->event_handler )
						knob->event_handler( knob->psvEvent, -backward );
				}
				if( knob->last_arc != ( knob->delta_arc + arc ) % 12 )
				{
					knob->last_arc = ( knob->delta_arc + arc ) % 12;
					// no motion, no reason to update
					knob->flags.draw_update_arc = 1;
				}
			}
		}
		else
		{
         // release drag
			knob->_b &= ~MK_LBUTTON;
		}
	}
	else
	{
		if( b & MK_LBUTTON )
		{
			knob->_b |= MK_LBUTTON;
			knob->delta_arc = knob->last_arc - arc;
			knob->last_arc = ( knob->delta_arc + arc ) % 12;
			knob->flags.draw_update_arc = 0;
		}
		else
		{
			// mouse was not down, entering control....
			knob->_first_arc = arc;
			knob->flags.draw_update_arc = 0;
		}
	}
   if( knob->flags.draw_update_arc )
		SmudgeCommon( pc );
	return 1;
}
static int OnDrawCommon( CONTROL_SCROLL_KNOB_NAME )( PSI_CONTROL pc )
{
	ValidatedControlData( PScrollKnob, sk_MyControlID[0], knob, pc );
	if( knob )
	{
		Image surface;
		surface = GetControlSurface( pc );
		if( !knob->knob_sprite )
		{
			ClearImageTo( surface, BASE_COLOR_RED );
			PutString( surface, 0, 0, BASE_COLOR_WHITE, 0, "No Image" );
			return 1;
		}
		ClearImageTo( surface, 0x1000001 );
		{
			uint32_t image_width = 0, image_height = 0;
			GetImageSize( knob->knob_image, &image_width, &image_height );
			if( image_width && image_height ) {
				knob->width_scale = 0x10000 * surface->width / image_width;
				knob->height_scale = 0x10000 * surface->height / image_height;
				SetSpritePosition( knob->knob_sprite, surface->width  / 2, surface->height / 2 );
				rotate_scaled_sprite( surface
										  , knob->knob_sprite
										  , ( ( 0x100000000LL/12 ) * knob->last_arc ) - knob->zero_angle
										  , knob->width_scale
										  , knob->height_scale
										  );
			}
		}
	}
	return 1;
}
#ifndef NO_TOUCH
static int OnTouchCommon( CONTROL_SCROLL_KNOB_NAME )( PSI_CONTROL pc, PINPUT_POINT inputs, int input_count )
{
	ValidatedControlData( PScrollKnob, sk_MyControlID[0], knob, pc );
	if( knob )
	{
	}
	return 0;
}
#endif
void SetScrollKnobEvent( PSI_CONTROL pc, KnobEvent event, uintptr_t psvEvent )
{
	ValidatedControlData( PScrollKnob, sk_MyControlID[0], knob, pc );
	if( knob )
	{
		knob->psvEvent = psvEvent;
		knob->event_handler = event;
	}
}
PSI_PROC( void, SetScrollKnobImageName )( PSI_CONTROL pc, CTEXTSTR image )
{
	ValidatedControlData( PScrollKnob, sk_MyControlID[0], knob, pc );
	if( knob )
	{
		knob->knob_image_file = StrDup( image );
		UnmakeImageFile( knob->knob_image );
		knob->knob_image = LoadImageFile( image );
		if( knob->knob_image ) {
			if( knob->knob_sprite )
				UnmakeSprite( knob->knob_sprite, 0 );
			knob->knob_sprite = MakeSpriteImage( knob->knob_image );
			{
				uint32_t image_width, image_height;
				uint32_t control_width, control_height;
				GetFrameSize( pc, &control_width, &control_height );
				GetImageSize( knob->knob_image, &image_width, &image_height );
				knob->width_scale = 0x10000 * control_width / image_width;
				knob->height_scale = 0x10000 * control_height / image_height;
				SetSpritePosition( knob->knob_sprite, control_width / 2, control_height / 2 );
				SetSpriteHotspot( knob->knob_sprite, image_width / 2, image_height / 2 );
			}
		}
	}
}
PSI_PROC( void, SetScrollKnobImage )( PSI_CONTROL pc, Image image )
{
	PScrollKnob knob = ControlData( PScrollKnob, pc );
	if( knob )
	{
		knob->knob_image = image;
		if( image ) {
			if( knob->knob_sprite )
				UnmakeSprite( knob->knob_sprite, 0 );
			knob->knob_sprite = MakeSpriteImage( knob->knob_image );
			{
				uint32_t image_width, image_height;
				uint32_t control_width, control_height;
				GetFrameSize( pc, &control_width, &control_height );
				GetImageSize( knob->knob_image, &image_width, &image_height );
				knob->width_scale = 0x10000 * control_width / image_width;
				knob->height_scale = 0x10000 * control_height / image_height;
				SetSpritePosition( knob->knob_sprite, control_width / 2, control_height / 2 );
				SetSpriteHotspot( knob->knob_sprite, image_width / 2, image_height / 2 );
			}
		}
	}
}
// fixed is defined in image.h
// angle is a fixed scaled integer with 0x1 0000 0000 being the full circle.
PSI_PROC( void, SetScrollKnobImageZeroAngle )( PSI_CONTROL pc, fixed angle )
{
	ValidatedControlData( PScrollKnob, sk_MyControlID[0], knob, pc );
	if( knob )
	{
		knob->zero_angle = angle;
	}
}
#ifndef PSI_GLOBAL_STRUCTURE_DEFINED
#define PSI_GLOBAL_STRUCTURE_DEFINED
//DOM-IGNORE-BEGIN
#define g global_psi_structure
//DOM-IGNORE-END
#ifndef PSI_SERVICE
#  ifndef FORCE_NO_INTERFACE
 // some people including this may have already defined this
#    ifndef USE_IMAGE_INTERFACE
#define USE_IMAGE_INTERFACE global_psi_structure.MyImageInterface
#    endif
#  endif
#endif
#ifdef __cplusplus_cli
//#  undef USE_INTERFACES
#else
#  ifdef FORCE_NO_INTERFACE
#    undef USE_INTERFACES
#  else
#    define USE_INTERFACES
#  endif
#endif
#ifndef PSI_SERVICE
#  ifndef FORCE_NO_INTERFACE
#define USE_RENDER_INTERFACE global_psi_structure.MyDisplayInterface
#  endif
#endif
PSI_NAMESPACE
#if !defined( CONTROL_BASE )
extern
#endif
	CDATA DefaultColors[14];
//DOM-IGNORE-BEGIN
typedef struct psi_global_tag
{
#ifndef PSI_SERVICE
#  ifndef FORCE_NO_INTERFACE
	PIMAGE_INTERFACE MyImageInterface;
	PRENDER_INTERFACE MyDisplayInterface;
#endif
#endif
	struct {
		// will be set optionally when on a touch display
		// which will auto-magically grow certain controls
      // listbox, scrollbar...
		BIT_FIELD touch_display : 1;
		BIT_FIELD fancy_border : 1;
		BIT_FIELD bLogDebugUpdate : 1;
 // removes dirty, and expects to have to draw every display frame
		BIT_FIELD always_draw : 1;
		BIT_FIELD bLogDetailedMouse : 1;
		BIT_FIELD bLogSuperDetailedMouse : 1;
		BIT_FIELD bLogKeyEvents : 1;
		BIT_FIELD allow_threaded_draw : 1;
 // don't use fancy border... unless it's also set externally
		BIT_FIELD system_color_set : 1;
		BIT_FIELD allow_copy_from_render : 1;
	} flags;
	PLIST borders;
	PFrameBorder DefaultBorder;
#if 0
	CDATA *defaultcolors;
	int32_t BorderWidth;
	int32_t BorderHeight;
	struct psi_global_border_info {
 // 0 = none, 1=left, 2=center, 3=right
		BIT_FIELD bAnchorTop : 2;
 // 0 = none, 1=left, 2=center, 3=right
		BIT_FIELD bAnchorBottom : 2;
 // 0 = none, 1=top, 2=center, 3=bottom
		BIT_FIELD bAnchorLeft : 2;
 // 0 = none, 1=top, 2=center, 3=bottom
		BIT_FIELD bAnchorRight : 2;
	} Border;
	Image BorderImage;
 // really 8, but symetry is kept
	Image BorderSegment[9];
#endif
	Image FrameCaptionImage;
	Image FrameCaptionFocusedImage;
	Image StopButton;
	Image StopButtonPressed;
	int   StopButtonPad;
	PLIST shown_frames;
	SFTFont default_font;
	PTHREAD updateThread;
}PSI_GLOBAL;
enum {
	SEGMENT_TOP_LEFT
	  , SEGMENT_TOP
	  , SEGMENT_TOP_RIGHT
	  , SEGMENT_LEFT
	  , SEGMENT_CENTER
	  , SEGMENT_RIGHT
	  , SEGMENT_BOTTOM_LEFT
	  , SEGMENT_BOTTOM
	  , SEGMENT_BOTTOM_RIGHT
     // border segment index's
};
#if !defined( CONTROL_BASE ) && (defined( SOURCE_PSI2 ) || defined( __cplusplus_cli ))
extern
#endif
#ifndef __cplusplus_cli
#  ifdef WIN32
#    if !defined( SOURCE_PSI2 )
#      if !defined( CONTROL_BASE )
__declspec(dllimport)
#      else
__declspec(dllexport)
#      endif
#    endif
#  else
#    if !defined( SOURCE_PSI2 )
#      if !defined( CONTROL_BASE )
extern
#      else
#      endif
#    endif
#  endif
#endif
/* This is the structure PSI uses to track .... what? The
   application has to know its own handles... what does PSI keep
   anyhow? most methods are registered now.                      */
PSI_GLOBAL global_psi_structure
#ifndef CONTROL_BASE
;
#else
= {
#ifndef PSI_SERVICE
#  ifndef FORCE_NO_INTERFACE
	NULL, NULL,
#  endif
#endif
  { 0 }
  // none of these should be 0 (black) may be 1 (nearest black)
  , 0 };
#endif
//DOM-IGNORE-END
#ifndef CONTROL_BASE
extern
#endif
	void GetMyInterface( void );
// --------- borders.c --------------
void UpdateSurface( PSI_CONTROL pc );
void CPROC DrawFancyFrame( PSI_CONTROL pc );
void CPROC DrawNormalFrame( PSI_CONTROL pc );
PSI_NAMESPACE_END
#endif
// $Log: global.h,v $
// Revision 1.13  2005/03/23 12:20:53  panther
// Fix positioning of common buttons.  Also do a quick implementation of fancy borders.
//
// Revision 1.12  2005/03/23 02:43:07  panther
// Okay probably a couple more badly initialized 'unusable' flags.. but font rendering/picking seems to work again.
//
// Revision 1.11  2005/03/22 12:41:58  panther
// Wow this transparency thing is going to rock! :) It was much closer than I had originally thought.  Need a new class of controls though to support click-masks.... oh yeah and buttons which have roundable scaleable edged based off of a dot/circle
//
// Revision 1.10  2004/10/24 20:09:47  d3x0r
// Sync to psilib2... stable enough to call it mainstream.
//
// Revision 1.3  2004/10/07 04:37:16  d3x0r
// Okay palette and listbox seem to nearly work... controls draw, now about that mouse... looks like my prior way of cheating is harder to step away from than I thought.
//
// Revision 1.2  2004/10/06 09:52:16  d3x0r
// checkpoint... total conversion... now how does it work?
//
// Revision 1.1  2004/09/19 19:22:31  d3x0r
// Begin version 2 psilib...
//
// Revision 1.9  2003/04/02 07:31:25  panther
// Enable local GetMyInterface which will auto configure library to current link
//
// Revision 1.8  2003/03/29 15:52:17  panther
// Fix service PSI compilation (direct link to render/image).  Just for grins make caption text 3dlike
//
// Revision 1.7  2003/03/25 08:45:56  panther
// Added CVS logging tag
//
#ifndef PSI_CONSOLE_INTERFACE_DEFINED
#define PSI_CONSOLE_INTERFACE_DEFINED
#ifdef PSI_CONSOLE_SOURCE
#define PSI_CONSOLE_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define PSI_CONSOLE_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
#define _CONSOLE_NAMESPACE namespace console {
#define PSI_CONSOLE_NAMESPACE PSI_NAMESPACE _CONSOLE_NAMESPACE
#define PSI_CONSOLE_NAMESPACE_END } PSI_NAMESPACE_END
#define USE_PSI_CONSOLE_NAMESPACE using namespace sack::PSI::console
#else
#define _CONSOLE_NAMESPACE
#define PSI_CONSOLE_NAMESPACE
#define PSI_CONSOLE_NAMESPACE_END
#define USE_PSI_CONSOLE_NAMESPACE
#endif
PSI_NAMESPACE
	_CONSOLE_NAMESPACE
typedef struct PSI_console_phrase *PSI_Console_Phrase;
typedef struct PSI_console_feedback *PSI_Console_Feedback;
typedef void (*PSI_Console_FeedbackClick)( uintptr_t psv_user, PSI_Console_Phrase );
typedef struct PSI_console_draw_context *PSI_Console_DrawContext;
typedef void (*PSI_ConsoleMeasure)(void);
typedef void(* PSI_ConsoleOutput)( void );
PSI_CONSOLE_PROC( void, PSIConsoleLoadFile )( PSI_CONTROL pc, CTEXTSTR filename );
PSI_CONSOLE_PROC( void, PSIConsoleSaveFile )( PSI_CONTROL pc, CTEXTSTR filename );
PSI_CONSOLE_PROC( int, vpcprintf )( PSI_CONTROL pc, CTEXTSTR format, va_list args );
PSI_CONSOLE_PROC( int, pcprintf )( PSI_CONTROL pc, CTEXTSTR format, ... );
// this results with a context structure that allows referencing the line in the console in the future..
PSI_CONSOLE_PROC( PSI_Console_Phrase, PSIConsoleOutput )( PSI_CONTROL pc, PTEXT lines );
PSI_CONSOLE_PROC( PSI_Console_Phrase, PSIConsoleDirectOutput )( PSI_CONTROL pc, PTEXT lines );
PSI_CONSOLE_PROC( void, PSI_Console_SetPhraseData )( PSI_Console_Phrase phrase, uintptr_t psv );
PSI_CONSOLE_PROC( uintptr_t, PSI_Console_GetPhraseData )( PSI_Console_Phrase phrase );
/* measure and draw */
PSI_CONSOLE_PROC( PSI_Console_DrawContext, PSIConsoleCreateDrawContext )( PSI_CONTROL pc, PSI_ConsoleMeasure, PSI_ConsoleOutput );
PSI_CONSOLE_PROC( PSI_Console_Phrase, PSIConsoleOwnerDrawnOutput )( PSI_CONTROL pc, PSI_Console_DrawContext, uintptr_t psv_user_data );
/* register a callback to get the line that was input into the console by the user */
PSI_CONSOLE_PROC( void, PSIConsoleInputEvent )( PSI_CONTROL pc, void(CPROC*Event)(uintptr_t,PTEXT), uintptr_t psv );
/* if TRUE, then the line that was read is immediately queued to the output stream */
PSI_CONSOLE_PROC( void, PSIConsoleSetLocalEcho )( PSI_CONTROL pc, LOGICAL yesno );
PSI_CONSOLE_PROC( LOGICAL, PSIConsoleGetLocalEcho )( PSI_CONTROL pc );
PSI_CONSOLE_PROC( PSI_Console_Feedback, PSI_ConsoleDefineFeedback )( PSI_Console_FeedbackClick, uintptr_t );
// during a feedback event, this can be used to remove the current mesasge.
//PSI_CONSOLE_PROC( PSI_Console_Feedback, PSI_Console_FeedbackDelete )( PSI_Feedback context );
//PSI_CONSOLE_PROC( void, PSIConsoleSetMessageFeedbackHandler )( PSI_CONTROL pc, PSI_Feedback );
// this is an access into to use console features to wrap long text into a block.
// passed width in characters, no font.
PSI_CONSOLE_PROC( void, FormatTextToBlock )( CTEXTSTR input, TEXTSTR *output, int char_width, int char_height );
// the width and height passed are updated for the actual pixel width and height of the text block
// this allows a larger height to be passed; and allows the box to be shrunk slightly for width if
// words and roundings made it smaller than it appears.  (allow better centering)
// this is an access into to use console features to wrap long text into a block.
// font can be NULL and 0,0 for pixel size to format by characters only.
PSI_CONSOLE_PROC( void, FormatTextToBlockEx )( CTEXTSTR input, TEXTSTR *output, int *pixel_width, int *pixel_height, SFTFont font );
PSI_CONSOLE_PROC( struct history_tracking_info *, PSIConsoleSaveHistory )( PSI_CONTROL pc );
PSI_CONSOLE_PROC( void, PSIConsoleSetHistory )( PSI_CONTROL pc, struct history_tracking_info *history_info );
// mode 0 = inline/scrolling
// mode 1 = line buffer/scrolling
// mode 2 = line buffer/wrap
PSI_CONSOLE_PROC( void, PSIConsoleSetInputMode )( PSI_CONTROL pc, int mode );
PSI_CONSOLE_PROC( void, PSI_SaveConsoleToFile )( PSI_CONTROL pc, FILE *file );
PSI_CONSOLE_PROC( void, PSI_ReadConsoleFromFile )( PSI_CONTROL pc, FILE *file );
PSI_CONSOLE_NAMESPACE_END;
USE_PSI_CONSOLE_NAMESPACE;
#endif
#ifndef MY_DATAPATH_DEFINED
#define MY_DATAPATH_DEFINED
#ifndef CORECON_SOURCE
#if defined( SACK_BAG_EXPORTS ) || defined( PSI_CONSOLE_SOURCE )
#define CORECON_SOURCE
#endif
#endif
#ifdef CORECON_SOURCE
#define CORECON_NPROC(type,name) EXPORT_METHOD type name
#define CORECON_PROC(type,name) EXPORT_METHOD type CPROC name
// for defining variables.
#define CORECON_EXPORT(type,name) EXPORT_METHOD type name
#else
#define CORECON_NPROC(type,name) IMPORT_METHOD type name
#define CORECON_PROC(type,name) IMPORT_METHOD type CPROC name
// for defining variables.
#define CORECON_EXPORT(type,name) IMPORT_METHOD type name
#endif
//#define DEBUG_OUTPUT
#ifdef DEKWARE_PLUGIN
#define PLUGIN_MODULE
#include "plugin.h"
#include "datapath.h"
#include "space.h"
#endif
  // history_track
#ifndef console_history_defined
#define console_history_defined
//#define MAX_HISTORY 25000
//#define MAX_HISTORY_LINES 100
//#define MAX_HISTORY_BLOCKS (MAX_HISTORY/MAX_HISTORY_LINES)
//#include "histstruct.h"
PSI_CONSOLE_NAMESPACE
#define STRUC_PREFIX(n) n
 /*PCONSOLE_INFO*/
typedef void (CPROC *MeasureString )( uintptr_t console, CTEXTSTR s, int nShow, uint32_t *w, uint32_t *h, SFTFont font );
typedef struct STRUC_PREFIX(history_line_tag) TEXTLINE, *PTEXTLINE;
typedef struct STRUC_PREFIX(history_block_link_tag) HISTORY_BLOCK_LINK, *PHISTORY_BLOCK_LINK;
typedef struct STRUC_PREFIX(history_block_tag) HISTORYBLOCK, *PHISTORYBLOCK;
typedef struct STRUC_PREFIX(history_region_tag)  HISTORY_REGION, *PHISTORY_REGION;
typedef struct STRUC_PREFIX(displayed_line_info_tag)  DISPLAYED_LINE, *PDISPLAYED_LINE;
typedef struct STRUC_PREFIX(history_browser_cursor_tag) HISTORY_BROWSER, *PHISTORY_BROWSER;
typedef struct STRUC_PREFIX(history_line_cursor_tag) HISTORY_LINE_CURSOR, *PHISTORY_LINE_CURSOR;
typedef struct STRUC_PREFIX(history_tracking_tag) HISTORYTRACK, *PHISTORYTRACK;
typedef struct STRUC_PREFIX(history_bios_tag) HISTORY_BIOS, *PHISTORY_BIOS;
CORECON_PROC( PHISTORY_REGION, PSI_CreateHistoryRegion )( void );
CORECON_PROC( PHISTORY_LINE_CURSOR, PSI_CreateHistoryCursor )( PHISTORY_REGION );
CORECON_PROC( PHISTORY_BROWSER, PSI_CreateHistoryBrowser )( PHISTORY_REGION, MeasureString, uintptr_t );
CORECON_PROC( void, PSI_DestroyHistoryRegion )( PHISTORY_REGION );
CORECON_PROC( void, PSI_DestroyHistoryCursor )( PHISTORY_LINE_CURSOR );
CORECON_PROC( void, PSI_DestroyHistoryBrowser )( PHISTORY_BROWSER );
CORECON_PROC( void, PSI_DestroyHistory )( PHISTORYTRACK pht );
CORECON_PROC( PSI_Console_Phrase, PSI_EnqueDisplayHistory )( PHISTORY_LINE_CURSOR phc, PTEXT pLine );
CORECON_PROC( int, PSI_GetLastLineLength )( PHISTORY_REGION pht );
CORECON_PROC( void, PSI_InitHistory )( PHISTORY_REGION pht, PTEXT name );
//void CalculateHistory( PHISTORYTRACK pht, int columns, int lines );
CORECON_PROC( void, PSI_SetHistoryBrowserNoPageBreak )( PHISTORY_BROWSER phbr );
CORECON_PROC( void, PSI_SetHistoryBrowserOwnPageBreak )( PHISTORY_BROWSER phbr );
// get a line - enumerate - start start == 0;
// this routine will auto step start++...
CORECON_PROC( PTEXT, PSI_EnumHistoryLine )( PHISTORY_BROWSER pht
							, int *offset
							, int32_t *length );
CORECON_PROC( void, PSI_SetHistoryDefaultForeground )( PHISTORY_LINE_CURSOR phc, int iColor );
CORECON_PROC( void, PSI_SetHistoryDefaultBackground )( PHISTORY_LINE_CURSOR phc, int iColor );
//int BeginHistory( PHISTORY_LINE_CURSOR cursor );
// adjust history by offset...
int AlignHistory( PHISTORY_BROWSER cursor, int32_t nOffset, SFTFont font );
int HistoryNearEnd( PHISTORY_BROWSER cursor, int nLines );
// this takes into account typing a command, and recording a macro plus the dekware object prmopt...
int FixCommandCursor( PHISTORY_BROWSER pht, PUSER_INPUT_BUFFER CommandInfo
#ifdef __DEKWARE_PLUGIN__
						  , PMACRO pRecord
#endif
						  , int bEndOfStream );
int GetCursorLine( PHISTORY_LINE_CURSOR cursor );
int GetCommandCursor( PHISTORY_BROWSER phbr
					 , SFTFont font
						  , PUSER_INPUT_BUFFER CommandInfo
						  , int bEndOfStream
						, int bWrapCommand
						  , int *command_offset
						  , int *command_begin
						  , int *command_end
						  , int *command_pixel_start
						  , int *command_pixel_cursor
						  , int *line_offset
						  );
// Set line position
void SetCursorLine( PHISTORY_LINE_CURSOR cursor, int nLine );
// set total number of lines...
void SetCursorHeight( PHISTORY_LINE_CURSOR cursor, int nHeight );
CORECON_PROC( void, SetBrowserHeight )( PHISTORY_BROWSER cursor, int nLines );
// get column position
int GetCursorColumn( PHISTORY_LINE_CURSOR cursor );
// set column position
void SetCursorColumn( PHISTORY_LINE_CURSOR cursor, int nColumn );
// set total columns available...
void SetCursorWidth( PHISTORY_LINE_CURSOR cursor, int size );
void SetBrowserWidth( PHISTORY_BROWSER cursor, int size );
void SetBrowserFirstLine( PHISTORY_BROWSER cursor, int nLIne );
void SetCursorNoPrompt( PHISTORY_BROWSER phbr, LOGICAL bNoPrompt );
// computation of line is computed from the cursor's columns.
// amount +/- 1 == lineup down
// amount +/- N == pageup down
int MoveHistoryCursor( PHISTORY_BROWSER phbr, int amount );
uint32_t ComputeNextOffset( PTEXT segment, uint32_t nShown );
//int ComputeToShow( uint32_t cols, PTEXT segment, int nOfs, int nShown );
uint32_t ComputeToShow( uint32_t colsize, uint32_t *col_offset, PTEXT segment, uint32_t nLen, uint32_t nOfs, uint32_t nShown, PHISTORY_BROWSER phbr, SFTFont font );
int CountLinesSpanned( PHISTORY_BROWSER phb, PTEXT countseg, SFTFont font, LOGICAL count_trailing_linefeeds );
CORECON_PROC( void, BuildDisplayInfoLines )( PHISTORY_BROWSER phlc, PHISTORY_BROWSER leadin, SFTFont font );
#ifdef __DEKWARE_PLUGIN__
// this takes into account typing a command, and recording a macro plus the dekware object prmopt...
int GetCommandCursor( PHISTORY_BROWSER phbr
						  , COMMAND_INFO *CommandInfo
						  , int bEndOfStream
                    , int *command_offset
						  , int *command_begin
                    , int *command_end
						  );
#endif
CORECON_PROC( PDATALIST *,GetDisplayInfo )( PHISTORY_BROWSER phbr );
void GetHistoryCursorPos( PHISTORY_LINE_CURSOR phlc, int32_t* x, int32_t* y );
void SetHistoryCursorPos( PHISTORY_LINE_CURSOR phlc, int32_t x, int32_t y );
void PSI_SetHistoryPageLines( PHISTORY_BROWSER phbr, uint32_t nLines );
int32_t GetBrowserDistance( PHISTORY_BROWSER phbr, SFTFont font );
void ResetHistoryBrowser( PHISTORY_BROWSER phbr );
CORECON_PROC( int, CountDisplayedLines) ( PHISTORY_BROWSER phbr );
void SetHistoryBackingFile( PHISTORY_REGION phr, FILE *file );
//void SetHistoryBrowserOwnPageBreak( PHISTORY_BROWSER phbr );
//void SetHistoryBrowserNoPageBreak( PHISTORY_BROWSER phbr );
PSI_CONSOLE_NAMESPACE_END
#endif
PSI_CONSOLE_NAMESPACE
#if !defined( WIN32 ) && !defined( _WIN32 )
typedef struct rect_tag {
	int32_t top,left,right,bottom;
} RECT;
#endif
//----------------------------------------------------------------------------
// unused STILL - but one day status bars on output may be useful!
typedef struct statfield_tag {
 // line to pass to macroduplicate to get the actual string
	PTEXT *pLine;
 // length of this field - text will not exceed this
	int nLength;
	struct statfield_tag **me;
 // next to the right or next to the left...
	struct statfield_tag *pNext;
} STATFIELD, *PSTATFIELD;
typedef struct statbar_tag {
	PSTATFIELD *pLeft, *pRight;
} STATBAR, *PSTATBAR;
//----------------------------------------------------------------------------
 // overrides to default definitions
typedef struct keybind_tag {
	struct {
		  int bMacro:1;
		  int bFunction:1;
		int bStroke:1;
	} flags;
	union {
		PTEXT stroke;
	} data;
} KEYBIND, *PKEYBIND;
//----------------------------------------------------------------------------
// virtual buffer?
// video buffer?
//typedef struct vbuffer_tag {
	//int nDisplayLines;
	// nLines>0
	// ? nLines - nDisplayLines == nHistoryLines
	// : nHistoryLines = nLines
	//int nHistoryPercent; // 0 = 25, 1 = 50, 2 = 75, 3 = 100
	//int nCursorX; // current offset on current line
	//int nCursorY; // line offset from last line ... ( -1-> - lines)
	//int tabsize;	// multiple size of tabs....
//} VBUFFER, *PVBUFFER;
enum current_color_type
{
	COLOR_COMMAND
, COLOR_MARK
, COLOR_DEFAULT
, COLOR_SEGMENT
};
enum fill_color_type
{
	FILL_COMMAND_BACK
, FILL_DISPLAY_BACK
};
struct history_tracking_info
{
	// these are within the history cursor...
	// and this is the reason I need another cursor for
	// history and for display...
	// perhaps I could just always have two versions of browsing
	// browse_end, browse_current ?
	PHISTORY_REGION pHistory;
	// region history is browsed here,
	// this cursor is controlled for the top/bottom of form
	// control
	PHISTORY_BROWSER pHistoryDisplay;
	// output is performed here.
	// view is always built from tail backward.(?)
	PHISTORY_BROWSER pCurrentDisplay;
	// history, but on the outbound side?
	//
	// cursor as output has a cursor position
	// and a seperate cursor position for browsing...
	// I should probably seperate the data, but they
	// share the same width/height...
	PHISTORY_LINE_CURSOR pCursor;
	uint32_t pending_spaces;
	uint32_t pending_tabs;
};
//----------------------------------------------------------------------------
typedef struct myconsolestruc {
	// these would otherwise exist within the common datapath structure...
	PUSER_INPUT_BUFFER CommandInfo;
	// physical width and height, (1:1 in console modes)
	// in pixels
	uint32_t nWidth;
 // in character count width
	uint32_t nColumns;
  // in pixels
	uint32_t nHeight;
	// in character count rows
	uint32_t nLines;
	CRITICALSECTION Lock;
	int lockCount;
	void(CPROC*InputEvent)(uintptr_t, PTEXT);
	uintptr_t psvInputEvent;
	struct {
 // alternative to direct is Line-Mode
		BIT_FIELD bDirect:1;
 // normal mode is ot not wrap, but to scroll off...
		BIT_FIELD bWrapCommand : 1;
 // set if the last thing output was the command.
		BIT_FIELD bLastEnqueCommand:1;
		BIT_FIELD bUpdatingEnd : 1;
		BIT_FIELD bMarking : 1;
		BIT_FIELD bMarkingBlock : 1;
		BIT_FIELD bNoDisplay : 1;
		BIT_FIELD bNoHistoryRender : 1;
		BIT_FIELD bForceNewline : 1;
		// character mode input, instead of line buffered
		// just because it's in direct mode doesn't mean it
		// has to be direct send also...  But CharMode is only
		// available if mode is also direct.
		BIT_FIELD bCharMode : 1;
		BIT_FIELD bNoLocalEcho : 1;
		BIT_FIELD bHistoryShow : 1;
 // set if the next line is NEW else it's to be appended.
		BIT_FIELD bNewLine : 1;
		BIT_FIELD bBuildDataWithCarriageReturn : 1;
	} flags;
	// these are working parameters during output...
	uint32_t pending_spaces;
	uint32_t pending_tabs;
 // pixel size of the display (if font height/width>1)
	RECT rArea;
	//uint32_t nFontHeight;
	//uint32_t nFontWidth;
 // pixels/lines to padd left/right side...
	int32_t nXPad;
 // pixels/lines to padd top/bottom side...
	int32_t nYPad;
 // pixels to raise bar above cmdline (wider for separated command line)
	int32_t nCmdLinePad;
	//PHISTORY_BIOS pHistory;
	int nHistoryPercent;
	// these mark the bottom line, from these UP
	// are the regions... therefore if start = 0
	// the first line to show is above the display and
	// therefore that region has no information to show.
 // bottom-most line of the display
	int nCommandLineStart;
  // upper text area
	int nHistoryLineStart;
 // top visual line of those in 'display' (start of separator)
	int nDisplayLineStartDynamic;
 // this is computed from the last position of the last renderd line ( continue for command line)
	int nNextCharacterBegin;
 // how wide the separation line is. (previously had some arbitrary constants)
	int nSeparatorHeight;
	uint32_t nFontHeight;
	// these are within the history cursor...
	// and this is the reason I need another cursor for
	// history and for display...
	// perhaps I could just always have two versions of browsing
	// browse_end, browse_current ?
	PHISTORY_REGION pHistory;
	// region history is browsed here,
	// this cursor is controlled for the top/bottom of form
	// control
	PHISTORY_BROWSER pHistoryDisplay;
	// output is performed here.
	// view is always built from tail backward.(?)
	PHISTORY_BROWSER pCurrentDisplay;
 // the data for pCommandDisplay to use... overlapping the input history had issues.
	PHISTORY_REGION pCommandHistory;
	// a display browser for formatting the command input line
	// in wrapped mode.
	PHISTORY_BROWSER pCommandDisplay;
	// history, but on the outbound side?
	//
	// cursor as output has a cursor position
	// and a seperate cursor position for browsing...
	// I should probably seperate the data, but they
	// share the same width/height...
	PHISTORY_LINE_CURSOR pCursor;
	PDATALIST *CurrentLineInfo;
	KEYBIND Keyboard[256][8];
	// is actually current keymod state.
	uint32_t dwControlKeyState;
	int mark_location;
	// 0 = command, 1 = display, 2 = history
	//, 3 = header?, 4 = footer?
	// display list this is a mark in.
	PDATALIST *CurrentMarkInfo;
	struct {
		int row, col;
	} mark_start;
	struct {
		int row, col;
	} mark_end;
	// something like a specialized footer here... probably a
	// PSTATBAR MenuBar; might fit in well also...
	//PSTATBAR StatusBar; // if present - then all lines must recompute!
	// ----------------
	// Rendering Methods for console_core library external methods...
	void (CPROC *FillConsoleRect)( struct myconsolestruc *pmdp, RECT *r, enum fill_color_type );
	void (CPROC *DrawString)( struct myconsolestruc *pmdp, int x, int y, RECT *r, CTEXTSTR s, int nShown, int nShow );
	void (CPROC *SetCurrentColor )( struct myconsolestruc *pmdp, enum current_color_type, PTEXT segment );
 // allow width to be returned.
	int (CPROC *RenderSeparator )( struct myconsolestruc *pmdp, int pos );
	void (CPROC *KeystrokePaste )( struct myconsolestruc *pmdp );
	void (CPROC *RenderCursor )( struct myconsolestruc *pmdp, RECT *r, int column );
	void (CPROC *Update )( struct myconsolestruc *pmdp, RECT *upd );
	// void CPROC
	PLIST data_processors;
	union {
		// this is what this union has if nothing else defined
		// winlogic should need no member herein....
		uint32_t dwInterfaceData[32];
		struct
		{
			PRENDERER renderer;
			PSI_CONTROL frame;
			Image image;
			CDATA  crCommand;
			CDATA  crCommandBackground;
			CDATA  crBackground;
			CDATA  crMark;
			CDATA  crMarkBackground;
			// current working parameters...
			CDATA crText;
			CDATA crBack;
		} psicon;
	};
} CONSOLE_INFO, *PCONSOLE_INFO;
#ifndef __KEYS_DEFINED__
#define __KEYS_DEFINED__
// included by consolestruc.h - please use this if you want to include ME
// return values from Func( PUSER_INPUT_BUFFER )
enum {
    UPDATE_NOTHING
 , UPDATE_COMMAND
 // requires calculate, render display, render history
 , UPDATE_DISPLAY
 , UPDATE_HISTORY
 //, SET_END_HISTORY // special return value - implies UPDATE_DISPLAY
 //, SET_END_COMMAND // special return value - implies UPDATE_DISPLAY
};
// common keys return TRUE if they did an actino which resulted in
// 0 - no update
// 1 - command line update (cursor or data)
// 2 - display update  (when history starts...)
// 3 - history update only...
CORECON_PROC( int, KeyShift     )( uint32_t* pKeyState, LOGICAL bState );
CORECON_PROC( int, KeyControl   )( uint32_t* pKeyState, LOGICAL bState );
CORECON_PROC( int, KeyAlt       )( uint32_t* pKeyState, LOGICAL bState );
CORECON_PROC( int, KeyLeft )( void * list, PUSER_INPUT_BUFFER pci );
CORECON_PROC( int, KeyRight )( void * list, PUSER_INPUT_BUFFER pci );
CORECON_PROC( int, KeyInsert )( void * list, PUSER_INPUT_BUFFER pci );
CORECON_PROC( int, CommandKeyUp )( void * list, PUSER_INPUT_BUFFER pci );
CORECON_PROC( int, HandleKeyDown )(  void * list, PUSER_INPUT_BUFFER pci );
CORECON_PROC( int, KeyHome )( void * list, PUSER_INPUT_BUFFER pci );
CORECON_PROC( int, KeyEndCmd )( uintptr_t list, PUSER_INPUT_BUFFER pci );
CORECON_PROC( int, KeyEndHst )( PHISTORY_BROWSER pht );
CORECON_PROC( int, HistoryPageUp )( PHISTORY_BROWSER pht );
CORECON_PROC( int, HistoryPageDown )( PHISTORY_BROWSER pht );
CORECON_PROC( int, HistoryLineUp )( PHISTORY_BROWSER pht );
CORECON_PROC( int, HistoryLineDown )( PHISTORY_BROWSER pht );
//CPROC KeystrokePaste( PCONSOLE_INFO pht );
enum {
    KEY_FUNCTION_NOT_DEFINED = 0
    , KEYDATA
 // do this stroke?
 , KEYDATA_DEFINED
 , COMMANDKEY
 , HISTORYKEY
 , CONTROLKEY
 , SPECIALKEY
};
typedef struct KeyDefine {
   CTEXTSTR name1;
   CTEXTSTR name2;
   int flags;
   struct {
  // true if pStroke is pKeyFunc()
      int bFunction;
      union {
 // this may be pKeyFunc()
          PTEXT pStroke;
          void (CPROC *ControlKey)( uint32_t* pKeyState, LOGICAL bState );
          int (CPROC *CommandKey)( uintptr_t list, PUSER_INPUT_BUFFER pci );
          int (CPROC *HistoryKey)( PHISTORY_BROWSER pct );
 // PASTE
          int (CPROC *SpecialKey)( PCONSOLE_INFO pdp );
       } data;
   } op[8];
} PSIKEYDEFINE, *PPSIKEYDEFINE;
typedef int (CPROC *KeyFunc)( PCONSOLE_INFO pdp );
typedef int (CPROC *KeyFuncUpDown)( PCONSOLE_INFO pdp, int bDown );
//#define NONAMES { 0, 0, KDF_NOKEY }
//#define NUM_KEYS ( sizeof( KeyDefs ) / (sizeof(KEYDEFINE)) )
 // set to disallow key redefinition
#define KDF_NODEFINE 0x01
#define KDF_NOREDEF  0x10
 // key is sensitive to capslock state
#define KDF_CAPSKEY  0x02
 // key is sensitive to numlock state
#define KDF_NUMKEY   0x04
// the numpad returns num0 - ...
// or numpad returns home/end/pgdn etc...
//#define KDF_NUMKEY   0x04 // Key is sensitive to numlock state
 // no keydef here...
#define KDF_NOKEY    0x08
#define KDF_NOREDEF  0x10
 // action is called on key release
#define KDF_UPACTION 0x20
#ifndef KEYS_DEFINED
//CORECON_EXPORT( TEXT, KeyStroke[] );
#ifndef CORECON_SOURCE
CORECON_EXPORT( PSIKEYDEFINE, KeyDefs[] );
#endif
#endif
#define KEYMOD_NORMAL 0
#define KEYMOD_SHIFT  KEY_MOD_SHIFT
#define KEYMOD_CTRL   KEY_MOD_CTRL
#define KEYMOD_ALT    KEY_MOD_ALT
#ifdef __DEKWARE_PLUGIN__
CORECON_PROC( int, KeyBind )( PDATAPATH pdp, PSENTIENT ps, PTEXT parameters );
CORECON_PROC( int, KeyUnBind )( PDATAPATH pdp, PSENTIENT ps, PTEXT parameters );
#endif
CORECON_PROC(int, PSI_DoStroke )( PCONSOLE_INFO pdp, PTEXT stroke );
void PSI_KeyPressHandler( PCONSOLE_INFO pdp
						 , uint8_t key_index
						 , uint8_t mod
						 , PTEXT characters
						, SFTFont font
						 );
#endif
// $Log: keydefs.h,v $
// Revision 1.20  2005/06/10 10:31:59  d3x0r
// Fix setcolor usage so background is actually set.  Fix loading option table... most of the options are DLLIMPORT which is a void(**f)(...)
//
// Revision 1.19  2005/01/26 20:00:01  d3x0r
// Okay - need to do something about partial updates - such as command typing should only update that affected area of the screen...
//
// Revision 1.18  2005/01/23 04:07:57  d3x0r
// Hmm somehow between display rendering stopped working.
//
// Revision 1.17  2005/01/20 06:10:19  d3x0r
// One down, 3 to convert... concore library should serve to encapsulate drawing logic and history code...
//
// Revision 1.16  2004/09/29 09:31:32  d3x0r
//  Added support to make page breaks on output.  Fixed up some minor issues with scrollback distances
//
// Revision 1.15  2004/09/09 13:41:04  d3x0r
// works much better passing correct structures...
//
// Revision 1.14  2004/08/13 09:29:50  d3x0r
// checkpoint
//
// Revision 1.13  2004/07/30 14:08:40  d3x0r
// More tinkering...
//
// Revision 1.12  2004/06/12 08:42:34  d3x0r
// Well it initializes, first character causes failure... all windows targets build...
//
// Revision 1.11  2004/06/10 10:01:45  d3x0r
// Okay so cursors have input and output characteristics... history and display are run by seperate cursors.
//
// Revision 1.10  2004/06/08 00:23:26  d3x0r
// Display and history combing proceeding...
//
// Revision 1.9  2004/05/12 10:05:20  d3x0r
// checkpoint
//
// Revision 1.8  2004/03/08 09:25:42  d3x0r
// Fix history underflow and minor drawing/mouse issues
//
// Revision 1.7  2004/01/21 06:45:23  d3x0r
// Compiles okay - windows.  Test point
//
// Revision 1.6  2004/01/19 23:42:26  d3x0r
// Misc fixes for merging cursecon with psi/win con interfaces
//
// Revision 1.7  2004/01/19 00:02:06  panther
// Cursecon compat edits
//
// Revision 1.6  2004/01/18 22:02:31  panther
// Merge wincon/psicon/cursecon
//
// Revision 1.5  2003/03/26 02:05:21  panther
// begin updating option handlers to real option handlers
//
// Revision 1.4  2003/03/25 08:59:02  panther
// Added CVS logging
//
PSI_CONSOLE_NAMESPACE_END
#endif
#ifndef HISTORY_STRUCTURES_DEFINED
#define HISTORY_STRUCTURES_DEFINED
PSI_CONSOLE_NAMESPACE
struct history_line_tag {
	struct history_line_flags_tag {
		SBIT_FIELD nLineLength : 16;
		BIT_FIELD deleted : 1;
		//BIT_FIELD updated : 1;
	} flags;
	PTEXT pLine;
};
#if 0
typedef struct STRUC_PREFIX( history_line_tag ) TEXTLINE, *PTEXTLINE;
#define MAXTEXTLINESPERSET 256
DeclareSet( TEXTLINE );
#endif
struct history_block_link_tag {
	struct history_block_tag *next;
	union {
		struct history_block_tag **me;
		struct history_block_tag *prior;
	};
};
struct history_block_tag {
	// (me) == coincidentally the address of prior
	// block if we define *next as the first element...
	struct {
		struct history_block_tag *next;
		union {
			struct history_block_tag **me;
			struct history_block_tag *prior;
		};
	};
	int nLinesUsed;
	// INDEX nLinesAvail; // = MAX_HISTORY_LINES
#define MAX_HISTORY_LINES 250
	struct history_line_tag pLines[MAX_HISTORY_LINES];
};
struct history_region_tag {
	struct {
		// if next segment is NO_RETURN, force a return
		// if segment is a newline, use that, clear this anyhow.
 // set after entering a command
		uint32_t bForceNewline: 1;
 // when adding text at a cursor, otherwise overwrite
		uint32_t bInsert : 1;
		uint32_t bUpdated : 1;
	} flags;
	int nMaxHistoryBlocks;
	int nHistoryBlocks;
 // lines per block
	int nHistoryBlockSize;
	int nLines;
	int32_t tabsize;
	union {
		struct history_block_link_tag root;
		struct {
			PHISTORYBLOCK next;
			union {
				PHISTORYBLOCK *me;
				PHISTORYBLOCK last;
			};
		};
	} pHistory;
	// list of cursors on this block
	PLIST pCursors;
	PLIST pBrowsers;
	FILE *file_backing;
};
//----------------------------------------------------------------------------
struct displayed_line_info_tag
{
 // history line index...
	int nLine;
 // actual segment here
	PTEXT start;
	 // offset into start which begins this line.
	int nFirstSegOfs;
 // length of data we intend to show...
	int nToShow;
 // how long measure resulted this should be at...
	int nPixelStart;
 // how long measure resulted this should be at...
	int nPixelEnd;
 // absolute character that is the start line character index
	int nLineStart;
 // absolute character that is the last line character index
	int nLineEnd;
  // how high this line is...
	int nLineHeight;
 // top coordiante of this line...
	int nLineTop;
};
//----------------------------------------------------------------------------
struct history_browser_cursor_tag {
	PHISTORY_REGION region;
	//struct history_line_cursor_tag *phlc; // display width/height characteristics...
	// cursor position...
	// -1 = lastline, -2 next to last line..
	// pBlock->nLinesUsed + nCursorY = nLine;
	struct {
		uint32_t bWrapText : 1;
		uint32_t bNoPrompt : 1;
 // don't stop at page_breaks...
		uint32_t bNoPageBreak : 1;
 // dont' stop, but also return the page break segments... I want to render them.
		uint32_t bOwnPageBreak : 1;
		uint32_t bSetLineCounts : 1;
 // history region content has been updated.
		uint32_t bUpdated : 1;
	} flags;
	// visible region...
	//INDEX nLines;
	int nHeight;
 // number of lines to scroll up/down for 1 page.
	int nPageLines;
 // set as page lines... and cleared after first move.
	int nFirstLines;
 // rough character count/ depricated....
	int nColumns;
  // height of lines...
	int nLineHeight;
 // this is pixel size (using measure string)
	int nWidth;
  // first position of line to start at...
	int nLineStart;
	int nFirstLine;
	PDATALIST DisplayLineInfo;
	// current line of historyc block;
	// if nLine > 0, then the current block
	// is the base of stuff...
	int32_t nLine;
	/// this is more of a reference for the current output block;
	// it points to the last block (or the block recieving lines if seeked)
	PHISTORYBLOCK pBlock;
	// character offset within current segment
	int nOffset;
	CRITICALSECTION cs;
	MeasureString measureString;
	uintptr_t psvMeasure;
};
struct history_line_cursor_tag {
	PHISTORY_REGION region;
#ifdef _MSC_VER
#pragma pack (push, 1)
#endif
	PREFIX_PACKED struct {
		uint16_t nWidth;
		uint16_t nHeight;
	} PACKED;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
#ifdef _MSC_VER
#pragma pack (push, 1)
#endif
	PREFIX_PACKED struct {
		struct {
			PHISTORYBLOCK block;
			int32_t line;
			// may consider storing these for historical usage...
			// at the moment though, one current top for clear_page
			// works well.
		} top_of_form;
		// cursor position...
		// -1 = lastline, -2 next to last line..
		// pBlock->nLinesUsed + nCursorY = nLine;
		int16_t nCursorY;
		int16_t nCursorX;
		//PHISTORYBLOCK pBlock;
		// current line of historyc block;
		uint32_t nLine;
		// current line segment pointer, within which offset is.
		PTEXTLINE pLine;
		// the current segment
		PTEXT pSegment;
		// character offset within current segment
		int nOffset;
		// cursor paints prior color if no attributes
		// are specified on the text tag.
		FORMAT PriorColor;
		// when reset, the cursor gains this color.
		FORMAT DefaultColor;
	} output;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
} ;
//----------------------------------------------------------------------------
struct history_tracking_tag {
	int nRegions;
	PHISTORY_REGION pRegion;
	struct myconsolestruc *pdp;
} ;
struct history_bios_tag
// basic io system... takes all the above and
// brings together everything needed for
// a commandline, display, and fractional history
// anything more complex than this is going to
// have to be constructed...
{
	int nHistoryPercent;
	// these mark the bottom line, from these UP
	// are the regions... therefore if start = 0
	// the first line to show is above the display and
	// therefore that region has no information to show.
	int nHistoryLineStart;
 // top visual line of those in 'display' (start of separator)
	int nDisplayLineStart;
 // marks the top of the separator line... bottom of text
	int nCommandLineStart;
	// these are within the history cursor...
	// and this is the reason I need another cursor for
	// history and for display...
	// perhaps I could just always have two versions of browsing
	// browse_end, browse_current ?
	PHISTORY_REGION pHistory;
	// region history is browsed here,
	// this cursor is controlled for the top/bottom of form
	// control
	PHISTORY_BROWSER pHistoryDisplay;
	// output is performed here.
	// view is always built from tail backward.(?)
	PHISTORY_BROWSER pCurrentDisplay;
	// history, but on the outbound side?
	//
	// cursor as output has a cursor position
	// and a seperate cursor position for browsing...
	// I should probably seperate the data, but they
	// share the same width/height...
	PHISTORY_LINE_CURSOR pCursor;
};
struct PSI_console_word
{
	PTEXTLINE line;
	PTEXT segment;
	int cursor_position_added_at;
};
struct PSI_console_phrase
{
  // list of the words which may span multiple lines
	PLIST words;
	uintptr_t data;
};
struct PSI_console_feedback
{
	uintptr_t psv_user_data;
	PSI_Console_FeedbackClick feedback_handler;
};
PSI_CONSOLE_NAMESPACE_END
#endif
PSI_CONSOLE_NAMESPACE
#ifdef CURSECON
#define SEPARATOR_HEIGHT 1
#else
#define SEPARATOR_HEIGHT 4
#endif
// pass the rect describing the area...
// font size, etc will have been set in the datapath already...
CORECON_PROC( void, PSI_ConsoleCalculate )( PCONSOLE_INFO pdp, SFTFont font );
CORECON_PROC( void, PSI_RenderConsole )( PCONSOLE_INFO pdp, SFTFont font);
// this is a short calculation, assuming that
// the size of the whole surface has not changed,
// use this to update portions within...
CORECON_PROC(void, PSI_CalculateHistory )( PCONSOLE_INFO pdp );
CORECON_PROC( PSI_Console_Phrase, PSI_WinLogicWriteEx )( PCONSOLE_INFO pdp
												, PTEXT pLine
												, int update
												);
CORECON_PROC( void, PSI_WinLogicCalculateHistory )( PCONSOLE_INFO pdp, SFTFont font);
CORECON_PROC( void, PSI_WinLogicDoStroke )( PCONSOLE_INFO pdp, PTEXT pStroke );
// nChar could also be considered nColumn
CORECON_PROC(int, PSI_GetCharFromLine )( uint32_t cols
                         , PDISPLAYED_LINE pLine
                         , int nChar, TEXTCHAR *result );
CORECON_PROC(int, PSI_GetCharFromRowCol )( PCONSOLE_INFO pdp
                            , int row, int col
                            , char *data );
CORECON_PROC(TEXTCHAR *,PSI_GetDataFromBlock )( PCONSOLE_INFO pdp );
CORECON_PROC(int, PSI_ConvertXYToLineCol )( PCONSOLE_INFO pdp
                              , int x, int y
                              , int *line, int *col );
//CORECON_PROC(void, DoRenderHistory )( PCONSOLE_INFO pdp, int bHistoryStart );
CORECON_PROC(int, PSI_UpdateHistory )( PCONSOLE_INFO pdp, SFTFont font );
int GetCharFromLine( PCONSOLE_INFO console, uint32_t cols
						, PDISPLAYED_LINE pLine
						, int nChar, TEXTCHAR *result );
//------------------------------------------------------------------
// reflective definitions - these need to exist in the real project...
typedef struct penging_rectangle_tag
{
	struct {
		uint32_t bHasContent : 1;
		uint32_t bTmpRect : 1;
	} flags;
   CRITICALSECTION cs;
	int32_t x, y;
   uint32_t width, height;
} PENDING_RECT, *PPENDING_RECT;
void PSI_RenderCommandLine( PCONSOLE_INFO pdp, PENDING_RECT *region );
void CPROC PSIMeasureString( uintptr_t psvConsole, CTEXTSTR s, int nShown, uint32_t *w, uint32_t *h, SFTFont font );
PSI_CONSOLE_NAMESPACE_END
PSI_CONSOLE_NAMESPACE
struct BlockFormatter
{
	PCONSOLE_INFO console;
	SFTFont font;
};
static void CPROC AsciiMeasureString( uintptr_t psvConsole, CTEXTSTR s, int nShow, uint32_t *w, uint32_t *h, SFTFont font )
{
	struct BlockFormatter *block = (struct BlockFormatter*)psvConsole;
#ifndef __NO_GUI__
	if( block->font )
	{
		GetStringSizeFontEx( s, nShow, w, h, block->font );
	}
	else
#endif
	{
		(*w) = nShow;
		(*h) = 1;
	}
}
void FormatTextToBlockEx( CTEXTSTR input, TEXTSTR *output, int* pixel_width, int* pixel_height, SFTFont font )
{
	struct BlockFormatter *block_data = New( struct BlockFormatter );
	PCONSOLE_INFO console;
	TEXTSTR block;
	GetMyInterface();
	block_data->console
		= console = New( CONSOLE_INFO );
	block_data->font = font;
	MemSet( console, 0, sizeof( CONSOLE_INFO ) );
	{
		//console->common.pName = SegCreateFromText( "Auto Console" );
		//Log( "Create frame!!" );
		//console->nFontWidth = 1;
		//console->nFontHeight = 1;
		InitializeCriticalSec( &console->Lock );
		console->rArea.left = 0;
		console->rArea.right = (*pixel_width);
		console->rArea.top = 0;
		console->rArea.bottom = (*pixel_height);
		// this is destroyed when the common closes...
  //CreateUserInputBuffer();
		console->CommandInfo = NULL;
		//console->common.Type = myTypeID;
		console->flags.bDirect = 1;
		//console->common.flags.Formatted = TRUE;
		console->pHistory = PSI_CreateHistoryRegion();
		console->pCursor = PSI_CreateHistoryCursor( console->pHistory );
		console->pCurrentDisplay = PSI_CreateHistoryBrowser( console->pHistory, AsciiMeasureString, (uintptr_t)block_data );
		console->nXPad = 0;
		console->nYPad = 0;
		console->nCmdLinePad = 0;
		console->nFontHeight = GetFontHeight( font );
		PSI_ConsoleCalculate( console, font );
	}
	//console->nLines = char_height;
	//console->nColumns = char_width;
	{
		// ansi filter?
		// conditions for getting text lines which have format elements
		// break lines?
		PTEXT parsed;
		PTEXT next;
		PTEXT remainder = NULL;
		PTEXT tmp;
		PTEXT lines = SegCreateFromText( input );
		parsed = lines;
		//LineRelease( lines );
		remainder = parsed;
		for( tmp = parsed; tmp; tmp = next )
		{
			next = NEXTLINE( tmp );
			if( !GetTextSize( tmp ) )
			{
				PTEXT prior;
				PTEXT que;
				prior = SegBreak( tmp );
				if( prior )
				{
					SetStart( prior );
					prior->format.position.offset.spaces += (uint16_t)console->pending_spaces;
					prior->format.position.offset.tabs += (uint16_t)console->pending_tabs;
					if( prior->Next || GetTextSize( prior ) )
					{
						que = BuildLine( prior );
						if( !console->flags.bNewLine )
							que->flags |= TF_NORETURN;
						PSI_WinLogicWriteEx( console, que, 0 );
						LineRelease( prior );
					}
					else
						PSI_WinLogicWriteEx( console, prior, 0 );
				}
				//else
				//	PSI_WinLogicWriteEx( console, SegCreate( 0 ), 0 );
				//console->flags.bNewLine = 1;
				// throw away the blank... don't really need it on the display
				SegGrab( tmp );
				tmp->flags |= TF_NORETURN;
				PSI_WinLogicWriteEx( console, tmp, 0 );
				//console->pending_spaces = tmp->format.position.offset.spaces;
				//console->pending_tabs = tmp->format.position.offset.tabs;
				//LineRelease( tmp );
				remainder = next;
			}
		}
		if( remainder )
		{
			PTEXT que = BuildLine( remainder );
			LineRelease( remainder );
			que->flags |= TF_NORETURN;
			PSI_WinLogicWriteEx( console, que, 0 );
			 console->flags.bNewLine = 0;
		}
		else
		{
			//console->flags.bNewLine = 1;
		}
	}
	// make sure we think we're showing the top 5 lines, not top 0
	//console->pCurrentDisplay->nOffset = char_height - 1;
	if( font )
		console->pCurrentDisplay->nLineHeight = GetFontHeight( font );
	BuildDisplayInfoLines( console->pCurrentDisplay, NULL, font );
	console->CurrentLineInfo =
		console->CurrentMarkInfo = &console->pCurrentDisplay->DisplayLineInfo;
	if( font )
	{
		INDEX len;
		int maxlen = 0;
		int lines = 1;
		PDISPLAYED_LINE pdl;
		for( lines = 0; pdl = (PDISPLAYED_LINE)GetDataItem( console->CurrentMarkInfo, lines ) ; lines++ )
		{
			if( !pdl->start )
				break;
			len = pdl->nToShow;
			if( pdl->nToShow > maxlen )
				maxlen = (int)len;
			//lprintf( "line %d len %d", lines, len );
			//if( len == 0 )
			//	break;
		}
		//lprintf( "measured block in characters %d,%d", maxlen, lines );
		console->mark_start.row = lines;
		console->mark_start.col = 0;
		console->mark_end.row = 0;
		console->mark_end.col = maxlen + 1;
	}
	else
	{
		console->mark_start.row = ((*pixel_height) - 1);
		console->mark_start.col = 0;
		console->mark_end.row = 0;
		console->mark_end.col = (*pixel_width) - 1;
	}
	block = PSI_GetDataFromBlock( console );
	if( *output )
	{
		//lprintf( "Release %p", (*output ) );
		//DebugBreak();
		Deallocate( TEXTCHAR *, (*output) );
	}
	(*output) = block;
	{
		uint32_t width, height;
		GetStringSizeFont( (*output), &width, &height, font );
		(*pixel_width) = width;
		(*pixel_height) = height;
	}
	PSI_DestroyHistoryBrowser( console->pCurrentDisplay );
	PSI_DestroyHistoryCursor( console->pCursor );
	PSI_DestroyHistoryRegion( console->pHistory );
	Release( console );
}
void FormatTextToBlock( CTEXTSTR input, TEXTSTR *output, int char_width, int char_height )
{
	FormatTextToBlockEx( input, output, &char_width, &char_height, NULL );
}
PSI_CONSOLE_NAMESPACE_END
#define CORECON_SOURCE
#define NO_LOGGING
#define KEYS_DEFINED
// included to have pending struct available to pass to
// command line update....
//#include "history.h"
PSI_CONSOLE_NAMESPACE
extern int myTypeID;
enum{
   KS_DELETE
};
static void CPROC _Key_KeystrokePaste( PCONSOLE_INFO pmdp )
{
	if( pmdp->KeystrokePaste )
      pmdp->KeystrokePaste( pmdp );
}
 // DECLTEXT implies 'static'
DECLTEXT( KeyStroke, "\x7f" );
#if defined( GCC ) || defined( __LINUX__ )
CORECON_EXPORT( PSIKEYDEFINE, ConsoleKeyDefs[256] ) =
#ifdef __cplusplus
{{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
, {"esc","escape",0|0|0|0|0|0,{{KEYDATA}}}
, {"1",0,0|0|0|0|0|0,{{KEYDATA},{KEYDATA}}}
, {"2",0,0|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"3",0,0|0|0|0|0|0,{{KEYDATA},{KEYDATA}}}
, {"4",0,0|0|0|0|0|0,{{KEYDATA},{KEYDATA}}}
, {"5",0,0|0|0|0|0|0,{{KEYDATA},{KEYDATA}}}
, {"6",0,0|0|0|0|0|0,{{KEYDATA},{KEYDATA}}}
, {"7",0,0|0|0|0|0|0,{{KEYDATA},{KEYDATA}}}
, {"8",0,0|0|0|0|0|0,{{KEYDATA},{KEYDATA}}}
, {"9",0,0|0|0|0|0|0,{{KEYDATA},{KEYDATA}}}
, {"0",0,0|0|0|0|0|0,{{KEYDATA},{KEYDATA}}}
, {"-","dash",0|0|0|0|0|0,{{KEYDATA},{KEYDATA}}}
, {"=","equal",0|0|0|0|0|0,{{KEYDATA},{KEYDATA}}}
, {"back","backspace",0|0|0|0|0|0,{{KEYDATA}}}
, {"tab",0,0|0|0|0|0|0,{{KEYDATA}}}
, {"q",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"w",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"e",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"r",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"t",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"y",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"u",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"i",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"o",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"p",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"[","lbracket",0|0|0|0|0|0,{{KEYDATA},{KEYDATA}}}
, {"]","rbracket",0|0|0|0|0|0,{{KEYDATA},{KEYDATA}}}
,{0}
,{0}
, {"a",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"s",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"d",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"f",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"g",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"h",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"j",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"k",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"l",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {";","semicolon",0|0|0|0|0|0,{{KEYDATA},{KEYDATA}}}
, {"'","quote",0|0|0|0|0|0,{{KEYDATA},{KEYDATA}}}
, {"`","accent",0|0|0|0|0|0,{{KEYDATA},{KEYDATA}}}
,{0}
, {"\\","backslash",0|0|0|0|0|0,{{KEYDATA},{KEYDATA}}}
, {"z",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"x",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"c",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"v",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA},{}}}
, {"b",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"n",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {"m",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA}}}
, {",","comma",0|0|0|0|0|0,{{KEYDATA},{KEYDATA}}}
, {".","period",0|0|0|0|0|0,{{KEYDATA},{KEYDATA}}}
, {"/","slash",0|0|0|0|0|0,{{KEYDATA},{KEYDATA}}}
,{0}
, {"mult","mulitply",KDF_NODEFINE|0|0|0|0|0,{{KEYDATA}}}
,{0}
, {"space","blank",0|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA},{KEYDATA},{KEYDATA},{KEYDATA},{KEYDATA},{KEYDATA}}}
,{0}
, {"f1",0,0|0|0|0|0|0,{}}
, {"f2",0,0|0|0|0|0|0,{}}
, {"f3",0,0|0|0|0|0|0,{}}
, {"f4",0,0|0|0|0|0|0,{}}
, {"f5",0,0|0|0|0|0|0,{}}
, {"f6",0,0|0|0|0|0|0,{}}
, {"f7",0,0|0|0|0|0|0,{}}
, {"f8",0,0|0|0|0|0|0,{}}
, {"f9",0,0|0|0|0|0|0,{}}
, {"f10",0,0|0|0|0|0|0,{}}
,{0}
,{0}
, {"num7","pad7",KDF_NODEFINE|0|0|0|0|0,{{KEYDATA}}}
, {"num8","pad8",KDF_NODEFINE|0|0|0|0|0,{{KEYDATA}}}
, {"num9","pad9",KDF_NODEFINE|0|0|0|0|0,{{KEYDATA}}}
, {"subtract" ,0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA}}}
, {"num4","pad4",KDF_NODEFINE|0|0|0|0|0,{{KEYDATA}}}
, {"num5","pad5",KDF_NODEFINE|0|0|0|0|0,{{KEYDATA}}}
, {"num6","pad6",KDF_NODEFINE|0|0|0|0|0,{{KEYDATA}}}
, {"add" ,     0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA}}}
, {"separator",0,KDF_NODEFINE|0|0|0|0|0,{}}
, {"num2","pad2",KDF_NODEFINE|0|0|0|0|0,{{KEYDATA}}}
, {"num3","pad3",KDF_NODEFINE|0|0|0|0|0,{{KEYDATA}}}
, {"num0","pad0",KDF_NODEFINE|0|0|0|0|0,{{KEYDATA}}}
, {"decimal"  ,0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA}}}
,{0}
,{0}
,{0}
, {"f11",0,0|0|0|0|0|0,{}}
, {"f12",0,0|0|0|0|0|0,{}}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
, {"insert",0,0|0|0|0|0|0,{{}}}
, {"delete",0,0|0|0|0|0|0,{{}}}
, {"help",0,0|0|0|0|0|0,{}}
,{0}
,{0}
,{0}
, {"divide",0,KDF_NODEFINE|0|0|0|0|0,{{KEYDATA}}}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
, {"return","enter",0|0|0|0|0|0,{{KEYDATA},{KEYDATA},{KEYDATA},{KEYDATA},{KEYDATA},{KEYDATA},{KEYDATA},{KEYDATA}}}
,{0}
,{0}
,{0}
,{0}
,{0}
,{0}
, {"next","pgdn",0|0|0|0|0|0,{{}}}
, {"down",0,0|0|0|0|0|0,{{},{}}}
, {"end",0,0|0|0|0|0|0,{{}}}
, {"right",0,0|0|0|0|0|0,{{}}}
,{0}
, {"left",0,0|0|0|0|0|0,{{}}}
, {"prior","pgup",0|0|0|0|0|0,{{}}}
, {"up",0,0|0|0|0|0|0,{{},{}}}
, {"home",0,0|0|0|0|0|0,{{}}}
,{0}
,{0}
,{0}};
#else
{ [KEY_BACKSPACE]={"back","backspace",0,{{KEYDATA}} }
                      , [KEY_TAB]={"tab",0,0,{{KEYDATA}} }
                      , [KEY_ENTER]={"return", "enter",0,{{KEYDATA}
                                             ,{KEYDATA}
                                             ,{KEYDATA}
                                             ,{KEYDATA}
                                             ,{KEYDATA}
                                             ,{KEYDATA}
                                             ,{KEYDATA}
                                             ,{KEYDATA}} }
                      //, [KEY_PAUSE]={"pause",0,KDF_NODEFINE }
 // 0x1b
                      , [KEY_ESCAPE]={"esc", "escape", 0, {{KEYDATA}}}
                      , [KEY_SPACE]={"space", "blank", 0, {{KEYDATA}
                                              ,{KEYDATA}
                                              ,{KEYDATA}
                                              ,{KEYDATA}
                                              ,{KEYDATA}
                                              ,{KEYDATA}
                                              ,{KEYDATA}
 //0x20
                                              ,{KEYDATA}} }
                      , [KEY_PGUP]={"prior", "pgup", 0, {{HISTORYKEY,(PTEXT)HistoryPageUp}} }
                      , [KEY_PGDN]={"next", "pgdn", 0, {{HISTORYKEY,(PTEXT)HistoryPageDown}} }
                      , [KEY_END]={"end", 0, 0, {{COMMANDKEY, (PTEXT)KeyEndCmd}}}
                      , [KEY_HOME]={"home", 0, 0, {{COMMANDKEY, (PTEXT)KeyHome}}}
                      , [KEY_LEFT]={"left", 0, 0, {{COMMANDKEY, (PTEXT)KeyLeft}}}
                      , [KEY_UP]={"up" , 0, 0, { {COMMANDKEY, (PTEXT)CommandKeyUp}
                                       , {HISTORYKEY, (PTEXT)HistoryLineUp}}}
                      , [KEY_RIGHT]={"right", 0, 0, {{COMMANDKEY, (PTEXT)KeyRight}}}
                      , [KEY_DOWN]={"down", 0, 0, {{COMMANDKEY, (PTEXT)HandleKeyDown}
                                       , {HISTORYKEY, (PTEXT)HistoryLineDown}}}
                      //, {"select"}
                      //, [KEY_PRINT]={"print"}
                      //, {"execute"}
                      //, {"snapshot"}
                      , [KEY_GREY_INSERT]={"insert", 0, 0, {{COMMANDKEY, (PTEXT)KeyInsert}}}
                      , [KEY_GREY_DELETE]={"delete", 0, 0, {{KEYDATA_DEFINED, (PTEXT)&KeyStroke}}}
                      //, {"help"}
                      , [KEY_0]={"0", 0, 0, {{KEYDATA}
      //0x30
                                    ,{KEYDATA}}}
                      , [KEY_1]={"1", 0, 0, {{KEYDATA}
                                    ,{KEYDATA}}}
                      , [KEY_2]={"2", 0, 0, {{KEYDATA}
                                    ,{KEYDATA}
                                    ,{KEYDATA}}}
                      , [KEY_3]={"3", 0, 0, {{KEYDATA}
                                    ,{KEYDATA}}}
                      , [KEY_4]={"4", 0, 0, {{KEYDATA}
                                    ,{KEYDATA}}}
                      , [KEY_5]={"5", 0, 0, {{KEYDATA}
                                    ,{KEYDATA}}}
                      , [KEY_6]={"6", 0, 0, {{KEYDATA}
                                    ,{KEYDATA}}}
                      , [KEY_7]={"7", 0, 0, {{KEYDATA}
                                    ,{KEYDATA}}}
                      , [KEY_8]={"8", 0, 0, {{KEYDATA}
                                    ,{KEYDATA}}}
                      , [KEY_9]={"9", 0, 0, {{KEYDATA}
                                    ,{KEYDATA}}}
/* VK_0 thru VK_9 are the same as ASCII '0' thru '9' (0x30 - 0x39) */
/* VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (0x41 - 0x5A) */
                      //..... to hmm 39
                      , [KEY_A] = {"a",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
 // 0x41 'A'
                                           ,{KEYDATA}}}
                      , [KEY_B] = {"b",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_C] = {"c",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_D] = {"d",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_E] = {"e",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_F] = {"f",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_G] = {"g",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_H] = {"h",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_I] = {"i",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_J] = {"j",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_K] = {"k",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_L] = {"l",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_M] = {"m",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_N] = {"n",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_O] = {"o",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_P] = {"p",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_Q] = {"q",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_R] = {"r",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_S] = {"s",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_T] = {"t",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_U] = {"u",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_V] = {"v",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}
                                           ,{0}
                                           ,{SPECIALKEY,(PTEXT)_Key_KeystrokePaste}}}
                      , [KEY_W] = {"w",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_X] = {"x",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_Y] = {"y",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_Z] = {"z",0,KDF_NODEFINE,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , [KEY_PAD_0] = {"num0", "pad0",KDF_NODEFINE,{{KEYDATA}} }
                      , [KEY_PAD_1] = {"num1", "pad1",KDF_NODEFINE,{{KEYDATA}} }
                      , [KEY_PAD_2] = {"num2", "pad2",KDF_NODEFINE,{{KEYDATA}} }
                      , [KEY_PAD_3] = {"num3", "pad3",KDF_NODEFINE,{{KEYDATA}} }
                      , [KEY_PAD_4] = {"num4", "pad4",KDF_NODEFINE,{{KEYDATA}} }
                      , [KEY_PAD_5] = {"num5", "pad5",KDF_NODEFINE,{{KEYDATA}} }
                      , [KEY_PAD_6] = {"num6", "pad6",KDF_NODEFINE,{{KEYDATA}} }
                      , [KEY_PAD_7] = {"num7", "pad7",KDF_NODEFINE,{{KEYDATA}} }
                      , [KEY_PAD_8] = {"num8", "pad8",KDF_NODEFINE,{{KEYDATA}} }
                      , [KEY_PAD_9] = {"num9", "pad9",KDF_NODEFINE,{{KEYDATA}} }
                      , [KEY_PAD_MULT] = {"mult", "mulitply",KDF_NODEFINE,{{KEYDATA}} }
                      , [KEY_PAD_PLUS] = {"add",0,KDF_NODEFINE,{{KEYDATA} }}
					//, [KEY_PA{ "separator" , 0, KDF_NODEFINE,{} }
                      , [KEY_PAD_MINUS] = {"subtract",0,KDF_NODEFINE,{{KEYDATA}} }
                      , [KEY_PAD_DOT] = {"decimal",0,KDF_NODEFINE,{{KEYDATA}} }
                      , [KEY_PAD_DIV] = {"divide",0,KDF_NODEFINE,{{KEYDATA}} }
   // 0x70
                      , [KEY_F1]={"f1" }
                      , [KEY_F2]={"f2" }
                      , [KEY_F3]={"f3" }
                      , [KEY_F4]={"f4" }
                      , [KEY_F5]={"f5" }
                      , [KEY_F6]={"f6" }
                      , [KEY_F7]={"f7" }
                      , [KEY_F8]={"f8" }
                      , [KEY_F9]={"f9" }
                      , [KEY_F10]={"f10" }
                      , [KEY_F11]={"f11" }
                      , [KEY_F12]={"f12" }
                      //, {"numlock",0,KDF_NODEFINE} // 0x90
                      //, {"scroll",0,KDF_NODEFINE}
/*
 * VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().
 * No other API or message will distinguish left and right keys in this way.
 */
                      //, NONAMES // {"lshift",0,KDF_NODEFINE}  // 0xa0
                      //, NONAMES // {"rshift",0,KDF_NODEFINE}
                      //, NONAMES // {"lctrl", "lcontrol",0,KDF_NODEFINE}
                      //, NONAMES // {"rctrl", "rcontrol",0,KDF_NODEFINE}
                      //, NONAMES // {"lmenu", "lalt",0,KDF_NODEFINE }
                      //, NONAMES // {"rmenu", "ralt",0,KDF_NODEFINE }
                      , [KEY_SEMICOLON]={";", "semicolon",0,{{KEYDATA}
                                            ,{KEYDATA}} }
                      , [KEY_EQUAL]={"=", "equal",0    ,{{KEYDATA}
                                            ,{KEYDATA}}}
                      , [KEY_COMMA]={",", "comma",0    ,{{KEYDATA}
                                            ,{KEYDATA}} }
                      , [KEY_DASH]={"-", "dash",0     ,{{KEYDATA}
                                            ,{KEYDATA}}}
                      , [KEY_STOP]={".", "period",0   ,{{KEYDATA}
                                            ,{KEYDATA}}}
                      , [KEY_SLASH]={"/","slash",0     ,{{KEYDATA}
                                            ,{KEYDATA}}}
                      , [KEY_ACCENT]={"`", "accent",0   ,{{KEYDATA}
 // 0xc0
                                            ,{KEYDATA}} }
                      , [KEY_LEFT_BRACKET]={ "[", "lbracket",0  ,{{KEYDATA}
                                              ,{KEYDATA}} }
                      , [KEY_BACKSLASH]={ "\\", "backslash",0,{{KEYDATA}
                                              ,{KEYDATA}} }
                      , [KEY_RIGHT_BRACKET]={ "]", "rbracket",0  ,{{KEYDATA}
                                              ,{KEYDATA}} }
                      , [KEY_QUOTE]={ "'", "quote",0     ,{{KEYDATA}
                                              ,{KEYDATA}} }
};
#endif
#ifndef __cplusplus
#  if 0
PRELOAD( WriteSymbols)
{
	FILE *junk = fopen( "out.keysyms", "wt" );
	if( junk )
	{
		int n;
		for( n = 0; n <256; n++ )
		{
         int m;
			if( ConsoleKeyDefs[n].name1 || ConsoleKeyDefs[n].name2 )
			{
				TEXTCHAR tmp[4];
				TEXTCHAR tmp2[4];
				TEXTSTR n1 = ConsoleKeyDefs[n].name1;
				TEXTSTR n2 = ConsoleKeyDefs[n].name2;
				if( StrCmp( ConsoleKeyDefs[n].name1, "\"" ) == 0 )
				{
               n1 = tmp;
               tmp[0] = '\\';
               tmp[1] = '\"';
					tmp[2] = 0;
				}
				if( StrCmp( ConsoleKeyDefs[n].name2, "\"" ) == 0 )
				{
               n2 = tmp2;
               tmp2[0] = '\\';
               tmp2[1] = '\"';
					tmp2[2] = 0;
				}
				if( StrCmp( ConsoleKeyDefs[n].name1, "\\" ) == 0 )
				{
               n1 = tmp;
               tmp[0] = '\\';
               tmp[1] = '\\';
					tmp[2] = 0;
				}
				if( StrCmp( ConsoleKeyDefs[n].name2, "\\" ) == 0 )
				{
               n2 = tmp2;
               tmp2[0] = '\\';
               tmp2[1] = '\\';
					tmp2[2] = 0;
				}
				fprintf( junk, ", {%s%s%s,%s%s%s,%s|%s|%s|%s|%s|%s,{"
						 , ConsoleKeyDefs[n].name1?"\"":""
						 , ConsoleKeyDefs[n].name1?n1:"NULL"
						 , ConsoleKeyDefs[n].name1?"\")":""
						 , ConsoleKeyDefs[n].name2?"\"":""
						 , ConsoleKeyDefs[n].name2?n2:"NULL"
						 , ConsoleKeyDefs[n].name2?"\")":""
						 , ConsoleKeyDefs[n].flags&KDF_NODEFINE?"KDF_NODEFINE":"0"
						 , ConsoleKeyDefs[n].flags&KDF_NOREDEF?"KDF_NOREDEF":"0"
						 , ConsoleKeyDefs[n].flags&KDF_CAPSKEY?"KDF_CAPSKEY":"0"
						 , ConsoleKeyDefs[n].flags&KDF_NUMKEY?"KDF_NUMKEY":"0"
						 , ConsoleKeyDefs[n].flags&KDF_UPACTION?"KDF_UPACTION":"0"
						 , ConsoleKeyDefs[n].flags&KDF_NOKEY?"KDF_NOKEY":"0"
						 );
				for( m = 0; m < 8; m++ )
				{
					if( ConsoleKeyDefs[n].op[m].bFunction )
					{
						fprintf( junk, "%s", m?",":"" );
						fprintf( junk, "{%s}"
								 , (ConsoleKeyDefs[n].op[m].bFunction==KEYDATA)?"KEYDATA":""
								 );
					}
				}
				fprintf( junk, "}}\n" );
			}
			else
			{
				fprintf( junk, ",{0}\n");
			}
		}
		fclose( junk );
	}
}
#  endif
#endif
#else
#define NONAMES {NULL,NULL,0}
PSIKEYDEFINE ConsoleKeyDefs[] = { NONAMES
                      , {"lbutton",0,0 }
                      , {"rbutton",0,0 }
                      , {"cancel",0,0}
 // 0x04
                      , {"mbutton",0,0}
                      , NONAMES, NONAMES, NONAMES
                      , {"back","backspace",0,{{KEYDATA}} }
                      , {"tab",0,0,{{KEYDATA}} }
                      , NONAMES, NONAMES
   // 0x0c
                      , {"clear",0,0 }
                      , {"return", "enter",0,{{KEYDATA}
                                             ,{KEYDATA}
                                             ,{KEYDATA}
                                             ,{KEYDATA}
                                             ,{KEYDATA}
                                             ,{KEYDATA}
                                             ,{KEYDATA}
                                             ,{KEYDATA}} }
                      , NONAMES, NONAMES
                      , {"shift",0,0, {{CONTROLKEY,(PTEXT)KeyShift}
                                                 ,{CONTROLKEY,(PTEXT)KeyShift}
                                                 ,{CONTROLKEY,(PTEXT)KeyShift}
                                                 ,{CONTROLKEY,(PTEXT)KeyShift}
                                                 ,{CONTROLKEY,(PTEXT)KeyShift}
                                                 ,{CONTROLKEY,(PTEXT)KeyShift}
                                                 ,{CONTROLKEY,(PTEXT)KeyShift}
 // 0x10
                                                 ,{CONTROLKEY,(PTEXT)KeyShift}} }
                      , {"control",0,0, {{CONTROLKEY,(PTEXT)KeyControl}
                                                 ,{CONTROLKEY,(PTEXT)KeyControl}
                                                 ,{CONTROLKEY,(PTEXT)KeyControl}
                                                 ,{CONTROLKEY,(PTEXT)KeyControl}
                                                 ,{CONTROLKEY,(PTEXT)KeyControl}
                                                 ,{CONTROLKEY,(PTEXT)KeyControl}
                                                 ,{CONTROLKEY,(PTEXT)KeyControl}
                                                 ,{CONTROLKEY,(PTEXT)KeyControl}} }
                      , {"menu",0,0, {{CONTROLKEY,(PTEXT)KeyAlt}
                                                 ,{CONTROLKEY,(PTEXT)KeyAlt}
                                                 ,{CONTROLKEY,(PTEXT)KeyAlt}
                                                 ,{CONTROLKEY,(PTEXT)KeyAlt}
                                                 ,{CONTROLKEY,(PTEXT)KeyAlt}
                                                 ,{CONTROLKEY,(PTEXT)KeyAlt}
                                                 ,{CONTROLKEY,(PTEXT)KeyAlt}
                                                 ,{CONTROLKEY,(PTEXT)KeyAlt}} }
                      , {"pause",0,0 }
                      , {"captial",0,0 }
                      , NONAMES, NONAMES, NONAMES, NONAMES, NONAMES, NONAMES
 // 0x1b
                      , {"esc", "escape", 0, {{KEYDATA}}}
                      , NONAMES, NONAMES
                      , NONAMES, NONAMES
                      , {"space", "blank", 0, {{KEYDATA}
                                              ,{KEYDATA}
                                              ,{KEYDATA}
                                              ,{KEYDATA}
                                              ,{KEYDATA}
                                              ,{KEYDATA}
                                              ,{KEYDATA}
 //0x20
                                              ,{KEYDATA}} }
                      , {"prior", "pgup", 0, {{HISTORYKEY,(PTEXT)HistoryPageUp}} }
                      , {"next", "pgdn", 0, {{HISTORYKEY,(PTEXT)HistoryPageDown}} }
                      , {"end", 0, 0, {{COMMANDKEY, (PTEXT)KeyEndCmd}}}
                      , {"home", 0, 0, {{COMMANDKEY, (PTEXT)KeyHome}}}
                      , {"left", 0, 0, {{COMMANDKEY, (PTEXT)KeyLeft}}}
                      , {"up" , 0, 0, { {COMMANDKEY, (PTEXT)CommandKeyUp}
                                       , {HISTORYKEY, (PTEXT)HistoryLineUp}}}
                      , {"right", 0, 0, {{COMMANDKEY, (PTEXT)KeyRight}}}
                      , {"down", 0, 0, {{COMMANDKEY, (PTEXT)HandleKeyDown}
                                       , {HISTORYKEY, (PTEXT)HistoryLineDown}}}
                      , {"select"}
                      , {"print"}
                      , {"execute"}
                      , {"snapshot"}
                      , {"insert", 0, 0, {{COMMANDKEY, (PTEXT)KeyInsert}}}
                      , {"delete", 0, 0, {{KEYDATA_DEFINED, (PTEXT)&KeyStroke}}}
                      , {"help"}
                      , {"0", 0, 0, {{KEYDATA}
      //0x30
                                    ,{KEYDATA}}}
                      , {"1", 0, 0, {{KEYDATA}
                                    ,{KEYDATA}}}
                      , {"2", 0, 0, {{KEYDATA}
                                    ,{KEYDATA}
                                    ,{KEYDATA}}}
                      , {"3", 0, 0, {{KEYDATA}
                                    ,{KEYDATA}}}
                      , {"4", 0, 0, {{KEYDATA}
                                    ,{KEYDATA}}}
                      , {"5", 0, 0, {{KEYDATA}
                                    ,{KEYDATA}}}
                      , {"6", 0, 0, {{KEYDATA}
                                    ,{KEYDATA}}}
                      , {"7", 0, 0, {{KEYDATA}
                                    ,{KEYDATA}}}
                      , {"8", 0, 0, {{KEYDATA}
                                    ,{KEYDATA}}}
                      , {"9", 0, 0, {{KEYDATA}
                                    ,{KEYDATA}}}
                      , NONAMES, NONAMES
                      , NONAMES, NONAMES
                      , NONAMES, NONAMES
                      , NONAMES
/* VK_0 thru VK_9 are the same as ASCII '0' thru '9' (0x30 - 0x39) */
/* VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (0x41 - 0x5A) */
                      //..... to hmm 39
                      , {"a",0,0,{{KEYDATA}
                                           ,{KEYDATA}
 // 0x41 'A'
                                           ,{KEYDATA}}}
                      , {"b",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"c",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"d",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"e",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"f",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"g",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"h",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"i",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"j",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"k",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"l",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"m",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"n",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"o",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"p",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"q",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"r",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"s",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"t",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"u",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"v",0,0,{{KEYDATA}
											,{KEYDATA}
											,{SPECIALKEY,(PTEXT)_Key_KeystrokePaste}
											,{SPECIALKEY,(PTEXT)_Key_KeystrokePaste}
											//,{KEYDATA}
							 }}
                      , {"w",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"x",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"y",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"z",0,0,{{KEYDATA}
                                           ,{KEYDATA}
                                           ,{KEYDATA}}}
                      , {"lwin" }
                      , {"rwin" }
                      , {"apps" }
                      , NONAMES, NONAMES
                      , {"num0", "pad0",0,{{KEYDATA}} }
                      , {"num1", "pad1",0,{{KEYDATA}} }
                      , {"num2", "pad2",0,{{KEYDATA}} }
                      , {"num3", "pad3",0,{{KEYDATA}} }
                      , {"num4", "pad4",0,{{KEYDATA}} }
                      , {"num5", "pad5",0,{{KEYDATA}} }
                      , {"num6", "pad6",0,{{KEYDATA}} }
                      , {"num7", "pad7",0,{{KEYDATA}} }
                      , {"num8", "pad8",0,{{KEYDATA}} }
                      , {"num9", "pad9",0,{{KEYDATA}} }
                      , {"mult", "mulitply",0,{{KEYDATA}} }
                      , {"add",0,0,{{KEYDATA} }}
                      , {"separator", 0, 0 }
                      , {"subtract",0,0,{{KEYDATA}} }
                      , {"decimal",0,0,{{KEYDATA}} }
                      , {"divide",0,0,{{KEYDATA}} }
   // 0x70
                      , {"f1" }
                      , {"f2" }
                      , {"f3" }
                      , {"f4" }
                      , {"f5" }
                      , {"f6" }
                      , {"f7" }
                      , {"f8" }
                      , {"f9" }
                      , {"f10" }
                      , {"f11" }
                      , {"f12" }
                      , {"f13" }
                      , {"f14" }
                      , {"f15" }
                      , {"f16" }
                      , {"f17" }
                      , {"f18" }
                      , {"f19" }
                      , {"f20" }
                      , {"f21" }
                      , {"f22" }
                      , {"f23" }
 // 0x87
                      , {"f24" }
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
 // 0x90
                      , {"numlock",0,0}
                      , {"scroll",0,0}
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
/*
 * VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().
 * No other API or message will distinguish left and right keys in this way.
 */
 // {"lshift",0,0}  // 0xa0
                      , NONAMES
 // {"rshift",0,0}
                      , NONAMES
 // {"lctrl", "lcontrol",0,0}
                      , NONAMES
 // {"rctrl", "rcontrol",0,0}
                      , NONAMES
 // {"lmenu", "lalt",0,0 }
                      , NONAMES
 // {"rmenu", "ralt",0,0 }
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
 // 0xb0
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , {";", "semicolon",0,{{KEYDATA}
                                            ,{KEYDATA}} }
                      , {"=", "equal",0    ,{{KEYDATA}
                                            ,{KEYDATA}}}
                      , {",", "comma",0    ,{{KEYDATA}
                                            ,{KEYDATA}} }
                      , {"-", "dash",0     ,{{KEYDATA}
                                            ,{KEYDATA}}}
                      , {".", "period",0   ,{{KEYDATA}
                                            ,{KEYDATA}}}
                      , {"/","slash",0     ,{{KEYDATA}
                                            ,{KEYDATA}}}
                      , {"`", "accent",0   ,{{KEYDATA}
 // 0xc0
                                            ,{KEYDATA}} }
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
 // 0xd0
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , { "[", "lbracket",0  ,{{KEYDATA}
                                              ,{KEYDATA}} }
                      , { "\\", "backslash",0,{{KEYDATA}
                                              ,{KEYDATA}} }
                      , { "]", "rbracket",0  ,{{KEYDATA}
                                              ,{KEYDATA}} }
                      , { "'", "quote",0     ,{{KEYDATA}
                                              ,{KEYDATA}} }
                      , NONAMES
 // 0xe0
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
 // 0xf0
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
                      , NONAMES
  // 0xff
                      , NONAMES
                       };
#endif
/*
#if(WINVER >= 0x0400)
#define VK_PROCESSKEY     0xE5
#endif
#define VK_ATTN           0xF6
#define VK_CRSEL          0xF7
#define VK_EXSEL          0xF8
#define VK_EREOF          0xF9
#define VK_PLAY           0xFA
#define VK_ZOOM           0xFB
#define VK_NONAME         0xFC
#define VK_PA1            0xFD
#define VK_OEM_CLEAR      0xFE
*/
//----------------------------------------------------------------------------
int CommandKeyUp( void * list, PUSER_INPUT_BUFFER pci )
{
   RecallUserInput( pci, TRUE );
   return UPDATE_COMMAND;
}
//----------------------------------------------------------------------------
int HandleKeyDown( void * list, PUSER_INPUT_BUFFER pci )
{
   RecallUserInput( pci, FALSE );
   return UPDATE_COMMAND;
}
//----------------------------------------------------------------------------
int KeyHome( void * list, PUSER_INPUT_BUFFER pci )
{
	SetUserInputPosition( pci, 0, COMMAND_POS_SET );
	return UPDATE_COMMAND;
}
//----------------------------------------------------------------------------
int KeyEndCmd( uintptr_t list, PUSER_INPUT_BUFFER pci )
{
	SetUserInputPosition( pci, -1, COMMAND_POS_SET );
	return UPDATE_COMMAND;
}
//----------------------------------------------------------------------------
int KeyInsert( void * list, PUSER_INPUT_BUFFER pci )
{
	SetUserInputInsert( pci, -1 );
	return UPDATE_COMMAND;
}
//----------------------------------------------------------------------------
int KeyRight( void * list, PUSER_INPUT_BUFFER pci )
{
	SetUserInputPosition( pci, 1, COMMAND_POS_CUR );
	return UPDATE_COMMAND;
}
//----------------------------------------------------------------------------
int KeyLeft( void * list, PUSER_INPUT_BUFFER pci )
{
	SetUserInputPosition( pci, -1, COMMAND_POS_CUR );
	return UPDATE_COMMAND;
}
//----------------------------------------------------------------------------
int KeyShift( uint32_t* pKeyState, LOGICAL bDown )
{
   if( bDown )
   {
      *pKeyState |= KEY_MOD_SHIFT;
   }
   else
   {
      *pKeyState &= ~KEY_MOD_SHIFT;
   }
   return FALSE;
}
//----------------------------------------------------------------------------
int KeyControl( uint32_t* pKeyState, LOGICAL bDown )
{
   if( bDown )
   {
      *pKeyState |= KEY_MOD_CTRL;
   }
   else
   {
      *pKeyState &= ~KEY_MOD_CTRL;
   }
   return FALSE;
}
//----------------------------------------------------------------------------
int KeyAlt( uint32_t* pKeyState, LOGICAL bDown )
{
   if( bDown )
   {
      *pKeyState |= KEY_MOD_ALT;
   }
   else
   {
      *pKeyState &= ~KEY_MOD_ALT;
   }
   return FALSE;
}
//----------------------------------------------------------------------------
// Extensions and usage of keybinding data
// -- so far seperated so that perhaps it could be a seperate module...
//----------------------------------------------------------------------------
#define NUM_MODS ( sizeof( ModNames ) / sizeof( char * ) )
CTEXTSTR ModNames[] = { "shift", "ctrl", "alt"
                   , NULL, "control", NULL
                   , "$", "^", "@" };
int FindMod( PTEXT pMod )
{
   int i;
   for( i = 0; i < NUM_MODS; i++ )
   {
      if( ModNames[i] )
         if( TextLike( pMod, ModNames[ i ] ) )
            break;
   }
   if( i < NUM_MODS )
      return ( 1 << ( i % 3 ) );
   return 0;
}
int FindKey( PTEXT pKey )
{
   int i;
   for( i = 0; i < NUM_KEYS; i++ )
   {
		//if( ( !ConsoleKeyDefs[i].flags ) ||
		//    ( ConsoleKeyDefs[i].flags & (KDF_NODEFINE) ) )
      //   continue;
      if( ConsoleKeyDefs[i].name1 && TextLike( pKey, ConsoleKeyDefs[i].name1 ) )
      {
         return i;
      }
      else if( ConsoleKeyDefs[i].name2 && TextLike( pKey, ConsoleKeyDefs[i].name2 ) )
      {
         return i;
      }
   }
   return 0;
}
//----------------------------------------------------------------------------
#ifdef __DEKWARE_PLUGIN__
static void DestroyKeyMacro( PMACRO pm )
{
   PTEXT temp;
   INDEX idx;
   if( pm->flags.un.macro.bUsed )
   {
      pm->flags.un.macro.bDelete = TRUE;
      return;
   }
   LineRelease( pm->pArgs );
   LineRelease( pm->pName );
   LineRelease( pm->pDescription );
   LIST_FORALL( pm->pCommands, idx, PTEXT, temp )
   {
      LineRelease( temp );
   }
   DeleteList( &pm->pCommands );
   Release( pm );
}
#endif
// Usage: /KeyBind shift-F1
//        ... #commands
//        /endmac
// Usage: /KeyBind shift-F1 kill
// Usage: /KeyBind $F1 ... ^F1 $^F1
//  if parameters follow the keybind key-def, those params
//  are taken as keystrokes to type...
//  if no parameters follow, the definition is assumed to
//  be a macro definition, and the macro is invoked by
//  the processing entity...
#ifdef __DEKWARE_PLUGIN__
CORECON_NPROC( int, KeyBind )( PDATAPATH pdp, PSENTIENT ps, PTEXT parameters )
{
   PTEXT pKey;
   int ModVal;
   int Mod = 0;
   int KeyVal;
	PVARTEXT vt;
   PCONSOLE_INFO pmdp = (PCONSOLE_INFO)pdp;
   do{
      pKey = GetParam( ps, &parameters );
      if( pKey )
      {
         ModVal = FindMod( pKey );
         Mod |= ModVal;
      }
      else
         break;
   }while( ModVal );
   if( pKey )
      KeyVal = FindKey( pKey );
   else
   {
      DECLTEXT( msg, "Not enough parameters to KeyBind..." );
      EnqueLink( &ps->Command->Output, &msg );
      return 0;
   }
   if( !KeyVal )
   {
      DECLTEXT( msg, "First parameters to KeyBind were not a known key..." );
      EnqueLink( &ps->Command->Output, &msg );
      return 0;
   }
   else
   {
      //DECLTEXTSZ( msg, 256 );
      PMACRO pm;
      PTEXT pStroke;
      if( pmdp->Keyboard[KeyVal][Mod].flags.bMacro )
      {
         DECLTEXT( msg, "Destroyed prior key macro" );
         EnqueLink( &ps->Command->Output, &msg );
         DestroyKeyMacro( pmdp->Keyboard[KeyVal][Mod].data.macro );
      }
      if( pmdp->Keyboard[KeyVal][Mod].flags.bStroke )
      {
         DECLTEXT( msg, "Destroyed prior key stroke" );
         EnqueLink( &ps->Command->Output, &msg );
         LineRelease( pmdp->Keyboard[KeyVal][Mod].data.stroke );
      }
      {
         PTEXT pSubst;
         pSubst = MacroDuplicateEx( ps, parameters, FALSE, TRUE );
         if( pSubst )
         {
            pStroke = BuildLine( pSubst );
            LineRelease( pSubst );
         }
         else
            pStroke = NULL;
      }
      if( pStroke )
      {
         pmdp->Keyboard[KeyVal][Mod].flags.bStroke = TRUE;
         pmdp->Keyboard[KeyVal][Mod].flags.bMacro = FALSE;
         pmdp->Keyboard[KeyVal][Mod].data.stroke = pStroke;
         return 0;
      }
      vt = VarTextCreate();
      if( Mod & KEYMOD_SHIFT )
      {
         if( Mod & KEYMOD_CTRL )
            if( Mod & KEYMOD_ALT )
               vtprintf( vt, "shift-ctrl-alt-%s"
                           ,ConsoleKeyDefs[KeyVal].name1 );
            else
               vtprintf( vt, "shift-ctrl-%s"
                           ,ConsoleKeyDefs[KeyVal].name1 );
         else
            if( Mod & KEYMOD_ALT )
               vtprintf( vt, "shift-alt-%s"
                           ,ConsoleKeyDefs[KeyVal].name1 );
            else
               vtprintf( vt, "shift-%s"
                           ,ConsoleKeyDefs[KeyVal].name1 );
      }
      else
      {
         if( Mod & KEYMOD_CTRL )
            if( Mod & KEYMOD_ALT )
               vtprintf( vt, "ctrl-alt-%s"
                           ,ConsoleKeyDefs[KeyVal].name1 );
            else
               vtprintf( vt, "ctrl-%s"
                           ,ConsoleKeyDefs[KeyVal].name1 );
         else
            if( Mod & KEYMOD_ALT )
               vtprintf( vt, "alt-%s"
                           ,ConsoleKeyDefs[KeyVal].name1 );
            else
               vtprintf( vt, "%s"
                           ,ConsoleKeyDefs[KeyVal].name1 );
      }
      pm = (PMACRO)Allocate( sizeof( MACRO ) );
      MemSet( pm, 0, sizeof( MACRO ) );
      pm->flags.bMacro = TRUE;
      pm->pName = VarTextGet( vt );
      pm->pDescription = NULL;
      pm->nArgs = 0;
      pm->pArgs = NULL;
      ps->pRecord = pm;
      pmdp->Keyboard[KeyVal][Mod].flags.bMacro = TRUE;
      pmdp->Keyboard[KeyVal][Mod].flags.bStroke = FALSE;
      pmdp->Keyboard[KeyVal][Mod].data.macro = pm;
		VarTextDestroy( &vt );
   }
   return 0;
}
#endif
//----------------------------------------------------------------------------
#ifdef __DEKWARE_PLUGIN__
CORECON_NPROC( int, KeyUnBind )( PDATAPATH pdp, PSENTIENT ps, PTEXT parameters )
{
   PTEXT pKey;
   int ModVal;
   int Mod = 0;
   int KeyVal;
   PCONSOLE_INFO pmdp = (PCONSOLE_INFO)pdp;
   do{
      pKey = GetParam( ps, &parameters );
      if( pKey )
      {
         ModVal = FindMod( pKey );
         Mod |= ModVal;
      }
      else
         break;
   }while( ModVal );
   if( pKey )
      KeyVal = FindKey( pKey );
   else
   {
      DECLTEXT( msg, "Not enough parameters to KeyUnBind..." );
      EnqueLink( &ps->Command->Output, &msg );
      return 0;
   }
   if( !KeyVal )
   {
      DECLTEXT( msg, "First parameters to KeyUnBind were not a known key..." );
      EnqueLink( &ps->Command->Output, &msg );
      return 0;
   }
   else
   {
      if( pmdp->Keyboard[KeyVal][Mod].flags.bMacro )
      {
         DECLTEXT( msg, "Destroyed prior key macro" );
         EnqueLink( &ps->Command->Output, &msg );
         DestroyKeyMacro( pmdp->Keyboard[KeyVal][Mod].data.macro );
         pmdp->Keyboard[KeyVal][Mod].data.macro = NULL;
         pmdp->Keyboard[KeyVal][Mod].flags.bMacro = FALSE;
      }
      else if( pmdp->Keyboard[KeyVal][Mod].flags.bStroke )
      {
         DECLTEXT( msg, "Destroyed prior key stroke" );
         EnqueLink( &ps->Command->Output, &msg );
         LineRelease( pmdp->Keyboard[KeyVal][Mod].data.stroke );
         pmdp->Keyboard[KeyVal][Mod].data.stroke = NULL;
         pmdp->Keyboard[KeyVal][Mod].flags.bStroke = FALSE;
      }
      else
      {
         DECLTEXT( msg, "Key was not bound..." );
         EnqueLink( &ps->Command->Output, &msg );
      }
   }
   return 0;
}
#endif
//----------------------------------------------------------------------------
#ifdef __DEKWARE_PLUGIN__
int KeyList( PSENTIENT ps, PTEXT parameters )
{
	// somewhere I should have macro dump
	// this would be useful for this thing also..
	// header's a little different though
	return 0;
}
#endif
//----------------------------------------------------------------------------
int PSI_DoStroke( PCONSOLE_INFO pdp, PTEXT stroke )
{
   INDEX i;
   int bOutput = FALSE;
   DECLTEXT( key, " " );
   //Log1( "Do Stroke with %c", stroke->data.data[0] );
   while( stroke )
   {
      for( i = 0; i < stroke->data.size; i++ )
      {
         switch( key.data.data[0] = stroke->data.data[i] )
         {
         case '\r':
            // output is always prefix linefed...
 // carriage return = linefeed
            key.data.data[0] = '\n';
  // do not output return... extra lines otherwise
            goto normal_process;
         case 9:
            key.data.data[0] = ' ';
         case 27:
         case '\b':
            //pdp->bUpdateToEnd = FALSE; // need update ALL not just to end
         default:
         normal_process:
            {
               if( pdp->flags.bDirect && pdp->flags.bCharMode )
               {
                  PTEXT newseg = TextDuplicate( stroke, FALSE );
                  if( stroke->data.data[0] == '\r' )
                  {
                     newseg->flags &= ~TF_NORETURN;
                     newseg->data.size = 0;
                  }
                  else
							newseg->flags |= TF_NORETURN;
#ifdef __DEKWARE_PLUGIN__
 // just pipe it through to the final output...
						newseg->flags |= TF_RELAY;
                  // direct mode is REALLY direct.
						EnqueLink( &pdp->common.Input, newseg );
#else
//						EnqueLink( &pdp->Input, newseg );
#endif
                  i = stroke->data.size;
                  break;
               }
               else
               {
					GatherUserInput( pdp->
#ifdef __DEKWARE_PLUGIN__
											 common.
#endif
											 CommandInfo
											, (PTEXT)&key );
               }
            }
            bOutput = TRUE;
            break;
         }
      }
      stroke = NEXTLINE( stroke );
   }
   return bOutput;
}
//----------------------------------------------------------------------------
void PSI_KeyPressHandler( PCONSOLE_INFO pdp
						  , uint8_t key_index
						  , uint8_t mod
						  , PTEXT characters
						  , SFTFont font
						  )
{
//cpg26dec2006 console\keydefs.c(1409): Warning! W202: Symbol 'result' has been defined, but not referenced
//cpg26dec2006    int result;
	int bOutput = 0;
	// check current keyboard override...
   if( ConsoleKeyDefs[key_index].flags & KDF_CAPSKEY )
   {
      //if( event.dwControlKeyState & CAPSLOCK_ON )
      //{
      //   mod ^= KEYMOD_SHIFT;
      //}
   }
	if( pdp->Keyboard[key_index][mod].flags.bStroke ||
		pdp->Keyboard[key_index][mod].flags.bMacro )
	{
		if( pdp->Keyboard[key_index][mod].flags.bStroke )
		{
			extern void CPROC PSI_WinLogicDoStroke( PCONSOLE_INFO pdp, PTEXT stroke );
			PSI_WinLogicDoStroke(pdp, pdp->Keyboard[key_index][mod].data.stroke);
			SmudgeCommon( pdp->psicon.frame );
		}
#ifdef __DEKWARE_PLUGIN__
		else if( pdp->Keyboard[key_index][mod].flags.bMacro )
		{
			if( pdp->common.Owner->pRecord != pdp->Keyboard[key_index][mod].data.macro )
				InvokeMacro( pdp->common.Owner
							  , pdp->Keyboard[key_index][mod].data.macro
							  , NULL );
		}
#endif
	}
 // key was not overridden
	else
	{
		int result = 0;
		//Log1( "Keyfunc = %d", KeyDefs[key_index].op[mod].bFunction );
		switch( ConsoleKeyDefs[key_index].op[mod].bFunction )
		{
		case KEYDATA_DEFINED:
			//Log( "Key data_defined" );
			{
				extern void CPROC PSI_WinLogicDoStroke( PCONSOLE_INFO pdp, PTEXT stroke );
				PSI_WinLogicDoStroke( pdp, (PTEXT)&ConsoleKeyDefs[key_index].op[mod].data.pStroke );
				SmudgeCommon( pdp->psicon.frame );
			}
 // unsure about this - recently added.
			result = UPDATE_NOTHING;
			// well it would appear that the stroke results in whether to update
			// the command prompt or not.
			break;
		case KEYDATA:
			if( GetTextSize( characters ) )
			{
				extern void CPROC PSI_WinLogicDoStroke( PCONSOLE_INFO pdp, PTEXT stroke );
				PSI_WinLogicDoStroke( pdp, characters );
				SmudgeCommon( pdp->psicon.frame );
			}
 // already taken care of?!
			result = UPDATE_NOTHING;
			break;
		case COMMANDKEY:
			result = ConsoleKeyDefs[key_index].op[mod].data.CommandKey( (uintptr_t)pdp, pdp->
#ifdef __DEKWARE_PLUGIN__
																				 common.
#endif
																				 CommandInfo );
			if( result == UPDATE_COMMAND ) {
				pdp->pCommandDisplay->flags.bUpdated = 1;
				if( !pdp->pCommandDisplay->pBlock ) {
					pdp->pCommandDisplay->pBlock = pdp->pCommandDisplay->region->pHistory.root.next;
					pdp->pCommandDisplay->pBlock->nLinesUsed = 1;
					pdp->pCommandDisplay->pBlock->pLines[0].flags.deleted = 0;
					pdp->pCommandDisplay->nLine = 1;
				}
				pdp->pCommandDisplay->pBlock->pLines[0].flags.nLineLength = (int)LineLengthExEx( pdp->CommandInfo->CollectionBuffer, FALSE, 8, NULL );
				pdp->pCommandDisplay->pBlock->pLines[0].pLine = pdp->CommandInfo->CollectionBuffer;
				if( !pdp->flags.bDirect )
					BuildDisplayInfoLines( pdp->pCommandDisplay, NULL, GetCommonFont( pdp->psicon.frame ) );
				else {
					BuildDisplayInfoLines( pdp->pCommandDisplay, pdp->pCurrentDisplay, GetCommonFont( pdp->psicon.frame ) );
					// update bias of displayed section above the last (complete)
					if( pdp->pCommandDisplay->DisplayLineInfo->Cnt > 1 )
						pdp->nDisplayLineStartDynamic = ((PDISPLAYED_LINE)GetDataItem( &pdp->pCommandDisplay->DisplayLineInfo
							, pdp->pCommandDisplay->DisplayLineInfo->Cnt - 2 ))->nLineTop;
					else {
						pdp->nDisplayLineStartDynamic = pdp->nCommandLineStart;
					}
				}
				SmudgeCommon( pdp->psicon.frame );
			}
			break;
		case HISTORYKEY:
			result = ConsoleKeyDefs[key_index].op[mod].data.HistoryKey( pdp->pHistoryDisplay );
			break;
		case CONTROLKEY:
			ConsoleKeyDefs[key_index].op[mod].data.ControlKey( &pdp->dwControlKeyState, TRUE );
			result = UPDATE_NOTHING;
			break;
		case SPECIALKEY:
			result = ConsoleKeyDefs[key_index].op[mod].data.SpecialKey( pdp );
			break;
		}
		switch( result )
		{
		case UPDATE_COMMAND:
			{
				PENDING_RECT upd;
				//extern void RenderCommandLine( PCONSOLE_INFO pdp, POINTER region );
				upd.flags.bHasContent = 0;
				upd.flags.bTmpRect = 1;
				PSI_RenderCommandLine( pdp, &upd );
				{
					RECT r;
					r.left = upd.x;
					r.right = upd.x + upd.width;
					r.top = upd.y;
					r.bottom = upd.y + upd.height;
					pdp->Update( pdp, &r );
				}
			}
			bOutput = TRUE;
			break;
		case UPDATE_HISTORY:
			{
				if( PSI_UpdateHistory( pdp, font ) )
				{
					PSI_RenderConsole( pdp, font );
				}
			}
			break;
		case UPDATE_DISPLAY:
			{
				PSI_ConsoleCalculate( pdp, font );
			}
			break;
		}
	}
}
PSI_CONSOLE_NAMESPACE_END
//----------------------------------------------------------------------------
// $Log: keydefs.c,v $
// Revision 1.37  2005/08/08 15:24:12  d3x0r
// Move updated rectangle struct to common space.  Improved curses console handling....
//
// Revision 1.36  2005/04/22 18:34:09  d3x0r
// Fix CPROC declaration of keystroke paste handler.
//
// Revision 1.35  2005/04/15 07:28:39  d3x0r
// Okay this all seems to work sufficicnetly - disabled logging entirely.
//
// Revision 1.34  2005/02/24 00:47:14  d3x0r
// Updated vc projects - use $(SACK_BASE) refernece instead of hard coded path.  Also ported to studio 2003
//
// Revision 1.33  2005/01/28 09:53:34  d3x0r
// Okay all forms of graphical interface work on windows platform with appropriate updates
//
// Revision 1.32  2005/01/27 17:31:37  d3x0r
// psicon works now, added some locks to protect multiple accesses to datapath (render/update_write)
//
// Revision 1.31  2005/01/26 20:00:01  d3x0r
// Okay - need to do something about partial updates - such as command typing should only update that affected area of the screen...
//
// Revision 1.30  2005/01/23 04:07:57  d3x0r
// Hmm somehow between display rendering stopped working.
//
// Revision 1.29  2005/01/20 06:10:19  d3x0r
// One down, 3 to convert... concore library should serve to encapsulate drawing logic and history code...
//
// Revision 1.28  2004/09/29 09:31:32  d3x0r
//  Added support to make page breaks on output.  Fixed up some minor issues with scrollback distances
//
// Revision 1.27  2004/09/27 16:06:17  d3x0r
// Checkpoint - all seems well.
//
// Revision 1.26  2004/09/23 09:53:33  d3x0r
// Looks like it's in a usable state for windows... perhaps an alpha/beta to be released soon.
//
// Revision 1.25  2004/09/09 13:41:04  d3x0r
// works much better passing correct structures...
//
// Revision 1.24  2004/08/13 09:29:50  d3x0r
// checkpoint
//
// Revision 1.23  2004/07/30 14:08:40  d3x0r
// More tinkering...
//
// Revision 1.22  2004/06/12 08:42:34  d3x0r
// Well it initializes, first character causes failure... all windows targets build...
//
// Revision 1.21  2004/06/10 22:11:00  d3x0r
// more progress...
//
// Revision 1.20  2004/06/08 00:23:26  d3x0r
// Display and history combing proceeding...
//
// Revision 1.19  2004/05/14 18:35:40  d3x0r
// Checkpoint
//
// Revision 1.18  2004/05/13 23:35:07  d3x0r
// checkpoint
//
// Revision 1.17  2004/05/12 10:05:11  d3x0r
// checkpoint
//
// Revision 1.16  2003/12/10 21:59:51  panther
// Remove all LIST_ENDFORALL
//
// Revision 1.15  2003/11/08 00:09:41  panther
// fixes for VarText abstraction
//
// Revision 1.14  2003/04/17 06:40:32  panther
// More merging of wincon/psicon.  Should nearly have the renderer totally seperate now from the logic
//
// Revision 1.13  2003/03/28 12:16:29  panther
// Fix some minor issues with PSI interface
//
// Revision 1.12  2003/03/26 02:31:19  panther
// Windows keydefs - use HandleKeyDown not KeyDown
//
// Revision 1.11  2003/03/26 02:08:59  panther
// And cleanup FindMyDataPath more migration of handling options
//
// Revision 1.10  2003/03/26 02:05:21  panther
// begin updating option handlers to real option handlers
//
// Revision 1.9  2003/03/26 01:42:24  panther
// Update each section implicitly by drawing it.
//
// Revision 1.8  2003/03/26 01:08:20  panther
// Fix CVS conflict error.  Clean some warnings with typecasting
//
// Revision 1.7  2003/03/26 00:44:17  panther
// Enable mouse.  Perform updates to display.  Misc.
//
// Revision 1.6  2003/03/25 08:59:02  panther
// Added CVS logging
//
#ifdef __LINUX__
typedef int HKEY;
typedef int DWORD;
#define HKEY_CURRENT_USER 0
#define HKEY_LOCAL_MACHINE 1
enum enum_type { REG_SZ,REG_DWORD,REG_BINARY };
#endif
int GetRegistryItem( HKEY hRoot, CTEXTSTR pPrefix,
                     CTEXTSTR pProduct, CTEXTSTR pKey,
                     DWORD dwType,
                     TEXTSTR nResult, int nSize );
int SetRegistryItem( HKEY hRoot, CTEXTSTR pPrefix,
                     CTEXTSTR pProduct, CTEXTSTR pKey,
                     DWORD dwType,
                     CTEXTSTR pValue, int nSize );
int GetRegistryInt( CTEXTSTR pProduct, CTEXTSTR pKey, int *Value );
int GetLocalRegistryInt( CTEXTSTR pProduct, CTEXTSTR pKey, int *Value );
int GetRegistryString( CTEXTSTR pProduct, CTEXTSTR pKey, TEXTSTR Value, int nMaxLen );
int GetLocalRegistryString( CTEXTSTR pProduct, CTEXTSTR pKey, TEXTSTR Value, int nMaxLen );
int GetRegistryBinary( CTEXTSTR pProduct, CTEXTSTR pKey, TEXTSTR Value, int nMaxLen );
int GetLocalRegistryBinary( CTEXTSTR pProduct, CTEXTSTR pKey, TEXTSTR Value, int nMaxLen );
int SetRegistryInt( CTEXTSTR pProduct, CTEXTSTR pKey, int Value );
int SetLocalRegistryInt( CTEXTSTR pProduct, CTEXTSTR pKey, int Value );
int SetRegistryString( CTEXTSTR pProduct, CTEXTSTR pKey, CTEXTSTR pValue );
int SetLocalRegistryString( CTEXTSTR pProduct, CTEXTSTR pKey, CTEXTSTR pValue );
int SetRegistryBinary( CTEXTSTR pProduct, CTEXTSTR pKey, CTEXTSTR pValue, int nLen );
int SetLocalRegistryBinary( CTEXTSTR pProduct, CTEXTSTR pKey, CTEXTSTR pValue, int nLen );
// $Log: regaccess.h,v $
// Revision 1.5  2004/03/08 09:25:43  d3x0r
// Fix history underflow and minor drawing/mouse issues
//
// Revision 1.4  2004/01/20 08:21:34  d3x0r
// Common updates for merging more commonality
//
// Revision 1.3  2003/03/25 20:41:43  panther
// Fix what CVS logging addition broke
//
// Revision 1.2  2003/03/25 08:59:04  panther
// Added CVS logging
//
 // all relavent includes
PSI_CONSOLE_NAMESPACE
	//#include "interface.h"
extern int myTypeID;
void SetTopOfForm( PHISTORY_LINE_CURSOR phlc );
//----------------------------------------------------------------------------
PHISTORYBLOCK PSI_DestroyRawHistoryBlock( PHISTORYBLOCK pHistory )
{
	int32_t i;
	PHISTORYBLOCK next;
	for( i = 0; i < pHistory->nLinesUsed; i++ )
	{
		LineRelease( pHistory->pLines[i].pLine );
	}
	if( ( next = ( (*pHistory->me) = pHistory->next ) ) )
		pHistory->next->me = pHistory->me;
	Release( pHistory );
	return next;
}
//----------------------------------------------------------------------------
void PSI_DestroyHistoryRegion( PHISTORY_REGION phr )
{
	if( phr )
	{
		while( phr->pHistory.next )
			PSI_DestroyRawHistoryBlock( phr->pHistory.next );
		DeleteList( &phr->pCursors );
		DeleteList( &phr->pBrowsers );
		Release( phr );
	}
}
//----------------------------------------------------------------------------
void PSI_DestroyHistoryBlock( PHISTORY_REGION phr )
{
	// just destroy the first block...
	if( phr )
	{
		PSI_DestroyRawHistoryBlock( phr->pHistory.next );
	}
}
//----------------------------------------------------------------------------
void PSI_DestroyHistory( PHISTORYTRACK pht )
{
	if( pht )
	{
		PSI_DestroyHistoryRegion(pht->pRegion);
		Release( pht );
	}
}
//----------------------------------------------------------------------------
void PSI_DestroyHistoryBrowser( PHISTORY_BROWSER phbr )
{
	DeleteCriticalSec( &phbr->cs );
	DeleteDataList( &phbr->DisplayLineInfo );
	Release( phbr );
}
//----------------------------------------------------------------------------
void PSI_DestroyHistoryCursor( PHISTORY_LINE_CURSOR phlc )
{
	Release( phlc );
}
//----------------------------------------------------------------------------
PHISTORYBLOCK CreateRawHistoryBlock( void )
{
	PHISTORYBLOCK pHistory;
	pHistory = (PHISTORYBLOCK)Allocate( sizeof( HISTORYBLOCK ) );
	MemSet( pHistory, 0, sizeof( HISTORYBLOCK ) );
	return pHistory;
}
//----------------------------------------------------------------------------
PHISTORYBLOCK CreateHistoryBlock( PHISTORY_BLOCK_LINK phbl )
{
	PHISTORYBLOCK pHistory;
	// phbl needs to be valid node link thingy...
	if( !phbl->me )
	{
		lprintf( "FATAL ERROR, NODE in list is not initialized correctly." );
		DebugBreak();
	}
	pHistory = CreateRawHistoryBlock();
	/* this is link next... (first in list)
	pHistory->next = phbl->next;
	if( phbl->me ) // in most cases it's 'last'
		(*(pHistory->me = &(phbl->me->next))) = pHistory;
		phbl->next = pHistory;
		*/
	// if this is the head of the list... then that
	// me points at the last node of the list, the
	// next of the last node is NULL, which if we
	// get the next, and set it here will be NULL.
	// if this points at an element within the list,
	// then phbl->me is the node prior to the node passed,
	// and that will be phbl itself, which will set
	// next to be phbl, and therefore will be immediately
	// before the next.
	//pHistory->next = (*phbl->me);
	pHistory->next = (*(pHistory->me = phbl->me));
	// set what is pointing at the passed node, and
	// make my reference of prior node's pointer mine,
	//pHistory->me = phbl->me;
	// and then set that pointer to ME, instead of phbl...
 // set pointer pointing at me to ME
	(*pHistory->me) = pHistory;
	// finally, phbl's me is now my next, since the new node points at it.
	phbl->me = &pHistory->next;
	return pHistory;
}
//----------------------------------------------------------------------------
PHISTORY_LINE_CURSOR PSI_CreateHistoryCursor( PHISTORY_REGION phr )
{
	if( phr )
	{
		PHISTORY_LINE_CURSOR phlc = (PHISTORY_LINE_CURSOR)Allocate( sizeof( HISTORY_LINE_CURSOR ) );
		MemSet( phlc, 0, sizeof( HISTORY_LINE_CURSOR ) );
		phlc->output.DefaultColor.flags.background = SACK_GetProfileInt( "SACK/PSI/console", "background", 0 );
		phlc->output.DefaultColor.flags.foreground = SACK_GetProfileInt( "SACK/PSI/console", "foreground", 7 );
		phlc->output.PriorColor = phlc->output.DefaultColor;
		phlc->region = phr;
		AddLink( &phr->pCursors, phlc );
		return phlc;
	}
	return NULL;
}
//----------------------------------------------------------------------------
PHISTORY_REGION PSI_CreateHistoryRegion( void )
{
	PHISTORY_REGION phr = (PHISTORY_REGION)Allocate( sizeof( HISTORY_REGION ) );
	MemSet( phr, 0, sizeof( HISTORY_REGION ) );
	phr->pHistory.me = &phr->pHistory.next;
	CreateHistoryBlock( &phr->pHistory.root );
	return phr;
}
//----------------------------------------------------------------------------
PHISTORY_BROWSER PSI_CreateHistoryBrowser( PHISTORY_REGION region, MeasureString measureString, uintptr_t psvMeasure )
{
	PHISTORY_BROWSER phbr = (PHISTORY_BROWSER)Allocate( sizeof( HISTORY_BROWSER ) );
	MemSet( phbr, 0, sizeof( HISTORY_BROWSER ) );
	InitializeCriticalSec( &phbr->cs );
	phbr->region = region;
	phbr->DisplayLineInfo = CreateDataList( sizeof( DISPLAYED_LINE ) );
	phbr->flags.bWrapText = 1;
	phbr->measureString = measureString;
	phbr->psvMeasure = psvMeasure;
	AddLink( &region->pBrowsers, phbr );
	return phbr;
}
//----------------------------------------------------------------------------
void ResolveLineColor( PHISTORY_LINE_CURSOR pdp, PTEXT pLine )
{
	FORMAT *f;
	while( pLine )
	{
 // ignore extended formats
		if( !(pLine->flags & TF_FORMATEX) )
		{
			f = &pLine->format;
			if( f->flags.default_foreground )
				f->flags.foreground = pdp->output.DefaultColor.flags.foreground;
			else if( f->flags.prior_foreground )
				f->flags.foreground = pdp->output.PriorColor.flags.foreground;
			if( f->flags.highlight )
				f->flags.foreground |= 8;
			if( f->flags.default_background )
				f->flags.background = pdp->output.DefaultColor.flags.background;
			else if( f->flags.prior_background )
				f->flags.background = pdp->output.PriorColor.flags.background;
			if( f->flags.reverse )
			{
			}
			if( f->flags.blink )
				f->flags.background |= 8;
			// apply any fixup for DEFAULT_COLOR or PRIOR_COLOR
			pdp->output.PriorColor = *f;
		}
		pLine = NEXTLINE( pLine );
	}
}
//----------------------------------------------------------------------------
PTEXTLINE GetSomeHistoryLineEx( PHISTORY_REGION region
									 , PHISTORYBLOCK start
 // 0 = from end of, -1 = next up...
									 , int line
										 DBG_PASS )
#define GetSomeHistoryLine(r,s,n) GetSomeHistoryLineEx(r,s,n DBG_SRC )
{
	// if history has never had anything...
	//_xlprintf( 0 DBG_RELAY )("Getting some history line: %d", line );
	if( !region->pHistory.next )
		return NULL;
	if( ( line > 0 ) && start )
	{
		return start->pLines + (line-1);
	}
	if( !start )
	{
		start = region->pHistory.last;
		line += start->nLinesUsed;
		//lprintf( "overriding start, using line as rel index back... now is %d", line );
	}
	// if start, and line < 0 then we'll naturally
	// step back one at a time...
	// so for a certain loop we may have a start greater than 0
	// which will rreturn immediately,
	// at less than 0 we back up a block, add that blocks size,
	// and result with that blocks, now positive index, and so forth
	// until there are no blocks, or the index becomes a positive one
	// in a block...
	{
		PHISTORYBLOCK pBlock = start;
		// correct for last block last line index...
		//line += region->pHistory.last->nLinesUsed;
		// if line is before this block, then step back
		// through the blocks until line is discovered....
		while( *(pBlock->me) && line <= 0 )
		{
			// okay we never want to pre-expand when doing this get...
			// this is really intended to be the routine to browse
			// therefore if it's not there, don't show it.
			// still have lines to go back to get to the desired line,
			// but it is past the beginning page-break... uhmm actually...
			//
			if( pBlock->nLinesUsed && pBlock->pLines[0].pLine )
				if( ( pBlock->pLines[0].pLine->flags & TF_FORMATEX ) &&
					( pBlock->pLines[0].pLine->format.flags.format_op == FORMAT_OP_PAGE_BREAK ) )
				{
					DebugBreak();
					// can't go backwards past a page-break.
					return NULL;
				}
			if( ( pBlock = pBlock->prior ) && *(pBlock->me) )
			{
				//lprintf( "Adjusting line as we step backward..." );
				line += pBlock->nLinesUsed;
			}
		}
		if( line > 0 )
		{
			if( line < MAX_HISTORY_LINES )
			{
				//lprintf( "Setting used lines in history block..." );
				//pBlock->nLinesUsed = line;
			}
			return pBlock->pLines + (line - 1);
		}
	}
	return NULL;
}
//----------------------------------------------------------------------------
// if bExpand ...
//	this is done during normal line processing
//	and if this is the case - then Y is an apsolute
//  hmm... if not expand - then return the literal line...
//  otherwise only consider real lines?  no...
//  okay so the flags must be set and managed... but then overridden
//  if a
PTEXTLINE GetNewHistoryLine( PHISTORY_REGION region )
{
	PHISTORYBLOCK pBlock = region->pHistory.last;
	if( pBlock->nLinesUsed >= MAX_HISTORY_LINES )
	{
		pBlock = CreateHistoryBlock( &region->pHistory.root );
	}
	//lprintf( "INcrementint lines used... returning this line at %d", pBlock->nLinesUsed );
	return pBlock->pLines + pBlock->nLinesUsed++;
}
//----------------------------------------------------------------------------
// get the line to which output is going...
// ncursory is measured from top of form down.
// the actual updated region may be outside of browser parameters...
PTEXTLINE GetAHistoryLine( PHISTORY_LINE_CURSOR phc, PHISTORY_BROWSER phbr, int nLine, int bCreate )
{
	if( phc )
	{
		int tmp;
		PHISTORYBLOCK phb;
		//lprintf( "Get line %d after %d", nLine, phc->output.top_of_form.line );
		tmp = nLine + phc->output.top_of_form.line;
		phb = phc->output.top_of_form.block;
		// first block is different then those after this...
		// have to remember we may be biased within a block...
		if( phb && phb->next &&tmp >= phb->nLinesUsed )
		{
			tmp -= phb->nLinesUsed - phc->output.top_of_form.line;
			phb = phb->next;
		}
		while( phb && phb->next &&
				tmp >= phb->nLinesUsed )
		{
			tmp -= phb->nLinesUsed;
			phb = phb->next;
		}
		//lprintf( "tmp is now %d", tmp );
		{
			PTEXTLINE ptl;
			while( tmp >= (phb?phb->nLinesUsed:0) )
			{
				if( !bCreate )
				{
					// fail creation of blank lines...
					return NULL;
				}
				ptl = GetNewHistoryLine( phc->region );
				if( !phc->output.top_of_form.block )
					phc->output.top_of_form.block = phc->region->pHistory.next;
				if( !phb )
					phb = phc->output.top_of_form.block;
				if( phb && phb->next )
				{
					tmp -= phb->nLinesUsed;
					phb = phb->next;
				}
			}
		}
		return phb->pLines + tmp;
	}
	else if( phbr )
	{
		INDEX tmp;
		PHISTORYBLOCK phb;
		//lprintf( "Get line %d after %d", nLine, phbr->nLine );
		tmp = nLine + phbr->nLine;
		phb = phbr->pBlock;
		// first block is different then those after this...
		// have to remember we may be biased within a block...
		if( phb && phb->next &&tmp >= phb->nLinesUsed )
		{
			tmp -= phb->nLinesUsed - phbr->nLine;
			phb = phb->next;
		}
		while( phb && phb->next &&
				tmp >= phb->nLinesUsed )
		{
			tmp -= phb->nLinesUsed;
			phb = phb->next;
		}
		//lprintf( "tmp is now %d", tmp );
		{
			PTEXTLINE ptl;
			while( tmp >= (phb?phb->nLinesUsed:0) )
			{
				if( !bCreate )
				{
					// fail creation of blank lines...
					return NULL;
				}
				ptl = GetNewHistoryLine( phbr->region );
				if( !phbr->pBlock )
					phbr->pBlock = phbr->region->pHistory.next;
				if( !phb )
					phb = phbr->pBlock;
				if( phb->next )
				{
					tmp -= phb->nLinesUsed;
					phb = phb->next;
				}
			}
		}
		return phb->pLines + tmp;
	}
	return NULL;
}
PTEXTLINE GetHistoryLine( PHISTORY_LINE_CURSOR phc )
{
	if( phc->output.nCursorY < 0 )
		phc->output.nCursorY = 0;
	return GetAHistoryLine( phc, NULL, phc->output.nCursorY, TRUE );
}
//----------------------------------------------------------------------------
struct PSI_console_word *PutSegmentOut( PHISTORY_LINE_CURSOR phc
							  , PTEXT segment )
{
	// this puts the segment at the correct x, y
	// it also updates the curren X on the65 line...
	struct PSI_console_word *word = New( struct PSI_console_word );
	PTEXTLINE pCurrentLine;
	PTEXT text;
	int len;
	if( !(phc->region->pHistory.next) ||
		 ( phc->region->pHistory.last->nLinesUsed == MAX_HISTORY_LINES &&
			!(segment->flags&TF_NORETURN) ) )
		CreateHistoryBlock( &phc->region->pHistory.root );
	//lprintf( "Okay after much layering... need to fix some...." );
	//lprintf( "Put a segment out!" );
	// get line at nCursorY
	word->line = pCurrentLine = GetHistoryLine( phc );
	word->cursor_position_added_at = phc->output.nCursorX;
	word->segment = segment;
	if( !pCurrentLine )
	{
		lprintf( "No line result from history..." );
	}
	if( (phc->output.nCursorX) > pCurrentLine->flags.nLineLength )
	{
		// beyond the end of the line...
		PTEXT filler = SegCreate( (phc->output.nCursorX) - pCurrentLine->flags.nLineLength );
		TEXTCHAR *data = GetText( filler );
		int n;
#ifdef DEBUG_OUTPUT
		lprintf( "Cursor beyond line, creating filler segment up to X" );
#endif
		filler->format.flags.foreground = segment->format.flags.foreground;
		filler->format.flags.background = segment->format.flags.background;
		//Log1( "Make a filler segment %d charactes", phc->region->(phc->output.nCursorX) - pCurrentLine->nLineLength );
		for( n = 0; n < (phc->output.nCursorX) - pCurrentLine->flags.nLineLength; n++ )
		{
			data[n] = ' ';
		}
		pCurrentLine->flags.nLineLength = (phc->output.nCursorX);
		pCurrentLine->pLine = SegAppend( pCurrentLine->pLine, filler );
	}
	if( (phc->output.nCursorX) < pCurrentLine->flags.nLineLength )
	{
		// very often the case...
		// need to split the segment which the cursor is on
		// unless the cursor happens to be at the start of the segment,
		// in which cast, it is spilt, segment is inserted, and
		// any data in the segment beyond 'segment' will have to be
		// split/trimmed/overwritten.
		// so - split the line, result with current segment.
		int32_t pos = 0;
#ifdef DEBUG_OUTPUT
		lprintf( "Okay insert/overwrite this segment on the display..." );
#endif
		text = pCurrentLine->pLine;
		while( pos < (phc->output.nCursorX) && text )
		{
			len = (int)GetTextSize( text );
			//Log3( "Skipping over ... pos:%d len:%d curs:%d", pos, len, phc->region->(phc->output.nCursorX) );
			if( (len + pos) > (phc->output.nCursorX) )
			{
				// 'text' is OVER pos...
				PTEXT split;
				if( text == pCurrentLine->pLine )
					split = SegSplit( &pCurrentLine->pLine, ( (phc->output.nCursorX) - pos ) );
				else
					split = SegSplit( &text, ( (phc->output.nCursorX) - pos ) );
 // otherwise we miscalculated something.
				if( split )
				{
					text = NEXTLINE( split );
					len = (int)GetTextSize( text );
				}
			}
			pos += len;
			text = NEXTLINE( text );
		}
	}
 // cursor is exactly linelength...
	else
	{
		//Log( "Cursor is at end or after end." );
		text = NULL;
		len = 0;
	}
	// expects 'text' to be the start of the correct segment.
	if( segment->flags & TF_FORMATEX )
	{
		Log( "Extended info carried on this segment." );
		segment->flags &= ~TF_FORMATEX;
		switch( segment->format.flags.format_op )
		{
 // these are difficult....
		case FORMAT_OP_CLEAR_END_OF_LINE:
			//Log( "Clear end of line..." );
			if( text == pCurrentLine->pLine )
			{
				pCurrentLine->pLine = NULL;
				pCurrentLine->flags.nLineLength = 0;
			}
			SegBreak( text );
			LineRelease( text );
			text = NULL;
			len = 0;
			break;
		case FORMAT_OP_DELETE_CHARS:
			Log1( "Delete %d characters", segment->format.flags.background );
 // otherwise there's no characters to delete?  or does it mean next line?
			if( text )
			{
				PTEXT split;
				Log1( "Has a current segment... %" _size_f, GetTextSize( text ) );
				if( text == pCurrentLine->pLine )
				{
					Log( "is the first segment... ");
					split = SegSplit( &pCurrentLine->pLine, segment->format.flags.background );
					text = pCurrentLine->pLine;
				}
				else
				{
					Log("Is not first - splitting segment... ");
					split = SegSplit( &text, segment->format.flags.background );
				}
				if( split )
				{
					Log( "Resulting split..." );
					text = NEXTLINE( split );
					LineRelease( SegGrab( split ) );
				}
				else
				{
					Log( "Didn't split the line - deleting the next segment." );
					LineRelease( SegGrab( text ) );
				}
			}
			else
			{
				Log( "Didn't find a next semgnet( text)" );
			}
			break;
		case FORMAT_OP_CLEAR_START_OF_LINE:
			{
				PTEXT filler = SegCreate( (phc->output.nCursorX) );
				TEXTCHAR *data = GetText( filler );
				int n;
				filler->format.flags.foreground = phc->output.PriorColor.flags.foreground;
				filler->format.flags.background = phc->output.PriorColor.flags.background;
				//Log1( "Make a filler segment %d charactes", (phc->output.nCursorX) - pCurrentLine->nLineLength );
				for( n = 0; n < (phc->output.nCursorX) - pCurrentLine->flags.nLineLength; n++ )
				{
					data[n] = ' ';
				}
				Log( "This is all so terribly bad - clear start of line is horrid idea." );
 // insert before text... else append to line.
				if( text )
				{
					PTEXT fill_here = SegCreate( 1 );
 // 1 space.
					GetText( fill_here )[0] = ' ';
					fill_here->format.flags.foreground = segment->format.flags.foreground;
					fill_here->format.flags.background = segment->format.flags.background;
					if( text == pCurrentLine->pLine )
					{
						SegSplit( &pCurrentLine->pLine, 1 );
						text = pCurrentLine->pLine;
						SegSubst( pCurrentLine->pLine, fill_here );
						if( GetTextSize( filler ) )
							Log( "Size expected, zero size filler computed" );
 // should be zero sized...
						LineRelease( filler );
					}
					else
					{
 // need to eat 1 character.
						SegSplit( &text, 1 );
						SegSubst( text, fill_here );
						text = fill_here;
						SegBreak( fill_here );
						LineRelease( pCurrentLine->pLine );
						pCurrentLine->pLine = SegAppend( filler, fill_here );
					}
				}
				else
				{
					// attribute of filler needs to be set to current color paramters.
					LineRelease( pCurrentLine->pLine );
					pCurrentLine->pLine = filler;
				}
			}
			break;
		case FORMAT_OP_PAGE_BREAK:
			// enque as normal...
			segment->flags |= TF_FORMATEX;
			pCurrentLine->pLine = SegAppend( pCurrentLine->pLine, segment );
			// step to the next line, cursor 0, all zero...
			phc->output.nCursorX = 0;
			phc->output.nCursorY++;
  // start a new line
			pCurrentLine = GetHistoryLine( phc );
  // signal current line index is a new form
			SetTopOfForm( phc );
			break;
		case FORMAT_OP_JUSTIFY_CENTER:
		case FORMAT_OP_JUSTIFY_RIGHT:
			// this needs to pass
			// enque as normal...
			// the display layer needs to know this ex format
			segment->flags |= TF_FORMATEX;
			break;
		default:
			Log( "Invalid extended format segment. " );
			break;
		}
		if( !(segment->flags & TF_FORMATEX ) )
		{
			if( segment->format.flags.prior_foreground )
				segment->format.flags.foreground = phc->output.PriorColor.flags.foreground;
			else
				segment->format.flags.foreground = phc->output.DefaultColor.flags.foreground;
			if( segment->format.flags.prior_background )
				segment->format.flags.background = phc->output.PriorColor.flags.background;
			else
				segment->format.flags.background = phc->output.DefaultColor.flags.background;
		}
	}
	//else
	//	Log( "No extended info carried on this segment." );
	if( GetTextSize( segment ) || ( segment->flags & TF_FORMATEX ) )
	{
		if( text )
		{
			//Log( "Inserting new segment..." );
			SegInsert( segment, text );
			if( text == pCurrentLine->pLine )
				pCurrentLine->pLine = segment;
		}
		else
		{
			//Log( "Appending segment." );
			pCurrentLine->pLine = SegAppend( pCurrentLine->pLine, segment );
		}
		len = (int)GetTextSize( segment );
		(phc->output.nCursorX) += len;
		if( !phc->region->flags.bInsert && text )
		{
			// len characters from 'text' need to be removed.
			// okay that should be fun...
			int32_t deletelen = len;
			//Log1( "Remove %d characters!", len );
			while( deletelen && text )
			{
				int32_t thislen = (int)GetTextSize( text );
				PTEXT next = NEXTLINE( text );
				if( thislen <= deletelen )
				{
					LineRelease( SegGrab( text ) );
					deletelen -= thislen;
					text = next;
				}
 // thislen > deletelen
				else
				{
					if( text == pCurrentLine->pLine )
						SegSplit( &pCurrentLine->pLine, deletelen );
					else
						SegSplit( &text, deletelen );
				}
			}
		}
		else
			pCurrentLine->flags.nLineLength += len;
	}
	else if( segment->flags & TF_FORMATEX )
	{
		// the only one that gets here is the set top of form??
		//switch( segment->format.flags.format_op )
		pCurrentLine->pLine = SegAppend( pCurrentLine->pLine, segment );
		SetTopOfForm( phc );
	}
	else
	{
		pCurrentLine->pLine = SegAppend( pCurrentLine->pLine, segment );
		//Log( "no data in segment." );
	}
	return word;
}
//----------------------------------------------------------------------------
void SetTopOfForm( PHISTORY_LINE_CURSOR phlc )
{
	if( phlc )
	{
		lprintf( "Set the top of form here..." );
		while( phlc->output.top_of_form.block &&
				phlc->output.top_of_form.block->next )
			phlc->output.top_of_form.block = phlc->output.top_of_form.block->next;
		if( phlc->output.top_of_form.block )
			phlc->output.top_of_form.line = phlc->output.top_of_form.block->nLinesUsed;
		phlc->output.nCursorY = 0;
	}
}
//----------------------------------------------------------------------------
PTEXT HandleExtendedFormat( PHISTORY_LINE_CURSOR phc, PTEXT pLine )
{
	PTEXT _pLine = pLine;
	PTEXTLINE pCurrentLine;
	switch( pLine->format.flags.format_op )
	{
		/*
		 case FORMAT_OP_GET_CURSOR:
		 {
		 PTEXT responce = SegCreate(0);
		 responce->flags |= TF_FORMATEX;
		 responce->format.foreground = FORMAT_OP_SET_CURSOR;
		 responce->format.position.coords.x = pht->nCursorX;
		 responce->format.position.coords.y = -pht->nCursorY;
		 EnqueLink( &pht->pdp->common.Input, responce );
		 }
		 break;
		 */
	case FORMAT_OP_PAGE_BREAK:
 // set cursor home
	case FORMAT_OP_CLEAR_PAGE:
		pLine->format.flags.format_op = FORMAT_OP_PAGE_BREAK;
		// and that sets the cursory to 0 for the thing...
		// but now if I hit top of form in display gather info
		// then I need to stop.
		// pages are still bottom-up safe then.
 // these are difficult....
	case FORMAT_OP_CLEAR_END_OF_LINE:
	case FORMAT_OP_CLEAR_START_OF_LINE:
	case FORMAT_OP_DELETE_CHARS:
	case FORMAT_OP_JUSTIFY_RIGHT:
	case FORMAT_OP_JUSTIFY_CENTER:
		// need to pass this segment through to enquesegments
		pLine->flags |= TF_FORMATEX;
		break;
	case FORMAT_OP_CLEAR_LINE:
		pLine->format = phc->output.PriorColor;
		pCurrentLine = GetHistoryLine( phc );
		phc->output.nCursorX = 0;
		pCurrentLine->flags.nLineLength = 0;
		LineRelease( pCurrentLine->pLine );
		pCurrentLine->pLine = NULL;
		break;
	case FORMAT_OP_CLEAR_END_OF_PAGE:
		pLine->format = phc->output.PriorColor;
		{
			int y;
			PTEXTLINE ptl;
			for( y = phc->output.nCursorY;
				 (ptl = GetHistoryLine( phc ));
				  y++ )
			{
				ptl->flags.nLineLength = 0;
				LineRelease( ptl->pLine );
				ptl->pLine = NULL;
			}
		}
		break;
	case FORMAT_OP_CLEAR_START_OF_PAGE:
		pLine->format = phc->output.PriorColor;
		{
			int y;
			PTEXTLINE ptl;
			for( y = 0;
				 y < phc->output.nCursorY;
				  y++ )
			{
				ptl = GetAHistoryLine( phc, NULL, y, FALSE );
				ptl->flags.nLineLength = 0;
				LineRelease( ptl->pLine );
				ptl->pLine = NULL;
			}
		}
		break;
 // sets option to not show text at all until next color.
	case FORMAT_OP_CONCEAL:
		pLine->format.flags.foreground = 0;
		pLine->format.flags.background = 0;
		// hmm - need to set this as a flag... but
		// for now this will be sufficient....
		pLine->flags &= ~TF_FORMATEX;
		break;
	}
	return _pLine;
}
//----------------------------------------------------------------------------
PSI_Console_Phrase PSI_EnqueDisplayHistory( PHISTORY_LINE_CURSOR phc, PTEXT pLine )
{
	 PSI_Console_Phrase phrase = New( struct PSI_console_phrase );
	MemSet( phrase, 0, sizeof( struct PSI_console_phrase ) );
	if( pLine->flags & TF_FORMATEX )
	{
		// clear this bit... extended format will result with bit re-set
		// if it is so required.
		pLine->flags &= ~TF_FORMATEX;
		HandleExtendedFormat( phc, pLine );
	}
	if( !(pLine->flags & TF_NORETURN) )
	{
		// auto return/newline if not noreturn
		//lprintf( "Not NORETURN - therefore skipping to next line..." );
		phc->output.nCursorX = 0;
		phc->output.nCursorY++;
	}
	{
		PTEXTLINE pCurrentLine = NULL;
		//lprintf( "Flattening line..." );
		pLine = FlattenLine( pLine );
		ResolveLineColor( phc, pLine );
		// colors are processed in the stream of output - not by position
		// lprintf okay putting segments out...
		{
			PTEXT next = pLine;
			while( ( pLine = next ) )
			{
				next = NEXTLINE( pLine );
				AddLink( &phrase->words, PutSegmentOut( phc, SegGrab( pLine ) ) );
			}
		}
 // else no change...
		if( pCurrentLine )
		{
			pCurrentLine->flags.nLineLength = (int)LineLength( pCurrentLine->pLine );
		}
	}
	{
		INDEX idx;
		PHISTORY_BROWSER browser;
		LIST_FORALL( phc->region->pBrowsers, idx, PHISTORY_BROWSER, browser ) {
			browser->flags.bUpdated = 1;
		}
	}
	return phrase;
}
//----------------------------------------------------------------------------
void DumpBlock( PHISTORYBLOCK pBlock DBG_PASS )
{
	INDEX idx;
	_xlprintf( 0 DBG_RELAY )("History block used lines: %" _size_f " of %d", pBlock->nLinesUsed, MAX_HISTORY_LINES );
	for( idx = 0; idx < pBlock->nLinesUsed; idx++ )
	{
		PTEXTLINE ptl = pBlock->pLines + idx;
		_xlprintf( 0 DBG_RELAY )("line: %" _size_f " = (%d,%" _size_f ",%s)", idx, ptl->flags.nLineLength, GetTextSize( ptl->pLine ), GetText( ptl->pLine ) );
	}
}
//----------------------------------------------------------------------------
void DumpRegion( PHISTORY_REGION region DBG_PASS )
{
	PHISTORYBLOCK blocks = region->pHistory.root.next;
	_xlprintf( 0 DBG_RELAY )("History blocks: %d history block size: %d", region->nHistoryBlocks
			 , region->nHistoryBlockSize
			 );
	while( blocks )
	{
		DumpBlock( blocks DBG_RELAY );
		blocks = blocks->next;
	}
}
//----------------------------------------------------------------------------
PTEXT EnumHistoryLineEx( PHISTORY_BROWSER phbr
							  , int *offset
							  , int32_t *length DBG_PASS)
#define EnumHistoryLine(hb,o,l) EnumHistoryLineEx(hb,o,l DBG_SRC )
{
	PTEXTLINE ptl;
	int line = -(*offset);
	if( !offset )
	{
		Log( "No start..." );
		return NULL;
	}
	//lprintf("Getting line: %d ", line );
	//DumpRegion( phlc->region DBG_RELAY );
	// uhmm... yeah.
	ptl = GetSomeHistoryLine( phbr->region
									, phbr->pBlock
									, (phbr->pBlock?phbr->nLine:0) + line );
	//DumpRegion( phlc->region DBG_RELAY );
	if( ptl )
	{
		(*offset)++;
		if( ptl->pLine )
		{
			if( length )
				*length = ptl->flags.nLineLength;
			//lprintf( "Resulting: (%d)%s", ptl->nLineLength, GetText( ptl->pLine ) );
			return ptl->pLine;
		}
		else
		{
			DECLTEXT( nothing, "" );
			nothing.format.flags.foreground = 0;
			nothing.format.flags.background = 0;
			if( length )
				*length = 0;
			//lprintf( "resulting nothing. %d", line );
			return (PTEXT)&nothing;
		}
	}
	//Log( "No result" );
	return NULL;
}
//----------------------------------------------------------------------------
void SetHistoryLength( PHISTORY_REGION phr, int length )
{
	Log1( "Set Length to %" _size_f " blocks", length/MAX_HISTORY_LINES );
	phr->nMaxHistoryBlocks = length/MAX_HISTORY_LINES;
}
//----------------------------------------------------------------------------
INDEX GetHistoryLength( PHISTORY_REGION phr )
{
	int total = 0;
	PHISTORYBLOCK block;
	for( block = phr->pHistory.root.next; block; block = block->next )
		total += block->nLinesUsed;
	return total;
}
//----------------------------------------------------------------------------
void InitHistoryRegion( PHISTORY_REGION phr )
{
	while( phr->pHistory.next )
		PSI_DestroyRawHistoryBlock( phr->pHistory.next );
	phr->tabsize = 8;
 // configurable option now...
	phr->nMaxHistoryBlocks = 5000;
}
//----------------------------------------------------------------------------
void WriteHistoryToFile( FILE *file, PHISTORY_REGION phr )
{
#ifndef __NO_WIN32API__
	PHISTORYBLOCK pHistory = phr->pHistory.next;
	INDEX idx;
	while( pHistory )
	{
		lprintf( "Have a history block with %" _size_f " lines", pHistory->nLinesUsed );
		for( idx = 0; idx < pHistory->nLinesUsed; idx++ )
		{
			size_t length;
			PTEXTLINE pLine = pHistory->pLines + idx;
			PTEXT pText = pLine->pLine;
			while( pText )
			{
				length = GetTextSize( pText );
				lprintf( "%s", GetText(pText) );
				sack_fwrite( &length,  sizeof( length ), 1, file );
				sack_fwrite( &pText->flags,  sizeof( pText->flags ), 1, file );
				sack_fwrite( &pText->format,  sizeof( pText->format ), 1, file );
				sack_fwrite( GetText( pText ), length, 1, file );
				pText = NEXTLINE( pText );
			}
			length = 0;
			sack_fwrite( &length,  sizeof( length ), 1, file );
		}
		pHistory = pHistory->next;
	}
#else
	lprintf( "Cannot write to file, please port file access" );
#endif
}
void ReadHistoryFromFile( FILE *file, PHISTORY_REGION phr )
{
#ifndef __NO_WIN32API__
	size_t length;
	PTEXT readline = NULL;
	PTEXT rebuild;
	while( sack_fread( &length,  sizeof( length ), 1, file ) )
	{
		if( length )
		{
			rebuild = SegCreate( length );
			sack_fread( &rebuild->flags, sizeof( rebuild->flags ), 1, file );
			sack_fread( &rebuild->format, sizeof( rebuild->format ), 1, file );
			sack_fread( GetText( rebuild ), length, 1, file );
			readline = SegAppend( readline, rebuild );
		}
		else
		{
			PSI_EnqueDisplayHistory( (PHISTORY_LINE_CURSOR)GetLink( &phr->pCursors, 0 )
				, readline );
			readline = NULL;
		}
	}
#else
	lprintf( "Cannot write to file, please port file access" );
#endif
}
void SetHistoryBackingFile( PHISTORY_REGION phr, FILE *file )
{
	ReadHistoryFromFile( file, phr );
	phr->file_backing = file;
}
//----------------------------------------------------------------------------
uint32_t ComputeNextOffset( PTEXT segment, uint32_t nShown )
{
	 uint32_t offset = 0;
	 while( segment )
	 {
		uint32_t nLen = (uint32_t)GetTextSize( segment );
		TEXTCHAR *text = GetText( segment );
		while( nShown < nLen
			  && text[nShown] == ' ' )
			nShown++;
		if( nShown == nLen )
		{
			offset += nShown;
			nShown = 0;
			segment = NEXTLINE( segment );
			continue;
		}
		else
			break;
	 }
	 return nShown + offset;
}
//----------------------------------------------------------------------------
uint32_t ComputeToShow( uint32_t colsize, uint32_t *col_offset, PTEXT segment, uint32_t nLen, uint32_t nOfs, uint32_t nShown, PHISTORY_BROWSER phbr, SFTFont font )
{
	int32_t result_bias = 0;
	int32_t nShow = nLen - nShown;
	uint32_t nLenSize, nLenHeight;
	// if space left to show here is less than
	// then length to show, compute wrapping point.
	//lprintf( "Compute to show: %d (%d)%s %d %d", cols, GetTextSize( segment ), GetText( segment ), nOfs, nShown );
	phbr->measureString( phbr->psvMeasure, GetText( segment ) + nShown
		, nLen - nShown, &nLenSize, &nLenHeight, font );
	if( ( nLenSize + (*col_offset ) ) > colsize || nLenHeight > (uint32_t)phbr->nLineHeight )
	{
		uint32_t good_space_size;
		LOGICAL has_good_space = FALSE;
		uint32_t good_space = 0;
		uint32_t nSpace;
		uint32_t nSegSize, nSegHeight;
		uint32_t best_chars = 0;
		uint32_t best_char_size;
		TEXTCHAR *text = GetText( segment );
		for( nSpace = nShown; nSpace < nLen; nSpace++ )
		{
			if( text[nSpace] == '\n' )
			{
				phbr->measureString( phbr->psvMeasure, GetText( segment ) + nShown
					, nSpace - nShown, &nSegSize, &nSegHeight, font );
				good_space_size = nSegSize;
				has_good_space = TRUE;
 // include space in this part of the line...
				good_space = nSpace;
 // start next line past the \n
				result_bias = 1;
				break;
			}
			else if( text[nSpace] == ' ' || text[nSpace] == '\t' )
			{
				//lprintf( "measure string until space... %s (%s)", text, text + nSpace );
				phbr->measureString( phbr->psvMeasure, GetText( segment ) + nShown
					, nSpace - nShown, &nSegSize, &nSegHeight, font );
				if( ( (*col_offset) + nSegSize  ) < colsize )
				{
					has_good_space = TRUE;
					good_space_size = nSegSize;
 // include space in this part of the line...
					good_space = nSpace + 1;
				}
				else
					break;
			}
			else if( !best_chars )
			{
				phbr->measureString( phbr->psvMeasure, GetText( segment ) + nShown
					, nSpace - nShown, &nSegSize, &nSegHeight, font );
				if( ( (*col_offset) + nSegSize  ) >= colsize )
				{
					if( (nSpace - nShown) < 2 ) {
						if( *col_offset ) return 0;
						best_char_size = nSegSize;
  // minimum of 1 character to use.
						best_chars = nShown + 1;
						break;
					}
					best_chars = (nSpace - 1);
					break;
				}
				else {
					best_char_size = nSegSize;
				}
			}
		}
		if( !best_chars && !has_good_space && best_char_size && (*col_offset) == 0 )
			best_chars = nSpace - 1;
		// found a space, please show up to that.
		if( has_good_space )
		{
			//while( text[good_space] == ' ' )
			//	good_space++;
			(*col_offset) += good_space_size;
			nShow = good_space - nShown;
		}
		else if( best_chars )
		{
			(*col_offset) += best_char_size;
			nShow = best_chars - nShown;
		}
 // if started after a line, wrap whole thing to next...
		else if( nOfs )
		{
			nShow = 0;
			(*col_offset) = 0;
		}
		else
		{
			// failing all of this nShow will be length, and non delimited text
			// will wrap forcably.
			// show as much fo this....
			// well.. have to figure out which character will still fit....
			for( nSpace = nShown; nSpace <= nLen; nSpace++ )
			{
				phbr->measureString( phbr->psvMeasure, GetText( segment ) + nShown
					, nSpace - nShown, &nSegSize, &nSegHeight, font );
				if( ( (*col_offset) + nSegSize  ) < colsize )
					;
				else
				{
					nShow = ( nSpace - 1 ) - nShown;
					(*col_offset) += nSegSize;
					break;
				}
			}
			if( nSpace > nLen )
			{
				nShow = ( nSpace - 1 ) - nShown;
				(*col_offset) += nSegSize;
				// ran out of characters in segment... whole segment fits.
				// it didn't fit, but now it fits?!
				//lprintf( "This should be a segfault or something" );
			}
		}
	 }
	 else
	{
		 nShow = nLen - nShown;
		(*col_offset) += nLenSize;
	}
	if( (nShow + result_bias) < 0 )
		DebugBreak();
	//lprintf( "Show %d", nShow );
	return nShow + result_bias;
}
//----------------------------------------------------------------------------
int SkipSomeLines( PHISTORY_BROWSER phbr, SFTFont font, PTEXT countseg, int lines )
{
	uint32_t colsize = phbr->nWidth;
	// always spans at least one line.
	int nLines = 1;
	if( countseg && colsize )
	{
		int32_t nShown = 0;
		int32_t nChar = 0;
		uint32_t col_offset = 0;
		while( countseg )
		{
			int32_t nLen = (int)GetTextSize( countseg );
			// part of this segment has already been skipped.
			// ComputeNextOffset can do this.
			if( nShown > nLen )
			{
				nShown -= nLen;
			}
 // otherwise nShown is within this segment...
			else
			{
				uint32_t text_size;
				uint32_t text_lines;
				phbr->measureString( phbr->psvMeasure, GetText( countseg ), nLen, &text_size, &text_lines, font );
				if( ( col_offset + text_size ) > colsize )
				{
					// this is the wrapping condition...
					while( nShown < nLen )
					{
						nShown += ComputeToShow( colsize, &col_offset, countseg, nLen, nChar, nShown, phbr, font );
						if( nShown < nLen )
						{
							nLines++;
							nChar = 0;
						}
					}
					nShown -= nLen;
				}
				else
					nChar += nLen;
			}
			countseg = NEXTLINE( countseg );
		}
		return nShown;
	}
	return 0;
}
//----------------------------------------------------------------------------
// colsize is the size of space the line can take up
int CountLinesSpannedEx( PHISTORY_BROWSER phbr, PTEXT countseg, SFTFont font, LOGICAL count_trailing_linefeeds, int leadinPad )
#define CountLinesSpanned(phbr,segs,font,lf)   CountLinesSpannedEx(phbr,segs,font,lf,0)
{
	// always spans at least one line.
	uint32_t colsize = phbr->nWidth;
	int nLines = 1;
	int used_size = 0;
	if( countseg && colsize )
	{
		int32_t nChar = 0;
  // pixel size of nShown
		uint32_t col_offset = leadinPad;
   // how many characters of this segment have been put out
		int32_t nSegShown = 0;
   // how many characters have been put out
		int32_t nShown = 0;
		while( countseg )
		{
			int32_t nLen = (int)GetTextSize( countseg );
			// part of this segment has already been skipped.
			// ComputeNextOffset can do this.
			if( !nLen )
			{
				// empty segment is linebreak....
				if( !count_trailing_linefeeds && !countseg->Next )
				{
					while( countseg->Prior && !GetTextSize( countseg->Prior ) )
					{
						nLines--;
						countseg = PRIORLINE( countseg );
					}
					return nLines;
				}
				//else
				//	nLines++;
				//if( countseg->Prior || countseg->Next )
				//	nLines++;
			}
			else
			{
				uint32_t text_size;
				uint32_t text_lines;
				phbr->measureString( phbr->psvMeasure, GetText( countseg ), nLen, &text_size, &text_lines, font );
				if( ( text_lines > (uint32_t)phbr->nLineHeight )
					|| ( ( col_offset + text_size ) > colsize ) )
				{
					int32_t _nShown = nShown;
					// this is the wrapping condition...
					while( nSegShown < nLen )
					{
						int skip_char;
						int32_t nShow = ComputeToShow( colsize, &col_offset, countseg, nLen, nChar, nSegShown, phbr, font );
						if( nShow + nSegShown > 1 ) {
							if( GetText( countseg )[nShow + nSegShown - 1] == '\n' )
								skip_char = 1;
							else
								skip_char = 0;
						}
						else if( PRIORLINE( countseg ) ) {
							skip_char = 0;
						}
						else
							skip_char = 0;
						if( ( nShow == 0 ) && ( nSegShown < nLen ) )
							nShow++;
						nSegShown += nShow;
						nShown += nShow ;
						_nShown = nShown;
						if( nSegShown < nLen || skip_char )
						{
							nLines++;
							nChar = 0;
							col_offset = 0;
						}
					}
				}
				else
				{
					nChar += nLen;
					col_offset += text_size;
				}
			}
			nSegShown = 0;
			countseg = NEXTLINE( countseg );
		}
	}
	return nLines;
}
//----------------------------------------------------------------------------
// nOffset is number of lines to move...
int AlignHistory( PHISTORY_BROWSER phbr, int32_t nOffset, SFTFont font )
{
	int result = UPDATE_NOTHING;
	//lprintf( "--------------- ALIGN HISTORY -------------" );
	// sets the current line pointer to the current position plus/minus nOffset.
	// this routine will fix the nHistoryDisplay to be
	// within some block... consider boundry where condition
	// may cause bounce...
	// also - this will make sure that there is a minimum of
	// nHistoryLines left to be displayed...
	if( !phbr->pBlock )
	{
		PHISTORYBLOCK phb = phbr->region->pHistory.next;
		while( phb && phb->next && phb->next->nLinesUsed )
			phb = phb->next;
		phbr->nLine = phb->nLinesUsed - 1;
		phbr->pBlock = phb;
	}
	while( ( nOffset < 0 ) && phbr->pBlock )
	{
		//lprintf( "Offset is %d and is < 0", nOffset );
		nOffset++;
		if( phbr->nLine > 1 )
		{
			if( phbr->nOffset )
			{
				lprintf( "Previously had an offset... %d", phbr->nOffset );
				phbr->nOffset--;
			}
			else
			{
				int n;
				phbr->nLine--;
				n = CountLinesSpanned( phbr
					, phbr->pBlock->pLines[phbr->nLine-1].pLine, font, FALSE );
				//lprintf( "total span is what ? %d", n );
				if( n )
					phbr->nOffset = n-1;
			}
		}
		else
		{
			if( (*phbr->pBlock->prior->me) )
			{
				lprintf( "jumping back naturally." );
				phbr->pBlock = phbr->pBlock->prior;
				phbr->nLine = phbr->pBlock->nLinesUsed;
			}
			else
			{
				// fell off the beginning of history.
				// and nline is already 0....
				// phlc->nLine = 0;
				lprintf( "Fell off of history ... need to lock down at first line." );
				phbr->pBlock = phbr->region->pHistory.next;
 // minimum.
				phbr->nLine = 1;
				nOffset = 0;
				break;
			}
			// plus full number of lines left...
			// always at least 1, but my be more from this...
			// but it is truncated result, hence it does not include the
			// 1 for the partial line (which is what the first 1 is - partial line)
			if( phbr->pBlock->pLines[phbr->nLine-1].flags.nLineLength )
			{
				int tmp;
				lprintf( "This counted on an monospaced font...." );
 /*phbr->nColumns*/
				tmp = (phbr->pBlock->pLines[phbr->nLine - 1].flags.nLineLength - 1) / 12;
				lprintf( "Offset plus uhmm... %d", tmp );
				nOffset += tmp;
			}
		}
	}
	{
		// fix up forward motion
		// N == number of lines the current line is...
		// the offset is the total distance of lines we wish
		// to move.
		int n;
		while( phbr->pBlock &&
				( nOffset > 0 ) )
		{
			n = CountLinesSpanned( phbr
				, phbr->pBlock->pLines[phbr->nLine-1].pLine, font, FALSE );
			//lprintf( "fixing forward motion offset: %d this spans %d", nOffset, n );
			if( n - phbr->nOffset > nOffset )
			{
				// okay then how do we find the offset of this line?
				// probably consult the uhmm gather code...
				phbr->nOffset = n - nOffset;
				nOffset = 0;
			}
			else
			{
/*+1*/
				nOffset -= (n);
				//nOffset--; // subtrace one just for moving a line.
				phbr->nLine++;
				phbr->nOffset = 0;
				if( (int64_t)phbr->nLine > phbr->pBlock->nLinesUsed )
				{
					phbr->pBlock = phbr->pBlock->next;
					phbr->nLine = 1;
				}
			}
		}
		// fell off the tail of history - clear out shown history
		// and then we're all done....
		if( !phbr->pBlock )
		{
			phbr->nLine = 0;
			return result;
		}
	}
	//!!!!!!!!!!!!!!!!!!
	// this bit of code needs more smarts - to advance to
	// the line correctly located at the end of the set
	// of history lines shown and stay there....
	// fixup before all history...
	if( phbr->nLine < 0 )
	{
		nOffset = 0;
		phbr->nLine = 1;
	}
	if( !phbr->pBlock )
	{
		phbr->pBlock = phbr->region->pHistory.last;
	}
	// fixup alignment beyond the current block...
	while( (int64_t)phbr->nLine > phbr->pBlock->nLinesUsed
			&& phbr->pBlock->next )
	{
		phbr->nLine -= phbr->pBlock->nLinesUsed;
		phbr->pBlock = phbr->pBlock->next;
	}
	if( phbr->nLine > phbr->pBlock->nLinesUsed )
	{
		phbr->nLine = 0;
		phbr->pBlock = NULL;
	}
	return result;
}
//----------------------------------------------------------------------------
int32_t GetBrowserDistance( PHISTORY_BROWSER phbr, SFTFont font )
{
 // count of lines...
	int32_t nLines = 0;
	PHISTORYBLOCK pHistory;
	INDEX n;
	for( n = phbr->nLine, pHistory = phbr->pBlock;
		 pHistory;
		  (pHistory = pHistory->next), n=0 )
	{
		for( ; n < pHistory->nLinesUsed; n++ )
		{
			nLines += CountLinesSpanned( phbr
				, pHistory->pLines[n].pLine, font, FALSE );
		}
	}
#ifdef DEBUG_OUTPUT
	lprintf( "Browser is %" _size_f " lines from end...", nLines );
#endif
	return nLines;
}
//----------------------------------------------------------------------------
int MoveHistoryCursor( PHISTORY_BROWSER browser, int amount )
{
	AlignHistory( browser, amount, NULL );
	return UPDATE_HISTORY;
}
//----------------------------------------------------------------------------
// return the x position of the visible cursor
int GetCommandCursor( PHISTORY_BROWSER phbr
                    , SFTFont font
                    , PUSER_INPUT_BUFFER CommandInfo
                    , int bEndOfStream
                    , int bWrapCommand
                    , int *command_offset
                    , int *command_begin
                    , int *command_end
                    , int *command_pixel_start
                    , int *command_pixel_cursor
                    , int *line_offset
                    )
{
	PTEXT pCmd;
	int32_t tmpx = 0, nLead, tmp_end = 0;
	int32_t pixelWidth = 0;
	PDISPLAYED_LINE pdl;
	int32_t lines;
	if( !CommandInfo )
		return 0;
	// else there is no history...
	//lprintf( "bendofstream = %d", bEndOfStream );
	if( bEndOfStream )
	{
		(*line_offset) = 0;
		pdl = (PDISPLAYED_LINE)GetDataItem( &phbr->DisplayLineInfo, 0 );
		if( pdl ) {
			int32_t max;
			tmpx = pdl->nToShow;
			pixelWidth = pdl->nPixelEnd;
			if( !bWrapCommand )
				if( phbr->nWidth < 150 )
					max = (phbr->nWidth * 2) / 3;
				else
					max = phbr->nWidth - 150;
			else
				max = phbr->nWidth;
			if( pixelWidth > max ) {
				lprintf( "Drawing direct command prompt is confusing... and I don't like it." );
				// I have to put the command here, so I have to adjust the visible line...
				// or go down to the next line, and if I'm on the next line, I have to result that also...
				// but then I have to know this before I even start drawing so the last line is not
				// the last line of history, but is a command prompt...
				// also need to count the prompt size (macro:line)...
			}
			nLead = tmpx;
		}
		else {
			nLead = 0;
			pixelWidth = 0;
		}
	}
	else {
		nLead = 0;
		pixelWidth = 0;
	}
	if( command_offset )
		(*command_offset) = nLead;
	if( command_pixel_start )
		(*command_pixel_start) = pixelWidth;
	pCmd = CommandInfo->CollectionBuffer;
	SetStart( pCmd );
	if( bWrapCommand )
	{
		lines = CountLinesSpannedEx( phbr, pCmd, font, TRUE, pixelWidth );
		if( bEndOfStream )
			lines--;
	}
	else
	{
		if( bEndOfStream )
  // number of lines we have to push display up...
			lines = 0;
		else
			lines = 1;
	}
	tmp_end = 0;
	while( pCmd != CommandInfo->CollectionBuffer )
	{
		uint32_t width, height;
		phbr->measureString( phbr->psvMeasure, GetText( pCmd ), (int)GetTextSize( pCmd ), &width, &height, font );
		pixelWidth += width;
		tmp_end += (int)GetTextSize( pCmd );
		pCmd = NEXTLINE( pCmd );
	}
	//tmp_end = tmpx;
	while( pCmd )
	{
		uint32_t width, height;
		if( tmp_end < CommandInfo->CollectionIndex ) {
			phbr->measureString( phbr->psvMeasure, GetText( pCmd )
 /* GetTextSize( pCmd )*/
				, (int)CommandInfo->CollectionIndex - tmp_end, &width, &height, font );
			pixelWidth += width;
		}
		tmp_end += (int)GetTextSize( pCmd );
		pCmd = NEXTLINE( pCmd );
	}
	tmpx += (int)CommandInfo->CollectionIndex;
	if( command_begin )
		(*command_begin) = 0;
	if( command_end )
	{
		(*command_end) = tmp_end;
	}
	/*
	if( tmpx > phbr->nColumns - 10 )
	{
		if( command_begin )
			(*command_begin) = ( tmpx - ( phbr->nColumns - 10 ) ) - nLead;
		tmpx = phbr->nColumns - 10;
	}
	*/
	if( command_pixel_cursor )
		( *command_pixel_cursor) = pixelWidth;
	return tmpx;
}
//----------------------------------------------------------------------------
void ResetHistoryBrowser( PHISTORY_BROWSER phbr )
{
	// now unlocked and trails the end...
	phbr->pBlock = NULL;
	phbr->nLine = 0;
}
//----------------------------------------------------------------------------
int KeyEndHst( PHISTORY_BROWSER pht )
{
	ResetHistoryBrowser( pht );
	return UPDATE_HISTORY;
}
//----------------------------------------------------------------------------
int HistoryLineUp( PHISTORY_BROWSER pb )
{
	return MoveHistoryCursor( pb, !pb->pBlock?-(int)pb->nPageLines:-1 );
}
//----------------------------------------------------------------------------
int HistoryLineDown( PHISTORY_BROWSER pb )
{
	if( pb->pBlock )
		return MoveHistoryCursor( pb, 1 );
	return 0;
}
//----------------------------------------------------------------------------
int HistoryPageUp( PHISTORY_BROWSER pb )
{
	//lprintf( "Moving history up %d", pb->nPageLines );
	return MoveHistoryCursor( pb, -(int)pb->nPageLines );
}
//----------------------------------------------------------------------------
int HistoryPageDown( PHISTORY_BROWSER pb )
{
	//lprintf( "Moving history down %d", pb->nPageLines );
	if( pb->pBlock )
		return MoveHistoryCursor( pb, pb->nPageLines );
	return 0;
}
//----------------------------------------------------------------------------
PDATALIST *GetDisplayInfo( PHISTORY_BROWSER phbr )
{
	return &phbr->DisplayLineInfo;
}
int CountDisplayedLines( PHISTORY_BROWSER phbr )
{
	int n;
	int used = 0;
	for( n = 0; ; n++ )
	{
		PDISPLAYED_LINE pdl;
		if( pdl = (PDISPLAYED_LINE)GetDataItem( &phbr->DisplayLineInfo, n ) ) {
			if( pdl->start )
				used++;
		}
		else break;
	}
	return used;
}
void BuildDisplayInfoLines( PHISTORY_BROWSER phbr, PHISTORY_BROWSER leadin, SFTFont font )
//void BuildDisplayInfoLines( PHISTORY_LINE_CURSOR phlc )
{
	if( phbr->flags.bUpdated )
	{
		int nLines, nLinesShown = 0;
  // this with col_offset is character count on line
		int nChar;
		uint32_t nLen;
 // pixel position to match nChar
		uint32_t col_offset;
 // characters on segment shown
		uint32_t nSegShown = 0;
		//int nLineCount = phbr->nLines;
		int nLineTop = phbr->nFirstLine;
		PTEXT pText;
		PDATALIST *CurrentLineInfo = &phbr->DisplayLineInfo;
		int start;
		int firstline = 1;
 // total length of all segs shown on a line...
		uint32_t nShown = 0;
		PDISPLAYED_LINE pLastSetLine = NULL;
		PTEXTLINE pLastLine = GetAHistoryLine( NULL, phbr, 0, FALSE );
		PDISPLAYED_LINE pdlLeadin = (PDISPLAYED_LINE)(leadin?GetDataItem( &leadin->DisplayLineInfo, 0 ):NULL);
		//PHISTORY phbStart;
		if( *CurrentLineInfo )
			(*CurrentLineInfo)->Cnt = 0;
		start = 0;
		EnterCriticalSec( &phbr->cs );
#ifdef DEBUG_OUTPUT
			lprintf( "nShown starts at %d %d", nShown, pdlLeadin?pdlLeadin->nToShow:0 );
#endif
			while( ( nLineTop > 0 ) &&
					 ( pText = EnumHistoryLine( phbr
											  , &start
											  , NULL ) ) )
			{
				DISPLAYED_LINE dl;
				//lprintf( " Lines %d of %d", nLinesShown, nLineCount );
				// can't show past the top of form.
				// while bhilding display info lines...
				// this is history info lines also?!
				if( ( pText->flags & TF_FORMATEX ) && ( pText->format.flags.format_op == FORMAT_OP_PAGE_BREAK ) )
				{
					if( !phbr->flags.bNoPageBreak && !phbr->flags.bOwnPageBreak )
					{
						//DebugBreak();
 // done!
						break;
					}
					if( phbr->flags.bNoPageBreak && !phbr->flags.bOwnPageBreak )
						continue;
				}
				if( pLastLine && pText == pLastLine->pLine )
				{
					lprintf( "top of form reached, bailing early on available history." );
					break;
				}
				if( phbr->flags.bWrapText )
				{
					int nShow;
					int nWrapped = 0;
					nLines = CountLinesSpannedEx( phbr, pText, font, FALSE, pdlLeadin?pdlLeadin->nPixelEnd:0 );
#ifdef DEBUG_OUTPUT
					lprintf( "------------- Building Display Info Lines %d  offset %d", nLines, pdlLeadin ? pdlLeadin->nPixelEnd : 0 );
#endif
					if( pdlLeadin )
  // if there's a leadin (command prompt) then use that to start.
						col_offset = pdlLeadin->nPixelEnd;
					else
 // new histroy line, itself should wrap.
						col_offset = 0;
					pdlLeadin = NULL;
					// after counting the first (last visible) line
					// figure out how much we need to overflow to show the
					// last partial line...
					// phbr->nOffset = 0->nLines-1 of wrap.  This
					// is the index of the line to show...
					// nOffset 0 == the beginning of the line
					// noffset 1 == second part of line...
					// if nOffset is small, then the extra lines
					// need to be thrown out... which means a
					// large nLines will cause a negative nLinesShown...
					//
					if( firstline )
					{
						//lprintf( "Fixup of first line by offset... %d %d"
						//		  , phbr->nOffset, nLines );
						if( 1 )
							;
						else
							nLinesShown = phbr->nOffset - (nLines-1);
						firstline = 0;
					}
					//lprintf( "Wraping text, current line is at most %d", nLines );
					nChar = 0;
					pLastSetLine = NULL;
					while( pText )
					{
	#ifdef __DEKWARE_PLUGIN__
						if( phbr->flags.bNoPrompt
							&& ( pText->flags & TF_PROMPT )
						  )
						{
						  // lprintf( "skipping prompt segment..." );
							pText = NEXTLINE( pText );
							continue;
						}
	#endif
						if( !pLastSetLine )
						{
 // just has to be different
							dl.nLine = start;
 // start of a new line here...
							dl.nFirstSegOfs = 0;
 // text in history that started this...
							dl.start = pText;
							dl.nToShow = 0;
							dl.nLineStart = 0;
							dl.nLineEnd = -1;
							dl.nPixelStart = col_offset;
							// nPixelEnd has to be set later with pLastSetLine
							dl.nLineHeight = phbr->nLineHeight;
							dl.nLineTop = nLineTop - (nLines) * phbr->nLineHeight;
							nLineTop = dl.nLineTop;
							//lprintf( "Adding line to display: %p (%d) %d", dl.start, dl.nOfs, dl.nLine );
							if( nLinesShown + nLines > 0 )
							{
#ifdef DEBUG_OUTPUT
								lprintf( "Set line %d %s", nLinesShown + nLines -1, GetText( dl.start ) );
#endif
								pLastSetLine = (PDISPLAYED_LINE)SetDataItem( CurrentLineInfo
																		   , nLinesShown + nLines -1
																		   , &dl );
							}
						}
						nLen = (int)GetTextSize( pText );
						{
							int trim_char;
							// shown - show part of this segment... but not the whole segment...
							if( !nLen )
							{
								// zero size segments can end up in the display because they contain
								// position or other formatting information.
								// generally systems will filter out the newlines and convert it to
								// a separatly queued line.
								if( 1 )
 /* !pText->format.flags.prior_background ||
									!pText->format.flags.prior_background ) */
 {
									pText = NEXTLINE( pText );
									nSegShown = 0;
									continue;
								}
								trim_char = 0;
								pText = NEXTLINE( pText );
								if( !pText ) break;
								nLen = (int)GetTextSize( pText );
								goto do_end_of_line;
							}
							else while( nSegShown < nLen )
							{
								trim_char = 0;
								// nShow is now the number of characters we can show.
#ifdef DEBUG_OUTPUT
								lprintf( "Segment is %d", GetTextSize( pText ) );
#endif
								nShow = ComputeToShow( phbr->nWidth, &col_offset, pText, nLen, nChar, nSegShown, phbr, font );
								// in case we wrap 0 characters for columns less than a width of a character...
								if( nShow > 0 ) {
									nSegShown += nShow;
									nShown += nShow;
									nChar += nShow;
									if( GetText( pText )[nSegShown - 1] == '\n' )
										trim_char = 1;
									else
										trim_char = 0;
									// wrapped on a space - word break in segment
									// or had a newline at the end which causes a wrap...
									// log the line and get a new one.
									pLastSetLine->nPixelEnd = col_offset;
									pLastSetLine->nToShow = nChar - trim_char;
									if( ( nSegShown < nLen ) || ( trim_char ) )
									{
										//lprintf( "Wrapped line... reset nChar cause it's a new line of characters." );
										nWrapped++;
									do_end_of_line:
										if( pLastSetLine ) {
											//lprintf( "Setting prior toshow to nChar...%d", nChar );
											if( nSegShown < nLen )
												dl.nPixelStart = col_offset = 0;
											else
												dl.nPixelStart = col_offset;
											dl.nLineEnd = pLastSetLine->nLineEnd = pLastSetLine->nLineStart + (nChar)-1;
										}
										else
											dl.nLineEnd = (nChar)-1;
										dl.nLineStart = dl.nLineEnd + 1;
									}
								}
								// begin a new line output
								if( (nSegShown < nLen) || (trim_char) ) {
									// continue with current char, but new start offset
									dl.nPixelStart = 0;
									col_offset = 0;
									dl.nLineTop += phbr->nLineHeight;
									{
 // just has to be different
										dl.nLine = nShown + start;
 // start of a new line here...
										dl.nFirstSegOfs = nSegShown;
 // text in history that started this...
										dl.start = pText;
										//lprintf( "Adding line to display: %p (%d) %d", dl.start, dl.nOfs, dl.nLine );
										if( (nLines - nWrapped) > 0 ) {
#ifdef DEBUG_OUTPUT
											lprintf( "Set line %d", nLinesShown + ((nLines - 1) - nWrapped) );
#endif
											pLastSetLine = (PDISPLAYED_LINE)SetDataItem( CurrentLineInfo
												, nLinesShown + (nLines-1) - nWrapped
												, &dl );
										}
									}
								}
								// skip next leading spaces.
								// (and can be more than the length of the first segment)
							}
						}
						pText = NEXTLINE( pText );
						nSegShown = 0;
					}
					nChar = 0;
					nLinesShown+=nLines;
					//lprintf( "Fixing up last line set for number of chars to show. %d", nChar );
					pLastSetLine->nToShow += nChar;
					pLastSetLine->nLineEnd = pLastSetLine->nLineStart + ( nChar - 1 );
					pLastSetLine->nPixelEnd = col_offset;
				}
				else
				{
					// this uses the cursorX to determine the left character to show...
					// cursor Y is the bottom line to show.
					dl.nFirstSegOfs = 0;
					dl.start = NULL;
					dl.nLine = 0;
					dl.nToShow = 0;
					dl.nLineStart = dl.nLineEnd = 0;
					nLines = 1;
					nChar = 0;
					col_offset = 0;
					lprintf( "Clearing last set line..." );
					pLastSetLine = NULL;
					while( ( dl.start = pText ) )
					{
	#ifdef __DEKWARE_PLUGIN__
						if( !phbr->flags.bNoPrompt && ( pText->flags & TF_PROMPT ) )
						{
							pText = NEXTLINE( pText );
							continue;
						}
	#endif
						if( !pLastSetLine )
						{
							nLen = (int)GetTextSize( pText );
							if( USS_LT( (dl.nFirstSegOfs + nLen), uint32_t, phbr->nOffset, int ) )
							{
								lprintf( "Skipping segement, it's before the offset..." );
								dl.nLineEnd += nLen;
								dl.nFirstSegOfs += nLen;
							}
							else
							{
 // just has to be different
								dl.nLine = start;
								//dl.start = pText; // text in history that started this...
								lprintf( "Adding line to display: %p (%" _size_f ") %" _size_f " %d"
										 , dl.start, dl.nFirstSegOfs, dl.nLine, nLinesShown+nLines );
								if( nLinesShown + nLines > 0 )
								{
									lprintf( "Set line %d", nLinesShown + nLines );
									pLastSetLine = (PDISPLAYED_LINE)SetDataItem( CurrentLineInfo
																							 , nLinesShown + nLines -1
																							 , &dl );
								}
								lprintf( "After set last set line is %p", pLastSetLine );
							}
						}
						pText = NEXTLINE( pText );
					}
					if( !pLastSetLine )
					{
						// dl will be initialized as a blank line...
						lprintf( "Adding line to display: %p (%" _size_f ") %" _size_f, dl.start, dl.nFirstSegOfs, dl.nLine );
						if( nLinesShown + nLines > 0 )
						{
							lprintf( "Set line %d", nLinesShown + nLines -1 );
							pLastSetLine = (PDISPLAYED_LINE)SetDataItem( CurrentLineInfo
																					 , nLinesShown + nLines -1
																					 , &dl );
						}
					}
				}
			}
		if( !nLinesShown && nLineTop > 0 ) {
			uint32_t h = phbr->nLineHeight;
			DISPLAYED_LINE dl;
			dl.nFirstSegOfs = 0;
			dl.start = NULL;
			dl.nLine = 0;
			dl.nToShow = 0;
			dl.nPixelStart = 0;
			dl.nPixelEnd = 0;
			dl.nLineStart = dl.nLineEnd = 0;
			dl.nLineHeight = h;
			dl.nLineTop = nLineTop - h;
			phbr->nLineHeight = dl.nLineHeight = h;
#ifdef DEBUG_OUTPUT
			lprintf( "Set first empty dataline." );
#endif
			SetDataItem( CurrentLineInfo, 0 , &dl );
		}
		//clear_remaining_lines:
		//lprintf( "Clearning lines %d to %d", nLinesShown, nLineCount );
		phbr->flags.bUpdated = 0;
		LeaveCriticalSec( &phbr->cs );
	}
}
//----------------------------------------------------------------------------
void SetCursorNoPrompt( PHISTORY_BROWSER phbr, LOGICAL bNoPrompt )
{
	phbr->flags.bNoPrompt = bNoPrompt;
}
//----------------------------------------------------------------------------
void PSI_SetHistoryDefaultForeground( PHISTORY_LINE_CURSOR phlc, int iColor )
{
	phlc->output.DefaultColor.flags.foreground = iColor;
	phlc->output.PriorColor = phlc->output.DefaultColor;
}
//----------------------------------------------------------------------------
void PSI_SetHistoryDefaultBackground( PHISTORY_LINE_CURSOR phlc, int iColor )
{
	phlc->output.DefaultColor.flags.background = iColor;
	phlc->output.PriorColor = phlc->output.DefaultColor;
}
//----------------------------------------------------------------------------
void GetHistoryCursorPos( PHISTORY_LINE_CURSOR phlc, int32_t* x, int32_t* y )
{
	if( x ) *x = phlc->output.nCursorX;
	if( y ) *y = phlc->output.nCursorY;
}
//----------------------------------------------------------------------------
int GetCursorLine( PHISTORY_LINE_CURSOR phlc )
{
	int32_t y;
	GetHistoryCursorPos( phlc, NULL, &y );
	return y;
}
//----------------------------------------------------------------------------
int GetCursorColumn( PHISTORY_LINE_CURSOR phlc )
{
	int32_t x;
	GetHistoryCursorPos( phlc, &x, NULL );
	return x;
}
//----------------------------------------------------------------------------
void SetCursorLine( PHISTORY_LINE_CURSOR phlc, int n )
{
	//GetHistoryCursorPos( phlc, NULL, &y );
	//return y;
}
//----------------------------------------------------------------------------
void SetCursorColumn( PHISTORY_LINE_CURSOR phlc, int n )
{
	//GetHistoryCursorPos( phlc, &x, NULL );
	//return x;
}
//----------------------------------------------------------------------------
void SetCursorHeight( PHISTORY_LINE_CURSOR phlc, int n )
{
	phlc->nHeight = n;
	// recompute visible lines...
}
//----------------------------------------------------------------------------
void SetBrowserHeight( PHISTORY_BROWSER phbr, int n )
{
	phbr->nHeight = n;
	// recompute visible lines...
}
//----------------------------------------------------------------------------
void SetBrowserWidth( PHISTORY_BROWSER phbr, int size )
{
	phbr->nWidth = size;
	// recompute visible lines...
}
//----------------------------------------------------------------------------
void SetCursorWidth( PHISTORY_LINE_CURSOR phlc, int n )
{
	phlc->nWidth = n;
	// recompute visible lines...
}
//----------------------------------------------------------------------------
void SetBrowserFirstLine( PHISTORY_BROWSER cursor, int nLine ) {
	cursor->nFirstLine = nLine;
}
//----------------------------------------------------------------------------
void SetHistoryCursorPos( PHISTORY_LINE_CURSOR phlc, int32_t x, int32_t y )
{
	phlc->output.nCursorX = (int16_t)x;
	phlc->output.nCursorY = (int16_t)y;
}
//----------------------------------------------------------------------------
void PSI_SetHistoryPageLines( PHISTORY_BROWSER phbr, uint32_t nLines )
{
	//lprintf( "Set histpry lines at %d", nLines );
	phbr->nPageLines = nLines;
}
//----------------------------------------------------------------------------
void PSI_SetHistoryBrowserNoPageBreak( PHISTORY_BROWSER phbr )
{
	phbr->flags.bNoPageBreak = 1;
}
//----------------------------------------------------------------------------
void PSI_SetHistoryBrowserOwnPageBreak( PHISTORY_BROWSER phbr )
{
	phbr->flags.bOwnPageBreak = 1;
}
void PSI_Console_SetPhraseData( PSI_Console_Phrase phrase, uintptr_t psv )
{
	if( phrase )
		phrase->data = psv;
}
uintptr_t PSI_Console_GetPhraseData( PSI_Console_Phrase phrase )
{
	if( phrase )
		return phrase->data;
	return 0;
}
PSI_CONSOLE_NAMESPACE_END
#ifdef WIN32
#define _INCLUDE_CLIPBOARD
#endif
#if ( defined( PSICON ) && defined( _WIN32 ) ) || defined( CONSOLECON ) || defined( WINCON )
int KeystrokePaste( PCONSOLE_INFO pdp )
{
    if( OpenClipboard(NULL) )
    {
        uint32_t format;
        // successful open...
        format = EnumClipboardFormats( 0 );
        while( format )
        {
            //DECLTEXT( msg, "                                     " );
            //msg.data.size = sprintf( msg.data.data, "Format: %d", format );
            //EnqueLink( pdp->ps->Command->ppOutput, SegDuplicate( (PTEXT)&msg ) );
#ifndef CF_TEXT
#define CF_TEXT 1
#endif
            if( format == CF_TEXT )
            {
                HANDLE hData = GetClipboardData( CF_TEXT );
                LPVOID pData = GlobalLock( hData );
                PTEXT pStroke = SegCreateFromText( pData );
                int ofs, n;
                GlobalUnlock( hData );
                n = ofs = 0;
                while( pStroke->data.data[n] )
                {
                    pStroke->data.data[ofs] = pStroke->data.data[n];
 // trash extra returns... keep newlines
                    if( pStroke->data.data[n] == '\r' )
                    {
                        n++;
                        continue;
                    }
                    else
                    {
                        ofs++;
                        n++;
                    }
                }
                pStroke->data.size = ofs;
                pStroke->data.data[ofs] = pStroke->data.data[n];
                if( PSI_DoStroke( pdp, pStroke ) ) 1;
                //   RenderCommandLine( pdp );
                //EnqueLink( pdp->ps->Command->ppOutput, SegDuplicate(pStroke) );
                LineRelease( pStroke );
                break;
            }
            format = EnumClipboardFormats( format );
        }
        CloseClipboard();
    }
    else
	 {
#ifdef __DEKWARE__PLUGIN__
        DECLTEXT( msg, "Clipboard was not available" );
		  EnqueLink( &pdp->common.Owner->Command->Output, &msg );
#endif
    }
    return 0;
}
#endif
//#define DO_LOGGING
#if defined( WIN32 ) || defined( SACK_BAG_EXPORTS )
#define _INCLUDE_CLIPBOARD
#endif
//#define NO_LOGGING
 // sprintf ?
 // strchr
/*
//#define USE_IMAGE_INTERFACE ImageInterface
//#define USE_RENDER_INTERFACE RenderInterface
#define USE_IMAGE_INTERFACE (g.MyImageInterface?g.MyImageInterface:(g.MyImageInterface=GetImageInterface() ))
#define USE_RENDER_INTERFACE (g.MyDisplayInterface?g.MyDisplayInterface:(g.MyDisplayInterface=GetDisplayInterface() ))
#include <image.h>
//PIMAGE_INTERFACE ImageInterface;
#include <render.h>
//PRENDER_INTERFACE RenderInterface;
#include <controls.h>
#include <keybrd.h>
*/
//#define PutStringEx(i,x,y,f,b,s,l) { Log6( "Putting string: %ld,%ld %ld %*.*s", x,y,l,l,l,s); PutStringFontEx( i,x,y,f,b,s,l,NULL); }
//#define BlatColor(i,x,y,w,h,c)	  { Log5( "BlatColor: %ld,%ld %ld,%ld %08lx", x, y, w, h, c ); BlatColor( i,x,y,w,h,c ); }
PSI_CONSOLE_NAMESPACE
#define text_alpha 255
#define back_alpha 255
static CDATA crColorTableText[16];
#if 0
= { AColor( 0,0,1, text_alpha ), AColor( 0, 0, 128, text_alpha ), AColor( 0, 128, 0, text_alpha )
									 , AColor( 0, 128, 128, text_alpha ), AColor( 192, 32, 32, text_alpha ), AColor( 140, 0, 140, text_alpha )
									 , AColor( 160, 160, 0, text_alpha ), AColor( 192, 192, 192, text_alpha )
									 , AColor( 128, 128, 128, text_alpha ), AColor( 0, 0, 255, text_alpha ), AColor( 0, 255, 0, text_alpha )
									 , AColor( 0, 255, 255, text_alpha ), AColor( 255, 0, 0, text_alpha ), AColor( 255, 0, 255, text_alpha )
									 , AColor( 255, 255, 0, text_alpha ), AColor( 255, 255, 255, text_alpha ) };
#endif
static CDATA crColorTableBack[16];
#if 0
] = { AColor( 0,0,1, back_alpha ), AColor( 0, 0, 128, back_alpha ), AColor( 0, 128, 0, back_alpha )
									 , AColor( 0, 128, 128, back_alpha ), AColor( 192, 32, 32, back_alpha ), AColor( 140, 0, 140, back_alpha )
									 , AColor( 160, 160, 0, back_alpha ), AColor( 192, 192, 192, back_alpha )
									 , AColor( 128, 128, 128, back_alpha ), AColor( 0, 0, 255, back_alpha ), AColor( 0, 255, 0, back_alpha )
									 , AColor( 0, 255, 255, back_alpha ), AColor( 255, 0, 0, back_alpha ), AColor( 255, 0, 255, back_alpha )
									 , AColor( 255, 255, 0, back_alpha ), AColor( 255, 255, 255, back_alpha ) };
#endif
#define MNU_FONT 100
#define MNU_HISTORYSIZE25 101
#define MNU_HISTORYSIZE50 102
#define MNU_HISTORYSIZE75 103
#define MNU_HISTORYSIZE100 104
#define MNU_DIRECT			105
#define MNU_COMMAND_COLOR 106
#define MNU_COMMAND_BACK  107
#define MNU_BLACK	 115
#define MNU_BLUE	  116
#define MNU_GREEN	 117
#define MNU_CYAN	  118
#define MNU_RED		119
#define MNU_MAGENTA  120
#define MNU_DKYEL	 121
#define MNU_GREY	  122
#define MNU_DKGREY	123
#define MNU_LTBLUE	124
#define MNU_LTGREEN  125
#define MNU_LTCYAN	126
#define MNU_LTRED	 127
#define MNU_LTMAG	 128
#define MNU_YELLOW	129
#define MNU_WHITE	 130
#define MNU_BKBLACK	 ( 115 + 16 )
#define MNU_BKBLUE	  ( 116 + 16 )
#define MNU_BKGREEN	 ( 117 + 16 )
#define MNU_BKCYAN	  ( 118 + 16 )
#define MNU_BKRED		( 119 + 16 )
#define MNU_BKMAGENTA  ( 120 + 16 )
#define MNU_BKDKYEL	 ( 121 + 16 )
#define MNU_BKGREY	  ( 122 + 16 )
#define MNU_BKDKGREY	( 123 + 16 )
#define MNU_BKLTBLUE	( 124 + 16 )
#define MNU_BKLTGREEN  ( 125 + 16 )
#define MNU_BKLTCYAN	( 126 + 16 )
#define MNU_BKLTRED	 ( 127 + 16 )
#define MNU_BKLTMAG	 ( 128 + 16 )
#define MNU_BKYELLOW	( 129 + 16 )
#define MNU_BKWHITE	 ( 130 + 16 )
//----------------------------------------------------------------------------
// only one master copy of this is really needed...
CDATA cPenNormal, cPenHighlight, cPenShadow, cPenDkShadow, cPenCursor;
PMENU hChildMenu;
PMENU hHistoryMenu;
//cpg27dec2006 console\psicon.c(96): Warning! W202: Symbol 'bCreatingControl' has been defined, but not referenced
//cpg27dec2006 static int bCreatingControl; // set when this is creating a control as opposed to someone externally creating one
//----------------------------------------------------------------------------
static int CPROC InitPSIConsole( PSI_CONTROL pc );
//static int CPROC RenderChildWindow( PSI_CONTROL pc );
static int CPROC MouseHandler( PSI_CONTROL pc, int32_t x, int32_t y, uint32_t b );
static int CPROC KeyEventProc( PSI_CONTROL pc, uint32_t key );
CONTROL_REGISTRATION ConsoleClass = { "PSI Console", { { 640, 480 }, sizeof( CONSOLE_INFO ), BORDER_NORMAL|BORDER_RESIZABLE|BORDER_FIXED }
												, InitPSIConsole
												, NULL
//RenderChildWindow
												, NULL
												, MouseHandler
												, KeyEventProc
};
//----------------------------------------------------------------------------
int CPROC RenderSeparator( PCONSOLE_INFO console, int nStart )
{
	if( nStart > 0 && (int64_t)nStart < console->nHeight )
	{
		// Render Command Line Separator
		do_hline( console->psicon.image, nStart, 0, console->nWidth, cPenHighlight );
		do_hline( console->psicon.image, nStart+1, 0, console->nWidth, cPenNormal );
		do_hline( console->psicon.image, nStart+2, 0, console->nWidth, cPenShadow );
		do_hline( console->psicon.image, nStart+3, 0, console->nWidth, cPenDkShadow );
		//SmudgeCommon( console->psicon.image );
	}
	return 4;
}
//----------------------------------------------------------------------------
void CPROC PSI_Console_KeystrokePaste( PCONSOLE_INFO console )
{
#if defined( WIN32 ) && !defined( __NO_WIN32API__ )
	if( OpenClipboard(NULL) )
	{
		uint32_t format;
		// successful open...
		format = EnumClipboardFormats( 0 );
		while( format )
		{
			if( format == CF_TEXT )
			{
				HANDLE hData = GetClipboardData( CF_TEXT );
				LPVOID pData = GlobalLock( hData );
				PTEXT pStroke = SegCreateFromText( (CTEXTSTR)pData );
				int ofs, n;
				GlobalUnlock( hData );
				n = ofs = 0;
				while( pStroke->data.data[n] )
				{
					pStroke->data.data[ofs] = pStroke->data.data[n];
 // trash extra returns... keep newlines
					if( pStroke->data.data[n] == '\r' )
					{
						n++;
						continue;
					}
					else
					{
						ofs++;
						n++;
					}
				}
				pStroke->data.size = ofs;
				pStroke->data.data[ofs] = pStroke->data.data[n];
				PSI_WinLogicDoStroke( console, pStroke );
				//EnqueLink( console->ps->Command->ppOutput, SegDuplicate(pStroke) );
				LineRelease( pStroke );
				break;
			}
			format = EnumClipboardFormats( format );
		  }
		  CloseClipboard();
	 }
	 else
	{
#ifdef __DEKWARE_PLUGIN__
		  DECLTEXT( msg, "Clipboard was not available" );
		  EnqueLink( &console->common.Output, (PTEXT)&msg );
#endif
	 }
#endif
	 return;
}
//----------------------------------------------------------------------------
static int OnDrawCommon( "PSI Console" )( PSI_CONTROL pc )
{
	ValidatedControlData( PCONSOLE_INFO, ConsoleClass.TypeID, console, pc );
	//PCONSOLE_INFO console = (PCONSOLE_INFO)GetCommonUserData(pc);
	//lprintf( "Rendering window." );
	if( !console )
	{
		Log( "How could we have gotten here without a console??" );
		return 0;
	}
	console->psicon.image = GetFrameSurface( pc );
	//ClearImage( console->psicon.image );
	BlatColor( console->psicon.image, 0, 0, console->psicon.image->width, console->psicon.image->height, AColor( 5, 5, 5, 64 ) );
	// this is the only place which size is changed.
	if( console->nWidth != console->psicon.image->width ||
		console->nHeight != console->psicon.image->height )
	{
		// nWidth/nHeight are set in child calculate
		// and acknowledge processing a new rarea rect.
		console->rArea.left = 0;
		console->rArea.right = console->psicon.image->width;
		console->rArea.top = 0;
		console->rArea.bottom = console->psicon.image->height;
		//lprintf( " ----------------- BOTTOM OF AREA %d ", console->psicon.image->height );
		//lprintf( "Updating child propportions..." );
 // this includes doing a render.
		PSI_ConsoleCalculate( console, GetCommonFont( pc ) );
	}
	else {
		PSI_RenderConsole( console, GetCommonFont( pc ) );
	}
	//lprintf( "Done rendering child." );
	return TRUE;
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
int CPROC KeyEventProc( PSI_CONTROL pc, uint32_t key )
{
	ValidatedControlData( PCONSOLE_INFO, ConsoleClass.TypeID, console, pc );
	//PCONSOLE_INFO console = (PCONSOLE_INFO)GetCommonUserData( pc );
	// this must here gather keystrokes and pass them forward into the
	// opened sentience...
	if( console )
	{
		const TEXTCHAR *character = GetKeyText( key );
 // single character ...
		DECLTEXT( stroke, "                                       " );
 // not a valid window handle/device path
		if( !console )
			return 0;
		EnterCriticalSec( &console->Lock );
		console->lockCount++;
		// here is where we evaluate the curent keystroke....
		if( character )
		{
			int n;
			for( n = 0; character[n]; n++ )
				stroke.data.data[n] = character[n];
			stroke.data.size = n;
		}
		else
			stroke.data.size = 0;
		if( key & KEY_PRESSED )
		{
			PSI_KeyPressHandler( console, (uint8_t)(KEY_CODE(key)&0xFF), (uint8_t)KEY_MOD(key), (PTEXT)&stroke, GetCommonFont( pc ) );
			//SmudgeCommon( console->psicon.frame );
		}
		console->lockCount--;
		LeaveCriticalSec( &console->Lock );
	}
	return 1;
}
//----------------------------------------------------------------------------
int CPROC MouseHandler( PSI_CONTROL pc, int32_t x, int32_t y, uint32_t b )
{
	static int32_t _x, _y;
	static uint32_t _b;
	//lprintf( "Mouse thing...%ld,%ld %08lx", x, y, b );
	{
		int xPos, yPos, row, col;
		//PCONSOLE_INFO console;
		if( (b & MK_LBUTTON) && !(_b & MK_LBUTTON) )
 // mouse down.
		  {
			  ValidatedControlData( PCONSOLE_INFO, ConsoleClass.TypeID, console, pc );
			  //console = (PCONSOLE_INFO)GetCommonUserData( pc );
			  if( !console )
				  return 0;
			  xPos = x;
			  yPos = y;
			  if( PSI_ConvertXYToLineCol( console, xPos, yPos
											, &row, &col ) )
			  {
				  //lprintf( "converted is %d,%d", row, col );
				  console->mark_start.row = row;
				  console->mark_start.col = col;
				  console->flags.bUpdatingEnd = 1;
				  console->flags.bMarking = 1;
				  console->CurrentMarkInfo = console->CurrentLineInfo;
			  }
		  }
		else if( ( !(b & MK_LBUTTON) && (_b & MK_LBUTTON) )
				  ||( b & MK_LBUTTON ) )
 // mouse up
		{
			ValidatedControlData( PCONSOLE_INFO, ConsoleClass.TypeID, console, pc );
			//console = (PCONSOLE_INFO)GetCommonUserData( pc );
			if( !console )
				return 0;
			xPos = x;
			yPos = y;
			if( PSI_ConvertXYToLineCol( console, xPos, yPos
										 , &row, &col ) )
			{
				//lprintf( "converted is %d,%d", row, col );
				if( console->CurrentMarkInfo == console->CurrentLineInfo )
				{
					if( console->flags.bUpdatingEnd )
					{
						console->mark_end.row = row;
						console->mark_end.col = col;
						if( console->mark_end.row > console->mark_start.row )
						{
							int tmp = console->mark_end.row;
							console->mark_end.row = console->mark_start.row;
							console->mark_start.row = tmp;
							tmp = console->mark_end.col;
							console->mark_end.col = console->mark_start.col;
							console->mark_start.col = tmp;
							console->flags.bUpdatingEnd = 0;
						}
						else if( console->mark_end.row == console->mark_start.row
								  && ( console->mark_end.col < console->mark_start.col ) )
						{
							int tmp = console->mark_end.col;
							console->mark_end.col = console->mark_start.col;
							console->mark_start.col = tmp;
							console->flags.bUpdatingEnd = 0;
						}
					}
					else
					{
						console->mark_start.col = col;
						console->mark_start.row = row;
						if( console->mark_end.row > console->mark_start.row )
						{
							int tmp = console->mark_end.row;
							console->mark_end.row = console->mark_start.row;
							console->mark_start.row = tmp;
							tmp = console->mark_end.col;
							console->mark_end.col = console->mark_start.col;
							console->mark_start.col = tmp;
							console->flags.bUpdatingEnd = 1;
						}
						else if( console->mark_end.row == console->mark_start.row
								  && console->mark_end.col < console->mark_start.col )
						{
							int tmp = console->mark_end.col;
							console->mark_end.col = console->mark_start.col;
							console->mark_start.col = tmp;
							console->flags.bUpdatingEnd = 1;
						}
					}
					if( !(b & MK_LBUTTON) && (_b & MK_LBUTTON) )
					{
						if( console->mark_start.row != console->mark_end.row
							|| console->mark_start.col != console->mark_end.col )
						{
#ifndef __NO_WIN32API__
#ifdef _WIN32
							TEXTCHAR *data = PSI_GetDataFromBlock( console );
							if( data && OpenClipboard(NULL) )
							{
								size_t nLen = StrLen( data ) + 1;
								HGLOBAL mem = GlobalAlloc( GMEM_MOVEABLE, nLen );
								MemCpy( GlobalLock( mem ), data, nLen );
								GlobalUnlock( mem );
								EmptyClipboard();
#ifndef CF_TEXT
#define CF_TEXT 1
#endif
								SetClipboardData( CF_TEXT, mem );
										  CloseClipboard();
										  GlobalFree( mem );
										  //Log( data );
										  Release( data );
							}
#endif
#endif
						}
						//Log( "Ending mark." );
						console->flags.bMarking = 0;
						console->flags.bUpdatingEnd = 0;
					}
					SmudgeCommon( console->psicon.frame );
				}
			}
			if( !(b & MK_LBUTTON) && (_b & MK_LBUTTON) )
			{
				//Log( "Ending mark(2)." );
				console->flags.bMarking = 0;
				console->flags.bUpdatingEnd = 0;
				SmudgeCommon( console->psicon.frame );
			}
		}
	}
	if( (b & MK_RBUTTON) && !(_b & MK_RBUTTON ) )
	{
		ValidatedControlData( PCONSOLE_INFO, ConsoleClass.TypeID, console, pc );
		//PCONSOLE_INFO console = (PCONSOLE_INFO)GetCommonUserData( pc );
		int cmd;
		if( !console )
			return 0;
		CheckPopupItem( hHistoryMenu
						  , MNU_HISTORYSIZE25+console->nHistoryPercent
						  , MF_BYCOMMAND|MF_CHECKED	 );
		if( console->flags.bDirect )
			CheckPopupItem( hChildMenu
							  , MNU_DIRECT
							  , MF_BYCOMMAND|MF_CHECKED );
		cmd = TrackPopup( hChildMenu, console->psicon.frame );
		if( ( cmd >= MNU_BKBLACK ) &&
			( cmd <= MNU_BKWHITE ) )
		{
			PSI_SetHistoryDefaultBackground( console->pCursor, cmd - MNU_BKBLACK );
			SACK_WriteProfileInt( "sack/PSI/console", "background", cmd - MNU_BKBLACK );
		}
		else if( ( cmd >= MNU_BLACK ) &&
				  ( cmd <= MNU_WHITE ) )
		{
			PSI_SetHistoryDefaultForeground( console->pCursor, cmd - MNU_BLACK );
			SACK_WriteProfileInt( "sack/PSI/console", "foreground", cmd - MNU_BLACK );
		}
		else switch( cmd )
		{
		case MNU_DIRECT:
			{
				console->flags.bDirect ^= 1;
				SACK_WriteProfileInt( "sack/PSI/console", "direct", console->flags.bDirect );
				EnterCriticalSec( &console->Lock );
				console->lockCount++;
				PSI_ConsoleCalculate( console, GetCommonFont( pc ) );
				console->lockCount--;
				LeaveCriticalSec( &console->Lock );
			}
			break;
		case MNU_HISTORYSIZE25:
		case MNU_HISTORYSIZE50:
		case MNU_HISTORYSIZE75:
		case MNU_HISTORYSIZE100:
			{
				console->nHistoryPercent =  cmd - MNU_HISTORYSIZE25;
				SACK_WriteProfileInt( "sack/PSI/console", "direct", console->nHistoryPercent );
 // currently showing history
				if( console->flags.bHistoryShow )
				{
					EnterCriticalSec( &console->Lock );
					console->lockCount++;
 // changed history display...
					PSI_ConsoleCalculate( console, GetCommonFont( pc ) );
					console->lockCount--;
					LeaveCriticalSec( &console->Lock );
				}
			}
			break;
		case MNU_FONT:
			{
				//console->cfFont.hwndOwner = hWnd;
				size_t size;
				SFTFont font;
				POINTER info = NULL;
				if( font = PickFont( -1, -1, &size, &info, NULL ) )
				{
					//POINTER data;
					//size_t datalen;
					//GetFontRenderData( font, &data, &datalen );
					SACK_WriteProfileString( "sack/PSI/console", "font", (CTEXTSTR)info );
					//console->psicon.hFont = (SFTFont)font;
					SetCommonFont( console->psicon.frame, (SFTFont)font );
					//GetDefaultFont();
					//GetStringSizeFont( " ", &console->nFontWidth, &console->nFontHeight, (SFTFont)font );
					PSI_ConsoleCalculate( console, GetCommonFont( pc ) );
				}
			}
				break;
		  case MNU_COMMAND_COLOR:
				{
				CDATA color;
					 if( PickColor( &color, console->psicon.crCommand, console->psicon.frame ) )
						  console->psicon.crCommand = color;
					 else
						  Log2( "Colors %08x %08x", color, console->psicon.crCommand );
				}
			break;
		  case MNU_COMMAND_BACK:
				{
				CDATA color;
					 if( PickColor( &color, console->psicon.crCommandBackground, console->psicon.frame ) )
						  console->psicon.crCommandBackground = color;
					 else
						  Log2( "Colors %08x %08x", color, console->psicon.crCommandBackground );
				}
			break;
		}
		  CheckPopupItem( hHistoryMenu
								 , MNU_HISTORYSIZE25+console->nHistoryPercent
								 , MF_BYCOMMAND|MF_UNCHECKED  );
		  CheckPopupItem( hChildMenu
								 , MNU_DIRECT
								 , MF_BYCOMMAND|MF_UNCHECKED );
	 }
	 _x = x;
	 _y = y;
	 _b = b;
	 return TRUE;
}
//----------------------------------------------------------------------------
// Image is a temporary subimage to draw into...
void DrawMenuItem( LOGICAL measure, PDRAWPOPUPITEM pdi )
{
	 if( measure )
	 {
		pdi->measure.width  = 80;
		pdi->measure.height = 15;
	 }
	 else
	 {
		  if( pdi->psvUser >= MNU_BLACK && pdi->psvUser <= MNU_WHITE )
				pdi->psvUser -= MNU_BLACK;
		  else if( pdi->psvUser >= MNU_BKBLACK && pdi->psvUser <= MNU_BKWHITE )
				pdi->psvUser -= MNU_BKBLACK;
		  BlatColor( pdi->draw.image
						, pdi->draw.x + 2, pdi->draw.y + 1
						  , pdi->draw.width - 4, pdi->draw.height - 2
						  , crColorTableText[ pdi->psvUser ] );
	 }
}
//----------------------------------------------------------------------------
static int WindowRegistered;
int RegisterWindows( void )
{
	if( WindowRegistered )
		return TRUE;
	//Log( "Done with psi interfaces.." );
	hChildMenu = CreatePopup();
	//Log( "Created menu..." );
	AppendPopupItem( hChildMenu, MF_STRING, MNU_FONT, "Set Font" );
	//Log( "Added an ittem..." );
	{
		hHistoryMenu = CreatePopup();
		AppendPopupItem( hHistoryMenu, MF_STRING, MNU_HISTORYSIZE25, "25%" );
		AppendPopupItem( hHistoryMenu, MF_STRING, MNU_HISTORYSIZE50, "50%" );
		AppendPopupItem( hHistoryMenu, MF_STRING, MNU_HISTORYSIZE75, "75%" );
		AppendPopupItem( hHistoryMenu, MF_STRING, MNU_HISTORYSIZE100, "100%" );
		AppendPopupItem( hChildMenu, MF_STRING|MF_POPUP, (uintptr_t)hHistoryMenu, "History Display Size" );
	}
	{
		PMENU hColorMenu, hColorMenu2;
		hColorMenu = CreatePopup();
		AppendPopupItem( hColorMenu, MF_OWNERDRAW, MNU_BLACK, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu, MF_OWNERDRAW, MNU_BLUE, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu, MF_OWNERDRAW, MNU_GREEN, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu, MF_OWNERDRAW, MNU_CYAN, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu, MF_OWNERDRAW, MNU_RED, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu, MF_OWNERDRAW, MNU_MAGENTA, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu, MF_OWNERDRAW, MNU_DKYEL, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu, MF_OWNERDRAW, MNU_GREY, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu, MF_OWNERDRAW, MNU_DKGREY, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu, MF_OWNERDRAW, MNU_LTBLUE, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu, MF_OWNERDRAW, MNU_LTGREEN, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu, MF_OWNERDRAW, MNU_LTCYAN, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu, MF_OWNERDRAW, MNU_LTRED, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu, MF_OWNERDRAW, MNU_LTMAG, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu, MF_OWNERDRAW, MNU_YELLOW, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu, MF_OWNERDRAW, MNU_WHITE, (POINTER)DrawMenuItem );
		AppendPopupItem( hChildMenu, MF_STRING|MF_POPUP, (uintptr_t)hColorMenu, "Text Color" );
		hColorMenu2 = CreatePopup();
		AppendPopupItem( hColorMenu2, MF_OWNERDRAW, MNU_BKBLACK, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu2, MF_OWNERDRAW, MNU_BKBLUE, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu2, MF_OWNERDRAW, MNU_BKGREEN, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu2, MF_OWNERDRAW, MNU_BKCYAN, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu2, MF_OWNERDRAW, MNU_BKRED, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu2, MF_OWNERDRAW, MNU_BKMAGENTA, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu2, MF_OWNERDRAW, MNU_BKDKYEL, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu2, MF_OWNERDRAW, MNU_BKGREY,  (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu2, MF_OWNERDRAW, MNU_BKDKGREY, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu2, MF_OWNERDRAW, MNU_BKLTBLUE, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu2, MF_OWNERDRAW, MNU_BKLTGREEN, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu2, MF_OWNERDRAW, MNU_BKLTCYAN, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu2, MF_OWNERDRAW, MNU_BKLTRED, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu2, MF_OWNERDRAW, MNU_BKLTMAG, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu2, MF_OWNERDRAW, MNU_BKYELLOW, (POINTER)DrawMenuItem );
		AppendPopupItem( hColorMenu2, MF_OWNERDRAW, MNU_BKWHITE, (POINTER)DrawMenuItem );
		AppendPopupItem( hChildMenu, MF_STRING|MF_POPUP, (uintptr_t)hColorMenu2, "Background Color" );
	}
	AppendPopupItem( hChildMenu, MF_STRING, MNU_COMMAND_COLOR, "Command Color" );
	AppendPopupItem( hChildMenu, MF_STRING, MNU_COMMAND_BACK, "Command Background Color" );
	AppendPopupItem( hChildMenu, MF_STRING, MNU_DIRECT, "Direct Mode" );
	//Log( "Menus created..." );
	cPenNormal = GetBaseColor( NORMAL );
	cPenHighlight = GetBaseColor( HIGHLIGHT );
	cPenShadow = GetBaseColor( SHADE );
	cPenDkShadow = GetBaseColor( SHADOW );
	cPenCursor = Color( 255, 255, 255 );
	WindowRegistered = TRUE;
	return TRUE;
}
//----------------------------------------------------------------------------
void UnregisterWindows( void )
{
	DestroyPopup( hChildMenu );
	// first set the old interfaces to NULL then we can drop the interface.
	SetControlInterface( NULL );
	//SetControlImageInterface( NULL );
	DropDisplayInterface( NULL );
	DropImageInterface( NULL );
	WindowRegistered = FALSE;
}
//----------------------------------------------------------------------------
#ifdef __DEKWARE_PLUGIN__
static void CPROC WinconPrompt( PDATAPATH console )
{
	//RenderCommandLine( (PCONSOLE_INFO)console );
 // will need to call this since it's bypassed
	prompt( console->Owner );
}
#endif
//----------------------------------------------------------------------------
#ifdef __DEKWARE_PLUGIN__
static int CPROC Close( PDATAPATH pPath )
{
	PCONSOLE_INFO console = (PCONSOLE_INFO)pPath;
	RemoveVolatileVariable( console->common.Owner->Current, &vve_rows );
	RemoveVolatileVariable( console->common.Owner->Current, &vve_cols );
	RemoveVolatileVariable( console->common.Owner->Current, &vve_cursorx );
	RemoveVolatileVariable( console->common.Owner->Current, &vve_cursory );
	console->common.Close = NULL;
	console->common.Write = NULL;
	console->common.Read = NULL;
	console->common.Type = 0;
	PSI_DestroyHistoryRegion( console->pHistory );
	PSI_DestroyHistoryCursor( console->pCursor );
	PSI_DestroyHistoryBrowser( console->pCurrentDisplay );
	PSI_DestroyHistoryBrowser( console->pHistoryDisplay );
	PSI_DestroyHistoryBrowser( console->pCommandDisplay );
	DestroyFrame( &console->psicon.frame );
	return 1;
}
#endif
static void FillDefaultColors( void )
{
	if( !crColorTableText[0] )
	{
		crColorTableText[0] = AColor( 0,0,1, text_alpha );
		crColorTableText[1] = AColor( 0, 0, 128, text_alpha );
		crColorTableText[2] = AColor( 0, 128, 0, text_alpha );
		crColorTableText[3] = AColor( 0, 128, 128, text_alpha );
		crColorTableText[4] = AColor( 192, 32, 32, text_alpha );
		crColorTableText[5] = AColor( 140, 0, 140, text_alpha );
		crColorTableText[6] = AColor( 160, 160, 0, text_alpha );
		crColorTableText[7] = AColor( 192, 192, 192, text_alpha );
		crColorTableText[8] = AColor( 128, 128, 128, text_alpha );
		crColorTableText[9] = AColor( 0, 0, 255, text_alpha );
		crColorTableText[10] = AColor( 0, 255, 0, text_alpha );
		crColorTableText[11] = AColor( 0, 255, 255, text_alpha );
		crColorTableText[12] = AColor( 255, 0, 0, text_alpha );
		crColorTableText[13] = AColor( 255, 0, 255, text_alpha );
		crColorTableText[14] = AColor( 255, 255, 0, text_alpha );
		crColorTableText[15] = AColor( 255, 255, 255, text_alpha );
		crColorTableBack[0] = AColor( 0,0,1, back_alpha );
		crColorTableBack[1] = AColor( 0, 0, 128, back_alpha );
		crColorTableBack[2] = AColor( 0, 128, 0, back_alpha );
		crColorTableBack[3] = AColor( 0, 128, 128, back_alpha );
		crColorTableBack[4] = AColor( 192, 32, 32, back_alpha );
		crColorTableBack[5] = AColor( 140, 0, 140, back_alpha );
		crColorTableBack[6] = AColor( 160, 160, 0, back_alpha );
		crColorTableBack[7] = AColor( 192, 192, 192, back_alpha );
		crColorTableBack[8] = AColor( 128, 128, 128, back_alpha );
		crColorTableBack[9] = AColor( 0, 0, 255, back_alpha );
		crColorTableBack[10] = AColor( 0, 255, 0, back_alpha );
		crColorTableBack[11] = AColor( 0, 255, 255, back_alpha );
		crColorTableBack[12] = AColor( 255, 0, 0, back_alpha ) ;
		crColorTableBack[13] = AColor( 255, 0, 255, back_alpha );
		crColorTableBack[14] = AColor( 255, 255, 0, back_alpha );
		crColorTableBack[15] = AColor( 255, 255, 255, back_alpha );
	}
}
//----------------------------------------------------------------------------
PRELOAD(RegisterConsole)
{
	//ImageInterface = GetImageInterface();
	//RenderInterface = GetDisplayInterface();
	DoRegisterControl( &ConsoleClass );
	//SimpleRegisterMethod( "psi/control/" "Dekware PSI Console" "/rtti/extra init"
	//						  , InitDekwareConsole, "int", "extra init", "(PSI_CONTROL)" );
}
void CPROC PSIMeasureString( uintptr_t psvConsole, CTEXTSTR s, int nShow, uint32_t *w, uint32_t *h, SFTFont font )
{
	PCONSOLE_INFO console = (PCONSOLE_INFO)psvConsole;
	GetStringSizeFontEx( s, nShow, w, h, font?font:GetCommonFont( console->psicon.frame ) );
}
//----------------------------------------------------------------------------
// methods for window logic routines to use as callbacks...
//----------------------------------------------------------------------------
static void CPROC DrawString( PCONSOLE_INFO console, int x, int y, RECT *r, CTEXTSTR s, int nShown, int nShow )
{
	//uint32_t width;
	//lprintf( "Adding string out : %p %s start:%d len:%d at %d,%d #%08lX #%08lX", console, s, nShown, nShow,x,y,r->left,r->top
	//		 , console->psicon.crText, console->psicon.crBack );
  // strings are measured way before drawstring happens now...
	if(0)
	{
		uint32_t w, h;
		GetStringSizeFontEx( s + nShown, nShow, &w, &h, GetCommonFont( console->psicon.frame ) );
		r->right = r->left + w;
		r->bottom = r->top + h;
	}
#ifdef DEBUG_OUTPUT
	lprintf( "Output string  xy(%d,%d)   lr(%d-%d)  tb(%d-%d) %*.*s  %08x %08x"
		, x, y
		, (*r).left, (*r).right, (*r).top, (*r).bottom
		, nShow, nShow, s + nShown, console->psicon.crText, console->psicon.crBack );
#endif
	PutStringFontEx( console->psicon.image, x, y
						, console->psicon.crText, console->psicon.crBack
						, s + nShown
						, nShow
						, GetCommonFont( console->psicon.frame ) );
}
//----------------------------------------------------------------------------
static void CPROC SetCurrentColor( PCONSOLE_INFO console, enum current_color_type type, PTEXT segment )
{
	switch( type )
	{
	case COLOR_COMMAND:
		( console->psicon.crText = console->psicon.crCommand );
		( console->psicon.crBack = console->psicon.crCommandBackground );
		break;
	case COLOR_MARK:
		( console->psicon.crText = console->psicon.crMark );
		( console->psicon.crBack = console->psicon.crMarkBackground );
		break;
	case COLOR_DEFAULT:
		( console->psicon.crText = crColorTableText[15] );
		( console->psicon.crBack = console->psicon.crBackground );
		break;
	case COLOR_SEGMENT:
		if( segment )
		{
			( console->psicon.crText = crColorTableText[segment->format.flags.foreground] );
			( console->psicon.crBack = crColorTableBack[segment->format.flags.background] );
		}
		break;
	}
	//lprintf( "Set Color :%p %d #%08lX #%08lX", console, type
	//		 , console->psicon.crText, console->psicon.crBack );
}
//----------------------------------------------------------------------------
static void CPROC FillConsoleRect( PCONSOLE_INFO console, RECT *r, enum fill_color_type type )
{
	switch( type )
	{
	case FILL_COMMAND_BACK:
		BlatColorAlpha( console->psicon.image
					, r->left,r->top
					, r->right - r->left
					, r->bottom - r->top, console->psicon.crCommandBackground );
		break;
	case FILL_DISPLAY_BACK:
		BlatColorAlpha( console->psicon.image, r->left,r->top
					 ,r->right - r->left
					 ,r->bottom - r->top
					, console->psicon.crBack );
		break;
	}
}
//----------------------------------------------------------------------------
static void CPROC RenderCursor( PCONSOLE_INFO console, RECT *r, int column )
{
	if( console->CommandInfo->CollectionInsert )
	{
		int y, x;
 /* * console->nFontWidth */
		x = ( column ) + console->nXPad;
		if( console->flags.bDirect )
			y = r->top;
		else
			y = r->top + 4;
		do_lineAlpha( console->psicon.image, x-3, y, x, y + 2, cPenCursor );
		do_lineAlpha( console->psicon.image, x, y+2, x+4, y, cPenCursor );
		if( console->flags.bDirect )
			y = r->bottom - 2;
		else
			y = r->bottom - 5;
		do_lineAlpha( console->psicon.image, x-3, y, x, y - 2, cPenCursor );
		do_lineAlpha( console->psicon.image, x, y-2, x+4, y, cPenCursor );
	}
	else
	{
		uint32_t w, h;
		int y, x;
 /*  * console->nFontWidth */
		x = ( column ) + console->nXPad;
		if( console->flags.bDirect )
			y = r->top;
		else
			y = r->top + 4;
		if( console->CommandInfo->CollectionIndex == GetTextSize( console->CommandInfo->CollectionBuffer) )
			GetStringSizeFontEx( " ", 1, &w, &h, GetCommonFont( console->psicon.frame ) );
		else if( console->CommandInfo->CollectionBuffer )
			GetStringSizeFontEx( GetText( console->CommandInfo->CollectionBuffer ) + console->CommandInfo->CollectionIndex, 1
			                   , &w, &h, GetCommonFont( console->psicon.frame ) );
		else {
			w = 0; h = 0;
		}
		do_lineAlpha( console->psicon.image, x, y+3, x, y, cPenCursor );
		do_lineAlpha( console->psicon.image, x, y, x + w, y, cPenCursor );
		do_lineAlpha( console->psicon.image, x + w, y, x+w, y+3, cPenCursor );
		if( console->flags.bDirect )
			y = r->bottom - 2;
		else
			y = r->bottom - 5;
		do_lineAlpha( console->psicon.image, x, y-3, x, y, cPenCursor );
		do_lineAlpha( console->psicon.image, x, y, x + w, y, cPenCursor );
		do_lineAlpha( console->psicon.image, x + w, y, x+w, y-3, cPenCursor );
	}
}
//----------------------------------------------------------------------------
static void CPROC ConsoleUpdate( PCONSOLE_INFO pmdp, RECT *upd )
{
	// passed region is the region which was updated by drawing
	// code.
	//lprintf( "------------------------------------" );
	//lprintf( "update some controls... %d,%d - %d,%d", upd->left, upd->right, upd->top, upd->bottom );
	upd->right -= upd->left;
	upd->bottom -= upd->top;
	// this causes the parent to update? shoudl be smart and recall the parent's
	// saved original picture here...
	UpdateSomeControls( pmdp->psicon.frame, (IMAGE_RECTANGLE*)upd );
	//lprintf( "------------------------------------" );
}
//----------------------------------------------------------------------------
static void OnControlFontChanged( "PSI Console" )(PSI_CONTROL pc) {
	ValidatedControlData( PCONSOLE_INFO, ConsoleClass.TypeID, console, pc );
	SFTFont font = GetCommonFont( pc );
	console->nFontHeight = GetFontHeight( GetCommonFont( pc ) );
	// it is possible that the new font has never rendered any characters
	if( !console->nFontHeight ) {
		console->nFontHeight = GetStringSizeFont( " ", NULL, NULL, GetCommonFont( pc ) );
	}
	PSI_ConsoleCalculate( console, font );
}
int CPROC InitPSIConsole( PSI_CONTROL pc )
{
	ValidatedControlData( PCONSOLE_INFO, ConsoleClass.TypeID, console, pc );
	if( !RegisterWindows() )
	{
		//Log( "Register windows failed..." );
 // cancel load, unload library...
		return FALSE;
	}
	FillDefaultColors();
	SetCommonTransparent( pc, TRUE );
	if( console )
	{
		//console->common.pName = SegCreateFromText( "Auto Console" );
		//Log( "Create frame!!" );
		console->psicon.frame = pc;
		InitializeCriticalSec( &console->Lock );
		// this is destroyed when the common closes...
		console->CommandInfo = CreateUserInputBuffer();
		//console->common.Type = myTypeID;
		console->flags.bDirect = 1;
		console->flags.bWrapCommand = 1;
		console->flags.bNoLocalEcho = 1;
		//console->common.flags.Formatted = TRUE;
		console->flags.bDirect = SACK_GetProfileInt( "SACK/PSI/console", "direct", 0 );
		console->nHistoryPercent = SACK_GetProfileInt( "SACK/PSI/console", "history", 1 );
		{
			char fontdata[256];
			SACK_GetProfileString( "sack/PSI/console", "font", "", fontdata, 256 );
			if( fontdata[0] ) {
				FRACTION one = { 1,1 };
				SetControlFont( pc, RenderScaledFontData( (PFONTDATA)fontdata, &one, &one ) );
			}
		}
		console->psicon.crCommand = AColor( 32, 192, 192, text_alpha );
		console->psicon.crCommandBackground = AColor( 0, 0, 1, back_alpha );
		console->psicon.crBackground = AColor( 0, 0, 1, back_alpha );
		console->psicon.crMark = AColor( 192, 192, 192, text_alpha );
		console->psicon.crMarkBackground = AColor( 67, 116, 150, back_alpha );
   // this is the history backing buffer; the set of lines that make up the raw history.
		console->pHistory = PSI_CreateHistoryRegion();
 // cursor is where output into the history region happens.
		console->pCursor = PSI_CreateHistoryCursor( console->pHistory );
   // this is the history backing buffer; the set of lines that make up the raw history.
		console->pCommandHistory = PSI_CreateHistoryRegion();
		console->pCurrentDisplay = PSI_CreateHistoryBrowser( console->pHistory, PSIMeasureString, (uintptr_t)console );
		console->pHistoryDisplay = PSI_CreateHistoryBrowser( console->pHistory, PSIMeasureString, (uintptr_t)console );
		console->pCommandDisplay = PSI_CreateHistoryBrowser( console->pCommandHistory, PSIMeasureString, (uintptr_t)console );
		PSI_SetHistoryBrowserNoPageBreak( console->pHistoryDisplay );
		console->nXPad = 5;
		console->nYPad = 5;
		console->nCmdLinePad = 2;
		if( !(console->nFontHeight = GetFontHeight( GetCommonFont( pc ) ) ) ) {
			console->nFontHeight = GetStringSizeFont( " ", NULL, NULL, GetCommonFont( pc ) );
		}
		console->nSeparatorHeight = RenderSeparator( console, 0 );
		console->FillConsoleRect = FillConsoleRect;
		console->RenderSeparator = RenderSeparator;
		console->DrawString = DrawString;
		console->KeystrokePaste = PSI_Console_KeystrokePaste;
		console->SetCurrentColor = SetCurrentColor;
		console->RenderCursor = RenderCursor;
		console->Update = ConsoleUpdate;
		return 1;
	}
	return 0;
}
PSI_CONSOLE_NAMESPACE_END
//----------------------------------------------------------------------------
#define KEY_PREFIX "Software\\Freedom Collective\\"
int GetRegistryItem( HKEY hRoot, CTEXTSTR pPrefix,
                     CTEXTSTR pProduct, CTEXTSTR pKey,
                     DWORD dwType,
                     TEXTSTR nResult, int nSize )
{
	TEXTCHAR szString[512];
	if( pProduct )
		snprintf( szString, 512, "%s%s", pPrefix, pProduct );
	else
		snprintf( szString, 512, "%s", pPrefix );
	switch( dwType ) {
	case REG_SZ:
		SACK_GetProfileString( szString, pKey, "", nResult, nSize );
		break;
	case REG_DWORD:
		((int*)nResult)[0] = SACK_GetProfileInt( szString, pKey, ((int*)nResult)[0] );
		break;
	case REG_BINARY:
		{
			TEXTCHAR *data;
			size_t dataLen;
			((int*)nResult)[0] = SACK_GetProfileBlob( szString, pKey, &data, &dataLen );
			memcpy( nResult, data, dataLen );
			Release( data );
			return dataLen;
		}
		break;
	}
	return TRUE;
}
//-----------------------------------------------------------
int GetRegistryInt( CTEXTSTR pProduct, CTEXTSTR pValue,
                    int *nResult )
{
   return GetRegistryItem( HKEY_LOCAL_MACHINE, KEY_PREFIX,
                           pProduct, pValue,
                           REG_DWORD,
                           (TEXTCHAR*)nResult, sizeof(DWORD) );
}
//-----------------------------------------------------------
int GetLocalRegistryInt( CTEXTSTR pProduct, CTEXTSTR pValue,
                         int *nResult )
{
   return GetRegistryItem( HKEY_CURRENT_USER, KEY_PREFIX,
                           pProduct, pValue,
                           REG_DWORD,
                           (TEXTCHAR*)nResult, sizeof(DWORD) );
}
//-----------------------------------------------------------
int GetRegistryString( CTEXTSTR pProduct, CTEXTSTR pValue,
                       TEXTSTR pResult, int nMaxLen )
{
   return GetRegistryItem( HKEY_LOCAL_MACHINE, KEY_PREFIX,
                           pProduct, pValue,
                           REG_SZ,
                           pResult, nMaxLen );
}
//-----------------------------------------------------------
int GetRegistryBinary( CTEXTSTR pProduct, CTEXTSTR pValue,
                       TEXTSTR pResult, int nMaxLen )
{
   return GetRegistryItem( HKEY_LOCAL_MACHINE, KEY_PREFIX,
                           pProduct, pValue,
                           REG_BINARY,
                           pResult, nMaxLen );
}
//-----------------------------------------------------------
int GetLocalRegistryString( CTEXTSTR pProduct, CTEXTSTR pValue,
                            TEXTSTR pResult, int nMaxLen )
{
   return GetRegistryItem( HKEY_CURRENT_USER, KEY_PREFIX,
                           pProduct, pValue,
                           REG_SZ,
                           pResult, nMaxLen );
}
//-----------------------------------------------------------
int GetLocalRegistryBinary( CTEXTSTR pProduct, CTEXTSTR pValue,
                            TEXTSTR pResult, int nMaxLen )
{
   return GetRegistryItem( HKEY_CURRENT_USER, KEY_PREFIX,
                           pProduct, pValue,
                           REG_BINARY,
                           pResult, nMaxLen );
}
//-----------------------------------------------------------
int SetRegistryItem( HKEY hRoot, CTEXTSTR pPrefix,
                     CTEXTSTR pProduct, CTEXTSTR pKey,
                     DWORD dwType,
                     CTEXTSTR pValue, int nSize )
{
	TEXTCHAR szString[512];
	if( pProduct )
		snprintf( szString, 512, "%s%s", pPrefix, pProduct );
	else
		snprintf( szString, 512, "%s", pPrefix );
	switch( dwType ) {
	case REG_DWORD:
		SACK_WriteProfileInt( szString, pKey, ((int*)pValue)[0] );
		break;
	case REG_SZ:
		SACK_WriteProfileString( szString, pKey, pValue );
		break;
	case REG_BINARY:
		SACK_WriteProfileBlob( szString, pKey, (TEXTCHAR*)pValue, nSize );
		break;
	}
	return TRUE;
}
//-----------------------------------------------------------
int SetRegistryInt( CTEXTSTR pProduct, CTEXTSTR pValue,
                    int nValue )
{
   return SetRegistryItem( HKEY_LOCAL_MACHINE, KEY_PREFIX,
                           pProduct, pValue,
                           REG_DWORD,
                           (TEXTCHAR*)&nValue, sizeof(int) );
}
//-----------------------------------------------------------
int SetLocalRegistryInt( CTEXTSTR pProduct, CTEXTSTR pValue,
                         int nValue )
{
   return SetRegistryItem( HKEY_CURRENT_USER, KEY_PREFIX,
                           pProduct, pValue,
                           REG_DWORD,
                           (TEXTCHAR*)&nValue, sizeof(int) );
}
//-----------------------------------------------------------
int SetRegistryString( CTEXTSTR pProduct, CTEXTSTR pKey,
                       CTEXTSTR pValue )
{
   return SetRegistryItem( HKEY_LOCAL_MACHINE, KEY_PREFIX,
                           pProduct, pKey,
                           REG_SZ,
                           pValue, StrLen( pValue ) );
}
//-----------------------------------------------------------
int SetRegistryBinary( CTEXTSTR pProduct, CTEXTSTR pKey,
                       CTEXTSTR pValue, int nLen )
{
   return SetRegistryItem( HKEY_LOCAL_MACHINE, KEY_PREFIX,
                           pProduct, pKey,
                           REG_BINARY,
                           pValue, nLen );
}
//-----------------------------------------------------------
int SetLocalRegistryString( CTEXTSTR pProduct, CTEXTSTR pKey,
                            CTEXTSTR pValue )
{
   return SetRegistryItem( HKEY_CURRENT_USER, KEY_PREFIX,
                           pProduct, pKey,
                           REG_SZ,
                           pValue, StrLen( pValue ) );
}
//-----------------------------------------------------------
int SetLocalRegistryBinary( CTEXTSTR pProduct, CTEXTSTR pKey,
                            CTEXTSTR pValue, int nLen )
{
   return SetRegistryItem( HKEY_CURRENT_USER, KEY_PREFIX,
                           pProduct, pKey,
                           REG_BINARY,
                           pValue, nLen );
}
//#define NO_LOGGING
//#define DEBUG_HISTORY_RENDER
//#include "interface.h"
#define WINLOGIC_SOURCE
PSI_CONSOLE_NAMESPACE
//----------------------------------------------------------------------------
static void AddUpdateRegion( PPENDING_RECT update_rect, int32_t x, int32_t y, uint32_t wd, uint32_t ht )
{
#ifdef __LINUX__
	if( !update_rect->flags.bTmpRect )
	{
		if( !update_rect->flags.bHasContent )
			MemSet( &update_rect->cs, 0, sizeof( update_rect->cs ) );
		EnterCriticalSec( &update_rect->cs );
	}
#endif
	if( wd && ht )
	{
		if( update_rect->flags.bHasContent )
		{
			if( x < update_rect->x )
			{
				update_rect->width += update_rect->x - x;
				update_rect->x = x;
			}
			if( x + wd > update_rect->x + update_rect->width )
				update_rect->width = (wd + x) - update_rect->x;
			if( y < update_rect->y )
			{
				update_rect->height += update_rect->y - y;
				update_rect->y = y;
			}
			if( y + ht > update_rect->y + update_rect->height )
				update_rect->height = (y + ht) - update_rect->y;
			//lprintf( "result (%d,%d)-(%d,%d)"
			//		, update_rect->x, update_rect->y
			//		, update_rect->width, update_rect->height
			//	  );
		}
		else
		{
			//_lprintf( DBG_AVAILABLE, "Setting (%d,%d)-(%d,%d)" DBG_RELAY
			//		, x, y
			//		, wd, ht
			//		);
			update_rect->x = x;
			update_rect->y = y;
			update_rect->width = wd;
			update_rect->height = ht;
		}
		update_rect->flags.bHasContent = 1;
	}
#ifdef __LINUX__
	if( !update_rect->flags.bTmpRect ) {
		LeaveCriticalSec( &update_rect->cs );
	}
#endif
}
static void RenderTextLine(
	PCONSOLE_INFO pdp
	, PDISPLAYED_LINE pCurrentLine
	, RECT *r
	, int nLine
	, int nFirst
	, int nFirstLine
	, int nMinLine
	, LOGICAL mark_applies
	, LOGICAL allow_segment_coloring
	, int leadinOffset
	, int nBottomOffset
	, int bClearEnd
						)
{
	// left and right are relative... to the line segment only...
	// for the reason of color changes inbetween segments...
	{
		int justify = 0;
		int x, y;
		int nChar;
		PTEXT pText;
		int nShow, nShown;
#ifdef DEBUG_HISTORY_RENDER
		lprintf( "Rect is %d-%d   %d-%d", r->left, r->right, r->top, r->bottom );
		lprintf( "Get display line %d", nLine );
#endif
		if( !pCurrentLine )
		{
#ifdef DEBUG_HISTORY_RENDER
			lprintf( "No such line... %d", nLine );
#endif
			return;
		}
		(*r).top = pCurrentLine->nLineTop - nBottomOffset;
		if( nFirst >= 0 )
			(*r).bottom = (*r).top + pCurrentLine->nLineHeight + 2;
		else
			(*r).bottom = (*r).top + pCurrentLine->nLineHeight;
		if( (*r).bottom <= nMinLine )
		{
#ifdef DEBUG_HISTORY_RENDER
			lprintf( "bottom < minline.." );
#endif
			return;
		}
		y = (*r).top;
#ifdef DEBUG_HISTORY_RENDER
		lprintf( "Y STARTS AT %d", y );
#endif
		if( !pCurrentLine->nPixelStart ) {
			r->left = 0;
			r->right = pdp->nXPad;
			//lprintf( "Rect is %d-%d   %d-%d", r->left, r->right, r->top, r->bottom );
			if( pdp->FillConsoleRect )
				pdp->FillConsoleRect(pdp, r, FILL_DISPLAY_BACK );
		}
		else {
			r->right = pdp->nXPad;
		}
		x = (*r).left = r->right + pCurrentLine->nPixelStart;
		(*r).right = (*r).left;
		//(*r).left = x;
		nChar = 0;
		pText = pCurrentLine->start;
		if( pText && ( pText->flags & TF_FORMATEX ) )
		{
			if( pText->format.flags.format_op == FORMAT_OP_JUSTIFY_RIGHT )
			{
				justify = 1;
			}
		}
		//lprintf( "Rect is %d-%d   %d-%d", r->left, r->right, r->top, r->bottom );
		if( allow_segment_coloring )
			if( pdp->SetCurrentColor )
				pdp->SetCurrentColor( pdp, COLOR_DEFAULT, NULL );
		nShown = (int)pCurrentLine->nFirstSegOfs;
#ifdef DEBUG_HISTORY_RENDER
		if( !pText )
			lprintf( "Okay no text to show... end up filling line blank." );
#endif
		while( pText )
		{
			size_t nLen;
			TEXTCHAR *text = GetText( pText );
#ifdef __DEKWARE_PLUGIN__
			if( !pdp->flags.bDirect && ( pText->flags & TF_PROMPT ) )
			{
				lprintf( "Segment is promtp - and we need to skip it." );
				pText = NEXTLINE( pText );
				continue;
			}
#endif
			if( allow_segment_coloring )
				if( pdp->SetCurrentColor )
					pdp->SetCurrentColor( pdp, COLOR_SEGMENT, pText );
			nLen = GetTextSize( pText );
#ifdef DEBUG_HISTORY_RENDER
			lprintf( "start: %d  len: %d", nShown, nLen );
#endif
			while( nShown < nLen )
			{
#ifdef DEBUG_HISTORY_RENDER
				lprintf( "nShown < nLen... char %d len %d toshow %d", nChar, nLen, pCurrentLine->nToShow );
#endif
				if( USS_GT( nLen, size_t, pCurrentLine->nToShow- nChar, int ) )
					nShow = (int)(pCurrentLine->nToShow - nChar);
				else
				{
#ifdef DEBUG_HISTORY_RENDER
					lprintf( "nShow is what's left of now to nLen from nShown... %d,%d", nLen, nShown );
#endif
					nShow = (int)(nLen - nShown);
				}
				if( !nShow )
				{
					//lprintf( "nothing to show..." );
					break;
				}
				if( pdp->flags.bMarking &&
					mark_applies )
				{
					if( !pdp->flags.bMarkingBlock )
					{
						if( ( nLine ) > pdp->mark_start.row
						 ||( nLine ) < pdp->mark_end.row )
						{
							// line above or below the marked area...
							if( allow_segment_coloring )
								if( pdp->SetCurrentColor )
									pdp->SetCurrentColor( pdp, COLOR_SEGMENT, pText );
							//SetCurrentColor( crThisText, crThisBack );
						}
						else
						{
							if( pdp->mark_start.row == pdp->mark_end.row )
							{
								if( nChar >= pdp->mark_start.col &&
									nChar < pdp->mark_end.col )
								{
									if( nChar + nShow > pdp->mark_end.col )
										nShow = (int)(pdp->mark_end.col - nChar);
									if( allow_segment_coloring )
										if( pdp->SetCurrentColor )
											pdp->SetCurrentColor( pdp, COLOR_MARK, pText );
									//SetCurrentColor( pdp->crMark
									//				  , pdp->crMarkBackground );
								}
								else if( nChar >= pdp->mark_end.col )
								{
									if( allow_segment_coloring )
										if( pdp->SetCurrentColor )
											pdp->SetCurrentColor( pdp, COLOR_SEGMENT, pText );
									//SetCurrentColor( crThisText, crThisBack );
								}
								else if( nChar + nShow > pdp->mark_start.col )
								{
									nShow = (int)(pdp->mark_start.col - nChar);
								}
							}
							else
							{
								if( nLine == pdp->mark_start.row )
								{
									if( nChar >= pdp->mark_start.col )
									{
										if( allow_segment_coloring )
											if( pdp->SetCurrentColor )
												pdp->SetCurrentColor( pdp, COLOR_MARK, pText );
										//SetCurrentColor( pdp->crMark
										//					, pdp->crMarkBackground );
									}
									else if( nChar + nShow > pdp->mark_start.col )
									{
										// current segment up to the next part...
										nShow = (int)(pdp->mark_start.col - nChar);
									}
								}
								if( ( nLine ) < pdp->mark_start.row
								 &&( nLine ) > pdp->mark_end.row )
								{
									if( allow_segment_coloring )
										if( pdp->SetCurrentColor )
											pdp->SetCurrentColor( pdp, COLOR_MARK, pText );
									//SetCurrentColor( pdp->crMark
									//					, pdp->crMarkBackground );
								}
								if( ( nLine ) == pdp->mark_end.row )
								{
									if( nChar >= pdp->mark_end.col )
									{
										if( allow_segment_coloring )
											if( pdp->SetCurrentColor )
												pdp->SetCurrentColor( pdp, COLOR_SEGMENT, pText );
										//SetCurrentColor( crThisText, crThisBack );
									}
									else if( nChar + nShow > pdp->mark_end.col )
									{
										nShow = pdp->mark_end.col - nChar;
										if( allow_segment_coloring )
											if( pdp->SetCurrentColor )
												pdp->SetCurrentColor( pdp, COLOR_MARK, pText );
										//SetCurrentColor( pdp->crMark
										//					, pdp->crMarkBackground );
									}
									else if( nChar < pdp->mark_end.col )
									{
										if( allow_segment_coloring )
											if( pdp->SetCurrentColor )
												pdp->SetCurrentColor( pdp, COLOR_MARK, pText );
										//SetCurrentColor( pdp->crMark
										//					, pdp->crMarkBackground );
									}
								}
							}
						}
					}
				}
				//lprintf( "Rect is %d-%d   %d-%d", r->left, r->right, r->top, r->bottom );
				//lprintf( "Some stats %d %d %d", nChar, nShow, nShown );
				if( nChar )
				{
					// not first character on line...
					x = (*r).left = (*r).right;
				}
				else {
					if( !(*r).right ) {
						if( justify == 1 ) {
							x = (*r).right = (pdp->nWidth - (pdp->nXPad + pCurrentLine->nPixelEnd)) + (*r).left;
						}
						else if( justify == 2 ) {
							x = (*r).right = ((pdp->nWidth - pCurrentLine->nPixelEnd) / 2) + (*r).left;
						}
						else if( !(*r).left )
							(*r).right = (*r).left + pdp->nXPad;
						else
							(*r).right = (*r).left;
						if( r->right != r->left )
							if( pdp->FillConsoleRect )
								pdp->FillConsoleRect( pdp, r, FILL_DISPLAY_BACK );
					}
				}
				//(*r).right = pdp->nXPad + pCurrentLine->nPixelEnd;
				(*r).right = (*r).left + pCurrentLine->nPixelEnd;
				if( (*r).bottom > nMinLine )
				{
					uint32_t nSegSize, nSegHeight;
#ifdef DEBUG_HISTORY_RENDER
					lprintf( "And finally we can show some text... %s %d", text, y );
#endif
					(*r).left = x;
#ifdef DEBUG_HISTORY_RENDER
					lprintf( "putting string %s at %d,%d (left-right) %d,%d", text, x, y, (*r).left, (*r).right );
#endif
					if( pdp->pHistoryDisplay->measureString )
						pdp->pHistoryDisplay->measureString( pdp->pHistoryDisplay->psvMeasure, GetText( pText ) + nShown
							, nShow, &nSegSize, &nSegHeight, GetCommonFont( pdp->psicon.frame ) );
					(*r).right = (*r).left + nSegSize;
					if( pdp->DrawString )
						//pdp->DrawString( pdp, x, y, r, text, nShown, nShow );
						pdp->DrawString( pdp, (*r).left, y, r, text, nShown, nShow );
					(*r).left = (*r).right;
  // only keep the (last) line's end.
					if( nLine == 0 )
						pdp->nNextCharacterBegin = (*r).right;
					//DrawString( text );
					//lprintf( "putting string %s at %d,%d (left-right) %d,%d", text, x, y, (*r).left, (*r).right );
				}
#ifdef DEBUG_HISTORY_RENDER
				else
					lprintf( "Hmm bottom < minline?" );
#endif
				// fill to the end of the line...
				//nLen -= nShow;
				nShown += nShow;
				nChar += nShow;
			}
#ifdef DEBUG_HISTORY_RENDER
			lprintf( "nShown >= nLen..." );
#endif
			nShown -= (int)nLen;
			pText = NEXTLINE( pText );
		}
		{
			x = (*r).left = (*r).right;
			(*r).right = pdp->nWidth;
			// if soething left to fill, blank fill it...
			if( (*r).left < (*r).right )
			{
#ifdef DEBUG_HISTORY_RENDER
				lprintf( "Fill empty to right (%d-%d)  (%d-%d)", (*r).left, (*r).right, (*r).top, (*r).bottom );
#endif
				if( nLine || bClearEnd )
					if( pdp->FillConsoleRect )
						pdp->FillConsoleRect( pdp, r, FILL_DISPLAY_BACK );
				//FillConsoleRect();
			}
		}
		if( nFirst >= 0 )
			nFirst = -1;
		nLine++;
	}
	//lprintf( "(*(*r)...bottom nMin %d %d", (*r)..bottom, nMinLine );
	if( (*r).bottom > nMinLine )
	{
		(*r).bottom = (*r).top;
		(*r).top = nMinLine;
		(*r).left = 0;
		(*r).right = pdp->nWidth;
#ifndef PSI_LIB
		//lprintf( "Would be blanking the screen here, but no, there's no reason to." );
				 //FillEmptyScreen();
#endif
	}
}
void PSI_RenderCommandLine( PCONSOLE_INFO pdp, PENDING_RECT *region )
{
	PENDING_RECT myrect;
	// need to render the current macro being recorded.....
	RECT upd;
	SFTFont font = GetCommonFont( pdp->psicon.frame );
	RECT r;
	int nMaxLen, nShow, nCurrentCol, x, y, nCursorPos;
	int nCursorIdx;
	int lines;
	int nLeadinoffset;
	int line_offset;
	int nShown;
	int start, end;
	int toppad = 0;
	PTEXT pStart;
	// no command line...
	if( !pdp->CommandInfo )
	{
		// region->bHasContent = 0?
		return;
	}
#ifdef DEBUG_HISTORY_RENDER
	lprintf( "Begin render command line" );
#endif
	if( !region )
	{
		region = &myrect;
		myrect.flags.bHasContent = 0;
		myrect.flags.bTmpRect = 1;
	}
	if( pdp->SetCurrentColor )
//pdp->crCommand, pdp->crCommandBackground );
		pdp->SetCurrentColor( pdp, COLOR_COMMAND, NULL );
	nCursorIdx = GetCommandCursor( pdp->pCurrentDisplay, font
											, pdp->CommandInfo
											, pdp->flags.bDirect
											, pdp->flags.bWrapCommand
											, &nCurrentCol
											, &start
											, &end
											, &nLeadinoffset
											, &nCursorPos
											, &line_offset);
	// nYpad at bottom of screen, font height up begins the top of the
	// output text line...
	// also line starts are considered from the bottom up...
	// nXPad,n__LineStart
 //****** THIS PROBABLY NEEDS AN OFFSET ********/
	r.top = y = pdp->nCommandLineStart - pdp->nFontHeight;
	r.bottom = pdp->nHeight;
	if( !pdp->flags.bDirect )
		toppad = pdp->nCmdLinePad;
	r.top -= toppad;
/*
	lprintf( "*** Commandline %d,%d  uhh %d %d  %d and %d"
			, r.top, r.bottom
			, start, end
			, nCursorPos
			 , nCurrentCol
			 );
			 */
	if( !nCurrentCol && !nLeadinoffset )
	{
		// need to blatcolor for the 5 pixels left of first char...
		r.left = 0;
		r.right = 0;
		/*
		if( pdp->FillConsoleRect )
		{
			lprintf( "draw blank to left %d-%d   %d-%d", r.left, r.right, r.top, r.bottom );
			pdp->FillConsoleRect( pdp, &r, FILL_COMMAND_BACK );
		}
		*/
		upd.left = 0;
	}
	else
	{
		if( pdp->flags.bDirect )
			r.right = nLeadinoffset;
		else
			r.right = pdp->nXPad;
	}
	//r.left = x = pdp->nXPad + ( nCurrentCol * pdp->nFontWidth );
	r.left = x = r.right;
	//lprintf( "x/left is %d", x );
	// for now...
	upd.left = x;
	upd.right = pdp->nWidth;
	upd.top = pdp->nDisplayLineStartDynamic - pdp->nFontHeight;
	upd.bottom = r.bottom;
	{
		// totally set the background of the command thingy...
		// previously the putstring would have done the rect fill...
		// but now we need to just put text data over a solid backgorund...
		r.right = pdp->nWidth;
		r.top -= toppad;
		if( pdp->FillConsoleRect )
			pdp->FillConsoleRect( pdp, &r, FILL_COMMAND_BACK );
		r.top += toppad;
	}
	// the normal prompt string will have the current
	// macroname being recorded... do not show this in
	// direct mode.....
	nMaxLen = end - start;
	nShown = start;
	pStart = pdp->CommandInfo->CollectionBuffer;
	SetStart( pStart );
	if( pdp->flags.bWrapCommand )
	{
		int skip_lines;
		PDISPLAYED_LINE pdlCommand;
		skip_lines = 0;
		lines = CountDisplayedLines( pdp->pCommandDisplay );
		if( !lines )
			lines = 1;
		if( lines > 1 )
			upd.left = 0;
#ifdef DEBUG_OUTPUT
		lprintf( "want to do this in %d lines", lines );
#endif
		if( lines > 3 )
		{
			skip_lines = lines - 3;
			lines = 3;
		}
		if( pdp->flags.bDirect )
		{
			// should already be set from last doStroke
			//pdp->nDisplayLineStartDynamic = ((PDISPLAYED_LINE)GetDataItem( &pdp->pCommandDisplay->DisplayLineInfo
			//	, pdp->pCommandDisplay->DisplayLineInfo->Cnt - 1 ))->nLineTop;
		}
		else
		{
			pdlCommand = (PDISPLAYED_LINE)GetDataItem( GetDisplayInfo( pdp->pCommandDisplay ), lines-1 );
			//lprintf( "Input parameters to setting line %d %d %d %d", pdp->nCommandLineStart, pdlCommand->nLineTop, pdp->nYPad, pdp->nCmdLinePad );
			pdp->nDisplayLineStartDynamic = pdlCommand->nLineTop - (
 // one at bottom, one above separator
					+ ( pdp->nYPad )
  // extraa width around command line
					+ ( pdp->nCmdLinePad / 2)
					 ) ;
			//lprintf( "(direct write command line)Setting display line to %d", pdp->nDisplayLineStartDynamic );
		}
		AddUpdateRegion( region, upd.left, upd.top, upd.right-upd.left,upd.bottom-upd.top );
		{
			int nLine;
			DISPLAYED_LINE *pCurrentLine;
			PDATALIST *ppCurrentLineInfo;
			ppCurrentLineInfo = GetDisplayInfo( pdp->pCommandDisplay );
			for( nLine = 0; nLine < 3; nLine ++ )
			{
				pCurrentLine = (PDISPLAYED_LINE)GetDataItem( ppCurrentLineInfo, nLine );
				if( !pCurrentLine )
				{
		#ifdef DEBUG_HISTORY_RENDER
					lprintf( "No such line... %d", nLine );
		#endif
					break;
				}
#ifdef DEBUG_HISTORY_RENDER
				lprintf( "Something else %d %d", pdp->nCommandLineStart, pCurrentLine->nLineTop );
#endif
				if( pCurrentLine->start )
					RenderTextLine( pdp, pCurrentLine, &upd
						, nLine, TRUE, y, pdp->nCommandLineStart - pCurrentLine->nLineTop
						, FALSE
  // cursor; to know where to draw the mark...
						, FALSE, nLeadinoffset, 0, 1 );
				y -= pdp->nFontHeight;
				nLeadinoffset = 0;
			}
		}
		if( pdp->RenderCursor )
			// rect has top/bottom info, and current cursor position column
			// is passed - each client will be able to
 // top/bottom are the line...
			pdp->RenderCursor( pdp, &r, ( nCursorPos ) );
	}
	else
	{
		if( pdp->flags.bDirect ) {
			y -= pdp->pCommandDisplay->nLineHeight;
			r.top = y;
		}
		while( pStart && SUS_GT( nShown, int, GetTextSize( pStart ), size_t ) )
		{
			nShown -= (int)GetTextSize( pStart );
			pStart = NEXTLINE( pStart );
		}
		while( pStart && nCurrentCol < nCursorIdx )
		{
			nShow = (int)GetTextSize( pStart ) - nShown;
			if( nCurrentCol + nShow > end )
				nShow = end - nCurrentCol;
			if( pdp->DrawString ) {
				uint32_t width, height;
#ifdef DEBUG_HISTORY_RENDER
				lprintf( "(2)putting string %s at %d,%d (left-right) %d,%d", GetText( pStart ), x, y, (r).left, (r).right );
#endif
				pdp->DrawString( pdp, x, y, &r, GetText( pStart ), nShown, nShow );
				pdp->pCommandDisplay->measureString( pdp->pCommandDisplay->psvMeasure
					, GetText( pStart ) + nShown, nShow
					, &width, &height, font );
				x += width;
			}
			r.left = x;
			//x = r.left = r.right;
			nShown = 0;
			nCurrentCol += nShow;
			pStart = NEXTLINE( pStart );
		}
		//if( pStart )
		//	lprintf( "Stopped because of length." );
		r.left = r.right;
		r.right = pdp->nWidth;
		// only have to clean trail if on a direct input method...
		if( r.right > r.left )
		{
			// clear the remainder of the line...
#ifdef DEBUG_HISTORY_RENDER
			lprintf( "Clearing end of line... %d-%d   %d-%d", r.left, r.right, r.top, r.bottom );
#endif
			if( pdp->FillConsoleRect )
				pdp->FillConsoleRect( pdp, &r, FILL_DISPLAY_BACK );
		}
		if( pdp->RenderCursor )
			// rect has top/bottom info, and current cursor position column
			// is passed - each client will be able to
 // top/bottom are the line...
			pdp->RenderCursor( pdp, &r, ( nCursorPos ) );
		// command line only update ? maybe add this to regions which should be updated?
		// refresh here?
		AddUpdateRegion( region, upd.left, upd.top, upd.right-upd.left,upd.bottom-upd.top );
	}
#ifdef DEBUG_HISTORY_RENDER
	lprintf( "done render command line" );
#endif
}
//----------------------------------------------------------------------------
// 5 on left, 5 on right total 10 pixels we can't use...
void WinLogicCalculateHistory( PCONSOLE_INFO pdp, SFTFont font )
{
	// there's some other related set of values to set here....
	//lprintf( "Calculate history! %d %d", pdp->nColumns, pdp->nLines );
	if( !pdp->nFontHeight )
		return;
	SetCursorHeight( pdp->pCursor, pdp->nHeight - pdp->nYPad*2 );
	SetCursorWidth( pdp->pCursor, pdp->nWidth - pdp->nXPad * 2 );
	if( pdp->pHistoryDisplay )
		SetBrowserWidth( pdp->pHistoryDisplay, pdp->nWidth - pdp->nXPad*2 );
	SetBrowserWidth( pdp->pCurrentDisplay, pdp->nWidth - pdp->nXPad*2 );
	SetBrowserHeight( pdp->pCurrentDisplay, pdp->nHeight );
	pdp->pCurrentDisplay->nLineHeight = pdp->nFontHeight;
	if( pdp->pHistoryDisplay )
		pdp->pHistoryDisplay->nLineHeight = pdp->nFontHeight;
	if( pdp->pCommandDisplay )
		pdp->pCommandDisplay->nLineHeight = pdp->nFontHeight;
	//lprintf( "Don't forget we wanted to inset command for a button..." );
	if( pdp->pCommandDisplay )
		SetBrowserWidth( pdp->pCommandDisplay, pdp->nWidth - pdp->nXPad*2 );
	if( pdp->flags.bHistoryShow )
	{
		//lprintf( "Doing history... check percent and set display/history approp." );
		switch( pdp->nHistoryPercent )
		{
  // 25
		case 0:
 //50
		case 1:
 //75
		case 2:
			{
				if( pdp->pHistoryDisplay )
				{
					int nWorkLines;
					int displayHeight;
					nWorkLines = ( pdp->nHeight / pdp->nFontHeight ) * ( 3 - pdp->nHistoryPercent ) / 4;
					displayHeight = pdp->nYPad * 2 + nWorkLines * pdp->nFontHeight;
					SetBrowserHeight( pdp->pCurrentDisplay, displayHeight );
					SetBrowserHeight( pdp->pHistoryDisplay, pdp->nHeight - displayHeight );
					PSI_SetHistoryPageLines( pdp->pHistoryDisplay, (pdp->nLines - nWorkLines)-3 );
					pdp->nHistoryLineStart = pdp->nDisplayLineStartDynamic - ( pdp->nHeight * ( 3 - pdp->nHistoryPercent ) ) / 4;
				}
			}
			break;
 //100
		case 3:
			if( pdp->pHistoryDisplay )
			{
				pdp->nHistoryLineStart = pdp->nDisplayLineStartDynamic;
				SetBrowserHeight( pdp->pHistoryDisplay, pdp->nHeight );
				// need this to know how far close to end we can get...
				SetBrowserHeight( pdp->pCurrentDisplay, 0 );
				PSI_SetHistoryPageLines( pdp->pHistoryDisplay, pdp->nLines );
				//pdp->nHistoryLines = nLines;
				//pdp->nDisplayLines = 0;
			}
		}
	}
	else
	{
		pdp->nHistoryLineStart = 0;
		if( pdp->pHistoryDisplay )
		{
			//lprintf( "No history, all display" );
			// internally we'll need this amount to get into
			// scrollback...
			{
				int nWorkLines;
				nWorkLines = ( pdp->nLines * ( 1 + pdp->nHistoryPercent ) ) / 4;
				PSI_SetHistoryPageLines( pdp->pHistoryDisplay, nWorkLines - 3 );
			}
			PSI_SetHistoryPageLines( pdp->pHistoryDisplay, pdp->nHeight/pdp->nFontHeight - 4 );
			SetBrowserHeight( pdp->pHistoryDisplay, 0 );
			ResetHistoryBrowser( pdp->pHistoryDisplay );
			// 1 for the partial line at the top of the display.
		}
		SetBrowserHeight( pdp->pCurrentDisplay, pdp->nHeight );
	}
//#endif
	if( pdp->pHistoryDisplay ) {
		SetBrowserFirstLine( pdp->pHistoryDisplay, pdp->nHistoryLineStart );
		pdp->pHistoryDisplay->flags.bUpdated = 1;
		BuildDisplayInfoLines( pdp->pHistoryDisplay, NULL, font );
	}
	SetBrowserFirstLine( pdp->pCurrentDisplay, pdp->nDisplayLineStartDynamic );
	pdp->pCurrentDisplay->flags.bUpdated = 1;
	BuildDisplayInfoLines( pdp->pCurrentDisplay, NULL, font );
	if( pdp->pCommandDisplay ) {
#ifdef DEBUG_HISTORY_RENDER
		lprintf( "ncommand line start: %d", pdp->nCommandLineStart );
#endif
		SetBrowserFirstLine( pdp->pCommandDisplay, pdp->nCommandLineStart );
		pdp->pCommandDisplay->flags.bUpdated = 1;
		BuildDisplayInfoLines( pdp->pCommandDisplay, pdp->flags.bDirect ? pdp->pCurrentDisplay : NULL, font );
	}
}
//----------------------------------------------------------------------------
void DoRenderHistory( PCONSOLE_INFO pdp, int bHistoryStart, int nBottomLineOffset, int nStartLineOffset, PENDING_RECT *region );
void PSI_RenderConsole( PCONSOLE_INFO pdp, SFTFont font )
{
	PENDING_RECT upd;
	upd.flags.bHasContent = 0;
	upd.flags.bTmpRect = 1;
	MemSet( &upd.cs, 0, sizeof( upd.cs ) );
	EnterCriticalSec( &pdp->Lock );
	pdp->lockCount++;
	/*
	lprintf( "Render Console... %d  %d %d  %d"
			, pdp->nDisplayLineStartDynamic, pdp->nCommandLineStart
		, pdp->nHistoryLineStart, pdp->nHeight );
	*/
#ifdef DEBUG_HISTORY_RENDER
	lprintf( "Render Console... %d %d", pdp->nDisplayLineStartDynamic, pdp->nHistoryLineStart );
#endif
	if( pdp->RenderSeparator )
	{
		if( !pdp->flags.bDirect && pdp->nDisplayLineStartDynamic != pdp->nCommandLineStart )
			pdp->nSeparatorHeight = pdp->RenderSeparator( pdp, pdp->nDisplayLineStartDynamic );
		//lprintf( "Render AGAIN the hsitory line separator" );
		if( pdp->nHistoryLineStart && pdp->nHistoryLineStart != pdp->nDisplayLineStartDynamic )
			pdp->nSeparatorHeight = pdp->RenderSeparator( pdp, pdp->nHistoryLineStart );
	}
	if( !pdp->flags.bDirect )
		PSI_RenderCommandLine( pdp, &upd );
	SetBrowserFirstLine( pdp->pCurrentDisplay, pdp->nDisplayLineStartDynamic );
	BuildDisplayInfoLines( pdp->pCurrentDisplay, NULL, font );
	if( pdp->pCommandDisplay ) {
		//if( (pdp->flags.bDirect && !pdp->flags.bCharMode) ) {
		//	BuildDisplayInfoLines( pdp->pCommandDisplay, pdp->pCurrentDisplay, font );
		//}
		PSI_RenderCommandLine( pdp, &upd );
	}
	// if direct rendering, command line doesn't change, so it doesn't need to be redrawn here.
	// if history is showing, first line is below the top (> 0 )
	if( pdp->nHistoryLineStart )
	{
		DoRenderHistory( pdp, TRUE, 0, 0, &upd );
	}
	// if there's a section of display left to render between history and command
	if( pdp->nDisplayLineStartDynamic != pdp->nHistoryLineStart )
	{
		DoRenderHistory( pdp, FALSE, pdp->nCommandLineStart - pdp->nDisplayLineStartDynamic, 0, &upd );
	}
	if( pdp->Update && upd.flags.bHasContent )
	{
		RECT r;
		r.left = upd.x;
		r.right = upd.x + upd.width;
		r.top = upd.y;
		r.bottom = upd.y + upd.height;
		pdp->Update( pdp, &r );
	}
	pdp->lockCount--;
	LeaveCriticalSec( &pdp->Lock );
}
//----------------------------------------------------------------------------
// called for initialization, but any time some size on the display changes (history height
// or window size.
void PSI_ConsoleCalculate( PCONSOLE_INFO pdp, SFTFont font )
{
	//RECT rArea;
	//lprintf( "*** DISPLAY is %d,%d by %d,%d", pdp->rArea.top, pdp->rArea.left, pdp->rArea.right, pdp->rArea.bottom );
	if( ( ( pdp->rArea.right -  pdp->rArea.left )== 0 )
		&& ( ( pdp->rArea.bottom -  pdp->rArea.top )== 0 ) )
		return;
	if ( (pdp->rArea.right - pdp->rArea.left) <= 0 ||
			(pdp->rArea.bottom - pdp->rArea.top ) <= 0 )
	{
		// not enough size to display anything.... disable display
		 pdp->flags.bNoDisplay = 1;
	}
	else
		 pdp->flags.bNoDisplay = 0;
	pdp->nWidth = pdp->rArea.right - pdp->rArea.left;
	pdp->nHeight = pdp->rArea.bottom - pdp->rArea.top;
	if( pdp->nWidth &0x80000000 || pdp->nHeight &0x80000000 )
	{
		pdp->nWidth = 0;
		pdp->nHeight = 0;
	}
#ifdef DEBUG_HISTORY_RENDER
	lprintf( "-------- set command line to area : %d", pdp->rArea.bottom );
#endif
	pdp->nCommandLineStart = pdp->rArea.bottom;
	//lprintf( "Okay font height existsts... that's good" );
	if( pdp->flags.bDirect )
	{
		SetCursorNoPrompt( pdp->pCurrentDisplay, FALSE );
		if( pdp->pHistoryDisplay )
			SetCursorNoPrompt( pdp->pHistoryDisplay, FALSE );
		pdp->nCommandLineStart -= pdp->nYPad;
#ifdef DEBUG_HISTORY_RENDER
		lprintf( "(direct)Setting display line to %d", pdp->nCommandLineStart );
#endif
		pdp->nDisplayLineStartDynamic = pdp->nCommandLineStart;
	}
	else
	{
		SetCursorNoPrompt( pdp->pCurrentDisplay, TRUE );
		if( pdp->pHistoryDisplay )
			SetCursorNoPrompt( pdp->pHistoryDisplay, FALSE );
		pdp->nCommandLineStart -= pdp->nYPad + pdp->nCmdLinePad / 2;
		pdp->nDisplayLineStartDynamic = pdp->nCommandLineStart - (pdp->nYPad + ( pdp->nCmdLinePad / 2 ) + pdp->nSeparatorHeight );
#ifdef DEBUG_HISTORY_RENDER
		lprintf( "(linemode)Setting display line to %d", pdp->nDisplayLineStartDynamic );
#endif
	}
	WinLogicCalculateHistory( pdp, font );
	PSI_RenderConsole( pdp, font );
}
//----------------------------------------------------------------------------
// this does assume that special formatting text packets are spoon-fed to it.
PSI_Console_Phrase PSI_WinLogicWriteEx( PCONSOLE_INFO pmdp
						, PTEXT pLine
						, int update
						)
{
	PSI_Console_Phrase result = NULL;
	EnterCriticalSec( &pmdp->Lock );
	pmdp->lockCount++;
	{
		//int flags = pLine->flags & (TF_NORETURN|TF_PROMPT);
		//lprintf( "Updated... %d", updated );
		//updated++;
		if( pLine->flags & TF_FORMATABS )
		{
			int32_t cursorx, cursory;
			//lprintf( "absolute position format." );
			GetHistoryCursorPos( pmdp->pCursor, &cursorx, &cursory );
			if( pLine->format.position.coords.x != -16384 )
				cursorx = pLine->format.position.coords.x;
			if( pLine->format.position.coords.y != -16384 )
 /*pmdp->nLines*/
				cursory = - pLine->format.position.coords.y;
			SetHistoryCursorPos( pmdp->pCursor, cursorx, cursory );
			pLine->format.position.offset.spaces = 0;
			pLine->format.position.offset.tabs = 0;
			pLine->flags &= ~TF_FORMATABS;
		}
		if( pLine->flags & TF_FORMATREL )
		{
			int32_t cursorx, cursory;
			//lprintf( "relative position format" );
			GetHistoryCursorPos( pmdp->pCursor, &cursorx, &cursory );
			cursorx += pLine->format.position.coords.x;
			cursory += pLine->format.position.coords.y;
			SetHistoryCursorPos( pmdp->pCursor, cursorx, cursory );
			pLine->format.position.offset.spaces = 0;
			pLine->format.position.offset.tabs = 0;
			pLine->flags &= ~TF_FORMATREL;
			// this should not leave the current region....
		}
#ifdef COMMAND_LINE_ENTRY_EXTRA_NEWLINE_STUFF
		if( !( pLine->flags & TF_NORETURN ) ||
			( pLine->flags & TF_FORMATREL ) ||
			( phc->region->flags.bForceNewline ) )
 // err new segment goes on a new line.  (even if we are in the past)
		{
			//Log2( "Line is automatically promoting itself to the next line. %d %d"
			//  , pht->nCursorY, pht->pTrailer?pht->pTrailer->nLinesUsed:-1 );
			if( !( pLine->flags & TF_NORETURN ) || phc->region->flags.bForceNewline )
				(phc->nCursorY)++;
		}
		if( !( pLine->flags & TF_NORETURN ) || phc->region->flags.bForceNewline )
			(phc->nCursorX) = 0;
		pLine->flags &= ~TF_FORMATREL;
		phc->region->flags.bForceNewline = FALSE;
#endif
		// at the point, history will use the current
		// cursorx, cursory and output the line, if TF_NORETURN
		// otherwise it will reset cursorx and insert one line to history.
		// unless no line insert, then the next line will be overwritten, and one blank line added to end
		// to keep cursorY bias from end of screen the same?
		// if CursorY == 0 (last line) then one line is added, else cursor Y is adjusted... that's it.
		// history will also respect some of the format_ops... actually the display history
		// is this layer inbetween history and display that handles much of the format ops...
		result = PSI_EnqueDisplayHistory( pmdp->pCursor, pLine );
	}
	pmdp->lockCount--;
	LeaveCriticalSec( &pmdp->Lock );
	return result;
}
//----------------------------------------------------------------------------
int GetCharFromLine( PCONSOLE_INFO console, uint32_t cols
						, PDISPLAYED_LINE pLine
						, int nChar, TEXTCHAR *result )
{
	int nLen;
	if( pLine && result )
	{
		PTEXT pText = pLine->start;
		int nOfs = 0, nSegShown = pLine->nFirstSegOfs;
		int32_t seg_len;
		int32_t nShown = 0;
		int32_t col_offset = 0;
// ComputeToShow( cols, &col_offset, pText, GetTextSize( pText ), nOfs, nShown, console->pCurrentDisplay );
		nLen = pLine->nToShow ;
		while( pText )
		{
			// nOfs is the column position to start at...
			// nShown is the amount of the first segment shown.
			//nLen = GetTextSize( pText );
			seg_len = (int)GetTextSize( pText );
			if( nShown >= nLen )
				return FALSE;
			if( !seg_len && !nChar )
			{
				(*result) = '\n';
				return TRUE;
			}
			if( nChar < pText->format.position.offset.spaces )
			{
				*result = ' ';
				return TRUE;
			}
			nShown += pText->format.position.offset.spaces;
			nChar -= pText->format.position.offset.spaces;
			if( (nChar + nSegShown) < seg_len )
			{
				TEXTCHAR *text = GetText( pText );
				*result = text[nChar + nSegShown];
				return TRUE;
			}
			nChar -= seg_len - nSegShown;
			nShown += seg_len - nSegShown;
			pText = NEXTLINE( pText );
 // have shown nothing on this segment.
			nSegShown = 0;
		}
	}
	return FALSE;
}
//----------------------------------------------------------------------------
#if 0
int GetCharFromRowCol( PCONSOLE_INFO pdp, int row, int col, char *data )
{
	PDISPLAYED_LINE pdl = GetDataItem( &pdp->pCurrentDisplay->DisplayLineInfo, row );
	return GetCharFromLine( pdp, pdp->nColumns, pdl, col, data );
}
#endif
//----------------------------------------------------------------------------
TEXTCHAR *PSI_GetDataFromBlock( PCONSOLE_INFO pdp )
{
	int line_start = pdp->mark_start.row;
	int col_start = pdp->mark_start.col;
	int line_end = pdp->mark_end.row;
	int col_end = pdp->mark_end.col + 1;
	int bBlock = FALSE;
	// 2 characters to stuff in \r\n on newline.
	TEXTCHAR *result = NewArray( TEXTCHAR, ( ( line_start - line_end ) + 1 ) * (col_end + 2) );
	int ofs = 0;
	int line, col;
	int first_char = TRUE;
	int first = TRUE;
	int _priorline;
	//lprintf( "allocated something crazy like %d,%d  %d %p",line_start - line_end, pdp->nColumns,  ( ( line_start - line_end ) + 1 ) * (pdp->nColumns + 2) ,  result );
	for( col = col_start, line = line_start
		; line >= line_end
		 ; line--, (col = bBlock) )
	{
		PDISPLAYED_LINE pdl;
		if( ( pdl = (PDISPLAYED_LINE)GetDataItem( pdp->CurrentMarkInfo, line ) ) )
		{
			if( first )
			{
				first = FALSE;
				_priorline = pdl->nLine;
			}
			else
				result[ofs++] = '\n';
			if( !pdl->nToShow || bBlock )
			{
				if( pdp->flags.bBuildDataWithCarriageReturn )
					result[ofs++] = '\r';
				result[ofs++] = '\n';
				_priorline = pdl->nLine;
			}
			{
				int end_count = bBlock?(col_end)
										 : ( line == line_end ? (col_end)
												: ( pdl->nToShow - col_start ) );
				for( ;
					 (int64_t)col < end_count;
					 col++ )
				{
/*pdp->nColumns*/
					if( GetCharFromLine( pdp, 0, pdl, col, result + ofs ) )
					{
						first_char = FALSE;
						ofs++;
					}
				}
			}
		}
	}
	result[ofs] = 0;
	if( ofs )
		return result;
	Release( result );
	return NULL;
}
//----------------------------------------------------------------------------
int PSI_ConvertXYToLineCol( PCONSOLE_INFO pdp
										, int x, int y
										, int *line, int *col )
{
	// x, y is top, left biased...
	// line is bottom biased... (also have to account for history)
#ifdef DEBUG_OUTPUT
	lprintf( "Convert XY to LineCol needs work.... it needs to iterate through the computed dipslayable lines..." );
#endif
	(*line) = 0;
	(*col) = 0;
#if 0
	*col = ( ( ( x + ( pdp->nFontWidth / 2 ) ) - pdp->nXPad )
							/ pdp->nFontWidth );
	if( y < pdp->nHistoryLineStart )
	{
		 // y is in 'history'
		 // might have to bias over separator lines
 // invert y;
		 y = pdp->nHistoryLineStart - y - pdp->nYPad;
		 pdp->CurrentLineInfo = GetDisplayInfo( pdp->pHistoryDisplay );
	}
	else if( y < pdp->nDisplayLineStart )
	{
		 // y is in 'display'
 // invert y;
		 y = pdp->nDisplayLineStart - pdp->nYPad - y;
		 pdp->CurrentLineInfo = GetDisplayInfo( pdp->pCurrentDisplay );
	}
 // y is on the command line...
	else
	{
		 return FALSE;
	}
	if( y < 0 )
		return FALSE;
	*line = y / pdp->nFontHeight;
#endif
	return TRUE;
}
//----------------------------------------------------------------------------
#if 0
int GetMaxDisplayedLine( PCONSOLE_INFO pdp, int nStart )
{
	if( nStart )
		 return ( pdp->nDisplayLineStart )
						/ pdp->nFontHeight;
	else
		 return ( pdp->nCommandLineStart
					- pdp->nDisplayLineStart )
						/ pdp->nFontHeight;
}
#endif
//----------------------------------------------------------------------------
void DoRenderHistory( PCONSOLE_INFO pdp, int bHistoryStart, int nBottomLineOffset, int nStartLineOffset, PENDING_RECT *region )
{
	int nMinLine, nFirst = 0;
	INDEX nLine = 0;
	RECT r;
	RECT upd;
	int nFirstLine;
	PDATALIST *ppCurrentLineInfo;
	if( pdp->flags.bNoDisplay )
	{
		lprintf( "nodisplay!" );
		return;
	}
	//lprintf( "Begin render history line" );
	EnterCriticalSec( &pdp->Lock );
	//lprintf( "Begin render history locked" );
	pdp->lockCount++;
#ifdef DEBUG_HISTORY_RENDER
	lprintf( "Begin Render history." );
#endif
	if( !bHistoryStart )
	{
		// if no display (all history?)
		// this is the command line/display line separator.
		nFirstLine = ( upd.bottom = pdp->nDisplayLineStartDynamic );
		if( !pdp->flags.bDirect && pdp->nDisplayLineStartDynamic != pdp->nCommandLineStart )
		{
			//lprintf( "Rendering display line seperator %d (not %d)", pdp->nDisplayLineStart, pdp->nCommandLineStart );
			if( pdp->RenderSeparator )
				pdp->RenderSeparator( pdp, pdp->nDisplayLineStartDynamic );
			nFirstLine -= pdp->nSeparatorHeight;
			// add update region...
			// but how big is the thing that just drew?!
		}
#ifdef DEBUG_HISTORY_RENDER
		lprintf( "nFirstline is %d", nFirstLine );
#endif
		// figure out if we draw up to history or all the screen...
		if( pdp->nHistoryLineStart )
			nMinLine = pdp->nHistoryLineStart;
		else
			nMinLine = 0;
		ppCurrentLineInfo = GetDisplayInfo( pdp->pCurrentDisplay );
		//lprintf( "ppCurrentLineInfo=%p", ppCurrentLineInfo );
	}
 // do render history start...
	else
	{
		// if no history (all display?)
		if( pdp->nHistoryLineStart == 0 )
		{
			pdp->lockCount--;
			LeaveCriticalSec( &pdp->Lock );
			return;
		}
		nFirstLine = ( upd.bottom = pdp->nHistoryLineStart ) - (pdp->nYPad);
		nMinLine = 0;
		nFirst = -1;
		// the seperator is actually rendererd OVER the top of the displayed line.
		ppCurrentLineInfo = GetDisplayInfo( pdp->pHistoryDisplay );
		//lprintf( "ppCurrentLineInfo=%p", ppCurrentLineInfo );
	}
	//lprintf( "Render history separator %d", pdp->nHistoryLineStart );
	if( pdp->RenderSeparator )
		pdp->RenderSeparator( pdp, pdp->nHistoryLineStart - nStartLineOffset );
	r.bottom = nFirstLine;
	r.top = 0;
	// left and right are relative... to the line segment only...
	// for the reason of color changes inbetween segments...
	while( 1 )
	{
		PDISPLAYED_LINE pCurrentLine;
#ifdef DEBUG_HISTORY_RENDER
		lprintf( "Get display line %d", nLine );
#endif
		pCurrentLine = (PDISPLAYED_LINE)GetDataItem( ppCurrentLineInfo, nLine );
		if( !pCurrentLine )
		{
#ifdef DEBUG_HISTORY_RENDER
			lprintf( "No such line... %d", nLine );
#endif
			break;
		}
		r.left = pCurrentLine->nPixelStart;
		r.right = pCurrentLine->nPixelEnd;
		r.top = pCurrentLine->nLineTop;
		r.bottom = r.top + pCurrentLine->nLineHeight;
		RenderTextLine( pdp, pCurrentLine, &r
			, (int)nLine, nFirst, nFirstLine - nStartLineOffset, nMinLine
			, ppCurrentLineInfo == &pdp->pCurrentDisplay->DisplayLineInfo
			, TRUE, 0, nBottomLineOffset, 0 );
		if( nFirst >= 0 )
			nFirst = -1;
		nLine++;
	}
	//lprintf( "r.bottom nMin %d %d", r.bottom, nMinLine );
	if( ( r.bottom - nStartLineOffset ) > nMinLine )
	{
		r.bottom = r.top;
		r.top = nMinLine;
		r.left = 0;
		r.right = pdp->nWidth;
#ifndef PSI_LIB
		//lprintf( "Would be blanking the screen here, but no, there's no reason to." );
				 //FillEmptyScreen();
#endif
	}
	//RenderConsole( pdp );
	//lprintf( "Render AGAIN the display line separator" );
	upd.top = r.top;
	upd.left = 0;
	upd.right = pdp->nWidth;
	AddUpdateRegion( region
						, upd.left, upd.top
						, upd.right-upd.left, (upd.bottom - nStartLineOffset) - upd.top );
	// screen updates affect the posititon of the last line/command line
	//if( pdp->flags.bDirect && !bHistoryStart )
	//	PSI_RenderCommandLine( pdp, region );
	pdp->lockCount--;
	LeaveCriticalSec( &pdp->Lock );
	//lprintf( "Done render history line" );
}
//----------------------------------------------------------------------------
void PSI_WinLogicDoStroke( PCONSOLE_INFO pdp, PTEXT stroke )
{
	EnterCriticalSec( &pdp->Lock );
	pdp->lockCount++;
	if( PSI_DoStroke( pdp, stroke ) )
	{
		pdp->pCommandDisplay->flags.bUpdated = 1;
		if( !pdp->pCommandDisplay->pBlock )
		{
			pdp->pCommandDisplay->pBlock = pdp->pCommandDisplay->region->pHistory.root.next;
			pdp->pCommandDisplay->pBlock->nLinesUsed = 1;
			pdp->pCommandDisplay->pBlock->pLines[0].flags.deleted = 0;
			pdp->pCommandDisplay->nLine = 1;
		}
		pdp->pCommandDisplay->pBlock->pLines[0].flags.nLineLength = (int)LineLengthExEx( pdp->CommandInfo->CollectionBuffer, FALSE, 8, NULL );
		pdp->pCommandDisplay->pBlock->pLines[0].pLine = pdp->CommandInfo->CollectionBuffer;
		if( !pdp->flags.bDirect )
			BuildDisplayInfoLines( pdp->pCommandDisplay, NULL, GetCommonFont( pdp->psicon.frame ) );
		else {
			BuildDisplayInfoLines( pdp->pCommandDisplay, pdp->pCurrentDisplay, GetCommonFont( pdp->psicon.frame ) );
			// update bias of displayed section above the last (complete)
			if( pdp->pCommandDisplay->DisplayLineInfo->Cnt > 1 )
				pdp->nDisplayLineStartDynamic = ((PDISPLAYED_LINE)GetDataItem( &pdp->pCommandDisplay->DisplayLineInfo
					, pdp->pCommandDisplay->DisplayLineInfo->Cnt - 2 ))->nLineTop;
			else {
				pdp->nDisplayLineStartDynamic = pdp->nCommandLineStart;
			}
//#ifdef DEBUG_HISTORY_RENDER
			lprintf( "(direct stroke)Setting display line to %d", pdp->nDisplayLineStartDynamic );
//#endif
		}
	}
	pdp->lockCount--;
	LeaveCriticalSec( &pdp->Lock );
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
int PSI_UpdateHistory( PCONSOLE_INFO pdp, SFTFont font )
{
	int bUpdate = 0;
	lprintf( "nLines = %d  percent = %d  x = %d"
			, 0
			, pdp->nHistoryPercent
/*pdp->nLines*/
			, ( 0 * ( 3 - pdp->nHistoryPercent ) / 4 ) );
	EnterCriticalSec( &pdp->Lock );
	pdp->lockCount++;
	if( GetBrowserDistance( pdp->pHistoryDisplay, NULL ) >
/*pdp->nLines*/
		( 0 * ( 3 - pdp->nHistoryPercent ) / 4 ) )
	{
		if( !pdp->flags.bHistoryShow )
		{
			extern PSIKEYDEFINE ConsoleKeyDefs[];
			lprintf( "Key END shoudl end history.." );
			ConsoleKeyDefs[KEY_END].op[0].bFunction = HISTORYKEY;
			ConsoleKeyDefs[KEY_END].op[0].data.HistoryKey = KeyEndHst;
			pdp->flags.bHistoryShow = 1;
 // this builds history and real display info lines.
			WinLogicCalculateHistory( pdp, font );
			bUpdate = 1;
		}
		else
		{
			PENDING_RECT upd;
			upd.flags.bHasContent = 0;
			upd.flags.bTmpRect = 0;
			MemSet( &upd.cs, 0, sizeof( upd.cs ) );
			BuildDisplayInfoLines( pdp->pHistoryDisplay, NULL, font );
			//lprintf( "ALready showing history?!" );
			DoRenderHistory(pdp, TRUE, 0, 0, &upd);
			// history only changed - safe to update
			// its content on result here...
			if( pdp->Update && upd.flags.bHasContent )
			{
				RECT r;
				r.left = upd.x;
				r.right = upd.x + upd.width;
				r.top = upd.y;
				r.bottom = upd.y + upd.height;
				pdp->Update( pdp, &r );
			}
		}
	}
	else
	{
		if( pdp->flags.bHistoryShow )
		{
			extern PSIKEYDEFINE ConsoleKeyDefs[];
			lprintf( "key end command line now... please do renderings.." );
			{
				int KeyEndCmd( uintptr_t list, PUSER_INPUT_BUFFER pci );
				ConsoleKeyDefs[KEY_END].op[0].bFunction = COMMANDKEY;
				ConsoleKeyDefs[KEY_END].op[0].data.CommandKey = KeyEndCmd;
			}
			pdp->flags.bHistoryShow = 0;
			WinLogicCalculateHistory( pdp, font );
			bUpdate = 1;
		}
	}
	pdp->lockCount--;
	LeaveCriticalSec( &pdp->Lock );
	return bUpdate;
}
PSI_CONSOLE_NAMESPACE_END
#ifndef USE_IMAGE_INTERFACE
#define USE_IMAGE_INTERFACE ImageInterface
#endif
#ifndef USE_RENDER_INTERFACE
#define USE_RENDER_INTERFACE RenderInterface
#endif
extern PIMAGE_INTERFACE ImageInterface;
PSI_CONSOLE_NAMESPACE
	extern CONTROL_REGISTRATION ConsoleClass;
static PTEXT eol;
PSI_Console_Phrase PSIConsoleOutput( PSI_CONTROL pc, PTEXT lines )
{
	PSI_Console_Phrase phrase;
	ValidatedControlData( PCONSOLE_INFO, ConsoleClass.TypeID, console, pc );
	// ansi filter?
	// conditions for getting text lines which have format elements
	// break lines?
	if( !eol )
		eol = SegCreateFromText( "\n" );
	if( console )
	{
		PTEXT parsed;
		PTEXT next;
		PTEXT remainder = NULL;
		PTEXT tmp;
		remainder = parsed = burst( lines );
		for( tmp = remainder; tmp; tmp = next )
		{
			next = NEXTLINE( tmp );
			if( !GetTextSize( tmp ) )
			{
				PTEXT prior;
				PTEXT que;
				prior = SegBreak( tmp );
				if( prior )
				{
					SetStart( prior );
					prior->format.position.offset.spaces += (uint16_t)console->pending_spaces;
					prior->format.position.offset.tabs += (uint16_t)console->pending_tabs;
					que = BuildLine( prior );
					if( !console->flags.bNewLine )
						que->flags |= TF_NORETURN;
					phrase  = PSI_WinLogicWriteEx( console, que, 0 );
					LineRelease( prior );
				}
				else {
					que = SegCreate( 0 );
					if( !console->flags.bNewLine )
						que->flags |= TF_NORETURN;
					phrase = PSI_WinLogicWriteEx( console, que, 0 );
				}
				console->flags.bNewLine = 1;
				// throw away the blank... don't really need it on the display
				SegGrab( tmp );
				console->pending_spaces = tmp->format.position.offset.spaces;
				console->pending_tabs = tmp->format.position.offset.tabs;
				LineRelease( tmp );
				remainder = next;
			}
		}
		if( remainder )
		{
			PTEXT que = BuildLine( remainder );
			if( !console->flags.bNewLine ) {
				que->flags |= TF_NORETURN;
			}
			phrase = PSI_WinLogicWriteEx( console, que, 0 );
			console->flags.bNewLine = 0;
		}
		else
		{
			console->flags.bNewLine = 1;
		}
		SmudgeCommon( pc );
	}
	return phrase;
}
PSI_Console_Phrase PSIConsoleDirectOutput( PSI_CONTROL pc, PTEXT lines )
{
	PSI_Console_Phrase phrase;
	ValidatedControlData( PCONSOLE_INFO, ConsoleClass.TypeID, console, pc );
	// ansi filter?
	// conditions for getting text lines which have format elements
	// break lines?
	//lprintf( "Direct Output:%s", GetText( lines ) );
	phrase  = PSI_WinLogicWriteEx( console, lines, 0 );
	SmudgeCommon( pc );
	return phrase;
}
static void sendInputEvent( uintptr_t arg, PTEXT line ) {
	PCONSOLE_INFO console = (PCONSOLE_INFO)arg;
	int n;
	if( console->flags.bDirect && !console->flags.bNoLocalEcho ) {
		PTEXT pEcho;
		pEcho = BuildLine( line );
		//pEcho->data.size--; // trim the last character (probably cr)
		pEcho->flags |= TF_NORETURN;
		PSI_WinLogicWriteEx( console, pEcho, 1 );
		console->flags.bNewLine = 1;
		//lprintf( "Should this local echo be marked somehow?" );
		//pdp->History.flags.bEnqueuedLocalEcho = 1;
		//pdp->flags.bLastEnqueCommand = TRUE;
	}
	for( n = 0; n < console->lockCount; n++ )
		LeaveCriticalSec( &console->Lock );
	console->InputEvent( console->psvInputEvent, line );
	for( n = 0; n < console->lockCount; n++ )
		EnterCriticalSec( &console->Lock );
}
void PSIConsoleInputEvent( PSI_CONTROL pc, void(CPROC*Event)(uintptr_t,PTEXT), uintptr_t psv )
{
	ValidatedControlData( PCONSOLE_INFO, ConsoleClass.TypeID, console, pc );
	if( console )
	{
		// this should be set with an appropriate method.
		console->InputEvent = Event;
		console->psvInputEvent = psv;
		console->CommandInfo->CollectedEvent = sendInputEvent;
		console->CommandInfo->psvCollectedEvent = (uintptr_t)console;
	}
}
void PSIConsoleLoadFile( PSI_CONTROL pc, CTEXTSTR file )
{
	// reset history and read a file into history buffer
	// this also implies setting the cursor position at the start of the history buffer
}
int vpcprintf( PSI_CONTROL pc, CTEXTSTR format, va_list args )
{
	ValidatedControlData( PCONSOLE_INFO, ConsoleClass.TypeID, console, pc );
	if( console )
	{
		PVARTEXT pvt = VarTextCreate();
		PTEXT output;
		vvtprintf( pvt, format, args );
		output = VarTextGet( pvt );
		//lprintf( "printf Output:%s", GetText( output ) );
		PSIConsoleOutput( pc, output );
	}
	return 1;
}
int pcprintf( PSI_CONTROL pc, CTEXTSTR format, ... )
{
	va_list args;
	va_start( args, format );
	return vpcprintf( pc, format, args );
}
void PSIConsoleSetLocalEcho( PSI_CONTROL pc, LOGICAL yesno )
{
	ValidatedControlData( PCONSOLE_INFO, ConsoleClass.TypeID, console, pc );
	if( console )
	{
		console->flags.bNoLocalEcho = !yesno;
	}
}
LOGICAL PSIConsoleGetLocalEcho( PSI_CONTROL pc )
{
	ValidatedControlData( PCONSOLE_INFO, ConsoleClass.TypeID, console, pc );
	if( console ) {
		return !console->flags.bNoLocalEcho;
	}
	return FALSE;
}
struct history_tracking_info *PSIConsoleSaveHistory( PSI_CONTROL pc )
{
	ValidatedControlData( PCONSOLE_INFO, ConsoleClass.TypeID, console, pc );
	if( console )
	{
		struct history_tracking_info *history_info = New( struct history_tracking_info );
		history_info->pHistory = console->pHistory;
		history_info->pHistoryDisplay = console->pHistoryDisplay;
		history_info->pCurrentDisplay = console->pCurrentDisplay;
		history_info->pCursor = console->pCursor;
		history_info->pending_spaces = console->pending_spaces;
		history_info->pending_tabs = console->pending_tabs;
		return history_info;
	}
	return NULL;
}
void PSIConsoleSetHistory( PSI_CONTROL pc, struct history_tracking_info *history_info )
{
	ValidatedControlData( PCONSOLE_INFO, ConsoleClass.TypeID, console, pc );
	if( console )
	{
		if( history_info )
		{
			console->pHistory = history_info->pHistory;
			console->pHistoryDisplay = history_info->pHistoryDisplay;
			console->pCurrentDisplay = history_info->pCurrentDisplay;
			console->pCursor = history_info->pCursor;
			console->pending_spaces = history_info->pending_spaces;
			console->pending_tabs = history_info->pending_tabs;
		}
		else
		{
			console->pHistory = PSI_CreateHistoryRegion();
			console->pCursor = PSI_CreateHistoryCursor( console->pHistory );
			console->pCurrentDisplay = PSI_CreateHistoryBrowser( console->pHistory, PSIMeasureString, (uintptr_t)console );
			console->pHistoryDisplay = PSI_CreateHistoryBrowser( console->pHistory, PSIMeasureString, (uintptr_t)console );
			console->pending_spaces = 0;
			console->pending_tabs = 0;
			PSI_SetHistoryBrowserNoPageBreak( console->pHistoryDisplay );
		}
		//GetStringSizeFont( " ", &console->nFontWidth, &console->nFontHeight, GetCommonFont( pc ) );
		PSI_ConsoleCalculate( console, GetCommonFont( pc ) );
	}
}
// mode 0 = inline/scrolling
// mode 1 = line buffer/scrolling
// mode 2 = line buffer/wrap
void PSIConsoleSetInputMode( PSI_CONTROL pc, int mode )
{
	ValidatedControlData( PCONSOLE_INFO, ConsoleClass.TypeID, console, pc );
	if( console )
	{
		if( mode )
		{
 // direct is inline, instead of line-mode
			console->flags.bDirect = 0;
			if( mode == 2 )
			{
				SetBrowserHeight( console->pCommandDisplay, 3 * console->nFontHeight + 2 * console->nYPad );
				console->flags.bWrapCommand = 1;
			}
			else {
				//SetBrowserHeight( console->pCommandDisplay, 1 * nLineHeight + 2 * console->nYPad );
				console->flags.bWrapCommand = 0;
			}
		}
		else {
 // direct in with text... (0) mode only
			console->flags.bDirect = 1;
			console->flags.bWrapCommand = 1;
		}
		if( console->nHeight )
		{
			// may not have gotten visual fittting yet...
			EnterCriticalSec( &console->Lock );
			console->lockCount++;
			PSI_ConsoleCalculate( console, GetCommonFont( pc ) );
			console->lockCount--;
			LeaveCriticalSec( &console->Lock );
			SmudgeCommon( console->psicon.frame );
		}
	}
}
void PSI_SetConsoleBackingFile( PSI_CONTROL pc, FILE *file )
{
	ValidatedControlData( PCONSOLE_INFO, ConsoleClass.TypeID, console, pc );
	SetHistoryBackingFile( console->pHistory, file );
}
PSI_CONSOLE_NAMESPACE_END
static CONTROL_REGISTRATION calendar;
typedef struct {
	struct {
		BIT_FIELD bShowMonth : 1;
		BIT_FIELD bStuff : 1;
		BIT_FIELD bMonth: 1;
		BIT_FIELD bWeek : 1;
		BIT_FIELD bDays : 1;
		BIT_FIELD bNow : 1;
	} flags;
} CALENDER, *PCALENDAR;
#if 0
int CPROC DrawCalender( PSI_CONTROL pc )
{
	// stuff...
	ValidatedControlData( PCALENDAR, calendar.nType, pCal, pc );
	if( pCal )
	{
		Image surface = GetCommonSurface( pc );
		if( pCal->flags.bMonth )
		{
		}
		else if( pCal->flags.bWeek )
		{
		}
		else if( pCal->flags.bDays )
		{
		}
		else if( pCal->flags.bNow )
		{
			if( pCal->flags.bTime )
			{
			}
		}
		{
		}
	}
}
CONTROL_REGISTRATION calendar = { "Calender Widget"
										  , { { 50, 50 }, BORDER_NONE, sizeof( CALENDER ) }
										  , NULL
};
PRELOAD(DoRegisterControl)
{
   DoRegisterControl( &calendar );
}
#endif
#undef g
#define g global_calender_structure
#ifndef USE_IMAGE_INTERFACE
#  define USE_IMAGE_INTERFACE (g.MyImageInterface?g.MyImageInterface:(g.MyImageInterface=GetImageInterface() ))
#endif
//#define USE_RENDER_INTERFACE g.MyDisplayInterface
PSI_CLOCK_NAMESPACE
// set color of the clock text
PSI_PROC( void, SetClockColor )( PSI_CONTROL pc, CDATA color );
// set color of the area behind the text, where the clock occupies
PSI_PROC( void, SetClockBackColor )( PSI_CONTROL pc, CDATA color );
// set the background image of the clock, used instead of the back color if present.
PSI_PROC( void, SetClockBackImage )( PSI_CONTROL pc, Image image );
// get the color of the clock widget
PSI_PROC( CDATA, GetClockColor )( PSI_CONTROL pc );
// stop the clock update
PSI_PROC( void, StopClock )( PSI_CONTROL pc );
// resume clock update
PSI_PROC( void, StartClock )( PSI_CONTROL pc );
// mark the curernt time
PSI_PROC( void, MarkClock )( PSI_CONTROL pc );
// unimplmeented really?
// this should result with the difference between the marked time and now?
PSI_PROC( void, ElapseClock )( PSI_CONTROL pc );
PSI_PROC( void, SetClockAmPm )( PSI_CONTROL pc, LOGICAL yes_no );
PSI_PROC( void, SetClockDate )( PSI_CONTROL pc, LOGICAL yes_no );
PSI_PROC( void, SetClockDayOfWeek )( PSI_CONTROL pc, LOGICAL yes_no );
PSI_PROC( void, SetClockSingleLine )( PSI_CONTROL pc, LOGICAL yes_no );
struct clock_image_thing {
   IMAGE_RECTANGLE rect_face;
   IMAGE_COORDINATE center_face;
	IMAGE_RECTANGLE rect_hourhand;
   IMAGE_COORDINATE center_hourhand;
   IMAGE_RECTANGLE rect_minutehand;
   IMAGE_COORDINATE center_minutehand;
	IMAGE_RECTANGLE rect_secondhand;
   IMAGE_COORDINATE center_secondhand;
};
PSI_PROC( void, MakeClockAnalogEx )( PSI_CONTROL pc, CTEXTSTR imagename, struct clock_image_thing *description );
// calls MakeClockAnalogEx( pc, "Clock.png" );
PSI_PROC( void, MakeClockAnalog )( PSI_CONTROL pc );
PSI_CLOCK_NAMESPACE_END
   USE_PSI_CLOCK_NAMESPACE
#define CLOCK_CORE
typedef struct global_tag
{
	PIMAGE_INTERFACE MyImageInterface;
	PRENDER_INTERFACE MyDisplayInterface;
	PLIST clocks;
} GLOBAL;
#ifndef CLOCK_CORE
extern
#endif
GLOBAL global_calender_structure;
#if !defined( CLOCK_CORE ) || defined( _MSC_VER ) || defined( __cplusplus )
extern
	CONTROL_REGISTRATION clock_control;
#endif
PSI_CLOCK_NAMESPACE
typedef struct analog_clock ANALOG_CLOCK, *PANALOG_CLOCK;
typedef struct clock_control_tag
{
	struct {
		BIT_FIELD bStopped : 1;
		BIT_FIELD bLocked : 1;
		BIT_FIELD bHighTime : 1;
		BIT_FIELD bAmPm : 1;
		BIT_FIELD bDate : 1;
		BIT_FIELD bDayOfWeek : 1;
		BIT_FIELD bSingleLine : 1;
	} flags;
#ifdef _MSC_VER
#pragma pack (push, 1)
#endif
	PREFIX_PACKED struct {
 // milliseconds
      uint16_t ms;
		uint8_t sc;
		uint8_t mn;
		uint8_t hr;
		uint8_t dy;
		uint8_t dow;
		uint8_t mo;
		uint16_t yr;
	} PACKED time_data;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
	CDATA textcolor;
	PTEXT time;
	CDATA backcolor;
	Image back_image;
	PANALOG_CLOCK analog_clock;
	TEXTSTR last_time;
} CLOCK_CONTROL, *PCLOCK_CONTROL;
void DrawAnalogClock( PSI_CONTROL pc );
PSI_CLOCK_NAMESPACE_END
PSI_CLOCK_NAMESPACE
extern CONTROL_REGISTRATION clock_control;
//--------------------------------------------------------------------------
//cpg26dec2006 calctl\clock.c(20): Warning! W202: Symbol 'Months' has been defined, but not referenced
/*
static TEXTCHAR Months[13][10] = { "default"
                  , "January"
                  , "February"
                  , "March"
                  , "April"
                  , "May"
                  , "June"
                  , "July"
                  , "August"
                  , "September"
                  , "October"
                  , "November"
                  , "December" };
*/
//cpg26dec2006 calctl\clock.c(33): Warning! W202: Symbol 'Days' has been defined, but not referenced
/*static TEXTCHAR Days[7][10] = {"Sunday", "Monday", "Tuesday", "Wednesday"
               , "Thursday", "Friday", "Saturday" };
*/
//DECLTEXTSZ( timenow, 80 );
static PTEXT GetTime( PCLOCK_CONTROL clock, int bNewline )
{
	static PTEXT timenow;
	if( !timenow )
		timenow = SegCreate( 80 );
//	PTEXT pTime;
#ifdef WIN32
	{
		SYSTEMTIME st;
	//	pTime = SegCreate( 38 );
		GetLocalTime( &st );
		clock->time_data.sc = (uint8_t)st.wSecond;
		clock->time_data.mn = (uint8_t)st.wMinute;
		clock->time_data.hr = (uint8_t)st.wHour;
		//clock->time_data.doy = st.wDayOfWeek;
		clock->time_data.dy = (uint8_t)st.wDay;
		clock->time_data.mo = (uint8_t)st.wMonth;
		clock->time_data.yr = st.wYear;
		clock->time_data.ms = st.wMilliseconds;
	/*
	 n = sprintf( pTime->data.data, "%s, %s %d, %d, %02d:%02d:%02d",
	 Days[st.wDayOfWeek], Months[st.wMonth],
	 st.wDay, st.wYear
	 , st.wHour, st.wMinute, st.wSecond );
	 */
		{
			static int last_second;
			static int prior_milli;
			if( clock->flags.bHighTime && ( last_second == st.wSecond || ( ( last_second+1)%60 == st.wSecond && prior_milli ) ) )
			{
				timenow->data.size = tnprintf( timenow->data.data, 80*sizeof(TEXTCHAR), "%02d/%02d/%d%c%02d:%02d:%02d.%03d%s"
													  , st.wMonth, st.wDay, st.wYear
													  , bNewline?'\n':' '
													  , clock->flags.bAmPm?(st.wHour == 0?12:(st.wHour > 12?st.wHour-12:st.wHour)):st.wHour
													  , st.wMinute, st.wSecond, st.wMilliseconds
													  , clock->flags.bAmPm?((st.wHour >= 12)?"P":"A"):""
													  );
				prior_milli = 1;
			}
			else
			{
				timenow->data.size = tnprintf( timenow->data.data, 80*sizeof(TEXTCHAR), "%02d/%02d/%d%c%02d:%02d:%02d%s"
													  , st.wMonth, st.wDay, st.wYear
													  , bNewline?'\n':' '
													  , clock->flags.bAmPm?(st.wHour == 0?12:(st.wHour > 12?st.wHour-12:st.wHour)):st.wHour
													  , st.wMinute, st.wSecond
													  , clock->flags.bAmPm?((st.wHour >= 12)?"P":"A"):""
													  );
				prior_milli = 0;
			}
			last_second = st.wSecond;
		}
		return timenow;
	}
#else
	{
		//struct timeval tv;
		struct tm *timething;
      char ftime[80];
		time_t timevalnow;
		time(&timevalnow);
		timething = localtime( &timevalnow );
		clock->time_data.sc = timething->tm_sec;
		clock->time_data.mn = timething->tm_min;
		clock->time_data.hr = timething->tm_hour;
		clock->time_data.dy = timething->tm_mday;
		clock->time_data.mo = timething->tm_mon;
		clock->time_data.yr = timething->tm_year;
		clock->time_data.ms = 0;
		strftime( ftime
				  , 80
				  , bNewline
					?"%m/%d/%Y\n%H:%M:%S"
					:"%m/%d/%Y %H:%M:%S"
				  , timething );
#ifdef UNICODE
		{
			TEXTCHAR *tmp = DupCStr( ftime );
			StrCpy( timenow->data.data, tmp );
         Release( tmp );
		}
#else
		StrCpy( timenow->data.data, ftime );
#endif
		return timenow;
	}
#endif
}
//------------------------------------------------------------------------
static int CPROC psiClockDrawClock( PSI_CONTROL pc )
{
	Image surface = GetControlSurface( pc );
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, pClk, pc );
	if( pClk )
	{
		uint32_t w, h;
		int line_count = 0;
		int lines = 0;
		//PTEXT szNow = pClk->time;
		TEXTSTR line;
		if( pClk->analog_clock )
		{
			//lprintf( "Draw." );
			DrawAnalogClock( pc );
			return 1;
		}
		//else
		{
			//lprintf( "Get to draw before being analog?" );
			for( line = GetText( pClk->time ); line; line = strchr( line, '\n' ) )
			{
				lines++;
				line++;
			}
			for( line = GetText( pClk->time ); line; line = strchr( line, '\n' ) )
			{
				TEXTCHAR* trunk;
				if( line != GetText( pClk->time ) )
					line++;
				trunk = strchr( line, '\n' );
				if( trunk )
					trunk[0] = 0;
				GetStringSizeFont( line, &w, &h, GetCommonFont( pc ) );
				if( pClk->back_image )
					BlotScaledImageAlpha( surface, pClk->back_image, ALPHA_TRANSPARENT );
				else
					BlatColorAlpha( surface, 0, 0, surface->width, surface->height, pClk->backcolor );
				//DebugBreak();
				PutStringFontEx( surface
									, (SUS_GT(surface->width,int32_t,w,uint32_t)?(( surface->width - w ) / 2):0)
									, (SUS_GT(surface->height,int32_t,h,uint32_t)?(( surface->height - ( h * lines ) ) / 2):0) + ( line_count * h )
									, pClk->textcolor, 0
									, line, strlen( line )
									, GetCommonFont( pc ) );
				if( trunk )
					trunk[0] = '\n';
				line_count++;
			}
		}
	}
	return TRUE;
}
static void CPROC ClockUpdate( uintptr_t psvPC )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, pClk, (PSI_CONTROL)psvPC );
	if( pClk )
	{
		if( !pClk->flags.bStopped )
		{
			int no_update = 0;
			//( pClk->time )
			// LineRelease( pClk->time );
			pClk->time = GetTime(pClk, TRUE);
			if( !pClk->analog_clock )
			{
				//static TEXTCHAR *text;
				if( pClk->last_time && StrCmp( pClk->last_time, GetText( pClk->time ) ) == 0 )
				{
					no_update = 1;
				}
				else
				{
					if( pClk->last_time )
						Release( pClk->last_time );
					pClk->last_time = StrDup( GetText( pClk->time ) );
				}
			}
			if( !no_update )
				SmudgeCommon( (PSI_CONTROL)psvPC );
			if( pClk->analog_clock )
			{
				// +100 from now... (less than 10/sec)
				RescheduleTimer( 100 );
			}
			else
			{
				if( pClk->flags.bHighTime )
					RescheduleTimer( 40 );
				else
					RescheduleTimer( 250 );
			}
		}
	}
}
int CPROC InitClock( PSI_CONTROL pc )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, pClk, (PSI_CONTROL)pc );
	// 7 lines, width non-specified...
#ifndef __NO_OPTIONS__
	pClk->flags.bHighTime = SACK_GetProfileIntEx( "SACK", "PSI/Clock Control/Default to high resolution time?", 0, TRUE );
#endif
	SetCommonFont( pc
					 , RenderFontFile( NULL
										  , (GetControlSurface( pc )->width -10) / 6
										  , (GetControlSurface( pc )->height -10)/ 2
										  ,3 ) );
	SetControlUserData( pc, AddTimer( 50, ClockUpdate, (uintptr_t)pc ) );
	SetControlTransparent( pc, TRUE );
	pClk->textcolor = GetBaseColor( TEXTCOLOR );
 // make sure it's NULL
	pClk->last_time = NULL;
	AddLink( &g.clocks, pc );
	return TRUE;
}
void CPROC DestroyClock( PSI_CONTROL pc )
{
	RemoveTimer( (uint32_t)GetControlUserData( pc ) );
	DeleteLink( &g.clocks, pc );
}
CONTROL_REGISTRATION clock_control = { "Basic Clock Widget"
									  , { { 270, 120 }, sizeof( CLOCK_CONTROL )
										 , BORDER_FIXED|BORDER_NONE|BORDER_NOCAPTION }
									  , InitClock
									  , NULL
									  , psiClockDrawClock
									  , NULL
									  , NULL
                             , DestroyClock
};
void SetClockColor( PSI_CONTROL pc, CDATA color )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, pClk, pc );
	if( pClk )
	{
      pClk->textcolor = color;
	}
}
void SetClockBackColor( PSI_CONTROL pc, CDATA color )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, pClk, pc );
	if( pClk )
	{
		pClk->backcolor = color;
	}
}
void SetClockBackImage( PSI_CONTROL pc, Image image )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, pClk, pc );
	if( pClk )
	{
		pClk->back_image = image;
	}
}
void SetClockHighTimeResolution( PSI_CONTROL pc, LOGICAL bEnable )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, pClk, pc );
	if( pClk )
	{
		pClk->flags.bHighTime = bEnable;
	}
}
CDATA GetClockColor( PSI_CONTROL pc )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, pClk, pc );
	if( pClk )
	{
		return pClk->textcolor;
	}
	return 0;
}
void StopClock( PSI_CONTROL pc )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, pClk, pc );
	if( pClk )
	{
		pClk->flags.bStopped = 1;
	}
}
void StartClock( PSI_CONTROL pc )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, pClk, pc );
	if( pClk )
	{
		pClk->flags.bStopped = 0;
	}
}
void MarkClock( PSI_CONTROL pc )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, pClk, pc );
	if( pClk )
	{
		pClk->flags.bStopped = 1;
	}
}
void ElapseClock( PSI_CONTROL pc )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, pClk, pc );
	if( pClk )
	{
		pClk->flags.bStopped = 1;
      // at the time it was stopped... the time needs to be marked.
	}
}
void SetClockAmPm( PSI_CONTROL pc, LOGICAL yes_no )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, pClk, pc );
	if( pClk )
	{
      pClk->flags.bAmPm = yes_no;
	}
}
void SetClockDate( PSI_CONTROL pc, LOGICAL yes_no )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, pClk, pc );
	if( pClk )
	{
      pClk->flags.bDate = yes_no;
	}
}
void SetClockDayOfWeek( PSI_CONTROL pc, LOGICAL yes_no )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, pClk, pc );
	if( pClk )
	{
		pClk->flags.bDayOfWeek = yes_no;
	}
}
void SetClockSingleLine( PSI_CONTROL pc, LOGICAL yes_no )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, pClk, pc );
	if( pClk )
	{
		pClk->flags.bSingleLine = yes_no;
	}
}
PRELOAD( DoRegisterClockControl )
{
	DoRegisterControl( &clock_control );
}
/* Android support; when the app stops, stop updating timers */
static void OnDisplayPause( "PSI_Clock" TARGETNAME )( void )
{
	INDEX idx;
	PSI_CONTROL clock;
	LIST_FORALL( g.clocks, idx, PSI_CONTROL, clock )
	{
		StopClock( clock );
	}
}
/* Android support; when the app reumes, start updating timers */
static void OnDisplayResume( "PSI_Clock" TARGETNAME)( void )
{
	INDEX idx;
	PSI_CONTROL clock;
	LIST_FORALL( g.clocks, idx, PSI_CONTROL, clock )
	{
		StartClock( clock );
	}
}
//PUBLIC( uint32_t, LinkClockPlease );
PSI_CLOCK_NAMESPACE_END
#undef g
#undef g
#define g global_calender_structure
//#ifndef __cplusplus_cli
#ifndef USE_RENDER_INTERFACE
#  define USE_RENDER_INTERFACE (g.MyDisplayInterface?g.MyDisplayInterface:(g.MyDisplayInterface=GetDisplayInterface() ))
#endif
#ifndef USE_IMAGE_INTERFACE
#  define USE_IMAGE_INTERFACE (g.MyImageInterface?g.MyImageInterface:(g.MyImageInterface=GetImageInterface() ))
#endif
//#endif
PSI_CLOCK_NAMESPACE
#define CLOCK_NAME "Basic Clock Widget"
extern CONTROL_REGISTRATION clock_control;
struct analog_clock
{
	struct {
		uint32_t bLocked : 1;
	} flags;
	PRENDERER render;
	Image image;
	Image face;
 // size of face, work space to add hands.  Clock face created always.
	Image composite;
	uint32_t w, h;
	PSPRITE second_hand;
	PSPRITE minute_hand;
	PSPRITE hour_hand;
	struct {
		uint32_t xofs;
		uint32_t yofs;
	} face_center;
	PCLOCK_CONTROL clock;
};
static void psiAnalogDrawClock( Image surface, PANALOG_CLOCK analog )
{
	{
		if( analog )
		{
			int remake = 0;
			if( analog->flags.bLocked )
				return;
			analog->flags.bLocked = 1;
			SetSpritePosition( analog->second_hand, surface->width/2, surface->height/2 );
			SetSpritePosition( analog->minute_hand, surface->width/2, surface->height/2 );
			SetSpritePosition( analog->hour_hand, surface->width/2, surface->height/2 );
			if( SUS_GT(surface->height,int32_t,analog->h,uint32_t) )
			{
				remake = 1;
				analog->h = surface->height;
			}
			if( SUS_GT(surface->width ,int32_t,analog->w,uint32_t) )
			{
				remake = 1;
				analog->w = surface->width;
			}
			if( remake )
			{
				UnmakeImageFile( analog->composite );
				analog->composite = MakeImageFile( analog->w, analog->h );
			}
			analog->composite = surface;
			ClearImageTo( analog->composite, 0 );
			//BlotScaledImageAlpha( surface, analog->composite, ALPHA_TRANSPARENT );
			BlotScaledImageSizedToAlpha( analog->composite, analog->face
												, 0, 0
												, surface->width, surface->height, ALPHA_TRANSPARENT );
			//BlotImage( analog->composite, analog->face, 0, 0);
			{
				//PANALOG_CLOCK analog = (PANALOG_CLOCK)psv;
				//Image surface = GetDisplayImage( renderer );
				rotate_scaled_sprite( analog->composite, analog->second_hand
										  , ( analog->clock->time_data.sc * 0x100000000LL ) / 60
										  + ( analog->clock->time_data.ms * 0x100000000LL ) / (1000*60)
										  , ( 0x10000 * surface->width ) / analog->face->width
										  , ( 0x10000 * surface->height ) / analog->face->height
										  );
				rotate_scaled_sprite( analog->composite, analog->minute_hand
										  , ( analog->clock->time_data.mn * 0x100000000LL ) / 60
											+ ( analog->clock->time_data.sc * 0x100000000LL ) / (60*60)
										  , ( 0x10000 * surface->width ) / analog->face->width
										  , ( 0x10000 * surface->height ) / analog->face->height
										  );
				rotate_scaled_sprite( analog->composite, analog->hour_hand
										  , ( analog->clock->time_data.hr * 0x100000000LL ) / 12
											+ ( analog->clock->time_data.mn * 0x100000000LL ) / (60*12)
										  , ( 0x10000 * surface->width ) / analog->face->width
										  , ( 0x10000 * surface->height ) / analog->face->height
										  );
			}
			//xlprintf(LOG_NOISE-1)( "Surface is %ld,%ld,%ld", surface, surface->x, surface->y );
			if( surface != analog->composite )
				BlotImageAlpha( surface, analog->composite, 0, 0, ALPHA_TRANSPARENT );
			//BlotImageSizedAlpha( surface, analog->composite, 0, 0, surface->width, surface->height, ALPHA_TRANSPARENT );
			//BlotScaledImageAlpha( surface, analog->composite, ALPHA_TRANSPARENT );
			analog->flags.bLocked = 0;
		}
	}
}
static void OnRevealCommon( CLOCK_NAME )( PSI_CONTROL pc )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, clock, (PSI_CONTROL)pc );
	if( clock )
	{
		PANALOG_CLOCK analog = clock->analog_clock;
#if draw_on_renderer
		if( analog )
		{
			RestoreDisplay( analog->render );
		}
#endif
	}
}
static void OnHideCommon( CLOCK_NAME )( PSI_CONTROL pc )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, clock, (PSI_CONTROL)pc );
	if( clock )
	{
		PANALOG_CLOCK analog = clock->analog_clock;
		if( analog )
		{
#if draw_on_renderer
			HideDisplay( analog->render );
#endif
		}
	}
}
static void MoveSurface( PSI_CONTROL pc )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, clock, (PSI_CONTROL)pc );
	if( clock )
	{
		PANALOG_CLOCK analog = clock->analog_clock;
		if( analog )
		{
			Image surface = GetControlSurface( pc );
			PRENDERER r = GetFrameRenderer( GetFrame( pc ) );
			int32_t x = 0;
			int32_t y = 0;
			GetPhysicalCoordinate( pc, &x, &y, TRUE );
#if draw_on_renderer
			if( analog->render )
				MoveDisplay( analog->render, x, y );
#endif
		}
	}
}
static void OnMoveCommon( CLOCK_NAME )( PSI_CONTROL pc, LOGICAL changing )
{
	if( !changing )
		MoveSurface( pc );
}
static void OnMotionCommon( CLOCK_NAME )( PSI_CONTROL pc, LOGICAL changing )
{
	if( !changing )
		MoveSurface( pc );
}
static void OnSizeCommon( CLOCK_NAME )( PSI_CONTROL pc, LOGICAL changing )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, clock, (PSI_CONTROL)pc );
	if( !changing && clock )
	{
		PANALOG_CLOCK analog = clock->analog_clock;
		if( analog )
		{
			Image surface = GetControlSurface( pc );
#if draw_on_renderer
			if( analog->render )
				SizeDisplay( analog->render, surface->width, surface->height );
#endif
		}
	}
}
#ifdef draw_on_renderer
void CPROC DrawClockLayers( uintptr_t psv, PRENDERER renderer )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, clock, (PSI_CONTROL)psv );
	if( clock )
	{
		PANALOG_CLOCK analog = clock->analog_clock;
		Image surface = GetDisplayImage( renderer );
		psiAnalogDrawClock( surface, analog );
		UpdateDisplay( renderer );
	}
}
#endif
void DrawAnalogClock( PSI_CONTROL pc )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, clock, pc );
	if( clock )
	{
		PANALOG_CLOCK analog = clock->analog_clock;
		Image surface = GetControlSurface( pc );
		//Redraw( analog->render );
		psiAnalogDrawClock( surface, analog );
	}
}
void MakeClockAnalogEx( PSI_CONTROL pc, CTEXTSTR imagename, struct clock_image_thing *description )
{
	ValidatedControlData( PCLOCK_CONTROL, clock_control.TypeID, clock, pc );
	if( clock )
	{
		PANALOG_CLOCK analog = clock->analog_clock;
		if( !analog )
		{
			if( !imagename )
 // no image? well then no analog clock for you.
				return;
			analog = (PANALOG_CLOCK)Allocate( sizeof( ANALOG_CLOCK ) );
			MemSet( analog,0,sizeof( ANALOG_CLOCK ) );
			analog->clock = clock;
			analog->image = LoadImageFile( imagename );
			if( !analog->image )
			{
				Release( analog );
				return;
			}
			{
				int x, y, w, h;
				int face_center_x, face_center_y;
				int second_hand_center, second_hand_width, second_hand_pivot;
				int minute_hand_center, minute_hand_width, minute_hand_pivot;
				int hour_hand_center, hour_hand_width, hour_hand_pivot;
				TEXTCHAR tmp[256];
				tnprintf( tmp, sizeof( tmp ), "Analog Clock/%s", imagename );
#ifdef __NO_OPTIONS__
#undef SACK_GetProfileInt
#define SACK_GetProfileInt(a,b,c) (c)
#endif
				x = SACK_GetProfileInt( tmp, "face x", 0 );
				y = SACK_GetProfileInt( tmp, "face y", 0 );
				w = SACK_GetProfileInt( tmp, "face width", 358 );
				h = SACK_GetProfileInt( tmp, "face height", 358 );
				face_center_x = SACK_GetProfileInt( tmp, "face.center.x", 178 );
				face_center_y = SACK_GetProfileInt( tmp, "face.center.y", 179 );
				second_hand_center = SACK_GetProfileInt( tmp, "hand.second.center", 400 );
				second_hand_width = SACK_GetProfileInt( tmp, "hand.second.width", 40 );
				second_hand_pivot = SACK_GetProfileInt( tmp, "hand.second.pivot", 179 );
				minute_hand_center = SACK_GetProfileInt( tmp, "hand.minute.center", 440 );
				minute_hand_width = SACK_GetProfileInt( tmp, "hand.minute.width", 40 );
				minute_hand_pivot = SACK_GetProfileInt( tmp, "hand.minute.pivot", 179 );
				hour_hand_center = SACK_GetProfileInt( tmp, "hand.hour.center", 480 );
				hour_hand_width = SACK_GetProfileInt( tmp, "hand.hour.width", 40 );
				hour_hand_pivot = SACK_GetProfileInt( tmp, "hand.hour.pivot", 179 );
			analog->face = MakeSubImage( analog->image, x, y, w, h );
			analog->composite = MakeImageFile( w, h );
			analog->w = w;
			analog->h = h;
			analog->second_hand = MakeSpriteImage( MakeSubImage( analog->image, second_hand_center-(second_hand_width/2), y, second_hand_width, h ) );
			analog->minute_hand = MakeSpriteImage( MakeSubImage( analog->image, minute_hand_center-(minute_hand_width/2), y, minute_hand_width, h ) );
			analog->hour_hand = MakeSpriteImage( MakeSubImage( analog->image, hour_hand_center-(hour_hand_width/2), y, hour_hand_width, h ) );
			analog->face_center.xofs = face_center_x;
			analog->face_center.yofs = face_center_y;
			SetSpritePosition( analog->second_hand, analog->face_center.xofs, analog->face_center.yofs );
			SetSpritePosition( analog->minute_hand, analog->face_center.xofs, analog->face_center.yofs );
			SetSpritePosition( analog->hour_hand, analog->face_center.xofs, analog->face_center.yofs );
			SetSpriteHotspot( analog->second_hand, minute_hand_width/2, second_hand_pivot );
			SetSpriteHotspot( analog->minute_hand, minute_hand_width/2, minute_hand_pivot );
			SetSpriteHotspot( analog->hour_hand, hour_hand_width/2, hour_hand_pivot );
			}
#if draw_on_renderer
			if( 0 )
			{
				Image surface = GetControlSurface( pc );
				PRENDERER r = GetFrameRenderer( GetFrame( pc ) );
				int32_t x = 0;
				int32_t y = 0;
				GetPhysicalCoordinate( pc, &x, &y, FALSE );
					lprintf( "Making clock uhm... %d %d %d %d over %p", x, y,surface->width
																	 , surface->height );
				analog->render = OpenDisplayAboveSizedAt( DISPLAY_ATTRIBUTE_LAYERED
																	  |DISPLAY_ATTRIBUTE_NO_MOUSE
 // mark that this is uhmm intended to not be a alt-tabbable window
																	  |DISPLAY_ATTRIBUTE_CHILD
																	 , surface->width
																	 , surface->height
																	 , x, y
 // r may not exist yet... we might just be over a control that is frameless... later we'll relate as child
																	 , r
																	 );
				UpdateDisplay( analog->render );
				SetRedrawHandler( analog->render, DrawClockLayers, (uintptr_t)pc );
			}
#endif
			clock->analog_clock = analog;
			//EnableSpriteMethod( GetFrameRenderer( GetFrame( pc ) ), DrawAnalogHands, (uintptr_t)analog );
		}
		else
		{
			if( !imagename )
			{
				UnmakeImageFile( analog->composite );
				UnmakeImageFile( analog->face );
				UnmakeSprite( analog->second_hand, TRUE );
				UnmakeSprite( analog->minute_hand, TRUE );
				UnmakeSprite( analog->hour_hand, TRUE );
				Release( analog );
				clock->analog_clock = NULL;
			}
			// reconfigure
		}
	}
}
void MakeClockAnalog( PSI_CONTROL pc )
{
	TEXTCHAR namebuf[256];
#ifndef __NO_OPTIONS__
	SACK_GetProfileString( GetProgramName(), "Analog Clock/Use Image", "images/Clock.png", namebuf, 256 );
#else
   StrCpy( namebuf, "images/Clock.png" );
#endif
	MakeClockAnalogEx( pc, namebuf, NULL );
}
PSI_CLOCK_NAMESPACE_END
#undef g
#define NO_OPEN_MACRO
#define FIX_RELEASE_COM_COLLISION
//#ifndef __cplusplus_cli
#ifdef WIN32
#include	<windowsx.h>
#endif
//#endif
#ifdef SYSTRAY_LIBRARAY
#define SYSTRAY_PROC EXPORT_METHOD
#else
#define SYSTRAY_PROC IMPORT_METHOD
#endif
#define ICONFROMIMAGE 1
#define ICONFROMTEXT 2
SYSTRAY_PROC int RegisterIconEx( CTEXTSTR icon DBG_PASS);
#define RegisterIcon(icon) RegisterIconEx( icon DBG_SRC )
SYSTRAY_PROC void ChangeIconEx( CTEXTSTR icon DBG_PASS );
#define ChangeIcon(icon) ChangeIconEx( icon DBG_SRC )
SYSTRAY_PROC void UnregisterIcon( void );
SYSTRAY_PROC void SetIconDoubleClick( void (*DoubleClick)(void ) );
SYSTRAY_PROC void TerminateIcon( void );
SYSTRAY_PROC void AddSystrayMenuFunction( CTEXTSTR text, void (CPROC*function)(void) );
SYSTRAY_PROC void AddSystrayMenuFunction_v2( CTEXTSTR text, void (CPROC* function)(uintptr_t), uintptr_t );
// this may be important one day!
//void SetIconMenu( HMENU menu );
// $Log: systray.h,v $
// Revision 1.3  2003/03/25 08:38:11  panther
// Add logging
//
#define ICO_DEFAULT 1001
//----------------------------------------------------------------------
#define MNU_EXIT 1000
#ifdef WIN32
HWND ghWndIcon;
#define WM_USERICONMSG (WM_USER + 212)
static HMENU hMainMenu;
HICON hLastIcon;
static NOTIFYICONDATA nid;
static HINSTANCE hInstMe;
static UINT WM_TASKBARCREATED;
CTEXTSTR icon;
LOGICAL thread_ready;
#else
#define __NO_WIN32API__
static PMENU hMainMenu;
#endif
static void (*DblClkCallback)(void);
typedef struct addition {
	CTEXTSTR text;
	void (CPROC*f2)(uintptr_t);
	uintptr_t param;
	void (CPROC*f)(void);
   int id;
} ADDITION, *PADDITION;
static int additions = 0;
static PLIST Functions;
static struct systray_local {
	struct {
		BIT_FIELD bLog : 1;
	} flags;
} localSystrayState;
//----------------------------------------------------------------------
#ifndef __NO_WIN32API__
LRESULT APIENTRY IconMessageHandler( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	if( uMsg == WM_TASKBARCREATED )
	{
		Shell_NotifyIcon( NIM_ADD, &nid );
	}
	else switch( uMsg )
	{
	case WM_MOUSEMOVE:
		//printf( "Mouse: %d, %d", HIWORD( wParam ), LOWORD( wParam ) );
		break;
	case WM_USERICONMSG:
		//lprintf( "anythign %08x", lParam );
		switch( lParam & 0xFF )
		{
 // double right.
		case 6:
			break;
  // right button down
		case 4:
			//printf( "RightDown" );
			break;
 // right button up
		case 5:
			{
				POINT p;
				GetCursorPos( &p );
#ifdef WIN32
				TrackPopupMenu( hMainMenu
 //| TPM_LEFTBUTTON|TPM_RIGHTBUTTON
								  , TPM_LEFTALIGN
								  , p.x, p.y
								  , 0
								  , hWnd
								  , NULL );
#else
				if( TrackPopup( hMainMenu, NULL ) == MNU_EXIT )
					SendMessage( hWnd, WM_COMMAND, MNU_EXIT, 0 );
#endif
			}
			//printf( "RightUp" );
			break;
 // double left
		case 3:
			if( DblClkCallback )
				DblClkCallback();
			break;
 // left button down
		case 2:
			//printf( "LeftUp" );
			break;
 // left button up
		case 1:
			//printf( "LeftDown" );
			break;
		default:
			//Log3( "Mouse: %d, %d %08x", HIWORD( wParam ), LOWORD( wParam ), lParam );
			break;
		}
		break;
	case WM_COMMAND:
//IJ		switch( LOWORD( wParam ))
		switch( GET_WM_COMMAND_ID (wParam, lParam) )
		{
		case MNU_EXIT:
			if( localSystrayState.flags.bLog )
				lprintf( "Posting quit Message" );
			UnregisterIcon();
			PostQuitMessage( 0 );
			exit(0);
		case 0xFFFF:
			break;
		default:
			{
				int fidx = LOWORD(wParam) - (MNU_EXIT + 1);
				PADDITION addon = ((PADDITION)GetLink( &Functions, fidx ));
				if( addon ) {
					void (CPROC * func)(void) = addon->f;
					if( func )
				               func();
					else if( addon->f2 )
						addon->f2( addon->param );
				}
			}
		}
		break;
	case WM_TIMER:
		break;
	case WM_CREATE:
		break;
	}
	return DefWindowProc( hWnd, uMsg, wParam, lParam );
}
//----------------------------------------------------------------------
static PTHREAD pMyThread;
static int CPROC systrayidle( uintptr_t unused )
{
	MSG msg;
	if( IsThisThread( pMyThread ) )
	{
		if( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
		{
			if( localSystrayState.flags.bLog )
				lprintf( "dispatch %d ...", msg.message );
			DispatchMessage( &msg );
			return 1;
		}
		return 0;
	}
	return -1;
}
#endif
//----------------------------------------------------------------------
uintptr_t CPROC RegisterAndCreate( PTHREAD thread )
{
#ifndef __NO_WIN32API__
  // zero init.
	static WNDCLASS wc;
	static ATOM ac;
#ifndef __NO_OPTIONS__
	localSystrayState.flags.bLog = SACK_GetProfileIntEx( GetProgramName(), "SACK/System Tray/Logging Enable", 0, TRUE );
#endif
	if( !ac )
	{
		WM_TASKBARCREATED = RegisterWindowMessage("TaskbarCreated");
		memset( &wc, 0, sizeof( WNDCLASS ) );
		   wc.lpfnWndProc   = (WNDPROC)IconMessageHandler;
		wc.hInstance     = GetModuleHandle( NULL ) ;
		wc.lpszClassName = "AlertAgentIcon";
		if( !( ac = RegisterClass(&wc) ) )
		{
			TEXTCHAR byBuf[256];
			if( GetLastError() != ERROR_CLASS_ALREADY_EXISTS )
			{
				tnprintf( byBuf, sizeof( byBuf ), "RegisterClassError: %p %d", GetModuleHandle( NULL ), GetLastError() );
				MessageBox( NULL, byBuf, "BAD", MB_OK );
   // stop thread
				return FALSE;
			}
		}
		pMyThread = MakeThread();
		AddIdleProc( systrayidle, 0 );
	}
	{
		TEXTCHAR wndname[256];
		//if( (uintptr_t)icon < 0x10000)
		//	snprintf( wndname, sizeof( wndname ), "AlertAgentIcon:%d", icon );
		//else
		tnprintf( wndname, sizeof( wndname ), "AlertAgentIcon:%s", GetProgramName() );
      /*
		{
			HWND prior = NULL;
			HWND test = NULL;
			while( (test = FindWindow( wc.lpszClassName, wndname )) && test != prior )
			{
            //lprintf( "Sending paint to prior window?" );
            SendMessage( test, WM_PAINT, 0, 0 );
            prior = test;
			}
			}
      */
		ghWndIcon = CreateWindow(  (CTEXTSTR)ac,
										 wndname,
										 0,0,0,0,0,NULL,NULL,NULL,NULL);
	}
	if( !ghWndIcon )
	{
		MessageBox( NULL, "System Tray icon cannot load (no window)", "Exiting now", MB_OK );
		return FALSE;
	}
	if( thread )
	{
		MSG msg;
		thread_ready = TRUE;
		//icon = NULL;
		while( GetMessage( &msg, NULL, 0, 0 ) )
			DispatchMessage( &msg );
		return 0;
	}
	else
#endif
		return TRUE;
}
//----------------------------------------------------------------------
int RegisterIconHandler( CTEXTSTR param_icon )
{
	//if( param_icon )
	//{
	//   icon = param_icon;
	//	return RegisterAndCreate( NULL );
	//}
	//else
#ifdef WIN32
	{
		// start as a thread... which creates the window and registers the class..
		// and continues to receive messages... since the thread parameter is NOT NULL
		// when a threadproc is invoked by ThreadTo();
		if( !param_icon )
			icon = "default";
		else
			icon = param_icon;
		ThreadTo( RegisterAndCreate, 0 );
		// have to wait for a completion event....
		// so we know when we can actually result and allow
		// the registration of the icon itself with a valid window handle
		// with a valid message loop.
		while( !thread_ready )
		{
			// blah..
			Relinquish();
		}
		return TRUE;
	}
#endif
	return 0;
}
//----------------------------------------------------------------------
void SetIconDoubleClick( void (*DoubleClick)(void ) )
{
	DblClkCallback = DoubleClick;
}
//----------------------------------------------------------------------
void BasicExitMenu( void )
{
	CTEXTSTR filepath;
	filepath = GetProgramName();
#ifdef WIN32
	hInstMe = GetModuleHandle( TARGETNAME );
	hMainMenu = CreatePopupMenu();
	AppendMenu( hMainMenu, MF_STRING, TXT_STATIC, filepath );
	AppendMenu( hMainMenu, MF_STRING, MNU_EXIT, "&Exit" );
#else
	hMainMenu = CreatePopup();
	AppendPopupItem( hMainMenu, MF_STRING, TXT_STATIC, filepath );
	AppendPopupItem( hMainMenu, MF_STRING, MNU_EXIT, "&Exit" );
#endif
	{
		INDEX idx;
		PADDITION addition;
		LIST_FORALL( Functions, idx, PADDITION, addition )
		{
#ifdef WIN32
			AppendMenu( hMainMenu, MF_STRING, MNU_EXIT+1+addition->id, addition->text );
#else
			AppendPopupItem( hMainMenu, MF_STRING, MNU_EXIT+1+addition->id, addition->text );
#endif
		}
	}
}
void AddSystrayMenuFunction( CTEXTSTR text, void (CPROC*function)(void) )
{
	if( hMainMenu )
	{
#ifdef WIN32
		AppendMenu( hMainMenu, MF_STRING, MNU_EXIT+1+additions, text );
#else
		AppendPopupItem( hMainMenu, MF_STRING, MNU_EXIT+1+additions, text );
#endif
	}
	{
		PADDITION addition = New( ADDITION );
		addition->text = StrDupEx( text DBG_SRC );
		addition->f = function;
		addition->id = additions;
		SetLink( &Functions, additions, addition );
		additions++;
	}
}
void AddSystrayMenuFunction_v2( CTEXTSTR text, void (CPROC* function)(uintptr_t), uintptr_t param ){
	if( hMainMenu )
	{
#ifdef WIN32
		AppendMenu( hMainMenu, MF_STRING, MNU_EXIT+1+additions, text );
#else
		AppendPopupItem( hMainMenu, MF_STRING, MNU_EXIT+1+additions, text );
#endif
	}
	{
		PADDITION addition = New( ADDITION );
		addition->text = StrDupEx( text DBG_SRC );
		addition->f = NULL;
		addition->param = param;
		addition->f2 = function;
		addition->id = additions;
		SetLink( &Functions, additions, addition );
		additions++;
	}
}
//----------------------------------------------------------------------
int RegisterIconEx( CTEXTSTR user_icon DBG_PASS )
{
	int status;
	int tried_default = 0;
	//NOTIFYICONDATA nid;
	if( !RegisterIconHandler( user_icon ) )
		return 0;
	if( !hMainMenu )
		BasicExitMenu();
#ifdef WIN32
	nid.cbSize = sizeof( NOTIFYICONDATA );
	nid.hWnd = ghWndIcon;
	nid.uID = 0;
	nid.uFlags = NIF_ICON|NIF_MESSAGE;
	nid.uCallbackMessage = WM_USERICONMSG;
	if( (uintptr_t)icon & 0xFFFF0000 )
	{
		nid.hIcon = (HICON)LoadImage( NULL, icon, IMAGE_ICON
									, 0, 0
									,
#ifndef _ARM_
									LR_LOADFROMFILE|
									LR_DEFAULTSIZE
#else
									0
#endif
									);
		if( !nid.hIcon )
				nid.hIcon = (HICON)LoadImage( GetModuleHandle(NULL), icon, IMAGE_ICON
											, 0, 0
#ifndef _ARM_
											,  LR_DEFAULTSIZE
#else
											, 0
#endif
											);
		if( !nid.hIcon )
				nid.hIcon = (HICON)LoadImage( hInstMe, icon, IMAGE_ICON
											, 0, 0
#ifndef _ARM_
											,  LR_DEFAULTSIZE
#else
											, 0
#endif
											);
	}
	else
	{
		if( icon )
		{
			nid.hIcon = (HICON)LoadImage( GetModuleHandle(NULL), icon, IMAGE_ICON
										, 0, 0
#ifndef _ARM_
											,  LR_DEFAULTSIZE
#else
											, 0
#endif
										);
			if( !nid.hIcon )
				nid.hIcon = (HICON)LoadImage( hInstMe, icon, IMAGE_ICON
											, 0, 0
#ifndef _ARM_
											,  LR_DEFAULTSIZE
#else
											, 0
#endif
											);
			if( !nid.hIcon )
				nid.hIcon = (HICON)LoadImage( NULL, icon, IMAGE_ICON
											, 0, 0
#ifndef _ARM_
											,  LR_DEFAULTSIZE
#else
											, 0
#endif
											);
		}
		else
		{
			SetDefault:
			{
				nid.hIcon = (HICON)LoadImage( hInstMe
											, (TEXTCHAR*)ICO_DEFAULT, IMAGE_ICON
											, 0, 0
#ifndef _ARM_
											,  LR_DEFAULTSIZE
#else
											, 0
#endif
											);
				if( !nid.hIcon )
					nid.hIcon = (HICON)LoadImage( hInstMe, (TEXTCHAR*)"ICO_DEFAULT", IMAGE_ICON
												, 0, 0
#ifndef _ARM_
												,  LR_DEFAULTSIZE
#else
												, 0
#endif
												);
			}
		}
	}
	if( !nid.hIcon && !tried_default )
	{
		//char msg[128];
		tried_default++;
		//sprintf( msg, DBG_FILELINEFMT "Failed to load icon" DBG_RELAY );
		//MessageBox( NULL, msg, "Systray Library", MB_OK );
      goto SetDefault;
	}
	status = Shell_NotifyIcon( NIM_ADD, &nid );
	DeleteObject( hLastIcon );
	hLastIcon = nid.hIcon;
#endif
	return status;
}
//----------------------------------------------------------------------
void ChangeIconEx( CTEXTSTR icon DBG_PASS )
{
#ifdef WIN32
	if( !ghWndIcon ) {
		RegisterIcon( icon );
		return;
	}
	nid.cbSize = sizeof( NOTIFYICONDATA );
	nid.hWnd = ghWndIcon;
	nid.uID = 0;
	nid.uFlags = NIF_ICON|NIF_MESSAGE;
	nid.uCallbackMessage = WM_USERICONMSG;
	if( (uintptr_t)icon & 0xFFFF0000 )
	{
		nid.hIcon = (HICON)LoadImage( GetModuleHandle(NULL), icon, IMAGE_ICON
								, 0, 0
#ifndef _ARM_
											,  LR_DEFAULTSIZE
#else
											, 0
#endif
								);
		if( !nid.hIcon )
		nid.hIcon = (HICON)LoadImage( NULL, icon, IMAGE_ICON
								, 0, 0
#ifndef _ARM_
								, LR_LOADFROMFILE| LR_DEFAULTSIZE
#else
											, 0
#endif
								);
	}
	else
	{
		nid.hIcon = (HICON)LoadImage( GetModuleHandle(NULL), icon, IMAGE_ICON
								, 0, 0
#ifndef _ARM_
								,  LR_DEFAULTSIZE
#else
											, 0
#endif
								);
	}
	if( !nid.hIcon )
	{
		TEXTCHAR msg[128];
		tnprintf( msg, sizeof( msg ), DBG_FILELINEFMT "Failed to load icon" DBG_RELAY );
		MessageBox( NULL, msg, "Systray Library", MB_OK );
	}
	Shell_NotifyIcon( NIM_MODIFY, &nid );
	DeleteObject( hLastIcon );
	hLastIcon = nid.hIcon;
#endif
}
//----------------------------------------------------------------------
void UnregisterIcon( void )
{
#ifdef WIN32
	if( nid.cbSize )
	{
		nid.cbSize = sizeof( NOTIFYICONDATA );
		nid.hWnd = ghWndIcon;
		nid.uID = 0;
		nid.uFlags = NIF_ICON|NIF_MESSAGE;
		nid.uCallbackMessage = WM_USERICONMSG;
		Shell_NotifyIcon( NIM_DELETE, &nid );
	}
#endif
}
void TerminateIcon( void )
{
#if WIN32
	int attempt = 0;
	HWND hWndOld;
	TEXTCHAR iconwindow[256];
	tnprintf( iconwindow, sizeof( iconwindow ), "AlertAgentIcon:%s", GetProgramName() );
	while( ( hWndOld = FindWindow( "AlertAgentIcon", iconwindow ) ) && ( attempt < 5 ) )
	{
		if( localSystrayState.flags.bLog )
			Log( "Telling previous instance to exit." );
 /*MNU_EXIT*/
		SendMessage( hWndOld, WM_COMMAND,1000, 0 );
		Sleep( 100 );
      attempt++;
	}
	if( attempt == 5 )
	{
      DWORD dwProcess;
		DWORD dwThread = GetWindowThreadProcessId( hWndOld, &dwProcess );
		HANDLE hProc;
		if( localSystrayState.flags.bLog )
			lprintf( "posting didn't cause process to exit... attempting to terminate." );
		hProc = OpenProcess( SYNCHRONIZE | PROCESS_TERMINATE, FALSE, dwProcess );
		if( hProc == NULL )
		{
			if( localSystrayState.flags.bLog )
				lprintf( "Failed to open process handle..." );
			return;
		}
		TerminateProcess( hProc, 0xFEED );
		CloseHandle( hProc );
	}
#endif
}
ATEXIT( DoUnregisterIcon )
{
   UnregisterIcon();
}
// $Log: systray.c,v $
// Revision 1.15  2005/07/25 21:43:15  jim
// Fix regisrered name of non-default icons
//
// Revision 1.18  2005/07/25 21:41:49  d3x0r
// Didn't pass icon name new newly threaded - easy to use systray thing.
//
// Revision 1.17  2005/06/06 09:27:41  d3x0r
// Fix loading of the default icon.
//
// Revision 1.16  2005/06/05 05:23:43  d3x0r
// Add module filename to the menu so we know which default icon is which.
//
// Revision 1.15  2005/06/05 05:07:20  d3x0r
// Add default thread to accompany default icon and default behvaior of exit(0)
//
// Revision 1.14  2005/06/05 04:53:42  d3x0r
// Default exit method also calls exit().  THis is a termination exit, and does not allow the application to exit gracefully.  There is also a PostQuitMessage... which may or may not be received by the main thread (this thread??)
//
// Revision 1.13  2005/06/05 04:52:02  d3x0r
// Add default icon to systray handler... so we can registericon...
//
// Revision 1.12  2005/05/25 16:50:30  d3x0r
// Synch with working repository.
//
// Revision 1.13  2005/01/10 21:43:42  panther
// Unix-centralize makefiles, also modify set container handling of getmember index
//
// Revision 1.12  2004/12/20 22:32:49  panther
// Modifications to make idle proc check for thread instance
//
// Revision 1.11  2004/10/03 02:14:03  d3x0r
// Auto unregister icon at exit...
//
// Revision 1.10  2004/06/24 03:33:02  d3x0r
// Register idle proc for systray's ldle of peek/dispatch message which eveyrone else doesn't need to know.
//
// Revision 1.9  2004/06/15 21:33:36  d3x0r
// Define libmain to make compilation happier...
//
// Revision 1.8  2004/05/27 20:57:40  d3x0r
// Use PSI menus instead of windows menus...
//
// Revision 1.8  2004/05/21 00:57:49  jim
// Fix some mouse issues, track focus issues, fix some soft cursor issues...
//
// Revision 1.7  2003/11/09 22:33:13  panther
// Fix name of wndname if token is int resource
//
// Revision 1.6  2003/10/21 16:23:04  panther
// Append icon name to window title to produce 'unique' names to wake
//
// Revision 1.5  2002/10/16 10:22:12  panther
// Modified places to check for a named icon from.  - file/resource, resource
//
// Revision 1.4  2002/04/25 00:05:04  panther
// Added logging of PostQuitMessages/WM_QUIT...
//
// Revision 1.3  2002/04/18 20:42:52  panther
// minor cleanup.
//
// Revision 1.2  2002/04/18 17:48:24  panther
// Added doublclick icon method callback...
//
// need to check if is instanced.
#ifndef PSI_GLOBAL_STRUCTURE_DEFINED
#  define DEFINE_DEFAULT_RENDER_INTERFACE
#endif
#define BTN_FIND 1008
#define BTN_CREATE 1007
#define BTN_RESET 1006
#define BTN_UPDATE 1005
#define TXT_DESCRIPTION 1004
#define BTN_DELETE 1003
#define BTN_COPY 1002
#define EDT_OPTIONVALUE 1001
#define LST_OPTIONMAP 1000
struct query_params
{
	PSI_CONTROL pc;
	TEXTSTR result;
};
typedef struct list_fill_tag
{
	struct {
		uint32_t bSecondLevel : 1;
	} flags;
	PSI_CONTROL pcList;
	int nLevel;
	PLISTITEM pLastItem;
	PODBC odbc;
} LISTFILL, *PLISTFILL;
typedef struct node_data_tag
{
	struct {
		// if it has not been opened, then there is a fake item under....
		uint32_t bOpened : 1;
	} flags;
	POPTION_TREE_NODE ID_Value;
	char description[128];
 // lookin for parent things...
	POPTION_TREE_NODE ID_Option;
	CTEXTSTR option_text;
	uint32_t nLevel;
	PLISTITEM pli_fake;
} NODE_DATA, *PNODE_DATA;
struct instance_local
{
	POPTION_TREE tree;
	PNODE_DATA last_node;
	POPTION_TREE_NODE last_option;
	TEXTCHAR last_value[256];
	int done1;
	int done2;
	int done3;
};
#if HAS_TLS
DeclareThreadLocal struct instance_local *option_thread;
#define l (*option_thread)
#else
struct instance_local *option_thread;
#define l (*option_thread)
#endif
// to support older interface
struct instance_local *default_local;
int CPROC FillList( uintptr_t psv, CTEXTSTR name, POPTION_TREE_NODE ID, int flags );
void CPROC ListItem( uintptr_t psv, PSI_CONTROL pc, PLISTITEM pli )
{
	PNODE_DATA pnd = (PNODE_DATA)GetItemData( pli );
	if( !pnd->flags.bOpened )
	{
		LISTFILL lf;
		lf.flags.bSecondLevel = 0;
		lf.pcList = pc;
		lf.nLevel = pnd->nLevel;
		lf.pLastItem = pli;
		lf.odbc = (PODBC)psv;
		//DeleteListItem( pc, pnd->pli_fake );
		EnumOptionsEx( lf.odbc, pnd->ID_Option, FillList, (uintptr_t)&lf );
		pnd->flags.bOpened = TRUE;
		pnd->pli_fake = NULL;
	}
}
void CPROC HandleItemOpened( uintptr_t psv, PSI_CONTROL pc, PLISTITEM pli, LOGICAL bOpened )
{
	if( bOpened )
	{
		PNODE_DATA pnd = (PNODE_DATA)GetItemData( pli );
		if( pnd )
		{
			if( pnd->flags.bOpened )
				return;
			else
			{
				EnumListItems( pc, pli, ListItem, psv );
				pnd->flags.bOpened = TRUE;
			}
		}
	}
}
int CPROC FillList( uintptr_t psv, CTEXTSTR name, POPTION_TREE_NODE ID, int flags )
{
	PLISTFILL plf = (PLISTFILL)psv;
	LISTFILL lf = *plf;
	PLISTITEM hli;
	lf.nLevel++;
	lf.flags.bSecondLevel = 1;
	//lprintf( "%d - %s (%p)", plf->nLevel, name, ID );
	lf.pLastItem = hli = InsertListItemEx( plf->pcList, plf->pLastItem, plf->nLevel, name );
	{
//Allocate( sizeof( NODE_DATA ) );
		PNODE_DATA pnd = New(NODE_DATA);
		pnd->flags.bOpened = FALSE;
		//pnd->nListIndex = GetItemIndex( pc, hli );
		pnd->option_text = NULL;
//GetOptionValueIndex( ID );
		pnd->ID_Value = ID;
		pnd->ID_Option = ID;
		pnd->nLevel = lf.nLevel;
 //InsertListItemEx( plf->pcList, hli, plf->nLevel+1, "fake" );
		pnd->pli_fake = 0;
		SetItemData( hli,(uintptr_t)pnd );
	}
	if( !plf->flags.bSecondLevel )
		EnumOptionsEx( lf.odbc, ID, FillList, (uintptr_t)&lf );
	plf->pLastItem = lf.pLastItem;
	//lprintf( "done with all children under this node." );
	return TRUE;
}
PUBLIC( int, InitOptionList )( PODBC odbc, PSI_CONTROL pc, uint32_t ID )
{
	LISTFILL lf;
	lf.flags.bSecondLevel = 0;
	lf.pcList = pc;
	lf.nLevel = 0;
	lf.pLastItem = NULL;
	lf.odbc = odbc;
	EnableCommonUpdates( pc, FALSE );
	EnumOptionsEx( odbc, NULL, FillList, (uintptr_t)&lf );
	EnableCommonUpdates( pc, TRUE );
	SmudgeCommon( pc );
	return 0;
}
static void CPROC OptionSelectionChanged( uintptr_t psvUser, PSI_CONTROL pc, PLISTITEM hli )
{
	//static TEXTCHAR buffer[4096];
	PNODE_DATA pnd = (PNODE_DATA)GetItemData( hli );
	if( !option_thread )
		option_thread = default_local;
	l.last_option = pnd->ID_Option;
	l.last_node = pnd;
	if( pnd->option_text )
	{
		size_t buflen;
		char *buffer;
		if( !pnd->ID_Option )
			pnd->ID_Option = GetOptionIndexExx( (PODBC)psvUser, NULL, pnd->option_text, NULL, NULL, NULL, FALSE, FALSE DBG_SRC );
		GetOptionStringValueEx( (PODBC)psvUser, pnd->ID_Option, &buffer, &buflen DBG_SRC );
		StrCpyEx( l.last_value, buffer, buflen );
		SetControlText( GetNearControl( pc, EDT_OPTIONVALUE ), buffer );
	}
	else
	{
		if( pnd->ID_Value )
		{
			//lprintf( "Set value to real value." );
			char *buffer;
			size_t buflen;
			GetOptionStringValueEx( (PODBC)psvUser, pnd->ID_Value, &buffer, &buflen DBG_SRC );
			StrCpyEx( l.last_value, buffer, buflen );
			SetControlText( GetNearControl( pc, EDT_OPTIONVALUE ), buffer );
		}
		else
		{
			//lprintf( "Set to blank value - no value on branch." );
			l.last_value[0] = 0;
			SetControlText( GetNearControl( pc, EDT_OPTIONVALUE ), "" );
		}
	}
}
static void CPROC UpdateValue( uintptr_t psv, PSI_CONTROL pc )
{
	if( !option_thread )
		option_thread = default_local;
	if( l.last_node )
	{
		TEXTCHAR value[256];
		GetControlText( GetNearControl( pc, EDT_OPTIONVALUE ), value, sizeof(value) );
		if( StrCmp( value, l.last_value ) != 0 )
		{
			POPTION_TREE tree = GetOptionTreeExxx( (PODBC)psv, NULL DBG_SRC );
			SetOptionStringValue( tree, l.last_node->ID_Option, value );
		}
	}
}
static void CPROC ResetButton( uintptr_t psv, PSI_CONTROL pc )
{
	if( !option_thread )
		option_thread = default_local;
	ResetList( GetNearControl( pc, LST_OPTIONMAP ) );
	ResetOptionMap( (PODBC)psv );
	l.last_option = NULL;
	InitOptionList( (PODBC)psv, GetNearControl( pc, LST_OPTIONMAP ), LST_OPTIONMAP );
}
static void CPROC DoneButton( uintptr_t psv, PSI_CONTROL pc )
{
	PSI_CONTROL pc_frame = (PSI_CONTROL)GetParentControl( pc );
	DestroyFrame( &pc_frame );
}
static void CPROC DeleteBranch( uintptr_t psv, PSI_CONTROL pc )
{
	if( !option_thread )
		option_thread = default_local;
	if( l.last_option )
		DeleteOption( l.last_option );
	ResetList( GetNearControl( pc, LST_OPTIONMAP ) );
	ResetOptionMap( (PODBC)psv );
	l.last_option = NULL;
	InitOptionList( (PODBC)psv, GetNearControl( pc, LST_OPTIONMAP ), LST_OPTIONMAP );
}
static void CPROC CopyBranchQueryResult( uintptr_t psv, LOGICAL success )
{
	struct query_params  *params = (struct query_params  *)psv;
	if( !option_thread )
		option_thread = default_local;
	if( success ) {
		DuplicateOption( l.last_option, params->result );
		ResetList( GetNearControl( params->pc, LST_OPTIONMAP ) );
		ResetOptionMap( (PODBC)psv );
		l.last_option = NULL;
		InitOptionList( (PODBC)psv, GetNearControl( params->pc, LST_OPTIONMAP ), LST_OPTIONMAP );
	}
}
static void CPROC CopyBranch( uintptr_t psv, PSI_CONTROL pc )
{
	struct query_params  *params = New( struct query_params );
	if( !option_thread )
		option_thread = default_local;
	params->pc = pc;
	params->result = NewArray( TEXTCHAR, 256 );
	// there's a current state already ...
	//GetCurrentSelection( );
	SimpleUserQueryEx( params->result, 256, "Enter New Branch Name", GetFrame( pc ), CopyBranchQueryResult, (uintptr_t)params );
}
static void CPROC CreateEntryQueryResult( uintptr_t psv, LOGICAL success )
{
	struct query_params  *params = (struct query_params  *)psv;
	if( success )
	{
		GetOptionIndexExx( (PODBC)psv, l.last_option, NULL, params->result, NULL, NULL, TRUE, FALSE DBG_SRC );
		//DuplicateOption( l.last_option, result );
		ResetList( GetNearControl( params->pc, LST_OPTIONMAP ) );
		ResetOptionMap( (PODBC)psv );
		l.last_option = NULL;
		InitOptionList( (PODBC)psv, GetNearControl( params->pc, LST_OPTIONMAP ), LST_OPTIONMAP );
	}
	Release( params->result );
	Release( params );
}
static void CPROC CreateEntry( uintptr_t psv, PSI_CONTROL pc )
{
	struct query_params  *params = New( struct query_params );
	params->pc = pc;
	params->result = NewArray( TEXTCHAR, 256 );
	// there's a current state already ...
	//GetCurrentSelection( );
	SimpleUserQueryEx( params->result, 256, "Enter New Branch Name", GetFrame( pc ), CreateEntryQueryResult, (uintptr_t)params );
}
static void CPROC FindEntry( uintptr_t psv, PSI_CONTROL pc );
static PSI_CONTROL CreateOptionFrame( PODBC odbc, LOGICAL tree, int *done )
{
	PSI_CONTROL frame;
	{
		PSI_CONTROL pc;
		PSI_CONTROL list;
#define SIZE_BASE 430
#define NEW_SIZE 720
#define LIST_SIZE           240 - SIZE_BASE + NEW_SIZE
#define RIGHT_START   250 - SIZE_BASE + NEW_SIZE
		frame = CreateFrame( "Edit Options", -1, -1, NEW_SIZE, 320, BORDER_NORMAL, NULL );
		list = MakeListBox( frame, 5, 5, LIST_SIZE, 310, LST_OPTIONMAP, 0 );
		SetListboxIsTree( list, tree );
		SetSelChangeHandler( list, OptionSelectionChanged, (uintptr_t)odbc );
		SetListItemOpenHandler( list, HandleItemOpened, (uintptr_t)odbc );
		MakeEditControl( frame, RIGHT_START, 35, 175, 25, EDT_OPTIONVALUE, "blah", 0 );
		pc = MakeButton( frame, RIGHT_START, 95, 150, 25, BTN_UPDATE, "Update", 0, 0, 0  );
		SetButtonPushMethod( pc, UpdateValue, (uintptr_t)odbc );
		if( tree )
		{
			pc = MakeButton( frame, RIGHT_START, 125, 150, 25, BTN_FIND, "Find Entries", 0, 0, 0  );
			SetButtonPushMethod( pc, FindEntry, (uintptr_t)odbc );
			pc = MakeButton( frame, RIGHT_START, 155, 150, 25, BTN_CREATE, "Make Entry", 0, 0, 0  );
			SetButtonPushMethod( pc, CreateEntry, (uintptr_t)odbc );
		}
		pc = MakeButton( frame, RIGHT_START, 185, 150, 25, BTN_COPY, "Copy", 0, 0, 0  );
		SetButtonPushMethod( pc, CopyBranch, (uintptr_t)odbc );
		pc = MakeButton( frame, RIGHT_START, 215, 150, 25, BTN_DELETE, "Delete", 0, 0, 0  );
		SetButtonPushMethod( pc, DeleteBranch, (uintptr_t)odbc );
		pc = MakeButton( frame, RIGHT_START, 245, 150, 25, BTN_DELETE, "Reset", 0, 0, 0  );
		SetButtonPushMethod( pc, ResetButton, (uintptr_t)odbc );
		if( !done ) {
			pc = MakeButton( frame, NEW_SIZE - 70, 320 - 40, 60, 25, IDCANCEL, "Done", 0, 0, 0 );
			SetButtonPushMethod( pc, DoneButton, (uintptr_t)odbc );
		} else {
			AddCommonButtonsEx( frame, done, "Done", NULL, NULL );
		}
	}
	return frame;
}
struct find_entry_external {
	TEXTSTR result;
	PSI_CONTROL frame;
	PODBC odbc;
};
static void CPROC FindEntryResult( uintptr_t psv, LOGICAL success )
{
	struct find_entry_external *params = (struct find_entry_external*)psv;
	TEXTSTR result = params->result;
	if( success )
	{
		CTEXTSTR name;
		INDEX idx;
		PLIST options = NULL;
		// this is a magic function.
		FindOptions( params->odbc, &options, result );
		if( !options )
		{
			SimpleMessageBox( params->frame, "No Options Found", "Could not find any matching options" );
			Release( params->result );
			Release( params );
			return;
		}
		LIST_FORALL( options, idx, CTEXTSTR, name )
		{
			lprintf( "Found : %s", name );
		}
		{
			int done = 0;
			PSI_CONTROL frame = CreateOptionFrame( params->odbc, FALSE, &done );
			PSI_CONTROL list = GetControl( frame, LST_OPTIONMAP );
			LIST_FORALL( options, idx, CTEXTSTR, name )
			{
				PLISTITEM hli = AddListItem( list, name );
//Allocate( sizeof( NODE_DATA ) );
				PNODE_DATA pnd = New(NODE_DATA);
				pnd->flags.bOpened = TRUE;
				pnd->ID_Value = NULL;
				pnd->ID_Option = NULL;
				pnd->option_text = StrDup( name );
				pnd->nLevel = 0;
 //InsertListItemEx( plf->pcList, hli, plf->nLevel+1, "fake" );
				pnd->pli_fake = 0;
				SetItemData( hli,(uintptr_t)pnd );
				lprintf( "Found : %s", name );
			}
			//InitOptionList( odbc, GetControl( frame, LST_OPTIONMAP ), LST_OPTIONMAP );
			DisplayFrame( frame );
			CommonWait( frame );
			DestroyFrame( &frame );
		}
	}
	Release( params->result );
	Release( params );
}
static void CPROC FindEntry( uintptr_t psv, PSI_CONTROL pc )
{
	struct find_entry_external *params = New( struct find_entry_external );
	params->frame = GetFrame( pc );
//[256];
	params->result = NewArray( TEXTCHAR, 256 );
	params->odbc = (PODBC)psv;
	// there's a current state already ...
	//GetCurrentSelection( );
	SimpleUserQueryEx( params->result, 256, "Enter Option Name to Find", GetFrame( pc )
							, FindEntryResult, (uintptr_t)params );
}
static void OnDisplayConnect( "EditOption Display" )( struct display_app * app, struct display_app_local***local )
{
	PSI_CONTROL frame;
	option_thread = New( struct instance_local );
	MemSet( option_thread, 0, sizeof( option_thread ) );
	(*local) = (struct display_app_local**)&option_thread;
	frame = CreateOptionFrame( NULL, TRUE, &l.done1 );
	InitOptionList( GetOptionODBC( NULL ), GetControl( frame, LST_OPTIONMAP ), LST_OPTIONMAP );
	DisplayFrame( frame );
}
#ifdef EDITOPTION_PLUGIN
PUBLIC( int, EditOptionsEx )
#else
int EditOptionsEx
#endif
                  ( PODBC odbc, PSI_CONTROL parent, LOGICAL wait )
{
// = LoadFrame( "edit.frame", NULL, NULL, 0 );
	PSI_CONTROL frame;
	int done = FALSE;
	if( !odbc )
		odbc = GetOptionODBC( NULL );
	//if( !frame )
	if( !RenderIsInstanced() )
	{
		default_local = option_thread = New( struct instance_local );
		MemSet( option_thread, 0, sizeof( option_thread[0] ) );
		frame = CreateOptionFrame( odbc, TRUE, wait?&done:NULL );
		InitOptionList( odbc, GetControl( frame, LST_OPTIONMAP ), LST_OPTIONMAP );
		//EditFrame( frame, TRUE );
		DisplayFrameOver( frame, parent );
		if( wait ) {
			CommonWait( frame );
			DestroyFrame( &frame );
		}
	}
	else
	{
		while( 1 )
		{
			WakeableSleep( 1000000 );
		}
	}
	return 1;
}
#ifdef EDITOPTION_PLUGIN
PUBLIC( int, EditOptions )
#else
int EditOptions
#endif
( PODBC odbc, PSI_CONTROL parent ) {
	return EditOptionsEx( odbc, parent, FALSE );
}
#ifndef EDITOPTION_PLUGIN
SaneWinMain( argc, argv )
{
	PODBC o = NULL;
	if( argc > 1 )
	{
		o = GetOptionODBC( argv[1] );
	}
	else
		o = GetOptionODBC( NULL );
	EditOptionsEx( o, NULL, TRUE );
	return 0;
}
EndSaneWinMain()
#endif
