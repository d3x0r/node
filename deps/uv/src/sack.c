#define TARGETNAME "node.exe"
#define NO_SSL
#define __STATIC__
#define NO_FILEOP_ALIAS
#define __NO_OPTIONS__
#define NEED_SHLAPI
#define NEED_SHLOBJ
/*CMake Option defined*/
/*
 BLOCKINDEX BAT[BLOCKS_PER_BAT] // link of next blocks; 0 if free, FFFFFFFF if end of file block
 uint8_t  block_data[BLOCKS_PER_BAT][BLOCK_SIZE];
 // (1+BLOCKS_PER_BAT) * BLOCK_SIZE total...
 BAT[0] = first directory cluster; array of struct directory_entry
 BAT[1] = name space; directory offsets land in a block referenced by this chain
 */
#define SACK_VFS_SOURCE
#if 1
/* Includes the system platform as required or appropriate. If
   under a linux system, include appropriate basic linux type
   headers, if under windows pull "windows.h".
   Includes the MOST stuff here ( a full windows.h parse is many
   many lines of code.)                                          */
/* A macro to build a wide character string of __FILE__ */
#define _WIDE__FILE__(n) WIDE(n)
#define WIDE__FILE__ _WIDE__FILE__(__FILE__)
#ifndef STANDARD_HEADERS_INCLUDED
/* multiple inclusion protection symbol */
#define STANDARD_HEADERS_INCLUDED
#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>
#include <stdint.h>
#if _MSC_VER
#  ifdef EXCLUDE_SAFEINT_H
#    define _INTSAFE_H_INCLUDED_
#  endif
 //_MSC_VER
#endif
#ifndef WINVER
#  define WINVER 0x0601
#endif
#if !defined(__LINUX__)
#  ifndef STRICT
#    define STRICT
#  endif
#  define WIN32_LEAN_AND_MEAN
// #define NOGDICAPMASKS             // CC_*, LC_*, PC_*, CP_*, TC_*, RC_
// #define NOVIRTUALKEYCODES         // VK_*
// #define NOWINMESSAGES             // WM_*, EM_*, LB_*, CB_*
// #define NOWINSTYLES               // WS_*, CS_*, ES_*, LBS_*, SBS_*, CBS_*
// #define NOSYSMETRICS              // SM_*
// #define NOMENUS                   // MF_*
// #define NOICONS                   // IDI_*
// #define NOKEYSTATES               // MK_*
// #define NOSYSCOMMANDS             // SC_*
// #define NORASTEROPS               // Binary and Tertiary raster ops
// #define NOSHOWWINDOW              // SW_*
               // OEM Resource values
#  define OEMRESOURCE
// #define NOATOM                    // Atom Manager routines
#  ifndef _INCLUDE_CLIPBOARD
               // Clipboard routines
#    define NOCLIPBOARD
#  endif
// #define NOCOLOR                   // Screen colors
// #define NOCTLMGR                  // Control and Dialog routines
//(spv) #define NODRAWTEXT                // DrawText() and DT_*
// #define NOGDI                     // All GDI defines and routines
// #define NOKERNEL                  // All KERNEL defines and routines
// #define NOUSER                    // All USER defines and routines
#  ifndef _ARM_
#    ifndef _INCLUDE_NLS
                     // All NLS defines and routines
#      define NONLS
#    endif
#  endif
// #define NOMB                      // MB_* and MessageBox()
                  // GMEM_*, LMEM_*, GHND, LHND, associated routines
#  define NOMEMMGR
                // typedef METAFILEPICT
#  define NOMETAFILE
                  // Macros min(a,b) and max(a,b)
#  define NOMINMAX
// #define NOMSG                     // typedef MSG and associated routines
// #define NOOPENFILE                // OpenFile(), OemToAnsi, AnsiToOem, and OF_*
// #define NOSCROLL                  // SB_* and scrolling routines
                 // All Service Controller routines, SERVICE_ equates, etc.
#  define NOSERVICE
//#define NOSOUND                   // Sound driver routines
#  ifndef _INCLUDE_TEXTMETRIC
              // typedef TEXTMETRIC and associated routines
#    define NOTEXTMETRIC
#  endif
// #define NOWH                      // SetWindowsHook and WH_*
// #define NOWINOFFSETS              // GWL_*, GCL_*, associated routines
// #define NOCOMM                    // COMM driver routines
                   // Kanji support stuff.
#  define NOKANJI
                    // Help engine interface.
#  define NOHELP
                // Profiler interface.
#  define NOPROFILER
//#define NODEFERWINDOWPOS          // DeferWindowPos routines
                     // Modem Configuration Extensions
#  define NOMCX
   // no StrCat StrCmp StrCpy etc functions.  (used internally)
#  define NO_SHLWAPI_STRFCNS
  // This also has defines that override StrCmp StrCpy etc... but no override
#  define STRSAFE_NO_DEPRECATE
#  ifdef _MSC_VER
#    ifndef _WIN32_WINDOWS
// needed at least this for what - updatelayeredwindow?
#      define _WIN32_WINDOWS 0x0601
#    endif
#  endif
// INCLUDE WINDOWS.H
#  ifdef __WATCOMC__
#    undef _WINDOWS_
#  endif
#  ifdef UNDER_CE
// just in case windows.h also fails after undef WIN32
// these will be the correct order for primitives we require.
#    include <excpt.h>
#    include <windef.h>
#    include <winnt.h>
#    include <winbase.h>
#    include <wingdi.h>
#    include <wtypes.h>
#    include <winuser.h>
#    undef WIN32
#  endif
#  define _WINSOCKAPI_
#  include <windows.h>
#  undef _WINSOCKAPI_
#  if defined( WIN32 ) && defined( NEED_SHLOBJ )
#    include <shlobj.h>
#  endif
//#  include <windowsx.h>
// we like timeGetTime() instead of GetTickCount()
//#  include <mmsystem.h>
#ifdef __cplusplus
extern "C"
#endif
__declspec(dllimport) DWORD WINAPI timeGetTime(void);
#  if defined( NEED_SHLAPI )
#    include <shlwapi.h>
#    include <shellapi.h>
#  endif
#  ifdef NEED_V4W
#    include <vfw.h>
#  endif
#  if defined( HAVE_ENVIRONMENT )
#    define getenv(name)       OSALOT_GetEnvironmentVariable(name)
#    define setenv(name,val)   SetEnvironmentVariable(name,val)
#  endif
#  define Relinquish()       Sleep(0)
//#pragma pragnoteonly("GetFunctionAddress is lazy and has no library cleanup - needs to be a lib func")
//#define GetFunctionAddress( lib, proc ) GetProcAddress( LoadLibrary( lib ), (proc) )
#  ifdef __cplusplus_cli
#    include <vcclr.h>
 /*lprintf( */
#    define DebugBreak() System::Console::WriteLine(gcnew System::String( WIDE__FILE__ WIDE("(") STRSYM(__LINE__) WIDE(") Would DebugBreak here...") ) );
//typedef unsigned int HANDLE;
//typedef unsigned int HMODULE;
//typedef unsigned int HWND;
//typedef unsigned int HRC;
//typedef unsigned int HMENU;
//typedef unsigned int HICON;
//typedef unsigned int HINSTANCE;
#  endif
 // ifdef unix/linux
#else
#  include <pthread.h>
#  include <sched.h>
#  include <unistd.h>
#  include <sys/time.h>
#  include <errno.h>
#  if defined( __ARM__ )
#    define DebugBreak()
#  else
/* A symbol used to cause a debugger to break at a certain
   point. Sometimes dynamicly loaded plugins can be hard to set
   the breakpoint in the debugger, so it becomes easier to
   recompile with a breakpoint in the right place.
   Example
   <code lang="c++">
   DebugBreak();
	</code>                                                      */
#    ifdef __ANDROID__
#      define DebugBreak()
#    else
#      define DebugBreak()  asm("int $3\n" )
#    endif
#  endif
#  ifdef __ANDROID_OLD_PLATFORM_SUPPORT__
extern __sighandler_t bsd_signal(int, __sighandler_t);
#  endif
// moved into timers - please linnk vs timers to get Sleep...
//#define Sleep(n) (usleep((n)*1000))
#  define Relinquish() sched_yield()
#  define GetLastError() (int32_t)errno
/* return with a THREAD_ID that is a unique, universally
   identifier for the thread for inter process communication. */
#  define GetCurrentProcessId() ((uint32_t)getpid())
#  define GetCurrentThreadId() ((uint32_t)getpid())
  // end if( !__LINUX__ )
#endif
#ifndef NEED_MIN_MAX
#  ifndef NO_MIN_MAX_MACROS
#    define NO_MIN_MAX_MACROS
#  endif
#endif
#ifndef NO_MIN_MAX_MACROS
#  ifdef __cplusplus
#    ifdef __GNUC__
#      ifndef min
#        define min(a,b) ((a)<(b))?(a):(b)
#      endif
#    endif
#  endif
/* Define a min(a,b) macro when the compiler lacks it. */
#  ifndef min
#    define min(a,b) (((a)<(b))?(a):(b))
#  endif
/* Why not add the max macro, also? */
#  ifndef max
#    define max(a,b) (((a)>(b))?(a):(b))
#  endif
#endif
/* please Include sthdrs.h */
/* Define most of the sack core types on which everything else is
   based. Also defines some of the primitive container
   structures. We also handle a lot of platform/compiler
   abstraction here.
   A reFactoring for stdint.h and uint32_t etc would be USEFUL!
   where types don't exist, define them as apprpritate types instead.
But WHO doesn't have stdint?  BTW is sizeof( size_t ) == sizeof( void* )
   This is automatically included with stdhdrs.h; however, when
   including sack_types.h, the minimal headers are pulled. */
#define HAS_STDINT
//#define USE_SACK_CUSTOM_MEMORY_ALLOCATION
	// this has to be a compile option (option from cmake)
   // enables debug dump mem...
#ifdef USE_SACK_CUSTOM_MEMORY_ALLOCATION
#  define USE_CUSTOM_ALLOCER 1
#else
#  define USE_CUSTOM_ALLOCER 0
#endif
#ifndef __64__
#  if defined( _WIN64 ) || defined( ENVIRONMENT64 ) || defined( __x86_64__ ) || defined( __ia64 ) || defined( __ppc64__ ) || defined( __LP64__ )
#    define __64__ 1
#  endif
#endif
#ifdef _MSC_VER
#  ifndef _WIN32_WINNT
#    define _WIN32_WINNT 0x501
#  endif
#  ifndef WIN32
#    ifdef _WIN32
#      define WIN32 _WIN32
#    endif
#  endif
// force windows on __MSVC
#  ifndef WIN32
#    define WIN32
#  endif
#endif
#if !defined( __NO_THREAD_LOCAL__ ) && ( defined( _MSC_VER ) || defined( __WATCOMC__ ) )
#  define HAS_TLS 1
#  define DeclareThreadLocal static __declspec(thread)
#  define DeclareThreadVar __declspec(thread)
#elif !defined( __NO_THREAD_LOCAL__ ) && ( defined( __GNUC__ ) )
#  define HAS_TLS 1
#  define DeclareThreadLocal static __thread
#  define DeclareThreadVar __thread
#else
#  define DeclareThreadLocal static
#  define DeclareThreadVar
#endif
#ifdef __cplusplus_cli
// these things define a type called 'Byte'
	// which causes confusion... so don't include vcclr for those guys.
#  ifdef SACK_BAG_EXPORTS
// maybe only do this while building sack_bag project itself...
#    if !defined( ZCONF_H )        && !defined( __FT2_BUILD_GENERIC_H__ )        && !defined( ZUTIL_H )        && !defined( SQLITE_PRIVATE )        && !defined( NETSERVICE_SOURCE )        && !defined( LIBRARY_DEF )
//using namespace System;
#    endif
#  endif
#endif
// Defined for building visual studio monolithic build.  These symbols are not relavent with cmakelists.
#ifdef SACK_BAG_EXPORTS
#  define SACK_BAG_CORE_EXPORTS
// exports don't really matter with CLI compilation.
#  ifndef BAG
//#ifndef TARGETNAME
//#  define TARGETNAME "sack_bag.dll"  //$(TargetFileName)
//#endif
#    ifndef __cplusplus_cli
// cli mode, we use this directly, and build the exports in sack_bag.dll directly
#    else
#      define LIBRARY_DEADSTART
#    endif
#define USE_SACK_FILE_IO
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define MEM_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SYSLOG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define _TYPELIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define HTTP_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define TIMER_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define IDLE_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define CLIENTMSG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define FRACTION_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define NETWORK_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define CONFIGURATION_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define FILESYSTEM_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SYSTEM_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define FILEMONITOR_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define VECTOR_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SHA1_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define CONSTRUCT_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define PROCREG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SQLPROXY_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define TYPELIB_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define JSON_EMITTER_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SERVICE_SOURCE
#  ifndef __NO_SQL__
#    ifndef __NO_OPTIONS__
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.    and not NO_SQL and not NO_OPTIONS   */
#      define SQLGETOPTION_SOURCE
#    endif
#  endif
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define PSI_SOURCE
#  ifdef _MSC_VER
#    ifndef JPEG_SOURCE
//wouldn't matter... the external things wouldn't need to define this
//#error projects were not generated with CMAKE, and JPEG_SORUCE needs to be defined
#    endif
//#define JPEG_SOURCE
//#define __PNG_LIBRARY_SOURCE__
//#define FT2_BUILD_LIBRARY   // freetype is internal
//#define FREETYPE_SOURCE		// build Dll Export
#  endif
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define MNG_BUILD_DLL
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define BAGIMAGE_EXPORTS
/* Defined when SACK_BAG_EXPORTS is defined. This was an
 individual library module once upon a time.           */
#ifndef IMAGE_LIBRARY_SOURCE
#  define IMAGE_LIBRARY_SOURCE
#endif
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SYSTRAY_LIBRARAY
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SOURCE_PSI2
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define VIDEO_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
	/* define RENDER SOURCE when building monolithic. */
#     ifndef RENDER_LIBRARY_SOURCE
#       define RENDER_LIBRARY_SOURCE
#     endif
#     ifndef __NO_WIN32API__
// this is moved to a CMake option (based on whter it's arm or not right now)
//#define _OPENGL_ENABLED
#     endif
// define a type that is a public name struct type...
// good thing that typedef and struct were split
// during the process of port to /clr option.
//#define PUBLIC_TYPE public
#  else
//#define PUBLIC_TYPE
#    ifdef __cplusplus_CLR
//using namespace System;
#    endif
#  endif
#endif
 // wchar for X_16 definition
#include <wchar.h>
#include <sys/types.h>
#include <sys/stat.h>
#ifndef MY_TYPES_INCLUDED
#define MY_TYPES_INCLUDED
// include this before anything else
// thereby allowing us to redefine exit()
 // CHAR_BIT
#include <limits.h>
 // typelib requires this
#include <stdarg.h>
#ifdef _MSC_VER
#ifndef UNDER_CE
 // memlib requires this, and it MUST be included befoer string.h if it is used.
#include <intrin.h>
#endif
#endif
 // typelib requires this
#include <string.h>
#if !defined( WIN32 ) && !defined( _WIN32 ) && !defined( _PNACL )
#include <dlfcn.h>
#endif
#if defined( _MSC_VER )
// disable pointer conversion warnings - wish I could disable this
// according to types...
//#pragma warning( disable:4312; disable:4311 )
// disable deprication warnings of snprintf, et al.
//#pragma warning( disable:4996 )
#define EMPTY_STRUCT struct { char nothing[]; }
#endif
#if defined( __WATCOMC__ )
#define EMPTY_STRUCT char
#endif
#ifdef __cplusplus
/* Could also consider defining 'SACK_NAMESPACE' as 'extern "C"
   ' {' and '..._END' as '}'                                    */
#define SACK_NAMESPACE namespace sack {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define SACK_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _CONTAINER_NAMESPACE namespace containers {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _CONTAINER_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _LINKLIST_NAMESPACE namespace list {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _LINKLIST_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _DATALIST_NAMESPACE namespace data_list {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _DATALIST_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _SETS_NAMESPACE namespace sets {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _SETS_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _TEXT_NAMESPACE namespace text {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _TEXT_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define TEXT_NAMESPACE SACK_NAMESPACE _CONTAINER_NAMESPACE namespace text {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define TEXT_NAMESPACE_END  } _CONTAINER_NAMESPACE_END SACK_NAMESPACE_END
#else
/* Define the sack namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define SACK_NAMESPACE
/* Define the sack namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define SACK_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _CONTAINER_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _CONTAINER_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _LINKLIST_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _LINKLIST_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _DATALIST_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _DATALIST_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _SETS_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _SETS_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _TEXT_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _TEXT_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define TEXT_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define TEXT_NAMESPACE_END
#endif
/* declare composite SACK_CONTAINER namespace to declare sack::container in a single line */
#define SACK_CONTAINER_NAMESPACE SACK_NAMESPACE _CONTAINER_NAMESPACE
/* declare composite SACK_CONTAINER namespace to close sack::container in a single line */
#define SACK_CONTAINER_NAMESPACE_END _CONTAINER_NAMESPACE_END SACK_NAMESPACE_END
/* declare composite SACK_CONTAINER namespace to declare sack::container::list in a single line */
#define SACK_CONTAINER_LINKLIST_NAMESPACE SACK_CONTAINER_NAMESPACE _LISTLIST_NAMESPACE
/* declare composite SACK_CONTAINER namespace to close sack::container::list in a single line */
#define SACK_CONTAINER_LINKLIST_NAMESPACE_END _LISTLIST_NAMESPACE_END SACK_CONTAINER_NAMESPACE
// this symbols is defined to enforce
// the C Procedure standard - using a stack, and resulting
// in EDX:EAX etc...
#define CPROC
#ifdef SACK_BAG_EXPORTS
# ifdef BUILD_GLUE
// this is used as the export method appropriate for C#?
#  define EXPORT_METHOD [DllImport(LibName)] public
# else
#  ifdef __cplusplus_cli
#   if defined( __STATIC__ ) || defined( __LINUX__ ) || defined( __ANDROID__ )
#     define EXPORT_METHOD
#     define IMPORT_METHOD extern
#   else
#     define EXPORT_METHOD __declspec(dllexport)
#     define IMPORT_METHOD __declspec(dllimport)
#   endif
#   define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#   define LITERAL_LIB_IMPORT_METHOD extern
//__declspec(dllimport)
#  else
#   if defined( __STATIC__ ) || defined( __LINUX__ ) || defined( __ANDROID__ )
#      define EXPORT_METHOD
#      define IMPORT_METHOD extern
#    else
/* Method to declare functions exported from a DLL. (nothign on
   LINUX or building statically, but __declspec(dllimport) on
   windows )                                                    */
#      define EXPORT_METHOD __declspec(dllexport)
/* method to define a function which will be Imported from a
   library. Under windows, this is probably
   __declspec(dllimport). Under linux this is probably 'extern'. */
#      define IMPORT_METHOD __declspec(dllimport)
#    endif
#      define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#      define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
#  endif
# endif
#else
# if ( !defined( __STATIC__ ) && defined( WIN32 ) && !defined( __cplusplus_cli) )
#  define EXPORT_METHOD __declspec(dllexport)
#  define IMPORT_METHOD __declspec(dllimport)
#  define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#  define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
# else
// MRT:  This is needed.  Need to see what may be defined wrong and fix it.
#  if defined( __LINUX__ ) || defined( __STATIC__ )
#    define EXPORT_METHOD
#    define IMPORT_METHOD extern
#    define LITERAL_LIB_EXPORT_METHOD
#    define LITERAL_LIB_IMPORT_METHOD extern
#  else
#    define EXPORT_METHOD __declspec(dllexport)
#    define IMPORT_METHOD __declspec(dllimport)
/* Define how methods in LITERAL_LIBRARIES are exported.
   literal_libraries are libraries that are used for plugins,
   and are dynamically loaded by code. They break the rules of
   system prefix and suffix extensions. LITERAL_LIBRARIES are
   always dynamic, and never static.                           */
#    define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
/* Define how methods in LITERAL_LIBRARIES are imported.
   literal_libraries are libraries that are used for plugins,
   and are dynamically loaded by code. They break the rules of
   system prefix and suffix extensions. LITERAL_LIBRARIES are
   always dynamic, and never static.                           */
#    define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
#  endif
# endif
#endif
// used when the keword specifying a structure is packed
// needs to prefix the struct keyword.
#define PREFIX_PACKED
// private thing left as a note, and forgotten.  some compilers did not define offsetof
#define my_offsetof( ppstruc, member ) ((uintptr_t)&((*ppstruc)->member)) - ((uintptr_t)(*ppstruc))
SACK_NAMESPACE
#ifdef BCC16
#define __inline__
#define MAINPROC(type,name)     type _pascal name
// winproc is intended for use at libmain/wep/winmain...
#define WINPROC(type,name)      type _far _pascal _export name
// callbackproc is for things like timers, dlgprocs, wndprocs...
#define CALLBACKPROC(type,name) type _far _pascal _export name
#define PUBLIC(type,name)       type STDPROC _export name
 /* here would be if dwReason == process_attach */
#define LIBMAIN() WINPROC(int, LibMain)(HINSTANCE hInstance, WORD wDataSeg, WORD wHeapSize, LPSTR lpCmdLine )		 { {
 /* end if */
 /*endproc*/
#define LIBEXIT() } }	    int STDPROC WEP(int nSystemExit )  {
#define LIBMAIN_END()  }
// should use this define for all local defines...
// this will allow one place to modify ALL _pascal or not to _pascal decls.
#define STDPROC _far _pascal
#endif
#if defined( __LCC__ ) || defined( _MSC_VER ) || defined(__DMC__) || defined( __WATCOMC__ )
#ifdef __WATCOMC__
#undef CPROC
#define CPROC __cdecl
#define STDPROC __cdecl
#ifndef __WATCOMC__
// watcom windef.h headers define this
#define STDCALL _stdcall
#endif
#if __WATCOMC__ >= 1280
// watcom windef.h headers no longer define this.
#define STDCALL __stdcall
#endif
#undef PREFIX_PACKED
#define PREFIX_PACKED _Packed
#else
#undef CPROC
//#error blah
#define CPROC __cdecl
#define STDPROC
#define STDCALL _stdcall
#endif
#define far
#define huge
#define near
#define _far
#define _huge
#define _near
/* portability type for porting legacy 16 bit applications. */
/* portability macro for legacy 16 bit applications. */
#define __far
#ifndef FAR
#define FAR
#endif
//#define HUGE
//#ifndef NEAR
//#define NEAR
//#endif
#define _fastcall
#ifdef __cplusplus
#ifdef __cplusplus_cli
#define PUBLIC(type,name) extern "C"  LITERAL_LIB_EXPORT_METHOD type CPROC name
#else
//#error what the hell!?
// okay Public functions are meant to be loaded with LoadFuncion( "library" , "function name"  );
#define PUBLIC(type,name) extern "C"  LITERAL_LIB_EXPORT_METHOD type CPROC name
#endif
#else
#define PUBLIC(type,name) LITERAL_LIB_EXPORT_METHOD type CPROC name
#endif
#define MAINPROC(type,name)  type WINAPI name
#define WINPROC(type,name)   type WINAPI name
#define CALLBACKPROC(type,name) type CALLBACK name
#if defined( __WATCOMC__ )
#define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(_WIDE(TARGETNAME)) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#define LIBMAIN_END() }
#else
#ifdef TARGETNAME
#define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(_WIDE(TARGETNAME)) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#else
#define LIBMAIN()   TARGETNAME_NOT_DEFINED
#endif
#define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#define LIBMAIN_END() }
#endif
#define PACKED
#endif
#if defined( __GNUC__ )
#  ifndef STDPROC
#    define STDPROC
#  endif
#  ifndef STDCALL
 // for IsBadCodePtr which isn't a linux function...
#    define STDCALL
#  endif
#  ifndef WINAPI
#    ifdef __LINUX__
#       define WINAPI
#    else
#       define WINAPI __stdcall
#    endif
#  endif
#  ifndef PASCAL
//#define PASCAL
#  endif
#  define WINPROC(type,name)   type WINAPI name
#  define CALLBACKPROC( type, name ) type name
#  define PUBLIC(type,name) EXPORT_METHOD type CPROC name
#  define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(TARGETNAME) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#  define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#  define LIBMAIN_END()  }
/* Portability Macro for porting legacy code forward. */
#  define FAR
#  define NEAR
//#define HUGE
#  define far
#  define near
#  define huge
#  define PACKED __attribute__((packed))
#endif
#if defined( BCC32 )
#define far
#define huge
/* define obsolete keyword for porting purposes */
/* defined for porting from 16 bit environments */
#define near
/* portability macro for legacy 16 bit applications. */
#define _far
#define _huge
#define _near
/* portability type for porting to compilers that don't inline. */
/* portability macro for legacy 16 bit applications. */
#define __inline__
#define MAINPROC(type,name)     type _pascal name
// winproc is intended for use at libmain/wep/winmain...
#define WINPROC(type,name)      EXPORT_METHOD type _pascal name
// callbackproc is for things like timers, dlgprocs, wndprocs...
#define CALLBACKPROC(type,name) EXPORT_METHOD type _stdcall name
#define STDCALL _stdcall
#define PUBLIC(type,name)        type STDPROC name
#ifdef __STATIC__
			/*Log( WIDE("Library Enter" ) );*/
#define LIBMAIN() static WINPROC(int, LibMain)(HINSTANCE hInstance, DWORD dwReason, void *unused )		 { if( dwReason == DLL_PROCESS_ATTACH ) {
 /* end if */
#define LIBEXIT() } if( dwReason == DLL_PROCESS_DETACH ) {
#define LIBMAIN_END()  } return 1; }
#else
			/*Log( WIDE("Library Enter" ) );*/
#define LIBMAIN() WINPROC(int, LibMain)(HINSTANCE hInstance, DWORD dwReason, void *unused )		 { if( dwReason == DLL_PROCESS_ATTACH ) {
 /* end if */
#define LIBEXIT() } if( dwReason == DLL_PROCESS_DETACH ) {
#define LIBMAIN_END()  } return 1; }
#endif
// should use this define for all local defines...
// this will allow one place to modify ALL _pascal or not to _pascal decls.
#define STDPROC _pascal
#define PACKED
#endif
#define TOCHR(n) #n[0]
#define TOSTR(n) WIDE(#n)
#define STRSYM(n) TOSTR(n)
#define _WIDE__FILE__(n) WIDE(n)
#define WIDE__FILE__ _WIDE__FILE__(__FILE__)
/* a constant text string that represents the current source
   filename and line... fourmated as "source.c(11) :"        */
#define FILELINE  TEXT(__FILE__) WIDE("(" ) TEXT(STRSYM(__LINE__))WIDE(" : " ))
#if defined( _MSC_VER ) || defined( __PPCCPP__ )
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnote(msg) message( FILELINE msg )
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnoteonly(msg) message( msg )
#else
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnote(msg) msg
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnoteonly(msg) msg
#endif
/* specify a consistant macro to pass current file and line information.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_SRC         , (CTEXTSTR)_WIDE(__FILE__), __LINE__
/* specify a consistant macro to pass current file and line information, to functions which void param lists.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDSRC     (CTEXTSTR)_WIDE(__FILE__), __LINE__
//#define FILELINE_LEADSRC     (CTEXTSTR)_WIDE(__FILE__), __LINE__,
/* specify a consistant macro to define file and line parameters, to functions with otherwise void param lists.  This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDPASS    CTEXTSTR pFile, uint32_t nLine
//#define FILELINE_LEADPASS    CTEXTSTR pFile, uint32_t nLine,
/* specify a consistant macro to define file and line parameters.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_PASS        , CTEXTSTR pFile, uint32_t nLine
/* specify a consistant macro to forward file and line parameters.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_RELAY       , pFile, nLine
/* specify a consistant macro to forward file and line parameters, to functions which have void parameter lists without this information.  This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDRELAY   pFile, nLine
/* specify a consistant macro to format file and line information for printf formated strings. */
#define FILELINE_FILELINEFMT WIDE("%s(%") _32f WIDE("): ")
#define FILELINE_FILELINEFMT_MIN WIDE("%s(%") _32f WIDE(")")
#define FILELINE_NULL        , NULL, 0
#define FILELINE_VOIDNULL    NULL, 0
/* define static parameters which are the declaration's current file and line, for stubbing in where debugging is being stripped.
  usage
    FILELINE_VARSRC: // declare pFile and nLine variables.
	*/
#define FILELINE_VARSRC       CTEXTSTR pFile = _WIDE(__FILE__); uint32_t nLine = __LINE__
// this is for passing FILE, LINE information to allocate
// useful during DEBUG phases only...
// drop out these debug relay paramters for managed code...
// we're going to have the full call frame managed and known...
#if !defined( _DEBUG ) && !defined( _DEBUG_INFO )
#  if defined( __LINUX__ ) && !defined( __PPCCPP__ )
//#warning "Setting DBG_PASS and DBG_FORWARD to be ignored."
#  else
//#pragma pragnoteonly("Setting DBG_PASS and DBG_FORWARD to be ignored"  )
#  endif
#define DBG_AVAILABLE   0
/* in NDEBUG mode, pass nothing */
#define DBG_SRC
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_VOIDSRC
/* <combine sack::DBG_PASS>
   \#define DBG_LEADSRC in NDEBUG mode, declare (void) */
/* <combine sack::DBG_PASS>
   \ \                      */
#define DBG_VOIDPASS    void
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_PASS
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_RELAY
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_VOIDRELAY
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_FILELINEFMT
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_FILELINEFMT_MIN
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing
   Example
   printf( DBG_FILELINEFMT ": extra message" DBG_PASS ); */
#define DBG_VARSRC
#else
	// these DBG_ formats are commented out from duplication in sharemem.h
#  if defined( __LINUX__ ) && !defined( __PPCCPP__ )
//#warning "Setting DBG_PASS and DBG_FORWARD to work."
#  else
//#pragma pragnoteonly("Setting DBG_PASS and DBG_FORWARD to work"  )
#  endif
// used to specify whether debug information is being passed - can be referenced in compiled code
#define DBG_AVAILABLE   1
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_SRC */
#define DBG_SRC         FILELINE_SRC
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDSRC */
#define DBG_VOIDSRC     FILELINE_VOIDSRC
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDPASS */
#define DBG_VOIDPASS    FILELINE_VOIDPASS
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
/* Example
   This example shows forwarding debug information through a
   chain of routines.
   <code lang="c++">
   void ReportFunction( int sum DBG_PASS )
   {
       printf( "%s(%d):started this whole mess\\n" DBG_RELAY );
   }
   void TrackingFunction( int a, int b DBG_PASS )
   {
       ReportFunction( a+b, DBG_RELAY );
   }
   void CallTrack( void )
   {
       TrackingFunction( 1, 2 DBG_SRC );
   }
   </code>
   In this example, the debug information is passed to the
   logging system. This allows logging to blame the user
   application for allocations, releases, locks, etc...
   <code lang="c++">
   void MyAlloc( int size DBG_PASS )
   {
       _lprintf( DBG_RELAY )( ": alloc %d\\n", size );
   }
   void g( void )
   {
       lprintf( "Will Allocate %d\\n", 32 );
       MyAlloc( 32 DBG_SRC );
   }
   </code>
   This example uses the void argument macros
   <code>
   void SimpleFunction( DBG_VOIDPASS )
   {
       // this function usually has (void) parameters.
   }
   void f( void )
   {
       SimpleFunction( DBG_VOIDSRC );
   }
   </code>
   Description
   in NDEBUG mode, pass nothing.
   This function allows specification of DBG_RELAY or DBG_SRC
   under debug compilation. Otherwise, the simple AddLink macro
   should be used. DBG_RELAY can be used to forward file and
   line information which has been passed via DBG_PASS
   declaration in the function parameters.
   This is a part of a set of macros which allow additional
   logging information to be passed.
   These 3 are the most commonly used.
   DBG_SRC - this passes the current __FILE__, __LINE__
   \parameters.
   DBG_PASS - this is used on a function declaration, is a
   filename and line number from DBG_SRC or DBG_RELAY.
   DBG_RELAY - this passes the file and line passed to this
   function to another function with DBG_PASS defined on it.
   DBG_VOIDPASS - used when the argument list is ( void )
   without debugging information.
   DBG_VOIDSRC - used to call a function who's argument list is
   ( void ) without debugging information.
   DBG_VOIDRELAY - pass file and line information forward to
   another function, who's argument list is ( void ) without
   debugging information.
   Remarks
   The SACK library is highly instrumented with this sort of
   information. Very commonly the only difference between a
   specific function called 'MyFunctionName' and
   'MyFunctionNameEx' is the addition of debug information
   tracking.
   The following code blocks show the evolution added to add
   instrumentation...
   <code lang="c++">
   int MyFunction( int param )
   {
       // do stuff
   }
   int CallingFunction( void )
   {
       return MyFunction();
   }
   </code>
   Pretty simple code, a function that takes a parameter, and a
   function that calls it.
   The first thing is to extend the called function.
   <code>
   int MyFunctionEx( int param DBG_PASS )
   {
       // do stuff
   }
   </code>
   And provide a macro for everyone else calling the function to
   automatically pass their file and line information
   <code lang="c++">
   \#define MyFunction(param)  MyFunctionEx(param DBG_SRC)
   </code>
   Then all-together
   <code>
   \#define MyFunction(param)  MyFunctionEx(param DBG_SRC)
   int MyFunctionEx( int param DBG_PASS )
   {
       // do stuff
   }
   int CallingFunction( void )
   {
       // and this person calling doesn't matter
       // does require a recompile of source.
       return MyFunction( 3 );
   }
   </code>
   But then... what if CallingFunction decided wasn't really the
   one at fault, or responsible for the allocation, or other
   issue being tracked, then she could be extended....
   <code>
   int CallingFunctionEx( DBG_VOIDPASS )
   \#define CallingFunction() CallingFunction( DBG_VOIDSRC )
   {
       // and this person calling doesn't matter
       // does require a recompile of source.
       return MyFunction( 1 DBG_RELAY );
   }
   </code>
   Now, calling function will pass it's callers information to
   MyFunction....
   Why?
   Now, when you call CreateList, your code callng the list
   creation method is marked as the one who allocates the space.
   Or on a DeleteList, rather than some internal library code
   being blamed, the actual culprit can be tracked and
   identified, because it's surely not the fault of CreateList
   that the reference to the memory for the list wasn't managed
   correctly.
   Note
   It is important to note, every usage of these macros does not
   have a ',' before them. This allows non-debug code to
   eliminate these extra parameters cleanly. If the ',' was
   outside of the macro, then it would remain on the line, and
   an extra parameter would have be be passed that was unused.
   This is also why DBG_VOIDPASS exists, because in release mode
   this is substituted with 'void'.
   In Release mode, DBG_VOIDRELAY becomes nothing, but when in
   debug mode, DBG_RELAY has a ',' in the macro, so without a
   paramter f( DBG_RELAY ) would fail; on expansion this would
   be f( , pFile, nLine ); (note the extra comma, with no
   parameter would be a syntax error.                            */
#define DBG_PASS        FILELINE_PASS
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_RELAY */
#define DBG_RELAY       FILELINE_RELAY
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDRELAY */
#define DBG_VOIDRELAY   FILELINE_VOIDRELAY
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_FILELINEFMT */
#define DBG_FILELINEFMT FILELINE_FILELINEFMT
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_FILELINEFMT_MIN */
#define DBG_FILELINEFMT_MIN FILELINE_FILELINEFMT_MIN
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VARSRC */
#define DBG_VARSRC      FILELINE_VARSRC
#endif
// cannot declare _0 since that overloads the
// vector library definition for origin (0,0,0,0,...)
//typedef void             _0; // totally unusable to declare 0 size things.
/* the only type other than when used in a function declaration that void is valid is as a pointer to void. no _0 type exists (it does, but it's in vectlib, and is an origin vector)*/
typedef void             *P_0;
/*
 * several compilers are rather picky about the types of data
 * used for bit field declaration, therefore this type
 * should be used instead of uint32_t (DWORD)
 */
typedef unsigned int  BIT_FIELD;
// have to do this on a per structure basis - otherwise
// any included headers with structures to use will get FUCKED
#ifndef PACKED
#define PACKED
#endif
/* An pointer to a volatile unsigned integer type that is 64 bits long. */
//typedef volatile uint64_t  *volatile int64_t*;
/* An pointer to a volatile pointer size type that is as long as a pointer. */
typedef volatile uintptr_t        *PVPTRSZVAL;
/* an unsigned type meant to index arrays.  (By convention, arrays are not indexed negatively.)  An index which is not valid is INVALID_INDEX, which equates to 0xFFFFFFFFUL or negative one cast as an INDEX... ((INDEX)-1). */
typedef size_t         INDEX;
/* An index which is not valid; equates to 0xFFFFFFFFUL or negative one cast as an INDEX... ((INDEX)-1). */
#define INVALID_INDEX ((INDEX)-1)
#ifdef __CYGWIN__
typedef unsigned short wchar_t;
#endif
// may consider changing this to uint16_t* for unicode...
typedef wchar_t X_16;
/* This is a pointer to wchar_t. A 16 bit value that is
   character data, and is not signed or unsigned.       */
typedef wchar_t *PX_16;
#if defined( UNICODE ) || defined( SACK_COM_OBJECT )
//should also consider revisiting code that was updated for TEXTCHAR to char conversion methods...
#  ifdef _MSC_VER
#    ifdef UNDER_CE
#      define NULTERM
#    else
#      define NULTERM __nullterminated
#    endif
#  else
#    define NULTERM
#  endif
#define WIDE(s)  L##s
#define _WIDE(s)  WIDE(s)
#define cWIDE(s)  s
#define _cWIDE(s)  cWIDE(s)
 // constant text string content
typedef NULTERM          const X_16      *CTEXTSTR;
 // pointer to constant text string content
typedef NULTERM          CTEXTSTR        *PCTEXTSTR;
typedef NULTERM          X_16            *TEXTSTR;
/* a text 16 bit character  */
typedef X_16             TEXTCHAR;
#else
#define WIDE(s)   s
#define _WIDE(s)  s
#define cWIDE(s)   s
/* Modified WIDE wrapper that actually forces non-unicode
   string.                                                */
#define _cWIDE(s)  s
// constant text string content
typedef const char     *CTEXTSTR;
/* A non constant array of TEXTCHAR. A pointer to TEXTCHAR. A
   pointer to non-constant characters. (A non-static string
   probably)                                                  */
typedef char           *TEXTSTR;
#if defined( __LINUX__ ) && defined( __cplusplus )
// pointer to constant text string content
typedef TEXTSTR const  *PCTEXTSTR;
#else
// char const *const *
typedef CTEXTSTR const *PCTEXTSTR;
#endif
/* a text 8 bit character  */
typedef char            TEXTCHAR;
#endif
/* a character rune.  Strings should be interpreted as UTF-8 or 16 depending on UNICODE compile option.
   GetUtfChar() from strings.  */
typedef uint32_t             TEXTRUNE;
/* Used to handle returned values that are invalid runes; past end or beginning of string for instance */
#define INVALID_RUNE  0x80000000
//typedef enum { FALSE, TRUE } LOGICAL; // smallest information
#ifndef FALSE
#define FALSE 0
/* Define TRUE when not previously defined in the platform. TRUE
   is (!FALSE) so anything not 0 is true.                        */
#define TRUE (!FALSE)
#endif
/* Meant to hold boolean and only boolean values. Should be
   implemented per-platform as appropriate for the bool type the
   compiler provides.                                            */
typedef uint32_t LOGICAL;
/* This is a pointer. It is a void*. It is meant to point to a
   single thing, and cannot be used to reference arrays of bytes
   without recasting.                                            */
typedef P_0 POINTER;
/* This is a pointer to constant data. void const *. Compatible
   with things like char const *.                               */
typedef const void *CPOINTER;
SACK_NAMESPACE_END
//------------------------------------------------------
// formatting macro defintions for [vsf]printf output of the above types
#if !defined( _MSC_VER ) || ( _MSC_VER >= 1900 )
#define __STDC_FORMAT_MACROS
#include <inttypes.h>
#endif
SACK_NAMESPACE
/* 16 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16f   WIDE("u" )
/* 16 bit hex output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16fx   WIDE("x" )
/* 16 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16fX   WIDE("X" )
/* 16 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\>               */
#define _16fs   WIDE("d" )
/* 8 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8f   WIDE("u" )
/* 8 bit hex output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8fx   WIDE("x" )
/* 8 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8fX   WIDE("X" )
/* 8 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\>               */
#define _8fs   WIDE("d" )
#if defined( __STDC_FORMAT_MACROS )
#  define _32f   _WIDE( PRIu32 )
#  define _32fx   _WIDE( PRIx32 )
#  define _32fX   _WIDE( PRIX32 )
#  define _32fs   _WIDE( PRId32 )
#  define _64f    _WIDE(PRIu64)
#  define _64fx   _WIDE(PRIx64)
#  define _64fX   _WIDE(PRIX64)
#  define _64fs   _WIDE(PRId64)
#  define _64f    _WIDE(PRIu64)
#  define _64fx   _WIDE(PRIx64)
#  define _64fX   _WIDE(PRIX64)
#  define _64fs   _WIDE(PRId64)
// non-unicode strings
#  define c_32f    PRIu32
#  define c_32fx   PRIx32
#  define c_32fX   PRIX32
#  define c_32fs   PRId32
#  define c_64f    PRIu64
#  define c_64fx   PRIx64
#  define c_64fX   PRIX64
#  define c_64fs   PRId64
#else
#  define _32f   WIDE("u" )
#  define _32fx   WIDE("x" )
#  define _32fX   WIDE("X" )
#  define _32fs   WIDE("d" )
#  define c_32f   "u"
#  define c_32fx  "x"
#  define c_32fX  "X"
#  define c_32fs  "d"
#  define c_64f    "llu"
#  define c_64fx   "llx"
#  define c_64fX   "llX"
#  define c_64fs   "lld"
#endif
#if defined( UNICODE )
#  define _cstring_f WIDE("s")
#  define _string_f WIDE("S")
#  define _ustring_f WIDE("S")
#else
#  define _cstring_f WIDE("s")
#  define _string_f WIDE("s")
#  define _ustring_f WIDE("S")
#endif
#if defined( __64__ )
#  if defined( __STDC_FORMAT_MACROS )
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f    _WIDE( PRIu64 )
#      define _size_fx   _WIDE( PRIx64 )
#      define _size_fX   _WIDE( PRIX64 )
#      define _size_fs   _WIDE( PRId64 )
#      define c_size_f    PRIu64
#      define c_size_fx   PRIx64
#      define c_size_fX   PRIX64
#      define c_size_fs   PRId64
#    else
#      define _size_f    WIDE( "zu" )
#      define _size_fx   WIDE( "zx" )
#      define _size_fX   WIDE( "zX" )
#      define _size_fs   WIDE( "zd" )
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs _WIDE( PRIuPTR )
#    define _PTRSZVALfx _WIDE( PRIxPTR )
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  else
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f    _64f
#      define _size_fx   _64fx
#      define _size_fX   _64fX
#      define _size_fs   _64fs
#      define c_size_f   c_64f
#      define c_size_fx  c_64fx
#      define c_size_fX  c_64fX
#      define c_size_fs  c_64fs
#    else
#      define _size_f    WIDE( "zu" )
#      define _size_fx   WIDE( "zx" )
#      define _size_fX   WIDE( "zX" )
#      define _size_fs   WIDE( "zd" )
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs _WIDE( PRIuPTR )
#    define _PTRSZVALfx _WIDE( PRIxPTR )
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  endif
#else
#  if defined( __STDC_FORMAT_MACROS )
      // this HAS been fixed in UCRT - 2015!  but it'll take 5 years before everyone has that...
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f    _WIDE( PRIu32 )
#      define _size_fx   _WIDE( PRIx32 )
#      define _size_fX   _WIDE( PRIX32 )
#      define _size_fs   _WIDE( PRId32 )
#      define c_size_f    PRIu32
#      define c_size_fx   PRIx32
#      define c_size_fX   PRIX32
#      define c_size_fs   PRId32
#    else
#      define _size_f    WIDE( "zu" )
#      define _size_fx   WIDE( "zx" )
#      define _size_fX   WIDE( "zX" )
#      define _size_fs   WIDE( "zd" )
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs _WIDE( PRIuPTR )
#    define _PTRSZVALfx _WIDE( PRIxPTR )
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  else
      // this HAS been fixed in UCRT - 2015!  but it'll take 5 years before everyone has that...
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f    _32f
#      define _size_fx   _32fx
#      define _size_fX   _32fX
#      define _size_fs   _32fs
#      define c_size_f    c_32f
#      define c_size_fx   c_32fx
#      define c_size_fX   c_32fX
#      define c_size_fs   c_32fs
#    else
#      define _size_f    WIDE( "zu" )
#      define _size_fx   WIDE( "zx" )
#      define _size_fX   WIDE( "zX" )
#      define _size_fs   WIDE( "zd" )
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs _WIDE( PRIuPTR )
#    define _PTRSZVALfx _WIDE( PRIxPTR )
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  endif
#endif
#define PTRSZVALf WIDE("p" )
#define _PTRSZVALf WIDE("p" )
#if defined( _MSC_VER ) && ( _MSC_VER < 1900 )
/* 64 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIu64              */
#define _64f    WIDE("llu")
/* 64 bit hex output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIxFAST64                */
#define _64fx   WIDE("llx")
/* 64 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIxFAST64                */
#define _64fX   WIDE("llX")
/* 64 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\> as PRIdFAST64               */
#define _64fs   WIDE("lld")
#endif
// This should be for several years a
// sufficiently large type to represent
// threads and processes.
typedef uint64_t THREAD_ID;
#define GetMyThreadIDNL GetMyThreadID
#if defined( _WIN32 ) || defined( __CYGWIN__ )
#define _GetMyThreadID()  ( (( ((uint64_t)GetCurrentProcessId()) << 32 ) | ( (uint64_t)GetCurrentThreadId() ) ) )
#define GetMyThreadID()  (GetThisThreadID())
#else
// this is now always the case
// it's a safer solution anyhow...
#ifndef GETPID_RETURNS_PPID
#define GETPID_RETURNS_PPID
#endif
#ifdef GETPID_RETURNS_PPID
#ifdef __ANDROID__
#define GetMyThreadID()  (( ((uint64_t)getpid()) << 32 ) | ( (uint64_t)(gettid()) ) )
#else
#define GetMyThreadID()  (( ((uint64_t)getpid()) << 32 ) | ( (uint64_t)(pthread_self()) ) )
#endif
#else
#define GetMyThreadID()  (( ((uint64_t)getppid()) << 32 ) | ( (uint64_t)(getpid()|0x40000000)) )
#endif
#define _GetMyThreadID GetMyThreadID
#endif
//#error blah
// general macros for linking lists using
#define DeclareLink( type )  type *next;type **me
#define RelinkThing( root, node )	   ((( node->me && ( (*node->me)=node->next ) )?	  node->next->me = node->me:0),(node->next = NULL),(node->me = NULL),node),	 ((( node->next = root )?	        (root->me = &node->next):0),	  (node->me = &root),	             (root = node) )
/* Link a new node into the list.
   Example
   struct mynode
   {
   DeclareLink( struct mynode );
   } *node;
   struct mynode *list;
   LinkThing( list_root, node );  */
#define LinkThing( root, node )		     ((( (node)->next = (root) )?	        (((root)->me) = &((node)->next)):0),	  (((node)->me) = &(root)),	             ((root) = (node)) )
/* Link a node to the end of a list. Link thing inserts the new
   node as the new head of the list.                            */
#define LinkLast( root, type, node ) if( node ) do { if( !root )	 { root = node; (node)->me=&root; }	 else { type tmp;	 for( tmp = root; tmp->next; tmp = tmp->next );	 tmp->next = (node);	 (node)->me = &tmp->next;	 } } while (0)
// put 'Thing' after 'node'
#define LinkThingAfter( node, thing )	 ( ( (thing)&&(node))	   ?(((((thing)->next = (node)->next))?((node)->next->me = &(thing)->next):0)	  ,((thing)->me = &(node)->next), ((node)->next = thing))	  :((node)=(thing)) )
//
// put 'Thing' before 'node'... so (*node->me) = thing
#define LinkThingBefore( node, thing )	 {  thing->next = (*node->me);	(*node->me) = thing;    thing->me = node->me;       node->me = &thing->next;     }
/* Remove a node from a list. Requires only the node. */
#define UnlinkThing( node )	                      ((( (node) && (node)->me && ( (*(node)->me)=(node)->next ) )?	  (node)->next->me = (node)->me:0),((node)->next = NULL),((node)->me = NULL),(node))
// this has two expressions duplicated...
// but in being so safe in this expression,
// the self-circular link needs to be duplicated.
// GrabThing is used for nodes which are circularly bound
#define GrabThing( node )	    ((node)?(((node)->me)?(((*(node)->me)=(node)->next)?	 ((node)->next->me=(node)->me),((node)->me=&(node)->next):NULL):((node)->me=&(node)->next)):NULL)
/* Go to the next node with links declared by DeclareLink */
#define NextLink(node) ((node)?(node)->next:NULL)
// everything else is called a thing... should probably migrate to using this...
#define NextThing(node) ((node)?(node)->next:NULL)
//#ifndef FALSE
//#define FALSE 0
//#endif
//#ifndef TRUE
//#define TRUE (!FALSE)
//#endif
/* the default type to use for flag sets - flag sets are arrays of bits which can be toggled on and off by an index. */
#define FLAGSETTYPE uint32_t
/* the number of bits a specific type is.
   Example
   int bit_size_int = FLAGTYPEBITS( int ); */
#define FLAGTYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* how many bits to add to make sure we round to the next greater index if even 1 bit overflows */
#define FLAGROUND(t) (FLAGTYPEBITS(t)-1)
/* the index of the FLAGSETTYPE which contains the bit in question */
#define FLAGTYPE_INDEX(t,n)  (((n)+FLAGROUND(t))/FLAGTYPEBITS(t))
/* how big the flag set is in count of FLAGSETTYPEs required in a row ( size of the array of FLAGSETTYPE that contains n bits) */
#define FLAGSETSIZE(t,n) (FLAGTYPE_INDEX(t,n) * sizeof( FLAGSETTYPE ) )
// declare a set of flags...
#define FLAGSET(v,n)   FLAGSETTYPE (v)[((n)+FLAGROUND(FLAGSETTYPE))/FLAGTYPEBITS(FLAGSETTYPE)]
// set a single flag index
#define SETFLAG(v,n)   ( (v)[(n)/FLAGTYPEBITS((v)[0])] |= 1 << ( (n) & FLAGROUND((v)[0]) ))
// clear a single flag index
#define RESETFLAG(v,n) ( (v)[(n)/FLAGTYPEBITS((v)[0])] &= ~( 1 << ( (n) & FLAGROUND((v)[0]) ) ) )
// test if a flags is set
#define TESTFLAG(v,n)  ( (v)[(n)/FLAGTYPEBITS((v)[0])] & ( 1 << ( (n) & FLAGROUND((v)[0]) ) ) )
// reverse a flag from 1 to 0 and vice versa
#define TOGGLEFLAG(v,n)   ( (v)[(n)/FLAGTYPEBITS((v)[0])] ^= 1 << ( (n) & FLAGROUND((v)[0]) ))
// 32 bits max for range on mask
#define MASK_MAX_LENGTH 32
// gives a 32 bit mask possible from flagset..
#define MASKSET_READTYPE uint32_t
// gives byte index...
#define MASKSETTYPE uint8_t
/* how many bits the type specified can hold
   Parameters
   t :  data type to measure (int, uint32_t, ... ) */
#define MASKTYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* the maximum number of bits storable in a type */
#define MASK_MAX_TYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* round up to the next count of types that fits 1 bit - used as a cieling round factor */
#define MASKROUND(t) (MASKTYPEBITS(t)-1)
/* define MAX_MAX_ROUND factor based on MASKSET_READTYPE - how to read it... */
#define MASK_MAX_ROUND() (MASK_MAX_TYPEBITS(MASKSET_READTYPE)-1)
/* byte index of the start of the mask
   Parameters
   t :  type to measure with
   n :  mask index                     */
#define MASKTYPE_INDEX(t,n)  (((n)+MASKROUND(t))/MASKTYPEBITS(t))
/* The number of bytes the set would be.
   Parameters
   t :  the given type to measure with
   n :  the count of masks to fit.       */
#define MASKSETSIZE(t,n) (MASKTYPE_INDEX(t,(n+1)))
// declare a set of flags...
#define MASK_TOP_MASK_VAL(length,val) ((val)&( (0xFFFFFFFFUL) >> (32-(length)) ))
/* the mask in the dword resulting from shift-right.   (gets a mask of X bits in length) */
#define MASK_TOP_MASK(length) ( (0xFFFFFFFFUL) >> (32-(length)) )
/* the mast in the dword shifted to the left to overlap the field in the word */
#define MASK_MASK(n,length)   (MASK_TOP_MASK(length) << (((n)*(length))&0x7) )
// masks value with the mask size, then applies that mask back to the correct word indexing
#define MASK_MASK_VAL(n,length,val)   (MASK_TOP_MASK_VAL(length,val) << (((n)*(length))&0x7) )
/* declare a mask set. */
#define MASKSET(v,n,r)  MASKSETTYPE  (v)[(((n)*(r))+MASK_MAX_ROUND())/MASKTYPEBITS(MASKSETTYPE)]; const int v##_mask_size = r;
// set a field index to a value
#define SETMASK(v,n,val)    (((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS((v)[0])))[0] =    ( ((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS(uint8_t)))[0]                                  & (~(MASK_MASK(n,v##_mask_size))) )	                                                                           | MASK_MASK_VAL(n,v##_mask_size,val) )
// get the value of a field
#define GETMASK(v,n)  ( ( ((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS((v)[0])))[0]                                  & MASK_MASK(n,v##_mask_size) )	                                                                           >> (((n)*(v##_mask_size))&0x7))
/* This type stores data, it has a self-contained length in
   bytes of the data stored.  Length is in characters       */
_CONTAINER_NAMESPACE
#define DECLDATA(name,length) struct {size_t size; TEXTCHAR data[length];} name
// Hmm - this can be done with MemLib alone...
// although this library is not nessecarily part of that?
// and it's not nessecarily allocated.
typedef struct SimpleDataBlock {
   size_t size;
/* unsigned size; size is sometimes a pointer value... this
                    means bad thing when we change platforms... Defined as
                    uintptr_t now, so it's relative to the size of the platform
                    anyhow.                                                    */
#ifdef _MSC_VER
#pragma warning (disable:4200)
#endif
   uint8_t  data[
#ifndef __cplusplus
   1
#endif
 // beginning of var data - this is created size+sizeof(uint8_t)
   ];
#ifdef _MSC_VER
#pragma warning (default:4200)
#endif
} DATA, *PDATA;
/* This is a slab array of pointers, each pointer may be
   assigned to point to any user data.
   Remarks
   When the list is filled to the capacity of Cnt elements, the
   list is reallocated to be larger.
   Cannot add NULL pointer to list, empty elements in the list
   are represented with NULL, and may be filled by any non-NULL
   value.                                                       */
_LINKLIST_NAMESPACE
/* <combine sack::containers::list::LinkBlock>
   \ \                                         */
typedef struct LinkBlock
{
	/* How many pointers the list can contain now. */
	INDEX     Cnt;
	/* \ \  */
	POINTER pNode[1];
} LIST, *PLIST;
_LINKLIST_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::containers::list;
#endif
_DATALIST_NAMESPACE
/* a list of data structures... a slab array of N members of X size */
typedef struct DataBlock  DATALIST;
/* A typedef of a pointer to a DATALIST struct DataList. */
typedef struct DataBlock *PDATALIST;
/* Data Blocks are like LinkBlocks, and store blocks of data in
   slab format. If the count of elements exceeds available, the
   structure is grown, to always contain a continuous array of
   structures of Size size.
   Remarks
   When blocks are deleted, all subsequent blocks are shifted
   down in the array. So the free blocks are always at the end. */
struct DataBlock
{
	/* How many elements are used. */
	INDEX     Cnt;
	/* How many elements are available in his array. */
	INDEX     Avail;
	/* A simple exchange lock on the data for insert and delete. For
	   thread safety.                                                */
	//volatile uint32_t     Lock;
	/* How big each element of the array is. */
	INDEX     Size;
	/* The physical array. */
	uint8_t      data[1];
};
_DATALIST_NAMESPACE_END
/* This is a stack that contains pointers to user objects.
   Remarks
   This is a stack 'by reference'. When extended, the stack will
   occupy different memory, care must be taken to not duplicate
   pointers to this stack.                                       */
typedef struct LinkStack
{
	/* This is the index of the next pointer to be pushed or popped.
	   If top == 0, the stack is empty, until a pointer is added and
	   top is incremented.                                           */
	INDEX     Top;
	/* How many pointers the stack can contain. */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore. For
	                  thread safety.                                            */
	//volatile uint32_t     Lock;
	/*  a defined maximum capacity of stacked values... values beyond this are lost from the bottom  */
	uint32_t     Max;
	/* Reserved data portion that stores the pointers. */
	POINTER pNode[1];
} LINKSTACK, *PLINKSTACK;
/* A Stack that stores information in an array of structures of
   known size.
   Remarks
   The size of each element must be known at stack creation
   time. Structures are literally copied to and from this stack.
   This is a stack 'by value'. When extended, the stack will
   occupy different memory, care must be taken to not duplicate
   pointers to this stack.                                       */
typedef struct DataListStack
{
	volatile INDEX     Top;
 /* enable logging the program executable (probably the same for
	                all messages, unless they are network)
	                                                                             */
 // How many elements are on the stack.
	INDEX     Cnt;
	//volatile uint32_t     Lock;  /* thread interlock using InterlockedExchange semaphore. For
	//                  thread safety.                                            */
	INDEX     Size;
	INDEX     Max;
	uint8_t      data[1];
} DATASTACK, *PDATASTACK;
/* A queue which contains pointers to user objects. If the queue
   is filled to capacity and new queue is allocated, and all
   existing pointers are transferred.                            */
typedef struct LinkQueue
{
	/* This is the index of the next pointer to be added to the
	   queue. If Top==Bottom, then the queue is empty, until a
	   pointer is added to the queue, and Top is incremented.   */
	volatile INDEX     Top;
	/* This is the index of the next element to leave the queue. */
	volatile INDEX     Bottom;
	/* This is the current count of pointers that can be stored in
	   the queue.                                                  */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore. For
	   thread safety.                                            */
#if USE_CUSTOM_ALLOCER
	volatile uint32_t     Lock;
#endif
 // need two to have distinct empty/full conditions
	POINTER pNode[2];
} LINKQUEUE, *PLINKQUEUE;
/* A queue of structure elements.
   Remarks
   The size of each element must be known at stack creation
   time. Structures are literally copied to and from this stack.
   This is a stack 'by value'. When extended, the stack will
   occupy different memory, care must be taken to not duplicate
   pointers to this stack.                                       */
typedef struct DataQueue
{
	/* This is the next index to be added to. If Top==Bottom, the
	   queue is empty, until an entry is added at Top, and Top
	   increments.                                                */
	volatile INDEX     Top;
	/* The current bottom index. This is the next one to be
	   returned.                                            */
	volatile INDEX     Bottom;
	/* How many elements the queue can hold. If a queue has more
	   elements added to it than it has count, it will be expanded,
	   and a new queue returned.                                    */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore */
	//volatile uint32_t     Lock;
	/* How big each element in the queue is. */
	INDEX     Size;
	/* How many elements to expand the queue by, when its capacity
	   is reached.                                                 */
	INDEX     ExpandBy;
	/* The data area of the queue. */
	uint8_t      data[1];
} DATAQUEUE, *PDATAQUEUE;
/* A mostly obsolete function, but can return the status of
   whether all initially scheduled startups are completed. (Or
   maybe whether we are not complete, and are processing
   startups)                                                   */
_CONTAINER_NAMESPACE_END
SACK_NAMESPACE_END
/* This contains the methods to use the base container types
   defined in sack_types.h.                                  */
#ifndef LINKSTUFF
#define LINKSTUFF
	SACK_NAMESPACE
	_CONTAINER_NAMESPACE
#    define TYPELIB_CALLTYPE
#  if defined( _TYPELIBRARY_SOURCE_STEAL )
#    define TYPELIB_PROC extern
#  elif defined( NO_EXPORTS )
#    if defined( _TYPELIBRARY_SOURCE )
#      define TYPELIB_PROC
#    else
#      define TYPELIB_PROC extern
#    endif
#  elif defined( _TYPELIBRARY_SOURCE )
#    define TYPELIB_PROC EXPORT_METHOD
#  else
#    define TYPELIB_PROC IMPORT_METHOD
#  endif
_LINKLIST_NAMESPACE
//--------------------------------------------------------
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        CreateListEx   ( DBG_VOIDPASS );
/* Destroy a PLIST. */
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        DeleteListEx   ( PLIST *plist DBG_PASS );
/* See <link AddLink>.
   See <link DBG_PASS>. */
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        AddLinkEx      ( PLIST *pList, POINTER p DBG_PASS );
/* Sets the value of a link at the specified index.
   Parameters
   pList :     address of a PLIST
   idx :       index of the element to set
   p :         new link value to be set at the specified index
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        SetLinkEx      ( PLIST *pList, INDEX idx, POINTER p DBG_PASS );
/* Gets the link at the specified index.
   Parameters
   pList :  address of a PLIST pointer.
   idx :    index to get the link from.  */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      GetLink        ( PLIST *pList, INDEX idx );
/* Gets the address of the link node in the PLIST.
   Parameters
   pList :  address of a PLIST to get the node address
   idx :    index of the node to get the adddress of
   Example
   <code lang="c++">
   PLIST list = NULL; // don't have to use CreateList();
   POINTER *a;
   POINTER b;
   POINTER *result;
   a = &amp;b;
   AddLink( &amp;list, a );
   \result = GetLinkAddress( &amp;list, 0 );
    ( (*result) == b )
   </code>                                               */
TYPELIB_PROC  POINTER* TYPELIB_CALLTYPE     GetLinkAddress ( PLIST *pList, INDEX idx );
/* Locate a pointer in a PLIST. Return the index.
   Parameters
   pList :  address of a list pointer to locate link
   value :  link to find in the list
   Return Value List
   INVALID_INDEX :  Not found in the list
   0\-n :           Index of the first occurance of the link in the
                    list.                                           */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        FindLink       ( PLIST *pList, POINTER value );
/* return the count of used members in a PLIST
    pList : the list to count
	Return Value
	   number of things in the list.
*/
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        GetLinkCount   ( PLIST pList );
/* Uses FindLink on the list for the value to delete, and then
   sets the index of the found link to NULL.
   Parameters
   pList :  Address of a PLIST pointer
   value :  the link to find and remove from the list.
   Example
   <code lang="c++">
   PLIST list = NULL;
	POINTER a = &#47;*some address*&#47;;
   </code>
   <code>
   AddLink( &amp;list, a );
   DeleteLink( &amp;list, a );
   </code>                                                     */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      DeleteLink     ( PLIST *pList, CPOINTER value );
/* Remove all links from a PLIST. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyList      ( PLIST *pList );
#ifdef __cplusplus
/* This was a basic attempt to make list into a C++ class. I
   gave up doing this sort of thing afterwards after realizing
   the methods of a library and these static methods for a class
   aren't much different.                                        */
typedef class iList
{
public:
	PLIST list;
	INDEX idx;
	inline iList() { list = CreateListEx( DBG_VOIDSRC ); }
	inline ~iList() { DeleteListEx( &list DBG_SRC ); }
	inline iList &operator+=( POINTER &p ){ AddLinkEx( &list, p DBG_SRC ); return *this; }
	inline void add( POINTER p ) { AddLinkEx( &list, p DBG_SRC ); }
	inline void remove( POINTER p ) { DeleteLink( &list, p ); }
	inline POINTER first( void ) { POINTER p; for( idx = 0, p = NULL;list && (idx < list->Cnt) && (( p = GetLink( &list, idx ) )==0); )idx++; return p; }
	inline POINTER next( void ) { POINTER p; for( idx++;list && (( p = GetLink( &list, idx ) )==0) && idx < list->Cnt; )idx++; return p; }
	inline POINTER get(INDEX idx) { return GetLink( &list, idx ); }
} *piList;
#endif
// address of the thing...
typedef uintptr_t (CPROC *ForProc)( uintptr_t user, INDEX idx, POINTER *item );
// if the callback function returns non 0 - then the looping is aborted,
// and the value is returned... the user value is passed to the callback.
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE     ForAllLinks    ( PLIST *pList, ForProc func, uintptr_t user );
/* This is a iterator which can be used to check each member in
   a PLIST.
   Parameters
   list :     List to iterate through
   index :    variable to use to index the list
   type :     type of the elements stored in the list (for C++)
   pointer :  variable used to get the current member of the
              list.
   Example
   <code lang="c++">
   POINTER p;  // the pointer to receive the list member pointer (should be a user type)
   INDEX idx; // indexer
   PLIST pList; // some list.
   LIST_FORALL( pList, idx, POINTER, p )
   {
       // p will never be NULL here.
       // each link stored in the list is set to p here..
       // this is a way to remove this item from the list...
       SetLink( &amp;pList, idx, NULL );
       if( some condition )
          break;
   }
   </code>
   Another example that uses data and searches..
   <code lang="c++">
   PLIST pList = NULL;
   INDEX idx;
   CTEXTSTR string;
   AddLink( &amp;pList, (POINTER)"hello" );
   </code>
   <code>
   AddLink( &amp;pList, (POINTER)"world" );
   LITS_FORALL( pList, idx, CTEXTSTR, string )
   {
       if( strcmp( string, "hello" ) == 0 )
           break;
   }
   // here 'string' will be NULL if not found, else will be what was found
   </code>
   Remarks
   This initializes the parameters passed to the macro so that
   if the list is NULL or empty, then p will be set to NULL. If
   there are no non-nulll members in the list, p will be set to
   NULL. If you break in the loop, like in the case of searching
   the list for something, then p will be non-null at the end of
   the loop.
                                                                                         */
#define LIST_FORALL( l, i, t, v )  if(((v)=(t)NULL),(l))                                                        for( ((i)=0); ((i) < ((l)->Cnt))?                                         (((v)=(t)((l)->pNode[i])),1):(((v)=(t)NULL),0); (i)++ )  if( v )
/* This can be used to continue iterating through a list after a
   LIST_FORALL has been interrupted.
   Parameters
   list :     \Description
   index :    index variable for stepping through the list
   type :     type of the members in the list.
   pointer :  variable name to use to store the the current list
              element.
   Example
   <code lang="c++">
   PLIST pList = NULL;
   CTEXTSTR p;
   INDEX idx;
   </code>
   <code>
   AddLink( &amp;pList, "this" );
   AddLink( &amp;pList, "is" );
   AddLink( &amp;pList, "a" );
   AddLink( &amp;pList, "test" );
   LIST_FORALL( pList, idx, CTEXTSTR, p )
   {
       if( strcmp( p, "is" ) == 0 )
           break;
   }
   LIST_NEXTALL( pList, idx, CTEXTSTR, p )
   {
       printf( "remaining element : %s", p );
   }
   </code>
   <code lang="c++">
   j
   </code>                                                       */
#define LIST_NEXTALL( l, i, t, v )  if(l)                for( ++(i),((v)=(t)NULL); ((i) < ((l)->Cnt))?     (((v)=(t)(l)->pNode[i]),1):(((v)=(t)NULL),0); (i)++ )  if( v )
/* <combine sack::containers::list::CreateListEx@DBG_VOIDPASS>
   \ \                                                         */
#define CreateList()       ( CreateListEx( DBG_VOIDSRC ) )
/* <combine sack::containers::list::DeleteListEx@PLIST *plist>
   \ \                                                         */
#ifndef FIX_RELEASE_COM_COLLISION
#  define DeleteList(p)      ( DeleteListEx( (p) DBG_SRC ) )
#endif
/* Adds a pointer to a user object to a list.
   Example
   <code lang="c++">
   // the list can be initialized to NULL,
   // it does not have to be assigned the result of a CreateList().
   // this allows the list to only be allocated if it is used.
   PLIST list = NULL;
   AddLink( &amp;list, (POINTER)user_pointer );
   {
       POINTER p; // this should be USER_DATA_TYPE *p;
       INDEX idx; // just a generic counter.
       LIST_FORALL( list, idx, POINTER, p )
       {
           // for each item in the list, p will be not null.
           if( p-\>something == some_other_thing )
               break;
       }
       // p will be NULL if the list is empty
       // p will be NULL if the LIST_FORALL loop completes to termination.
       // p will be not NULL if the LIST_FORALL loop executed a 'break;'
   }
   </code>                                                                 */
#define AddLink(p,v)       ( AddLinkEx( (p),((POINTER)(v)) DBG_SRC ) )
/* <combine sack::containers::list::SetLinkEx@PLIST *@INDEX@POINTER p>
   \ \                                                                 */
#define SetLink(p,i,v)     ( SetLinkEx( (p),(i),((POINTER)(v)) DBG_SRC ) )
#ifdef __cplusplus
//		namespace list;
	};
#endif
//--------------------------------------------------------
_DATALIST_NAMESPACE
/* Creates a data list which hold data elements of the specified
   size.
                                                                 */
TYPELIB_PROC  PDATALIST TYPELIB_CALLTYPE  CreateDataListEx ( uintptr_t nSize DBG_PASS );
/* <combine sack::containers::data_list::DeleteDataList>
   \ \                                                   */
TYPELIB_PROC  void TYPELIB_CALLTYPE       DeleteDataListEx ( PDATALIST *ppdl DBG_PASS );
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    SetDataItemEx ( PDATALIST *ppdl, INDEX idx, POINTER data DBG_PASS );
/* Adds an item to a DataList.
   Example
   <code lang="c++">
   PDATALIST datalist = CreateDataList();
   struct my_struct {
       uint32_t my_data;
   }
   struct my_struct my_item;
   my_item.my_data = 0;
   AddDataItem( &amp;datalist, &amp;my_item );
   </code>                                     */
#define AddDataItem(list,data) (((list)&&(*(list)))?SetDataItemEx((list),(*list)->Cnt,data DBG_SRC ):NULL)
/* Sets the item at a specific nodes to the new data.
   Parameters
   ppdl :      address of a PDATALIST.
   idx :       index of element in list to set
   data :      POINTER to data to set element to
   DBG_PASS :  optional debug file/line information
   Example
   <code lang="c++">
      PDATALIST pdl;
      int oldval = 3;
      int newval = 5;
      pdl = CreateDataList( sizeof( int ) ); // store int's as data
      AddDataItem( &amp;pdl, &amp;oldval );
      SetDataItem( &amp;pdl, 0, &amp;newval );
   </code>                                                          */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    SetDataItemEx ( PDATALIST *ppdl, INDEX idx, POINTER data DBG_PASS );
/* \Returns a pointer to the data at a specified index.
   Parameters
   \ \
   ppdl :  address of a PDATALIST
   idx :   index of element to get                      */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    GetDataItem ( PDATALIST *ppdl, INDEX idx );
/* Removes a data element from the list (moves all other
   elements down over it since there is no used indicator.
   Parameters
   ppdl :  address of a PDATALIST.
   idx :   index of element to delete                      */
TYPELIB_PROC  void TYPELIB_CALLTYPE       DeleteDataItem ( PDATALIST *ppdl, INDEX idx );
/* Empties a PDATALIST of all content.
   Parameters
   ppdl :  address of a PDATALIST
   Example
   <code lang="c++">
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) ); // store int's as data
   EmptyDataList( &amp;pdl );
   </code>                                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE       EmptyDataList ( PDATALIST *ppdl );
/* For loop to iterate through all items in a PDATALIST.
   <code lang="c++">
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) );
   {
      INDEX index;
      int *value;
      DATA_FORALL( pdl, index, int, value )
      {
      }
   }
   </code>                                               */
#define DATA_FORALL( l, i, t, v )  if(((v)=(t)NULL),(l)&&((l)->Cnt != INVALID_INDEX))	   for( ((i)=0);	                         (((i) < (l)->Cnt)                                             ?(((v)=(t)((l)->data + (uintptr_t)(((l)->Size) * (i)))),1)	         :(((v)=(t)NULL),0))&&(v); (i)++ )
/* <code>
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) );
   {
      INDEX index;
      int *value;
      DATA_FORALL( pdl, index, int, value )
      {
          // abort loop early
      }
      DATA_NEXTALL( pdl, index, int, value )
      {
      }
   }
   </code>                                   */
#define DATA_NEXTALL( l, i, t, v )  if(((v)=(t)NULL),(l))	   for( ((i)++);	                         ((i) < (l)->Cnt)                                             ?((v)=(t)((l)->data + (((l)->Size) * (i))))	         :(((v)=(t)NULL),0); (i)++ )
/* <combine sack::containers::data_list::CreateDataListEx@uintptr_t nSize>
   Creates a DataList specifying just the size. Uses the current
   source and line for debugging parameter.                               */
#define CreateDataList(sz) ( CreateDataListEx( (sz) DBG_SRC ) )
/* Destroy a DataList.
   Example
   <code>
   PDATALIST datalist = CreateDataList( 4 );
   DeleteDataList( &amp;datalist );
   </code>
   Parameters
   ppDataList :  pointer to the PDATALIST.   */
#define DeleteDataList(p)  ( DeleteDataListEx( (p) DBG_SRC ) )
/* <combine sack::containers::data_list::SetDataItemEx@PDATALIST *@INDEX@POINTER data>
   \ \                                                                                 */
#define SetDataItem(p,i,v) ( SetDataItemEx( (p),(i),(v) DBG_SRC ) )
   _DATALIST_NAMESPACE_END
//--------------------------------------------------------
#ifdef __cplusplus
		namespace link_stack {
#endif
/* Creates a new stack for links (POINTERS).
   Parameters
   DBG_PASS :  Debug file and line information to use for the
               allocation of the stack.
   Returns
   Pointer to a new link stack.                               */
TYPELIB_PROC  PLINKSTACK TYPELIB_CALLTYPE   CreateLinkStackEx( DBG_VOIDPASS );
/* Creates a new stack for links (POINTERS).  Link stack has a limited number of entries.
    When the stack fills, the oldest item on the stack is removed automatically.
	 Parameters
	 max_entries : maximum depth of the stack.
   DBG_PASS :  Debug file and line information to use for the
               allocation of the stack.
   Returns
   Pointer to a new link stack.                               */
         // creates a link stack with maximum entries - any extra entries are pushed off the bottom into NULL
TYPELIB_PROC  PLINKSTACK TYPELIB_CALLTYPE      CreateLinkStackLimitedEx        ( int max_entries  DBG_PASS );
/* <combine sack::containers::link_stack::CreateLinkStackLimitedEx@int max_entries>
   Macro to pass default debug file and line information.                           */
#define CreateLinkStackLimited(n) CreateLinkStackLimitedEx(n DBG_SRC)
/* Destroy a link stack. Sets the pointer to the stack to NULL
   on deletion.
   Parameters
   pls :       address of a link stack pointer
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteLinkStackEx( PLINKSTACK *pls DBG_PASS);
/* Pushes a new link on the stack.
   Parameters
   pls :       address of a link stack pointer
   p :         new pointer to push on the stack
   DBG_PASS :  debug source file and line information.
   Returns
   New link stack pointer if the stack was reallocated to have
   more space. Since the address of the pointer is passed, the
   pointer is already updated, and the return value is
   unimportant.                                                */
TYPELIB_PROC  PLINKSTACK TYPELIB_CALLTYPE   PushLinkEx       ( PLINKSTACK *pls, POINTER p DBG_PASS);
/* Reads the top value of the stack and returns it, removes top
   link on the stack.
   Parameters
   pls :  address of a link stack pointer
   Return Value List
   NULL :      Stack was empty
   not NULL :  Link that was on the top of the stack.           */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopLink          ( PLINKSTACK *pls );
/* Look at the top link on the stack.
   Parameters
   pls :  address of a link stack pointer
   Return Value List
   NULL :      Nothing on stack.
   not NULL :  link on the top of the stack. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekLink         ( PLINKSTACK *pls );
/* Look at links in the stack.
   Parameters
	pls :  address of a link stack pointer
	n : index of the element from the top to look at
   Return Value List
   NULL :      Nothing on stack at the position specified.
   not NULL :  link on the top of the stack. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekLinkEx         ( PLINKSTACK *pls, INDEX n );
// thought about adding these, but decided on creating a limited stack instead.
//TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      StackLength      ( PLINKSTACK *pls );
//TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopLinkEx        ( PLINKSTACK *pls, int position );
/* <combine sack::containers::link_stack::CreateLinkStackEx@DBG_VOIDPASS>
   Macro to pass default file and line information.                       */
#define CreateLinkStack()  CreateLinkStackEx( DBG_VOIDSRC )
/* <combine sack::containers::link_stack::DeleteLinkStackEx@PLINKSTACK *pls>
   Macro to pass default file and line information.                          */
#define DeleteLinkStack(p) DeleteLinkStackEx((p) DBG_SRC)
/* <combine sack::containers::link_stack::PushLinkEx@PLINKSTACK *@POINTER p>
   Macro to pass default debug file and line information.                    */
#define PushLink(p, v)     PushLinkEx((p),(v) DBG_SRC)
#ifdef __cplusplus
//		namespace link_stack {
		};
#endif
//--------------------------------------------------------
#ifdef __cplusplus
		namespace data_stack {
#endif
/* Creates a data stack for data element of the specified size.
   Parameters
   size :       size of elements in the stack
   DBG_PASS :  debug file and line information.                 */
TYPELIB_PROC  PDATASTACK TYPELIB_CALLTYPE   CreateDataStackEx( size_t size DBG_PASS );
/* Creates a data stack for data element of the specified size.
   Parameters
   size :       size of items in the stack
   count :      max items in stack (oldest gets deleted)
   DBG_PASS :  debug file and line information.                 */
TYPELIB_PROC  PDATASTACK TYPELIB_CALLTYPE   CreateDataStackLimitedEx( size_t size, INDEX count DBG_PASS );
/* Destroys a data stack.
   Parameters
   pds :       address of a data stack pointer. The pointer will
               be set to NULL when the queue is destroyed.
   DBG_PASS :  Debug file and line information.                  */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteDataStackEx( PDATASTACK *pds DBG_PASS);
/* Push a data element onto the stack. The size of the element
   is known at the stack creation time.
   Parameters
   pds :       address of a data stack pointer
   p :         pointer to data to push on stack
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC  PDATASTACK TYPELIB_CALLTYPE   PushDataEx     ( PDATASTACK *pds, POINTER pdata DBG_PASS );
/* \Returns an allocated buffer containing the data on the
   stack. Removes item from the stack.
   Parameters
   pds :  address of a data stack to get data from         */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopData        ( PDATASTACK *pds );
/* Clear all data stored in the stack.
   Parameters
   pds :  address of a data stack pointer. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyDataStack ( PDATASTACK *pds );
/* Look at top item in the stack without removing it.
   Parameters
   pds :  address of a data stack to look at          */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekData       ( PDATASTACK *pds );
// Incrementing Item moves progressivly down the stack
// final(invalid) stack, and/or empty stack will return NULL;
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekDataEx     ( PDATASTACK *pds, INDEX Item );
 /* keeps data on stack (can be used)
                                                                                      Parameters
                                                                                      pds :   address of a data stack pointer
                                                                                      Item :  Item to peek at; 0 is the top, 1 is just below it...
                                                                                              (maybe \-1 is last and further up)
                                                                                      Returns
                                                                                      \returns the address of the data item in the data stack.     */
/* <combine sack::containers::data_stack::CreateDataStackEx@INDEX size>
   Macro to pass default file and line information.                     */
#define CreateDataStack(size) CreateDataStackEx( size DBG_SRC )
/* <combine sack::containers::data_stack::CreateDataStackEx@INDEX size>
   Macro to pass default file and line information.                     */
#define CreateDataStackLimited(size,items) CreateDataStackLimitedEx( size,items DBG_SRC )
/* <combine sack::containers::data_stack::DeleteDataStackEx@PDATASTACK *pds>
   Macro to pass default file and line information.                          */
#define DeleteDataStack(p) DeleteDataStackEx((p) DBG_SRC)
/* <combine sack::containers::data_stack::PushDataEx@PDATASTACK *@POINTER pdata>
   Macro to pass default file and line information.                              */
#define PushData(pds,p) PushDataEx(pds,p DBG_SRC )
#ifdef __cplusplus
 //		namespace data_stack {
		}
#endif
/* Queue container - can enque (at tail) deque (from head) and preque (at head). Can also browse the queue with peekqueue. */
#ifdef __cplusplus
		namespace queue {
#endif
/* Creates a <link sack::containers::PLINKQUEUE, LinkQueue>. In
   debug mode, gets passed the current source and file so it can
   blame the user for the allocation.                            */
TYPELIB_PROC  PLINKQUEUE TYPELIB_CALLTYPE   CreateLinkQueueEx( DBG_VOIDPASS );
/* Delete a link queue. Pass the address of the pointer to the
   queue to delete, this function sets the pointer to NULL if
   the queue is actually deleted.                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteLinkQueueEx( PLINKQUEUE *pplq DBG_PASS );
/* Enque a link to the queue.  */
TYPELIB_PROC  PLINKQUEUE TYPELIB_CALLTYPE   EnqueLinkEx      ( PLINKQUEUE *pplq, POINTER link DBG_PASS );
TYPELIB_PROC  void TYPELIB_CALLTYPE   EnqueLinkNLEx( PLINKQUEUE *pplq, POINTER link DBG_PASS );
/* EnqueLink adds the new item at the end of the list. PrequeueLink
   puts the new item at the head of the queue (so it's the next
   one to be retrieved).                                            */
TYPELIB_PROC  PLINKQUEUE TYPELIB_CALLTYPE   PrequeLinkEx      ( PLINKQUEUE *pplq, POINTER link DBG_PASS );
/* If the queue is not empty, returns the address of the next
   element in the queue and removes the element from the queue.
                                                                */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      DequeLink        ( PLINKQUEUE *pplq );
TYPELIB_PROC POINTER  TYPELIB_CALLTYPE      DequeLinkNL      ( PLINKQUEUE *pplq );
/* Return TRUE/FALSE if the queue is empty or not. */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      IsQueueEmpty     ( PLINKQUEUE *pplq );
/* Gets the number of elements current in the queue. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        GetQueueLength   ( PLINKQUEUE plq );
// get a PLINKQUEUE element at index
//  If idx < 0 then count from the end of the queue, otherwise count from the start of the queue
// start of the queue is the next element to be dequeue, end of the queue is the last element added to the queue.
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekQueueEx    ( PLINKQUEUE plq, int idx );
/* Can be used to look at the next element in the queue without
   removing it from the queue. PeekQueueEx allows you to specify
   an index of an item in the queue to get.                      */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekQueue    ( PLINKQUEUE plq );
/* <combinewith sack::containers::queue::CreateLinkQueueEx@DBG_VOIDPASS>
   \ \                                                                   */
#define     CreateLinkQueue()     CreateLinkQueueEx( DBG_VOIDSRC )
/* <combine sack::containers::queue::PrequeLinkEx@PLINKQUEUE *@POINTER link>
   \ \                                                                       */
#define     PrequeLink(pplq,link) PrequeLinkEx( pplq, link DBG_SRC )
/* <combine sack::containers::queue::DeleteLinkQueueEx@PLINKQUEUE *pplq>
   \ \                                                                   */
#define     DeleteLinkQueue(pplq) DeleteLinkQueueEx( pplq DBG_SRC )
/* <combine sack::containers::queue::EnqueLinkEx@PLINKQUEUE *@POINTER link>
   \ \                                                                      */
#define     EnqueLink(pplq, link) EnqueLinkEx( pplq, link DBG_SRC )
#define     EnqueLinkNL(pplq, link) EnqueLinkNLEx( pplq, link DBG_SRC )
#ifdef __cplusplus
//		namespace queue {
		}
#endif
/* Functions related to PDATAQUEUE container. DataQueue stores
   literal data elements in the list instead of just a pointer. (could
   be used for optimized vertex arrays for instance).
   int data = 3;
   int result;
   PDATAQUEUE pdq = CreateDataQueue( sizeof( int ) );
   EnqueData( &amp;pdq, &amp;data );
   DequeData( &amp;pdq, &amp;result );
   DestroyDataQueue( &amp;pdq );                                       */
#ifdef __cplusplus
		namespace data_queue {
#endif
/* Creates a PDATAQUEUE. Can pass DBG_FILELINE information to
   blame other code for the allocation.                       */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   CreateDataQueueEx( INDEX size DBG_PASS );
/* Creates a PDATAQUEUE that has an overridden expand-by amount
   and initial amount of entries in the queue. (expecting
   something like 1000 to start and expand by 500, instead of
   the default 0, and expand by 1.                              */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   CreateLargeDataQueueEx( INDEX size, INDEX entries, INDEX expand DBG_PASS );
/* Destroys a data queue. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteDataQueueEx( PDATAQUEUE *pplq DBG_PASS );
/* Add a data element into the queue. */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   EnqueDataEx      ( PDATAQUEUE *pplq, POINTER Data DBG_PASS );
/* Enque data at the head of the queue instead of the tail. (Normally
   add at tail, take from head).                                      */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   PrequeDataEx      ( PDATAQUEUE *pplq, POINTER Data DBG_PASS );
/* Removes data from a queue, resulting with the data in the
   specified buffer, and result TRUE if there was an element
   else FALSE, and the buffer is not modified.               */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      DequeData        ( PDATAQUEUE *pplq, POINTER Data );
/* Removes the last element in the queue. (takes from the tail). */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      UnqueData        ( PDATAQUEUE *pplq, POINTER Data );
/* Checks if the queue is empty, result TRUE if nothing in it,
   else FALSE.                                                 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      IsDataQueueEmpty ( PDATAQUEUE *pplq );
/* Empty a dataqueue of all data. (Sets head=tail). */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyDataQueue ( PDATAQUEUE *pplq );
/*
 * get a PDATAQUEUE element at index
 * result buffer is a pointer to the type of structure expected to be
 * stored within this.  The buffer result is a copy of the data stored in the queue.
 * This enforces that data stored in the list is immutable.
 * Also on the basic DequeData function, after resulting, if the pointer to the
 * data within the queue were returned, it could become invalid immediatly after
 * returning by having another enque happen which overwrites that position in the buffer.
 * One could, in theory, set a flag in the queue that a deque was done, and not update the
 * bottom until that flag is encountered while within DequeData again...
 * the pointer to the data in the queue may also not be returned because the queue may be
 * reallocated and moved.
 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  PeekDataQueueEx    ( PDATAQUEUE *pplq, POINTER ResultBuffer, INDEX idx );
/* <combine sack::containers::data_queue::PeekDataQueueEx@PDATAQUEUE *@POINTER@INDEX>
   \ \                                                                                */
#define PeekDataQueueEx( q, type, result, idx ) PeekDataQueueEx( q, (POINTER)result, idx )
/*
 * Result buffer is filled with the last element, and the result is true, otherwise the return
 * value is FALSE, and the data was not filled in.
 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  PeekDataQueue    ( PDATAQUEUE *pplq, POINTER ResultBuffer );
/* <combine sack::containers::data_queue::PeekDataQueue@PDATAQUEUE *@POINTER>
   \ \                                                                        */
#define PeekDataQueue( q, type, result ) PeekDataQueue( q, (POINTER)result )
/* <combine sack::containers::data_queue::CreateDataQueueEx@INDEX size>
   \ \                                                                  */
#define     CreateDataQueue(size)     CreateDataQueueEx( size DBG_SRC )
/* <combine sack::containers::data_queue::CreateLargeDataQueueEx@INDEX@INDEX@INDEX expand>
   \ \                                                                                     */
#define     CreateLargeDataQueue(size,entries)     CreateLargeDataQueueEx( size,entries, 0 DBG_SRC )
/* <combine sack::containers::data_queue::DeleteDataQueueEx@PDATAQUEUE *pplq>
   \ \                                                                        */
#define     DeleteDataQueue(pplq) DeleteDataQueueEx( pplq DBG_SRC )
/* <combine sack::containers::data_queue::EnqueDataEx@PDATAQUEUE *@POINTER Data>
   \ \                                                                           */
#define     EnqueData(pplq, Data) EnqueDataEx( pplq, Data DBG_SRC )
/* <combine sack::containers::data_queue::PrequeDataEx@PDATAQUEUE *@POINTER Data>
   \ \                                                                            */
#define     PrequeData(pplq, Data) PrequeDataEx( pplq, Data DBG_SRC )
#ifdef __cplusplus
//		namespace data_queue {
		}
#endif
//---------------------------------------------------------------------------
#ifdef __cplusplus
namespace message {
#endif
/* handle to a message queue. */
typedef struct MsgDataHandle *PMSGHANDLE;
//typedef struct MsgDataQueue *PMSGQUEUE;
// messages sent - the first dword of them must be
// a message ID.
typedef void (CPROC *MsgQueueReadCallback)( uintptr_t psv, CPOINTER p, uintptr_t sz );
/* Create a named shared memory message queue.
   Parameters
   name :     name of the queue to create
   size :     size of the queue.
   Read :     read callback, called when a message is received on
              the queue.
   psvRead :  user data associated with the queue. Passed to the
              read callback.                                      */
TYPELIB_PROC  PMSGHANDLE TYPELIB_CALLTYPE  SackCreateMsgQueue ( CTEXTSTR name, size_t size
                                                      , MsgQueueReadCallback Read
                                                      , uintptr_t psvRead );
/* Open a message queue. Opens if it exists, does not create.
   Parameters
   name :     name of the queue.
   Read :     read callback called when a message is received.
   psvRead :  user data associated with this queue, and passed to
              the read callback.                                  */
TYPELIB_PROC  PMSGHANDLE TYPELIB_CALLTYPE  SackOpenMsgQueue ( CTEXTSTR name
													 , MsgQueueReadCallback Read
													 , uintptr_t psvRead );
/* Destroys a message queue.
   Parameters
   ppmh :  address of the message queue handle to close (sets
           pointer to NULL when deleted)                      */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteMsgQueue ( PMSGHANDLE **ppmh );
 // if enque, fail send, return immediate on fail
#define MSGQUE_NOWAIT 0x0001
                             // if deque, fail no msg ready to get...
 // read any msg BUT MsgID
#define MSGQUE_EXCEPT 0x0002
 // enque this message... it is a task ID which is waiting.
#define MSGQUE_WAIT_ID 0x0004
/* Error result if there is no message to read. (GetLastError()
   after peekmsg or readmsg returns -1)                         */
#define MSGQUE_ERROR_NOMSG 1
/* Error result if the message to read is bigger than the buffer
   passed to read the message.                                   */
#define MSGQUE_ERROR_E2BIG 2
/* Error result. Unexpected error (queue head/tail out of
   bounds)                                                */
#define MSGQUE_ERROR_EABORT 5
// result is the size of the message, or 0 if no message.
// -1 if some other error?
TYPELIB_PROC  int TYPELIB_CALLTYPE  DequeMsgEx ( PMSGHANDLE pmh, long *MsgID, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Receives a message from the message queue.
   Parameters
   Message Queue :  PMSGHANDLE to read from
   Message ID * :   a Pointer to the message ID to read. Updated
                    with the message ID from the queue.
   buffer :         buffer to read message into
   buffer length :  length of the buffer to read
   options :        extra options for the read
   Return Value List
   \-1 :  Error
   0 :    No Message to read
   \>0 :  size of message read.
   Returns
   \ \                                                           */
#define DequeMsg(q,b,s,i,o) DequeMsgEx(q,b,s,i,o DBG_SRC )
/* <combine sack::containers::message::PeekMsg>
   \ \                                          */
TYPELIB_PROC  int TYPELIB_CALLTYPE  PeekMsgEx ( PMSGHANDLE pmh, long MsgID, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Just peek at the next message.
   Parameters
   queue :        The PMSGHANDLE queue to read.
   MsgID :        what message to read. 0 is read any message.
   buffer :       where to read the message data into.
   buffer_size :  the length of the message buffer.
   options :      Options controlling the read
   Returns
   \-1 on error
   0 if no message
   length of the message read                                  */
#define PeekMsg(q,b,s,i,o) PeekMsgEx(q,b,s,i,o DBG_SRC )
/* <combine sack::containers::message::EnqueMsg>
   \ \                                          */
TYPELIB_PROC  int TYPELIB_CALLTYPE  EnqueMsgEx ( PMSGHANDLE pmh, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Add a message to the queue.
   Parameters
   Message Queue :  PMSGQUEUE to write to.
   Buffer :         pointer to the message to send. THe MSgID is
                    the first part of the message buffer.
   Buffer Length :  how long the message to send is
   Options :        Extra options for send
   Return Value List
   \-1 :  Error
   \>0 :  bytes of message sent                                  */
#define EnqueMsg(q,b,s,o) EnqueMsgEx(q,b,s,o DBG_SRC )
/* Check if the message queue is empty.
   Parameters
   pmh :  queue to check if it's empty. */
TYPELIB_PROC  int TYPELIB_CALLTYPE  IsMsgQueueEmpty ( PMSGHANDLE pmh );
#ifdef __cplusplus
 //namespace message {
};
#endif
/* Routines to deal with SLAB allocated blocks of structures.
   Each slab has multiple elements of a type in it, and the
   blocks are tracked as a linked list. Each block also has a
   bitmask of allocated elements in the set.
   \---------------------------------------------------------------------------
   Set type
   Usage:
   typedef struct name_tag { } \<name\>;
   \#define MAX\<name\>SPERSET
   DeclareSet( \<name\> );
   Should alias GetFromset, DeleteFromSet, CountUsedInSet,
   GetLinearSetArray
   etc so that the type name is reflected there
   another good place where #define defining defines is good.
   \---------------------------------------------------------------------------
                                                                                */
_SETS_NAMESPACE
//---------------------------------------------------------------------------
// Set type
//   Usage:
//      typedef struct name_tag { } <name>;
//      #define MAX<name>SPERSET
//      DeclareSet( <name> );
//    Should alias GetFromset, DeleteFromSet, CountUsedInSet, GetLinearSetArray
//       etc so that the type name is reflected there
//       another good place where #define defining defines is good.
//---------------------------------------------------------------------------
/* Hard coded 32 bit division for getting word index. (x\>\>5) */
#define UNIT_USED_IDX(n)   ((n) >> 5)
/* Hard coded 32 bit division for getting bit index. (x &amp;
   0x1f)                                                      */
#define UNIT_USED_MASK(n)  (1 << ((n) &0x1f))
/* A macro for use by internal code that marks a member of a set
   as used.
   Parameters
   set :    pointer to a genericset
   index :  item to mark used.                                   */
#define SetUsed(set,n)   ((((set)->bUsed[UNIT_USED_IDX(n)]) |= UNIT_USED_MASK(n)), (++(set)->nUsed) )
/* A macro for use by internal code that marks a member of a set
   as available.
   Parameters
   set :    pointer to a genericset
   index :  item to mark available.                              */
#define ClearUsed(set,n) ((((set)->bUsed[UNIT_USED_IDX(n)]) &= ~UNIT_USED_MASK(n)), (--(set)->nUsed) )
/* A macro for use by internal code that tests a whole set of
   bits for used. (32 bits, can check to see if any in 32 is
   free)
   Parameters
   set :    pointer to a genericset
   index :  index of an one in the set of 32 being tested.
   Returns
   0 if not all are used.
   1 if all in this block of bits are used.                   */
#define AllUsed(set,n)   (((set)->bUsed[UNIT_USED_IDX(n)]) == 0xFFFFFFFF )
/* A macro for use by internal code that tests a member of a set
   as used.
   Parameters
   set :    pointer to a genericset
   index :  item to test used.
   Returns
   not zero if is used, otherwise is free.                       */
#define IsUsed(set,n)    (((set)->bUsed[UNIT_USED_IDX(n)]) & UNIT_USED_MASK(n) )
#ifdef __cplusplus
#define CPP_(n)
/* A macro which is used to emit code in C++ mode... */
#else
#define CPP_(n)
#endif
// requires a symbol of MAX<insert name>SPERSET to declare max size...
 //ndef __cplusplus
#if 1
#define SizeOfSet(size,count)  (sizeof(POINTER)*2+sizeof(int)+sizeof( uint32_t[((count)+31)/32] ) + ((size)*(count)))
#define DeclareSet( name )  typedef struct name##set_tag {	   struct name##set_tag *next, *prior;	                      uint32_t nUsed;	                                               uint32_t nBias;	                                               uint32_t bUsed[(MAX##name##SPERSET + 31 ) / 32];	              name p[MAX##name##SPERSET];	                           CPP_(int forall(uintptr_t(CPROC*f)(void*,uintptr_t),uintptr_t psv) {if( this ) return _ForAllInSet( (struct genericset_tag*)this, sizeof(name), MAX##name##SPERSET, f, psv ); else return 0; })	 CPP_(name##set_tag() { next = NULL;prior = NULL;nUsed = 0; nBias = 0; MemSet( bUsed, 0, sizeof( bUsed ) ); MemSet( p, 0, sizeof( p ) );} )	} name##SET, *P##name##SET
#define DeclareClassSet( name ) typedef struct name##set_tag {	   struct name##set_tag *next, *prior;	                      uint32_t nUsed;	                                               uint32_t nBias;	                                               uint32_t bUsed[(MAX##name##SPERSET + 31 ) / 32];	              class name p[MAX##name##SPERSET];	                        CPP_(int forall(uintptr_t(CPROC*)(void*f,uintptr_t),uintptr_t psv) {if( this ) return _ForAllInSet( (struct genericset_tag*)this, sizeof(class name), MAX##name##SPERSET, f, psv ); else return 0; })	 } name##SET, *P##name##SET
#endif
/* This represents the basic generic set structure. Addtional
   data is allocated at the end of this strcture to fit the bit
   array that maps usage of the set, and for the set size of
   elements.
   Remarks
   \ \
   Summary
   Generic sets are good for tracking lots of tiny structures.
   They track slabs of X structures at a time. They allocate a
   slab of X structures with an array of X bits indicating
   whether a node is used or not. The structure overall has how
   many are used, so once full, a block can be quickly checked
   whether there is anything free. Then when checking a block
   that might have room, the availablility is checked 32 bits at
   a time, until a free spot is found.
   Sets of 1024 members of x,y coordinates for example are good
   for this sort of storage. the points are often static, once
   loaded they all exist until none of them do. This storage has
   gross deletion methods too, quickly evaporate all allocated
   chunks. Storing tiny chunks in a slab is more efficient
   because every allocation method has some sort of tracking
   associated with it - an overhead of having it. Plus, when
   operating on sets of data, a single solid slab of exatly the
   structures you are working with is more efficient to cache.
   Example
   <code lang="c++">
   struct treenode_tag {
       uint32_t treenode_data;  // abitrary structure data
   };
   typedef struct treenode_tag TREENODE;
   \#define MAXTREENODESPERSET 256
   DeclareSet( TREENODE );
   </code>
   The important part of the prior code is the last two lines.
   \#define MAX\<your type name\>SPERSET \<how many\>
   This defines how many of your structure are kept per set
   block.
   The DeclareSet( type ) declares a typedefed structure called
   'struct type##set_tag', 'name##SET', and '*P##name##SET'; in
   the above case, it would be 'struct TREENODEset_tag',
   'TREENODESET', and 'PTREENODESET'.
   Then to actually use the set...
   <code lang="c#">
   // declare a set pointer with one of the magic names.
   PTREENODESET nodeset = NULL;
   // get a node from the set.
   TREENODE *node = GetFromSet( TREENODE, nodeset );
   </code>
   Notice there is no CreateSet, getting a set member will
   create the set as required. Many operations may expend the
   set, except for GetUsedSetMember which will only result with
   \members that are definatly in the set. Accesses to the set
   are all prefixed by the type name the set was created with,
   'TREENODE' in this example.
   <code lang="c++">
   DeleteFromSet( TREENODE, nodeset, node );
   node = GetFromSet( TREENODE, nodeset );
   {
      int index = GetMemberIndex( TREENODE, nodeset, node );
   }
   </code>
   The accessor macros take care of expanding several parameters
   that require sizeof structure expansion.                      */
typedef struct genericset_tag {
	// wow might be nice to have some flags...
	// first flag - bSetSet - meaning that this is a set of sets of
	// the type specified...
	struct genericset_tag *next;
	/* This is the pointer that's pointing at the pointer pointing
	   to me. (did you get that?) See <link DeclareLink>.          */
	struct genericset_tag **me;
	/* number of spots in this set block that are used. */
	uint32_t nUsed;
 // hmm if I change this here? we're hozed... so.. we'll do it anyhow :) evil - recompile please
	uint32_t nBias;
 // after this p * unit must be computed
	uint32_t bUsed[1];
} GENERICSET, *PGENERICSET;
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetFromSetEx( GENERICSET **pSet, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetFromSetEx@GENERICSET **@int@int@int maxcnt>
   \ \                                                                             */
#define GetFromSeta(ps, ss, us, max) GetFromSetPoolEx( NULL, 0, 0, 0, (ps), (ss), (us), (max) DBG_SRC )
/* <combine sack::containers::sets::GetFromSetEx@GENERICSET **@int@int@int maxcnt>
   \ \
   Parameters
   name :  name of type the set contains.
   pSet :  pointer to a set to get an element from.                                */
#define GetFromSet( name, pset ) (name*)GetFromSeta( (GENERICSET**)(pset), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET )
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  PGENERICSET  TYPELIB_CALLTYPE GetFromSetPoolEx( GENERICSET **pSetSet
													 , int setsetsize, int setunitsize, int setmaxcnt
													 , GENERICSET **pSet
													 , int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetFromSetPoolEx@GENERICSET **@int@int@int@GENERICSET **@int@int@int maxcnt>
   \ \                                                                                                           */
#define GetFromSetPoola(pl, sss, sus, smax, ps, ss, us, max) GetFromSetPoolEx( (pl), (sss), (sus), (smax), (ps), (ss), (us), (max) DBG_SRC )
/* <combine sack::containers::sets::GetFromSetPoolEx@GENERICSET **@int@int@int@GENERICSET **@int@int@int maxcnt>
   \ \                                                                                                           */
#define GetFromSetPool( name, pool, pset ) (name*)GetFromSetPoola( (GENERICSET**)(pool)	    , sizeof( name##SETSET ), sizeof( name##SET ), MAX##name##SETSPERSET	, (GENERICSET**)(pset), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET )
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                     */
#define GetSetMembera(ps, member, ss, us, max) (GetSetMemberEx( (ps), (member), (ss), (us), (max) DBG_SRC ))
/* <combine sack::containers::sets::GetSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                     */
#define GetSetMember( name, pset, member ) ((name*)GetSetMembera( (GENERICSET**)(pset), (member), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET ))
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetUsedSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetUsedSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                         */
#define GetUsedSetMembera(ps, member, ss, us, max) (GetUsedSetMemberEx( (ps), (member), (ss), (us), (max) DBG_SRC ))
/* <combine sack::containers::sets::GetUsedSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                         */
#define GetUsedSetMember( name, pset, member ) ((name*)GetUsedSetMembera( (GENERICSET**)(pset), (member), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET ))
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetMemberIndex(GENERICSET **set, POINTER unit, int unitsize, int max );
/* Gets the index of a member passed as a pointer.
   Parameters
   set :       pointer to the set the member is in
   unit :      pointer to the member in the set to get the index
               of.
   unitsize :  size of each member in the set
   max :       count of members in each set block.
   Returns
   \Returns the index of the member passed in as a pointer.      */
#define GetMemberIndex(name,set,member) GetMemberIndex( (GENERICSET**)set, member, sizeof( name ), MAX##name##SPERSET )
/* <combine sack::containers::sets::GetMemberIndex>
   \ \                                              */
#define GetIndexFromSet( name, pset ) GetMemberIndex( name, pset, GetFromSet( name, pset ) )
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteFromSetExx( GENERICSET *set, POINTER unit, int unitsize, int max DBG_PASS );
/* <combine sack::containers::sets::DeleteFromSetExx@GENERICSET *@POINTER@int@int max>
   \ \                                                                                 */
#define DeleteFromSetEx( name, set, member, xx ) DeleteFromSetExx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET DBG_SRC )
/* <combine sack::containers::sets::DeleteFromSetExx@GENERICSET *@POINTER@int@int max>
   \ \                                                                                 */
#ifdef _DEBUG
#define DeleteFromSet( name, set, member ) do { P##name##SET testset = set; DeleteFromSetExx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET DBG_SRC ); } while(0)
#else
#define DeleteFromSet( name, set, member ) DeleteFromSetExx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET DBG_SRC )
#endif
/* Marks a member in a set as usable.
   Parameters
   set :       pointer to a genericset pointer
   iMember :   index of member to delete
   unitsize :  (filled by macro) size of element in set
   max :       (filled by macro) size of a block of elements. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteSetMemberEx( GENERICSET *set, INDEX iMember, uintptr_t unitsize, INDEX max );
/* <combine sack::containers::sets::DeleteSetMemberEx@GENERICSET *@INDEX@uintptr_t@INDEX>
   \ \                                                                                   */
#define DeleteSetMember( name, set, member ) DeleteSetMemberEx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET )
/* This function can check to see if a pointer is a valid
   element from a set.
   Parameters
   set :       pointer to a set to check
   unit :      pointer to an element from the set
   unitsize :  size of element structures in the set.
   max :       count of structures per set block
   Returns
   TRUE if unit is in the set, else FALSE.                */
TYPELIB_PROC  int TYPELIB_CALLTYPE  MemberValidInSetEx( GENERICSET *set, POINTER unit, int unitsize, int max );
/* <combine sack::containers::sets::MemberValidInSetEx@GENERICSET *@POINTER@int@int>
   \ \                                                                               */
#define MemberValidInSet( name, set, member ) MemberValidInSetEx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET )
TYPELIB_PROC  int TYPELIB_CALLTYPE  CountUsedInSetEx( GENERICSET *set, int max );
/* Count number of elements that are allocated in the set.
   Parameters
   set :  The set to check
   max :  max items per set (may be unused, since this is stored
          internally now)
   Returns
   The number of items in the step.                              */
#define CountUsedInSet( name, set ) CountUsedInSetEx( (GENERICSET*)set, MAX##name##SPERSET )
TYPELIB_PROC  POINTER * TYPELIB_CALLTYPE GetLinearSetArrayEx( GENERICSET *pSet, int *pCount, int unitsize, int max );
/* Converts a set into a copy of the objects in the set
   organized in a flat array.
   Parameters
   pSet :      set to convert to an array
   pCount :    address of an integer to receive the count of
               elements put in the array.
   unitsize :  size of each element in the set
   max :       count of elements per set block
   Returns
   Pointer to an array that are a copy of the objects in the
   set.                                                      */
#define GetLinearSetArray( name, set, pCount ) GetLinearSetArrayEx( (GENERICSET*)set, pCount, sizeof( name ), MAX##name##SPERSET )
/* Returned the index of an item in a linear array returned from
   a set.
   Parameters
   pArray :      pointer to an array which has been returned from
                 the set
   nArraySize :  size fo the array
   unit :        pointer to an element in the array
   Returns
   Index of the unit in the array, INVALID_INDEX if not in the
   array.                                                         */
TYPELIB_PROC  int TYPELIB_CALLTYPE  FindInArray( POINTER *pArray, int nArraySize, POINTER unit );
/* Delete all allocated slabs.
   Parameters
   ppSet :  pointer to a generic set pointer to delete. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteSet( GENERICSET **ppSet );
/* <combine sack::containers::sets::DeleteSet@GENERICSET **>
   \ \                                                       */
#define DeleteSetEx( name, ppset ) { name##SET **delete_me = ppset; DeleteSet( (GENERICSET**)delete_me ); }
/* <combine sack::containers::sets::ForAllInSet>
   ForAllinSet Callback - callback fucntion used with
   ForAllInSet                                        */
typedef uintptr_t (CPROC *FAISCallback)(void*,uintptr_t);
/* \ \
   Parameters
   pSet :      poiner to a set
   unitsize :  size of elements in the array
   max :       count of elements per set block
   f :         user callback function to call for each element in
               the set
   psv :       user data passed to the user callback when it is
               invoked for a member of the set.
   Returns
   If the user callback returns 0, the loop continues. If the
   user callback returns non zero then the looping through the
   set ends, and that result is returned.                         */
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE  _ForAllInSet( GENERICSET *pSet, int unitsize, int max, FAISCallback f, uintptr_t psv );
/* <combine sack::containers::sets::ForEachSetMember>
   ForEachSetMember Callback function - for the function '
   ForEachSetMember'                                       */
typedef uintptr_t (CPROC *FESMCallback)(INDEX,uintptr_t);
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE  ForEachSetMember ( GENERICSET *pSet, int unitsize, int max, FESMCallback f, uintptr_t psv );
 //def __cplusplus
#if 0
#define DeclareSet(name)	                                struct name##set_tag {	               uint32_t set_size;	                             uint32_t element_size;	                         uint32_t element_cnt;	                          PGENERICSET pool;	                        name##set_tag() {	                        element_size = sizeof( name );	             element_cnt = MAX##name##SPERSET;	          set_size = (element_size * element_cnt )+ ((((element_cnt + 31 )/ 32 )- 1 ) * 4) + sizeof( GENERICSET );	 pool = NULL;	                               }	    ~name##set_tag() { DeleteSet( &pool ); }	 name* grab() { return (name*)GetFromSetEx( &pool, set_size, element_size, element_cnt DBG_SRC ); }	 name* grab(INDEX member) { return (name*)GetSetMemberEx( &pool, member, set_size, element_size, element_cnt DBG_SRC ); }	 name* get(INDEX member) { return (this)?(name*)GetUsedSetMemberEx( &pool, member, set_size, element_size, element_cnt DBG_SRC ):(NULL); }	 void drop( name* member ) { DeleteFromSetEx( pool, (POINTER)member, element_size, element_cnt ); }	 int valid( name* member ) { return MemberValidInSetEx( pool, (POINTER)member, element_size, element_cnt ); }	 uintptr_t forall( FAISCallback f, uintptr_t psv ) { if( this ) return _ForAllInSet( pool, element_size, element_cnt, f, psv ); else return 0; }	 };	       typedef struct name##set_tag *P##name##SET, name##SET;
#define ForAllInSet(name, pset,f,psv) _ForAllInSet( (GENERICSET*)(pset), sizeof( name ), MAX##name##SPERSET, (f), (psv) )
#else
/* <combine sack::containers::sets::_ForAllInSet@GENERICSET *@int@int@FAISCallback@uintptr_t>
   \ \                                                                                       */
#define ForAllInSet(name, pset,f,psv) _ForAllInSet( (GENERICSET*)(pset), sizeof( name ), MAX##name##SPERSET, (f), (psv) )
/* Performs an iteration over each allocated set member. Calls
   the user provided callback routine with each element in the
   set.
   Parameters
   pSet :      pointer to the set to iterate
   unitsize :  size of each element
   max :       max count of elements per set block
   f :         function to call ( uintptr_t (*)(INDEX,uintptr_t) )
   psv :       user data value to pass to function as uintptr_t
   Returns
   uintptr_t - this value is the return of the user function if
   the function does not return 0. A non zero return from the
   user callback stops iteration.                                */
#define ForEachSetMember(name,pset,f,psv) ForEachSetMember( (GENERICSET*)(pset),sizeof(name),MAX##name##SPERSET, (f), (psv) )
#endif
//---------------------------------------------------------------------------
_SETS_NAMESPACE_END
_TEXT_NAMESPACE
// this defines more esoteric formatting notions...
// these data blocks will be zero sized, and ahve the TF_FORMATEX
// bit set.
//#define DEFAULT_COLOR 0xF7
//#define PRIOR_COLOR 0xF6 // this does not change the color....
// these enumerated ops put in the foreground field of a format
// with a flag of TF_FORMATEX will cause the specified operation
// to be carried out on a display (not files) or generated into
// the appropriate sequence (ansi out encode)
// -- correction
//  this is encoded into its own field for the format
// size, due to machine optimization, 16 bits were free
// this was expanded and used for all information
// a segment may contain extended op, color, attributes,
// and text, everything short of a font for it...
//  - not sure how to address that issue... there's
// certainly modifications to current font... italic for
// instance..
	enum FORMAT_OPS {
      /* this segment clears to the end of the line.  Its content is then added to the output */
		FORMAT_OP_CLEAR_END_OF_LINE = 1
        ,FORMAT_OP_CLEAR_START_OF_LINE
                   ,
						  FORMAT_OP_CLEAR_LINE
						 ,
						  FORMAT_OP_CLEAR_END_OF_PAGE
                   ,
						  FORMAT_OP_CLEAR_START_OF_PAGE
						 ,
/* clear the entire vieable page (pushes all content to history)
                    set cursor home ;6*/
						  FORMAT_OP_CLEAR_PAGE
						 ,
						  FORMAT_OP_CONCEAL
                   ,
						  FORMAT_OP_DELETE_CHARS
                   ,
						  FORMAT_OP_SET_SCROLL_REGION
                   ,
						  FORMAT_OP_GET_CURSOR
						 ,
						  FORMAT_OP_SET_CURSOR
						 ,
						  FORMAT_OP_PAGE_BREAK
						 ,
/* break between paragraphs - kinda same as lines...
						  since lines are as long as possible... ;13 */
						 FORMAT_OP_PARAGRAPH_BREAK
						 ,
/* Justify line(s if wrapped) to the right
						   This attribute should be passed through to renderer;14*/
                   FORMAT_OP_JUSTIFY_RIGHT
						 ,
/* Justify line(s if wrapped) to the center
						 This attribute should be passed through to renderer;15*/
                   FORMAT_OP_JUSTIFY_CENTER
};
//typedef struct text_color_tag { uint32_t color: 8; } TEXTCOLOR;
// this was a 32 bit structure, but 8 fore, 8 back
// 8 x, 8 y failed for positioning...
// extended position, added more information
// reduced color, 16 colors is really all that there
// are... 4 bits... added bits for extended formatting
// like blink, bold, wide, high
// foreground/background  values will be
// sufficient... they retain full informaiton
//
typedef struct format_info_tag
{
   /* bit-packed flags indicating the type of format information that is applied to this segment.*/
	struct {
		// extended operation from enumeration above...
		// might shrink if more attributes are desired...
		// if many more are needed, one might consider
      // adding FONT!
     /* this segment uses the prior foreground, not its own. */
		BIT_FIELD prior_foreground : 1;
     /* this segment uses the prior background, not its own. */
		BIT_FIELD prior_background : 1;
     /* this segment uses the default foreground, not its own. */
		BIT_FIELD default_foreground : 1;
      /* this segment uses the default background, not its own. */
		BIT_FIELD default_background : 1;
      /* the foreground color of this segment (0-16 standard console text [ANSI text]) */
		BIT_FIELD foreground : 4;
      /* the background color of this segment (0-16 standard console text [ANSI text]) */
		BIT_FIELD background : 4;
      /* a bit indicating the text should blink if supported */
		BIT_FIELD blink : 1;
      /* a bit indicating the foreground and background color should be reversed */
		BIT_FIELD reverse : 1;
		// usually highly is bolder, perhaps it's
      // a highlighter effect and changes the background
		BIT_FIELD highlight : 1;
		// this is double height modifications to the font...
		BIT_FIELD tall : 1;
      // this is thicker characters...
		BIT_FIELD bold : 1;
      // draw a line under the text...
		BIT_FIELD underline : 1;
		// strike through - if able, draw a line right
		// through the middle of the text... maybe
		// it's a wiggly scribble line?  maybe that
      // could be extended again?
		BIT_FIELD strike : 1;
      // text is drawn wide (printer kinda font?)
		BIT_FIELD wide : 1;
       // this is pretty common......
		BIT_FIELD italic : 1;
		// --
		// these flags are free, but since we already have text segments
		// and I'm bringing in consoles, perhaps we should consider using
		// this to describe captions, but provide the api layer for CTEXTSTR
		// --
		// position data remains constant.
		// text is mounted at the top/left of the
		// first character... (unless center, then
		// the position specifies the middle of the text
		// draw vertical instead of horizontal
		BIT_FIELD bVertical:1;
		// draw opposite/upside down from normal
		// vertical/down, right/left upside down if not centered
		// if centered, the text pivots around position.
		BIT_FIELD bInvert:1;
		// 0 = default alignment 1 = left, 2 = center 3 = right
		// 0 is not set, the flag set in the lower 32 bit flags
		// is not needed any longer.... anything non zero
		// is that operation to apply.
		BIT_FIELD bAlign:2;
      /* format op indicates one of the enum FORMAT_OPS applies to this segment */
		BIT_FIELD format_op : 7;
	} flags;
	// if x,y are valid segment will have TF_POSFORMAT set...
	union {
		/* Coordinate information attached to a text segment. */
		/* Positioning specification of this text segment. with
		   basically 0 format options, position is used.
		   Position represents the distance from this segment to the
		   prior segment in count of tabs and spaces.
		   coords specifies an x,y coordinate location for the segment.
		   Usage of this union is dependant on <link text::format_info_tag::flags@1::format_op, format_op>. */
		struct {
         // Signed coordinate of this segment on a text display.  May be relative depending on format_op.
			int16_t x;
         // Signed coordinate of this segment on a text display.  May be relative depending on format_op.
			int16_t y;
		} coords;
		/* Defines the distance from the prior segment in count of tabs
		   and spaces (mostly count of spaces).                         */
		struct {
   // tabs preceed spaces....
			uint16_t tabs;
 // not sure what else to put with this...
			uint16_t spaces;
		} offset;
	} position;
} FORMAT, *PFORMAT;
 // special coordinate which is NO coordinate
#define IGNORE_CURSOR_POS -16384
/* test flag, format has position data */
#define TF_FORMATPOS (TF_FORMATABS|TF_FORMATREL|TF_FORMATEX)
/* these flags are used in PTEXT.flags member
 applications may use these flags to group expressions
 will affect the BuildLine but is not generated by library.
( TF_QUOTE, TF_SQUOTE, TF_BRACKET, TF_BRACE, TF_PAREN, and TF_TAG).
*/
enum TextFlags {
   // declared in program data.... do NOT release
 TF_STATIC    = 0x00000001,
   // double quoted string segment " "
 TF_QUOTE     = 0x00000002,
   // single quoted string ' '
 TF_SQUOTE    = 0x00000004,
   // bracketed expression []
 TF_BRACKET   = 0x00000008,
   // braced expression {}
 TF_BRACE     = 0x00000010,
   // parenthised expression ()
 TF_PAREN     = 0x00000020,
   // HTML tag like expression &lt;&gt;
 TF_TAG       = 0x00000040,
   // foreground is FORMAT_OP
 TF_FORMATEX  = 0x00000080,
   // x,y position used (relative)
 TF_FORMATREL = 0x00000100,
   // size field extually points at PTEXT
 TF_INDIRECT  = 0x00000200,
   // format position is x/y - else space count
 TF_FORMATABS = 0x00000800,
   // set during burst for last segment...
 TF_COMPLETE  = 0x00001000,
   // set for non-text variable
 TF_BINARY    = 0x00002000,
   // on release release indrect also...
 TF_DEEP      = 0x00004000,
   // set on first segment to send to omit lead \r\n
 TF_NORETURN  = 0x00008000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
// Low bound of value...
  TF_LOWER     = 0x00010000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
  // Upper bound of a value...
  TF_UPPER     = 0x00020000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
// boundry may be ON this value...
 TF_EQUAL     = 0x00040000,
   // this segment is not a permanent part (SubstToken)
 TF_TEMP      = 0x00080000,
  // this is something special do not treat as text indirect.
 TF_APPLICATION = 0x00100000,
};
//--------------------------------------------------------------------------
// flag combinatoin which represents actual data is present even with 0 size
// extended format operations (position, ops) are also considered data.
#define IS_DATA_FLAGS (TF_QUOTE|TF_SQUOTE|TF_BRACKET|TF_BRACE|                              TF_PAREN|TF_TAG|TF_FORMATEX|TF_FORMATABS|TF_FORMATREL)
#define DECLTEXTSZTYPE( name, size ) struct {    uint32_t flags;    struct text_segment_tag *Next, *Prior;    FORMAT format;    DECLDATA(data, size); } name
/* A macro to declare a structure which is the same physically
   as a PTEXT, (for declaring static buffers). Has to be cast to
   (PTEXT) is used. Is defined as a size, but no string content.
   Parameters
   name :  name of the variable to create
   size :  size of the static text element. (0 content)          */
#define DECLTEXTSZ( name, size ) DECLTEXTSZTYPE( name,(size) )	 = { TF_STATIC, NULL, NULL, {{1,1}} }
/* Defines an initializer block which can be used to satisfy a
   TEXT elemnt of a structure
   Parameters
   str :  string content of the TEXT
   Example
   <code lang="c++">
   TEXT something = DEFTEXT( "abc" );
   </code>                                                     */
#define DEFTEXT(str) {TF_STATIC,NULL,NULL,{{1,1}},{(sizeof(str)/sizeof(str[0]))-1,str}}
/* A macro to declare a structure which is the same physically
   as a PTEXT, (for declaring constant static strings
   basically). Has to be cast to (PTEXT) is used.
   Parameters
   name :   name of the variable to create
   value :  static string constant to initialize variable to.  */
#define DECLTEXT(name, str) static DECLTEXTSZTYPE( name, (sizeof(str)/sizeof(str[0])) ) = DEFTEXT(str)
/* Description
   A Text segment, it is based on DataBlock that has a length
   and an addtional region at the end of the structure which
   contains the text of the segment. Segments may have
   formatting attributes. Segments may be linked to other
   segments in a NEXTLINE/PRIORLINE. Segments may have indirect
   content, which may represent phrases. Sets of segments may
   represent sentence diagrams. A Pointer to a <link text::TEXT, TEXT>
   type.
   TEXT is a type I created to provide a variety of functions.
   One particular application was a common language processor,
   and I created the TEXT structure to store elements which are
   described by language. Sentences are words, and phases. A
   phrase is a set of words, but sometimes a word is a phrase.
   (sentence) = ( word ) ... (phrase ) ...
   (phrase) = (word)...
   hmm.. how to describe this.
   <code lang="c++">
   PTEXT phrase = NULL;
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   </code>
   <code>
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   </code>
   PTEXT segments point at other segments. A list of segments is
   a sentence. Segments can have information encoded on them
   that remove text from them. For instance, \< and \> tags
   might be removed around a phrase and stored as an attribute
   of the segment. A segment with such an attribute could be an
   indirect segment that points at a list of words which are the
   phrases in the tag.
   <code lang="c++">
   a map of two segments, and their content...
       (segment with TF_TAG) -\> (segment with TF_TAG)
             |                        |
             \+ - ("html")             + - (body) -\> (background="#000000")
   would actually expand to
      \<html\>\<body background="#000000"\>
   </code>
   See Also
   SegCreate
   burst
   TextParse
   SegAppend
   SegSubst
   SegSplit
   SegGrab
   SegDelete
   LineRelease
   BuildLine
   and also.....
   PVARTEXT                                                                  */
typedef struct text_segment_tag
{
	// then here I could overlap with pEnt .bshadow, bmacro, btext ?
   uint32_t flags;
	/* This points to the next segment in the sentence or phrase. NULL
	   if at the end of the line.                                      */
		struct text_segment_tag *Next;
	/* This points to the prior segment in the sentence or phrase. (NULL
	   if at the first segment)                                          */
		struct text_segment_tag *Prior;
	/* format is 64 bits.
      it's two 32 bit bitfields (position, expression)
	 valid if TF_FORMAT is set... */
	FORMAT format;
   /* A description of the data stored here.  It is compatible with a DATABLOCk.... */
   struct {
	   /* unsigned size; size is sometimes a pointer value...
                  this means bad thing when we change platforms... Or not, since we went to uintptr_t which is big enough for a pointer. */
		uintptr_t size;
		/* the data of the test segment
		 beginning of var data - this is created size+sizeof(TEXT) */
		   TEXTCHAR  data[1];
	} data;
} TEXT, *PTEXT;
//
// PTEXT DumpText( PTEXT somestring )
//    PTExT (single data segment with full description \r in text)
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  DumpText ( PTEXT text );
//SegCreateFromText( ".." );
// Burst, SegAppend, SegGrab
// segments are ment to be lines, the meaninful tag "TF_NORETURN" means it's part of the prior line.
//--------------------------------------------------------------------------
#define HAS_WHITESPACE(pText) ( pText && ( (pText)->format.position.offset.spaces || (pText)->format.position.offset.tabs ) )
/* A convenient macro to go from one segment in a line of text
   to the next segment.                                        */
#define NEXTLINE(line)   ((PTEXT)(((PTEXT)line)?(((PTEXT)line)->Next):(NULL)))
/* A convenient macro to go from one segment in a line of text
   to the prior segment.                                       */
#define PRIORLINE(line)  ((PTEXT)(((PTEXT)line)?(((PTEXT)line)->Prior):(NULL)))
/* Link one PTEXT segment to another. Sets one half of the links
   appropriate for usage.
   Example
   This example sets the prior pointer of 'word' to 'line'.
   <code>
   PTEXT line;
   PTEXT word;
   SETPRIORLINE( word, line );
   </code>                                                       */
#define SETPRIORLINE(line,p) ((line)?(((line)->Prior) = (PTEXT)(p)):0)
/* Link one PTEXT segment to another. Sets one half of the links
   appropriate for usage.
   Example
   This example sets the next pointer of 'line' to 'word'.
   <code lang="c#">
   PTEXT line;
   PTEXT word;
   SETNEXTLINE( line, word );
   </code>                                                       */
#define SETNEXTLINE(line,p)  ((line)?(((line)->Next ) = (PTEXT)(p)):0)
/* Sets a pointer to PTEXT to the first text segment in the
   list.                                                    */
#define SetStart(line)     for(; line && PRIORLINE(line);line=PRIORLINE(line))
/* Sets a PTEXT to the last segment that it points to.
   Parameters
   line :  segment in the line to move to the end of.
   Remarks
   Updates the variable passed to point to the last segment. */
#define SetEnd(line)      for(; line && NEXTLINE(line); line=NEXTLINE(line))
// might also check to see if pseg is an indirect - setting this size would be BAD
#define SetTextSize(pseg, sz ) ((pseg)?((pseg)->data.size = (sz )):0)
/* gets the indect segment content (if any) from a PTEXT
   segment.                                              */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GetIndirect(PTEXT segment );
/* Get the format flags of a PTEXT.
                                    */
TYPELIB_PROC  uint32_t TYPELIB_CALLTYPE  GetTextFlags( PTEXT segment );
/* Gets the text segment length. */
TYPELIB_PROC  size_t TYPELIB_CALLTYPE  GetTextSize( PTEXT segment );
/* Gets the text of a PTEXT segment. (convert to a CTEXTSTR)
   Parameters
   segment :  segment to get the string content from         */
TYPELIB_PROC  TEXTSTR TYPELIB_CALLTYPE  GetText( PTEXT segment );
// by registering for TF_APPLICTION is set on the segment
// and flags anded with the segment flags match, the
// function is called.... the result is the actual
// segment of this - since a TF_APPLICATION is also
// TF_INDIRECT - using the size to point to some application
// defined structure instead of a PTEXT structure.
TYPELIB_PROC  void TYPELIB_CALLTYPE  RegisterTextExtension ( uint32_t flags, PTEXT(CPROC*)(uintptr_t,POINTER), uintptr_t );
// similar to GetIndirect - but results in the literal pointer
// instead of the text that the application may have registered to result with.
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE  GetApplicationPointer ( PTEXT text );
/* Used to set the content of a segment to some application
   defined value. This allows a users application to store
   chunks of data in lists of text. These external chunks are
   handled like other words.
   Parameters
   text :  this is the text segment to set application data on
   p :     this is a pointer to application data               */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetApplicationPointer ( PTEXT text, POINTER p);
/* Set segment's indirect data.
   Parameters
   segment :  pointer to a TEXT segment to set the indirect content
              of.
   data :     pointer to a PTEXT to be referenced indirectly.       */
#define SetIndirect(Seg,Where)  ( (Seg)->data.size = ((uintptr_t)(Where)-(uintptr_t)NULL) )
		/* these return 1 for more(l1&gt;l2) -1 for (l1&lt;l2) and 0 for match.
       */
TYPELIB_PROC  int TYPELIB_CALLTYPE  SameText ( PTEXT l1, PTEXT l2 );
/* A test if one PTEXT is similar to another PTEXT.
   Parameters
   l1 :  PTEXT segment one
   l2 :  PTEXT segment two
   Return Value List
   \<0 :  l1 with case insensitive comparison is less then l2
   0 :    Texts compare case insenitive match
   \>0 :  l1 with case insensitive comparison is more than l2 */
TYPELIB_PROC  int TYPELIB_CALLTYPE  LikeText ( PTEXT l1, PTEXT l2 );
/* Compares if text is like a C string. Case Sensitive.
   <b>Returns</b>
   TRUE if they are alike.
   FALSE if they are different.
   <b>Parameters</b>                                    */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextIs  ( PTEXT pText, CTEXTSTR text );
/* Compares if text is like a C string. Case insensitive (like).
   Returns
   TRUE if they are alike.
   FALSE if they are different.
   Parameters
   pText :  PTEXT segment to compare
   text :   C string buffer to compare against                   */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextLike  ( PTEXT pText, CTEXTSTR text );
/* Compares if text is like a C string. Case insensitive (like). Uses min string length for max match.
   Returns
   TRUE if they are similar (both case insensitive using shorter of the strings for maxlen).
   FALSE if they are different.
   Parameters
   pText :  PTEXT segment to compare
   text :   C string buffer to compare against                   */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextSimilar  ( PTEXT pText, CTEXTSTR text );
//#define SameText( l1, l2 )  ( strcmp( GetText(l1), GetText(l2) ) )
#define textmin(a,b) ( (((a)>0)&&((b)>0))?(((a)<(b))?(a):(b)):(((a)>0)?(a):((b)>0)?(b):0) )
#ifdef __LINUX__
/* windows went with stricmp() and strnicmp(), whereas linux
 went with strcasecmp() and strncasecmp()                  */
#  ifdef UNICODE
#    ifndef NO_UNICODE_C
#      define strnicmp strncasecmp
/* windows went with stricmp() and strnicmp(), whereas linux
   went with strcasecmp() and strncasecmp()                  */
#      define stricmp strcasecmp
#    else
#      define strnicmp wcsncasecmp
/* windows went with stricmp() and strnicmp(), whereas linux
   went with strcasecmp() and strncasecmp()                  */
#      define stricmp wcscasecmp
#    endif
#  else
#    define strnicmp strncasecmp
/* windows went with stricmp() and strnicmp(), whereas linux
   went with strcasecmp() and strncasecmp()                  */
#     define stricmp strcasecmp
#  endif
#endif
/* Copy segment formatting to another segment... */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SegCopyFormat( PTEXT to_this, PTEXT copy_this );
/* Create a text segment of sepecified size; inclues one more character for NUL terminator */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateEx( size_t nSize DBG_PASS );
/* Create a PTEXT with specified number of character capacity.
   Example
   <code lang="c#">
   PTEXT text = SegCreate( 10 );
   </code>                                                     */
#define SegCreate(s) SegCreateEx(s DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromText> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromTextEx( CTEXTSTR text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromText( WIDE("Around the world in a day.") );
   </code>                                                         */
#define SegCreateFromText(t) SegCreateFromTextEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromCharLenEx( const char *text, size_t len DBG_PASS );
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromCharEx( const char *text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromChar( "Around the world in a day." );
   </code>                                                         */
#define SegCreateFromChar(t) SegCreateFromCharEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
#define SegCreateFromCharLen(t,len) SegCreateFromCharLenEx((t),(len) DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromWideLenEx( const wchar_t *text, size_t len DBG_PASS );
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromWideEx( const wchar_t *text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromWideLen( L"Around the world in a day.", 26 );
   </code>                                                         */
#define SegCreateFromWideLen(t,len) SegCreateFromWideLenEx((t),(len) DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
#define SegCreateFromWide(t) SegCreateFromWideEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateIndirect> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateIndirectEx( PTEXT pText DBG_PASS );
/* Creates a text segment that refers to the parameter
   indirectly. The new segment is not really a clone, but a
   reference of the original PTEXT.
   Example
   <code lang="c#">
   PTEXT phrase = SegCreateIndirect( SegAppend( SegCreateFromText( "Hello" )
                                              , SegCreateFromText( "World" ) ) );
   </code>
   The resulting phrase is a single segment with no prior or
   next, but its content is "HelloWorld" if it was passed to
   buildline... it's go the content of the two text segments
   linked together, but not in its buffer. It is actually a 0
   length buffer for a TEXT segment.
                                                                                  */
#define SegCreateIndirect(t) SegCreateIndirectEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegDuplicate> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegDuplicateEx( PTEXT pText DBG_PASS);
/* This duplicates a specific segment. It duplicates the first
   segment of a string. If the segment has indirect data, then
   the first segment of the indirect data is duplicated.       */
#define SegDuplicate(pt) SegDuplicateEx( pt DBG_SRC )
/* Duplicates a linked list of segments.
   Duplicates the structure of a line. The resulting line is an
   exact duplicate of the input line. All segments linked in
   exactly the same sorts of ways.
   Parameters
   line :  list of segments to duplicate                        */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  LineDuplicateEx( PTEXT pText DBG_PASS );
/* <combine sack::containers::text::LineDuplicateEx@PTEXT pText>
   \ \                                                           */
#define LineDuplicate(pt) LineDuplicateEx(pt DBG_SRC )
/* \ \
   See Also
   <link DBG_PASS>
   <link TextDuplicate> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  TextDuplicateEx( PTEXT pText, int bSingle DBG_PASS );
/* Duplicate the whole string of text to another string with
   exactly the same content.                                 */
#define TextDuplicate(pt,s) TextDuplicateEx(pt,s DBG_SRC )
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromInt> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromIntEx( int value DBG_PASS );
/* Creates a text segment from a 64 bit integer.
   Example
   <code>
   PTEXT number = SegCreateFromInt( 3314 );
   </code>                                       */
#define SegCreateFromInt(v) SegCreateFromIntEx( v DBG_SRC )
/* Converts an integer to a PTEXT segment.
   Parameters
   _64bit_value :  integer value to convert to a PTEXT segment. */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFrom_64Ex( int64_t value DBG_PASS );
/* Create a text segment from a uint64_t bit value. (long long int) */
#define SegCreateFrom_64(v) SegCreateFrom_64Ex( v DBG_SRC )
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromFloat> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromFloatEx( float value DBG_PASS );
/* Creates a text segment from a floating point value. Probably
   uses something like '%g' to format output. Fairly limited.
   Example
   <code lang="c++">
   PTEXT short_PI = SegCreateFromFloat( 3.14 );
   </code>                                                      */
#define SegCreateFromFloat(v) SegCreateFromFloatEx( v DBG_SRC )
/* Appends a list of segments to an existing list of segments. This
   assumes that the additional segment is referncing the head of
   the segment list.
   Parameters
   source :  source list to add to
   other :   additional segments to add to source.                  */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegAppend   ( PTEXT source, PTEXT other );
/* Inserts a segment before another segment.
   Parameters
   what :    what to insert into the list
   before :  insert the segments before this segment
   Returns
   The parameter 'what'.                             */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegInsert   ( PTEXT what, PTEXT before );
/* This expands a segment by a number of characters.
   Parameters
   PTEXT :  the segment to expand
   int :    count of character to expand by
   Returns
   A pointer to a new segment that is bigger, but has the same
   existing content.                                           */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegExpandEx (PTEXT source, INDEX nSize DBG_PASS );
/* <combine sack::containers::text::SegExpandEx@PTEXT@INDEX nSize>
   \ \                                                             */
#define SegExpand(s,n) SegExpandEx( s,n DBG_SRC )
/* Release a linked list of PTEXT segments.
   Parameters
   segments :  a segment in a list of segments to delete, first
               this routine goes to the start of the segment
               list, and then deletes all segments in the list.
   DBG_PASS :  debug file and line information                  */
TYPELIB_PROC  void TYPELIB_CALLTYPE   LineReleaseEx (PTEXT line DBG_PASS );
/* Release a line of text.
   A line may be a single segment.
   This is the proper way to dispose of PTEXT segments.
   Any segment in the line may be passed, the first segment is
   found, and then all segments in the line are deleted.       */
#define LineRelease(l) LineReleaseEx(l DBG_SRC )
/* \ \
   <b>See Also</b>
   <link DBG_PASS>
   <link SegRelease> */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SegReleaseEx( PTEXT seg DBG_PASS );
/* Release a single segment. UNSAFE. Does not respect that it is
   in a list.
   See Also
   <link LineRelease>                                            */
#define SegRelease(l) SegReleaseEx(l DBG_SRC )
/* Adds a part of input to the segment list of output.
   Parameters
   output\ :   the segment list to append to.
   input\ :    the input buffer to append from
   offset :    starting offset in 'input' to start from
   length :    how much from 'offset' in input to append as a new
               segment to output.
   DBG_PASS :  \file and line debugging information               */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegConcatEx   (PTEXT output,PTEXT input,int32_t offset,size_t length DBG_PASS);
/* <combine sack::containers::text::SegConcatEx@PTEXT@PTEXT@int32_t@size_t length>
   looks like it takes a peice of one segment and appends it to
   another....
   Needs More research to document correctly and exemplify.                     */
#define SegConcat(out,in,ofs,len) SegConcatEx(out,in,ofs,len DBG_SRC)
/* Removes a segment from a list of segments. Links what was
   prior and what was after together. Sets both next and prior
   of the segment unlinked to NULL.
   Example
   <code lang="c++">
   SegUnlink( segment );
   </code>
   Returns
   The segment passed.                                         */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegUnlink   (PTEXT segment);
/* Breaks a list of PTEXT segments at the specified segment and
   \returns a segment that was before the specified.
   Parameters
   segment :  segment to break the chain at
   Returns
   Any existing segment before the segment to break at.
   Example
   <code lang="c++">
   {
      PTEXT segs;
      PTEXT breakat;
      PTEXT leftover;
		&#47;* ... segs gets populated with some segments ... *&#47;
      breakat = NEXTLINE( segs );
   </code>
   <code>
      breakat = NEXTLINE( segs );
      leftover = segbreak( breakat );
      // now breakat begins a new chain of segments
      // leftover is the segment that was just before breakat
      SegStart( leftover );  // leftover would be equal to segs...
   }
   </code>                                                         */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegBreak    (PTEXT segment);
/* Removes a segment from a list. It also releases the segment.
    Example
    <code lang="c#">
    SegDelete( segment );
    </code>
    the result is NULL;                                          */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegDelete   (PTEXT segment);
/* removes segment from any list it might be in, returns
   segment.                                              */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegGrab     (PTEXT segment);
/* Substitute one PTEXT segment for another in a list of PTEXT
   segments.
   Parameters
   _this :  This is the segment to remove
   that :   This is the segment to subustitute with. This may be
            a list of segments, and it is linked in from the
            first segment to the prior to '_this' and the last to
            the next after '_this'
   Returns
   \Returns the '_this' that was substituted.                     */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegSubst    ( PTEXT _this, PTEXT that );
/* \ \
   See Also
   <link DBG_PASS>
   <link SegSplit> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegSplitEx( PTEXT *pLine, INDEX nPos DBG_PASS);
/* Split a PTEXT segment.
   Example
   \ \
   <code lang="c++">
   PTEXT result = SegSplit( &amp;old_string, 5 );
   </code>
   Returns
   PTEXT new_string;
   Remarks
   the old string segment is split at the position indicated. The
   pointer to the old segment is modified to point to now two
   segments linked dynamically, each part of the segment after
   the split. If the index is beyond the bounds of the segment,
   the segment remains unmodified.                                */
#define SegSplit(line,pos) SegSplitEx( line, pos DBG_SRC )
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  FlattenLine ( PTEXT pLine );
/* Create a highest precision signed integer from a PTEXT. */
TYPELIB_PROC  int64_t TYPELIB_CALLTYPE  IntCreateFromSeg( PTEXT pText );
/* Converts a text to the longest precision signed integer
   value.                                                  */
TYPELIB_PROC  int64_t TYPELIB_CALLTYPE  IntCreateFromText( CTEXTSTR p );
/* Create a high precision floating point value from PTEXT
   segment.                                                */
TYPELIB_PROC  double TYPELIB_CALLTYPE  FloatCreateFromSeg( PTEXT pText );
/* Create a high precision floating point value from text
   string.                                                */
TYPELIB_PROC  double TYPELIB_CALLTYPE  FloatCreateFromText( CTEXTSTR p, CTEXTSTR *pp );
//
// IsSegAnyNumber returns 0 if no, 1 if is int, 2 if is float
//   if pfNumber or piNumber are available then the text pointer
//   will be updated to the next segment after what was used to resolve
//   the number.
//   bUseAllSegs is for testing pTexts which are indirect, such that
//      only all segments within the indirect segment will result valid.
//   pfNumber and piNumber may be passed as NULL, and the function can still
// be used to determine ifnumber
//   the number resulting in the values pointed to will be filled in
//    with (*pfNumber)=FltCreateFromSeg(p) (or Int as appropriate)
//
//#define IsNumber(p) IsSegAnyNumberEx( &(p), NULL, NULL, NULL, 0 )
#define IsIntNumber(p, pint) IsSegAnyNumberEx( &(p), NULL, pint, NULL, 0 )
/* Tests a PTEXT segment to see if it might be a floating point
   number.                                                      */
#define IsFltNumber(p, pflt) IsSegAnyNumberEx( &(p), pflt, NULL, NULL, 0 )
/* Tests the content of a PTEXT to see if it might be a number.
   Parameters
   ppText :       pointer to PTEXT to check
   pfNumber :     pointer to double to get result of number it's
                  a float
   piNumber :     pointer to a signed 64 bit value to get the
                  \result if it's not a float.
   pbIsInt :      point to a integer \- receives boolean result
                  if the segment was an integer is TRUE else it's
                  a double.
   bUseAllSegs :  if TRUE, use all the segments starting with the
                  first, and update the pointer to the next
                  stgment. If false, use only the first segment. if
                  uses all segments, it must also use ALL
                  segments to get the number.
   Returns
   0 if not a number or fails.
   1 if a valid conversion took place.                              */
TYPELIB_PROC  int TYPELIB_CALLTYPE  IsSegAnyNumberEx ( PTEXT *ppText, double *pfNumber, int64_t *piNumber, int *pbIsInt, int bUseAllSegs );
/* <combine sack::containers::text::IsSegAnyNumberEx@PTEXT *@double *@int64_t *@int *@int>
   \ \                                                                                  */
#define IsSegAnyNumber(pptext, pfNum, piNum, pbIsInt) IsSegAnyNumberEx( pptext, pfNum, piNum, pbIsInt, 0 )
/* \Returns the amount of space required to store this segment,
   and all indirect statements it contains.
   Parameters
   segment :   segment to measure
   position :  starting position in the segment to measure from
   nTabSize :  how big tabs are supposed to be
   tabs :      list of tab positions (for arbitrary tab
               positioning\- table column alignment?)           */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentSpaceEx ( PTEXT segment, INDEX position, int nTabs, INDEX *tabs);
/* \Returns the amount of space required to store this segment,
   and all indirect statements it contains.
   Parameters
   segment :   segment to measure
   position :  starting position in the segment to measure
               from
   nTabSize :  how big tabs are supposed to be                  */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentSpace ( PTEXT segment, INDEX position, int nTabSize );
/* Simlar to getsegment space... */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentLengthEx ( PTEXT segment, INDEX position, int nTabs, INDEX *tabs );
/* \Returns the length of a single PTEXT segment.
   Parameters
   segment :   segment to measure
   position :  string position in the string to measure
   nTabSize :  how many characters a tab is supposed to be. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentLength ( PTEXT segment, INDEX position, int nTabSize );
/* Measure the length of a list of segments (combined length of
   all linked segments)                                         */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  LineLengthExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL );
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  LineLengthExx( PTEXT pt, LOGICAL bSingle,PTEXT pEOL );
/* <combine sack::containers::text::LineLengthExEx@PTEXT@LOGICAL@int@PTEXT>
   \ \                                                                      */
#define LineLengthExx(pt,single,eol) LineLengthExEx( pt,single,8,eol)
/* \ \
   Parameters
   Text segment :  PTEXT line or segment to get the length of
   single :        boolean, if set then only a single segment is
                   measured, otherwise all segments from this to
                   the end are measured.                         */
#define LineLengthEx(pt,single) LineLengthExx( pt,single,NULL)
/* Computes the length of characters in a line, if all segments
   in the line are flattened into a single word.                */
#define LineLength(pt) LineLengthEx( pt, FALSE )
/* Collapses an indirect segment or a while list of segments
   into a single segment with content expanded. When passed to
   things like TextParse and Burst, segments have their
   positioning encoded to counters for tabs and spaces; the
   segment itself contains only text without whitespace. Buildline
   expands these segments into their plain text representation.
   Parameters
   pt :        pointer to a PTEXT segment.
   bSingle :   if TRUE, build only the first segment. If the
               segment is indirect, builds entire content of
               indirect.
   nTabsize :  how wide tabs are. When written into a line, tabs
               are written as spaces. (maybe if 0, tabs are
               emitted directly?)
   pEOL :      the segment to use to represent an end of line. Often
               this is a SegCreate(0) segment.                       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  BuildLineExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL DBG_PASS );
/* Collapses an indirect segment or a while list of segments
into a single segment with content expanded. When passed to
things like TextParse and Burst, segments have their
positioning encoded to counters for tabs and spaces; the
segment itself contains only text without whitespace. Buildline
expands these segments into their plain text representation.
Parameters
pt :        pointer to a PTEXT segment.
bSingle :   if TRUE, build only the first segment. If the
segment is indirect, builds entire content of
indirect.
pEOL :      the segment to use to represent an end of line. Often
this is a SegCreate(0) segment.                       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  BuildLineExx( PTEXT pt, LOGICAL bSingle, PTEXT pEOL DBG_PASS );
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
\ \                                                                          */
#define BuildLineExx(from,single,eol) BuildLineExEx( from,single,8,NULL DBG_SRC )
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
   \ \                                                                          */
#define BuildLineEx(from,single) BuildLineExEx( from,single,8,NULL DBG_SRC )
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
   \ \
    Flattens all segments in a line to a single segment result.
*/
#define BuildLine(from) BuildLineExEx( from, FALSE,8,NULL DBG_SRC )
//
// text parse - more generic flavor of burst.
//
//static CTEXTSTR normal_punctuation=WIDE("\'\"\\({[<>]}):@%/,;!?=*&$^~#`");
// filter_to_space WIDE(" \t")
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  TextParse ( PTEXT input, CTEXTSTR punctuation, CTEXTSTR filter_tospace, int bTabs, int bSpaces  DBG_PASS );
/* normal_punctuation=WIDE("'"\\({[\<\>]}):@%/,;!?=*&amp;$^~#`");
   Process a line of PTEXT into another line of PTEXT, but with
   words parsed as appropriate for common language.
   Parameters
   input\ :  pointer to a list of PTEXT segments to parse.
   Remarks
   Burst is a simple method of breaking a sentence into its word
   and phrase parts. It collapses space and tabs before words
   into the word. Any space representation is space preceeding
   the word. Sentences are also broken on any punctuation.
   "({[\<\>]})'";;.,/?\\!@#$%^&amp;*=" for instances. + and - are
   treated specially if they prefix numbers, otherwise they are
   also punctuation. Also groups of '.' like '...' are kept
   together. if the '.' is in a number, it is stored as part of
   the number. Otherwise a '.' used in an abbreviation like P.S.
   will be a '.' with 0 spaces followed by a segment also with 0
   spaces. (unless it's the lsat one)
   so initials are encoded badly.
   Bugs
   There is an exploit in the parser such that . followed by a
   number will cause fail to break into seperate words. This is
   used by configuration scripts to write binary blocks, and
   read them back in, having the block parsed into a segment
   correctly.
   See Also
   <link sack::containers::text::TextParse@PTEXT@CTEXTSTR@CTEXTSTR@int@int bSpaces, TextParse> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  burstEx( PTEXT input DBG_PASS);
/* <combine sack::containers::text::burstEx@PTEXT input>
   \ \                                                   */
#define burst( input ) burstEx( (input) DBG_SRC )
/* Compares a couple lists of text segments.
   Parameters
   pt1 :      pointer to a phrase
   single1 :  use only the first word, not the whole phrase
   pt2 :      pointer to a phrase
   single2 :  use only the first segment, not the whole phrase
   bExact :   if FALSE, match case insensitive, otherwise match
              exact case.                                       */
TYPELIB_PROC  int TYPELIB_CALLTYPE  CompareStrings( PTEXT pt1, int single1
                            , PTEXT pt2, int single2
                            , int bExact );
/* This removes indirect segments, replacing them with their
   indirect content.
   Parameters
   pLine :  pointer to a PTEXT segment list to flatten.      */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  FlattenLine ( PTEXT pLine );
/* Steps through a linked list of segments, just a convenient
   for loop wrapper.                                          */
#define FORALLTEXT(start,var)  for(var=start;var; var=NEXTLINE(var))
/* returns number of characters filled into output.  Output needs to be at maximum 6 chars */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF8( char *output, TEXTRUNE rune );
/* returns number of characters filled into output.  Output needs to be at maximum 6 chars;  if overlong is set
   characters are deliberatly padded to be overlong */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF8Ex( char *output, TEXTRUNE rune, LOGICAL overlong );
/* returns number of wchar filled into output.  Output needs to be at maximum 2 wchar. */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF16( wchar_t *output, TEXTRUNE rune );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfChar( const char **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharIndexed( const char *from, size_t *index, size_t length );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfChar( const char *start, const char **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharIndexed( const char *from, size_t *index );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharW( const wchar_t **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharIndexedW( const wchar_t *from, size_t *index );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharW( const wchar_t *start, const wchar_t **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharIndexedW( const wchar_t *from, size_t *index );
TYPELIB_PROC size_t TYPELIB_CALLTYPE GetDisplayableCharacterCount( const char *string, size_t max_bytes );
TYPELIB_PROC CTEXTSTR TYPELIB_CALLTYPE GetDisplayableCharactersAtCount( const char *string, size_t character_index );
TYPELIB_PROC size_t TYPELIB_CALLTYPE  GetDisplayableCharacterBytes( const char *string, size_t character_count );
/* You Must Deallocate the result */
TYPELIB_PROC  char * TYPELIB_CALLTYPE  WcharConvertExx ( const wchar_t *wch, size_t len DBG_PASS );
/* You Must Deallocate the result */
TYPELIB_PROC  char * TYPELIB_CALLTYPE  WcharConvertEx ( const wchar_t *wch DBG_PASS );
/* <combine sack::containers::text::WcharConvertExx@wchar_t *@size_t len>
   \ \                                                                    */
#define WcharConvertLen(s,len) WcharConvertExx(s, len DBG_SRC )
/* <combine sack::containers::text::WcharConvertExx@wchar_t *@size_t len>
   \ \                                                                    */
#define WcharConvert(s) WcharConvertEx(s DBG_SRC )
/* You Must Deallocate the result */
TYPELIB_PROC wchar_t * TYPELIB_CALLTYPE CharWConvertExx ( const char *wch, size_t len DBG_PASS );
/* Convert wchar_t strings to char strings.
   Parameters
   string :    wchar_t string to convert
   DBG_PASS :  debug file and line information
   Returns
   A char * string. This string must be Release()'ed or
   Deallocate()'ed by the user.                         */
TYPELIB_PROC wchar_t * TYPELIB_CALLTYPE CharWConvertEx ( const char *wch DBG_PASS );
/* <combine sack::containers::text::CharWConvertExx@char *@size_t len>
   \ \                                                                 */
#define CharWConvertLen(s,len) CharWConvertExx(s,len DBG_SRC )
/* <combine sack::containers::text::CharWConvertExx@char *@size_t len>
   \ \                                                                 */
#define CharWConvert(s) CharWConvertEx(s DBG_SRC )
//--------------------------------------------------------------------------
/* This is a string collector type.  It has an interface to be able to vtprintf( vartext, "format string", ... ); which appends the specified string to the collected text.
  Example
   PVARTEXT pvt = VarTextCreate();
   vtprintf( pvt, "hello world!" );
   {
      PTEXT text = VarTextGet( pvt );
	  printf( "Text is : %s(%d)", GetText( text ), GetTextSize( text ) );
	  LineRelease( text );
   }
   VarTextDestroy( &pvt );
   */
typedef struct vartext_tag *PVARTEXT;
/* Creates a variable text collector. Allows specification of
   initial size and amount to expand by. SQL Command line sample
   utility uses this and allocates like 10,000 initial and sets
   expand as 40,000, because it expects to build very large
   strings, and expansion of 32 at a time is ludicrous; if the
   space required is more than the expansion factor, then it is
   expanded by the amount required plus the expansion factor.
   Parameters
   initial :   amount of initial buffer
   exand_by :  how much to expand the buffer by when more room
               is needed
   DBG_PASS :  debug file and line parameters.                   */
TYPELIB_PROC  PVARTEXT TYPELIB_CALLTYPE  VarTextCreateExEx ( uint32_t initial, uint32_t expand DBG_PASS );
/* <combine sack::containers::text::VarTextCreateExEx@uint32_t@uint32_t expand>
   \ \                                                                */
#define VarTextCreateExx(i,e) VarTextCreateExEx(i,e DBG_SRC )
/* <combine sack::containers::text::VarTextCreateExEx@uint32_t@uint32_t expand>
   Creates a variable text collector. Default initial size and
   expansion is 0 and 32.
                                                                      */
TYPELIB_PROC  PVARTEXT TYPELIB_CALLTYPE  VarTextCreateEx ( DBG_VOIDPASS );
/* The simplest, most general way to create a PVARTEXT
   collector. The most extended vartext creator allows
   specification of how long the initial buffer is, and how much
   the buffer expands by when required. This was added to
   optimize building HUGE SQL queries, working withing 100k
   buffers that expanded by 50k at a time was a lot less
   operations than expanding 32 bytes or something at a time.    */
#define VarTextCreate() VarTextCreateEx( DBG_VOIDSRC )
/* Empties and destroys all resources associated with the
   variable text collector.
   Parameters
   pvt * :     address of a PVARTEXT reference to destroy. Sets
               the pointer to NULL when it's destroyed.
   DBG_PASS :  debugging file and line parameters
   Example
   <code lang="c++">
   {
      PVARTEXT pvt = VarTextCreate();
      VarTextDestroy( &amp;pvt );
   }
   void Function( int something DBG_PASS )
   {
      pvt = VarTextCreateEx( DBG_RELAY );
      VarTextDestroyEx( &amp;pvt DBG_RELAY );
   }
   </code>
   C++ Syntax
   \ \                                                          */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextDestroyEx ( PVARTEXT* DBG_PASS );
/* Destroy a VarText collector. */
#define VarTextDestroy(pvt) VarTextDestroyEx( pvt DBG_SRC )
/* \Internal function - used to initialize a VARTEXT structure. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextInitEx( PVARTEXT pvt DBG_PASS);
/* Probably should not be exported. Initializes a VARTEXT
   structure to prepare it for subsequent VarText operations. */
#define VarTextInit(pvt) VarTextInitEx( (pvt) DBG_SRC )
/* Empties a PVARTEXT structure.
   Parameters
   pvt :  PVARTEXT to empty.     */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextEmptyEx( PVARTEXT pvt DBG_PASS);
/* <combine sack::containers::text::VarTextEmptyEx@PVARTEXT pvt>
   \ \                                                           */
#define VarTextEmpty(pvt) VarTextEmptyEx( (pvt) DBG_SRC )
/* Add a single character to a vartext collector.
   Note
   \ \
   Parameters
   pvt :       PVARTEXT to add character to
   c :         character to add
   DBG_PASS :  optional debug information         */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddCharacterEx( PVARTEXT pvt, TEXTCHAR c DBG_PASS );
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddRuneEx( PVARTEXT pvt, TEXTRUNE c, LOGICAL overlong DBG_PASS );
/* Adds a single character to a PVARTEXT collector.
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddCharacter( pvt, 'a' );
   </code>                                          */
#define VarTextAddCharacter(pvt,c) VarTextAddCharacterEx( (pvt),(c) DBG_SRC )
/* Adds a single rune to a PVARTEXT collector. (may be multiple characters convert to UTF8)
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddRune( pvt, 'a' );
   </code>                                          */
#define VarTextAddRune(pvt,c) VarTextAddRuneEx( (pvt),(c), FALSE DBG_SRC )
/* Adds a length of data to the vartext. This allows strings
   with nuls included to be added.
   Parameters
   pvt :       PVARTEXT to add data to
   block :     pointer to data to add
   size :      length of data block to add
	DBG_PASS :  optional file and line parameters             */
#define VARTEXT_ADD_DATA_NULTERM ((size_t)0xFF000000)
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddDataEx( PVARTEXT pvt, CTEXTSTR block, size_t length DBG_PASS );
/* Adds a single character to a PVARTEXT collector.
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddData( pvt, "test one", 8 );
   </code>                                          */
#define VarTextAddData(pvt,block,length) VarTextAddDataEx( (pvt),(block),(length) DBG_SRC )
/* Commits the currently collected text to segment, and adds the
   segment to the internal line accumulator.
		 returns true if any data was added...
       move any collected text to commit... */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  VarTextEndEx( PVARTEXT pvt DBG_PASS );
/* <combine sack::containers::text::VarTextEndEx@PVARTEXT pvt>
   \ \                                                         */
#define VarTextEnd(pvt) VarTextEndEx( (pvt) DBG_SRC )
/* Gets the length of the current collection in the VARTEXT.
   Parameters
   pvt :  PVARTEXT collector to get the length.              */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  VarTextLength( PVARTEXT pvt );
/* Gets the text segment built in the VarText. The PVARTEXT is
   set to empty. Clears the collector.
   Parameters
   pvt :  PVARTEXT to get text from.                           */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  VarTextGetEx( PVARTEXT pvt DBG_PASS );
/* <combine sack::containers::text::VarTextGetEx@PVARTEXT pvt>
   \ \                                                         */
#define VarTextGet(pvt) VarTextGetEx( (pvt) DBG_SRC )
/* Used to look at the vartext collector and get the current
   collection. Does not clear the collector.
   Parameters
   pvt :       PVARTEXT collector to peek at
   DBG_PASS :  debugging file and line parameters
   Return Value List
   NULL :      No data
   not NULL :  text segment which is in the collector.       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  VarTextPeekEx ( PVARTEXT pvt DBG_PASS );
/* \Returns the PTEXT that is currently in a PVARTEXT. It does
   not alter the contents of the PVARTEXT. Do not LineRelease
   this peeked value.                                          */
#define VarTextPeek(pvt) VarTextPeekEx( (pvt) DBG_SRC )
/* Increases the internal storage size of the variable text
   collector.
   Parameters
   pvt :       the var text collector to expand
   amount :    amount of size to expand the collector
   DBG_PASS :  debugging file and line parameters           */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextExpandEx( PVARTEXT pvt, INDEX size DBG_PASS );
/* Add a specified number of characters to the amount of space
   in the VARTEXT collector.                                   */
#define VarTextExpand(pvt, sz) VarTextExpandEx( (pvt), (sz) DBG_SRC )
//TYPELIB_PROC  int vtprintfEx( PVARTEXT pvt DBG_PASS TYPELIB_CALLTYPE  CTEXTSTR format, ... ;
// note - don't include format - MUST have at least one parameter passed to ...
//#define vtprintf(pvt, ...) vtprintfEx( (pvt) DBG_SRC, __VA_ARGS__ )
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  vtprintfEx( PVARTEXT pvt, CTEXTSTR format, ... );
/* <combine sack::containers::text::vtprintfEx@PVARTEXT@CTEXTSTR@...>
   Note                                                               */
#define vtprintf vtprintfEx
/* variable argument VARTEXT printf. Is passed a PVARTEXT to
   collect the formatted output using printf sort of formatting. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  vvtprintf( PVARTEXT pvt, CTEXTSTR format, va_list args );
/* encode binary buffer into base64 encoding.
   outsize is updated with the length of the buffer.
 */
TYPELIB_PROC  TEXTCHAR * TYPELIB_CALLTYPE  EncodeBase64Ex( uint8_t* buf, size_t length, size_t *outsize, const char *encoding );
/* decode base64 buffer into binary buffer
   outsize is updated with the length of the buffer.
   result should be Release()'d
 */
TYPELIB_PROC  char * TYPELIB_CALLTYPE  DecodeBase64Ex( uint8_t* buf, size_t length, size_t *outsize, const char *encoding );
/* xor a base64 encoded string over a utf8 string, keeping the utf8 characters in the same length...
   although technically this can result in invalid character encoding where upper bits get zeroed
   result should be Release()'d
*/
TYPELIB_PROC  char * TYPELIB_CALLTYPE  u8xor( const char *a, size_t alen, const char *b, size_t blen, int *ofs );
/* xor two base64 encoded strings, resulting in a base64 string
   result should be Release()'d
*/
TYPELIB_PROC  char * TYPELIB_CALLTYPE  b64xor( const char *a, const char *b );
//--------------------------------------------------------------------------
// extended command entry stuff... handles editing buffers with insert/overwrite/copy/paste/etc...
typedef struct user_input_buffer_tag {
	// -------------------- custom cmd buffer extension
  // position counter for pulling history
	INDEX nHistory;
  // a link queue which contains the prior lines of text entered for commands.
	PLINKQUEUE InputHistory;
 // set to TRUE when nHistory has wrapped...
	int   bRecallBegin;
   /* A exchange-lock variable for controlling access to the
      \history (so things aren't being read from it while it is
      scrolling old data out).                                  */
	uint32_t   CollectionBufferLock;
  // used to store index.. for insert type operations...
	INDEX CollectionIndex;
 // flag for whether we are inserting or overwriting
	int   CollectionInsert;
 // flag for whether we are inserting or overwriting
	int   storeCR;
 // used to store partial from GatherLine
	PTEXT CollectionBuffer;
 // called when a buffer is complete.
	void (CPROC*CollectedEvent)( uintptr_t psv, PTEXT text );
  // passed to the event callback when a line is completed
	uintptr_t psvCollectedEvent;
} USER_INPUT_BUFFER, *PUSER_INPUT_BUFFER;
/* Creates a buffer structure which behaves like the command
   line command recall queue.
                                                             */
TYPELIB_PROC  PUSER_INPUT_BUFFER TYPELIB_CALLTYPE  CreateUserInputBuffer ( void );
/* Destroy a created user input buffer. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DestroyUserInputBuffer ( PUSER_INPUT_BUFFER *pci );
// negative with SEEK_SET is SEEK_END -nPos
enum CommandPositionOps {
	// defined that the x,y position in the segment should be used for absolute positioning.
   // can also be SEEK_SET
 COMMAND_POS_SET = 0,
 // defined that the x,y position in the segment should be used for relative positioning.
 // can also be SEEK_CUR
 COMMAND_POS_CUR = 1
};
/* Updates the current input position, for things like input,
   etc. Some external process indicates where in the line to set
   the cursor position.                                          */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  SetUserInputPosition ( PUSER_INPUT_BUFFER pci, int nPos, int whence );
// bInsert < 0 toggle insert.  bInsert == 0 clear isnert(set overwrite) else
// set insert (clear overwrite )
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetUserInputInsert ( PUSER_INPUT_BUFFER pci, int bInsert );
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetUserInputSaveCR( PUSER_INPUT_BUFFER pci, int bSaveCR );
/* Get the next command in the queue in the speicifed direction
   Parameters
   pci :  pointer to command input buffer
   bUp :  if TRUE \- get older command; else get the newer
          command.                                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RecallUserInput ( PUSER_INPUT_BUFFER pci, int bUp );
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GetUserInputLine( PUSER_INPUT_BUFFER pOutput );
/* Add a buffer to the history buffer.
                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  EnqueUserInputHistory ( PUSER_INPUT_BUFFER pci, PTEXT pHistory );
/* Arbitrary PTEXT blocks are fed to the user input queue with
   this.
   Parameters
   pci :     pointer to command buffer
   stroke :  the stroke to add to the buffer (may be a whole
             String or linked list of segments). or NULL if
             getting existing input...
   Return Value List
   NULL :      There is no command available \- no text followed
               by a newline.
   not NULL :  A command line collected from the input text. There
               may be multiple commands in a single 'stroke'
               buffer.
   Example
   This may be used something like .... to add the storke to the
   \input buffer, and while there is a result, get the result
   from the buffer.
   <code lang="c++">
   {
       PUSER_INPUT_BUFFER pci = CreateUserInputBuffer();
       PTEXT result;
       for( result = GatherUserInput( pci, new_stroke ); result; result = GatherUserInput( pci, NULL ) )
       {
       }
   }
   </code>                                                                                               */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GatherUserInput ( PUSER_INPUT_BUFFER pci, PTEXT stroke );
/* delete 1 character at current user input index */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteUserInput( PUSER_INPUT_BUFFER pci );
/* Converts ascii character set to ebcidc. */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE  ConvertAsciiEbdic( TEXTSTR text, INDEX length );
/* Routine to convert from ebcdic character set to ascii. */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE  ConvertEbcdicAscii( TEXTSTR text, INDEX length );
/* Converts ascii 85 to ascii */
TYPELIB_PROC TEXTSTR FtnATA( TEXTSTR buf );
/* Converts ascii character set to ascii 85  */
TYPELIB_PROC TEXTSTR ATFtnA( TEXTSTR buf );
/* Expand characters which are outside of standard ascii to URI
   compatible escapes.
   Parameters
   text :        Text to convert
   length :      max length of text to convert
   skip_slash :  if TRUE, keep slash characters as literal,
                 otherwise they get converted.                  */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE ConvertTextURI( CTEXTSTR text, INDEX length, int skip_slash );
/* Converts URI escape characters like %3B to the appropriate
   ascii characters. The resulting string must be released by
   the application.
   Parameters
   text :    TEXTCHAR * string to convert.
   length :  max length of text to convert.
   Example
   <code lang="c++">
   TEXTCHAR *sample = WIDE( "https://www.google.com/#hl=en&amp;sugexp=eqn&amp;cp=11&amp;gs_id=1a&amp;xhr=t&amp;q=%3B+%5C+%2B+:+";
   TEXTCHAR *result;
   \result = ConvertURIText( sample, StrLen( sample ) );
   \result == https://www.google.com/#hl=en&amp;sugexp=eqn&amp;cp=11&amp;gs_id=1a&amp;xhr=t&amp;q=;+\\+++:+
   </code>                                                                                                                        */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE ConvertURIText( CTEXTSTR text, INDEX length );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE ParseStringVector( CTEXTSTR data, CTEXTSTR **pData, int *nData );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE ParseIntVector( CTEXTSTR data, int **pData, int *nData );
#ifdef __cplusplus
 //namespace text {
};
#endif
//--------------------------------------------------------------------------
#ifdef __cplusplus
	namespace BinaryTree {
#endif
/* This type defines a specific node in the tree. It is entirely
   private, and is a useless definition.                         */
typedef struct treenode_tag *PTREENODE;
/* Defines a Binary Tree.
   See Also
   <link CreateBinaryTree> */
typedef struct treeroot_tag *PTREEROOT;
/* This option may be passed to extended CreateBinaryTree
   methods to disallow adding of duplicates. Otherwise
   duplicates will be added; they will be added to the side of
   the node with the same value that has less children. Trees
   are created by default without this option, allowing the
   addition of duplicates.
   Example
   <code lang="c++">
   PTREEROOT = <link CreateBinaryTreeExtended>( BT_OPT_NODUPLICATES, NULL, NULL DBG_SRC );
   </code>                                                                                 */
#define BT_OPT_NODUPLICATES 1
/* Generic Compare is the type declaration for the callback routine for user custom comparisons.
  This routine should return -1 if new is less than old, it should return 1 if new is more than old, and it
  should return 0 if new and old are the same key. */
typedef int (CPROC *GenericCompare)( uintptr_t oldnode,uintptr_t newnode );
/* Signature for the user callback passed to CreateBinaryTreeEx
   that will be called for each node removed from the binary
   list.                                                        */
typedef void (CPROC *GenericDestroy)( CPOINTER user, uintptr_t key);
/* when adding a node if Compare is NULL the default method of a
   basic unsigned integer compare on the key value is done. if
   Compare is specified the specified key value of the orginal
   node (old) and of the new node (new) is added. Result of
   compare should be ( \<0 (lesser)) ( 0 (equal)) ( \>0
   (greater))
   Example
   <code lang="c++">
   int CPROC MyGenericCompare( uintptr_t oldnode,uintptr_t newnode )
   {
   </code>
   <code>
      if(oldnode\>newnode)
          return 1;
      else if(oldnode\<newnode)
          return -1;
      else return 0;
   </code>
   <code lang="c++">
      return (oldnode\>newnode)? 1
             \:(oldnode\<newnode)? -1
             \:0;
   }
   void CPROC MyGenericDestroy(POINTER user, uintptr_t key)
   {
      // do something custom with your user data and or key value
   }
   PTREEROOT tree = CreateBinaryTreeExtended( 0 // BT_OPT_NODUPLICATES
                                            , MyGenericCompare
                                            , MyGenericDestroy
                                            <link DBG_PASS, DBG_SRC> );
   </code>
   See Also
   <link CreateBinaryTreeExx>
   <link CreateBinaryTreeEx>
   <link CreateBinaryTree>                                               */
TYPELIB_PROC  PTREEROOT TYPELIB_CALLTYPE  CreateBinaryTreeExtended( uint32_t flags
															, GenericCompare Compare
															, GenericDestroy Destroy DBG_PASS);
/* This is the simpler case of <link CreateBinaryTreeExtended>,
   which does not make you pass DBG_SRC.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTreeExx( BT_OPT_NODUPLICATES, NULL, NULL );
   </code>                                                                  */
#define CreateBinaryTreeExx(flags,compare,destroy) CreateBinaryTreeExtended(flags,compare,destroy DBG_SRC)
/* Creates a binary tree, allowing specification of comparison
   and destruction routines.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTreeEx( <link CreateBinaryTreeExtended, MyGenericCompare>, <link CreateBinaryTreeExtended, MyGenericDestroy> );
   </code>                                                                                                                                      */
#define CreateBinaryTreeEx(compare,destroy) CreateBinaryTreeExx( 0, compare, destroy )
/* This is the simplest way to create a binary tree.
   The default compare routine treats 'key' as an integer value
   that is compared against other for lesser/greater condition.
   This tree also allows duplicates to be added.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   </code>                                                      */
#define CreateBinaryTree() CreateBinaryTreeEx( NULL, NULL )
/* \ \
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   DestroyBinaryTree( tree );
   tree = NULL;
   </code>                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DestroyBinaryTree( PTREEROOT root );
/* Drops all the nodes in a tree so it becomes empty...
   \ \
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   ResetBinaryTree( tree );
   tree = NULL;
   </code>                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  ResetBinaryTree( PTREEROOT root );
/* Balances a binary tree. If data is added to a binary list in
   a linear way (from least to most), the tree can become
   unbalanced, and all be on the left or right side of data. This
   routine can analyze branches and perform rotations so that
   the tree can be discretely rebalanced.
   Example
   <code lang="c++">
   <link PTREEROOT> tree;
   // <link AddBinaryNode>...
   BalanceBinaryTree( tree );
   </code>                                                        */
TYPELIB_PROC  void TYPELIB_CALLTYPE  BalanceBinaryTree( PTREEROOT root );
/* \ \
   See Also
   <link AddBinaryNode>
   <link DBG_PASS>
                        */
TYPELIB_PROC  int TYPELIB_CALLTYPE  AddBinaryNodeEx( PTREEROOT root
                                                   , CPOINTER userdata
                                                   , uintptr_t key DBG_PASS );
/* Adds a user pointer identified by key to a binary list.
   See Also
   <link BinaryTree::CreateBinaryTree, CreateBinaryTree>
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   uintptr_t key = 1;
   POINTER data = NewArray( TEXTCHAR, 32 );
   AddBinaryNode( tree, data, key );
   </code>
   Parameters
   root :  PTREEROOT binary tree instance.
   data :  POINTER to some user object.
   key :   uintptr_t a integer type which can be used to identify
           the data. (used to compare in the tree).<p /><p />If
           the user has specified a custom comparison routine in
           an extended CreateBinaryTree(), then this value might
           be a pointer to some other data. Often the thing used
           to key into a binary tree is a <link CTEXTSTR>.
   Returns
   The tree may be created with <link BT_OPT_NODUPLICATES>, in
   which case this will result FALSE if the key is found
   duplicated in the list. Otherwise this returns TRUE. if the
   root parameter is NULL, the result is FALSE.                  */
#define AddBinaryNode(r,u,k) AddBinaryNodeEx((r),(u),(k) DBG_SRC )
//TYPELIB_PROC  int TYPELIB_CALLTYPE  AddBinaryNode( PTREEROOT root
//                                    , POINTER userdata
//                                    , uintptr_t key );
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveBinaryNode( PTREEROOT root, POINTER use, uintptr_t key );
/* Search in a binary tree for the specified key.
   Returns
   user data POINTER if found, else NULL.
   Example
   <code lang="c++">
   PTREEROOT tree;
   void f( void )
   {
      CPOINTER mydata = FindInBinaryTree( tree, 5 );
      if( mydata )
      {
          // found '5' as the key in the tree
      }
   }
   </code>                                          */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  FindInBinaryTree( PTREEROOT root, uintptr_t key );
// result of fuzzy routine is 0 = match.  100 = inexact match
// 1 = no match, actual may be larger
// -1 = no match, actual may be lesser
// 100 = inexact match- checks nodes near for better match.
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  LocateInBinaryTree( PTREEROOT root, uintptr_t key
														, int (CPROC*fuzzy)( uintptr_t psv, uintptr_t node_key ) );
/* During FindInBinaryTree and LocateInBinaryTree, the last
   found result is stored. This function allows deletion of that
   node.
   Example
   <code lang="c++">
   FindInBinaryTree( tree, 5 );
   RemoveLastFoundNode( tree );
   </code>                                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveLastFoundNode(PTREEROOT root );
/* Removes the currently browsed node from the tree.
   See Also
   <link GetChildNode>                               */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveCurrentNode(PTREEROOT root );
/* Basically this is meant to dump to a log, if the print
   function is passed as NULL, then the tree's contents are
   dumped to the log. It dumps a very cryptic log of how all
   nodes in the tree are arranged. But by allowing the user to
   provide a method to log his data and key, the logging is more
   meaningful based on the application. The basic code for
   managing trees and nodes works....
   Example
   <code>
   int ForEachNode( POINTER user, uintptr_t key )
   {
       // return not 1 to dump to log the internal tree structure
       return 0; // probably did own logging here, so don't log tree internal
   }
   <link PTREEROOT> tree;
   void f( void )
   {
       DumpTree( tree, ForEachNode );
   }
   </code>                                                                    */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DumpTree( PTREEROOT root
                          , int (*Dump)( CPOINTER user, uintptr_t key ) );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLeastNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLeastNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreatestNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreatestNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLesserNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLesserNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreaterNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreaterNode( PTREEROOT root );
/* \Returns the node that is set as 'current' in the tree. There
   is a cursor within the tree that can be used for browsing.
   See Also
   <link GetChildNode>                                           */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetCurrentNodeEx( PTREEROOT root, POINTER *cursor );
/* \Returns the node that is set as 'current' in the tree. There
   is a cursor within the tree that can be used for browsing.
   See Also
   <link GetChildNode>                                           */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetCurrentNode( PTREEROOT root );
/* This sets the current node cursor to the root of the node.
   See Also
   <link GetChildNode>                                        */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetRootNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetParentNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetParentNode( PTREEROOT root );
/* While browsing the tree after a find operation move to the
   next child node, direction 0 is lesser direction !0 is
   greater.
   Binary Trees have a 'current' cursor. These operations may be
   used to browse the tree.
   Example
   \ \
   <code>
   // this assumes you have a tree, and it's fairly populated, then this demonstrates
   // all steps of browsing.
   POINTER my_data;
   // go to the 'leftmost' least node. (as determined by the compare callback)
   my_data = GetLeastNode( tree );
   // go to the 'rightmost' greatest node. (as determined by the compare callback)
   my_data = GetGreatestNode( tree );
   // move to the node that is less than the current node.  (move to the 'left')
   my_data = GetLesserNode( tree );
   // move to the node that is greater than the current node.  (move to the 'right')
   my_data = GetGreaterNode( tree );
   // follow the tree to the left down from here
   my_data = GetChildNode( tree, 0 );
   // follow the tree to the right down from here
   my_data = GetChildNode( tree, 1 );
   // follow the tree up to the node above the current one.
   //  (the one who's lesser or greater points at this)
   my_data = GetParentNode( tree );
   // this is probably the least useful, but someone clever might find a trick for it
   // Move back to the node we were just at.
   //  (makes the current the prior, and moves to what the prior was,
   //     but then it's just back and forth between the last two; it's not a stack ).
   my_data = GetPriorNode( tree );
   </code>
   A more practical example...
   <code lang="c++">
   POINTER my_data;
   for( my_data = GetLeastNode( tree );
        my_data;
        my_data = GetGreaterNode( tree ) )
   {
        // browse the tree from least to most.
   }
   </code>                                                                            */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetChildNode( PTREEROOT root, int direction );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetChildNodeEx( PTREEROOT root, POINTER *cursor, int direction );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetPriorNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetPriorNode( PTREEROOT root );
/* \Returns the total number of nodes in the tree.
   Example
   <code lang="c++">
   uint32_t total_nodes = GetNodeCount(tree);
   </code>                                         */
TYPELIB_PROC  uint32_t TYPELIB_CALLTYPE  GetNodeCount ( PTREEROOT root );
 // returns a shadow of the original.
TYPELIB_PROC  PTREEROOT TYPELIB_CALLTYPE  ShadowBinaryTree( PTREEROOT root );
#ifdef __cplusplus
 //namespace BinaryTree {
	};
#endif
//--------------------------------------------------------------------------
#ifdef __cplusplus
namespace family {
#endif
/* A family tree structure, for tracking elements that have
   multiple children.
                                                            */
typedef struct familyroot_tag *PFAMILYTREE;
typedef struct familynode_tag *PFAMILYNODE;
/* <unfinished>
   Incomplete Work in progress (maybe) */
TYPELIB_PROC  PFAMILYTREE TYPELIB_CALLTYPE  CreateFamilyTree ( int (CPROC *Compare)(uintptr_t key1, uintptr_t key2)
															, void (CPROC *Destroy)(POINTER user, uintptr_t key) );
/* <unfinished>
   Incomplete, Family tree was never completed. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE  FamilyTreeFindChild ( PFAMILYTREE root
														  , uintptr_t psvKey );
/* <unfinished>
   Incomplete, Family tree was never completed. */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE FamilyTreeFindChildEx ( PFAMILYTREE root, PFAMILYNODE root_node
													 , uintptr_t psvKey );
/* Resets the search cursors in the tree... */
TYPELIB_PROC  void TYPELIB_CALLTYPE  FamilyTreeReset ( PFAMILYTREE *option_tree );
/* Resets the content of the tree (should call destroy methods, at this time it does not) */
TYPELIB_PROC  void TYPELIB_CALLTYPE  FamilyTreeClear ( PFAMILYTREE option_tree );
/* <unfinished>
   Incomplete Work in progress (maybe) */
TYPELIB_PROC  PFAMILYNODE TYPELIB_CALLTYPE  FamilyTreeAddChild ( PFAMILYTREE *root, PFAMILYNODE parent, POINTER userdata, uintptr_t key );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE FamilyTreeForEachChild( PFAMILYTREE root, PFAMILYNODE node
			, LOGICAL (CPROC *ProcessNode)( uintptr_t psvForeach, uintptr_t psvNodeData )
			, uintptr_t psvUserData );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE FamilyTreeForEach( PFAMILYTREE root, PFAMILYNODE node
			, LOGICAL (CPROC *ProcessNode)( uintptr_t psvForeach, uintptr_t psvNodeData, int level )
			, uintptr_t psvUserData );
#ifdef __cplusplus
 //namespace family {
};
#endif
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
#ifdef __cplusplus
//} // extern "c"
 // namespace containers
};
 // namespace sack
};
using namespace sack::containers::link_stack;
using namespace sack::containers::data_stack;
using namespace sack::containers::data_list;
using namespace sack::containers::data_queue;
using namespace sack::containers::queue;
using namespace sack::containers::BinaryTree;
using namespace sack::containers::text;
using namespace sack::containers::message;
using namespace sack::containers::sets;
using namespace sack::containers::family;
using namespace sack::containers;
#else
// should 'class'ify these things....
#endif
#ifndef _TYPELIBRARY_SOURCE
//#undef TYPELIB_PROC // we don't need this symbol after having built the right prototypes
#endif
#endif
// $Log: sack_typelib.h,v $
// Revision 1.99  2005/07/10 23:56:25  d3x0r
// Fix types for C++...
//
//
// Revision 1.39  2003/03/25 08:38:11  panther
// Add logging
//
SACK_NAMESPACE
#ifndef IS_DEADSTART
// this is always statically linked with libraries, so they may contact their
// core executable to know when it's done loading everyone else also...
#  ifdef __cplusplus
extern "C"
#  endif
#  if defined( WIN32 ) && !defined( __STATIC__ ) && !defined( __ANDROID__ )
#    ifdef __NO_WIN32API__
// DllImportAttribute ?
#    else
__declspec(dllimport)
#    endif
#  else
#ifndef __cplusplus
extern
#endif
#  endif
/* a function true/false which indicates whether the root
   deadstart has been invoked already. If not, one should call
   InvokeDeadstart and MarkDeadstartComplete.
   <code lang="c++">
   int main( )
   {
       if( !is_deadstart_complete() )
       {
           InvokeDeadstart();
           MarkDeadstartComplete()
       }
       ... your code here ....
       return 0;  // or some other appropriate return.
   }
   </code>
   sack::app::deadstart                                        */
LOGICAL
#  if defined( __WATCOMC__ )
__cdecl
#  endif
is_deadstart_complete( void );
#endif
/* Define a routine to call for exit().  This triggers specific code to handle shutdown event registration */
#ifndef NO_EXPORTS
#  ifdef SACK_BAG_CORE_EXPORTS
EXPORT_METHOD
#  else
IMPORT_METHOD
#  endif
#else
#  ifndef SACK_BAG_CORE_EXPORTS
	extern
#  endif
#endif
		void CPROC BAG_Exit( int code );
#ifndef NO_SACK_EXIT_OVERRIDE
#define exit(n) BAG_Exit(n)
#endif
 // namespace sack {
SACK_NAMESPACE_END
// this should become common to all libraries and programs...
 // pronounced 'kahn-struct'
/* Defines interface for Construct API.
   Description
   This API is for distributed process tracking. A launching
   program will receive notifications to cause certain events to
   happen. Applications built for use by this execution tracking
   program will register that they are loading while they are
   loading, and before the application Main() is invoked. the
   application should then call LoadComplete() once they have
   initialized and are ready to process. This allows a
   quick-wait to wait for the process to register that it is
   loading, and a longer wait for process completion. Certain
   processes may not require others to be completely loaded, but
   maybe just loading. (Two peer processes that have to
   coordinate together to have either one complete
   initialization).                                              */
/* Define the procedure call type for construct API methods. */
#define CONSTRUCT_API CPROC
#ifdef CONSTRUCT_SOURCE
#define CONSTRUCT_PROC EXPORT_METHOD
#else
/* Library linkage specification. */
#define CONSTRUCT_PROC IMPORT_METHOD
#endif
#ifdef __cplusplus
/* Defines TASK namespace (unused?) */
#define _TASK_NAMESPACE namespace task {
/* Define Construct namespace. Construct is for distributed
   process tracking project. Applications will register on-load
   that they are loading, and should register load completed
   when they are done loading, or exit.                         */
#define _CONSTRUCT_NAMESPACE namespace construct {
/* Defines TASK namespace ending.(unused?) */
#define _TASK_NAMESPACE_END }
/* Define Construct namespace end. Construct is for distributed
   process tracking project. Applications will register on-load
   that they are loading, and should register load completed
   when they are done loading, or exit.                         */
#define _CONSTRUCT_NAMESPACE_END }
#else
#define _TASK_NAMESPACE
#define _CONSTRUCT_NAMESPACE
#define _TASK_NAMESPACE_END
#define _CONSTRUCT_NAMESPACE_END
#endif
/* Define a symbol to specify full sack::task::construct
   namespace.                                            */
#define CONSTRUCT_NAMESPACE SACK_NAMESPACE _TASK_NAMESPACE _CONSTRUCT_NAMESPACE
/* Define a symbol to specify full sack::task::construct
   namespace ending.                                     */
#define CONSTRUCT_NAMESPACE_END _CONSTRUCT_NAMESPACE_END _TASK_NAMESPACE_END SACK_NAMESPACE_END
	SACK_NAMESPACE
	_TASK_NAMESPACE
	/* Registers with message service, assuming the summoner message service is active.
	 Provides communication methods with a task manager, so the application can notify,
	 start has completed.   The service is ready to work.*/
_CONSTRUCT_NAMESPACE
/* Called to indicate that a process is done initializing and is
   ready to process. Notifies summoner service of Loading
   completed. If enabled, there is also a library component that
   will run at deadstart to just confirm initializing, this
   would actually indicate the service is now ready to serve.    */
CONSTRUCT_PROC void CONSTRUCT_API LoadComplete( void );
CONSTRUCT_NAMESPACE_END
#ifdef __cplusplus
	using namespace sack::task::construct;
#endif
/*
 *  Crafted by James Buckeyne
 *  Part of SACK github.com/d3x0r/SACK
 *
 *   (c) Freedom Collective 2000-2006++, 2016++
 *
 *   created to provide standard logging features
 *   lprintf( format, ... ); simple, basic
 *   if DEBUG, then logs to a file of the same name as the program
 *   if RELEASE most of this logging goes away at compile time.
 *
 *  standardized to never use int.
 */
#ifndef LOGGING_MACROS_DEFINED
#define LOGGING_MACROS_DEFINED
#define SYSLOG_API CPROC
#ifdef SYSLOG_SOURCE
#define SYSLOG_PROC EXPORT_METHOD
#else
#define SYSLOG_PROC IMPORT_METHOD
#endif
#ifdef __cplusplus
#define LOGGING_NAMESPACE namespace sack { namespace logging {
#define LOGGING_NAMESPACE_END }; };
#else
#define LOGGING_NAMESPACE
#define LOGGING_NAMESPACE_END
#endif
#ifdef __cplusplus
	namespace sack {
/* Handles log output. Logs can be directed to UDP directed, or
   broadcast, or localhost, or to a file location, and under
   windows the debugging console log.
   lprintf
   SetSystemLog
   SystemLogTime
   there are options, when options code is enabled, which
   control logging output and format. Log file location can be
   specified generically for instance.... see Options.
	This namespace contains the logging functions. The most basic
   thing you can do to start logging is use 'lprintf'.
   <code lang="c++">
   lprintf( "My printf like format %s %d times", "string", 15 );
   </code>
   This function takes a format string and arguments compatible
   with vsnprintf. Internally strings are truncated to 4k
   length. (that is no single logging message can be more than
   4k in length).
   There are functions to control logging behavior.
   See Also
   SetSystemLog
   SystemLogTime
   SystemLogOptions
   lprintf
   _lprintf
   xlprintf
   _xlprintf
                                                                 */
		namespace logging {
#endif
/* \Parameters for SetSystemLog() to specify where the logging
   should go.                                                  */
enum syslog_types {
 // disable any log output.
SYSLOG_NONE     =   -1
,
SYSLOG_UDP      =    0
,
SYSLOG_FILE     =    1
,
 /* Set logging to output to a file. The file passed is a FILE*. This
   may be a FILE* like stdout, stderr, or some file the
   application opens.                                                */
SYSLOG_FILENAME =    2
,
 /* Set logging to go to a file, pass the string text name of the
   \file to open as the second parameter of SetSystemLog.        */
SYSLOG_SYSTEM   =    3
,
 /* Specify that logging should go to system (this actually means
   Windows system debugging channel. OutputDebugString() ).      */
SYSLOG_UDPBROADCAST= 4
// Allow user to specify a void UserCallback( char * )
// which recieves the formatted output.
,
SYSLOG_CALLBACK    = 5
,
 /* Send Logging to a specified user callback to handle. This
   lets logging go anywhere else that's not already thought of. */
SYSLOG_AUTO_FILE = SYSLOG_FILE + 100
 /* Send logging to a file. If the file is not open, open the
   \file. If no logging happens, no log file is created.     */
,
SYSLOG_SOCKET_SYSLOGD
};
#if !defined( NO_LOGGING )
#define DO_LOGGING
#endif
// this was forced, force no_logging off...
#if defined( DO_LOGGING )
#undef NO_LOGGING
#endif
#ifdef __LINUX__
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
SYSLOG_PROC  LOGICAL SYSLOG_API  IsBadReadPtr ( CPOINTER pointer, uintptr_t len );
#endif
SYSLOG_PROC  CTEXTSTR SYSLOG_API  GetPackedTime ( void );
//
typedef void (CPROC*UserLoggingCallback)( CTEXTSTR log_string );
SYSLOG_PROC  void SYSLOG_API  SetSystemLog ( enum syslog_types type, const void *data );
SYSLOG_PROC  void SYSLOG_API  ProtectLoggedFilenames ( LOGICAL bEnable );
SYSLOG_PROC  void SYSLOG_API  SystemLogFL ( CTEXTSTR FILELINE_PASS );
SYSLOG_PROC  void SYSLOG_API  SystemLogEx ( CTEXTSTR DBG_PASS );
SYSLOG_PROC  void SYSLOG_API  SystemLog ( CTEXTSTR );
SYSLOG_PROC  void SYSLOG_API  LogBinaryFL ( const uint8_t* buffer, size_t size FILELINE_PASS );
SYSLOG_PROC  void SYSLOG_API  LogBinaryEx ( const uint8_t* buffer, size_t size DBG_PASS );
SYSLOG_PROC  void SYSLOG_API  LogBinary ( const uint8_t* buffer, size_t size );
// logging level defaults to 1000 which is log everything
SYSLOG_PROC  void SYSLOG_API  SetSystemLoggingLevel ( uint32_t nLevel );
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
/* Log a binary buffer. Logs lines representing 16 bytes of data
   at a time. The hex of each byte in a buffer followed by the
   text is logged.
   Example
   <code lang="c#">
   char sample[] = "sample string";
   LogBinary( sample, sizeof( sample ) );
   </code>
   Results with the following output in the log...
   <code>
    73 61 6D 70 6C 65 20 73 74 72 69 6E 67 00 sample string.
   </code>
   The '.' at the end of 'sample string' is a non printable
   character. characters 0-31 and 127+ are printed as '.'.       */
#define LogBinary(buf,sz) LogBinaryFL((uint8_t*)(buf),sz DBG_SRC )
#define SystemLog(buf)    SystemLogFL(buf DBG_SRC )
#else
// need to include the typecast... binary logging doesn't really care what sort of pointer it gets.
#define LogBinary(buf,sz) LogBinary((uint8_t*)(buf),sz )
//#define LogBinaryEx(buf,sz,...) LogBinaryFL(buf,sz FILELINE_NULL)
//#define SystemLogEx(buf,...) SystemLogFL(buf FILELINE_NULL )
#endif
// int result is useless... but allows this to be
// within expressions, which with this method should be easy.
typedef INDEX (CPROC*RealVLogFunction)(CTEXTSTR format, va_list args )
//#if defined( __GNUC__ ) && !defined( _UNICODE )
//	__attribute__ ((__format__ (__vprintf__, 1, 2)))
//#endif
	;
typedef INDEX (CPROC*RealLogFunction)(CTEXTSTR format,...)
#if defined( __GNUC__ ) && !defined( _UNICODE )
	__attribute__ ((__format__ (__printf__, 1, 2)))
#endif
	;
SYSLOG_PROC  RealVLogFunction SYSLOG_API  _vxlprintf ( uint32_t level DBG_PASS );
SYSLOG_PROC  RealLogFunction SYSLOG_API  _xlprintf ( uint32_t level DBG_PASS );
// utility function to format a cpu delta into a buffer...
// end-start is always printed... therefore tick_end-0 is
// print absolute time... formats as millisecond.NNN
SYSLOG_PROC  void SYSLOG_API  PrintCPUDelta ( TEXTCHAR *buffer, size_t buflen, uint64_t tick_start, uint64_t tick_end );
// return the current CPU tick
SYSLOG_PROC  uint64_t SYSLOG_API  GetCPUTick ( void );
// result in nano seconds - thousanths of a millisecond...
SYSLOG_PROC  uint32_t SYSLOG_API  ConvertTickToMicrosecond ( uint64_t tick );
SYSLOG_PROC  uint64_t SYSLOG_API  GetCPUFrequency ( void );
SYSLOG_PROC  CTEXTSTR SYSLOG_API  GetTimeEx ( int bUseDay );
SYSLOG_PROC  void SYSLOG_API  SetSyslogOptions ( FLAGSETTYPE *options );
/* When setting options using SetSyslogOptions() these are the
   defines for the bits passed.
   SYSLOG_OPT_OPENAPPEND - the file, when opened, will be opened
   for append.
   SYSLOG_OPT_OPEN_BACKUP - the file, if it exists, will be
   renamed automatically.
   SYSLOG_OPT_LOG_PROGRAM_NAME - enable logging the program
   executable (probably the same for all messages, unless they
   are network)
   SYSLOG_OPT_LOG_THREAD_ID - enables logging the unique process
   and thread ID.
   SYSLOG_OPT_LOG_SOURCE_FILE - enable logging source file
   information. See <link DBG_PASS>
   SYSLOG_OPT_MAX - used for declaring a flagset to pass to
   setoptions.                                                   */
enum system_logging_option_list {
		/* the file, when opened, will be opened for append.
		 */
		SYSLOG_OPT_OPENAPPEND
										  ,
  /* the file, if it exists, will be renamed automatically.
										  */
										  SYSLOG_OPT_OPEN_BACKUP
                                ,
 /* enable logging the program executable (probably the same for
                                   all messages, unless they are network)
                                                                                                */
                                 SYSLOG_OPT_LOG_PROGRAM_NAME
										  ,
 /* enables logging the unique process and thread ID.
										                                                       */
                                 SYSLOG_OPT_LOG_THREAD_ID
                                ,
 /* enable logging source file information. See <link DBG_PASS>
                                                                                               */
										   SYSLOG_OPT_LOG_SOURCE_FILE
										  ,
										  SYSLOG_OPT_MAX
};
// this solution was developed to provide the same
// functionality for compilers that refuse to implement __VA_ARGS__
// this therefore means that the leader of the function is replace
// and that extra parenthesis exist after this... therefore the remaining
// expression must be ignored... thereofre when defining a NULL function
// this will result in other warnings, about ignored, or meaningless expressions
# if defined( DO_LOGGING )
#  define vlprintf      _vxlprintf(LOG_NOISE DBG_SRC)
#  define lprintf       _xlprintf(LOG_NOISE DBG_SRC)
#  define _lprintf(file_line,...)       _xlprintf(LOG_NOISE file_line,##__VA_ARGS__)
#  define xlprintf(level)       _xlprintf(level DBG_SRC)
#  define vxlprintf(level)       _vxlprintf(level DBG_SRC)
# else
#  ifdef _MSC_VER
#   define vlprintf      (1)?(0):
#   define lprintf       (1)?(0):
#   define _lprintf(DBG_VOIDRELAY)       (1)?(0):
#   define xlprintf(level)       (1)?(0):
#   define vxlprintf(level)      (1)?(0):
#  else
#   define vlprintf(f,...)
/* use printf formating to output to the log. (log printf).
   Parameters
   Format :  Just like printf, the format string to print.
   ... :     extra arguments passed as required for the format.
   Example
   <code lang="c++">
      lprintf( "Test Logging %d %d", 13, __LINE__ );
   </code>                                                      */
#   define lprintf(f,...)
#   define  _lprintf(DBG_VOIDRELAY)       lprintf
#   define xlprintf(level) lprintf
#   define vxlprintf(level) lprintf
#  endif
# endif
#undef LOG_WARNING
#undef LOG_ADVISORIES
#undef LOG_INFO
// Defined Logging Levels
enum {
	  // and you are free to use any numerical value,
	  // this is a rough guideline for wide range
	  // to provide a good scaling for levels of logging
 // unless logging is disabled, this will be logged
	LOG_ALWAYS = 1
 // logging level set to 50 or more will cause this to log
	, LOG_ERRORS = 50
	,
 /* Specify a logging level which only ERROR level logging is
	   logged.                                                   */
 // logging level set to 50 or more will cause this to log
	 LOG_ERROR = LOG_ERRORS
	,
 // .......
	 LOG_WARNINGS = 500
	,
 // .......
	 LOG_WARNING = LOG_WARNINGS
   ,
 /* Use to specify that the log message is a warning level
      message.                                               */
    LOG_ADVISORY = 625
   ,
    LOG_ADVISORIES = LOG_ADVISORY
	,
 /* A symbol to specify to log Adviseries, Warnings and Error
	   level messages only.                                      */
	 LOG_INFO = 750
	  ,
 /* A moderate logging level, which is near maximum verbosity of
	     logging.                                                     */
	   LOG_NOISE = 1000
     ,
 /* Define that the message is just noisy - though verbosly
	  informative, it's level is less critical than even INFO.
	  default iS LOG_NOISE which is 1000, an ddefault for disabling most messages
	  is to set log level to 999.  Have to increase to 2000 to see debug, and this name
     has beviously
	  */
      LOG_LEVEL_DEBUG = 2000
	,
 /* Specify the message is of DEBUG importance, which is far
	   above even NOISY. If debug logging is enabled, all logging,
	   ERROR, WARNING, ADVISORY, INFO, NOISY and DEBUG will be
	   logged.                                                     */
 // not quite a negative number, but really big
	 LOG_CUSTOM = 0x40000000
	,
 /* A bit with LOG_CUSTOM might be enabled, and the lower bits
	   under 0x40000000 (all bits 0x3FFFFFFF ) can be used to
	   indicate a logging type. Then SetLoggingLevel can be passed a
	   mask of bits to filter types of messages.                     */
 // not quite a negative number, but really big
	 LOG_CUSTOM_DISABLE = 0x20000000
	// bits may be user specified or'ed with this value
	// such that ...
	// Example 1:SetSystemLoggingLevel( LOG_CUSTOM | 1 ) will
	// enable custom logging messages which have the '1' bit on... a logical
	// and is used to test the low bits of this value.
	// example 2:SetSystemLogging( LOG_CUSTOM_DISABLE | 1 ) will disable logging
	// of messages with the 1 bit set.
  // mask of bits which may be used to enable and disable custom logging
#define LOG_CUSTOM_BITS 0xFFFFFF
};
 // this is a flag set consisting of 0 or more or'ed symbols
enum SyslogTimeSpecifications {
 // disable time logging
 SYSLOG_TIME_DISABLE = 0,
 // enable is anything not zero.
 SYSLOG_TIME_ENABLE  = 1,
 // specify to log milliseconds
 SYSLOG_TIME_HIGH    = 2,
 // log the year/month/day also
 SYSLOG_TIME_LOG_DAY = 4,
 // log the difference in time instead of the absolute time
 SYSLOG_TIME_DELTA   = 8,
 // logs cpu ticks... implied delta
 SYSLOG_TIME_CPU     =16
};
/* Specify how time is logged. */
SYSLOG_PROC void SYSLOG_API SystemLogTime( uint32_t enable );
#ifndef NO_LOGGING
#define OutputLogString(s) SystemLog(s)
/* Depricated. Logs a format string that takes 0 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log(s)                                   SystemLog( s )
#else
#define OutputLogString(s)
/* Depricated. Logs a format string that takes 0 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log(s)
#endif
/* Depricated. Logs a format string that takes 1 parameter.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log1(s,p1)                               lprintf( s, p1 )
/* Depricated. Logs a format string that takes 2 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log2(s,p1,p2)                            lprintf( s, p1, p2 )
/* Depricated. Logs a format string that takes 3 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log3(s,p1,p2,p3)                         lprintf( s, p1, p2, p3 )
/* Depricated. Logs a format string that takes 4 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log4(s,p1,p2,p3,p4)                      lprintf( s, p1, p2, p3,p4)
/* Depricated. Logs a format string that takes 5 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log5(s,p1,p2,p3,p4,p5)                   lprintf( s, p1, p2, p3,p4,p5)
/* Depricated. Logs a format string that takes 6 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log6(s,p1,p2,p3,p4,p5,p6)                lprintf( s, p1, p2, p3,p4,p5,p6)
/* Depricated. Logs a format string that takes 7 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log7(s,p1,p2,p3,p4,p5,p6,p7)             lprintf( s, p1, p2, p3,p4,p5,p6,p7 )
/* Depricated. Logs a format string that takes 8 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log8(s,p1,p2,p3,p4,p5,p6,p7,p8)          lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8 )
/* Depricated. Logs a format string that takes 9 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log9(s,p1,p2,p3,p4,p5,p6,p7,p8,p9)       lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8,p9 )
/* Depricated. Logs a format string that takes 10 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log10(s,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10)  lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8,p9,p10 )
LOGGING_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::logging;
#endif
#endif
#if defined( _MSC_VER ) || (1)
// huh, apparently all compiles are messed the hell up.
#  define COMPILER_THROWS_SIGNED_UNSIGNED_MISMATCH
#endif
#ifdef COMPILER_THROWS_SIGNED_UNSIGNED_MISMATCH
#  define SUS_GT(a,at,b,bt)   (((a)<0)?0:(((bt)a)>(b)))
#  define USS_GT(a,at,b,bt)   (((b)<0)?1:((a)>((at)b)))
#  define SUS_LT(a,at,b,bt)   (((a)<0)?1:(((bt)a)<(b)))
#  define USS_LT(a,at,b,bt)   (((b)<0)?0:((a)<((at)b)))
#  define SUS_GTE(a,at,b,bt)  (((a)<0)?0:(((bt)a)>=(b)))
#  define USS_GTE(a,at,b,bt)  (((b)<0)?1:((a)>=((at)b)))
#  define SUS_LTE(a,at,b,bt)  (((a)<0)?1:(((bt)a)<=(b)))
#  define USS_LTE(a,at,b,bt)  (((b)<0)?0:((a)<=((at)b)))
#else
#  define SUS_GT(a,at,b,bt)   ((a)>(b))
#  define USS_GT(a,at,b,bt)   ((a)>(b))
#  define SUS_LT(a,at,b,bt)   ((a)<(b))
#  define USS_LT(a,at,b,bt)   ((a)<(b))
#  define SUS_GTE(a,at,b,bt)  ((a)>=(b))
#  define USS_GTE(a,at,b,bt)  ((a)>=(b))
#  define SUS_LTE(a,at,b,bt)  ((a)<=(b))
#  define USS_LTE(a,at,b,bt)  ((a)<=(b))
#endif
#ifdef __cplusplus
using namespace sack;
using namespace sack::containers;
#endif
#endif
// incldue this first so we avoid a conflict.
// hopefully this comes from sack system?
/*
 *  Created by Jim Buckeyne
 *
 *  Purpose
 *    Generalization of system routines which began in
 *   dekware development.
 *   - Process control (load,start,stop)
 *   - Library runtime link control (load, unload)
 *
 */
#ifndef SYSTEM_LIBRARY_DEFINED
#define SYSTEM_LIBRARY_DEFINED
#ifdef SYSTEM_SOURCE
#define SYSTEM_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SYSTEM_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __LINUX__
// Hmm I thought that dlopen resulted in an int...
// but this doc says void * (redhat9)
//typedef void *HLIBRARY;
#else
//typedef HMODULE HLIBRARY;
#endif
#ifdef __cplusplus
#define _SYSTEM_NAMESPACE namespace system {
#define _SYSTEM_NAMESPACE_END }
#else
#define _SYSTEM_NAMESPACE
#define _SYSTEM_NAMESPACE_END
#endif
#define SACK_SYSTEM_NAMESPACE SACK_NAMESPACE _SYSTEM_NAMESPACE
#define SACK_SYSTEM_NAMESPACE_END _SYSTEM_NAMESPACE_END SACK_NAMESPACE_END
#ifndef UNDER_CE
#define HAVE_ENVIRONMENT
#endif
SACK_NAMESPACE
	_SYSTEM_NAMESPACE
typedef struct task_info_tag *PTASK_INFO;
typedef void (CPROC*TaskEnd)(uintptr_t, PTASK_INFO task_ended);
typedef void (CPROC*TaskOutput)(uintptr_t, PTASK_INFO task, CTEXTSTR buffer, size_t size );
// Run a program completely detached from the current process
// it runs independantly.  Program does not suspend until it completes.
// Use GetTaskExitCode() to get the return code of the process
#define LPP_OPTION_DO_NOT_HIDE           1
// for services to launch normal processes (never got it to work; used to work in XP/NT?)
#define LPP_OPTION_IMPERSONATE_EXPLORER  2
#define LPP_OPTION_FIRST_ARG_IS_ARG      4
#define LPP_OPTION_NEW_GROUP             8
#define LPP_OPTION_NEW_CONSOLE          16
#define LPP_OPTION_SUSPEND              32
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgramExx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
                                               , int flags
                                               , TaskOutput OutputHandler
                                               , TaskEnd EndNotice
                                               , uintptr_t psv
                                                DBG_PASS
                                               );
SYSTEM_PROC( PTASK_INFO, LaunchProgramEx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args, TaskEnd EndNotice, uintptr_t psv );
// launch a process, program name (including leading path), a optional path to start in (defaults to
// current process' current working directory.  And a array of character pointers to args
// args should be the NULL.
SYSTEM_PROC( PTASK_INFO, LaunchProgram )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR  args );
// abort task, no kill signal, sigabort basically.  Use StopProgram for a more graceful terminate.
// if (!StopProgram(task)) TerminateProgram(task) would be appropriate.
SYSTEM_PROC( uintptr_t, TerminateProgram )( PTASK_INFO task );
SYSTEM_PROC( void, ResumeProgram )( PTASK_INFO task );
// get first address of program startup code(?) Maybe first byte of program code?
SYSTEM_PROC( uintptr_t, GetProgramAddress )( PTASK_INFO task );
// before luanchProgramEx, there was no userdata...
SYSTEM_PROC( void, SetProgramUserData )( PTASK_INFO task, uintptr_t psv );
// attempt to implement a method on windows that allows a service to launch a user process
// current systems don't have such methods
SYSTEM_PROC( void, ImpersonateInteractiveUser )( void );
// after launching a process should revert to a protected state.
SYSTEM_PROC( void, EndImpersonation )( void );
// generate a Ctrl-C to the task.
// maybe also signal systray icon
// maybe also signal process.lock region
// maybe end process?
// maybe then terminate process?
SYSTEM_PROC( LOGICAL, StopProgram )( PTASK_INFO task );
// ctextstr as its own type is a pointer so a
//  PcTextStr is a pointer to strings -
//   char ** - returns a quoted string if args have spaces (and escape quotes in args?)
SYSTEM_PROC( TEXTSTR, GetArgsString )( PCTEXTSTR pArgs );
// after a task has exited, this can return its code.
// undefined if task has not exited (probably 0)
SYSTEM_PROC( uint32_t, GetTaskExitCode )( PTASK_INFO task );
// returns the name of the executable that is this process (without last . extension   .exe for instance)
SYSTEM_PROC( CTEXTSTR, GetProgramName )( void );
// returns the path of the executable that is this process
SYSTEM_PROC( CTEXTSTR, GetProgramPath )( void );
// returns the path that was the working directory when the program started
SYSTEM_PROC( CTEXTSTR, GetStartupPath )( void );
// returns the path of the current sack library.
SYSTEM_PROC( CTEXTSTR, GetLibraryPath )( void );
// on windows, queries an event that indicates the system is rebooting.
SYSTEM_PROC( LOGICAL, IsSystemShuttingDown )( void );
// HandlePeerOutput is called whenever a peer task has generated output on stdout or stderr
//   - someday evolution may require processing stdout and stderr with different event handlers
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgramEx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
                                              , TaskOutput HandlePeerOutput
                                              , TaskEnd EndNotice
                                              , uintptr_t psv
                                               DBG_PASS
                                              );
#define LaunchPeerProgram(prog,path,args,out,end,psv) LaunchPeerProgramEx(prog,path,args,out,end,psv DBG_SRC)
SYSTEM_PROC( PTASK_INFO, SystemEx )( CTEXTSTR command_line
                                   , TaskOutput OutputHandler
                                   , uintptr_t psv
                                   DBG_PASS
                                   );
#define System(command_line,output_handler,user_data) SystemEx( command_line, output_handler, user_data DBG_SRC )
// generate output to a task... read by peer task on standard input pipe
// if a task has been opened with an output handler, than IO is trapped, and this is a method of
// sending output to a task.
SYSTEM_PROC( int, pprintf )( PTASK_INFO task, CTEXTSTR format, ... );
// if a task has been opened with an otuput handler, than IO is trapped, and this is a method of
// sending output to a task.
SYSTEM_PROC( int, vpprintf )( PTASK_INFO task, CTEXTSTR format, va_list args );
typedef void (CPROC*generic_function)(void);
SYSTEM_PROC( generic_function, LoadFunctionExx )( CTEXTSTR library, CTEXTSTR function, LOGICAL bPrivate DBG_PASS);
SYSTEM_PROC( generic_function, LoadFunctionEx )( CTEXTSTR library, CTEXTSTR function DBG_PASS);
SYSTEM_PROC( void *, GetPrivateModuleHandle )( CTEXTSTR libname );
/*
  Add a custom loaded library; attach a name to the DLL space; this should allow
  getcustomsybmol to resolve these
  */
SYSTEM_PROC( void, AddMappedLibrary )( CTEXTSTR libname, POINTER image_memory );
SYSTEM_PROC( LOGICAL, IsMappedLibrary )( CTEXTSTR libname );
SYSTEM_PROC( void, DeAttachThreadToLibraries )( LOGICAL attach );
#define LoadFunction(l,f) LoadFunctionEx(l,f DBG_SRC )
SYSTEM_PROC( generic_function, LoadPrivateFunctionEx )( CTEXTSTR libname, CTEXTSTR funcname DBG_PASS );
#define LoadPrivateFunction(l,f) LoadPrivateFunctionEx(l,f DBG_SRC )
#define OnLibraryLoad(name)	  __DefineRegistryMethod(WIDE("SACK"),_OnLibraryLoad,WIDE("system/library"),WIDE("load_event"),name WIDE("_LoadEvent"),void,(void), __LINE__)
// the callback passed will be called during LoadLibrary to allow an external
// handler to download or extract the library; the resulting library should also
// be loaded by the callback using the standard 'LoadFunction' methods
SYSTEM_PROC( void, SetExternalLoadLibrary )( LOGICAL (CPROC*f)(const char *) );
// please Release or Deallocate the reutrn value
// the callback should search for the file specified, if required, download or extract it
// and then return with a Release'able utf-8 char *.
SYSTEM_PROC( void, SetExternalFindProgram )( char * (CPROC*f)(const char *) );
// override the default program name.
// Certain program wrappers might use this to change log location, configuration, etc other defaults.
SYSTEM_PROC( void, SetProgramName )( CTEXTSTR filename );
// this is a pointer pointer - being that generic_fucntion is
// a pointer...
SYSTEM_PROC( int, UnloadFunctionEx )( generic_function* DBG_PASS );
#ifdef HAVE_ENVIRONMENT
SYSTEM_PROC( CTEXTSTR, OSALOT_GetEnvironmentVariable )(CTEXTSTR name);
SYSTEM_PROC( void, OSALOT_SetEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
SYSTEM_PROC( void, OSALOT_AppendEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
SYSTEM_PROC( void, OSALOT_PrependEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
#endif
/* this needs to have 'GetCommandLine()' passed to it.
 * Otherwise, the command line needs to have the program name, and arguments passed in the string
 * the parameter to winmain has the program name skipped
 */
SYSTEM_PROC( void, ParseIntoArgs )( TEXTCHAR *lpCmdLine, int *pArgc, TEXTCHAR ***pArgv );
#define UnloadFunction(p) UnloadFunctionEx(p DBG_SRC )
SACK_SYSTEM_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::system;
#endif
#endif
//----------------------------------------------------------------------
// $Log: system.h,v $
// Revision 1.14  2005/07/06 00:33:55  jim
// Fixes for all sorts of mangilng with the system.h header.
//
//
// Revision 1.2  2003/10/24 14:59:21  panther
// Added Load/Unload Function for system shared library abstraction
//
// Revision 1.1  2003/10/24 13:22:06  panther
// Initial commit
//
//
#if defined( _MSC_VER )|| defined(__LCC__) || defined( __WATCOMC__ ) || defined( __GNUC__ )
/* Includes networking as appropriate for the target platform. Providing
   compatibility definitions as are lacking between platforms...
   or perhaps appropriate name aliasing to the correct types.            */
#ifndef INCLUDED_SOCKET_LIBRARY
#define INCLUDED_SOCKET_LIBRARY
#if defined( _WIN32 ) || defined( __CYGWIN__ )
//#ifndef __cplusplus_cli
#ifdef UNDER_CE
#define USE_WSA_EVENTS
#endif
#include <winsock2.h>
#include <ws2tcpip.h>
#if defined( MINGW_SUX ) && ( __GNUC__ < 5 )
/* Address information */
typedef struct addrinfoA {
    int             ai_flags;
    int             ai_family;
    int             ai_socktype;
    int             ai_protocol;
    size_t          ai_addrlen;
    char            *ai_canonname;
    struct sockaddr *ai_addr;
    struct addrinfoA *ai_next;
} ADDRINFOA;
typedef ADDRINFOA   *PADDRINFOA;
typedef struct addrinfoW {
    int                 ai_flags;
    int                 ai_family;
    int                 ai_socktype;
    int                 ai_protocol;
    size_t              ai_addrlen;
    PWSTR               ai_canonname;
    struct sockaddr     *ai_addr;
    struct addrinfoW    *ai_next;
} ADDRINFOW;
typedef ADDRINFOW   *PADDRINFOW;
#ifdef UNICODE
typedef ADDRINFOW   ADDRINFOT;
typedef ADDRINFOW   *PADDRINFOT;
#else
typedef ADDRINFOA   ADDRINFOT;
typedef ADDRINFOA   *PADDRINFOT;
#endif
typedef ADDRINFOA   ADDRINFO;
typedef ADDRINFOA   *LPADDRINFO;
#endif
#ifdef __CYGWIN__
// just need this simple symbol
typedef int socklen_t;
#endif
//#endif
#elif defined( __LINUX__ )
#if defined( FBSD )
#endif
 // INADDR_ANY/NONE
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#if !defined( _PNACL )
#  include <net/if.h>
#endif
#define SOCKET int
#define SOCKADDR struct sockaddr
#define SOCKET_ERROR -1
//#define HWND int // unused params...
#define WSAEWOULDBLOCK EAGAIN
#define INVALID_SOCKET -1
#define WSAAsynchSelect( a,b,c,d ) (0)
#define WSAGetLastError()  (errno)
#define closesocket(s) close(s)
typedef struct hostent *PHOSTENT;
#ifndef __LINUX__
#define INADDR_ANY (-1)
#define INADDR_NONE (0)
#endif
struct win_in_addr {
	union {
		struct { uint8_t s_b1,s_b2,s_b3,s_b4; } S_un_b;
		struct { uint16_t s_w1,s_w2; } S_un_w;
		uint32_t S_addr;
	} S_un;
#ifndef __ANDROID__
#define s_addr  S_un.S_addr
/* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
	/* host on imp */
#define s_net   S_un.S_un_b.s_b1
	/* network */
#define s_imp   S_un.S_un_w.s_w2
	/* imp */
#define s_impno S_un.S_un_b.s_b4
	/* imp # */
#define s_lh    S_un.S_un_b.s_b3
	/* logical host */
#endif
};
struct win_sockaddr_in {
#ifdef __MAC__
	uint8_t sa_len;
	uint8_t sin_family;
#else
	short   sin_family;
#endif
	uint16_t sin_port;
	struct  win_in_addr sin_addr;
	char    sin_zero[8];
};
typedef struct win_sockaddr_in SOCKADDR_IN;
#endif
#endif
// $Log: loadsock.h,v $
// Revision 1.7  2005/01/27 08:09:25  panther
// Linux cleaned.
//
// Revision 1.6  2003/06/04 11:38:01  panther
// Define PACKED
//
// Revision 1.5  2003/03/25 08:38:11  panther
// Add logging
//
#  if defined( __MAC__ )
#  else
               // _heapmin() included here
#    include <malloc.h>
#  endif
#else
//#include "loadsock.h"
#endif
//#include <stdlib.h>
#ifdef __CYGWIN__
 // provided by -lgcc
// lots of things end up including 'setjmp.h' which lacks sigset_t defined here.
// lots of things end up including 'setjmp.h' which lacks sigset_t defined here.
#  include <sys/signal.h>
#endif
// GetTickCount() and Sleep(n) Are typically considered to be defined by including stdhdrs...
/*
 *  Crafted by Jim Buckeyne
 *
 *  (c)2001-2006++ Freedom Collective
 *
 *  Provide API interface for timers, critical sections
 *  and other thread things.
 *
 */
#ifndef TIMERS_DEFINED
/* timers.h mutliple inclusion protection symbol. */
#define TIMERS_DEFINED
#if defined( _WIN32 )
// on windows, we add a function that returns HANDLE
#endif
#ifndef SHARED_MEM_DEFINED
/* Multiple inclusion protection symbol. */
#define SHARED_MEM_DEFINED
#if defined (_WIN32)
//#define USE_NATIVE_CRITICAL_SECTION
#endif
#if defined( _SHLWAPI_H ) || defined( _INC_SHLWAPI )
#undef StrChr
#undef StrCpy
#undef StrDup
#undef StrRChr
#undef StrStr
#endif
#ifdef __cplusplus
#define SACK_MEMORY_NAMESPACE SACK_NAMESPACE namespace memory {
#define SACK_MEMORY_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define SACK_MEMORY_NAMESPACE
#define SACK_MEMORY_NAMESPACE_END
#endif
/* A declaration of the call type for memory library routines. */
#define MEM_API CPROC
#    ifdef MEM_LIBRARY_SOURCE
#      define MEM_PROC EXPORT_METHOD
#    else
/* Defines library linkage specification. */
#      define MEM_PROC IMPORT_METHOD
#    endif
#ifndef TIMER_NAMESPACE
#ifdef __cplusplus
#define _TIMER_NAMESPACE namespace timers {
/* define a timer library namespace in C++. */
#define TIMER_NAMESPACE SACK_NAMESPACE namespace timers {
/* define a timer library namespace in C++ end. */
#define TIMER_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define TIMER_NAMESPACE
#define TIMER_NAMESPACE_END
#endif
#endif
	TIMER_NAMESPACE
   // enables file/line monitoring of sections and a lot of debuglogging
//#define DEBUG_CRITICAL_SECTIONS
   /* this symbol controls the logging in timers.c... (higher level interface to NoWait primatives)*/
//#define LOG_DEBUG_CRITICAL_SECTIONS
/* A custom implementation of windows CRITICAL_SECTION api.
   Provides same capability for Linux type systems. Can be
   checked as a study in how to implement safe locks.
   See Also
   InitCriticalSec
   EnterCriticalSec
   LeaveCriticalSec
   Example
   <c>For purposes of this example this is declared in global
   memory, known to initialize to all 0.</c>
   <code lang="c++">
   CRITICALSECTION cs_lock_test;
   </code>
   In some bit of code that can be executed by several
   threads...
   <code lang="c++">
   {
      EnterCriticalSec( &amp;cs_lock_test );
      // the code in here will only be run by a single thread
      LeaveCriticalSec( &amp;cs_lock_test );
   }
   </code>
   Remarks
   The __Ex versions of functions passes source file and line
   information in debug mode. This can be used if critical
   section debugging is turned on, or if critical section
   logging is turned on. (See ... ) This allows applications to
   find deadlocks by tracking who is entering critical sections
   and probably failing to leave them.                          */
struct critical_section_tag {
 // this is set when entering or leaving (updating)...
	uint32_t dwUpdating;
  // count of locks entered.  (only low 24 bits may count for 16M entries, upper bits indicate internal statuses.
	uint32_t dwLocks;
 // windows upper 16 is process ID, lower is thread ID
	THREAD_ID dwThreadID;
 // ID of thread waiting for this..
	THREAD_ID dwThreadWaiting;
#ifdef DEBUG_CRITICAL_SECTIONS
#define MAX_SECTION_LOG_QUEUE 16
	uint32_t bCollisions ;
	CTEXTSTR pFile[16];
	uint32_t  nLine[16];
	uint32_t  nLineCS[16];
 // windows upper 16 is process ID, lower is thread ID
	THREAD_ID dwThreadPrior[16];
 // windows upper 16 is process ID, lower is thread ID
	uint8_t isLock[16];
	int nPrior;
#endif
};
#if !defined( _WIN32 )
#undef USE_NATIVE_CRITICAL_SECTION
#endif
/* <combine sack::timers::critical_section_tag>
   \ \                                          */
#if defined( USE_NATIVE_CRITICAL_SECTION )
#define CRITICALSECTION CRITICAL_SECTION
#else
typedef struct critical_section_tag CRITICALSECTION;
#endif
/* <combine sack::timers::critical_section_tag>
   defines a pointer to a CRITICALSECTION type  */
#if defined( USE_NATIVE_CRITICAL_SECTION )
#define PCRITICALSECTION LPCRITICAL_SECTION
#else
#define InitializeCriticalSection InitializeCriticalSec
typedef struct critical_section_tag *PCRITICALSECTION;
#endif
/* attempts to enter the critical section, and does not block.
   Returns
   If it enters the return is 1, else the return is 0.
   Parameters
   pcs :    pointer to a critical section
   prior :  if not NULL, prior will be set to the current thread
            ID of the owning thread.                             */
#ifndef USE_NATIVE_CRITICAL_SECTION
MEM_PROC  int32_t MEM_API  EnterCriticalSecNoWaitEx ( PCRITICALSECTION pcs, THREAD_ID *prior DBG_PASS );
#define EnterCriticalSecNoWait( pcs,prior ) EnterCriticalSecNoWaitEx( pcs, prior DBG_SRC )
#else
#define EnterCriticalSecNoWait( pcs,prior ) TryEnterCriticalSection( (pcs) )
#endif
/* <combine sack::timers::EnterCriticalSecNoWaitEx@PCRITICALSECTION@THREAD_ID *prior>
   \ \                                                                                */
//#define EnterCriticalSecNoWait( pcs,prior ) EnterCriticalSecNoWaitEx( (pcs),(prior) DBG_SRC )
/* clears all members of a CRITICALSECTION.  Same as memset( pcs, 0, sizeof( CRITICALSECTION ) ); */
#ifndef USE_NATIVE_CRITICAL_SECTION
MEM_PROC  void MEM_API  InitializeCriticalSec ( PCRITICALSECTION pcs );
#else
#define InitializeCriticalSec(pcs)  InitializeCriticalSection(pcs)
#endif
/* Get a count of how many times a critical section is locked */
//MEM_PROC  uint32_t MEM_API  CriticalSecOwners ( PCRITICALSECTION pcs );
/* Namespace of all memory related functions for allocating and
   releasing memory.                                            */
#ifdef __cplusplus
 // namespace timers
};
 // namespace sack
};
using namespace sack::timers;
#endif
#ifdef __cplusplus
namespace sack {
/* Memory namespace contains functions for allocating and
   releasing memory. Also contains methods for accessing shared
   memory (if available on the target platform).
   Allocate
   Release
   Hold
   OpenSpace                                                    */
namespace memory {
#endif
typedef struct memory_block_tag* PMEM;
// what is an abstract name for the memory mapping handle...
// where is a filename for the filebacking of the shared memory
// DigSpace( WIDE(TEXT( "Picture Memory" )), WIDE(TEXT( "Picture.mem" )), 100000 );
/* <combinewith sack::memory::OpenSpaceExx@CTEXTSTR@CTEXTSTR@uintptr_t@uintptr_t *@uint32_t*>
   \ \                                                                                 */
MEM_PROC  POINTER MEM_API  OpenSpace ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t *dwSize );
/* <unfinished>
   Open a shared memory region. The region may be named with a
   text string (this does not work under linux platforms, and
   the name of the file to back the shared region is the sharing
   point). The region may be backed with a file (and must be if
   it is to be shared on linux.
   If the region exists by name, the region is opened, and a
   pointer to that region is returned.
   If the file exists, the file is opened, and mapped into
   memory, and a pointer to the file backed memory is returned.
   if the file does not exist, and the size parameter passed is
   not 0, then the file is created, and expanded to the size
   requested. The bCreate flag is set to true.
   If NULL is passed for pWhat and pWhere, then a block of
   memory is allocated in system memory, backed by pagefile.
   if dwSize is 0, then the region is specified for open only,
   and will not create.
   Parameters
   pWhat :     String to a named shared memory region. NULL is
               unnamed.
   pWhere :    Filename to back the shared memory with. The file
               name itself may also be used to share the memory.
   address :   A base address to map the memory at. If 0,
               specifies do not care.
   dwSize :    pointer to a uintptr_t that defines the size to
               create. If 0, then the region is only opened. The
               size of the region opened is set back into this
               value after it is opened.
   bCreated :  pointer to a boolean to indicate whether the space
               was created or not.
   Returns
   Pointer to region requested to be opened. NULL on failure.
   Example
   Many examples of this are appropriate.
   1) Open or create a file backed shared space.
   2) Open a file for direct memory access, the file is loaded
   into memory by system paging routines and not any API.         */
MEM_PROC  POINTER MEM_API  OpenSpaceExx ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t address
	, uintptr_t *dwSize, uint32_t* bCreated );
/* <combine sack::memory::OpenSpaceExx@CTEXTSTR@CTEXTSTR@uintptr_t@uintptr_t *@uint32_t*>
   \ \                                                                             */
#define OpenSpaceEx( what,where,address,psize) OpenSpaceExx( what,where,address,psize,NULL )
/* Closes a shared memory region. Calls CloseSpaceEx() with
   bFinal set TRUE.
   Parameters
   pMem :  pointer to a memory region opened by OpenSpace.  */
MEM_PROC  void MEM_API  CloseSpace ( POINTER pMem );
/* Closes a memory region. Release can also be used to close
   opened spaces.
   Parameters
   pMem :    pointer to a memory region opened with OpenSpace()
   bFinal :  If final is set, the file used for backing the shared
             region is deleted.                                    */
MEM_PROC  void MEM_API  CloseSpaceEx ( POINTER pMem, int bFinal );
/* This can give the size back of a memory space.
   Returns
   The size of the memory block.
   Parameters
   pMem :  pointer to a block of memory that was opened with
           OpenSpace().                                      */
MEM_PROC  uintptr_t MEM_API  GetSpaceSize ( POINTER pMem );
/* even if pMem is just a POINTER returned from OpenSpace this
   will create a valid heap pointer.
   will result TRUE if a valid heap is present will result FALSE
   if heap is not able to init (has content)
   Parameters
   pMem :    pointer to a memory space to setup as a heap.
   dwSize :  size of the memory space pointed at by pMem.        */
MEM_PROC  int MEM_API  InitHeap( PMEM pMem, uintptr_t dwSize );
/* Dumps all blocks into the log.
   Parameters
   pHeap :     Heap to dump. If NULL or unspecified, dump the
               default heap.
   bVerbose :  Specify to dump each block's information,
               otherwise only summary information is generated. */
MEM_PROC  void MEM_API  DebugDumpHeapMemEx ( PMEM pHeap, LOGICAL bVerbose );
/* <combine sack::memory::DebugDumpHeapMemEx@PMEM@LOGICAL>
   Logs all of the blocks tracked in a specific heap.
   Parameters
   Heap :  Heap to dump the memory blocks of.              */
#define DebugDumpHeapMem(h)     DebugDumpMemEx( (h), TRUE )
/* <combine sack::memory::DebugDumpHeapMemEx@PMEM@LOGICAL>
   \ \                                                     */
MEM_PROC  void MEM_API  DebugDumpMemEx ( LOGICAL bVerbose );
/* Dumps all tracked heaps.
   Parameters
   None.                    */
#define DebugDumpMem()     DebugDumpMemEx( TRUE )
/* Dumps a heap to a specific file.
   Parameters
   pHeap :      Heap. If NULL or unspecified, dumps default heap.
   pFilename :  name of the file to write output to.              */
MEM_PROC  void MEM_API  DebugDumpHeapMemFile ( PMEM pHeap, CTEXTSTR pFilename );
/* <combine sack::memory::DebugDumpHeapMemFile@PMEM@CTEXTSTR>
   \ \                                                        */
MEM_PROC  void MEM_API  DebugDumpMemFile ( CTEXTSTR pFilename );
#ifdef __GNUC__
MEM_PROC  POINTER MEM_API  HeapAllocateAlignedEx ( PMEM pHeap, uintptr_t dwSize, uint16_t alignment DBG_PASS ) __attribute__( (malloc) );
MEM_PROC  POINTER MEM_API  HeapAllocateEx ( PMEM pHeap, uintptr_t nSize DBG_PASS ) __attribute__((malloc));
MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS ) __attribute__((malloc));
#else
/* \ \
   Parameters
   pHeap :  pointer to a heap which was initialized with
            InitHeap()
   Size :   Size of block to allocate                    */
MEM_PROC  POINTER MEM_API  HeapAllocateEx ( PMEM pHeap, uintptr_t nSize DBG_PASS );
/* \ Parameters
pHeap :  pointer to a heap which was initialized with
InitHeap()
Size :   Size of block to allocate
Alignment : count of bytes to return block on (1,2,4,8,16,32)  */
MEM_PROC  POINTER MEM_API  HeapAllocateAlignedEx( PMEM pHeap, uintptr_t nSize, uint16_t alignment DBG_PASS );
/* Allocates a block of memory of specific size. Debugging
   information if passed is recorded on the block.
   Parameters
   size :  size of the memory block to create              */
MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS );
#endif
/* A simple macro to allocate a new single unit of a structure. Adds
   a typecast automatically to be (type*) so C++ compilation is
   clean. Does not burden the user with extra typecasts. This,
   being in definition use means that all other things that are
   typecast are potentially error prone. Memory is considered
   uninitialized.
   Parameters
   type :  type to allocate
   Example
   <code lang="c++">
   int *p_int = New( int );
   </code>                                                           */
#define New(type) ((type*)HeapAllocate(0,sizeof(type)))
/* Reallocates an array of type.
   Parameters
   type :  type to use for sizeof(type) * sz for resulting size.
   p :     pointer to realloc
   sz :    count of elements in the array                        */
#define Renew(type,p,sz) ((type*)HeapReallocate(0,p, sizeof(type)*sz))
/* an advantage of C, can define extra space at end of structure
   which is allowed to carry extra data, which is unknown by
   other code room for exploits rock.
   Parameters
   type :   passed to sizeof()
   extra :  Number of additional bytes to allocate beyond the
            sizeof( type )
   Example
   Create a text segment plus 18 characters of data. (This
   should not be done, use SegCreate instead)
   <code lang="c#">
   PTEXT text = NewPlus( TEXT, 18 );
   </code>                                                       */
#define NewPlus(type,extra) ((type*)HeapAllocate(0,sizeof(type)+(extra)))
/* Allocate a new array of type.
   Parameters
   type :   type to determine size of array element to allocate.
   count :  count of elements to allocate in the array.
   Returns
   A pointer to type. (this is important, since in C++ it's cast
   correctly to the destination type).                           */
#define NewArray(type,count) ((type*)HeapAllocate(0,sizeof(type)*(count)))
/* Allocate sizeof(type). Will invoke some sort of registered
   initializer
   Parameters
   type :  type to allocate for. Passes the name of the type so
           the allocator can do a registered procedure lookup and
           invok an initializer for the type.                     */
//#define NewObject(type) ((type*)FancyAllocate(sizeof(type),#type DBG_SRC))
#ifdef __cplusplus
/* A 'safe' release macro. casts the block to the type to
   release. Makes sure the pointer being released is the type
   specified.
   Parameters
   type :   type of the variable
   thing :  the thing to actually release.                    */
#  ifdef _DEBUG
#    define Deallocate(type,thing) for(type _zzqz_tmp=thing;ReleaseEx((POINTER)(_zzqz_tmp)DBG_SRC),0;)
#  else
#    define Deallocate(type,thing) ReleaseEx((POINTER)(thing)DBG_SRC)
#  endif
#else
#  define Deallocate(type,thing) (ReleaseEx((POINTER)(thing)DBG_SRC))
#endif
/* <combine sack::memory::HeapAllocateEx@PMEM@uintptr_t nSize>
   \ \                                                        */
#define HeapAllocate(heap, n) HeapAllocateEx( (heap), (n) DBG_SRC )
   /* <combine sack::memory::HeapAllocateAlignedEx@PMEM@uintptr_t@uint32_t>
   \ \                                                        */
#define HeapAllocateAligned(heap, n, m) HeapAllocateAlignedEx( (heap), (n), m DBG_SRC )
   /* <combine sack::memory::AllocateEx@uintptr_t nSize>
   \ \                                               */
#ifdef FIX_RELEASE_COM_COLLISION
#else
#define Allocate( n ) HeapAllocateEx( (PMEM)0, (n) DBG_SRC )
#endif
//MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS );
//#define Allocate(n) AllocateEx(n DBG_SRC )
MEM_PROC  POINTER MEM_API  GetFirstUsedBlock ( PMEM pHeap );
/* Releases an allocated block. Memory becomes free to allocate
   again. If debugging information is passed, the releasing
   source and line is recorded in the block. (can be used to
   find code deallocating memory it shouldn't).
   This also works with Hold(), and decrements the hold counter.
   If there are no more holds on the block, then the block is
   released.
   Parameters
   p :  pointer to allocated block to release.                   */
MEM_PROC  POINTER MEM_API  ReleaseEx ( POINTER pData DBG_PASS ) ;
/* <combine sack::memory::ReleaseEx@POINTER pData>
   \ \                                             */
#ifdef FIX_RELEASE_COM_COLLISION
#else
/* <combine sack::memory::ReleaseEx@POINTER pData>
   \ \                                             */
#define Release(p) ReleaseEx( (p) DBG_SRC )
#endif
/* Adds a usage count to a block of memory. For each count
   added, an additional release must be used. This can be used
   to keep a copy of the block, even if some other code
   automatically releases it.
   Parameters
   pointer :  pointer to a block of memory that was Allocate()'d.
   Example
   Allocate a block of memory, and release it properly. But we
   passed it to some function. That function wanted to keep a
   copy of the block, so it can apply a hold. It needs to later
   do a Release again to actually free the memory.
   <code lang="c++">
   POINTER p = Allocate( 32 );
   call_some_function( p );
   Release( p );
   void call_some_function( POINTER p )
   {
      static POINTER my_p_copy;
      my_p_copy = p;
      Hold( p );
   }
   </code>                                                        */
MEM_PROC  POINTER MEM_API  HoldEx ( POINTER pData DBG_PASS  );
/* <combine sack::memory::HoldEx@POINTER pData>
   \ \                                          */
#define Hold(p) HoldEx(p DBG_SRC )
/* This can be used to add additional space after the end of a
   memory block.
   Parameters
   pHeap :   If NULL or not specified, uses the common memory heap.
   source :  pointer to the block to pre\-allocate. If NULL, a new
             memory block will be allocated that is filled with 0.
   size :    the new size of the block.
   Returns
   A pointer to a new block of memory that is the new size.
   Remarks
   If the size specified for the new block is larger than the
   previous size of the block, the curernt data is copied to the
   beginning of the new block, and the memory after the existing
   content is cleared to 0.
   If the size specified for the new block is smaller than the
   previous size, the end of the original block is not copied to
   the new block.
   If NULL is passed as the source block, then a new block
   filled with 0 is created.                                        */
MEM_PROC  POINTER MEM_API  HeapReallocateAlignedEx ( PMEM pHeap, POINTER source, uintptr_t size, uint16_t alignment DBG_PASS );
MEM_PROC  POINTER MEM_API  HeapReallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::HeapReallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                 */
#define HeapReallocateAligned(heap,p,sz,al) HeapReallocateEx( (heap),(p),(sz),(al) DBG_SRC )
#define HeapReallocate(heap,p,sz) HeapReallocateEx( (heap),(p),(sz) DBG_SRC )
/* <combine sack::memory::HeapReallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                 */
MEM_PROC  POINTER MEM_API  ReallocateEx ( POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::ReallocateEx@POINTER@uintptr_t size>
   \ \                                                        */
#ifdef FIX_RELEASE_COM_COLLISION
#else
#define Reallocate(p,sz) ReallocateEx( (p),(sz) DBG_SRC )
#endif
/* This can be used to add additional space before the beginning
   of a memory block.
   Parameters
   pHeap :   If NULL or not specified, uses the common memory heap.
   source :  pointer to the block to pre\-allocate. If NULL, a new
             memory block will be allocated that is filled with 0.
   size :    the new size of the block.
   Returns
   A pointer to a new block of memory that is the new size.
   Remarks
   If the size specified for the new block is larger than the
   previous size of the block, the content data is copied to the
   end of the new block, and the memory leading up to the block
   is cleared to 0.
   If the size specified for the new block is smaller than the
   previous size, the end of the original block is not copied to
   the new block.
   If NULL is passed as the source block, then a new block
   filled with 0 is created.                                        */
MEM_PROC  POINTER MEM_API  HeapPreallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::HeapPreallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                  */
#define HeapPreallocate(heap,p,sz) HeapPreallocateEx( (heap),(p),(sz) DBG_SRC )
/* <combine sack::memory::HeapPreallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                  */
MEM_PROC  POINTER MEM_API  PreallocateAlignedEx ( POINTER source, uintptr_t size, uint16_t alignment DBG_PASS );
MEM_PROC  POINTER MEM_API  PreallocateEx ( POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::PreallocateEx@POINTER@uintptr_t size>
   \ \                                                         */
#define PreallocateAligned(p,sz,al) PreallocateAlignedEx( (p),(sz),(al) DBG_SRC )
#define Preallocate(p,sz) PreallocateEx( (p),(sz) DBG_SRC )
/* Moves a block of memory from one heap to another.
   Parameters
   pNewHeap :  heap target to move the block to.
   source :    source block to move \- pointer to the data in the
               block.
   Remarks
   Since each block remembers its own size, it is possible to
   move a block from one heap to another. A heap might be a
   memory mapped file at a specific address for instance.         */
MEM_PROC  POINTER MEM_API  HeapMoveEx ( PMEM pNewHeap, POINTER source DBG_PASS );
/* <combine sack::memory::HeapMoveEx@PMEM@POINTER source>
   \ \                                                    */
#define HeapMove(h,s) HeapMoveEx( (h), (s) DBG_SRC )
/* \returns the size of a memory block which was Allocate()'d.
   Parameters
   pData :  pointer to a allocated memory block.
   Returns
   The size of the block that was specified by the Allocate(). */
MEM_PROC uintptr_t MEM_API  SizeOfMemBlock ( CPOINTER pData );
/* \returns the allocation alignment of a memory block which was Allocate()'d.
Parameters
pData :  pointer to a allocated memory block.
Returns
The alignment of the block that was specified from Allocate(). */
MEM_PROC uint16_t  AlignOfMemBlock( CPOINTER pData );
/* not so much of a fragment as a consolidation. Finds a free
   spot earlier in the heap and attempts to move the block
   there. This can help alleviate heap fragmentation.
   Parameters
   ppMemory :  pointer to a pointer to memory which might move */
MEM_PROC  LOGICAL MEM_API  Defragment ( POINTER *ppMemory );
/* \ \
   Parameters
   pHeap :        pointer to a heap
   pFree :        pointer to a 32 bit value to receive the size
                  of free space
   pUsed :        pointer to a 32 bit value to receive the size
                  of used space
   pChunks :      pointer to a 32 bit value to receive the total
                  count of chunks.
   pFreeChunks :  pointer to a 32 bit value to receive the total
                  count of free chunks.
   Remarks
   It looks like DBG_PASS parameter isn't used... not sure why
   it would here, there is no allocate or delete.
   The count of allocated chunks can be gotten by subtracting
   FreeChunks from Chunks.
   Example
   <code lang="c++">
   uint32_t free;
   uint32_t used;
   uint32_t chunks;
   uint32_t free_chunks;
   GetHeapMemStatsEx( NULL, &amp;free, &amp;used, &amp;chunks, &amp;free_chunks );
   </code>                                                                         */
MEM_PROC  void MEM_API  GetHeapMemStatsEx ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks DBG_PASS );
/* <combine sack::memory::GetHeapMemStatsEx@PMEM@uint32_t *@uint32_t *@uint32_t *@uint32_t *pFreeChunks>
   \ \                                                                               */
#define GetHeapMemStats(h,f,u,c,fc) GetHeapMemStatsEx( h,f,u,c,fc DBG_SRC )
//MEM_PROC  void MEM_API  GetHeapMemStats ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks );
MEM_PROC  void MEM_API  GetMemStats ( uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks );
/* Sets whether to log allocations or not.
   \returns the prior state of logging...
   Parameters
   bTrueFalse :  if TRUE, allocation logging is turned on. Enables
                 logging when each block is Allocated, Released,
                 or Held.                                          */
MEM_PROC  int MEM_API  SetAllocateLogging ( LOGICAL bTrueFalse );
/* disables storing file/line, also disables auto GetMemStats
   checking
   Parameters
   bDisable :  set to TRUE to disable allocate debug logging. */
MEM_PROC  int MEM_API  SetAllocateDebug ( LOGICAL bDisable );
/* disables auto GemMemStats on every allocate/release/Hold
   GetMemStats will evaluate each and every block allocated in
   memory and inspect it for corruption.
   Parameters
   bDisable :  set to TRUE to disable auto mem check.          */
MEM_PROC  int MEM_API  SetManualAllocateCheck ( LOGICAL bDisable );
/* Sets whether to log critical sections or not.
   \returns the prior state of logging...
   Parameters
   bTrueFalse :  if TRUE, critical section logging is turned on. Logs
                 when each thread enters or leaves a
                 CRITICIALSECTION.                                    */
MEM_PROC  int MEM_API  SetCriticalLogging ( LOGICAL bTrueFalse );
/* Sets the minimum size to allocate. If a block size less than
   this is allocated, then this much is actually allocated.
   Parameters
   nSize :  Specify the minimum allocation size                 */
MEM_PROC  void MEM_API  SetMinAllocate ( size_t nSize );
/* Sets how much a heap is expanded by when it is out of space. Default
   is like 512k.
   Parameters
   dwSize :  the new size to expand heaps by.
   Remarks
   Probably internally, this is rounded up to the next 4k
   boundary.                                                            */
MEM_PROC  void MEM_API  SetHeapUnit ( size_t dwSize );
/* Multi-processor safe exchange operation. Returns the prior
   value at the pointer.
   Parameters
   p :    pointer to a volatile 64 bit value.
   val :  a new 64 bit value to put at (*p)
   Example
   <code lang="c#">
   uint64_t value = 13;
   uint64_t oldvalue = LockedExchange64( &amp;value, 15 );
   // old value will be 13
   // value will be 15
   </code>                                                    */
MEM_PROC  uint64_t MEM_API  LockedExchange64 ( volatile uint64_t* p, uint64_t val );
/* A multi-processor safe increment of a variable.
   Parameters
   p :  pointer to a 32 bit value to increment.    */
MEM_PROC  uint32_t MEM_API  LockedIncrement ( uint32_t* p );
/* Does a multi-processor safe decrement on a variable.
   Parameters
   p :  pointer to a 32 bit value to decrement.         */
MEM_PROC  uint32_t MEM_API  LockedDecrement ( uint32_t* p );
#ifdef __cplusplus
// like also __if_assembly__
//extern "C" {
#endif
#ifdef __64__
#define LockedExchangePtrSzVal(a,b) LockedExchange64((volatile uint64_t*)(a),b)
#else
#define LockedExchangePtrSzVal(a,b) LockedExchange((volatile uint32_t*)(a),b)
#endif
/* Multiprocessor safe swap of the contents of a variable with a
   new value, and result with the old variable.
   Parameters
   p :    pointer to a 32 bit value to exchange
   val :  value to set into the variable
   Returns
   The prior value in p.
   Example
   <code>
   uint32_t variable = 0;
   uint32_t oldvalue = LockedExchange( &amp;variable, 1 );
   </code>                                                       */
MEM_PROC  uint32_t MEM_API  LockedExchange ( volatile uint32_t* p, uint32_t val );
/* Sets a 32 bit value into memory. If the length to set is not
   a whole number of 32 bit words, the last bytes may contain
   the low 16 bits of the value and the low 8 bits.
   Parameters
   p :   pointer to memory to set
   n :   32 bit value to set memory with
   sz :  length to set
   Remarks
   Writes as many 32 it values as will fit in sz.
   If (sz &amp; 2), the low 16 bits of n are written at the end.
   then if ( sz &amp; 1 ) the low 8 bits of n are written at the
   end.                                                          */
MEM_PROC  void MEM_API  MemSet ( POINTER p, uintptr_t n, size_t sz );
//#define _memset_ MemSet
/* memory copy operation. not safe when buffers overlap. Performs
   platform-native memory stream operation to copy from one
   place in memory to another. (32 or 64 bit operations as
   possible).
   Parameters
   pTo :    Memory to copy to
   pFrom :  memory to copy from
   sz :     size of block of memory to copy                       */
MEM_PROC  void MEM_API  MemCpy ( POINTER pTo, CPOINTER pFrom, size_t sz );
//#define _memcpy_ MemCpy
/* Binary byte comparison of one block of memory to another. Results
   \-1 if less, 1 if more and 0 if equal.
   Parameters
   pOne :  pointer to memory one
   pTwo :  pointer to some other memory
   sz :    count of bytes to compare
   Returns
   0 if equal
   \-1 if the first different byte in pOne is less than pTwo.
   1 if the first different byte in pOne is more than pTwo.          */
MEM_PROC  int MEM_API  MemCmp ( CPOINTER pOne, CPOINTER pTwo, size_t sz );
	/* nothing.
   does nothing, returns nothing. */
//#define memnop(mem,sz,comment)
#ifdef __cplusplus
//};
#endif
/* Compares two strings. Must match exactly.
   Parameters
   s1 :  string to compare
   s2 :  string to compare
   Returns
   0 if equal.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
	if s1 and s2 are NULL return is 0.              */
#ifdef StrCmp
#undef StrCmp
 // StrCmp
#endif
MEM_PROC  int MEM_API  StrCmp ( CTEXTSTR pOne, CTEXTSTR pTwo );
/* Compares two strings, case insensitively.
   Parameters
   s1 :  string to compare
   s2 :  string to compare
   Returns
   0 if equal.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
   if s1 and s2 are NULL return is 0.              */
MEM_PROC  int MEM_API  StrCaseCmp ( CTEXTSTR s1, CTEXTSTR s2 );
/* String insensitive case comparison with maximum length
   specified.
   Parameters
   s1 :      string to compare
   s2 :      string to compare
   maxlen :  maximum character required to match
   Returns
   0 if equal up to the number of characters.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
   if s1 and s2 are NULL return is 0.                     */
MEM_PROC  int MEM_API  StrCaseCmpEx ( CTEXTSTR s1, CTEXTSTR s2, size_t maxlen );
/* This searches a string for the first character that matches
   some specified character.
   A custom strchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This flavor is the only one on C where operator overloading
   cannot switch between CTEXTSTR and TEXTSTR parameters, to
   \result with the correct type. If a CTEXTSTR is passed to
   this it should result with a CTEXTSTR, but if that's the only
   choice, then the result of this is never modifiable, even if
	it is a pointer to a non-const TEXTSTR.                       */
MEM_PROC  CTEXTSTR MEM_API  StrChr ( CTEXTSTR s1, TEXTCHAR c );
/* copy S2 to S1, with a maximum of N characters.
   The last byte of S1 will always be a 'nul'. If S2 was longer
   than S1, then it will be truncated to fit within S1. Perferred
   method over this is SaveText or StrDup.
   Parameters
   s1 :      desitnation TEXTCHAR buffer
   s2 :      source string
   length :  the maximum number of characters that S1 can hold. (this
             is not a size, but is a character count)                 */
MEM_PROC  TEXTSTR MEM_API  StrCpyEx ( TEXTSTR s1, CTEXTSTR s2, size_t n );
/* copy S2 to S1. This is 'unsafe', since neither paramter's
   size is known. Prefer StrCpyEx which passes the maximum
   length for S1.
   Parameters
   s1 :  desitnation TEXTCHAR buffer
   s2 :  source string                                       */
MEM_PROC  TEXTSTR MEM_API  StrCpy ( TEXTSTR s1, CTEXTSTR s2 );
/* \Returns the count of characters in a string.
   Parameters
   s :  string to measure
   Returns
   length of string.                             */
MEM_PROC  size_t MEM_API  StrLen ( CTEXTSTR s );
/* Get the length of a string in C chars.
   Parameters
   s :  char * to count.
   Returns
   the length of s. If s is NULL, return 0. */
MEM_PROC  size_t MEM_API  CStrLen ( char const*s );
/* Finds the last instance of a character in a string.
   Parameters
   s1 :  String to search in
   c :   character to find
   Returns
   NULL if character is not in the string.
   a pointer to the last character in s1 that matches c. */
MEM_PROC  CTEXTSTR MEM_API  StrRChr ( CTEXTSTR s1, TEXTCHAR c );
#ifdef __cplusplus
/* This searches a string for the first character that matches
   some specified character.
   A custom strchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This second flavor is only available on C++ where operator
   overloading will switch between CTEXTSTR and TEXTSTR
   \parameters, to result with the correct type. If a CTEXTSTR
   is passed to this it should result with a CTEXTSTR, but if
   that's the only choice, then the result of this is never
   modifiable, even if it is a pointer to a non-const TEXTSTR.  */
MEM_PROC  TEXTSTR MEM_API  StrChr ( TEXTSTR s1, TEXTCHAR c );
/* This searches a string for the last character that matches
   some specified character.
   A custom strrchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This second flavor is only available on C++ where operator
   overloading will switch between CTEXTSTR and TEXTSTR
   \parameters, to result with the correct type. If a CTEXTSTR
   is passed to this it should result with a CTEXTSTR, but if
   that's the only choice, then the result of this is never
   modifiable, even if it is a pointer to a non-const TEXTSTR.  */
MEM_PROC  TEXTSTR MEM_API  StrRChr ( TEXTSTR s1, TEXTCHAR c );
/* <combine sack::memory::StrCmp@CTEXTSTR@CTEXTSTR>
   \ \                                              */
MEM_PROC  int MEM_API  StrCmp ( const char * s1, CTEXTSTR s2 );
#endif
/* <combine sack::memory::StrCmp@char *@CTEXTSTR>
   \ \                                            */
MEM_PROC  int MEM_API  StrCmpEx ( CTEXTSTR s1, CTEXTSTR s2, INDEX maxlen );
/* Finds an instance of a string in another string.
   Custom implementation because strstr is declared unsafe, and
   to handle switching between unicode and char.
   Parameters
   s1 :  the string to search in
   s2 :  the string to locate
   Returns
   NULL if s2 is not in s1.
   The beginning of the string in s1 that matches s2.
   Example
   <code lang="c++">
   TEXTCHAR const *found = StrStr( WIDE( "look in this string" ), WIDE( "in" ) );
                                               ^returns a pointer to here.
   </code>                                                                        */
MEM_PROC  CTEXTSTR MEM_API  StrStr ( CTEXTSTR s1, CTEXTSTR s2 );
#ifdef __cplusplus
/* Finds an instance of a string in another string.
   Custom implementation because strstr is declared unsafe, and
   to handle switching between unicode and char.
   Parameters
   s1 :  the string to search in
   s2 :  the string to locate
   Returns
   NULL if s2 is not in s1.
   The beginning of the string in s1 that matches s2.
   Example
   <code>
   TEXTCHAR *writable_string = StrDup( WIDE( "look in this string" ) );
   TEXTCHAR *found = StrStr( writable_string, WIDE( "in" ) );
   // returns a pointer to 'in' in the writable string, which can then be modified.
   </code>                                                                          */
MEM_PROC  TEXTSTR MEM_API  StrStr ( TEXTSTR s1, CTEXTSTR s2 );
#endif
/* Searches for one string in another. Compares case
   insensitively.
   Parameters
   s1 :  string to search in
   s2 :  string to locate
   See Also
   <link sack::memory::StrStr@CTEXTSTR@CTEXTSTR, StrStr> */
MEM_PROC  CTEXTSTR MEM_API  StrCaseStr ( CTEXTSTR s1, CTEXTSTR s2 );
/* This duplicates a block of memory.
   Parameters
   p :  pointer to a block of memory that was allocated.
   Returns
   a pointer to a new block of memory that has the same content
   as the original.                                             */
MEM_PROC  POINTER MEM_API  MemDupEx ( CPOINTER thing DBG_PASS );
/* <combine sack::memory::MemDupEx@CPOINTER thing>
   \ \                                             */
#define MemDup(thing) MemDupEx(thing DBG_SRC )
/* Duplicates a string, and returns a pointer to the copy.
   Parameters
   original :  string to duplicate                         */
MEM_PROC  TEXTSTR MEM_API  StrDupEx ( CTEXTSTR original DBG_PASS );
/* Translates from a TEXTCHAR string to a char string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  char *  MEM_API  CStrDupEx ( CTEXTSTR original DBG_PASS );
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  wchar_t *  MEM_API  DupTextToWideEx( CTEXTSTR original DBG_PASS );
#define DupTextToWide(s) DupTextToWideEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  char *     MEM_API  DupTextToCharEx( CTEXTSTR original DBG_PASS );
#define DupTextToChar(s) DupTextToCharEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC TEXTSTR     MEM_API  DupWideToTextEx( const wchar_t *original DBG_PASS );
#define DupWideToText(s) DupWideToTextEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC TEXTSTR     MEM_API  DupCharToTextEx( const char *original DBG_PASS );
#define DupCharToText(s) DupCharToTextEx( s DBG_SRC )
/* Converts from 8 bit char to 16 bit wchar (or no-op if not
   UNICODE compiled)
   Parameters
   original :  original string of C char.
   Returns
   a pointer to a wide character string.                     */
MEM_PROC  TEXTSTR MEM_API  DupCStrEx ( const char * original DBG_PASS );
/* Converts from 8 bit char to 16 bit wchar (or no-op if not
UNICODE compiled)
Parameters
original :  original string of C char.
Returns
a pointer to a wide character string.                     */
MEM_PROC  TEXTSTR MEM_API  DupCStrLenEx( const char * original, size_t chars DBG_PASS );
/* <combine sack::memory::StrDupEx@CTEXTSTR original>
   \ \                                                */
#define StrDup(o) StrDupEx( (o) DBG_SRC )
/* <combine sack::memory::CStrDupEx@CTEXTSTR original>
   \ \                                                 */
#define CStrDup(o) CStrDupEx( (o) DBG_SRC )
/* <combine sack::memory::DupCStrEx@char * original>
   \ \                                               */
#define DupCStr(o) DupCStrEx( (o) DBG_SRC )
/* <combine sack::memory::DupCStrLenEx@char * original@size_t chars>
   \ \                                               */
#define DupCStrLen(o,l) DupCStrLenEx( (o),(l) DBG_SRC )
//------------------------------------------------------------------------
#if 0
// this code was going to provide network oriented shared memory.
#ifndef TRANSPORT_STRUCTURE_DEFINED
typedef uintptr_t PTRANSPORT_QUEUE;
struct transport_queue_tag { uint8_t private_data_here; };
#endif
MEM_PROC  struct transport_queue_tag * MEM_API  CreateQueue ( int size );
MEM_PROC  int MEM_API  EnqueMessage ( struct transport_queue_tag *queue, POINTER msg, int size );
MEM_PROC  int MEM_API  DequeMessage ( struct transport_queue_tag *queue, POINTER msg, int *size );
MEM_PROC  int MEM_API  PequeMessage ( struct transport_queue_tag *queue, POINTER *msg, int *size );
#endif
//------------------------------------------------------------------------
#ifdef __cplusplus
 // namespace memory
};
 // namespace sack
};
using namespace sack::memory;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
/*
inline void operator delete( void * p )
{ Release( p ); }
#ifdef DELETE_HANDLES_OPTIONAL_ARGS
inline void operator delete (void * p DBG_PASS )
{ ReleaseEx( p DBG_RELAY ); }
#define delete delete( DBG_VOIDSRC )
#endif
//#define deleteEx(file,line) delete(file,line)
#ifdef USE_SACK_ALLOCER
inline void * operator new( size_t size DBG_PASS )
{ return AllocateEx( (uintptr_t)size DBG_RELAY ); }
static void * operator new[]( size_t size DBG_PASS )
{ return AllocateEx( (uintptr_t)size DBG_RELAY ); }
#define new new( DBG_VOIDSRC )
#define newEx(file,line) new(file,line)
#endif
*/
// common names - sometimes in conflict when declaring
// other functions... AND - release is a common
// component of iComObject
//#undef Allocate
//#undef Release
// Hmm wonder where this conflicted....
//#undef LineDuplicate
#else
#ifdef USE_SACK_ALLOCER
inline void * operator new(size_t size)
{ return AllocateEx( size ); }
inline void operator delete (void * p)
{ ReleaseEx( p ); }
#endif
#endif
#endif
#endif
#ifndef _TIMER_NAMESPACE
#ifdef __cplusplus
#define _TIMER_NAMESPACE namespace timers {
/* define a timer library namespace in C++. */
#define TIMER_NAMESPACE SACK_NAMESPACE namespace timers {
/* define a timer library namespace in C++ end. */
#define TIMER_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define _TIMER_NAMESPACE
#define TIMER_NAMESPACE
#define TIMER_NAMESPACE_END
#endif
#endif
// this is a method replacement to use PIPEs instead of SEMAPHORES
// replacement code only affects linux.
#if defined( __QNX__ ) || defined( __MAC__) || defined( __LINUX__ ) || defined( __ANDROID__ )
#  define USE_PIPE_SEMS
// no semtimedop; no semctl, etc
//#include <sys/sem.h>
#endif
#ifdef USE_PIPE_SEMS
#  define _NO_SEMTIMEDOP_
#endif
SACK_NAMESPACE
/* This namespace contains methods for working with timers and
   threads. Since timers are implemented in an asynchronous
   thread, the thread creation and control can be exposed here
   also.
   ThreadTo
   WakeThread
   WakeableSleep [Example]
   AddTimer
   RemoveTimer
   RescheduleTimer
   EnterCriticalSec see Also
 EnterCriticalSecNoWait
   LeaveCriticalSec                                            */
_TIMER_NAMESPACE
#ifdef TIMER_SOURCE
#define TIMER_PROC(type,name) EXPORT_METHOD type CPROC name
#else
/* Defines import export and call method for timers. Looks like
   timers are native calltype by default instead of CPROC.      */
#define TIMER_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#if defined( __LINUX__ ) || defined( __ANDROID__ )
TIMER_PROC( uint32_t, timeGetTime )( void );
TIMER_PROC( uint32_t, GetTickCount )( void );
TIMER_PROC( void, Sleep )( uint32_t ms );
#endif
/* Function signature for user callbacks passed to AddTimer. */
typedef void (CPROC *TimerCallbackProc)( uintptr_t psv );
/* Adds a new periodic timer. From now, until the timer is
   removed with RemoveTimer, it will call the timer procedure at
   the specified frequency of milliseconds. The delay until the
   first time the timer fires can be specified independant of
   frequency. If it is not specified, the first time the timer
   will get invoked is at +1 frequency from now.
   Parameters
   start :      how long in milliseconds until the timer starts. Can
                be 0 and timer will fire at the next opportunity.
   frequency :  how long the delay is between event invocations,
                in milliseconds.
   callback :   user routine to call when the timer's delay
                expires.
   user :       user data to pass to the callback when it is
                invoked.
   Returns
   a 32 bit ID that identifies the timer for this application.
   Example
   First some setup valid for all timer creations...
   <code lang="c++">
   void CPROC TimerProc( uintptr_t user_data )
   {
       // user_data of the timer is the 'user' parameter passed to AddTimer(Exx)
   }
   </code>
   you might want to save this for something like
   RescheduleTimer
   <code>
   uint32_t timer_id;
   </code>
   Create a simple timer, it will fire at 250 milliseconds from
   now, and again every 250 milliseconds from the time it
   starts.
   <code lang="c++">
   timer_id = AddTimer( 250, TimerProc, 0 );
   </code>
   Create a timer that fires immediately, and 732 milliseconds
   after, passing some value 1234 as user data...
   <code lang="c++">
   timer_id = AddTimerEx( 0, 732, TimerProc, 1234 );
	</code>
	Remarks
	if a timer is dispatched and needs to wait - please link with idlelib, and call Idle.
	this will allow other timers to fire on schedule.  The timer that is waiting is not
	in the list of timers to process.
	*/
TIMER_PROC( uint32_t, AddTimerExx )( uint32_t start, uint32_t frequency
					, TimerCallbackProc callback
					, uintptr_t user DBG_PASS);
/* <combine sack::timers::AddTimerExx@uint32_t@uint32_t@TimerCallbackProc@uintptr_t user>
   \ \                                                                         */
#define AddTimerEx( s,f,c,u ) AddTimerExx( (s),(f),(c),(u) DBG_SRC )
/* <combine sack::timers::AddTimerExx@uint32_t@uint32_t@TimerCallbackProc@uintptr_t user>
   \ \                                                                         */
#define AddTimer( f, c, u ) AddTimerExx( (f), (f), (c), (u) DBG_SRC)
/* Stops a timer. The next time this timer would run, it will be
   removed. If it is currently dispatched, it is safe to remove
   from within the timer itself.
   Parameters
   timer :  32 bit timer ID from AddTimer.                       */
TIMER_PROC( void, RemoveTimer )( uint32_t timer );
/* Reschedule when a timer can fire. The delay can be 0 to make
   wake the timer.
   Parameters
   timer :  32 bit timer identifier from AddTimer.
   delay :  How long before the timer should run now.<p />If 0,
            will issue timer immediately.<p />If not specified,
            using the macro, the default delay is the timer's
            frequency. (can prevent the timer from firing until
            it's frequency from now.)                           */
TIMER_PROC( void, RescheduleTimerEx )( uint32_t timer, uint32_t delay );
/* <combine sack::timers::RescheduleTimerEx@uint32_t@uint32_t>
   \ \                                               */
TIMER_PROC( void, RescheduleTimer )( uint32_t timer );
/* Changes the frequency of a timer. Reschedule timer only
   changes the next time it fires, this can adjust the
   frequency. The simple ChangeTimer macro is sufficient.
   Parameters
   ID :         32 bit ID of the time created by AddTimer.
   initial :    initial delay of the timer. (Might matter if the
                timer hasn't fired the first time)
   frequency :  new delay between timer callback invokations.    */
TIMER_PROC( void, ChangeTimerEx )( uint32_t ID, uint32_t initial, uint32_t frequency );
/* <combine sack::timers::ChangeTimerEx@uint32_t@uint32_t@uint32_t>
   \ \                                               */
#define ChangeTimer( ID, Freq ) ChangeTimerEx( ID, Freq, Freq )
/* This is the type returned by MakeThread, and passed to
   ThreadTo. This is a private structure, and no definition is
   publicly available, this should be treated like a handle.   */
typedef struct threads_tag *PTHREAD;
/* Function signature for a thread entry point passed to
   ThreadTo.                                             */
typedef uintptr_t (CPROC*ThreadStartProc)( PTHREAD );
/* Function signature for a thread entry point passed to
   ThreadToSimple.                                             */
typedef uintptr_t (*ThreadSimpleStartProc)( POINTER );
/* Create a separate thread that starts in the routine
   specified. The uintptr_t value (something that might be a
   pointer), is passed in the PTHREAD structure. (See
   GetThreadParam)
   Parameters
   proc :       starting routine for the thread
   user_data :  some value that can be stored in the number of
                bits that a pointer is. This is passed to the
                proc when the thread starts.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( PTHREAD, ThreadToEx )( ThreadStartProc proc, uintptr_t param DBG_PASS );
/* <combine sack::timers::ThreadToEx@ThreadStartProc@uintptr_t param>
   \ \                                                               */
#define ThreadTo(proc,param) ThreadToEx( proc,param DBG_SRC )
/* Create a separate thread that starts in the routine
   specified. The uintptr_t value (something that might be a
   pointer), is passed in the PTHREAD structure. (See
   GetThreadParam)
   Parameters
   proc :       starting routine for the thread
   user_data :  some value that can be stored in the number of
                bits that a pointer is. This is passed to the
                proc when the thread starts.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( PTHREAD, ThreadToSimpleEx )( ThreadSimpleStartProc proc, POINTER param DBG_PASS );
/* <combine sack::timers::ThreadToEx@ThreadStartProc@uintptr_t param>
   \ \                                                               */
#define ThreadToSimple(proc,param) ThreadToSimpleEx( proc,param DBG_SRC )
/* \Returns a PTHREAD that represents the current thread. This
   can be used to create a PTHREAD identifier for the main
   thread.
   Parameters
   None.
   Returns
   a pointer to a thread structure that identifies the current
   thread. If this thread already has this structure created,
   the same one results on subsequent MakeThread calls.        */
TIMER_PROC( PTHREAD, MakeThread )( void );
/* Releases resources associated with a PTHREAD. For purposes of
   waking a thread, and providing a wakeable point for the
   thread, a system blocking event object is allocated, named
   with the THREAD_ID so it can be referenced by other
   processes. This is only allowed to be done by the thread
   itself.
   Parameters
   Param1 :  \Description
   Param2 :  \Description
   Example
   <code lang="c++">
   int main( void )
   {
       PTHREAD myself = MakeThread();
       // create threads, do stuff...
       UnmakeThread();
       At this point the pointer in 'myself' is invalid, and should be cleared.
       myself = NULL;
   }
   </code>                                                                      */
TIMER_PROC( void, UnmakeThread )( void );
/* This returns the parameter passed as user data to ThreadTo.
   Parameters
   thread :  thread to get the parameter from.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( uintptr_t, GetThreadParam )( PTHREAD thread );
/* \returns the numeric THREAD_ID from a PTHREAD.
   Parameters
   thread :  thread to get the system wide unique ID of. */
TIMER_PROC( THREAD_ID, GetThreadID )( PTHREAD thread );
/* \returns the numeric THREAD_ID from a PTHREAD.
   Parameters
   thread :  thread to get the system wide unique ID of. */
TIMER_PROC( THREAD_ID, GetThisThreadID )( void );
/* Symbol defined to pass to Wakeable_Sleep to sleep until
   someone calls WakeThread.                               */
#define SLEEP_FOREVER 0xFFFFFFFF
/* Sleeps a number of milliseconds or until the thread is passed
   to WakeThread.
   Parameters
   dwMilliseconds :  How long to sleep. Can be indefinite if
                     value is SLEEP_FOREVER.
   Example
   <code lang="c++">
   PTHREAD main_thread;
   uintptr_t CPROC WakeMeThread( PTHREAD thread )
   {
      // get the value passed to ThreadTo as user_data.
      uintptr_t user_data = GetThreadParam( thread );
      // let the main thread sleep a little wile
       WakeableSleep( 250 );
      // then wake it up
       WakeThread( main_thread );
       return 0;
   }
   int main( void )
   {
       // save my PTHREAD globally.
       main_thread = MakeThread();
       // create a thread that can wake us
       ThreadTo( WakeMeThread, 0 );
       // demonstrate sleeping
       WakableSleep( SLEEP_FOREVER );
       return 0;
   }
   </code>                                                       */
TIMER_PROC( void, WakeableSleepEx )( uint32_t milliseconds DBG_PASS );
TIMER_PROC( void, WakeableSleep )( uint32_t milliseconds );
TIMER_PROC( void, WakeableNamedSleepEx )( CTEXTSTR name, uint32_t n DBG_PASS );
#define WakeableNamedSleep( name, n )   WakeableNamedSleepEx( name, n DBG_SRC )
TIMER_PROC( void, WakeNamedSleeperEx )( CTEXTSTR name DBG_PASS );
#define WakeNamedSleeper( name )   WakeNamedSleeperEx( name DBG_SRC )
TIMER_PROC( void, WakeableNamedThreadSleepEx )( CTEXTSTR name, uint32_t n DBG_PASS );
#define WakeableNamedThreadSleep( name, n )   WakeableNamedThreadSleepEx( name, n DBG_SRC )
TIMER_PROC( void, WakeNamedThreadSleeperEx )( CTEXTSTR name, THREAD_ID therad DBG_PASS );
#define WakeNamedThreadSleeper( name, thread )   WakeNamedThreadSleeperEx( name, thread DBG_SRC )
#ifdef USE_PIPE_SEMS
TIMER_PROC( int, GetThreadSleeper )( PTHREAD thread );
#endif
/* <combine sack::timers::WakeableSleepEx@uint32_t milliseconds>
   \ \                                                      */
#define WakeableSleep(n) WakeableSleepEx(n DBG_SRC )
/* Wake a thread by ID, if the pThread is not available. Can be
   used cross-process for instance. Although someone could add a
   method to provide a PTHREAD wrapper around THREAD_ID for
   threads in remote processes, this may not be a best practice.
   Parameters
   thread_id :  THREAD_ID from GetMyThreadID, which is a macro
                appropriate for a platform.                      */
TIMER_PROC( void, WakeThreadIDEx )( THREAD_ID thread DBG_PASS );
/* Wake a thread.
   Example
   See WakeableSleepEx.
   Parameters
   pThread :  thread to wake up from a WakeableSleep. */
TIMER_PROC( void, WakeThreadEx )( PTHREAD thread DBG_PASS );
/* <combine sack::timers::WakeThreadIDEx@THREAD_ID thread>
   \ \                                                     */
#define WakeThreadID(thread) WakeThreadIDEx( thread DBG_SRC )
/* <combine sack::timers::WakeThreadEx@PTHREAD thread>
   \ \                                                 */
#define WakeThread(t) WakeThreadEx(t DBG_SRC )
/* This can be checked to see if the THREAD_ID to wake still has
   an event. Sometimes threads end.
   Parameters
   thread :  thread identifier to check to see if it exists/can be
             woken.
   Returns
   TRUE if the thread can be signaled to wake up.
   FALSE if the thread cannot be found or cannot be woken up.      */
TIMER_PROC( int, TestWakeThreadID )( THREAD_ID thread );
/* This can be checked to see if the PTHREAD to wake still has
   an event. Sometimes threads call UnmakeThread(). This is a
   more practical test using a THREAD_ID instead. See
   TestWakeThreadID.
   Returns
   TRUE if the thread can be signaled to wake up.
   FALSE if the thread cannot be found or cannot be woken up.  */
TIMER_PROC( int, TestWakeThread )( PTHREAD thread );
//TIMER_PROC( void, WakeThread )( PTHREAD thread );
TIMER_PROC( void, EndThread )( PTHREAD thread );
/* This tests to see if a pointer to a thread references the
   current thread.
   Parameters
   thread :  thread to check to see if it is the current thread.
   Returns
   TRUE if this thread is the same as the PTHREAD passed.
   otherwise FALSE.
   Example
   <code lang="c++">
   PTHREAD main_thread;
   LOGICAL thread_finished_check;
   uintptr_t CPROC ThreadProc( PTHREAD thread )
   {
       if( IsThisThread( main_thread ) )
            printf( "This thread is not the main thread.\\n" );
       else
            printf( "This is the main thread - cannot happen :)\\n" );
   </code>
   <code>
       // mark that this thread is complete
       thread_finished_check = TRUE;
   </code>
   <code lang="c++">
       // hmm - for some reason, just pass the uintptr_t that was passed to ThreadTo as the result.
       return GetThreadParam( thread );
   }
   int main( void )
   {
        main_thread = MakeThread();
        ThreadTo( ThreadProc, 0 );
        // wait for the thread to finish its thread identity check.
        while( !thread_finished_check )
            Relinquish();
        return 0;
   }
   </code>                                                                                         */
TIMER_PROC( int, IsThisThreadEx )( PTHREAD pThreadTest DBG_PASS );
/* <combine sack::timers::IsThisThreadEx@PTHREAD pThreadTest>
   \ \                                                        */
#define IsThisThread(thread) IsThisThreadEx(thread DBG_SRC)
/* Enter a critical section. Only a single thread may be in a
   critical section, if a second thread attempts to enter the
   section while another thread is in it will block until the
   original thread leaves the section. The same thread may enter
   a critical section multiple times. For each time a critical
   section is entered, the thread must also leave the critical
   section (See LeaveCriticalSection).
   Parameters
   pcs :  pointer to a critical section to enter                 */
TIMER_PROC( LOGICAL, EnterCriticalSecEx )( PCRITICALSECTION pcs DBG_PASS );
/* Leaves a critical section. See EnterCriticalSecEx.
   Parameters
   pcs :  pointer to a critical section.              */
TIMER_PROC( LOGICAL, LeaveCriticalSecEx )( PCRITICALSECTION pcs DBG_PASS );
/* Does nothing. There are no extra resources required for
   critical sections, and the memory is allocated by the
   application.
   Parameters
   pcs :  pointer to critical section to do nothing with.  */
TIMER_PROC( void, DeleteCriticalSec )( PCRITICALSECTION pcs );
#ifdef _WIN32
	TIMER_PROC( HANDLE, GetWakeEvent )( void );
	TIMER_PROC( HANDLE, GetThreadHandle )( PTHREAD thread );
#endif
#ifdef __LINUX__
	TIMER_PROC( pthread_t, GetThreadHandle )(PTHREAD thread);
#endif
#ifdef USE_NATIVE_CRITICAL_SECTION
#define EnterCriticalSec(pcs) EnterCriticalSection( pcs )
#define LeaveCriticalSec(pcs) LeaveCriticalSection( pcs )
#else
/* <combine sack::timers::EnterCriticalSecEx@PCRITICALSECTION pcs>
   \ \                                                             */
#define EnterCriticalSec( pcs ) EnterCriticalSecEx( (pcs) DBG_SRC )
/* <combine sack::timers::LeaveCriticalSecEx@PCRITICALSECTION pcs>
   \ \                                                             */
#define LeaveCriticalSec( pcs ) LeaveCriticalSecEx( (pcs) DBG_SRC )
#endif
TIMER_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::timers;
#endif
#endif
// $Log: timers.h,v $
// Revision 1.37  2005/05/16 19:06:58  jim
// Extend wakeable sleep to know the originator of the sleep.
//
// Revision 1.36  2004/09/29 16:42:51  d3x0r
// fixed queues a bit - added a test wait function for timers/threads
//
// Revision 1.35  2004/07/07 15:33:54  d3x0r
// Cleaned c++ warnings, bad headers, fixed make system, fixed reallocate...
//
// Revision 1.34  2004/05/02 02:04:16  d3x0r
// Begin border exclusive option, define PushMethod explicitly, fix LaunchProgram in timers.h
//
// Revision 1.33  2003/12/10 15:38:25  panther
// Move Sleep and GetTickCount to real code
//
// Revision 1.32  2003/11/02 00:31:47  panther
// Added debuginfo pass to wakethread
//
// Revision 1.31  2003/10/24 14:59:21  panther
// Added Load/Unload Function for system shared library abstraction
//
// Revision 1.30  2003/10/17 00:56:04  panther
// Rework critical sections.
// Moved most of heart of these sections to timers.
// When waiting, sleep forever is used, waking only when
// released... This is preferred rather than continuous
// polling of section with a Relinquish.
// Things to test, event wakeup order uner linxu and windows.
// Even see if the wake ever happens.
// Wake should be able to occur across processes.
// Also begin implmeenting MessageQueue in containers....
// These work out of a common shared memory so multiple
// processes have access to this region.
//
// Revision 1.29  2003/09/21 04:03:30  panther
// Build thread ID with pthread_self and getgid
//
// Revision 1.28  2003/07/29 10:41:25  panther
// Predefine struct threads_tag to avoid warning
//
// Revision 1.27  2003/07/24 22:49:20  panther
// Define callback procs as CDECL
//
// Revision 1.26  2003/07/24 16:56:41  panther
// Updates to expliclity define C procedure model for callbacks and assembly modules - incomplete
//
// Revision 1.25  2003/07/22 15:33:19  panther
// Added comment about idle()
//
// Revision 1.24  2003/04/03 10:10:20  panther
// Add file/line debugging to addtimer
//
// Revision 1.23  2003/03/27 13:47:14  panther
// Immplement a EndThread
//
// Revision 1.22  2003/03/25 08:38:11  panther
// Add logging
//
#ifndef MAXPATH
// windef.h has MAX_PATH
# define MAXPATH MAX_PATH
#endif
#ifndef PATH_MAX
// sometimes PATH_MAX is what's used, well it's should be MAXPATH which is MAX_PATH
# define PATH_MAX MAXPATH
#endif
#ifdef _UNICODE
#  ifdef _WIN32
#    ifdef CONSOLE_SHELL
    // in order to get wide characters from the commandline we have to use the GetCommandLineW function, convert it to utf8 for internal usage.
#      define SaneWinMain(a,b) int main( int a, char **argv_real ) { char *tmp; TEXTCHAR **b; ParseIntoArgs( GetCommandLineW(), &a, &b ); Deallocate( char*, tmp ); {
	//int n; TEXTCHAR **b; b = NewArray( TEXTSTR, a + 1 ); for( n = 0; n < a; n++ ) b[n] = DupCharToText( argv_real[n] ); b[n] = NULL; {
#      define EndSaneWinMain() } }
#    else
#      define SaneWinMain(a,b) int APIENTRY WinMain( HINSTANCE hInst, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow ) { char *tmp; int a; TEXTCHAR **b; ParseIntoArgs( tmp = WcharConvert( GetCommandLineW() ), &a, &b ); Deallocate( char*, tmp ); {
#      define EndSaneWinMain() } }
#    endif
#  else
#    if defined( __ANDROID__ ) && !defined( ANDROID_CONSOLE_UTIL )
#      define SaneWinMain(a,b) int SACK_Main( int a, char **b )
#      define EndSaneWinMain()
#    else
#      define SaneWinMain(a,b) int main( int a, char **argv_real ) { int n; TEXTCHAR **b; b = NewArray( TEXTSTR, a + 1 ); for( n = 0; n < a; n++ ) b[n] = DupCharToText( argv_real[n] ); b[n] = NULL; {
#      define EndSaneWinMain() } }
#    endif
#  endif
#else
#  ifdef _WIN32
#    ifdef CONSOLE_SHELL
// in order to get wide characters from the commandline we have to use the GetCommandLineW function, convert it to utf8 for internal usage.
#      define SaneWinMain(a,b) int main( int a, char **argv_real ) { char *tmp; TEXTCHAR **b; ParseIntoArgs( tmp = WcharConvert( GetCommandLineW() ), &a, &b ); Deallocate( char*, tmp ); {
#      define EndSaneWinMain() } }
#    else
#      define SaneWinMain(a,b) int APIENTRY WinMain( HINSTANCE hInst, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow ) { int a; char *tmp; TEXTCHAR **b; ParseIntoArgs( tmp = WcharConvert( GetCommandLineW() ), &a, &b ); {
#      define EndSaneWinMain() } }
#    endif
#  else
#    if defined( __ANDROID__ ) && !defined( ANDROID_CONSOLE_UTIL )
#      define SaneWinMain(a,b) int SACK_Main( int a, char **b )
#      define EndSaneWinMain()
#    else
#      define SaneWinMain(a,b) int main( int a, char **b ) { char **argv_real = b; {
#      define EndSaneWinMain() } }
#    endif
#  endif
#endif
//  these are rude defines overloading otherwise very practical types
// but - they have to be dispatched after all standard headers.
#ifndef FINAL_TYPES
#define FINAL_TYPES
#  ifdef __WATCOMC__
 //__WATCOMC__
#  endif
#  ifdef _WIN32
#    include <basetsd.h>
  // this redefines lprintf sprintf etc... and strsafe is preferred
 // more things that need override by strsafe.h
#    include <tchar.h>
 // added for mingw64 actually
#    ifdef __GNUC__
#      undef __CRT__NO_INLINE
#    endif
#    ifndef MINGW_SUX
#      include <strsafe.h>
#    else
#      define STRSAFE_E_INSUFFICIENT_BUFFER  0x8007007AL
#    endif
#  else
#  endif
// may consider changing this to uint16_t* for unicode...
#ifdef UNICODE
#  ifndef NO_UNICODE_C
#    define strrchr          wcsrchr
#    define strchr           wcschr
#    define strncpy          wcsncpy
#    ifdef strcpy
#      undef strcpy
#    endif
#    define strcpy           wcscpy
#    define strcmp           wcscmp
#    ifndef __LINUX__
// linux also translates 'i' to 'case' in sack_typelib.h
#      define stricmp          wcsicmp
#      define strnicmp         wcsnicmp
//#  define strlen           mbrlen
#    endif
#    define strlen           wcslen
#    ifdef WIN32
#      define stat(a,b)        _wstat(a,b)
#    else
#    endif
#    define printf           wprintf
#    define fprintf          fwprintf
#    define fputs            fputws
#    define fgets            fgetws
#    define atoi             _wtoi
#    ifdef __WATCOMC__
#      undef atof
#    endif
//#    define atof             _wtof
#    ifdef _MSC_VER
#      ifndef __cplusplus_cli
#        define fprintf   fwprintf
#        define atoi      _wtoi
// define sprintf here.
#      endif
#    endif
#    if defined( _ARM_ ) && defined( WIN32 )
// len should be passed as character count. this was the wrongw ay to default this.
#      define snprintf StringCbPrintf
//#define snprintf StringCbPrintf
#    endif
#  else
//#    define atoi             wtoi
#  endif
 // not unicode...
#else
#endif
#  ifdef _MSC_VER
#    define SUFFER_WITH_NO_SNPRINTF
#    ifndef SUFFER_WITH_NO_SNPRINTF
#      define vnsprintf protable_vsnprintf
//   this one gives deprication warnings
//   #    define vsnprintf _vsnprintf
//   this one doesn't work to measure strings
//   #    define vsnprintf(buf,len,format,args) _vsnprintf_s(buf,len,(len)/sizeof(TEXTCHAR),format,args)
//   this one doesn't macro well, and doesnt' measure strings
//  (SUCCEEDED(StringCbVPrintf( buf, len, format, args ))?StrLen(buf):-1)
#      define snprintf portable_snprintf
//   this one gives deprication warnings
//   #    define snprintf _snprintf
//   this one doesn't work to measure strings
//   #    define snprintf(buf,len,format,...) _snprintf_s(buf,len,(len)/sizeof(TEXTCHAR),format,##__VA_ARGS__)
//   this one doesn't macro well, and doesnt' measure strings
//   (SUCCEEDED(StringCbPrintf( buf, len, format,##__VA_ARGS__ ))?StrLen(buf):-1)
// make sure this is off, cause we really don't, and have to include the following
#      undef HAVE_SNPRINTF
 // define this anyhow so we can avoid name collisions
#      define PREFER_PORTABLE_SNPRINTF
#      ifdef SACK_CORE_BUILD
#        include <../src/snprintf_2.2/snprintf.h>
#      else
#        include <snprintf-2.2/snprintf.h>
 // SACK_CORE_BUILD
#      endif
 // SUFFER_WITH_WARNININGS
#    else
#      define snprintf _snprintf
#      define vsnprintf _vsnprintf
#      if defined( _UNICODE )
#        define tnprintf _snwprintf
#        define vtnprintf _vsnwprintf
#      else
#        define tnprintf _snprintf
#        define vtnprintf _vsnprintf
#      endif
#    define snwprintf _snwprintf
// suffer_with_warnings
#    endif
#    if defined( _UNICODE ) && !defined( NO_UNICODE_C )
#    define tscanf swscanf_s
#    else
#    define tscanf sscanf_s
#    endif
#    define scanf sscanf_s
#    define swcanf swscanf_s
 // _MSC_VER
#  endif
#  ifdef  __GNUC__
#      if defined( _UNICODE )
#        define VSNPRINTF_FAILS_RETURN_SIZE
#        define tnprintf  swprintf
#        define vtnprintf vswprintf
#        if !defined( NO_UNICODE_C )
#           define snprintf   swprintf
#           define vsnprintf  vswprintf
//#           define sscanf     swscanf
#        else
#        endif
#      else
#        define tnprintf snprintf
#        define vtnprintf vsnprintf
//#        define snprintf snprintf
//#        define vsnprintf vsnprintf
#    if defined( _UNICODE ) && !defined( NO_UNICODE_C )
#    define tscanf swscanf
#    else
#    define tscanf sscanf
#    endif
#      endif
 // __GNUC__
#  endif
#  ifdef __WATCOMC__
#      if defined( _UNICODE )
#        define tnprintf  _snwprintf
#        define vtnprintf _vsnwprintf
#        if !defined( NO_UNICODE_C )
#           define snprintf  _snwprintf
#           define vsnprintf _vsnwprintf
#           define sscanf     swscanf
#        else
#        endif
#      else
#         define tnprintf  snprintf
#         define vtnprintf vsnprintf
//#        define snprintf snprintf
//#        define vsnprintf vsnprintf
#      endif
#        define snwprintf  _snwprintf
 // __WATCOMC__
#  endif
#endif
#endif
 // tolower on linux
#  include <ctype.h>
/*
 *  Created By Jim Buckeyne
 *
 *  Purpose:
 *    Provides some cross platform/library functionatlity for
 *  filesystem activities.
 *  - File dates, times, stuff like that
 *  - make paths, change paths
 *  - path parsing (like strchr, strrchr, but looking for closest / or \)
 *  - scan a directory for a set of files... using a recursive callback method
 */
#ifndef FILESYSTEM_UTILS_DEFINED
/* Header multiple inclusion protection symbol. */
#define FILESYSTEM_UTILS_DEFINED
#if _MSC_VER >= 1600
#include <share.h>
#endif
#if !defined( UNDER_CE )
#include <fcntl.h>
#if !defined( __LINUX__ )
#include <io.h>
#else
#define LPFILETIME uint64_t*
#define FILETIME uint64_t
#endif
#endif
/* uhmm in legacy usage this was not CPROC, but was unspecified */
#define FILESYS_API CPROC
// DOM-IGNORE-BEGIN
#ifdef FILESYSTEM_LIBRARY_SOURCE
#  define FILESYS_PROC EXPORT_METHOD
#else
#  define FILESYS_PROC IMPORT_METHOD
#endif
// DOM-IGNORE-END
#ifdef __cplusplus
/* defined the file system partial namespace (under
   SACK_NAMESPACE probably)                         */
#define _FILESYS_NAMESPACE  namespace filesys {
/* Define the ending symbol for file system namespace. */
#define _FILESYS_NAMESPACE_END }
/* Defined the namespace of file montior utilities. File monitor
   provides event notification based on file system changes.     */
#define _FILEMON_NAMESPACE  namespace monitor {
/* Define the end symbol for file monitor namespace. */
#define _FILEMON_NAMESPACE_END }
#else
#define _FILESYS_NAMESPACE
#define _FILESYS_NAMESPACE_END
#define _FILEMON_NAMESPACE
#define _FILEMON_NAMESPACE_END
#endif
/* define the file system namespace end. */
#define FILESYS_NAMESPACE_END _FILESYS_NAMESPACE_END SACK_NAMESPACE_END
/* define the file system namespace. */
#define FILESYS_NAMESPACE SACK_NAMESPACE _FILESYS_NAMESPACE
/* Define end file monitor namespace. */
#define FILEMON_NAMESPACE_END _FILEMON_NAMESPACE_END _FILESYS_NAMESPACE_END SACK_NAMESPACE_END
/* Defines the file montior namespace when compiling C++. */
#define FILEMON_NAMESPACE SACK_NAMESPACE _FILESYS_NAMESPACE _FILEMON_NAMESPACE
SACK_NAMESPACE
/* \File system abstractions. A few things like get current path
   may or may not exist on a function.
   Primarily this defines functions 'pathchr' and 'pathrchr'
   which resemble 'strchr' and 'strrchr' but search a string for
   a path character. A path character is either a / or a \\.
   Also in this area is file monitoring functions which support
   methods on windows and linux to get event notifications when
   directories and, by filtering, files that have changed.
                                                                 */
_FILESYS_NAMESPACE
	enum ScanFileFlags {
 // go into subdirectories
SFF_SUBCURSE    = 1,
 // return directory names also
SFF_DIRECTORIES = 2,
 // don't concatenate base with filename to result.
SFF_NAMEONLY    = 4,
 // when matching filename - do not match case.
SFF_IGNORECASE  = 8,
 // don't concatenate base with filename to result, but do build path relative to root specified
SFF_SUBPATHONLY    = 16,
	};
 // flags sent to Process when called with a matching name
enum ScanFileProcessFlags{
 // is a directory...
SFF_DIRECTORY  = 1,
 // this is a drive...
		SFF_DRIVE      = 2,
};
struct file_system_mounted_interface;
/* Extended external file system interface to be able to use external file systems */
struct file_system_interface {
                                                  //filename
	void* (CPROC *open)(uintptr_t psvInstance, const char *, const char *);
                                                 //file *
	int (CPROC *_close)(void *);
                    //file *, buffer, length (to read)
	size_t (CPROC *_read)(void *,char *, size_t);
                    //file *, buffer, length (to write)
	size_t (CPROC *_write)(void*,const char *, size_t);
	size_t (CPROC *seek)( void *, size_t, int whence);
	void  (CPROC *truncate)( void *);
	int (CPROC *_unlink)( uintptr_t psvInstance, const char *);
 // get file size
	size_t (CPROC *size)( void *);
 // get file current position
	size_t (CPROC *tell)( void *);
	int (CPROC *flush )(void *kp);
	int (CPROC *exists)( uintptr_t psvInstance, const char *file );
	LOGICAL (CPROC*copy_write_buffer)(void );
	struct find_cursor *(CPROC *find_create_cursor )( uintptr_t psvInstance, const char *root, const char *filemask );
	int (CPROC *find_first)( struct find_cursor *cursor );
	int (CPROC *find_close)( struct find_cursor *cursor );
	int (CPROC *find_next)( struct find_cursor *cursor );
	char * (CPROC *find_get_name)( struct find_cursor *cursor );
	size_t (CPROC *find_get_size)( struct find_cursor *cursor );
	LOGICAL (CPROC *find_is_directory)( struct find_cursor *cursor );
	LOGICAL (CPROC *is_directory)( uintptr_t psvInstance, const char *cursor );
	LOGICAL (CPROC *rename )( uintptr_t psvInstance, const char *original_name, const char *new_name );
};
/* \ \
   Parameters
   mask :      This is the mask used to compare
   name :      this is the name to compare against using the mask.
   keepcase :  if TRUE, must match case also.
   Returns
   TRUE if name is matched by mask. Otherwise returns FALSE.
   Example
   <code lang="c++">
   if( CompareMask( "*.exe", "program.exe", FALSE ) )
   {
       // then program.exe is matched by the mask.
   }
   </code>
   Remarks
   The mask support standard 'globbing' characters.
   ? matches one character
   \* matches 0 or more characters
   otherwise the literal character must match, unless comparing
   case insensitive, in which case 'A' == 'a' also.                */
FILESYS_PROC  int FILESYS_API  CompareMask ( CTEXTSTR mask, CTEXTSTR name, int keepcase );
// ScanFiles usage:
//   base - base path to scan
//   mask - file mask to process if NULL or "*" is everything "*.*" must contain a .
//   pInfo is a pointer to a void* - this pointer is used to maintain
//        internal information...
//   Process is called with the full name of any matching files
//   subcurse is a flag - set to go into all subdirectories looking for files.
// There is no way to abort the scan...
FILESYS_PROC  int FILESYS_API  ScanFilesEx ( CTEXTSTR base
           , CTEXTSTR mask
           , void **pInfo
           , void CPROC Process( uintptr_t psvUser, CTEXTSTR name, int flags )
           , int flags
		   , uintptr_t psvUser, LOGICAL begin_sub_path, struct file_system_mounted_interface *mount );
FILESYS_PROC  int FILESYS_API  ScanFiles ( CTEXTSTR base
           , CTEXTSTR mask
           , void **pInfo
           , void CPROC Process( uintptr_t psvUser, CTEXTSTR name, int flags )
           , int flags
           , uintptr_t psvUser );
FILESYS_PROC  void FILESYS_API  ScanDrives ( void (CPROC *Process)(uintptr_t user, CTEXTSTR letter, int flags)
										  , uintptr_t user );
// result is length of name filled into pResult if pResult == NULL && nResult = 0
// the result will the be length of the name matching the file.
FILESYS_PROC  int FILESYS_API  GetMatchingFileName ( CTEXTSTR filemask, int flags, TEXTSTR pResult, int nResult );
// searches a path for the last '/' or '\'
FILESYS_PROC  CTEXTSTR FILESYS_API  pathrchr ( CTEXTSTR path );
#ifdef __cplusplus
FILESYS_PROC  TEXTSTR FILESYS_API  pathrchr ( TEXTSTR path );
#endif
// searches a path for the first '/' or '\'
FILESYS_PROC  CTEXTSTR FILESYS_API  pathchr ( CTEXTSTR path );
// returns pointer passed (if it worked?)
FILESYS_PROC  TEXTSTR FILESYS_API  GetCurrentPath ( TEXTSTR path, int buffer_len );
FILESYS_PROC  int FILESYS_API  SetCurrentPath ( CTEXTSTR path );
/* Creates a directory. If parent peices of the directory do not
   exist, those parts are created also.
   Example
   <code lang="c#">
   MakePath( "c:\\where\\I'm/going/to/store/data" );
   </code>                                                       */
FILESYS_PROC  int FILESYS_API  MakePath ( CTEXTSTR path );
/* A boolean result function whether a specified name is a
   directory or not. (if not, assumes it's a file).
   Example
   <code lang="c#">
   if( IsPath( "c:/windows" ) )
   {
       // if yes, then c:\\windows is a directory.
   }
   </code>                                                 */
FILESYS_PROC LOGICAL  FILESYS_API  IsPath ( CTEXTSTR path );
FILESYS_PROC LOGICAL  FILESYS_API  IsAbsolutePath( CTEXTSTR path );
FILESYS_PROC  uint64_t     FILESYS_API  GetFileWriteTime ( CTEXTSTR name );
FILESYS_PROC  uint64_t     FILESYS_API  GetTimeAsFileTime ( void );
FILESYS_PROC  LOGICAL FILESYS_API  SetFileWriteTime( CTEXTSTR name, uint64_t filetime );
FILESYS_PROC  LOGICAL FILESYS_API  SetFileTimes( CTEXTSTR name
  // last modification time.
															  , uint64_t filetime_create
 // last modification time.
															  , uint64_t filetime_modify
  // last modification time.
															  , uint64_t filetime_access
															  );
FILESYS_PROC  void    FILESYS_API  SetDefaultFilePath ( CTEXTSTR path );
FILESYS_PROC  INDEX   FILESYS_API  SetGroupFilePath ( CTEXTSTR group, CTEXTSTR path );
FILESYS_PROC  TEXTSTR FILESYS_API  sack_prepend_path ( INDEX group, CTEXTSTR filename );
/* This is a new feature added for supporting systems without a
   current file location. This gets an integer ID of a group of
   files by name.
   the name 'default' is used to specify files to go into the
   'current working directory'
	There are some special symbols.
	. = use CurrentPath
	@ = use program path base
   ^ = use program startup path (may not be current)
   Parameters
   groupname :     name of the group
   default_path :  the path of the group, if the name is not
                   found.
   Returns
   the ID of a file group.
   Example
   <code lang="c++">
   int group = GetFileGroup( "fonts", "./fonts" );
   </code>                                                      */
FILESYS_PROC INDEX FILESYS_API  GetFileGroup ( CTEXTSTR groupname, CTEXTSTR default_path );
FILESYS_PROC TEXTSTR FILESYS_API GetFileGroupText ( INDEX group, TEXTSTR path, int path_chars );
FILESYS_PROC TEXTSTR FILESYS_API ExpandPathEx( CTEXTSTR path, struct file_system_interface *fsi );
FILESYS_PROC TEXTSTR FILESYS_API ExpandPath( CTEXTSTR path );
FILESYS_PROC LOGICAL FILESYS_API SetFileLength( CTEXTSTR path, size_t length );
/* \Returns the size of the file.
   Parameters
   name :  name of the file to get information about
   Returns
   \Returns the size of the file. or -1 if the file did not
   exist.                                                   */
FILESYS_PROC  size_t FILESYS_API  GetSizeofFile ( TEXTCHAR *name, uint32_t* unused );
#ifndef __ANDROID__
/* An extended function, which returns a uint64_t bit time
   appropriate for the current platform. This is meant to
   replace 'stat'. It can get all commonly checked attributes of
   a file.
   Parameters
   name :              name of the file to get information about
   lpCreationTime :    pointer to a FILETIME type to get creation
                       time. can be NULL.
   lpLastAccessTime :  pointer to a FILETIME type to get access
                       time. can be NULL.
   lpLastWriteTime :   pointer to a FILETIME type to get write
                       time. can be NULL.
   IsDirectory :       pointer to a LOGICAL to receive indicator
                       whether the file was a directory. can be
                       NULL.
   Returns
   \Returns the size of the file. or -1 if the file did not
	exist.                                                         */
FILESYS_PROC  uint32_t FILESYS_API  GetFileTimeAndSize ( CTEXTSTR name
													, LPFILETIME lpCreationTime
													,  LPFILETIME lpLastAccessTime
													,  LPFILETIME lpLastWriteTime
													, int *IsDirectory
													);
FILESYS_PROC void FILESYS_API ConvertFileIntToFileTime( uint64_t int_filetime, FILETIME *filetime );
FILESYS_PROC uint64_t FILESYS_API ConvertFileTimeToInt( const FILETIME *filetime );
#endif
// can use 0 as filegroup default - single 'current working directory'
#ifndef NEED_OLDNAMES
#define _NO_OLDNAMES
#endif
//#ifdef UNDER_CE
# ifndef O_RDONLY
#define O_RDONLY       0x0000
#define O_WRONLY       0x0001
#define O_RDWR         0x0002
#define O_APPEND       0x0008
#define O_CREAT        0x0100
#define O_TRUNC        0x0200
#define O_EXCL         0x0400
#endif
#ifndef __ANDROID__
#  ifndef S_IRUSR
#    define S_IRUSR 1
#    define S_IWUSR 2
#  endif
#endif
//# endif
#ifndef __LINUX__
FILESYS_PROC  HANDLE FILESYS_API  sack_open ( INDEX group, CTEXTSTR filename, int opts, ... );
FILESYS_PROC  LOGICAL FILESYS_API  sack_set_eof ( HANDLE file_handle );
FILESYS_PROC  long  FILESYS_API   sack_tell( INDEX file_handle );
FILESYS_PROC  HANDLE FILESYS_API  sack_openfile ( INDEX group, CTEXTSTR filename, OFSTRUCT *of, int flags );
FILESYS_PROC  HANDLE FILESYS_API  sack_creat ( INDEX group, CTEXTSTR file, int opts, ... );
FILESYS_PROC  int FILESYS_API  sack_close ( HANDLE file_handle );
FILESYS_PROC  int FILESYS_API  sack_lseek ( HANDLE file_handle, int pos, int whence );
FILESYS_PROC  int FILESYS_API  sack_read ( HANDLE file_handle, POINTER buffer, int size );
FILESYS_PROC  int FILESYS_API  sack_write ( HANDLE file_handle, CPOINTER buffer, int size );
#endif
FILESYS_PROC  INDEX FILESYS_API  sack_iopen ( INDEX group, CTEXTSTR filename, int opts, ... );
FILESYS_PROC  INDEX FILESYS_API  sack_iopenfile ( INDEX group, CTEXTSTR filename, int opts, int flags );
FILESYS_PROC  INDEX FILESYS_API  sack_icreat ( INDEX group, CTEXTSTR file, int opts, ... );
FILESYS_PROC  LOGICAL FILESYS_API  sack_iset_eof ( INDEX file_handle );
FILESYS_PROC  int FILESYS_API  sack_iclose ( INDEX file_handle );
FILESYS_PROC  int FILESYS_API  sack_ilseek ( INDEX file_handle, size_t pos, int whence );
FILESYS_PROC  int FILESYS_API  sack_iread ( INDEX file_handle, POINTER buffer, int size );
FILESYS_PROC  int FILESYS_API  sack_iwrite ( INDEX file_handle, CPOINTER buffer, int size );
/* internal (c library) file system is registered as prority 1000.... lower priorities are checked first for things like
  ScanFiles(), fopen( ..., "r" ), ... exists(), */
FILESYS_PROC struct file_system_mounted_interface * FILESYS_API sack_mount_filesystem( const char *name, struct file_system_interface *, int priority, uintptr_t psvInstance, LOGICAL writable );
FILESYS_PROC void FILESYS_API sack_unmount_filesystem( struct file_system_mounted_interface *mount );
FILESYS_PROC struct file_system_mounted_interface * FILESYS_API sack_get_mounted_filesystem( const char *name );
/* sometimes you want scanfiles to only scan external files...
  so this is how to get that mount */
FILESYS_PROC struct file_system_mounted_interface * FILESYS_API sack_get_default_mount( void );
/* specify a mounted system to open... multiple volumes of the same type need a different handle */
FILESYS_PROC  FILE* FILESYS_API  sack_fopenEx( INDEX group, CTEXTSTR filename, CTEXTSTR opts, struct file_system_mounted_interface *fsi );
/* if mode is read, all mounted file systems are attempted... */
FILESYS_PROC  FILE* FILESYS_API  sack_fopen ( INDEX group, CTEXTSTR filename, CTEXTSTR opts );
/* specify a mounted system to open... multiple volumes of the same type need a different handle */
FILESYS_PROC  FILE* FILESYS_API  sack_fsopenEx ( INDEX group, CTEXTSTR filename, CTEXTSTR opts, int share_mode, struct file_system_mounted_interface *fsi );
/* if mode is read, all mounted file systems are attempted...
   if mode is write/create only the first writable file system is used...
*/
FILESYS_PROC  FILE* FILESYS_API  sack_fsopen ( INDEX group, CTEXTSTR filename, CTEXTSTR opts, int share_mode );
FILESYS_PROC  struct file_system_interface * FILESYS_API sack_get_filesystem_interface( CTEXTSTR name );
FILESYS_PROC  void FILESYS_API sack_set_default_filesystem_interface( struct file_system_interface *fsi );
FILESYS_PROC  void FILESYS_API sack_register_filesystem_interface( CTEXTSTR name, struct file_system_interface *fsi );
FILESYS_PROC  int FILESYS_API  sack_fclose ( FILE *file_file );
FILESYS_PROC  size_t FILESYS_API  sack_fseekEx ( FILE *file_file, size_t pos, int whence, struct file_system_mounted_interface *mount );
FILESYS_PROC  size_t FILESYS_API  sack_fseek ( FILE *file_file, size_t pos, int whence );
FILESYS_PROC  size_t FILESYS_API  sack_ftell ( FILE *file_file );
FILESYS_PROC  size_t FILESYS_API  sack_fsize ( FILE *file_file );
FILESYS_PROC  LOGICAL FILESYS_API  sack_existsEx ( const char * filename, struct file_system_mounted_interface *mount );
FILESYS_PROC  LOGICAL FILESYS_API  sack_exists ( const char *file_file );
// tests if the text passed is a directory or path to a file... for a specific mount.
FILESYS_PROC  LOGICAL FILESYS_API  sack_isPathEx ( const char *filename, struct file_system_mounted_interface *fsi );
// tests if the text passed is a directory or path to a file... for all mounts
FILESYS_PROC  LOGICAL FILESYS_API  sack_isPath( const char * filename );
FILESYS_PROC  size_t FILESYS_API  sack_fread ( POINTER buffer, size_t size, int count,FILE *file_file );
FILESYS_PROC  size_t FILESYS_API  sack_fwrite ( CPOINTER buffer, size_t size, int count,FILE *file_file );
FILESYS_PROC  TEXTSTR FILESYS_API  sack_fgets ( TEXTSTR  buffer, size_t size,FILE *file_file );
FILESYS_PROC  int FILESYS_API  sack_fflush ( FILE *file );
FILESYS_PROC  int FILESYS_API  sack_ftruncate ( FILE *file );
FILESYS_PROC int FILESYS_API sack_vfprintf( FILE *file_handle, const char *format, va_list args );
FILESYS_PROC int FILESYS_API sack_fprintf( FILE *file, const char *format, ... );
FILESYS_PROC int FILESYS_API sack_fputs( const char *format, FILE *file );
FILESYS_PROC  int FILESYS_API  sack_unlinkEx ( INDEX group, CTEXTSTR filename, struct file_system_mounted_interface *mount );
FILESYS_PROC  int FILESYS_API  sack_unlink ( INDEX group, CTEXTSTR filename );
FILESYS_PROC  int FILESYS_API  sack_rmdir( INDEX group, CTEXTSTR filename );
FILESYS_PROC  int FILESYS_API  sack_renameEx ( CTEXTSTR file_source, CTEXTSTR new_name, struct file_system_mounted_interface *mount );
FILESYS_PROC  int FILESYS_API  sack_rename ( CTEXTSTR file_source, CTEXTSTR new_name );
FILESYS_PROC  void FILESYS_API sack_set_common_data_application( CTEXTSTR name );
FILESYS_PROC  void FILESYS_API sack_set_common_data_producer( CTEXTSTR name );
#ifndef NO_FILEOP_ALIAS
#  ifndef NO_OPEN_MACRO
# define open(a,...) sack_iopen(0,a,##__VA_ARGS__)
# define set_eof(a)  sack_iset_eof(a)
#  endif
#ifdef WIN32
#if !defined( SACK_BAG_EXPORTS ) && !defined( BAG_EXTERNALS ) && !defined( FILESYSTEM_LIBRARY_SOURCE )
# define _lopen(a,...) sack_open(0,a,##__VA_ARGS__)
# define tell(a)      sack_tell(a)
# define lseek(a,b,c) sack_ilseek(a,b,c)
# define _llseek(a,b,c) sack_lseek(a,b,c)
# define HFILE HANDLE
# undef HFILE_ERROR
# define HFILE_ERROR INVALID_HANDLE_VALUE
# define creat(a,...)  sack_icreat( 0,a,##__VA_ARGS__ )
# define close(a)  sack_iclose(a)
# define OpenFile(a,b,c) sack_openfile(0,a,b,c)
# define _lclose(a)  sack_close(a)
# define read(a,b,c) sack_iread(a,b,c)
# define write(a,b,c) sack_iwrite(a,b,c)
# define _lread(a,b,c) sack_read(a,b,c)
# define _lwrite(a,b,c) sack_write(a,b,c)
# define _lcreat(a,b) sack_creat(0,a,b)
# define remove(a)   sack_unlink(0,a)
# define unlink(a)   sack_unlink(0,a)
#endif
#endif
 //NO_FILEOP_ALIAS
#endif
#ifdef __LINUX__
#define SYSPATHCHAR WIDE("/")
#else
#define SYSPATHCHAR WIDE("\\")
#endif
FILESYS_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::filesys;
#endif
#endif
/*
 * Create: James Buckeyne
 *
 * Purpose: Provide a general structure to register names of
 *   routines and data structures which may be consulted
 *   for runtime linking.  Aliases and other features make this
 *   a useful library for tracking interface registration...
 *
 *  The namespace may be enumerated.
 */
#ifndef PROCEDURE_REGISTRY_LIBRARY_DEFINED
#define PROCEDURE_REGISTRY_LIBRARY_DEFINED
#ifndef DEADSTART_DEFINED
#define DEADSTART_DEFINED
#ifdef WIN32
//#include <stdhdrs.h>
#endif
 // leach, assuming this will be compiled with this part at least.
#define pastejunk_(a,b) a##b
#define pastejunk(a,b) pastejunk_(a,b)
#ifdef __cplusplus
#define USE_SACK_DEADSTART_NAMESPACE using namespace sack::app::deadstart;
#define SACK_DEADSTART_NAMESPACE   SACK_NAMESPACE namespace app { namespace deadstart {
#define SACK_DEADSTART_NAMESPACE_END    } } SACK_NAMESPACE_END
SACK_NAMESPACE
	namespace app{
/* Application namespace. */
/* These are compiler-platform abstractions to provide a method
   of initialization that allows for creation of threads, and
   transparent (easy to use) method of scheduling routines for
   initialization.
   Example
   This schedules a routine to run at startup. Fill in the
   routine with the code you want, and it will run at
   DEFAULT_PRELOAD_PRIORITY which is the number 69.
   <code lang="c++">
   PRELOAD( MyCustomInit )
   {
       // do something here (do anything here,
       // without limitations that are imposed by DllMain/LibMain.
   }
   </code>
   If you wanted a routine which was guaranteed to run before
   MyCustomInit you might use PRIORITY_PRELOAD whcih allows you
   to specify a priority.
   <code lang="c++">
   PRIORITY_PRELOAD( MyOtherInit, DEFAULT_PRELOAD_PRIORITY-10 )
   {
      // this will run before other things.
   }
   </code>
   Priorities are listed in deadstart.h and exit_priorities.h. The
   priorities are treated backwards, so low number startup
   priorities go first, and higher number shutdown priorities go
   first.
   Remarks
   In some compilers and compile modes this is also fairly easy
   to do. A lot of compilers do not offer priority, and are
   impossible to maintain an order in. Some compilers only
   provide startup priority for C++ mode. This system works as
   \long as there is a way to run a single function at some
   point before main() and after C runtime initializes.
   In Windows, you might think you have this ability with
   DllMain, but there are severe limitations that you would have
   to get around; primary is the inability to create a thread,
   well, you can create it, but it will remain suspended until
   you leave DllMains and all DllMains finish. There is also no
   way to consistantly provide initialization order, like memory
   needs to be initialized before anything else.
                                                                   */
		namespace deadstart {
#else
#define USE_SACK_DEADSTART_NAMESPACE
#define SACK_DEADSTART_NAMESPACE
#define SACK_DEADSTART_NAMESPACE_END
#endif
#ifdef TYPELIB_SOURCE
#define DEADSTART_SOURCE
#endif
/* A macro to specify the call type of schedule routines. This
   can be changed in most projects without affect, it comes into
   play if plugins built by different compilers are used,
   __cdecl is most standard.                                     */
#define DEADSTART_CALLTYPE CPROC
#  if defined( _TYPELIBRARY_SOURCE_STEAL )
#    define DEADSTART_PROC extern
#  elif defined( _TYPELIBRARY_SOURCE )
#    define DEADSTART_PROC EXPORT_METHOD
#  else
/* A definition for how to declare these functions. if the
   source itself is comipling these are _export, otherwise
   external things linking here are _import.               */
#    define DEADSTART_PROC IMPORT_METHOD
#  endif
   /* this is just a global space initializer (shared, named
      region, allows static link plugins to share information)
      Allocates its shared memory global region, so if this library
      is built statically and referenced in multiple plugins
      ConfigScript can share the same symbol tables. This also
      provides sharing between C++ and C.                           */
#define CONFIG_SCRIPT_PRELOAD_PRIORITY    (SQL_PRELOAD_PRIORITY-3)
   // this is just a global space initializer (shared, named region, allows static link plugins to share information)
#define SQL_PRELOAD_PRIORITY    (SYSLOG_PRELOAD_PRIORITY-1)
/* Level at which logging is initialized. Nothing under this
   should be doing logging, if it does, the behavior is not as
   well defined.                                               */
#define SYSLOG_PRELOAD_PRIORITY 35
   // global_init_preload_priority-1 is used by sharemem.. memory needs init before it can register itself
#define GLOBAL_INIT_PRELOAD_PRIORITY 37
 // OS A[bstraction] L[ayer] O[n] T[op] - system lib
#define OSALOT_PRELOAD_PRIORITY (CONFIG_SCRIPT_PRELOAD_PRIORITY-1)
/* Level which names initializes. Names is the process
   registration code. It has a common shared global registered.
   <link sack::app::registry, procreg; aka names.c>             */
#define NAMESPACE_PRELOAD_PRIORITY 39
/* image_preload MUST be after Namespce preload (anything that
   uses RegisterAndCreateGlobal) should init this before vidlib
   (which needs image?)                                         */
#define IMAGE_PRELOAD_PRIORITY  45
/* Level at which the video render library performs its
   initialization; RegisterClass() level code.          */
#define VIDLIB_PRELOAD_PRIORITY 46
/* Initialization level where PSI registers its builtin
   controls.                                            */
#define PSI_PRELOAD_PRIORITY    47
// need to open the queues and threads before the service server can begin...
#define MESSAGE_CLIENT_PRELOAD_PRIORITY 65
/* Level which message core service initializes. During startup
   message services can register themselves also; but not before
   this priority level.                                          */
#define MESSAGE_SERVICE_PRELOAD_PRIORITY 66
/* Routines are scheduled at this priority when the PRELOAD
   function is used.                                        */
#define DEFAULT_PRELOAD_PRIORITY (DEADSTART_PRELOAD_PRIORITY-1)
/* Not sure where this is referenced, this the core routine
   itself is scheduled with this symbol to the compiler if
   appropriate.                                             */
#define DEADSTART_PRELOAD_PRIORITY 70
#define PRIORITY_UNLOAD(proc,priority) PRIORITY_ATEXIT( proc##_unload, priority )
/* Used by PRELOAD and PRIORITY_PRELOAD macros to register a
   startup routine at a specific priority. Lower number
   priorities are scheduled to run before higher number
   priorities*backwards from ATEXIT priorities*. Using this
   scheduling mechanisms, routines which create threads under
   windows are guaranteed to run before main, and are guaranteed
   able to create threads. (They are outside of the loader lock)
   Parameters
   function :  pointer to a function to call at startup.
   name :      text name of the function
   priority :  priority at which to call the function.
   unused :    this is an unused parameter. The macros fill it
               with &amp;ThisRegisteringRoutine, so that the
               routine itself is referenced by code, and helps
               the compile not optimize out this code. The
               functions which perform the registration are prone
               to be optimized because it's hard for the compiler
               to identify that they are refernced by other names
               indirectly.
   file\ :     usually DBG_PASS of the code doing this
               registration.
   line :      usually DBG_PASS of the code doing this
               registration.                                      */
DEADSTART_PROC  void DEADSTART_CALLTYPE  RegisterPriorityStartupProc( void(CPROC*)(void), CTEXTSTR,int,void* unused DBG_PASS);
/* Used by ATEXIT and PRIORITY_ATEXIT macros to register a
   shutdown routine at a specific priority. Higher number
   priorities are scheduled to run before lower number
   priorities. *backwards from PRELOAD priorities* This
   registers functions which are run while the program exits if
   it is at all able to run when exiting. calling exit() or
   BAG_Exit() will invoke these.
   Parameters
   function :  pointer to a function to call at shutdown.
   name :      text name of the function
   priority :  priority at which to call the function.
   unused :    this is an unused parameter. The macros fill it
               with &amp;ThisRegisteringRoutine, so that the
               routine itself is referenced by code, and helps
               the compile not optimize out this code. The
               functions which perform the registration are prone
               to be optimized because it's hard for the compiler
               to identify that they are refernced by other names
               indirectly.
   file\ :     usually DBG_PASS of the code doing this
               registration.
   line :      usually DBG_PASS of the code doing this
               registration.                                      */
DEADSTART_PROC  void DEADSTART_CALLTYPE  RegisterPriorityShutdownProc( void(CPROC*)(void), CTEXTSTR,int,void* unused DBG_PASS);
/* This routine is used internally when LoadFunction is called.
   After MarkDeadstartComplete is called, any call to a
   RegisterPriorityStartupProc will call the startup routine
   immediately instead of waiting. This function disables the
   auto-running of this function, and instead enques the startup
   to the list of startups. When completed, at some later point,
   call ResumeDeadstart() to dispatched all scheduled routines,
   and release the suspend; however, if initial deastart was not
   dispatched, then ResumeDeadstart does not do the invoke, it
   only releases the suspend.                                    */
DEADSTART_PROC  void DEADSTART_CALLTYPE  SuspendDeadstart ( void );
/* Resumes a suspended deadstart. If root deadstart is
   completed, then ResumeDeadstart will call InvokeDeadstarts
   after resuming deadstart.                                  */
DEADSTART_PROC  void DEADSTART_CALLTYPE  ResumeDeadstart ( void );
/* Not usually used by user code, but this invokes all the
   routines which have been scheduled to run for startup. If
   your compiler doesn't have a method of handling deadstart
   code, this can be manually called. It can also be called if
   you loaded a library yourself without using the LoadFunction
   interface, to invoke startups scheduled in the loaded
   library.                                                     */
DEADSTART_PROC  void DEADSTART_CALLTYPE  InvokeDeadstart (void);
/* This just calls the list of shutdown procedures. This should
   not be used usually from user code, since internally this is
   handled by catching atexit() or with a static destructor.    */
DEADSTART_PROC  void DEADSTART_CALLTYPE  InvokeExits (void);
/* This is typically called after the first InvokeDeadstarts
   completes. The code that runs this is usually a routine just
   before main(). So once code in main begins to run, all prior
   initialization has been performed.                           */
DEADSTART_PROC  void DEADSTART_CALLTYPE  MarkRootDeadstartComplete ( void );
/* \returns whether InvokeDeadstarts has been called. */
DEADSTART_PROC  LOGICAL DEADSTART_CALLTYPE  IsRootDeadstartStarted ( void );
/* \returns whether MarkRootDeadstartComplete has been called. */
DEADSTART_PROC  LOGICAL DEADSTART_CALLTYPE  IsRootDeadstartComplete ( void );
#if defined( __LINUX__ )
// call this after a fork().  Otherwise, it will falsely invoke shutdown when it exits.
DEADSTART_PROC  void DEADSTART_CALLTYPE  DispelDeadstart ( void );
#endif
#ifdef DOC_O_MAT
// call this after a fork().  Otherwise, it will falsely invoke shutdown when it exits.
DEADSTART_PROC  void DEADSTART_CALLTYPE  DispelDeadstart ( void );
#endif
#ifdef __cplusplus
/* Defines some code to run at program inialization time. Allows
   specification of a priority. Lower priorities run first. (default
   is 69).
   Example
   <code>
   PRIORITY_PRELOAD( MyOtherInit, 153 )
   {
      // run some code probably after most all other initializtion is done.
   }
   </code>
   See Also
   <link sack::app::deadstart, deadstart Namespace>                         */
#define PRIORITY_PRELOAD(name,priority) static void CPROC name(void);    static class pastejunk(schedule_,name) {        public:pastejunk(schedule_,name)() {	    RegisterPriorityStartupProc( name,TOSTR(name),priority,(void*)this DBG_SRC);	  }	  } pastejunk(do_schedule_,name);	     static void name(void)
/* This is used once in deadstart_prog.c which is used to invoke
   startups when the program finishes loading.                   */
#define MAGIC_PRIORITY_PRELOAD(name,priority) static void CPROC name(void);    static class pastejunk(schedule_,name) {	     public:pastejunk(schedule_,name)() {	  name();	    }	  } pastejunk(do_schedul_,name);	     static void name(void)
/* A macro to define some code to run during program shutdown. An
   additional priority may be specified if the order matters. Higher
   numbers are called first.
                                                                     */
#define ATEXIT_PRIORITY(name,priority) static void CPROC name(void);    static class pastejunk(schedule_,name) {        public:pastejunk(schedule_,name)() {	    RegisterPriorityShutdownProc( name,TOSTR(name),priority,(void*)this DBG_SRC );	  }	  } pastejunk(do_schedule_,name);	     static void name(void)
/* Defines some code to run at program shutdown time. Allows
   specification of a priority. Higher priorities are run first.
   Example
   <code>
   PRIORITY_ATEXIT( MyOtherShutdown, 153 )
   {
      // run some code probably before most library code dissolves.
      // last to load, first to unload.
   }
   </code>
   See Also
   <link sack::app::deadstart, deadstart Namespace>                 */
	/*name(); / * call on destructor of static object.*/
#define PRIORITY_ATEXIT(name,priority) static void CPROC name(void);    static class pastejunk(shutdown_,name) {	   public:pastejunk(shutdown_,name)() {       RegisterPriorityShutdownProc( name,TOSTR(name),priority,(void*)this DBG_SRC );	   }	  } do_shutdown_##name;	     void name(void)
/* This is the most basic way to define some code to run
   initialization before main.
   Example
   <code lang="c++">
   PRELOAD( MyInitCode )
   {
      // some code here
   }
   </code>
   See Also
   <link sack::app::deadstart, deadstart Namespace>      */
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
/* Basic way to register a routine to run when the program exits
   gracefully.
   Example
   \    <code>
   ATEXIT( MyExitRoutine )
   {
       // this will be run sometime during program shutdown
   }
   </code>                                                       */
#define ATEXIT(name)      PRIORITY_ATEXIT(name,ATEXIT_PRIORITY_DEFAULT)
/* This is the core atexit. It dispatches all other exit
   routines. This is defined for internal use only...    */
#define ROOT_ATEXIT(name) ATEXIT_PRIORITY(name,ATEXIT_PRIORITY_ROOT)
//------------------------------------------------------------------------------------
// Win32 Watcom
//------------------------------------------------------------------------------------
#elif defined( __WATCOMC__ )
#pragma off (check_stack)
/* code taken from openwatcom/bld/watcom/h/rtinit.h */
typedef unsigned char   __type_rtp;
typedef unsigned short  __type_pad;
typedef void(*__type_rtn ) ( void );
#ifdef __cplusplus
#pragma pack(1)
#else
#pragma pack(1)
#endif
 // structure placed in XI/YI segment
struct rt_init
{
#define DEADSTART_RT_LIST_START 0xFF
 // - near=0/far=1 routine indication
    __type_rtp  rtn_type;
                          //   also used when walking table to flag
                          //   completed entries
 // - priority (0-highest 255-lowest)
    __type_rtp  priority;
      // - routine
    __type_rtn  rtn;
};
#pragma pack()
/* end code taken from openwatcom/bld/watcom/h/rtinit.h */
//------------------------------------------------------------------------------------
// watcom
//------------------------------------------------------------------------------------
//void RegisterStartupProc( void (*proc)(void) );
#define PRIORITY_PRELOAD(name,priority) static void pastejunk(schedule_,name)(void); static void CPROC name(void);	 static struct rt_init __based(__segname("XI")) pastejunk(name,_ctor_label)={0,(DEADSTART_PRELOAD_PRIORITY-1),pastejunk(schedule_,name)};	 static void pastejunk(schedule_,name)(void) {	                 RegisterPriorityStartupProc( name,TOSTR(name),priority,&pastejunk(name,_ctor_label) DBG_SRC );	}	                                       void name(void)
#define ATEXIT_PRIORITY(name,priority) static void pastejunk(schedule_exit_,name)(void); static void CPROC name(void);	 static struct rt_init __based(__segname("XI")) pastejunk(name,_dtor_label)={0,69,pastejunk(schedule_exit_,name)};	 static void pastejunk(schedule_exit_,name)(void) {	                                              RegisterPriorityShutdownProc( name,TOSTR(name),priority,&name##_dtor_label DBG_SRC );	}	                                       void name(void)
// syslog runs preload at priority 65
// message service runs preload priority 66
// deadstart itself tries to run at priority 70 (after all others have registered)
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
// this is a special case macro used in client.c
// perhaps all PRIORITY_ATEXIT routines should use this
// this enables cleaning up things that require threads to be
// active under windows... (message disconnect)
// however this routine is only triggered in windows by calling
// BAG_Exit(nn) which is aliased to replace exit(n) automatically
#define PRIORITY_ATEXIT(name,priority) ATEXIT_PRIORITY( name,priority)
/*
static void name(void); static void name##_x_(void);	static struct rt_init __based(__segname("YI")) name##_dtor_label={0,priority,name##_x_};	 static void name##_x_(void) { char myname[256];myname[0]=*(CTEXTSTR)&name##_dtor_label;GetModuleFileName(NULL,myname,sizeof(myname));name(); }	 static void name(void)
  */
#define ROOT_ATEXIT(name) ATEXIT_PRIORITY(name,ATEXIT_PRIORITY_ROOT)
#define ATEXIT(name)      PRIORITY_ATEXIT(name,ATEXIT_PRIORITY_DEFAULT)
// if priority_atexit is used with priority 0 - the proc is scheduled into
// atexit, and exit() is then invoked.
//#define PRIORITY_ATEXIT(name,priority) ATEXIT_PRIORITY(name,priority )
//------------------------------------------------------------------------------------
// Linux
//------------------------------------------------------------------------------------
#elif defined( __GNUC__ )
/* code taken from openwatcom/bld/watcom/h/rtinit.h */
typedef unsigned char   __type_rtp;
typedef void(*__type_rtn ) ( void );
 // structure placed in XI/YI segment
struct rt_init
{
#define DEADSTART_RT_LIST_START 0xFF
 // - near=0/far=1 routine indication
    __type_rtp  rtn_type;
                          //   also used when walking table to flag
                          //   completed entries
 // has this been scheduled? (0 if no)
    __type_rtp  scheduled;
 // - priority (0-highest 255-lowest)
    __type_rtp  priority;
#if defined( __64__ ) ||defined( __arm__ )||defined( __GNUC__ )
#define INIT_PADDING ,{0}
 // need this otherwise it's 23 bytes and that'll be bad.
	 char padding[1];
#else
#define INIT_PADDING
#endif
 // 32 bits in 64 bits....
	 int line;
// this ends up being nicely aligned for 64 bit platforms
// specially with the packed attributes
      // - routine (rtn)
	 __type_rtn  routine;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
	 CTEXTSTR file;
#endif
	 CTEXTSTR funcname;
	 struct rt_init *junk;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
#if defined( __GNUC__ ) && defined( __64__)
    // this provides padding - inter-object segments are packed
    // to 32 bytes...
	 struct rt_init *junk2[3];
#endif
#endif
} __attribute__((packed));
#define JUNKINIT(name) ,&pastejunk(name,_ctor_label)
#define RTINIT_STATIC static
#define ATEXIT_PRIORITY PRIORITY_ATEXIT
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
#  define PASS_FILENAME ,WIDE__FILE__
#else
#  define PASS_FILENAME
#endif
#ifdef __MAC__
#  define DEADSTART_SECTION "TEXT,deadstart_list"
#else
#  define DEADSTART_SECTION "deadstart_list"
#endif
#define PRIORITY_PRELOAD(name,pr) static void name(void);	 RTINIT_STATIC struct rt_init pastejunk(name,_ctor_label)	   __attribute__((section(DEADSTART_SECTION))) __attribute__((used))	 ={0,0,pr INIT_PADDING	     ,__LINE__,name	          PASS_FILENAME	        ,TOSTR(name)	        JUNKINIT(name)};	 void name(void) __attribute__((used));	  void name(void)
typedef void(*atexit_priority_proc)(void (*)(void),CTEXTSTR,int DBG_PASS);
#define PRIORITY_ATEXIT(name,priority) static void name(void); static void pastejunk(atexit,name)(void) __attribute__((constructor));  void pastejunk(atexit,name)(void)                                                  {	                                                                        RegisterPriorityShutdownProc(name,TOSTR(name),priority,NULL DBG_SRC);                          }                                                                          void name(void)
#define ATEXIT(name) PRIORITY_ATEXIT( name,ATEXIT_PRIORITY_DEFAULT )
#define ROOT_ATEXIT(name) static void name(void) __attribute__((destructor));    static void name(void)
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
//------------------------------------------------------------------------------------
// CYGWIN (-mno-cygwin)
//------------------------------------------------------------------------------------
#elif defined( __CYGWIN__ )
/* code taken from openwatcom/bld/watcom/h/rtinit.h */
typedef unsigned char   __type_rtp;
typedef void(*__type_rtn ) ( void );
 // structure placed in XI/YI segment
struct rt_init
{
#ifdef __cplusplus
	//rt_init( int _rtn_type ) { rt_init::rtn_type = _rtn_type; }
	/*rt_init( int _priority, CTEXTSTR name, __type_rtn rtn, CTEXTSTR _file, int _line )
	{
		rtn_type = 0;
		scheduled = 0;
		priority = priority;
		file = _file;
		line = _line;
      routine = rtn;
		}
      */
#endif
#define DEADSTART_RT_LIST_START 0xFF
 // - near=0/far=1 routine indication
    __type_rtp  rtn_type;
                          //   also used when walking table to flag
                          //   completed entries
 // has this been scheduled? (0 if no)
    __type_rtp  scheduled;
 // - priority (0-highest 255-lowest)
    __type_rtp  priority;
#if defined( __GNUC__ ) || defined( __64__ ) || defined( __arm__ ) || defined( __CYGWIN__ )
#define INIT_PADDING ,{0}
 // need this otherwise it's 23 bytes and that'll be bad.
	 char padding[1];
#else
#define INIT_PADDING
#endif
 // 32 bits in 64 bits....
	 int line;
// this ends up being nicely aligned for 64 bit platforms
// specially with the packed attributes
      // - routine (rtn)
	 __type_rtn  routine;
	 CTEXTSTR file;
	 CTEXTSTR funcname;
	 struct rt_init *junk;
#if defined( __GNUC__ ) && defined( __64__ )
    // this provides padding - inter-object segments are packed
    // to 32 bytes...
	 struct rt_init *junk2[3];
#endif
} __attribute__((packed));
#define JUNKINIT(name) ,&pastejunk(name,_ctor_label)
#ifdef __cplusplus
#define RTINIT_STATIC
#else
#define RTINIT_STATIC static
#endif
typedef void(*atexit_priority_proc)(void (*)(void),CTEXTSTR,int DBG_PASS);
#define ATEXIT_PRIORITY(name,priority) static void name(void); static void atexit##name(void) __attribute__((constructor));	  void atexit_failed##name(void(*f)(void),int i,CTEXTSTR s1,CTEXTSTR s2,int n) { lprintf( WIDE("Failed to load atexit_priority registerar from core program.") );} void atexit##name(void)                                                  {	                                                                        static char myname[256];HMODULE mod;if(myname[0])return;myname[0]='a';GetModuleFileName( NULL, myname, sizeof( myname ) );	mod=LoadLibrary(myname);if(mod){   typedef void (*x)(void);void(*rsp)( x,const CTEXTSTR,int,const CTEXTSTR,int);	 if((rsp=((void(*)(void(*)(void),const CTEXTSTR,int,const CTEXTSTR,int))(GetProcAddress( mod, WIDE("RegisterPriorityShutdownProc"))))))	 {rsp( name,TOSTR(name),priority DBG_SRC);}	 else atexit_failed##name(name,priority,TOSTR(name) DBG_SRC);	        }     FreeLibrary( mod);	 }             void name( void)
#ifdef _DEBUG
#  define PASS_FILENAME ,WIDE__FILE__
#else
#  define PASS_FILENAME
#endif
#define PRIORITY_PRELOAD(name,pr) static void name(void);	 RTINIT_STATIC struct pastejunk(rt_init name,_ctor_label)	   __attribute__((section("deadstart_list")))	 ={0,0,pr INIT_PADDING	     ,__LINE__,name	          PASS_FILENAME	        ,TOSTR(name)	        JUNKINIT(name)};	 static void name(void)
#define ATEXIT(name)      ATEXIT_PRIORITY(name,ATEXIT_PRIORITY_DEFAULT)
#define PRIORITY_ATEXIT ATEXIT_PRIORITY
#define ROOT_ATEXIT(name) static void name(void) __attribute__((destructor));    static void name(void)
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
//------------------------------------------------------------------------------------
// WIN32 MSVC
//------------------------------------------------------------------------------------
#elif defined( _MSC_VER ) && defined( _WIN32 )
//#define PRELOAD(name) __declspec(allocate(".CRT$XCAA")) void CPROC name(void)
//#pragma section(".CRT$XCA",long,read)
//#pragma section(".CRT$XCZ",long,read)
// put init in both C startup and C++ startup list...
// looks like only one or the other is invoked, not both?
/////// also the variables to be put into these segments
#if defined( __cplusplus_cli )
#define LOG_ERROR(n) System::Console::WriteLine( gcnew System::String(n) + gcnew System::String( myname) ) )
#else
#define LOG_ERROR(n) SystemLog( n )
// since we get linked first, then the runtime is added, we have to link against the last indicator of section,
// so we get put between start to end.
#define _STARTSEG_ ".CRT$XIM"
#define _STARTSEG2_ ".CRT$XCY"
#define _ENDSEG_ ".CRT$XTM"
//#pragma data_seg(".CRT$XIA")
#pragma data_seg(".CRT$XIM")
#pragma section(".CRT$XIM",long,read)
#pragma data_seg(".CRT$XCY")
#pragma section(".CRT$XCY",long,read)
//#pragma data_seg(".CRT$XIZ")
//#pragma data_seg(".CRT$YCZ")
#pragma data_seg(".CRT$XTM")
#pragma section(".CRT$XTM",long,read)
#pragma data_seg()
	                                       /*static __declspec(allocate(_STARTSEG_)) void (CPROC*pointer_##name)(void) = pastejunk(schedule_,name);*/
#define PRIORITY_PRELOAD(name,priority) static void CPROC name(void);    static int CPROC pastejunk(schedule_,name)(void);	   __declspec(allocate(_STARTSEG_)) int (CPROC*pastejunk(TARGET_LABEL,pastejunk( pastejunk(x_,name),__LINE__)))(void) = pastejunk(schedule_,name);	 int CPROC pastejunk(schedule_,name)(void) {	                 RegisterPriorityStartupProc( name,TOSTR(name),priority,pastejunk(TARGET_LABEL,pastejunk( pastejunk(x_,name),__LINE__)) DBG_SRC );	return 0;	 }	 static void CPROC name(void)
#define ROOT_ATEXIT(name) static void name(void);	 __declspec(allocate(_ENDSEG_)) static void (*f##name)(void)=name;    static void name(void)
#define ATEXIT(name) PRIORITY_ATEXIT(name,ATEXIT_PRIORITY_DEFAULT)
typedef void(*atexit_priority_proc)(void (*)(void),int,CTEXTSTR DBG_PASS);
#define PRIORITY_ATEXIT(name,priority) static void CPROC name(void);    static int schedule_atexit_##name(void);	   __declspec(allocate(_STARTSEG_)) void (CPROC*pastejunk(TARGET_LABEL,pastejunk( x_##name,__LINE__)))(void) = (void(CPROC*)(void))schedule_atexit_##name;	 static int schedule_atexit_##name(void) {	                 RegisterPriorityShutdownProc( name,TOSTR(name),priority,pastejunk(TARGET_LABEL,pastejunk( x_##name,__LINE__)) DBG_SRC );	return 0;	 }	                                       static void CPROC name(void)
#define ATEXIT_PRIORITY(name,priority) PRIORITY_ATEXIT(name,priority)
#endif
#ifdef __cplusplus_cli
#define InvokeDeadstart() do {	                                              TEXTCHAR myname[256];HMODULE mod;	 mod=LoadLibrary("sack_bag.dll");if(mod){           void(*rsp)(void);	 if((rsp=((void(*)(void))(GetProcAddress( mod, "RunDeadstart"))))){rsp();}else{lprintf( WIDE("Hey failed to get proc %d"), GetLastError() );}	FreeLibrary( mod); }} while(0)
#else
#endif
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
//extern uint32_t deadstart_complete;
//#define DEADSTART_LINK uint32_t *deadstart_link_couple = &deadstart_complete; // make sure we reference this symbol
//#pragma data_seg(".CRT$XCAA")
//extern void __cdecl __security_init_cookie(void);
//static _CRTALLOC(".CRT$XCAA") _PVFV init_cookie = __security_init_cookie;
//#pragma data_seg()
//------------------------------------------------------------------------------------
// UNDEFINED
//------------------------------------------------------------------------------------
#else
#error "there's nothing I can do to wrap PRELOAD() or ATEXIT()!"
/* This is the most basic way to define some startup code that
   runs at some point before the program starts. This code is
   declared as static, so the same preload initialization name
   can be used in multiple files.
   <link sack::app::deadstart, See Also.>                      */
#define PRELOAD(name)
#endif
// the higher the number the earlier it is run
#define ATEXIT_PRIORITY_SHAREMEM  1
#define ATEXIT_PRIORITY_THREAD_SEMS ATEXIT_PRIORITY_SYSLOG-1
#define ATEXIT_PRIORITY_SYSLOG    35
#define ATEXIT_PRIORITY_MSGCLIENT 85
#define ATEXIT_PRIORITY_DEFAULT   90
#define ATEXIT_PRIORITY_TIMERS   (ATEXIT_PRIORITY_DEFAULT+1)
// this is the first exit to be run.
// under linux it is __attribute__((destructor))
// under all it is registered during preload as atexit()
// only the runexits in deadstart should use ROOT_ATEXIT
#ifdef __WATCOMC__
#define ATEXIT_PRIORITY_ROOT 255
#else
#define ATEXIT_PRIORITY_ROOT 101
#endif
SACK_DEADSTART_NAMESPACE_END
USE_SACK_DEADSTART_NAMESPACE
#endif
#ifdef PROCREG_SOURCE
#define PROCREG_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define PROCREG_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
#ifdef __cplusplus_cli
//using namespace System;
#endif
#   define _INTERFACE_NAMESPACE namespace Interface {
#   define _INTERFACE_NAMESPACE_END }
#define PROCREG_NAMESPACE namespace sack { namespace app { namespace registry {
#define _PROCREG_NAMESPACE namespace registry {
#define _APP_NAMESPACE namespace app {
#define PROCREG_NAMESPACE_END }}}
//extern "C"  {
#else
#   define _INTERFACE_NAMESPACE
#   define _INTERFACE_NAMESPACE_END
#define _PROCREG_NAMESPACE
#define _APP_NAMESPACE
#define PROCREG_NAMESPACE
#define PROCREG_NAMESPACE_END
#endif
SACK_NAMESPACE
/* Deadstart is support which differs per compiler, but allows
   applications access a C++ feature - static classes with
   constructors that initialize at loadtime, but, have the
   feature that you can create threads. Deadstart code is run
   after the DLL load lock under windows that prevents creation
   of threads; however, deadstart is run before main. Deadstart
   routines can have a priority. Certain features require others
   to be present always. This allows explicit control of
   priority unlink using classes with static constructors, which
   requires ordering of objects to provide linking order. Also
   provides a similar registration mechanism for atexit, but
   extending with priority. Deadstop registrations are done
   sometime during normal C atexit() handling, but may be
   triggered first by calling BAG_Exit.
   Registry offers support to register functions, and data under
   a hierarchy of names. Names are kept in a string cache, which
   applications can take benefit of. Strings will exist only a
   single time. This table could be saved, and a look-aside
   table for language translation purposes. Registry is the
   support that the latest PSI relies on for registering event
   callbacks for controls. The registry was always used, but,
   the access to it was encapsulated by DoRegisterControl
   registering the appropriate methods.                          */
	_APP_NAMESPACE
   /* Contains methods dealing with registering routines and values
      in memory. Provisions are available to save the configuration
      state, but the best that can be offered here would be a
      translation tool for text strings. The namespace is savable,
      but most of the content of the registration space are short
      term pointers. Namespace containing registry namespace.
      old notes - very discongruant probably should delete them.
      Process name registry
      it's a tree of names.
      there are paths, and entries
      paths are represented as class_name
      PCLASSROOT is also a suitable class name
      PCLASSROOT is defined as a valid CTEXTSTR.
      there is (apparently) a name that is not valid as a path name
      that is TREE
      guess.
      POINTER in these two are equal to (void(*)(void)) but -
      that's rarely the most useful thing... so
      name class is a tree of keys... /\<...\>
      psi/control/## might contain procs Init Destroy Move
      RegAlias( WIDE("psi/control/3"), WIDE("psi/control/button")
      ); psi/control/button and psi/control/3 might reference the
      same routines
      psi/frame Init Destroy Move memlib Alloc Free
      network/tcp
      I guess name class trees are somewhat shallow at the moment
      not going beyond 1-3 layers
      names may eventually be registered and reference out of body
      services, even out of box...
      the values passed as returntype and parms/args need not be
      real genuine types, but do need to be consistant between the
      registrant and the requestor... this provides for full name
      dressing, return type and paramter type may both cause
      overridden functions to occur...                              */
_PROCREG_NAMESPACE
#ifndef REGISTRY_STRUCTURE_DEFINED
	// make these a CTEXTSTR to be compatible with name_class...
#ifdef __cplusplus
	// because of name mangling and stronger type casting
	// it becomes difficult to pass a tree_def_tag * as a CTEXTSTR classname
	// as valid as this is.
	typedef struct tree_def_tag const * PCLASSROOT;
#else
	typedef CTEXTSTR PCLASSROOT;
#endif
	typedef void (CPROC *PROCEDURE)(void);
#ifdef __cplusplus_cli
	typedef void (__stdcall *STDPROCEDURE)(array<System::Object^>^);
#endif
#else
	typedef struct tree_def_tag const * PCLASSROOT;
	typedef void (CPROC *PROCEDURE)(void);
#ifdef __cplusplus_cli
	typedef void (__stdcall *STDPROCEDURE)(array<System::Object^>^);
#endif
#endif
/* CheckClassRoot reads for a path of names, but does not create
   it if it does not exist.                                      */
PROCREG_PROC( PCLASSROOT, CheckClassRoot )( CTEXTSTR class_name );
/* \Returns a PCLASSROOT of a specified path. The path may be
   either a PCLASSROOT or a text string indicating the path. the
   Ex versions allow passing a base PCLASSROOT path and an
   additional subpath to get. GetClassRoot will always create
   the path if it did not exist before, and will always result
   with a root.
   Remarks
   a CTEXTSTR (plain text string, probably wide character if
   compiled unicode) and a PCLASSROOT are always
   interchangeable. Though you may need a forced type cast, I
   have defined both CTEXTSTR and PCLASSROOT function overloads
   for c++ compiled code, and C isn't so unkind about the
   conversion. I think problem might lie that CTEXTSTR has a
   const qualifier and PCLASSROOT doesn't (but should).
   Example
   <code lang="c++">
   PCLASSROOT root = GetClassRoot( "psi/resource" );
   // returns the root of all resource names.
   </code>
   <code>
   PCLASSROOT root2 = GetClassRootEx( "psi/resource", "buttons" );
   </code>                                                         */
PROCREG_PROC( PCLASSROOT, GetClassRoot )( CTEXTSTR class_name );
/* <combine sack::app::registry::GetClassRoot@CTEXTSTR>
   \ \                                                  */
PROCREG_PROC( PCLASSROOT, GetClassRootEx )( PCLASSROOT root, CTEXTSTR name_class );
#ifdef __cplusplus
/* <combine sack::app::registry::GetClassRoot@CTEXTSTR>
   \ \                                                  */
PROCREG_PROC( PCLASSROOT, GetClassRoot )( PCLASSROOT class_name );
/* <combine sack::app::registry::GetClassRoot@CTEXTSTR>
   \ \                                                  */
PROCREG_PROC( PCLASSROOT, GetClassRootEx )( PCLASSROOT root, PCLASSROOT name_class );
#endif
/* Fills a string with the path name to the specified node */
PROCREG_PROC( int, GetClassPath )( TEXTSTR out, size_t len, PCLASSROOT root );
PROCREG_PROC( void, SetInterfaceConfigFile )( TEXTCHAR *filename );
/* Get[First/Next]RegisteredName( WIDE("classname"), &amp;data );
   these operations are not threadsafe and multiple thread
   accesses will cause mis-stepping
   These functions as passed the address of a POINTER. this
   POINTER is for the use of the browse routines and should is
   meaningless to he calling application.
   Parameters
   root :       The root to search from
   classname :  A sub\-path from the root to search from
   data :       the address of a pointer that keeps track of
                information about the search. (opaque to user)
   Example
   Usage:
   <code lang="c++">
   CTEXTSTR result;
   POINTER data = NULL;
   for( result = GetFirstRegisteredName( "some/class/path", &amp;data );
        \result;
        \result = GetNextRegisteredName( &amp;data ) )
   {
        // result is a string name of the current node.
        // can use that name and GetRegistered____ (function/int/value)
        if( NameHasBranches( &amp;data ) ) // for consitancy in syntax
        {
            // consider recursing through tree, name becomes a valid classname for GetFirstRegisteredName()
        }
   }
   </code>                                                                                                  */
PROCREG_PROC( CTEXTSTR, GetFirstRegisteredNameEx )( PCLASSROOT root, CTEXTSTR classname, PCLASSROOT *data );
#ifdef __cplusplus
/* <combine sack::app::registry::GetFirstRegisteredNameEx@PCLASSROOT@CTEXTSTR@PCLASSROOT *>
   \ \                                                                                      */
	PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( PCLASSROOT classname, PCLASSROOT *data );
#endif
/* <combine sack::app::registry::GetFirstRegisteredNameEx@PCLASSROOT@CTEXTSTR@PCLASSROOT *>
   \ \                                                                                      */
PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( CTEXTSTR classname, PCLASSROOT *data );
/* Steps to the next registered name being browsed. Is passed
   only the pointer to data. See GetFirstRegisteredName for
   usage.
   See Also
   <link sack::app::registry::GetFirstRegisteredNameEx@PCLASSROOT@CTEXTSTR@PCLASSROOT *, sack::app::registry::GetFirstRegisteredNameEx Function> */
PROCREG_PROC( CTEXTSTR, GetNextRegisteredName )( PCLASSROOT *data );
/* When using GetFirstRegisteredName and GetNextRegisteredName
   to browse through names, this function is able to get the
   current PCLASSROOT of the current node, usually you end up
   with just the content of that registered name.
   \result with the current node ( useful for pulling registered
   subvalues like description, or file and line )
                                                                 */
PROCREG_PROC( PCLASSROOT, GetCurrentRegisteredTree )( PCLASSROOT *data );
#ifdef __cplusplus
//PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( CTEXTSTR classname, POINTER *data );
//PROCREG_PROC( CTEXTSTR, GetNextRegisteredName )( POINTER *data );
#endif
// while doing a scan for registered procedures, allow applications to check for branches
//PROCREG_PROC( int, NameHasBranches )( POINTER *data );
PROCREG_PROC( int, NameHasBranches )( PCLASSROOT *data );
// while doing a scan for registered procedures, allow applications to ignore aliases...
PROCREG_PROC( int, NameIsAlias )( PCLASSROOT *data );
/*
 * RegisterProcedureExx(
 *
 */
 // root name or PCLASSROOT of base path
PROCREG_PROC( int, RegisterProcedureExx )( PCLASSROOT root
 // an additional path on root
													  , CTEXTSTR name_class
 // the name of the value entry saved in the tree
													  , CTEXTSTR public_name
 // the text return type of this function - may be checked to validate during GetRegisteredProcedure
													  , CTEXTSTR returntype
 // name of the library this symbol is in - may be checked to validate during GetRegisteredProcedure
													  , CTEXTSTR library
 // actual C function name in library - may be checked to validate during GetRegisteredProcedure
													  , CTEXTSTR name
 // preferably the raw argument string of types and no variable references "([type][,type]...)"
													  , CTEXTSTR args
 // file and line of the calling application.  May be no parameter in release mode.
													  DBG_PASS
													  );
/*
 * RegisterProcedureEx( root       // root path
 *                    , name_class // additional name
 *                    , nice_name  // nice name
 *                    , return type not in quotes  'void'
 *                    , function_name in quotes '"Function"'
 *                    , args not in quotes '(int,char,float,UserType*)'
 */
#define RegisterProcedureEx(root,nc,n,rtype,proc,args)  RegisterProcedureExx( (root),(nc),(n),#rtype,TARGETNAME,(proc), #args DBG_SRC)
/*
 * RegisterProcedure( name_class // additional name
 *                    , nice_name  // nice name
 *                    , return type not in quotes  'void'
 *                    , function_name in quotes '"Function"'
 *                    , args not in quotes '(int,char,float,UserType*)'
 */
#define RegisterProcedure(nc,n,rtype,proc,args)  RegisterProcedureExx( NULL, (nc),(n),#rtype,TARGETNAME,(proc), #args DBG_SRC)
/*
 * Branches on the tree may be aliased together to form a single branch
 *
 */
				// RegisterClassAlias( WIDE("psi/control/button"), WIDE("psi/control/3") );
				// then the same set of values can be referenced both ways with
				// really only a single modified value.
/* parameters to RegisterClassAliasEx are the original name, and the new alias name for the origianl branch*/
PROCREG_PROC( PCLASSROOT, RegisterClassAliasEx )( PCLASSROOT root, CTEXTSTR original, CTEXTSTR alias );
/* <combine sack::app::registry::RegisterClassAliasEx@PCLASSROOT@CTEXTSTR@CTEXTSTR>
   \ \                                                                              */
PROCREG_PROC( PCLASSROOT, RegisterClassAlias )( CTEXTSTR original, CTEXTSTR newalias );
// root, return, public, args, address
PROCREG_PROC( PROCEDURE, ReadRegisteredProcedureEx )( PCLASSROOT root
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR parms
																  );
#define ReadRegisteredProcedure( root,rt,a) ((rt(CPROC*)a)ReadRegisteredProcedureEx(root,WIDE(#rt),WIDE(#a)))
/* Gets a function that has been registered. */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( PCLASSROOT root
																	 , PCLASSROOT name_class
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR name
																	 , CTEXTSTR parms
																	 );
#define GetRegisteredProcedureExx(root,nc,rt,n,a) ((rt (CPROC*)a)GetRegisteredProcedureExxx(root,nc,_WIDE(#rt),n,_WIDE(#a)))
#define GetRegisteredProcedure2(nc,rtype,name,args) (rtype (CPROC*)args)GetRegisteredProcedureEx((nc),WIDE(#rtype), name, WIDE(#args) )
#define GetRegisteredProcedureNonCPROC(nc,rtype,name,args) (rtype (*)args)GetRegisteredProcedureEx((nc),WIDE(#rtype), name, WIDE(#args) )
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureEx )( PCLASSROOT name_class
																	, CTEXTSTR returntype
																	, CTEXTSTR name
																	, CTEXTSTR parms
																	);
PROCREG_PROC( LOGICAL, RegisterFunctionExx )( PCLASSROOT root
													, PCLASSROOT name_class
													, CTEXTSTR public_name
													, CTEXTSTR returntype
													, PROCEDURE proc
													 , CTEXTSTR args
													 , CTEXTSTR library
													 , CTEXTSTR real_name
													  DBG_PASS
														  );
#ifdef __cplusplus
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( CTEXTSTR root
																	 , CTEXTSTR name_class
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR name
																	 , CTEXTSTR parms
																	 );
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( CTEXTSTR root
																	 , PCLASSROOT name_class
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR name
																	 , CTEXTSTR parms
																	 );
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( PCLASSROOT root
																	 , CTEXTSTR name_class
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR name
																	 , CTEXTSTR parms
																	 );
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureEx )( CTEXTSTR name_class
																	, CTEXTSTR returntype
																	, CTEXTSTR name
																	, CTEXTSTR parms
																	);
PROCREG_PROC( LOGICAL, RegisterFunctionExx )( CTEXTSTR root
													, CTEXTSTR name_class
													, CTEXTSTR public_name
													, CTEXTSTR returntype
                                       , PROCEDURE proc
													 , CTEXTSTR args
													 , CTEXTSTR library
													 , CTEXTSTR real_name
													  DBG_PASS
														  );
#endif
//#define RegisterFunctionExx( r,nc,p,rt,proc,ar ) RegisterFunctionExx( r,nc,p,rt,proc,ar,TARGETNAME,NULL DBG_SRC )
//#define RegisterFunctionEx(r,nc,pn,rt,proc,args,lib,rn) RegisterFunctionExx(r,nc,pn,rt,proc,args,lib,rn DBG_SRC)
#define RegisterFunctionEx( root,proc,rt,pn,a) RegisterFunctionExx( root,NULL,pn,rt,(PROCEDURE)(proc),a,NULL,NULL DBG_SRC )
#define RegisterFunction( nc,proc,rt,pn,a) RegisterFunctionExx( (PCLASSROOT)NULL,nc,pn,rt,(PROCEDURE)(proc),a,TARGETNAME,NULL DBG_SRC )
#define SimpleRegisterMethod(r,proc,rt,name,args) RegisterFunctionExx(r,NULL,name,rt,(PROCEDURE)proc,args,NULL,NULL DBG_SRC )
#define GetRegisteredProcedure(nc,rtype,name,args) (rtype (CPROC*)args)GetRegisteredProcedureEx((nc),_WIDE(#rtype), _WIDE(#name), _WIDE(#args) )
PROCREG_PROC( int, RegisterIntValueEx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, uintptr_t value );
PROCREG_PROC( int, RegisterIntValue )( CTEXTSTR name_class, CTEXTSTR name, uintptr_t value );
PROCREG_PROC( int, RegisterValueExx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal, CTEXTSTR value );
PROCREG_PROC( int, RegisterValueEx )( CTEXTSTR name_class, CTEXTSTR name, int bIntVal, CTEXTSTR value );
PROCREG_PROC( int, RegisterValue )( CTEXTSTR name_class, CTEXTSTR name, CTEXTSTR value );
/* \ \
   Parameters
   root :        Root class to start searching from
   name_class :  An additional sub\-path to get the name from
   name :        the name within the path specified
   bIntVal :     a true/false whether to get the string or
                 integer value from the specified node.
   Returns
   A pointer to a string if bIntVal is not set. (NULL if there
   was no string).
   Otherwise will be an int shorter than or equal to the size of
   a pointer, which should be cast to an int if bIntVal is set,
   and there is a value registered there. Probably 0 if no
   value, so registered 0 value and no value is
   indistinguisable.                                             */
PROCREG_PROC( CTEXTSTR, GetRegisteredValueExx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal );
/* <combine sack::app::registry::GetRegisteredValueExx@PCLASSROOT@CTEXTSTR@CTEXTSTR@int>
   \ \                                                                                   */
PROCREG_PROC( CTEXTSTR, GetRegisteredValueEx )( CTEXTSTR name_class, CTEXTSTR name, int bIntVal );
/* <combine sack::app::registry::GetRegisteredValueExx@PCLASSROOT@CTEXTSTR@CTEXTSTR@int>
   \ \                                                                                   */
PROCREG_PROC( CTEXTSTR, GetRegisteredValue )( CTEXTSTR name_class, CTEXTSTR name );
#ifdef __cplusplus
/* <combine sack::app::registry::GetRegisteredValueExx@PCLASSROOT@CTEXTSTR@CTEXTSTR@int>
   \ \                                                                                   */
PROCREG_PROC( CTEXTSTR, GetRegisteredValueExx )( CTEXTSTR root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal );
PROCREG_PROC( int, RegisterIntValueEx )( CTEXTSTR root, CTEXTSTR name_class, CTEXTSTR name, uintptr_t value );
#endif
/* This is like GetRegisteredValue, but takes the address of the
   type to return into instead of having to cast the final
   \result.
   if bIntValue, result should be passed as an (&amp;int)        */
PROCREG_PROC( int, GetRegisteredStaticValue )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name
															, CTEXTSTR *result
															, int bIntVal );
#define GetRegisteredStaticIntValue(r,nc,name,result) GetRegisteredStaticValue(r,nc,name,(CTEXTSTR*)result,TRUE )
/* <combine sack::app::registry::GetRegisteredValueExx@PCLASSROOT@CTEXTSTR@CTEXTSTR@int>
   \ \                                                                                   */
PROCREG_PROC( int, GetRegisteredIntValueEx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name );
/* <combine sack::app::registry::GetRegisteredIntValueEx@PCLASSROOT@CTEXTSTR@CTEXTSTR>
   \ \                                                                                 */
PROCREG_PROC( int, GetRegisteredIntValue )( CTEXTSTR name_class, CTEXTSTR name );
#ifdef __cplusplus
/* <combine sack::app::registry::GetRegisteredIntValueEx@PCLASSROOT@CTEXTSTR@CTEXTSTR>
   \ \                                                                                 */
PROCREG_PROC( int, GetRegisteredIntValue )( PCLASSROOT name_class, CTEXTSTR name );
#endif
typedef void (CPROC*OpenCloseNotification)( POINTER, uintptr_t );
#define PUBLIC_DATA( public, struct, open, close )	    PRELOAD( Data_##open##_##close ) {	 RegisterDataType( WIDE("system/data/structs")	        , public, sizeof(struct)	    , (OpenCloseNotification)open, (OpenCloseNotification)close ); }
#define PUBLIC_DATA_EX( public, struct, open, update, close )	    PRELOAD( Data_##open##_##close ) {	 RegisterDataTypeEx( WIDE("system/data/structs")	        , public, sizeof(struct)	    , (OpenCloseNotification)open, (OpenCloseNotification)update, (OpenCloseNotification)close ); }
#define GET_PUBLIC_DATA( public, type, instname )    (type*)CreateRegisteredDataType( WIDE("system/data/structs"), public, instname )
PROCREG_PROC( uintptr_t, RegisterDataType )( CTEXTSTR classname
												 , CTEXTSTR name
												 , uintptr_t size
												 , OpenCloseNotification open
												 , OpenCloseNotification close );
/* Registers a structure as creatable in shared memory by name.
   So a single name of the structure can be used to retrieve a
   pointer to one created.
   Example
   \ \
   <code lang="c++">
   POINTER p = CreateRegisteredDataType( "My types", "my_registered_type", "my instance" );
   // p will result to a region of type 'my_registered_type' called 'my_instance'
   // if it did not exist, it will be created, otherwise the one existing is returned.
   </code>
   Parameters
   root :          optional root name (ex version uses this)
   classname :     path to the type
   name :          name of the type to create an instance of
   instancename :  a name for the instance created.                                         */
PROCREG_PROC( uintptr_t, CreateRegisteredDataType)( CTEXTSTR classname
																 , CTEXTSTR name
																 , CTEXTSTR instancename );
PROCREG_PROC( uintptr_t, RegisterDataTypeEx )( PCLASSROOT root
													, CTEXTSTR classname
													, CTEXTSTR name
													, uintptr_t size
													, OpenCloseNotification Open
													, OpenCloseNotification Close );
/* <combine sack::app::registry::CreateRegisteredDataType@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                */
PROCREG_PROC( uintptr_t, CreateRegisteredDataTypeEx)( PCLASSROOT root
																	, CTEXTSTR classname
																	, CTEXTSTR name
																	, CTEXTSTR instancename );
/* Outputs through syslog a tree dump of all names registered. */
PROCREG_PROC( void, DumpRegisteredNames )( void );
/* Dumps through syslog all names registered from the specified
   root point. (instead of dumping the whole tree)              */
PROCREG_PROC( void, DumpRegisteredNamesFrom )( PCLASSROOT root );
PROCREG_PROC( int, SaveTree )( void );
PROCREG_PROC( int, LoadTree )( void );
#define METHOD_PTR(type,name) type (CPROC *_##name)
#define DMETHOD_PTR(type,name) type (CPROC **_##name)
#define METHOD_ALIAS(i,name) ((i)->_##name)
#define PDMETHOD_ALIAS(i,name) (*(i)->_##name)
/* Releases an interface. When interfaces are registered, they
   register with a OnGetInterface and an OnDropInterface
   callback so that it may do additional work to cleanup from
   giving you a copy of the interface.
   Example
   <code lang="c++">
   POINTER p = GetInterface( "image" );
   DropInterface( p );
   </code>                                                     */
PROCREG_PROC( void, DropInterface )( CTEXTSTR pServiceName, POINTER interface_x );
/* \Returns the pointer to a registered interface. This is
   typically a structure that contains pointer to functions. Takes
   a text string to an interface. Interfaces are registered at a
   known location in the registry tree.                            */
PROCREG_PROC( POINTER, GetInterfaceDbg )( CTEXTSTR pServiceName DBG_PASS );
#define GetInterface(n) GetInterfaceDbg( n DBG_SRC )
#define GetRegisteredInterface(name) GetInterface(name)
PROCREG_PROC( LOGICAL, RegisterInterface )( CTEXTSTR name, POINTER(CPROC*load)(void), void(CPROC*unload)(POINTER));
// unregister a function, should be smart and do full return type
// and parameters..... but for now this only references name, this indicates
// that this has not been properly(fully) extended, and should be layered
// in such a way as to allow this function work in it's minimal form.
PROCREG_PROC( int, ReleaseRegisteredFunctionEx )( PCLASSROOT root
													, CTEXTSTR name_class
													, CTEXTSTR public_name
													  );
#define ReleaseRegisteredFunction(nc,pn) ReleaseRegisteredFunctionEx(NULL,nc,pn)
/* This is a macro used to paste two symbols together. */
#define paste_(a,b) _WIDE(a##b)
#define paste(a,b) paste_(a,b)
#define ___DefineRegistryMethod2(task,name,classtype,methodname,desc,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRIORITY_PRELOAD( paste(paste(paste(Register,name),Method),line), SQL_PRELOAD_PRIORITY ) {	  SimpleRegisterMethod( task WIDE("/") classtype, paste(name,line)	  , _WIDE(#returntype), methodname, _WIDE(#argtypes) );    RegisterValue( task WIDE("/") classtype WIDE("/") methodname, WIDE("Description"), desc ); }	                                                                          static returntype CPROC paste(name,line)
#define __DefineRegistryMethod2(task,name,classtype,methodname,desc,returntype,argtypes,line)	   ___DefineRegistryMethod2(task,name,classtype,methodname,desc,returntype,argtypes,line)
#define ___DefineRegistryMethod2P(priority,task,name,classtype,methodname,desc,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRIORITY_PRELOAD( paste(paste(paste(Register,name),Method),line), priority ) {	  SimpleRegisterMethod( task WIDE("/") classtype, paste(name,line)	  , _WIDE(#returntype), methodname, _WIDE(#argtypes) );    RegisterValue( task WIDE("/") classtype WIDE("/") methodname, WIDE("Description"), desc ); }	                                                                          static returntype CPROC paste(name,line)
#define __DefineRegistryMethod2P(priority,task,name,classtype,methodname,desc,returntype,argtypes,line)	   ___DefineRegistryMethod2P(priority,task,name,classtype,methodname,desc,returntype,argtypes,line)
#define ___DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRELOAD( paste(Register##name##Button,line) ) {	  SimpleRegisterMethod( task WIDE("/") classtype WIDE("/") classbase, paste(name,line)	  , _WIDE(#returntype), methodname, _WIDE(#argtypes) ); }	                                                                          static returntype CPROC paste(name,line)
#define __DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,line)	   ___DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,line)
#define _DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,line)	   static returntype __DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,line)
#define DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes)	  __DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,__LINE__)
// this macro is used for ___DefineRegistryMethodP. Because this is used with complex names
// an extra define wrapper of priority_preload must be used to fully resolve paramters.
#define PRIOR_PRELOAD(a,p) PRIORITY_PRELOAD(a,p)
#define ___DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRIOR_PRELOAD( paste(Register##name##Button,line), priority ) {	  SimpleRegisterMethod( task WIDE("/") classtype WIDE("/") classbase, paste(name,line)	  , _WIDE(#returntype), methodname, _WIDE(#argtypes) ); }	                                                                          static returntype CPROC paste(name,line)
/* <combine sack::app::registry::SimpleRegisterMethod>
   General form to build a registered procedure. Used by simple
   macros to create PRELOAD'ed registered functions. This flavor
   requires the user to provide 'static' and a return type that
   matches the return type specified in the macro. This makes
   usage most C-like, and convenient to know what the return
   value of a function should be (if any).
   Parameters
   priority :    The preload priority to load at.
   task :        process level name registry. This would be
                 "Intershell" or "psi" or some other base prefix.
                 The prefix can contain a path longer than 1
                 level.
   name :        This is the function name to build. (Can be used
                 for link debugging sometimes)
   classtype :   class of the name being registered
   methodname :  name of the routine to register
   returntype :  the literal type of the return type of this
                 function (void, int, PStruct* )
   argtypes :    Argument signature of the routine in parenthesis
   line :        this is usually filled with __LINE__ so that the
                 same function name (name) will be different in
                 different files (even in the same file)
   Remarks
   This registers a routine at the specified preload priority.
   Registers under [task]/[classname]/methodname. The name of
   the registered routine from a C perspective is [name][line]. This
   function is not called directly, but will only be referenced
   from the registered name.
   Example
   See <link sack::app::registry::GetFirstRegisteredNameEx@PCLASSROOT@CTEXTSTR@PCLASSROOT *, GetFirstRegisteredNameEx> */
#define __DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)	   ___DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)
#define _DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)	   __DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)
#define DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes)	  _DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,__LINE__)
#define _DefineRegistrySubMethod(task,name,classtype,classbase,methodname,subname,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRELOAD( paste(Register##name##Button,line) ) {	  SimpleRegisterMethod( task WIDE("/") classtype WIDE("/") classbase WIDE("/") methodname, paste(name,line)	  , _WIDE(#returntype), subname, _WIDE(#argtypes) ); }	                                                                          static returntype CPROC paste(name,line)
#define DefineRegistrySubMethod(task,name,classtype,classbase,methodname,subname,returntype,argtypes)	  _DefineRegistrySubMethod(task,name,classtype,classbase,methodname,subname,returntype,argtypes,__LINE__)
/* attempts to use dynamic linking functions to resolve passed
   global name if that fails, then a type is registered for this
   global, and an instance created, so that that instance may be
   reloaded again, otherwise the data in the main application is
   used... actually we should deprecate the dynamic loading
   part, and just register the type.
   SimpleRegisterAndCreateGlobal Simply registers the type as a
   global variable type. Allows creation of the global space
   later.
   Parameters
   name :         name of the pointer to global type to create.<p />text
                  string to register this created global as.
   ppGlobal :     address of the pointer to global memory.
   global_size :  size of the global area to create
   Example
   <code lang="c++">
   typedef struct {
      int data;
   } my_global;
   my_global *global;
   PRELOAD( Init )
   {
       SimpleRegisterAndCreateGlobal( global );
   }
   </code>                                                               */
PROCREG_PROC( void, RegisterAndCreateGlobal )( POINTER *ppGlobal, uintptr_t global_size, CTEXTSTR name );
/* <combine sack::app::registry::RegisterAndCreateGlobal@POINTER *@uintptr_t@CTEXTSTR>
   \ \                                                                                   */
#define SimpleRegisterAndCreateGlobal( name )	 RegisterAndCreateGlobal( (POINTER*)&name, sizeof( *name ), WIDE(#name) )
/* Init routine is called, otherwise a 0 filled space is
   returned. Init routine is passed the pointer to the global
   and the size of the global block the global data block is
   zero initialized.
   Parameters
   ppGlobal :     Address of the pointer to the global region
   global_size :  size of the global region to create
   name :         name of the global region to register (so
                  future users get back the same data area)
   Init :         function to call to initialize the region when
                  created. (doesn't have to be a global. Could be
                  used to implement types that have class
                  constructors \- or not, since there's only one
                  instance of a global \- this is more for
                  singletons).
   Example
   <code>
   typedef struct {
      int data;
   } my_global;
   my_global *global;
   </code>
   <code lang="c++">
   void __cdecl InitRegion( POINTER region, uintptr_t region_size )
   {
       // do something to initialize 'region'
   }
   PRELOAD( InitGlobal )
   {
       SimpleRegisterAndCreateGlobalWithInit( global, InitRegion );
   }
   </code>                                                          */
PROCREG_PROC( void, RegisterAndCreateGlobalWithInit )( POINTER *ppGlobal, uintptr_t global_size, CTEXTSTR name, void (CPROC*Init)(POINTER,uintptr_t) );
/* <combine sack::app::registry::RegisterAndCreateGlobalWithInit@POINTER *@uintptr_t@CTEXTSTR@void __cdecl*InitPOINTER\,uintptr_t>
   \ \                                                                                                                              */
#define SimpleRegisterAndCreateGlobalWithInit( name,init )	 RegisterAndCreateGlobalWithInit( (POINTER*)&name, sizeof( *name ), WIDE(#name), init )
/* a tree dump will result with dictionary names that may translate automatically. */
/* This has been exported as a courtesy for StrDup.
 * this routine MAY result with a translated string.
 * this routine MAY result with the same pointer.
 * this routine MAY need to be improved if MANY more strdups are replaced
 * Add a binary tree search index when large.
 * Add a transaltion tree index at the same time.
 */
PROCREG_PROC( CTEXTSTR, SaveNameConcatN )( CTEXTSTR name1, ... );
// no space stripping, saves literal text
PROCREG_PROC( CTEXTSTR, SaveText )( CTEXTSTR text );
PROCREG_NAMESPACE_END
#ifdef __cplusplus
	using namespace sack::app::registry;
#endif
#endif
#ifdef SALTY_RANDOM_GENERATOR_SOURCE
#define SRG_EXPORT EXPORT_METHOD
#else
#define SRG_EXPORT IMPORT_METHOD
#endif
//
// struct random_context *entropy = CreateEntropy( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
SRG_EXPORT struct random_context *SRG_CreateEntropy( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
//
// struct random_context *entropy = CreateEntropy2( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
//  uses a larger salt generator...
SRG_EXPORT struct random_context *SRG_CreateEntropy2( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
// Destroya  context.  Pass the address of your 'struct random_context *entropy;   ... SRG_DestroyEntropy( &entropy );
SRG_EXPORT void SRG_DestroyEntropy( struct random_context **ppEntropy );
// get a large number of bits of entropy from the random_context
// buffer needs to be an integral number of 32 bit elements....
SRG_EXPORT void SRG_GetEntropyBuffer( struct random_context *ctx, uint32_t *buffer, uint32_t bits );
// get a number of bits of entropy from the
// if get_signed is not 0, the result will be sign extended if the last bit is set
//  (coded on little endian; tests for if ( result & ( 1 << bits - 1 ) ) then sign extend
SRG_EXPORT int32_t SRG_GetEntropy( struct random_context *ctx, int bits, int get_signed );
// opportunity to reset an entropy generator back to initial condition
// next call to getentropy will be the same as the first call after create.
SRG_EXPORT void SRG_ResetEntropy( struct random_context *ctx );
// restore the random contxt from the external holder specified
// {
//    POINTER save_context;
//    SRG_RestoreState( ctx, save_context );
// }
SRG_EXPORT void SRG_RestoreState( struct random_context *ctx, POINTER external_buffer_holder );
// save the random context in an external buffer holder.
// external buffer holder needs to be initialized to NULL.
// {
//    POINTER save_context = NULL;
//    SRG_SaveState( ctx, &save_context );
// }
SRG_EXPORT void SRG_SaveState( struct random_context *ctx, POINTER *external_buffer_holder );
// usage
/// { uint8_t* buf; size_t buflen; SRG_DecryptData( <resultfrom encrypt>, &buf, &buflen ); }
//  buffer result must be released by user
SRG_EXPORT void SRG_DecryptData( CTEXTSTR local_password, uint8_t* *buffer, size_t *chars );
SRG_EXPORT void SRG_DecryptRawData( CPOINTER binary, size_t length, uint8_t* *buffer, size_t *chars );
// text result must release by user
SRG_EXPORT TEXTSTR SRG_DecryptString( CTEXTSTR local_password );
// encrypt a block of binary data to another binary buffer
SRG_EXPORT void SRG_EncryptRawData( CPOINTER buffer, size_t buflen, uint8_t* *result_buf, size_t *result_size );
// text result must release by user
SRG_EXPORT TEXTCHAR * SRG_EncryptData( CPOINTER buffer, size_t buflen );
// text result must release by user
// calls EncrytpData with buffer and string length + 1 to include the null for decryption.
SRG_EXPORT TEXTCHAR * SRG_EncryptString( CTEXTSTR buffer );
// return a unique ID
SRG_EXPORT char * SRG_ID_Generator( void );
#ifndef SACK_VFS_DEFINED
/* Header multiple inclusion protection symbol. */
#define SACK_VFS_DEFINED
#ifdef SACK_VFS_STATIC
#  ifdef SACK_VFS_SOURCE
#    define SACK_VFS_PROC
#  else
#    define SACK_VFS_PROC extern
#  endif
#else
#  ifdef SACK_VFS_SOURCE
#    define SACK_VFS_PROC EXPORT_METHOD
#  else
#    define SACK_VFS_PROC IMPORT_METHOD
#  endif
#endif
#ifdef __cplusplus
/* defined the file system partial namespace (under
   SACK_NAMESPACE probably)                         */
#define _SACK_VFS_NAMESPACE  namespace SACK_VFS {
/* Define the ending symbol for file system namespace. */
#define _SACK_VFS_NAMESPACE_END }
#else
#define _SACK_VFS_NAMESPACE
#define _SACK_VFS_NAMESPACE_END
#endif
/* define the file system namespace end. */
#define SACK_VFS_NAMESPACE_END _SACK_VFS_NAMESPACE_END SACK_NAMESPACE_END
/* define the file system namespace. */
#define SACK_VFS_NAMESPACE SACK_NAMESPACE _SACK_VFS_NAMESPACE
SACK_VFS_NAMESPACE
// if the option to auto mount a file system is used, this is the
// name of the 'file system interface'  ( sack_get_filesystem_interface( SACK_VFS_FILESYSTEM_NAME ) )
#define SACK_VFS_FILESYSTEM_NAME WIDE("sack_shmem")
// open a volume at the specified pathname.
// if the volume does not exist, will create it.
// if the volume does exist, a quick validity check is made on it, and then the result is opened
// returns NULL if failure.  (permission denied to the file, or invalid filename passed, could be out of space... )
// same as load_cyrypt_volume with userkey and devkey NULL.
SACK_VFS_PROC struct volume * CPROC sack_vfs_load_volume( CTEXTSTR filepath );
// open a volume at the specified pathname.  Use the specified keys to encrypt it.
// if the volume does not exist, will create it.
// if the volume does exist, a quick validity check is made on it, and then the result is opened
// returns NULL if failure.  (permission denied to the file, or invalid filename passed, could be out of space... )
// if the keys are NULL same as load_volume.
SACK_VFS_PROC struct volume * CPROC sack_vfs_load_crypt_volume( CTEXTSTR filepath, uintptr_t version, CTEXTSTR userkey, CTEXTSTR devkey );
// pass some memory and a memory length of the memory to use as a volume.
// if userkey and/or devkey are not NULL the memory is assume to be encrypted with those keys.
// the space is opened as readonly; write accesses/expanding operations will fail.
SACK_VFS_PROC struct volume * CPROC sack_vfs_use_crypt_volume( POINTER filemem, size_t size, uintptr_t version, CTEXTSTR userkey, CTEXTSTR devkey );
// close a volume; release all resources; any open files will keep the volume open.
// when the final file closes the volume will complete closing.
SACK_VFS_PROC void            CPROC sack_vfs_unload_volume( struct volume * vol );
// remove unused extra allocated space at end of volume.  During working process, extra space is preallocated for
// things to be stored in.
SACK_VFS_PROC void            CPROC sack_vfs_shrink_volume( struct volume * vol );
// remove encryption from volume.
SACK_VFS_PROC LOGICAL         CPROC sack_vfs_decrypt_volume( struct volume *vol );
// change the key applied to a volume.
SACK_VFS_PROC LOGICAL         CPROC sack_vfs_encrypt_volume( struct volume *vol, uintptr_t version, CTEXTSTR key1, CTEXTSTR key2 );
// create a signature of current directory of volume.
// can be used to validate content.  Returns 256 character hex string.
SACK_VFS_PROC const char *    CPROC sack_vfs_get_signature( struct volume *vol );
// pass an offset from memory start and the memory start...
// computes the distance, uses that to generate a signature
// returns BLOCK_SIZE length signature; recommend using at least 128 bits of it.
SACK_VFS_PROC const uint8_t * CPROC sack_vfs_get_signature2( POINTER disk, POINTER diskReal );
// ---------- Operations on files in volumes ------------------
// open a file, creates if does not exist.
SACK_VFS_PROC struct sack_vfs_file * CPROC sack_vfs_openfile( struct volume *vol, CTEXTSTR filename );
// check if a file exists (if it does not exist, and you don't want it created, can use this and not openfile)
SACK_VFS_PROC int CPROC sack_vfs_exists( struct volume *vol, const char * file );
// close a file.
SACK_VFS_PROC int CPROC sack_vfs_close( struct sack_vfs_file *file );
// get the current File Position Index (FPI).
SACK_VFS_PROC size_t CPROC sack_vfs_tell( struct sack_vfs_file *file );
// get the length of the file
SACK_VFS_PROC size_t CPROC sack_vfs_size( struct sack_vfs_file *file );
// set the current File Position Index (FPI).
SACK_VFS_PROC size_t CPROC sack_vfs_seek( struct sack_vfs_file *file, size_t pos, int whence );
// write starting at the current FPI.
SACK_VFS_PROC size_t CPROC sack_vfs_write( struct sack_vfs_file *file, const char * data, size_t length );
// read starting at the current FPI.
SACK_VFS_PROC size_t CPROC sack_vfs_read( struct sack_vfs_file *file, char * data, size_t length );
// sets the file length to the current FPI.
SACK_VFS_PROC size_t CPROC sack_vfs_truncate( struct sack_vfs_file *file );
// psv should be struct volume *vol;
// delete a filename.  Clear the space it was occupying.
SACK_VFS_PROC int CPROC sack_vfs_unlink_file( struct volume *vol, const char * filename );
// -----------  directory interface commands. ----------------------
// returns find_info which is then used in subsequent commands.
SACK_VFS_PROC struct find_info * CPROC sack_vfs_find_create_cursor(uintptr_t psvInst,const char *base,const char *mask );
// reset find_info to the first directory entry.  returns 0 if no entry.
SACK_VFS_PROC int CPROC sack_vfs_find_first( struct find_info *info );
// closes a find cursor; returns 0.
SACK_VFS_PROC int CPROC sack_vfs_find_close( struct find_info *info );
// move to the next entry returns 0 if no entry.
SACK_VFS_PROC int CPROC sack_vfs_find_next( struct find_info *info );
// get file information for the file at the current cursor position...
SACK_VFS_PROC char * CPROC sack_vfs_find_get_name( struct find_info *info );
// get file information for the file at the current cursor position...
SACK_VFS_PROC size_t CPROC sack_vfs_find_get_size( struct find_info *info );
SACK_VFS_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::SACK_VFS;
#endif
#endif
#ifndef SQL_OPTIONS_DEFINED
#define SQL_OPTIONS_DEFINED
/* more documentation at end */
/*
 *
 *   Creator: Panther   #implemented in Dekware
 *   Modified by: Jim Buckeyne #ported to service SQL via proxy.
 *   Returned to sack by: Jim Buckeyne
 *                  # stripped application specific
 *                  # features, returned to SACK.
 *
 *  Provides a simple, intuitive interface to SQL.  Used sensibly,
 *  provides garbage collection of resources.
 *
 *  Commands without an ODBC specifier are the perferred method to
 *  use this interface.  This allows the internal system to maintain
 *  a primary and a redundant backup connection to provide transparent
 *  reliability to the application.
 *
 *  Provides some slick table creation routines
 *     - check for existance, and drop  (CTO_DROP)
 *     - check for existance, and match (CTO_MATCH)
 *     - check for existance, and merge (CTO_MERGE)
 *     - create table if not exist.
 *
 *  Latest additions provide ...RecordQuery... functions which
 *  result with a const CTEXTSTR * of results;  (ie, result[0] = (CTEXTSTR)result1 )
 *  also available are the column names from the query.
 *  I strongly recommend passing NULL always to the field names, and
 *  using sensible enumerators that follow the query definition.
 *
 *  (c)Freedom Collective (Jim Buckeyne 2000-2016)
 *
 */
#ifndef PSSQL_STUB_DEFINED
/* multiple inclusion protection symbol */
#define PSSQL_STUB_DEFINED
#if defined( SQLSTUB_SOURCE ) || defined( SQLPROXY_LIBRARY_SOURCE )
#define PSSQL_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define PSSQL_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
#define _SQL_NAMESPACE   namespace sql {
#define _SQL_NAMESPACE_END   }
#define SQL_NAMESPACE   namespace sack { namespace sql {
#define SQL_NAMESPACE_END } }
#else
#define _SQL_NAMESPACE
#define _SQL_NAMESPACE_END
#define SQL_NAMESPACE
#define SQL_NAMESPACE_END
#endif
SACK_NAMESPACE
/* SQL access library. This provides a simple access to ODBC
   connections, and to sqlite. If no database is specified,
   there is an internal database that can be used. These methods
   on the PODBC connection are NOT thread safe. Multiple threads
   shall never use the same PODBC; they can use seperate PODBC
   connections. Under linux this links to unixODBC.
   DoSQLCommandf
   DoSQLRecordQueryf
   GetSQLRecord
   ConnectToDatabase
   DoSQLCommandf
   DoSQLRecordQueryf
   FetchSQLRecord
   There is a configuration file for the default SQL connection,
   this is kept in a file 'sql.config' which is processed with
   ProcessConfigurationFile(); If this file does not exist, it
   will be automatically created with default values.
   (Need to describe this sql.config file)                       */
_SQL_NAMESPACE
/* <combine PSSQL_PROC>
   \ \                    */
#define SQLPROXY_PROC PSSQL_PROC
/* This is the connection object that provides interface to the
   database. Can be NULL to specify the default connection
   interface. See namespace <link sack::sql, sql>.
   An ODBC connection handles commands as a stack. Each command
   is done as a temporary entry on the stack. A query is done as
   an entry on the stack, but the entry remains on the stack
   until the final result is retrieved or an early PopODBC is
   called.
   The structure of this is such that if a command is slow to a
   database, it would be possible to stack commands that are
   temporary and pending until the database connection is
   restored.
   Example
   <code lang="c++">
   int f( void )
   {
       // results from the query
       CTEXTSTR *results;
       // connect.
       PODBC odbc = ConnectToDatabase( "system_dsn_name" );
       // do a command, does a temporary entry on the stack, unless the database is slow
       SQLCommandf( odbc, "create temporary table my_test_table( ID int, value int )" );
       // start a new entry on the command stack.
       SQLRecordQueryf( odbc, NULL, &amp;results, NULL, "select 1+1" );
       // when this command is done, it is stacked on the query.
       SQLCommandf( odbc, "insert into my_test_table (value) values(%d)", 1234 );
       // at this point there is technically 2 entries on the command stack until the next
       // FetchSQLResult( odbc, &amp;results );
   }
	</code>                                                                                 */
#if !defined( __GNUC__ ) || !defined( SQLSTUB_SOURCE )
   // GCC doesn't identify this as exactly the same declaration
	typedef struct odbc_handle_tag *PODBC;
#endif
typedef struct odbc_handle_tag ODBC;
// recently added {} container braces for structure element
#define FIELDS(n) {( sizeof( n ) / sizeof( FIELD ) ), n}
/* a field definition can be a rename, and contain prior names,
   so that the rename can be tracked and migrated appropraitely.
   Unfortuntaly this sort of operation only affects this code,
   and not all auxiliary code.                                   */
#define MAX_PREVIOUS_FIELD_NAMES 4
/* <combine sack::sql::required_field_tag>
   <code lang="c++">
     FIELD fields[] = { { "ID", WIDE("int") }, ... };
   </code>                                            */
typedef struct required_field_tag
{
	/* This is the name of the column described in this table. */
	CTEXTSTR name;
	/* pointer to a string describing the type of this column.  */
	CTEXTSTR type;
	/* extra information about the field... grab all addtional
	   information like 'NOT NULL' "default 'zxa'" to describe a
	   field. Sometimes target databases don't understand extra
	   \parameters, and these can be translated as required or
	   ignored.                                                  */
	CTEXTSTR extra;
	// if you have renamed this column more than 1
	// times - you really need to stop messing around
	// and get a life.
	CTEXTSTR previous_names[MAX_PREVIOUS_FIELD_NAMES];
} FIELD, *PFIELD;
#if !defined( _MSC_VER ) || ( _MSC_VER >= 800 )
/* A macro to append a NULL automatically to a list of strings.
   Example
   <code lang="c++">
   CTEXTSTR strings[] = { KEY_COLUMNS( "one", "two", "three" ) };
   </code>
   strings will be set to 4 elements with the 3 strings listed
   in KEY_COLUMNS plus a NULL string.                             */
#define KEY_COLUMNS(...) { __VA_ARGS__, NULL }
#endif
/* sets the count and the array of a statically declared
   required_table_tag.
   Example
   <code lang="c++">
   </code>
   <code>
   FIELD fields[5];
   DB_KEY_DEF keys[3];
   TABLE table = { "table_name", FIELDS( fields ), TABLE_KEYS( keys ) };
   </code>
   This creates a static table definition with the name
   "table_name" and 5 fields with 3 keys. fields[] = { } is
   usally the declartion. Also DB_KEY_DEF keys[] = { ... }; for
   keys.
                                                                         */
#define TABLE_KEYS(n) {( sizeof( n ) / sizeof( DB_KEY_DEF ) ), n}
/* maximum columns that can be specified for a multicolumn index
   in required_key_def.                                          */
#define MAX_KEY_COLUMNS 8
/* <combine sack::sql::required_key_def>
   \ \                                   */
typedef struct required_key_def  DB_KEY_DEF;
enum uniqueResolutions {
  // no on conflict specification.
	UNIQRES_UNSET = 0,
	UNIQRES_REPLACE,
	UNIQRES_IGNORE,
	UNIQRES_FAIL,
	UNIQRES_ABORT,
	UNIQRES_ROLLBACK
};
/* <combine sack::sql::required_key_def>
   \ \                                   */
typedef struct required_key_def  *PDB_KEY_DEF;
struct required_key_def
{
	/* Flags describing attributes of this key */
	/* <combine sack::sql::required_key_def::flags@1>
	   \ \                                            */
	struct {
		/* this defines the primary key for the table */
		BIT_FIELD bPrimary : 1;
		/* the key is meant to be unique. */
		BIT_FIELD bUnique : 1;
		BIT_FIELD uniqueResolution : 3;
	} flags;
	/* Name of the key column. Can be NULL if primary. */
	CTEXTSTR name;
 // uhm up to 5 colnames...
	CTEXTSTR colnames[MAX_KEY_COLUMNS];
 // if not null, broken structure...
	CTEXTSTR null;
#ifdef __cplusplus
   /* <combine sack::sql::required_key_def>
      This is used when actually building C++ for providing an
      initializer to this structure.                           */
   required_key_def( int bPrimary, int bUnique, CTEXTSTR _name, CTEXTSTR colname1 ) { flags.bPrimary = bPrimary; flags.bUnique = bUnique; name = _name; colnames[0] = colname1; colnames[1] = NULL; }
   /* <combine sack::sql::required_key_def>
      This is used when actually building C++ for providing an
      initializer to this structure.                           */
   required_key_def( int bPrimary, int bUnique, CTEXTSTR _name, CTEXTSTR colname1, CTEXTSTR colname2 ) { flags.bPrimary = bPrimary; flags.bUnique = bUnique; name = _name; colnames[0] = colname1; colnames[1] = colname2; colnames[2] = 0; }
	/* Just another required_key_def constructor. */
	required_key_def( int bPrimary, int bUnique, CTEXTSTR _name, CTEXTSTR colname1, CTEXTSTR colname2, CTEXTSTR colname3 ) { flags.bPrimary = bPrimary; flags.bUnique = bUnique; name = _name; colnames[0] = colname1; colnames[1] = colname2; colnames[2] = colname3; colnames[3] = 0; }
#else
#define required_key_def( a,b,c,...) { {a,b}, c, {__VA_ARGS__} }
#endif
};
 /* Describes a key column of a table.
      <code lang="c++">
      DB_KEY_DEF keys[] = { { "lockey", KEY_COLUMNS("hall_id","charity_id") } };
      </code>                                                                    */
/* <combine sack::sql::required_constraint_def>
   \ \                                   */
typedef struct required_constraint_def  DB_CONSTRAINT_DEF;
/* <combine sack::sql::required_constraint_def>
   \ \                                   */
typedef struct required_constraint_def  *PDB_CONSTRAINT_DEF;
struct required_constraint_def
{
	struct {
		BIT_FIELD cascade_on_delete : 1;
		BIT_FIELD cascade_on_update : 1;
		BIT_FIELD restrict_on_delete : 1;
		BIT_FIELD restrict_on_update : 1;
		BIT_FIELD noaction_on_delete : 1;
		BIT_FIELD noaction_on_update : 1;
		BIT_FIELD setnull_on_delete : 1;
		BIT_FIELD setnull_on_update : 1;
		BIT_FIELD setdefault_on_delete : 1;
		BIT_FIELD setdefault_on_update : 1;
		BIT_FIELD foreign_key : 1;
	} flags;
	CTEXTSTR name;
 // uhm up to 5 colnames...
	CTEXTSTR colnames[MAX_KEY_COLUMNS];
	CTEXTSTR references;
 // uhm up to 5 colnames...
	CTEXTSTR foriegn_colnames[MAX_KEY_COLUMNS];
 // if not null, broken structure...
	CTEXTSTR null;
 // Describes a constraint clause
};
/* Example
   By default, CreateTable( CTEXTSTR tablename, CTEXTSTR
   filename ) which reads a 'create table' statement from a file
   to create a table, this now parses the create table structure
   into an internal structure TABLE which has FIELDs and
   DB_KEY_DEFs. This structure is now passed to CheckODBCTable
   which is able to compare the structure with the table
   definition available from the database via DESCRIBE TABLE,
   and then update the table in the database to match the TABLE
   definition.
   One can use the table structure to define tables instead of
   maintaining external files... and without having to create a
   temporary external file which could then contain a create
   table statement to create the table.
   <code>
   // declare some fields...
   FIELD some_table_field_array_name[] = { { "field one", "int", NULL }
   , { "field two", "varchar(100)", NULL }
   , { "ID field", "int", "auto_increment" }
   , { "some other field", "int", "NOT NULL default '8'" }
   };
   // define some keys...
   DB_KEY_DEF some_table_key_array_name[] = { { .flags = { .bPrimary = 1 }, NULL, {"ID Field"} }
   , { {0}, "namekey", { "field two", NULL } }
   };
   </code>
   // the structure for DB_KEY_DEF takes an array of column
   names used to define the key, there should be a NULL to end
   the list. The value after the array of field names is called
   'null' which should always be set to NULL. If these are
   declared in global data space, then any unset value will be
   initialized to zero.
   <code>
   TABLE some_table_var_name = { "table name", FIELDS( some_table_field_array_name ), TABLE_KEYS( some_table_key_array_name ), 1 );
    LOGICAL CheckODBCTable( PODBC odbc, PTABLE table, uint32_t options )
        PODBC odbc - may be left NULL to use the default database connection.
        PTABLE table - a pointer to a TABLE structure which has been initialized.
        uint32_t options - zero or more of  the following symbols or'ed together.
                   \#define CTO_MATCH 4  // attempt to figure out alter statements to drop or add columns to exact match definition
                   \#define CTO_MERGE 8  // attempt to figure out alter statements to add missing columns, do not drop.  Rename?
   </code>
   Then some routine later
   <code>
   {
      ...
      CheckODBCTable( NULL, &amp;some_table_var_name, CTO_MERGE );
      ..
   }
   </code>
   * ---------------------------------------------------------- *
   alternatively tables may be checked and updated using the
   following code, given an internal constant text string that
   is the create table statement, this may be parsed into a
   PTABLE structure which the resulting table can be used in
   CheckODBCTable();
   <code>
   static CTEXTSTR create_player_info = "CREATE TABLE `players_info` ("
         "  `player_id` int(11) NOT NULL auto_increment,           "
         "  PRIMARY KEY  (`player_id`),                            "
         ")                               ";
   PTABLE table = GetFieldsInSQL( create_player_info, FALSE );
   CheckODBCTable( NULL, table, CTO_MERGE );
   DestroySQLTable( table );
   </code>                                                                                                                          */
struct required_table_tag
{
	/* This is the name of the table. */
	CTEXTSTR name;
	/* describes the columns (fields) in a table. */
	struct pssql_table_fields {
		/* number of fields in the array pointed at by field. */
		int count;
		/* pointer to an array of FIELD. */
		PFIELD field;
	} fields;
	/* Describes the keys on the table.  */
	/* <combine sack::sql::required_table_tag::keys@1>
	   \ \                                             */
	struct pssql_table_key {
		/* number of keys pointed at by key. */
		int count;
      /* pointer to an array of DB_REQ_KEY. */
      PDB_KEY_DEF key;
	} keys;
	struct pssql_table_constraint {
		int count;
		PDB_CONSTRAINT_DEF constraint;
	} constraints;
	/* <combine sack::sql::required_table_tag::flags@1>
	   \ \                                              */
	/* flags controlling the table. */
		struct pssql_table_flags {
         // set this if defined dynamically (from getfields in SQL)
		BIT_FIELD bDynamic : 1;
		/* This is a table that is allocated in memory, static table
		   definitions should leave this 0.                          */
		BIT_FIELD bTemporary : 1;
		/* Issue the create statement always, but include 'if not
		   exists'. Don't try and compare the table structure.    */
		BIT_FIELD bIfNotExist : 1;
	} flags;
   /* name of another table that already exists. Creates this table
      using that table's description.                               */
   CTEXTSTR create_like_table_name;
   /* name of the database that contains this table. */
   CTEXTSTR database;
   /* an additional field that can specify the database storage
      engine to use. (Hmm maybe use this to specify sqlite target?) */
   CTEXTSTR type;
   /* This is an additional field to add as a description to the
      database if supported by the target database.              */
   CTEXTSTR comment;
};
/* <combine sack::sql::required_table_tag>
   \ \                                     */
typedef struct required_table_tag TABLE;
/* <combine sack::sql::required_table_tag>
   \ \                                     */
typedef struct required_table_tag *PTABLE;
/* Checks a table in a database to see if it exists, and that
   all the columns in the table definition passed exist as
   column in the database. Will generate alter statements to the
   table as appropriate.
   Parameters
   odbc :     connection to check the table on
   table :    a table which was created with GetFieldsInSQL, or
              created by filling in a structure.
   options :  Options from CreateTableOptions.                   */
PSSQL_PROC( LOGICAL, CheckODBCTableEx)( PODBC odbc, PTABLE table, uint32_t options DBG_PASS );
/* Checks a table in a database to see if it exists, and that
   all the columns in the table definition passed exist as
   column in the database. Will generate alter statements to the
   table as appropriate.
   Parameters
   odbc :     connection to check the table on
   table :    a table which was created with GetFieldsInSQL, or
              created by filling in a structure.
   options :  Options from CreateTableOptions.                   */
PSSQL_PROC( LOGICAL, CheckODBCTable)( PODBC odbc, PTABLE table, uint32_t options );
/* <combine sack::sql::CheckODBCTableEx@PODBC@PTABLE@uint32_t options>
   \ \                                                            */
#define CheckODBCTable(odbc,t,opt) CheckODBCTableEx(odbc,t,opt DBG_SRC )
/* Enable or disable logging SQL to the sql.log file and to the
   application's log.
   Parameters
   odbc :      connection to disable logging on
   bDisable :  if TRUE disables logging, else restores logging. */
PSSQL_PROC( void, SetSQLLoggingDisable )( PODBC odbc, LOGICAL bDisable );
#ifndef SQLPROXY_INCLUDE
// result is FALSE on error
// result is TRUE on success
PSSQL_PROC( int, DoSQLCommandEx )( CTEXTSTR command DBG_PASS);
#endif
/* <combine sack::sql::DoSQLCommandEx@CTEXTSTR command>
   \ \                                                  */
#define DoSQLCommand(c) DoSQLCommandEx(c DBG_SRC )
/* Generate a commit for any outstanding transactions. Commit
   syntax is variable depending on the connection. Connections
   also have the feature to auto generate begin transaction, and
   flush after a period of idle.
   Parameters
   odbc :  connection to database to commit                      */
PSSQL_PROC( void, SQLCommit )( PODBC odbc );
/* generates the begin transaction for a commection.
   Parameters
   odbc :  connection to database to start a transaction        */
PSSQL_PROC( void, SQLBeginTransact )( PODBC odbc );
// parameters to this are pairs of "name", type, WIDE("value")
//  type == 0 - value is text, do not quote
//  type == 1 - value is text, add quotes appropriate for database
//  type == 2 - value is an integer, do not quote
// the last pair's name is NULL, and value does not matter.
// insert values into said table.
PSSQL_PROC( int, DoSQLInsert )( CTEXTSTR table, ... );
#ifndef SQLPROXY_INCLUDE
/* This opens or re-opens a database connection. Mostly an
   \internal function(?)
   Parameters
   odbc :  connection to open.                             */
PSSQL_PROC( int, OpenSQLConnection )( PODBC );
#endif
/* This opens or re-opens a database connection. Mostly an
   \internal function(?)
   Parameters
   odbc :  connection to open.                             */
PSSQL_PROC( int, OpenSQLConnectionEx )( PODBC DBG_PASS );
/* <combine sack::sql::OpenSQLConnectionEx@PODBC>
   \ \                                            */
#define OpenSQLConnect(o) OpenSQLConnectionEx( o DBG_SRC )
// should pass to this a &(CTEXTSTR) which starts as NULL for result.
// result is FALSE on error
// result is TRUE on success, and **result is updated to
// contain the resulting data.
PSSQL_PROC( int, DoSQLQueryEx )( CTEXTSTR query, CTEXTSTR *result DBG_PASS);
/* <combine sack::sql::DoSQLQueryEx@CTEXTSTR@CTEXTSTR *result>
   \ \                                                         */
#define DoSQLQuery(q,r) DoSQLQueryEx( q,r DBG_SRC )
/* <combine sack::sql::DoSQLRecordQueryf@int *@CTEXTSTR **@CTEXTSTR **@CTEXTSTR@...>
   \ \                                                                               */
#define DoSQLRecordQuery(q,r,c,f) SQLRecordQueryEx( NULL,q,r,c,f DBG_SRC )
/* <combine sack::sql::SQLRecordQueryEx@PODBC@CTEXTSTR@int *@CTEXTSTR **@CTEXTSTR **fields>
   \ \                                                                                      */
#define DoSQLQueryRecord(q,r,c)   DoSQLRecordQuery(q,r,c,NULL)
/* <combine sack::sql::SQLRecordQueryEx@PODBC@CTEXTSTR@int *@CTEXTSTR **@CTEXTSTR **fields>
   \ \                                                                                      */
#define SQLQueryRecord(o,q,r,c)   SQLRecordQuery(o,q,r,c,NULL)
/* <combine sack::sql::GetSQLRecord@CTEXTSTR **>
   \ \                                           */
#define GetSQLResultRecord(r,c)   GetSQLRecord(c)
/* <combine sack::sql::FetchSQLResult@PODBC@CTEXTSTR *>
   \ \                                                  */
PSSQL_PROC( int, GetSQLResult )( CTEXTSTR *result );
/* <combine sack::sql::FetchSQLRecord@PODBC@CTEXTSTR **>
   \ \                                                   */
PSSQL_PROC( int, GetSQLRecord )( CTEXTSTR **result );
/* Gets the last result on the default ODBC connection.
   Parameters
   result\ :  address of a string pointer to get set to the error
              string.
   Example
   <code>
   {
      CTEXTSTR error;
      GetSQLError( &amp;error );
      printf( "Error: %s", error );
   }
   </code>                                                        */
PSSQL_PROC( int, GetSQLError )( CTEXTSTR *result );
/* This is a test command that tests to see if the default
   database connection is able to work.                    */
PSSQL_PROC( int, IsSQLReady )( void );
/* <combine sack::sql::PushSQLQueryExEx@PODBC>
   \ \                                         */
PSSQL_PROC( int, PushSQLQuery )( void );
/* <combine sack::sql::PopODBCEx@PODBC>
   \ \                                  */
PSSQL_PROC( void, PopODBC )( void );
#ifndef SQLPROXY_INCLUDE
/* Clear the top non temporary sql statement from the PODBC
   stack.
   Parameters
   odbc :  connection to remove the statement from.
   Remarks
   A SQLCommand is temporary, a SQLQuery or a PushODBC is not. Pop
   MAY be used to clear a query early, but it is recommended to
   read to the end of it instead.                                  */
PSSQL_PROC( void, PopODBCExx )( PODBC, LOGICAL DBG_PASS );
PSSQL_PROC( void, PopODBCEx )( PODBC );
/* <combine sack::sql::PopODBCExx@PODBC@LOGICAL>
   \ \                                           */
#define PopODBCEx(o) PopODBCExx(o,FALSE DBG_SRC)
/* <combine sack::sql::PopODBCEx>
   \ \                            */
#define PopODBC() PopODBCExx(NULL,FALSE DBG_SRC)
#endif
/* This terminates a query on the PODBC stack. (It was mentioned
   in pop odbc that it could be used to terminate a query, but
   that will log that a pop is being done without a push. This
   is the proper way to prematurely end a query.)
   Parameters
   odbc :  connection to end a query on.                         */
PSSQL_PROC( void, SQLEndQuery )( PODBC odbc );
// release any open queries on the database... all result
// sets are now invalid... uhmm what about things like fields?
// could be messy...
PSSQL_PROC( void, ReleaseODBC )( PODBC odbc );
// does a query responce kinda thing returning types.
// if( GetSQLTypes() ) while( GetSQLResult( &result ) && result )
PSSQL_PROC( int, GetSQLTypes )( void );
#ifndef SQLPROXY_INCLUDE
/* parse the string passed as a date/time as returned from a
   MySQL database.
   Parameters
   date :    string to parse
   year :    pointer to an int that will receive the year portion
             of the date
   month :   pointer to an int that will receive the month
             portion of the date
   day :     pointer to an int that will receive the day portion
             of the date
   hour :    pointer to an int that will receive the hours
             portion of the date
   minute :  pointer to an int that will receive the minutes
             portion of the date
   second :  pointer to an int that will receive the second
             portion of the date
   msec :    pointer to an int that will receive the milli\-second
             portion of the date
   nsec :    pointer to an int that will receive the nano second portion
             of the date                                                 */
PSSQL_PROC( void, ConvertSQLDateEx )( CTEXTSTR date
												  , int *year, int *month, int *day
												  , int *hour, int *minute, int *second
												  , int *msec, int32_t *nsec
												  , int *zone_hr, int *zone_mn
												  );
#endif
/* <combine sack::sql::ConvertSQLDateEx@CTEXTSTR@int *@int *@int *@int *@int *@int *@int *@int32_t *>
   \ \                                                                                             */
#define ConvertSQLDate( date, y,m,d) ConvertSQLDateEx( date,y,m,d,NULL,NULL,NULL,NULL,NULL)
/* <combine sack::sql::ConvertSQLDateEx@CTEXTSTR@int *@int *@int *@int *@int *@int *@int *@int32_t *>
   \ \                                                                                             */
#define ConvertSQLDateTime( date, y,mo,d,h,mn,s) ConvertSQLDateEx( date,y,mo,d,h,mn,s,NULL,NULL)
//------------------------------
// this set of functions will auto create a suitable name table
// providing table_name_id and table_name_name as the columns to query by standard
// previous defaults where "id" and "name" which results in inability to use natural join
//
PSSQL_PROC( INDEX, FetchSQLNameID )( PODBC odbc, CTEXTSTR table_name, CTEXTSTR name );
/* A specialized function which takes a name, looks in a SQL
   table on the default database connection for in column
   'name', and returns the value in the 'ID' column. This
   function may create a table with the required fields. This
   table is very bad, if you have 3 tables all with the same
   'name' column reverse engineering and natural join clauses
   fail.
   Parameters
   table_name :  name of the table to get the name's ID from.
   name :        name to lookup its ID for.
   Returns
   the ID of the name or INVALID_INDEX if not found.          */
PSSQL_PROC( INDEX, GetSQLNameID )( CTEXTSTR table_name, CTEXTSTR name );
/* Still a bad function to use.... just don't.
   Parameters
   odbc :        _nt_
   table_name :  _nt_
   iName :       _nt_                          */
PSSQL_PROC( CTEXTSTR, FetchSQLName )( PODBC odbc, CTEXTSTR table_name, INDEX iName );
/* A specialized function which takes an ID, looks in a SQL
   table on the default database connection for in column 'ID',
   and returns the value in the 'name' column. This function may
   create a table with the required fields. This table is very
   bad, if you have 3 tables all with the same 'name' column
   reverse engineering and natural join clauses fail.
   Parameters
   table_name :  name of the database table to read from
   iName :       ID of the name to get                           */
PSSQL_PROC( CTEXTSTR, GetSQLName )( CTEXTSTR table_name, INDEX iName );
/* <combine sack::sql::SQLReadNameTableExEx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \
   Note
   If database connection is not specified or is NULL, uses the
   default SQL connection.                                                                         */
PSSQL_PROC( INDEX, ReadNameTableExEx)( CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS );
/* <combine sack::sql::ReadNameTableExEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                    */
#define ReadNameTableExx( name,table,col,namecol,bCreate) ReadNameTableExEx( name,table,col,namecol,bCreate DBG_SRC )
//column name if NOT specified will be 'ID'
PSSQL_PROC( INDEX, ReadNameTableEx)( CTEXTSTR name, CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::ReadNameTableExEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                    */
#define ReadNameTable(n,t,c) ReadNameTableExEx( n,t,c, WIDE("name"),TRUE DBG_SRC )
/* <combine sack::sql::ReadFromNameTableExEx@INDEX@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR *result>
   \ \                                                                                          */
PSSQL_PROC( int, ReadFromNameTableEx )( INDEX id, CTEXTSTR table, CTEXTSTR id_colname, CTEXTSTR name_colname, CTEXTSTR *result DBG_PASS);
/* TRUE if name in result... again if !colname colname = 'ID'
   Parameters
   odbc :       connection to use
   id :         ID of the name to read
   table :      table to read from
   id_column :  name of the column that contains the ID
   colname :    name of the column that is where the name is
   result\ :    pointer to a CTEXTSTR which will be filled with
                the name in the table                           */
PSSQL_PROC( int, ReadFromNameTableExEx )( INDEX id, CTEXTSTR table, CTEXTSTR id_column, CTEXTSTR colname, CTEXTSTR *result DBG_PASS);
/* <combine sack::sql::ReadFromNameTableExEx@INDEX@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR *result>
   \ \                                                                                          */
#define ReadFromNameTableExx(id,t,ic,nc,r) ReadFromNameTableExEx(id,t,ic,nc,r DBG_SRC )
/* <combine sack::sql::ReadFromNameTableEx@INDEX@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR *result>
   \ \                                                                                        */
#define ReadFromNameTable(id,t,c,r) ReadFromNameTableEx(id,t,c,WIDE("name"),r DBG_SRC )
/* This is a better name resolution function. It will also
   create a table that contains the required columns, but the
   column names may be more intelligent than 'ID' and 'name'.
   Parameters
   odbc :     database connection to read from
   name :     the name to lookup the ID for
   table :    table the name column is in
   col :      name of the key column(s) to read.
   namecol :  name of column containing the name to lookup.
   bCreate :  if TRUE, will insert the name into the table, and
              return the resulting columns.                     */
PSSQL_PROC( INDEX, SQLReadNameTableExEx)( PODBC odbc, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS );
/* <combine sack::sql::SQLReadNameTableExEx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                             */
#define SQLReadNameTableExx( odbc,name,table,col,namecol,bCreate) SQLReadNameTableExEx( odbc,name,table,col,namecol,bCreate DBG_SRC )
/* <combine sack::sql::SQLReadNameTableExEx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                             */
#define SQLReadNameTable(o,n,t,c) SQLReadNameTableExEx( o,n,t,c,WIDE( "name" ),TRUE DBG_SRC )
/* Reads a table that's assumed to be a primary key ID and a
   name sort of dictionary table. This also maintains an
   \internal cache of names queried, since it is assumed words
   in a dictionary don't move or change.
   Parameters
   odbc :      odbc connection to use
   name :      name to get the index of
   table :     table to get the index from
   col :       column name of the ID columns (macros allow this to
               be defaulted)
   namecol :   column name of the name column (macros allow this to
               be defaulted)
   bCreate :   If the name doesn't exist, setting this to TRUE will
               insert the new name, else return will be
               INVALID_INDEX.
   bQuote :    Indicates if the name should be quoted (else use no
               quotes)
   DBG_PASS :  _nt_                                                 */
PSSQL_PROC( INDEX, GetNameIndexExtended)( PODBC odbc, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate, int bQuote DBG_PASS );
/* <combine sack::sql::GetNameIndexExtended@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int@int bQuote>
   \ \                                                                                                */
PSSQL_PROC( INDEX, GetNameIndexExx)( PODBC odbc, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS );
/* <combine sack::sql::GetNameIndexExx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                        */
#define GetNameIndexEx( odbc,name,table,col,namecol,bCreate) GetNameIndexExx( odbc,name,table,col,namecol,bCreate DBG_SRC )
/* <combine sack::sql::GetNameIndexExx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                        */
#define GetNameIndex(o,n,t,c) GetNameIndexExx( o,n,t,c,WIDE( "name" ),TRUE DBG_SRC )
// table and col are not used if a MySQL backend is used...
// they are needed to get the last ID from a postgresql backend.
PSSQL_PROC( INDEX, GetLastInsertIDEx)( CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::GetLastInsertIDEx@CTEXTSTR@CTEXTSTR col>
   \ \                                                          */
#define GetLastInsertID(t,c) GetLastInsertIDEx(t,c DBG_SRC )
/* Gets the ID of the primary key from the prior insert. This
   value can be used in subsequent inserts to relate detail
   records to a master.
   Parameters
   odbc :    database connection
   table :   if NULL, just get's the connection's last insert
             into whatever table. PostgreSQL requires a table
             name and column name to get the last insert for. So,
             proper portability for certain databases may use
             this parameter.
   column :  if NULL, just get's the connection's last insert id
             from the auto increment primary key. PostgreSQL
             requires a table name and column name to get the
             last insert for. So, proper portability for certain
             databases may use this parameter.
   Returns
   a 64 bit row identifier.                                       */
PSSQL_PROC( INDEX, FetchLastInsertIDEx)( PODBC odbc, CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::FetchLastInsertIDEx@PODBC@CTEXTSTR@CTEXTSTR col>
   \ \                                                                  */
#define FetchLastInsertID(o,t,c) FetchLastInsertIDEx(o,t,c DBG_SRC )
/* <combine sack::sql::FetchLastInsertIDEx@PODBC@CTEXTSTR@CTEXTSTR col>
   \ \                                                                  */
#define FetchLastInsertKey(o,t,c) FetchLastInsertKeyEx(o,t,c DBG_SRC )
/* <combine sack::sql::FetchLastInsertIDEx@PODBC@CTEXTSTR@CTEXTSTR col>
   \ \                                                                  */
PSSQL_PROC( CTEXTSTR, FetchLastInsertKeyEx)( PODBC odbc, CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::GetLastInsertIDEx@CTEXTSTR@CTEXTSTR col>
   \ \                                                          */
PSSQL_PROC( CTEXTSTR, GetLastInsertKeyEx)( CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::GetLastInsertIDEx@CTEXTSTR@CTEXTSTR col>
   \ \                                                          */
#define GetLastInsertKey(t,c) GetLastInsertKeyEx(t,c DBG_SRC )
// CreateTable Options (CTO_)
enum CreateTableOptions {
   // drop old table before create.
 CTO_DROP  = 1,
  // attempt to figure out alter statements to drop or add columns to exact match definition
 CTO_MATCH = 4,
  // attempt to figure out alter statements to add missing columns, do not drop.  Rename?
 CTO_MERGE = 8,
 // log changes to "changes.sql"
		CTO_LOG_CHANGES = 16
};
/* \ \
   Parameters
   odbc :          database connection to check table in
   filename :      name of file containing sql CREATE TABLE
                   statements.
   templatename :  name of the table specified by the CREATE
                   TABLE statement.
   tablename :     table name to use when actually creating this.
                   May be different from template table name.
   options :       Options from CreateTableOptions.               */
PSSQL_PROC( int, SQLCreateTableEx )(PODBC odbc, CTEXTSTR filename, CTEXTSTR templatename, CTEXTSTR tablename, uint32_t options );
/* <combine sack::sql::SQLCreateTableEx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@uint32_t>
   \ \                                                                        */
#define SQLCreateTable( odbc, file, table ) SQLCreateTableEx(odbc,file,table,table,0)
/* Creates a table in a database by reading an external file
   containing the table definition. It can also perform
   iterative updates to table structure if the template
   definition adds or deletes columns.
   Parameters
   filename :      filename to read the template from
   templatename :  name of the table in the create table template
                   statement.
   tablename :     the name of the table to create (may be
                   different than template)
   options :       Options from CreateTableOptions.
   Returns
   TRUE if success.
   FALSE if failure. (No further information)                     */
PSSQL_PROC( int, CreateTableEx )( CTEXTSTR filename, CTEXTSTR templatename, CTEXTSTR tablename, uint32_t options );
/* <combine sack::sql::CreateTableEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@uint32_t>
   \ \                                                               */
#define CreateTable( file, table ) CreateTableEx(file,table,table,0)
// results in a static buffer with escapes filled in for characterws
// which would otherwise conflict with string punctuators.
PSSQL_PROC( TEXTSTR ,EscapeStringEx )( CTEXTSTR name DBG_PASS );
/* <combine sack::sql::EscapeStringEx@CTEXTSTR name>
   \ \                                               */
#define EscapeString(s) EscapeStringEx( s DBG_SRC )
/* <combine sack::sql::EscapeStringEx@CTEXTSTR name>
   \ \                                               */
#define EscapeStringOpt(s,q) EscapeSQLBinaryExx( NULL,s,StrLen(s),NULL, q DBG_SRC )
/* \ \
   Parameters
   odbc :  connection to escape the string appropriately for. Different
           database engines require different string escapes.
   name :  string to escape
   Returns
   a TEXTSTR that is the content of the string passed properly
   escaped.
   it is appropriate to Release( result );
   Example
   This is difficult to describe coorectly, since in C, you have
   to do escaping on the parameters anyhow....
   <code lang="c++">
   {
       TEXTSTR result = EscapeSQLString( "\\"test \\'escape\\'" );
       printf( "original : %s\\n"
               "result   : %s\\n"
             , "\\"test \\'escape\\'"
             , \result );
   }
   </code>
   \Output
   <code lang="c++">
   original : "test 'escape'
   \result   : \\"test \\'escape\\'
   </code>                                                              */
PSSQL_PROC( TEXTCHAR *,EscapeSQLStringEx )( PODBC odbc, CTEXTSTR name DBG_PASS );
/* <combine sack::sql::EscapeSQLStringEx@PODBC@CTEXTSTR name>
   \ \                                                        */
#define EscapeSQLString(odbc, s) EscapeSQLStringEx( odbc, s DBG_SRC )
// the following functions return an allcoated buffer which the application must Release()
PSSQL_PROC( TEXTSTR ,EscapeBinaryEx )( CTEXTSTR blob, uintptr_t bloblen DBG_PASS );
/* <combine sack::sql::EscapeBinaryEx@CTEXTSTR@uintptr_t bloblen>
   \ \                                                           */
#define EscapeBinary(b,bl) EscapeBinaryEx(b,bl DBG_SRC )
/* <combine sack::sql::EscapeBinaryEx@CTEXTSTR@uintptr_t bloblen>
   \ \                                                           */
#define EscapeBinaryOpt(b,bl,q) EscapeSQLBinaryExx(NULL,b,bl,NULL,q DBG_SRC )
/* <combine sack::sql::EscapeBinaryEx@CTEXTSTR@uintptr_t bloblen>
   \ \                                                           */
PSSQL_PROC( TEXTSTR,EscapeSQLBinaryExx )( PODBC odbc, CTEXTSTR blob, size_t bloblen, size_t *resultLen, LOGICAL bQuote DBG_PASS );
/* <combine sack::sql::EscapeBinaryEx@CTEXTSTR@uintptr_t bloblen>
   \ \                                                           */
//PSSQL_PROC( TEXTSTR,EscapeSQLBinaryEx )( PODBC odbc, CTEXTSTR blob, uintptr_t bloblen DBG_PASS );
/* <combine sack::sql::EscapeSQLBinaryEx@PODBC@CTEXTSTR@uintptr_t bloblen>
   \ \                                                                    */
#define EscapeSQLBinary(odbc,blob,len) EscapeSQLBinaryExx( odbc,blob,len, NULL, FALSE DBG_SRC )
/* <combine sack::sql::EscapeSQLBinaryEx@PODBC@CTEXTSTR@uintptr_t bloblen>
   \ \                                                                    */
#define EscapeSQLBinaryOpt(odbc,blob,len,q) EscapeSQLBinaryExx( odbc,blob,len,NULL,q DBG_SRC )
#define EscapeSQLBinaryLen(odbc,blob,len,resLen,q) EscapeSQLBinaryExx( odbc,blob,len,resLen, q DBG_SRC )
/* Remove escape sequences which are inserted into a text
   string. (for things like quotes and binary characters?)
   Parameters
   name :  string to remove string escapes from
   Returns
   a copy of the string without quotes. This result should be
   freed with Release when user is done with it.              */
PSSQL_PROC( TEXTSTR ,RevertEscapeString )( CTEXTSTR name );
/* Remove escape sequences which are inserted into a binary
   string.
   Parameters
   blob :     pointer to data to remove binary escape sequences
              from
   bloblen :  length of the data block to handle
   Returns
   a pointer to the string without escapes. (Even though it says
   binary, it's still to and from text?) This result should be
   freed with Release when user is done with it.                 */
PSSQL_PROC( TEXTSTR ,RevertEscapeBinary )( CTEXTSTR blob, size_t *bloblen );
/* Parse a Blob string stored as hex... that is text character
   0-9 and A-F.
   Parameters
   blob :    pointer to the string containing the blob string
   buffer :  target buffer for data
   buflen :  length of target buffer                           */
PSSQL_PROC( TEXTSTR , DeblobifyString )( CTEXTSTR blob, TEXTSTR buffer, size_t buflen );
/* parse the string passed as a date/time as returned from a
   MySQL database.
   Parameters
   timestring :     string to parse
   endtimestring :  pointer to a pointer to a string to receive
                    the position of the character after the
                    timestring.
   year :           pointer to an int that will receive the year
                    portion of the date
   month :          pointer to an int that will receive the month
                    portion of the date
   day :            pointer to an int that will receive the day
                    portion of the date
   hour :           pointer to an int that will receive the hours
                    portion of the date
   minute :         pointer to an int that will receive the
                    minutes portion of the date
   second :         pointer to an int that will receive the
                    second portion of the date
   Returns
   A true/false status whether the string passed was a valid
   time string (?).                                               */
PSSQL_PROC( int, ConvertDBTimeString )( CTEXTSTR timestring
                                      , CTEXTSTR *endtimestring
                                      , int *pyr, int *pmo, int *pdy
                                      , int *phr, int *pmn, int *psc );
#ifndef SQLPROXY_INCLUDE
/* Issue a command to a SQL database. Things like Update and
   Insert are commands.
   Parameters
   odbc :     database connection to perform the command on. If
              NULL uses the default global connection.
   command :  text string to send to the database to execute.
   Returns
   TRUE if the statement succeeds.
   FALSE if the statement fails. See FetchSQLError.             */
PSSQL_PROC( int, SQLCommandEx )( PODBC odbc, CTEXTSTR command DBG_PASS);
#endif
PSSQL_PROC( int, SQLCommandExx )(PODBC odbc, CTEXTSTR command, size_t commandLen DBG_PASS);
/* <combine sack::sql::SQLCommandEx@PODBC@CTEXTSTR command>
   \ \                                                      */
#define SQLCommand(o,c) SQLCommandEx(o,c DBG_SRC )
#define SQLCommandLen(o,c,len) SQLCommandExx(o,c,len DBG_SRC )
   /* Begin collecting insert statements for batch output.
   Parameters
   odbc :  database connection to start collecting inserts for */
PSSQL_PROC( int, SQLInsertBegin )( PODBC odbc );
/* Generate a SQL insert statement from a variable parameter
   list.
   Parameters
   odbc :   connection to generate an insert on
   table :  table to insert into
   args :   a list of fields.
   Remarks
   args each column is a set of 3 parameters; the first
   parameter is the name of the column to insert into, the
   second is a value 0 or 1 whether to quote the value or not,
   and a string pointer.
   Inserts may be batched together and flushed as a whole to the
   database connection.                                          */
PSSQL_PROC( int, vSQLInsert )( PODBC odbc, CTEXTSTR table, va_list args );
/* Generate an insert to the database. Inserts to a single table
   can be cached internally and flushed.
   Parameters
   odbc :   database connection to use
   table :  name of table to insert into
   ... :    sets of column paramters.                            */
PSSQL_PROC( int, SQLInsert )( PODBC odbc, CTEXTSTR table, ... );
PSSQL_PROC( int, DoSQLInsert )( CTEXTSTR table, ... );
/* Flushes all cached inserts collected on a database
   connection.
   Parameters
   odbc :  database connection to flush inserts       */
PSSQL_PROC( int, SQLInsertFlush )( PODBC odbc );
/* This was the original implementation, it returned the results
   as a comma separated list, with quotes around results that
   had commas in them, and quotes around empty strings to
   distinguish NULL result which is just ',,'.
   Parameters
   odbc :     database connection to do the query
   query :    the string query to do
   result\ :  address of a CTEXTSTR to get a comma seperated
              \result of the query in.
   Returns
   TRUE if the query succeeded
   FALSE if the query was in error. See FetchSQLError.
   Example
   <code lang="c++">
   PODBC odbc = NULL; // just use the default connection...
   CTEXTSTR result;
   DoSQLQuery( odbc, "select 1,2,3", &amp;result );
   printf( "result : %s" );
   </code>
   \Output
   <code lang="c++">
   \result : 1,2,3
   </code>
   See Also
   SQLRecordQuery                                                */
PSSQL_PROC( int, SQLQueryEx )( PODBC odbc, CTEXTSTR query, CTEXTSTR *result DBG_PASS);
/* <combine sack::sql::SQLQueryEx@PODBC@CTEXTSTR@CTEXTSTR *result>
   \ \                                                             */
#define SQLQuery(o,q,r) SQLQueryEx( o,q,r DBG_SRC )
/* <combine sack::sql::DoSQLRecordQueryf@int *@CTEXTSTR **@CTEXTSTR **@CTEXTSTR@...>
   \ \                                                                               */
PSSQL_PROC( int, SQLRecordQueryEx )( PODBC odbc
                                   , CTEXTSTR query
                                   , int *pnResult
                                   , CTEXTSTR **result
                                   , CTEXTSTR **fields DBG_PASS);
/* Do a SQL query on the default odbc connection. The first
   record results immediately if there are any records. Returns
   the results as an array of strings. If you know the select
   you are using .... "select a,b,c from xyz" then you know that
   this will have 3 columns resulting.
   Parameters
   odbc :     connection to do the query on.
   query :    query to execute.
   queryLength : actual length of the query (allows embedded NUL characters)
   columns :  pointer to an int to receive the number of columns
              in the result. (the user will know this based on
              the query issued usually, so it can be NULL to
              ignore parameter)
   result\ :  pointer to a pointer to strings... see example
   resultLengths : pointer to a size_t* that will contain an array of
              lengths of the result values.
   fields :   address of a pointer to strings which will get the
              field names
   Example
   See SQLRecordQueryf, but omit the database parameter.         */
PSSQL_PROC( int, SQLRecordQueryExx )( PODBC odbc
                                   , CTEXTSTR query
                                   , size_t queryLength
                                   , int *pnResult
                                   , CTEXTSTR **result
                                   , size_t **resultLengths
                                   , CTEXTSTR **fields
                                   DBG_PASS);
/* <combine sack::sql::SQLRecordQueryEx@PODBC@CTEXTSTR@int *@CTEXTSTR **@CTEXTSTR **fields>
   \ \                                                                                      */
#define SQLRecordQuery(o,q,prn,r,f) SQLRecordQueryEx( o,q,prn,r,f DBG_SRC )
/* <combine sack::sql::SQLRecordQueryExx@PODBC@CTEXTSTR@size_t@int *@CTEXTSTR **@size_t *@CTEXTSTR **fields>
   \ \                                                                                      */
#define SQLRecordQueryLen(o,q,ql,prn,r,rl,f) SQLRecordQueryExx( o,q,ql,prn,r,rl,f DBG_SRC )
   /* Gets the next result from a query.
   Parameters
   odbc :     database connection that the query was executed on
   result\ :  address of the result variable.
   Example
   See SQLRecordQueryf.                                          */
PSSQL_PROC( int, FetchSQLResult )( PODBC, CTEXTSTR *result );
/* Gets the next record result from the connection.
   Parameters
   odbc :     connection to get the result from; if NULL, uses
              \internal static connection.
   result\ :  address of a CTEXTSTR *; to set to an array of
              CTEXTSTR results.
   Remarks
   Values received are invalid after the next FetchSQLRecord or
   possibly other query.                                        */
PSSQL_PROC( int, FetchSQLRecord )( PODBC, CTEXTSTR **result );
/* Gets the last result on the specified ODBC connection.
   Parameters
   odbc :     connection to get the last error of
   result\ :  address of a string pointer to receive the error
              \result.
   Example
   <code lang="c++">
   {
      CTEXTSTR error;
      FetchSQLError( NULL, &amp;error );
   </code>
   <code>
      printf( "Error: %s", error );
   </code>
   <code lang="c++">
   }
   </code>                                                     */
PSSQL_PROC( int, FetchSQLError )( PODBC, CTEXTSTR *result );
#ifndef SQLPROXY_INCLUDE
/* Test if a database connection is open
   Parameters
   odbc :  database connection to check
   Returns
   TRUE if the connection is open and works.
   FALSE if the connection would not work because it is not
   connected.                                               */
PSSQL_PROC( int, IsSQLOpenEx )( PODBC DBG_PASS );
/* Test if a database connection is open
   Parameters
   odbc :  database connection to check
   Returns
   TRUE if the connection is open and works.
   FALSE if the connection would not work because it is not
   connected.                                               */
PSSQL_PROC( int, IsSQLOpen )( PODBC );
/* <combine sack::sql::IsSQLOpenEx@PODBC>
   \ \                                    */
#define IsSQLOpen(odbc) IsSQLOpenEx(odbc DBG_SRC )
/* An PODBC connection handles commands as a stack, this saves
   the current query state (that you want to still get results
   from), so you can start a new query within the outer query.
   Parameters
   odbc :  database connection to save the current query state. */
PSSQL_PROC( int, PushSQLQueryExEx )(PODBC DBG_PASS);
PSSQL_PROC( int, PushSQLQueryEx )(PODBC);
/* <combine sack::sql::PushSQLQueryExEx@PODBC>
   \ \                                         */
#define PushSQLQueryEx(odbc) PushSQLQueryExEx(odbc DBG_SRC )
// no application support for username/password, sorry, trust thy odbc layer, please
PSSQL_PROC( PODBC, ConnectToDatabase )( CTEXTSTR dsn );
PSSQL_PROC( PODBC, SQLGetODBC )( CTEXTSTR dsn );
PSSQL_PROC( PODBC, SQLGetODBCEx )( CTEXTSTR dsn, CTEXTSTR user, CTEXTSTR pass );
PSSQL_PROC( void, SQLDropODBC )( PODBC odbc );
PSSQL_PROC( void, SQLDropAndCloseODBC )( CTEXTSTR dsn );
#endif
// default parameter to require is the global flag RequireConnection from sql.config....
PSSQL_PROC( PODBC, ConnectToDatabaseExx )( CTEXTSTR DSN, LOGICAL bRequireConnection DBG_PASS );
PSSQL_PROC( PODBC, ConnectToDatabaseEx )( CTEXTSTR DSN, LOGICAL bRequireConnection );
#define ConnectToDatabaseEx( dsn, required ) ConnectToDatabaseExx( dsn, required DBG_SRC )
#define ConnectToDatabase( dsn ) ConnectToDatabaseExx( dsn, FALSE DBG_SRC )
/* Close a database connection. Releases all resources
   associated with the odbc connection.
   Parameters
   odbc :  connection to database to close. Should not be NULL.  */
PSSQL_PROC( void, CloseDatabase)(PODBC odbc );
// does a query responce kinda thing returning types.
// if( GetSQLTypes() ) while( GetSQLResult( &result ) && result )
PSSQL_PROC( int, GetSQLTypes )( void );
/* ODBC only (sqlite no support?). Gets the types of data that
   the ODBC connection supports.
   Parameters
   odbc :  database connection to get the types from.
   Example
   <code>
   PODBC odbc = NULL; // or do a ConnectToDatabsae
   CTEXTSTR result; // the singular line result
   if( FetchSQLTypes(odbc) )
       while( FetchSQLResult( &amp;result ) &amp;&amp; result )
       {
           printf( "Supported Type: %s\\n", result );
       }
   </code>
   <code lang="c++">
   if( GetSQLTypes() )
       while( GetSQLResult( &amp;result ) &amp;&amp; result )
   </code>
   <code>
       {
           printf( "Supported Type: %s\\n", result );
       }
   </code>                                                      */
PSSQL_PROC( int, FetchSQLTypes )( PODBC );
#define PSSQL_VARARG_PROC(a,b,c)  PSSQL_PROC(a,b)c; typedef a(CPROC * __f_##b)c; PSSQL_PROC( __f_##b, __##b )(DBG_VOIDPASS);
/* Do a SQL query on the default odbc connection. The first
   record results immediately if there are any records. Returns
   the results as an array of strings. If you know the select
   you are using .... "select a,b,c from xyz" then you know that
   this will have 3 columns resulting.
   Parameters
   columns :  pointer to an int to receive the number of columns
              in the result. (the user will know this based on
              the query issued usually, so it can be NULL to
              ignore parameter)
   result\ :  pointer to a pointer to strings... see example
   fields :   address of a pointer to strings which will get the
              field names
   fmt :      format string as is appropriate for vsnprintf
   .... :     extra arguments to pass to format string
   Example
   See SQLRecordQueryf, but omit the database parameter.         */
PSSQL_VARARG_PROC( int, DoSQLRecordQueryf ,( int *columns, CTEXTSTR **result, CTEXTSTR **fields, CTEXTSTR fmt, ... ) );
#define DoSQLRecordQueryf   (__DoSQLRecordQueryf( DBG_VOIDSRC ))
/* <combine sack::sql::SQLQueryf@PODBC@CTEXTSTR *@CTEXTSTR@...>
   \ \                                                          */
PSSQL_VARARG_PROC( int, DoSQLQueryf, ( CTEXTSTR *result, CTEXTSTR fmt, ... ) );
#define DoSQLQueryf   (__DoSQLQueryf( DBG_VOIDSRC ))
/* This does a command to the database as a formatted command.
   This allows the user to simply specify the command and
   \parameters, and not also maintain a buffer to build the
   string into before passing the string to the ODBC connection
   as a command.
   Parameters
   fmt :  format string appropriate for vsnprintf. ... \: extra
          \parameters to fill the format string.
   See Also
   SQLCommandf
   Returns
   TRUE if command success, else FALSE.
   if FALSE, can get the error from GetSQLError.
	*/
PSSQL_VARARG_PROC( int, DoSQLCommandf, ( CTEXTSTR fmt, ... ) );
#define DoSQLCommandf   (__DoSQLCommandf( DBG_VOIDSRC ))
/* Do a SQL query on the default odbc connection. The first
   record results immediately if there are any records. Returns
   the results as an array of strings. If you know the select
   you are using .... "select a,b,c from xyz" then you know that
   this will have 3 columns resulting.
   Parameters
   odbc :     database connection to perform the query on
   columns :  pointer to an int to receive the number of columns
              in the result. (the user will know this based on
              the query issued usually, so it can be NULL to
              ignore parameter)
   result\ :  pointer to a pointer to strings... see example
   fields :   address of a pointer to strings which will get the
              field names. May be ommited if you don't want to
              know the names. (is less work internally if this is
              not built).
   fmt :      format string as is appropriate for vsnprintf
   .... :     extra arguments to pass to format string
   Example
   <code lang="c++">
   PODBC odbc = ConnectToDatabase( "MySQL" );
   CTEXTSTR *results;
   CTEXTSTR *column_names;
   int columns;
   for( SQLRecordQueryf( odbc, &amp;columns, &amp;results, &amp;column_names
                       , "select a,b,c from %s where %s=%s"
                       , "table_name"
                       , "column_name"
                       , "'value'"
                       );
        results;
        FetchSQLRecord( odbc, &amp;results ) )
   {
      int n;
       // draw a seperator between rows returned
      printf( " ----- record data ----- \\n" );
      for( n = 0; n \< columns; n++ )
      {
         printf( "Result column '%s' = '%s'\\n", column_name[n], results[n] );
      }
   }
   CloseDatabase( odbc );
   </code>
   If the default connection is used, odbc can be NULL in the
   prior example, or the for staement could be
   <code>
   for( DoSQLRecordQueryf( &amp;columns, &amp;results, &amp;column_names
                         , "select a,b,c from %s where %s=%s"
                         , "table_name"
                         , "column_name"
                         , "'value'"
                         );
        results;
        GetSQLRecord( &amp;results ) )
   {
   }
   </code>                                                                     */
//PSSQL_PROC( int, SQLRecordQueryf )( PODBC odbc, int *columns, CTEXTSTR **result, CTEXTSTR **fields, CTEXTSTR fmt, ... );
PSSQL_VARARG_PROC( int, SQLRecordQueryf, ( PODBC odbc, int *columns, CTEXTSTR **result, CTEXTSTR **fields, CTEXTSTR fmt, ... ) );
#define SQLRecordQueryf   (__SQLRecordQueryf( DBG_VOIDSRC ))
PSSQL_VARARG_PROC( int, SQLRecordQueryf_v2, ( PODBC odbc, int *nResults, CTEXTSTR **result, size_t **resultLengths, CTEXTSTR **fields, CTEXTSTR fmt, ... ) );
#define SQLRecordQueryf_v2   (__SQLRecordQueryf_v2( DBG_VOIDSRC ))
/* This was the original implementation, it returned the results
   as a comma separated list, with quotes around results that
   had commas in them, and quotes around empty strings to
   distinguish NULL result which is just ',,'.
   Parameters
   odbc :     database connection to do the query
   result\ :  address of a CTEXTSTR to get a comma seperated
              \result of the query in.
   query :    the string query to do
   ... :      extra parameters for the query format string
   Returns
   TRUE if the query succeeded
   FALSE if the query was in error. See FetchSQLError.
   Example
   <code>
   PODBC odbc = NULL; // just use the default connection...
   CTEXTSTR result;
   DoSQLQueryf( odbc, &amp;result, "select %d,%d,%d", 1, 2, 3 );
   printf( "result : %s" );
   </code>
   \Output
   <code>
   \result : 1,2,3
   </code>
   See Also
   SQLRecordQueryf                                               */
PSSQL_VARARG_PROC( int, SQLQueryf ,( PODBC odbc, CTEXTSTR *result, CTEXTSTR fmt, ... ) );
#define SQLQueryf   (__SQLQueryf( DBG_VOIDSRC ))
/* This performs a command on a SQL connection.
   Parameters
   odbc :  database connection to do the command on
   fmt :   format string as appropriate for vsnprintf
   ... :   extra arguments as required by the format string
   Returns
   TRUE if command success, else FALSE.
   if FALSE, can get the error from FetchSQLError.
                                                            */
PSSQL_VARARG_PROC( int, SQLCommandf, ( PODBC odbc, CTEXTSTR fmt, ... ) );
#define SQLCommandf   (__SQLCommandf( DBG_VOIDSRC ))
/* Function signature for the callback when the SQL layer can
   log a status about a database connection (connection,
   disconnected, failed...) See SQLSetFeedbackHandler.        */
typedef void (CPROC *HandleSQLFeedback)(CTEXTSTR message);
// register a feedback message for startup messages
//  allows external bannering of status... perhaps this can handle failures
//  and disconnects also...
PSSQL_PROC( void, SQLSetFeedbackHandler )( HandleSQLFeedback handler );
/* Parses a CREATE TABLE statement and builds a PTABLE from it.
   Parameters
   cmd :         a CREATE TABLE sql command. It is a little
                 sqlite/mysql centric, and may fail on column
                 types for SQL Server.
   writestate :  if writestate is TRUE, a file called
                 'sparse.txt' will be generated with a C
                 structure of the Create Table statement passed. This
                 \file could then be used to copy into code, and
                 have a code\-static definition instead of going
                 from the create table statement.
   Returns
   a PTABLE which represents the create table statement.              */
PSSQL_PROC( PTABLE, GetFieldsInSQLEx )( CTEXTSTR cmd, int writestate DBG_PASS );
/* <combine sack::sql::GetFieldsInSQLEx@CTEXTSTR@int writestate>
   \ \                                                           */
#define GetFieldsInSQL(c,w) GetFieldsInSQLEx( c, w DBG_SRC )
//PSSQL_PROC( PTABLE, GetFieldsInSQL )( CTEXTSTR cmd, int writestate);
// this is used to destroy the table returned by GetFieldsInSQL
PSSQL_PROC( void, DestroySQLTable )( PTABLE table );
// allow setting and getting of a bit of user data associated with the PODBC...
// though this can result in memory losses at the moment, cause there is no notification
// that the PODBC has gone away, and that the user needs to remove his data...
PSSQL_PROC( uintptr_t, SQLGetUserData )( PODBC odbc );
/* A PODBC may have a user data assigned to it.
   Parameters
   odbc :  connection to set the data for; shouldn't be NULL.
   psv :   user data to assign to the database connection.
   See Also
   SQLGetUserData                                             */
PSSQL_PROC( void, SQLSetUserData )( PODBC odbc, uintptr_t );
/* Returns a text string GUID, the guid is saved in psersistant text space and will
   not be released or overwritten.  */
PSSQL_PROC( CTEXTSTR, GetGUID )( void );
/* Returns a text string GUID, This uses UuidCreateSequential  */
PSSQL_PROC( CTEXTSTR, GetSeqGUID )( void );
/* Returns a text string GUID, the guid is saved in psersistant text space and will
   not be released or overwritten.  This tring is the constant 0 guid */
PSSQL_PROC( CTEXTSTR, GuidZero )( void );
/* convert a string GUID to a binary representation of 16 bytes.
   litte_endian will byte-swap the grouped portions of numbers in a guid so they can be printed appropriately*/
PSSQL_PROC( uint8_t*, GetGUIDBinaryEx )( CTEXTSTR guid, LOGICAL litte_endian );
#define GetGUIDBinary(g) GetGUIDBinaryEx(g, TRUE )
struct guid_binary {
	union {
		struct {
			uint8_t bytes[16];
			uint8_t zero[2];
		} b;
		struct {
			uint32_t l1;
			uint16_t w1;
			uint16_t w2;
			uint16_t w3;
			uint64_t ll1;
		} d;
	} u;
};
// snprintf( buf, 256, guid_format, guid_param_pass(&guid_binary) )
// snprintf( buf, 256, guid_format, guid_param_pass(binary_buffer_result) )
#define guid_format WIDE("%08")_32fx WIDE("-%04")_16fx WIDE("-%04")_16fx WIDE("-%04")_16fx WIDE("-%012")_64fx
#define guid_param_pass(n) ((struct guid_binary*)(n))->u.d.l1,((struct guid_binary*)(n))->u.d.w1,((struct guid_binary*)(n))->u.d.w2,((struct guid_binary*)(n))->u.d.w3,((struct guid_binary*)(n))->u.d.ll1
/* some internal stub-proxy linkage for generating remote
   responders..
   This was work in progress for providing a msgsvr service to
   SQL. One of the implementations of this library was across a
   windows message queue using ATOM types to transport results
   and commands. Was going to implement this on the abstract
   msgqueue interface.                                          */
typedef struct responce_tag
{
	struct {
		BIT_FIELD bSingleLine : 1;
		BIT_FIELD bMultiLine : 1;
		BIT_FIELD bFields : 1;
	} flags;
	PVARTEXT result_single_line;
   int nLines;
	CTEXTSTR *pLines;
   CTEXTSTR *pFields;
} SQL_RESPONCE, *PSQL_RESPONCE;
/* *WORK IN PROGRESS* function call signature for callback method passed to
   RegisterResponceHandler.                              */
typedef void (CPROC *result_responder)( int responce
									  , PSQL_RESPONCE result );
/* *WORK IN PROGRESS*
   result_responder :  callback function to get called with sql
                       global status messages.
   See Also
   <link sack::sql::result_responder, Result Responder Type>    */
PSSQL_PROC( void, RegisterResponceHandler )( result_responder );
/* Thread protect means to use critical sections to protect this
   connection against multiple thread access. Recommended usage
   is to not use a PODBC with more than one thread in the first
   place.
   Parameters
   odbc :     connection to enable; if null, references the
              \internal static connection.
   bEnable :  TRUE to enable, FALSE to disable.                  */
PSSQL_PROC( void, SetSQLThreadProtect )( PODBC odbc, LOGICAL bEnable );
/* Enable using 'BEGIN TRANSACTION' and 'COMMIT' commands automatically
   around commands. If there is a lull of 500ms (1/2 second),
   then the commit automatically fires. SQLCommit can be called
   to trigger this process early.
   Parameters
   odbc :     connection to set auto transact on
   bEnable :  TRUE to enable, FALSE to disable.                         */
PSSQL_PROC( void, SetSQLAutoTransact )( PODBC odbc, LOGICAL bEnable );
/* Enable using 'BEGIN TRANSACTION' and 'COMMIT' commands automatically
   around commands. If there is a lull of 500ms (1/2 second),
   then the commit automatically fires. SQLCommit can be called
	to trigger this process early.
	if Callback is set, automatically enables AutoTransact
   if Callback is NULL, automatically clears AutoTransact
   Parameters
   odbc :     connection to set auto transact on
   callback :  not NULL to enable, NULL to disable.                         */
PSSQL_PROC( void, SetSQLAutoTransactCallback )( PODBC odbc, void (CPROC*callback)(uintptr_t,PODBC), uintptr_t psv );
/* Relevant for SQLite databases. After a certain period of
   inactivity the database is closed (allowing the file to be
   not-in-use during idle). PODBC odject remains valid, and
   connection to database is re-enabled on next usage.
   Parameters
   odbc :     connection to enable auto close behavior on
   bEnable :  TRUE to enable auto close FALSE to disable.     */
PSSQL_PROC( void, SetSQLAutoClose )( PODBC odbc, LOGICAL bEnable );
/* Relevant for SQLite databases. After a certain period of
   inactivity the database is issued a PRAGMA wal_checkpoint
   Parameters
   odbc :     connection to enable auto checkpoint behavior on
   bEnable :  TRUE to enable auto checkpoint FALSE to disable.     */
PSSQL_PROC( void, SetSQLAutoCheckpoint )( PODBC odbc, LOGICAL bEnable );
/* returns the current value of auto checkpoint mode on a conneciton
   Parameters
   odbc :     connection to enable auto checkpoint behavior on */
PSSQL_PROC( LOGICAL, GetSQLAutoCheckpoint )( PODBC odbc );
/* A function to apply a time offset for fiscal time
   calculations; sometimes the day doesn't end at midnight, but
   a shift might last until 5 in the morning.
   Parameters
   odbc :            connection to get the appropriate SQL
                     expression for
   BeginOfDayType :  name of the type of beginning of the day
   default_begin :   the default time when a day begins.
   Note
   default_begin is a format sort of like a time. If this is a
   simple integer 5 then it's 5:00am, if it's more than 100,
   then it's assumed to be hours and minutes so 530 would be
   5:30 in the monring. this is also stored in the option
   databse, so the default value can be overridden; if the SQL
   value has a ':' in it then it is parsed as hours and minutes.
   Negative time may be used to indicate that the day begins
   before the day ends (-2 would be day end at 10pm).            */
PSSQL_PROC( CTEXTSTR, GetSQLOffsetDate )( PODBC odbc, CTEXTSTR BeginOfDayType, int default_begin );
/* Performs a low level backup of one database to another.  This API supports
   sqlite3 connections ONLY.
   Parameters
   source :            original database to copy from
   dest :    database to copy to
   */
PSSQL_PROC( LOGICAL, BackupDatabase )( PODBC source, PODBC dest );
/* return the underlaying native connection handle of the database connection
 */
// deprecated during dev, instead added function hook exports
//PSSQL_PROC( POINTER, GetODBCHandle )( PODBC odbc );
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
#ifdef __cplusplus
SQL_NAMESPACE_END
#endif
struct sqlite3_value;
struct sqlite3_context;
#ifdef __cplusplus
SQL_NAMESPACE
#endif
PSSQL_PROC( int, PSSQL_AddSqliteFunction )( PODBC odbc
	, const char *name
	, void( *callUserFunction )( struct sqlite3_context*onwhat, int argc, struct sqlite3_value**argv )
	, void( *callUserDestroy )( void * )
	, int args
	, void *userData );
PSSQL_PROC( int, PSSQL_AddSqliteProcedure )( PODBC odbc
	, const char *name
	, void( *callUserFunction )( struct sqlite3_context*onwhat, int argc, struct sqlite3_value**argv )
	, void( *callUserDestroy )( void * )
	, int args
	, void *userData );
PSSQL_PROC( int, PSSQL_AddSqliteAggregate )( PODBC odbc
	, const char *name
	, void( *callStep )( struct sqlite3_context*onwhat, int argc, struct sqlite3_value**argv )
	, void( *callFinal )( struct sqlite3_context*onwhat )
	, void( *callUserDestroy )( void * )
	, int args
	, void *userData );
PSSQL_PROC( POINTER, PSSQL_GetSqliteFunctionData )( struct sqlite3_context*context );
PSSQL_PROC( void, PSSQL_ResultSqliteText )( struct sqlite3_context*context, const char *data, int dataLen, void (*done)(void*) );
PSSQL_PROC( void, PSSQL_ResultSqliteBlob )( struct sqlite3_context*context, const char *data, int dataLen, void (*done)(void*) );
PSSQL_PROC( void, PSSQL_ResultSqliteDouble )( struct sqlite3_context*context, double val );
PSSQL_PROC( void, PSSQL_ResultSqliteInt )( struct sqlite3_context*context, int val );
PSSQL_PROC( void, PSSQL_ResultSqliteInt64 )( struct sqlite3_context*context, int64_t val );
PSSQL_PROC( void, PSSQL_ResultSqliteNull )( struct sqlite3_context*context );
enum sqlite_data_types {
	PSSQL_TYPE_INTEGER= 1,
	PSSQL_TYPE_FLOAT= 2,
	PSSQL_TYPE_TEXT = 3,
	PSSQL_TYPE_BLOB  = 4,
	PSSQL_TYPE_NULL = 5,
};
PSSQL_PROC( enum sqlite_data_types, PSSQL_GetSqliteValueType )( struct sqlite3_value *val );
PSSQL_PROC( void, PSSQL_GetSqliteValueText )( struct sqlite3_value *val, const char **text, int *textLen );
PSSQL_PROC( void, PSSQL_GetSqliteValueBlob )( struct sqlite3_value *val, const char **text, int *textLen );
PSSQL_PROC( void, PSSQL_GetSqliteValueDouble )( struct sqlite3_value *val, double *result );
PSSQL_PROC( void, PSSQL_GetSqliteValueInt )( struct sqlite3_value *val, int *result );
PSSQL_PROC( void, PSSQL_GetSqliteValueInt64 )( struct sqlite3_value *val, int64_t *result );
PSSQL_PROC( const char *, PSSQL_GetColumnTableName )( PODBC odbc, int col );
PSSQL_PROC( const char *, PSSQL_GetColumnTableAliasName )( PODBC odbc, int col );
PSSQL_PROC( void, PSSQL_GetSqliteValue )( struct sqlite3_value *val, const char **text, int *textLen );
#endif
SQL_NAMESPACE_END
#ifdef __cplusplus
	using namespace sack::sql;
#endif
#endif
#if 0
#endif
// sqloptint.h leaves namespace open.
// these headers should really be collapsed.
#ifndef SQL_GET_OPTION_DEFINED
#define SQL_GET_OPTION_DEFINED
#ifdef __cplusplus
#define _OPTION_NAMESPACE namespace options {
#define _OPTION_NAMESPACE_END };
#define USE_OPTION_NAMESPACE	 using namespace sack::sql::options;
#else
#define _OPTION_NAMESPACE
#define _OPTION_NAMESPACE_END
#define USE_OPTION_NAMESPACE
#endif
SACK_NAMESPACE
   _SQL_NAMESPACE
	/* Contains methods for saving and recovering options from a
	   database. If enabled, will use a local option.db sqlite
	   database. Use EditOptions application to modify options. Can
	   use any database connection, but sql.config file will specify
	   'option.db' to start.                                         */
	_OPTION_NAMESPACE
#define SACK_OPTION_NAMESPACE SACK_NAMESPACE _SQL_NAMESPACE _OPTION_NAMESPACE
#define SACK_OPTION_NAMESPACE_END _OPTION_NAMESPACE_END _SQL_NAMESPACE_END SACK_NAMESPACE_END
#ifdef SQLGETOPTION_SOURCE
#define SQLGETOPTION_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SQLGETOPTION_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifndef __NO_INTERFACES__
   _INTERFACE_NAMESPACE
/* Defines a set of functions that can be registered as an
   interface, and the interface can be used for saving options. Module
   ideas might be to save into the windows registry system or
   into INI files.                                                     */
typedef struct option_interface_tag
{
   // these provide simple section, key, value queries.
	METHOD_PTR( size_t, GetPrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTSTR pBuffer, size_t nBuffer, CTEXTSTR pININame );
	METHOD_PTR( int32_t, GetPrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame );
	METHOD_PTR( size_t, GetProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTSTR pBuffer, size_t nBuffer );
	METHOD_PTR( int32_t, GetProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval );
   // these provide an additional level of abstraction - the ini file
	METHOD_PTR( LOGICAL, WritePrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile );
	METHOD_PTR( int32_t, WritePrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, CTEXTSTR pINIFile );
	METHOD_PTR( LOGICAL, WriteProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue );
	METHOD_PTR( int32_t, WriteProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value );
   // these offer(expose) the option to be quiet
	METHOD_PTR( size_t, GetPrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTSTR pBuffer, size_t nBuffer, CTEXTSTR pININame, LOGICAL bQuiet );
	METHOD_PTR( int32_t, GetPrivateProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame, LOGICAL bQuiet );
	METHOD_PTR( size_t, GetProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTSTR pBuffer, size_t nBuffer, LOGICAL bQuiet );
	METHOD_PTR( int32_t, GetProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval, LOGICAL bQuiet );
	METHOD_PTR( LOGICAL, WriteProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL flush );
	METHOD_PTR( LOGICAL, WritePrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL commit );
} *POPTION_INTERFACE;
#define GetOptionInterface() ((POPTION_INTERFACE)GetInterface( WIDE("options") ))
//POPTION_INTERFACE GetOptionInterface( void );
//void DropOptionInterface( POPTION_INTERFACE );
#ifndef DEFAULT_OPTION_INTERFACE
#define DEFAULT_OPTION_INTERFACE ((!pOptionInterface)?(pOptionInterface=GetOptionInterface()):pOptionInterface)
#ifdef USES_OPTION_INTERFACE
static POPTION_INTERFACE pOptionInterface;
#ifdef __WATCOMC__
static void UseInterface( void )
{
	// use the value of this function and set pOptionInterface with it
	// makes pOptionInterface marked as used so is UseInterface.
	// Visual Studio pucked on this because converting a function pointer to data pointer
   // but this function should never be called.
   pOptionInterface = (POPTION_INTERFACE)UseInterface;
}
#endif
#endif
#endif
   _INTERFACE_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::sql::options::Interface;
#endif
#endif
#define OptGetPrivateProfileString   METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetPrivateProfileString)
#define OptGetPrivateProfileInt      METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetPrivateProfileInt)
#define OptGetProfileString          METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetProfileString)
#define OptGetProfileInt             METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetProfileInt)
#define OptWritePrivateProfileString METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WritePrivateProfileString)
#define OptWritePrivateProfileInt    METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WritePrivateProfileInt)
#define OptWriteProfileString        METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WriteProfileString)
#define OptWriteProfileInt           METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WriteProfileInt)
#define OptGetPrivateProfileStringEx   METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetPrivateProfileStringEx)
#define OptGetPrivateProfileIntEx      METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetPrivateProfileIntEx)
#define OptGetProfileStringEx          METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetProfileStringEx)
#define OptGetProfileIntEx             METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetProfileIntEx)
#define OptWritePrivateProfileStringEx     METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WritePrivateProfileStringEx)
#define OptWriteProfileStringEx     METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WriteProfileStringEx)
SACK_OPTION_NAMESPACE_END
#endif
SACK_OPTION_NAMESPACE
typedef struct sack_option_tree_family_node *POPTION_TREE_NODE;
typedef struct sack_option_tree_family *POPTION_TREE;
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( size_t, SACK_GetPrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer, CTEXTSTR pININame );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int32_t, SACK_GetPrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( size_t, SACK_GetProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int, SACK_GetProfileBlob )( CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR **pBuffer, size_t *pnBuffer );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int, SACK_GetProfileBlobOdbc )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR **pBuffer, size_t *pnBuffer );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int32_t, SACK_GetProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval );
/* All gets eventually end up here. This function gets a value
   from a database. Functions which return an 'int' use this
   function, but has extra processing to convert the text into a
   number; also if the text is 'Y', or 'y' then the option's int
   value is 1.
   Parameters
   pSection :     Path of the option to retrieve.
   pOptname :     Actual option name to retrieve.
   pDefaultbuf :  Default value if the option doesn't exist
                  already.
   pBuffer :      Pointer to the buffer to get the result
   nBuffer :      size of the result buffer in characters (not
                  bytes).
   pININame :     This is the upper level name. If a function
                  does not have a pININame, then the name
                  "DEFAULT' is used. (pass NULL here for
                  non\-private)
   bQuiet :       Boolean, if configured to prompt the user for
                  option values, this overrides the default to
                  disable prompting.                             */
SQLGETOPTION_PROC( size_t, SACK_GetPrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer, CTEXTSTR pININame, LOGICAL bQuiet );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int32_t, SACK_GetPrivateProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame, LOGICAL bQuiet );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( size_t, SACK_GetProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer, LOGICAL bQuiet );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int32_t, SACK_GetProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval, LOGICAL bQuiet );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int32_t, SACK_WritePrivateProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, CTEXTSTR pINIFile, LOGICAL bQuiet );
SQLGETOPTION_PROC( LOGICAL, SACK_WritePrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL bFlush );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( LOGICAL, SACK_WriteProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIfile, LOGICAL flush );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int32_t, SACK_WriteProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, LOGICAL bQuiet );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( LOGICAL, SACK_WritePrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int32_t, SACK_WritePrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, CTEXTSTR pINIFile );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( LOGICAL, SACK_WriteProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( LOGICAL, SACK_WriteOptionString )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int, SACK_WriteProfileBlob )( CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int, SACK_WriteProfileBlobOdbc )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   returns boolean true/false whether the write worked or not.
   \ \                                                                                                            */
SQLGETOPTION_PROC( int, SACK_WritePrivateProfileBlob )( CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer, CTEXTSTR app );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   returns boolean true/false whether the write worked or not.
   \ \                                                                                                            */
SQLGETOPTION_PROC( int, SACK_WritePrivateProfileBlobOdbc )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer,  CTEXTSTR app);
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   returns boolean true/false whether the write worked or not.
   \ \                                                                                                            */
SQLGETOPTION_PROC( int32_t, SACK_WriteProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( size_t, SACK_GetPrivateProfileStringExxx )( PODBC odbc
																				, CTEXTSTR pSection
																				, CTEXTSTR pOptname
																				, CTEXTSTR pDefaultbuf
																				, TEXTCHAR *pBuffer
																				, size_t nBuffer
																				, CTEXTSTR pININame
																				, LOGICAL bQuiet
																				 DBG_PASS
																				);
#ifdef __NO_OPTIONS__
#define SACK_GetProfileInt( s,e,d ) (d)
#define SACK_GetProfileString( s,e,d,b,n ) ((d)?StrCpyEx( b,d,n ):0)
#endif
#define SACK_GetPrivateOptionString( odbc, section, option, default_buf, buf, buf_size, ini_name )	   SACK_GetPrivateProfileStringExxx( odbc, section, option, default_buf, buf, buf_size, ini_name, FALSE DBG_SRC )
#define SACK_GetPrivateOptionStringEx( odbc, section, option, default_buf, buf, buf_size, ini_name, quiet )      SACK_GetPrivateProfileStringExxx( odbc, section, option, default_buf, buf, buf_size, ini_name, quiet DBG_SRC )
#define SACK_GetOptionString( odbc, section, option, default_buf, buf, buf_size )      SACK_GetPrivateProfileStringExxx( odbc, section, option, default_buf, buf, buf_size, NULL, FALSE DBG_SRC )
#define SACK_GetOptionStringEx( odbc, section, option, default_buf, buf, buf_size, quiet )      SACK_GetPrivateProfileStringExxx( odbc, section, option, default_buf, buf, buf_size, NULL, quiet DBG_SRC )
SQLGETOPTION_PROC( int32_t, SACK_GetPrivateProfileIntExx )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame, LOGICAL bQuiet DBG_PASS );
#define SACK_GetPrivateOptionInt( odbc, section, option, default_val, ini_name )	   SACK_GetPrivateProfileIntExx( odbc, section, option, default_val, ini_name, FALSE DBG_SRC )
#define SACK_GetPrivateOptionIntEx( odbc, section, option, default_val, ini_name, quiet )      SACK_GetPrivateProfileIntExx( odbc, section, option, default_val, ini_name, quiet DBG_SRC )
#define SACK_GetOptionInt( odbc, section, option, default_val )      SACK_GetPrivateProfileIntExx( odbc, section, option, default_val, NULL, FALSE DBG_SRC )
#define SACK_GetOptionIntEx( odbc, section, option, default_val, quiet )      SACK_GetPrivateProfileIntExx( odbc, section, option, default_val, NULL, quiet DBG_SRC )
SQLGETOPTION_PROC( CTEXTSTR, GetSystemID )( void );
SQLGETOPTION_PROC( void, EnumOptions )( POPTION_TREE_NODE parent
					 , int (CPROC *Process)(uintptr_t psv, CTEXTSTR name, POPTION_TREE_NODE ID, int flags )
                , uintptr_t psvUser );
SQLGETOPTION_PROC( void, EnumOptionsEx )( PODBC odbc, POPTION_TREE_NODE parent
					 , int (CPROC *Process)(uintptr_t psv, CTEXTSTR name, POPTION_TREE_NODE ID, int flags )
                , uintptr_t psvUser );
SQLGETOPTION_PROC( POPTION_TREE, GetOptionTreeExxx )( PODBC odbc, PFAMILYTREE existing_tree DBG_PASS );
/* Sets the option database to use (does not prevent
   preload/deadstart code from using the old database) but this
   can be used for comparison utilities.
   Parameters
   odbc :  The PODBC connection to use.
   See Also
   PODBC                                                        */
SQLGETOPTION_PROC( POPTION_TREE, SetOptionDatabase )( PODBC odbc );
SQLGETOPTION_PROC( CTEXTSTR, GetDefaultOptionDatabaseDSN )( void );
SQLGETOPTION_PROC( void, SetOptionDatabaseOption )( PODBC odbc );
SQLGETOPTION_PROC( void, BeginBatchUpdate )( void );
SQLGETOPTION_PROC( void, EndBatchUpdate )( void );
SQLGETOPTION_PROC( POPTION_TREE_NODE, GetOptionIndexEx )( POPTION_TREE_NODE parent, const TEXTCHAR *file, const TEXTCHAR *pBranch, const TEXTCHAR *pValue, int bCreate, int bBypassParsing DBG_PASS );
SQLGETOPTION_PROC( POPTION_TREE_NODE, GetOptionIndexExx )( PODBC odbc, POPTION_TREE_NODE parent, CTEXTSTR program, const TEXTCHAR *file, const TEXTCHAR *pBranch, const TEXTCHAR *pValue, int bCreate, int bBypassParsing DBG_PASS );
#define GetOptionIndex(p,f,b,v) GetOptionIndexEx( p,f,b,v,FALSE,FALSE DBG_SRC )
SQLGETOPTION_PROC( size_t, GetOptionStringValueEx )( PODBC odbc, POPTION_TREE_NODE optval, TEXTCHAR **buffer, size_t *len DBG_PASS );
SQLGETOPTION_PROC( void,SetOptionStringValueEx )( PODBC odbc, POPTION_TREE_NODE node, CTEXTSTR value );
SQLGETOPTION_PROC( size_t, GetOptionStringValue )( POPTION_TREE_NODE optval, TEXTCHAR **buffer, size_t *len );
SQLGETOPTION_PROC( LOGICAL, SetOptionStringValue )( POPTION_TREE tree, POPTION_TREE_NODE optval, CTEXTSTR pValue );
SQLGETOPTION_PROC( void, DeleteOption )( POPTION_TREE_NODE iRoot );
SQLGETOPTION_PROC( void, DuplicateOption )( POPTION_TREE_NODE iRoot, CTEXTSTR pNewName );
 // flush the map cache.
SQLGETOPTION_PROC( void, ResetOptionMap )( PODBC odbc );
SQLGETOPTION_PROC( PODBC, GetOptionODBCEx )( CTEXTSTR dsn DBG_PASS );
SQLGETOPTION_PROC( void, DropOptionODBCEx )( PODBC odbc DBG_PASS );
SQLGETOPTION_PROC( PODBC, GetOptionODBC )( CTEXTSTR dsn );
SQLGETOPTION_PROC( void, DropOptionODBC )( PODBC odbc );
#define GetOptionODBC( b) GetOptionODBCEx( b DBG_SRC )
#define DropOptionODBC(a) DropOptionODBCEx( a DBG_SRC )
SQLGETOPTION_PROC( void, FindOptions )( PODBC odbc, PLIST *result_list, CTEXTSTR name );
_OPTION_NAMESPACE_END _SQL_NAMESPACE_END SACK_NAMESPACE_END
	USE_OPTION_NAMESPACE
#endif
#else
#  include <sack.h>
 // tolower on linux
//#include <filesys.h>
//#include <procreg.h>
//#include <salty_generator.h>
//#include <sack_vfs.h>
//#include <sqlgetoption.h>
#endif
SACK_VFS_NAMESPACE
//#define PARANOID_INIT
//#define DEBUG_TRACE_LOG
#ifdef DEBUG_TRACE_LOG
#define LoG( a,... ) lprintf( a,##__VA_ARGS__ )
#else
#define LoG( a,... )
#endif
/**************
  VFS_VERSION
     used to track migration of keys and keying methods.
  0x100 = version 1; SHORTKEY_LENGTH = 16
 **************/
#define VFS_VERSION     0x100
// 12 bits = 1 << 12 = 4096
#define BLOCK_SIZE_BITS 12
// BLOCKINDEX is either 4 or 8 bytes... sizeof( size_t )...
// all constants though should compile out to a single value... and just for grins went to 16 bit size_t and 0 shift... or 1 byte
#define BLOCK_SHIFT (BLOCK_SIZE_BITS-(sizeof(BLOCKINDEX)==16?4:sizeof(BLOCKINDEX)==8?3:sizeof(BLOCKINDEX)==4?2:sizeof(BLOCKINDEX)==2?1:0) )
#define BLOCK_SIZE (1<<BLOCK_SIZE_BITS)
#define BLOCK_MASK (BLOCK_SIZE-1)
#define BLOCKS_PER_BAT (BLOCK_SIZE/sizeof(BLOCKINDEX))
#define BLOCKS_PER_SECTOR (1 + (BLOCK_SIZE/sizeof(BLOCKINDEX)))
// per-sector perumation; needs to be a power of 2 (in bytes)
#define SHORTKEY_LENGTH 16
 // BLOCK_SIZE blocks...
typedef size_t BLOCKINDEX;
 // file position type
typedef size_t FPI;
enum block_cache_entries
{
	BLOCK_CACHE_DIRECTORY
	, BLOCK_CACHE_NAMES
	, BLOCK_CACHE_BAT
	, BLOCK_CACHE_DATAKEY
	, BLOCK_CACHE_FILE
	, BLOCK_CACHE_FILE_LAST = BLOCK_CACHE_FILE + 10
	, BLOCK_CACHE_COUNT
};
PREFIX_PACKED struct volume {
	const char * volname;
	struct disk *disk;
 // disk might be offset from diskReal because it's a .exe attached.
	struct disk *diskReal;
	//uint32_t dirents;  // constant 0
	//uint32_t nameents; // constant 1
	uintptr_t dwSize;
  // used for directory signatures
	const char * datakey;
	const char * userkey;
	const char * devkey;
	enum block_cache_entries curseg;
// cached segment with usekey[n]
	BLOCKINDEX _segment[BLOCK_CACHE_COUNT];
// associated with usekey[n]
	BLOCKINDEX segment[BLOCK_CACHE_COUNT];
	uint8_t fileCacheAge[BLOCK_CACHE_FILE_LAST - BLOCK_CACHE_FILE];
	uint8_t fileNextAge;
	struct random_context *entropy;
  // allow byte encrypting...
	uint8_t* key;
  // allow byte encrypting... key based on sector volume file index
	uint8_t* segkey;
  // signature of executable attached as header
	uint8_t* sigkey;
  // signature of executable attached as header
	uint8_t* sigsalt;
	size_t sigkeyLength;
 // composite key
	uint8_t* usekey[BLOCK_CACHE_COUNT];
 // when reopened file structures need to be updated also...
	PLIST files;
	LOGICAL read_only;
	LOGICAL external_memory;
	LOGICAL closed;
	uint32_t lock;
	uint8_t tmpSalt[16];
	uintptr_t clusterKeyVersion;
} PACKED;
PREFIX_PACKED struct directory_entry
{
  // name offset from beginning of disk
	FPI name_offset;
  // first block of data of the file
	BLOCKINDEX first_block;
  // how big the file is
	size_t filesize;
	//uint32_t filler;  // extra data(unused)
} PACKED;
#define VFS_DIRECTORY_ENTRIES ( BLOCK_SIZE/sizeof( struct directory_entry) )
struct disk
{
	// BAT is at 0 of every BLOCK_SIZE blocks (4097 total)
	// &BAT[0] == itself....
	// BAT[0] == first directory entry (actually next entry; first is always here)
	// BAT[1] == first name entry (actually next name block; first is known as here)
	// bat[BLOCK_SIZE] == NEXT_BAT[0]; NEXT_BAT = BAT + BLOCK_SIZE + 1024*BLOCK_SIZE;
	// bat[8192] == ... ( 0 + ( BLOCK_SIZE + BLOCKS_PER_BAT*BLOCK_SIZE ) * N >> 12 )
	BLOCKINDEX BAT[BLOCKS_PER_BAT];
	//struct directory_entry directory[BLOCK_SIZE/sizeof( struct directory_entry)]; // 256
	//char  names[BLOCK_SIZE/sizeof(char)];
	uint8_t  block_data[BLOCKS_PER_BAT][BLOCK_SIZE];
};
struct sack_vfs_file
{
  // has file size within
	struct directory_entry *entry;
	struct directory_entry dirent_key;
 // which volume this is in
	struct volume *vol;
	FPI fpi;
	BLOCKINDEX first_block;
 // this should be in-sync with current FPI always; plz
	BLOCKINDEX block;
  // someone already deleted this...
	LOGICAL delete_on_close;
};
#define TSEEK(type,v,o,c) ((type)vfs_SEEK(v,o,&c))
#define BTSEEK(type,v,o,c) ((type)vfs_BSEEK(v,o,&c))
#ifdef __GNUC__
#define HIDDEN __attribute__ ((visibility ("hidden")))
#else
#define HIDDEN
#endif
uintptr_t vfs_SEEK( struct volume *vol, FPI offset, enum block_cache_entries *cache_index ) HIDDEN;
uintptr_t vfs_BSEEK( struct volume *vol, BLOCKINDEX block, enum block_cache_entries *cache_index ) HIDDEN;
//BLOCKINDEX vfs_GetNextBlock( struct volume *vol, BLOCKINDEX block, int init, LOGICAL expand );
static struct {
	struct directory_entry zero_entkey;
	uint8_t zerokey[BLOCK_SIZE];
} l;
#define EOFBLOCK  (~(BLOCKINDEX)0)
#define EOBBLOCK  ((BLOCKINDEX)1)
#define GFB_INIT_NONE   0
#define GFB_INIT_DIRENT 1
#define GFB_INIT_NAMES  2
static BLOCKINDEX GetFreeBlock( struct volume *vol, int init );
static struct directory_entry * ScanDirectory( struct volume *vol, const char * filename, struct directory_entry *dirkey, int path_match );
static char mytolower( int c ) {	if( c == '\\' ) return '/'; return tolower( c ); }
// read the byte from namespace at offset; decrypt byte in-register
// compare against the filename bytes.
static int MaskStrCmp( struct volume *vol, const char * filename, FPI name_offset, int path_match ) {
	if( vol->key ) {
		int c;
		while(  ( c = ( ((uint8_t*)vol->disk)[name_offset] ^ vol->usekey[BLOCK_CACHE_NAMES][name_offset&BLOCK_MASK] ) )
			  && filename[0] ) {
			int del = mytolower(filename[0]) - mytolower(c);
			if( del ) return del;
			filename++;
			name_offset++;
			if( path_match && !filename[0] ) {
				c = ( ((uint8_t*)vol->disk)[name_offset] ^ vol->usekey[BLOCK_CACHE_NAMES][name_offset&BLOCK_MASK] );
				if( c == '/' || c == '\\' )
					return 0;
			}
		}
		// c will be 0 or filename will be 0...
		return filename[0] - c;
	} else {
		//LoG( "doesn't volume always have a key?" );
		if( path_match ) {
			int l;
			int r = StrCaseCmpEx( filename, (const char *)(((uint8_t*)vol->disk) + name_offset), l = strlen( filename ) );
			if( !r )
				if( ((const char *)(((uint8_t*)vol->disk) + name_offset))[l] == '/' || ((const char *)(((uint8_t*)vol->disk) + name_offset))[l] == '\\' )
					return 0;
				else
					return 1;
			return r;
		}
		else
			return StrCaseCmp( filename, (const char *)(((uint8_t*)vol->disk) + name_offset) );
	}
}
#ifdef DEBUG_TRACE_LOG
static void MaskStrCpy( char *output, size_t outlen, struct volume *vol, FPI name_offset ) {
	if( vol->key ) {
		int c;
		FPI name_start = name_offset;
		while(  ( c = ( ((uint8_t*)vol->disk)[name_offset] ^ vol->usekey[BLOCK_CACHE_NAMES][name_offset&BLOCK_MASK] ) ) ) {
			if( ( name_offset - name_start ) < outlen )
				output[name_offset-name_start] = c;
			name_offset++;
		}
		if( ( name_offset - name_start ) < outlen )
			output[name_offset-name_start] = 0;
		else
			output[outlen-1] = 0;
	} else {
		//LoG( "doesn't volume always have a key?" );
		StrCpyEx( output, (const char *)(((uint8_t*)vol->disk) + name_offset), outlen );
	}
}
#endif
static enum block_cache_entries UpdateSegmentKey( struct volume *vol, enum block_cache_entries cache_idx, BLOCKINDEX segment )
{
	if( !vol->key ) {
		vol->segment[cache_idx] = segment;
		return cache_idx;
	}
	if( cache_idx == BLOCK_CACHE_FILE ) {
		int n, m;
		int nLeast;
		uint8_t next = 0;
		for( n = 0; n < (BLOCK_CACHE_FILE_LAST - BLOCK_CACHE_FILE); n++ ) {
			if( vol->segment[cache_idx + n] == segment ) {
				cache_idx = (enum block_cache_entries)((cache_idx)+n);
				for( m = 0; m < (BLOCK_CACHE_FILE_LAST - BLOCK_CACHE_FILE); m++ ) {
					if( !vol->fileCacheAge[m] ) break;
					if( vol->fileCacheAge[m] > vol->fileCacheAge[n] )
						vol->fileCacheAge[m]--;
				}
				vol->fileCacheAge[n] = m;
				break;
			}
			if( !vol->fileCacheAge[n] ) {
				cache_idx = (enum block_cache_entries)((cache_idx)+n);
				for( m = 0; m < (BLOCK_CACHE_FILE_LAST - BLOCK_CACHE_FILE); m++ ) {
					if( !vol->fileCacheAge[m] ) break;
					if( vol->fileCacheAge[m] >( n + 1 ) )
						vol->fileCacheAge[m]--;
				}
				vol->fileCacheAge[n] = n + 1;
				break;
			}
			if( vol->fileCacheAge[n] == 1 ) nLeast = n;
		}
		if( n == (BLOCK_CACHE_FILE_LAST - BLOCK_CACHE_FILE) ) {
			for( n = 0; n < (BLOCK_CACHE_FILE_LAST - BLOCK_CACHE_FILE); n++ ) {
				vol->fileCacheAge[n]--;
			}
			vol->fileCacheAge[nLeast] = (BLOCK_CACHE_FILE_LAST - BLOCK_CACHE_FILE);
			cache_idx = (enum block_cache_entries)(BLOCK_CACHE_FILE + nLeast);
		}
	}
	vol->segment[cache_idx] = segment;
	if( vol->segment[cache_idx] == vol->_segment[cache_idx] )
		return cache_idx;
	SRG_ResetEntropy( vol->entropy );
	vol->_segment[cache_idx] = vol->segment[cache_idx];
  // so we know which 'segment[idx]' to use.
	vol->curseg = cache_idx;
	SRG_GetEntropyBuffer( vol->entropy, (uint32_t*)vol->segkey, SHORTKEY_LENGTH * 8 );
	{
		int n;
#ifdef __64__
		uint64_t* usekey = (uint64_t*)vol->usekey[cache_idx];
		uint64_t* volkey = (uint64_t*)vol->key;
		uint64_t* segkey = (uint64_t*)vol->segkey;
		for( n = 0; n < (BLOCK_SIZE / SHORTKEY_LENGTH); n++ ) {
			usekey[0] = volkey[0] ^ (segkey[0]);
			usekey[1] = volkey[1] ^ (segkey[1]);
			usekey += 2;
			volkey += 2;
		}
#else
		uint32_t* usekey = (uint32_t*)vol->usekey[cache_idx];
		uint32_t* volkey = (uint32_t*)vol->key;
		uint32_t* segkey = (uint32_t*)vol->segkey;
		for( n = 0; n < (BLOCK_SIZE / SHORTKEY_LENGTH); n++ ) {
			usekey[0] = volkey[0] ^ (segkey[0]);
			usekey[1] = volkey[1] ^ (segkey[1]);
			usekey[2] = volkey[2] ^ (segkey[2]);
			usekey[3] = volkey[3] ^ (segkey[3]);
			usekey += 4;
			volkey += 4;
		}
#endif
	}
	return cache_idx;
}
static LOGICAL ValidateBAT( struct volume *vol ) {
	BLOCKINDEX first_slab = 0;
	BLOCKINDEX slab = vol->dwSize / ( BLOCK_SIZE );
	BLOCKINDEX last_block = ( slab * BLOCKS_PER_BAT ) / BLOCKS_PER_SECTOR;
	BLOCKINDEX n;
	if( vol->key ) {
		for( n = first_slab; n < slab; n += BLOCKS_PER_SECTOR  ) {
			size_t m;
			BLOCKINDEX *BAT;
			BLOCKINDEX *blockKey;
			BAT = (BLOCKINDEX*)(((uint8_t*)vol->disk) + n * BLOCK_SIZE);
			blockKey = ((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT]);
			//vol->segment[BLOCK_CACHE_BAT] = n + 1;
			//while( LockedExchange( &vol->key_lock[BLOCK_CACHE_BAT], 1 ) ) Relinquish();
			UpdateSegmentKey( vol, BLOCK_CACHE_BAT, n + 1 );
			for( m = 0; m < BLOCKS_PER_BAT; m++ )
			{
				BLOCKINDEX block = BAT[0] ^ blockKey[0];
				BAT++; blockKey++;
				if( block == EOFBLOCK ) continue;
				if( block == EOBBLOCK ) break;
				if( block >= last_block ) return FALSE;
			}
			if( m < BLOCKS_PER_BAT ) break;
			//vol->key_lock[BLOCK_CACHE_BAT] = 0;
		}
	} else {
		for( n = first_slab; n < slab; n += BLOCKS_PER_SECTOR  ) {
			size_t m;
			BLOCKINDEX *BAT = (BLOCKINDEX*)(((uint8_t*)vol->disk) + n * BLOCK_SIZE);
			for( m = 0; m < BLOCKS_PER_BAT; m++ ) {
				BLOCKINDEX block = BAT[m];
				if( block == EOFBLOCK ) continue;
				if( block == EOBBLOCK ) break;
				if( block >= last_block ) return FALSE;
			}
			if( m < BLOCKS_PER_BAT ) break;
		}
	}
	if( !ScanDirectory( vol, NULL, NULL, 0 ) ) return FALSE;
	return TRUE;
}
//-------------------------------------------------------
// function to process a currently loaded program to get the
// data offset at the end of the executable.
static POINTER GetExtraData( POINTER block )
{
#ifdef WIN32
#  define Seek(a,b) (((uintptr_t)a)+(b))
	//uintptr_t source_memory_length = block_len;
	POINTER source_memory = block;
	{
		PIMAGE_DOS_HEADER source_dos_header = (PIMAGE_DOS_HEADER)source_memory;
		PIMAGE_NT_HEADERS source_nt_header = (PIMAGE_NT_HEADERS)Seek( source_memory, source_dos_header->e_lfanew );
		if( source_dos_header->e_magic != IMAGE_DOS_SIGNATURE ) {
			LoG( "Basic signature check failed; not a library" );
			return NULL;
		}
		if( source_nt_header->Signature != IMAGE_NT_SIGNATURE ) {
			LoG( "Basic NT signature check failed; not a library" );
			return NULL;
		}
		if( source_nt_header->FileHeader.SizeOfOptionalHeader )
		{
			if( source_nt_header->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC )
			{
				LoG( "Optional header signature is incorrect..." );
				return NULL;
			}
		}
		{
			int n;
			long FPISections = source_dos_header->e_lfanew
				+ sizeof( DWORD ) + sizeof( IMAGE_FILE_HEADER )
				+ source_nt_header->FileHeader.SizeOfOptionalHeader;
			PIMAGE_SECTION_HEADER source_section = (PIMAGE_SECTION_HEADER)Seek( source_memory, FPISections );
			uintptr_t dwSize = 0;
			uintptr_t newSize;
			source_section = (PIMAGE_SECTION_HEADER)Seek( source_memory, FPISections );
			for( n = 0; n < source_nt_header->FileHeader.NumberOfSections; n++ )
			{
				newSize = (source_section[n].PointerToRawData) + source_section[n].SizeOfRawData;
				if( newSize > dwSize )
					dwSize = newSize;
			}
 // pad 1 full block, plus all but 1 byte of a full block(round up)
			dwSize += (BLOCK_SIZE*2)-1;
 // mask off the low bits; floor result to block boundary
			dwSize &= ~(BLOCK_SIZE-1);
			return (POINTER)Seek( source_memory, dwSize );
		}
	}
#  undef Seek
#else
	// need to get elf size...
	return 0;
#endif
}
static void AddSalt2( uintptr_t psv, POINTER *salt, size_t *salt_size ) {
	struct datatype { void* start; size_t length; } *data = (struct datatype*)psv;
	(*salt_size) = data->length;
	(*salt) = (POINTER)data->start;
	// only need to make one pass of it....
	data->length = 0;
	data->start = NULL;
}
const uint8_t *sack_vfs_get_signature2( POINTER disk, POINTER diskReal ) {
	if( disk != diskReal ) {
		static uint8_t usekey[BLOCK_SIZE];
		static struct random_context *entropy;
		static struct datatype { void* start; size_t length; } data;
		data.start = diskReal;
		data.length = ((uintptr_t)disk - (uintptr_t)diskReal) - BLOCK_SIZE;
		if( !entropy ) entropy = SRG_CreateEntropy2( AddSalt2, (uintptr_t)&data );
		SRG_ResetEntropy( entropy );
		SRG_GetEntropyBuffer( entropy, (uint32_t*)usekey, BLOCK_SIZE*CHAR_BIT );
		return usekey;
	}
	return NULL;
}
// add some space to the volume....
static LOGICAL ExpandVolume( struct volume *vol ) {
	LOGICAL created;
	LOGICAL path_checked = FALSE;
	struct disk* new_disk;
	size_t oldsize = vol->dwSize;
	if( vol->read_only ) return TRUE;
	if( !vol->dwSize ) {
		{
			char *tmp = StrDup( vol->volname );
			char *dir = (char*)pathrchr( tmp );
			if( dir ) {
				dir[0] = 0;
				if( !IsPath( tmp ) ) MakePath( tmp );
			}
			Deallocate( char*, tmp );
		}
		new_disk = (struct disk*)OpenSpaceExx( NULL, vol->volname, 0, &vol->dwSize, &created );
		if( new_disk && vol->dwSize ) {
			vol->diskReal = new_disk;
#ifdef WIN32
			// elf has a different signature to check for .so extended data...
			struct disk *actual_disk;
			if( ((char*)new_disk)[0] == 'M' && ((char*)new_disk)[1] == 'Z' ) {
				actual_disk = (struct disk*)GetExtraData( new_disk );
				if( actual_disk ) {
					if( ( ( (uintptr_t)actual_disk - (uintptr_t)new_disk ) < vol->dwSize ) ) {
						const uint8_t *sig = sack_vfs_get_signature2( (POINTER)((uintptr_t)actual_disk-BLOCK_SIZE), new_disk );
						if( memcmp( sig, (POINTER)(((uintptr_t)actual_disk)-BLOCK_SIZE), BLOCK_SIZE ) ) {
							lprintf( "Signature failed comparison; the core has changed since it was attached" );
							CloseSpace( vol->diskReal );
							vol->diskReal = NULL;
							vol->dwSize = 0;
							return FALSE;
						}
						vol->dwSize -= ((uintptr_t)actual_disk - (uintptr_t)new_disk);
						new_disk = actual_disk;
					} else {
						lprintf( "Signature failed comparison; the core is not attached to anything." );
						CloseSpace( vol->diskReal );
						vol->diskReal = NULL;
						vol->dwSize = 0;
						return FALSE;
					}
				}
			}
#endif
			vol->disk = new_disk;
			if( created && vol->disk == vol->diskReal ) {
				((BLOCKINDEX*)(((uintptr_t)vol->disk) + 0))[0] = EOBBLOCK;
				((struct directory_entry*)(((uintptr_t)vol->disk) + BLOCK_SIZE))->first_block = 1;
			}
			return TRUE;
		}
		else {
			// really this is bad anyway.
			if( new_disk )
 // zero size result?, but with memory
				created = 1;
		}
	}
	if( oldsize ) CloseSpace( vol->diskReal );
	vol->dwSize += ((uintptr_t)vol->disk - (uintptr_t)vol->diskReal);
	// a BAT plus the sectors it references... ( BLOCKS_PER_BAT + 1 ) * BLOCK_SIZE
	vol->dwSize += BLOCKS_PER_SECTOR*BLOCK_SIZE;
	new_disk = (struct disk*)OpenSpaceExx( NULL, vol->volname, 0, &vol->dwSize, &created );
	LoG( "created expanded volume: %p from %p size:%" _size_f, new_disk, vol->disk, vol->dwSize );
	if( new_disk && new_disk != vol->disk ) {
		INDEX idx;
		struct sack_vfs_file *file;
		vol->diskReal = new_disk;
#ifdef WIN32
		// elf has a different signature to check for .so extended data...
		{
			struct disk *actual_disk;
			if( ((char*)new_disk)[0] == 'M' && ((char*)new_disk)[1] == 'Z' ) {
				actual_disk = (struct disk*)GetExtraData( new_disk );
				if( actual_disk ) {
					const uint8_t *sig = sack_vfs_get_signature2( (POINTER)((uintptr_t)actual_disk-BLOCK_SIZE), new_disk );
					if( memcmp( sig, (POINTER)(((uintptr_t)actual_disk)-BLOCK_SIZE), BLOCK_SIZE ) ) {
						lprintf( "Signature failed comparison; the core has changed since it was attached" );
						CloseSpace( vol->diskReal );
						vol->diskReal = NULL;
						vol->dwSize = 0;
						return FALSE;
					}
					vol->dwSize -= ((uintptr_t)actual_disk - (uintptr_t)new_disk);
					new_disk = actual_disk;
				}
			}
		}
#endif
		LIST_FORALL( vol->files, idx, struct sack_vfs_file *, file ) {
			file->entry = (struct directory_entry*)((uintptr_t)file->entry - (uintptr_t)vol->disk + (uintptr_t)new_disk);
		}
		vol->disk = new_disk;
	}
	if( vol->key ) {
		BLOCKINDEX first_slab = oldsize / ( BLOCK_SIZE );
		BLOCKINDEX slab = vol->dwSize / ( BLOCK_SIZE );
		BLOCKINDEX n;
		for( n = first_slab; n < slab; n++  ) {
			//vol->segment[BLOCK_CACHE_BAT] = n + 1;
			if( ( n % (BLOCKS_PER_SECTOR) ) == 0 )	 UpdateSegmentKey( vol, BLOCK_CACHE_BAT, n + 1 );
#ifdef PARANOID_INIT
			else SRG_GetEntropyBuffer( vol->entropy, (uint32_t*)vol->usekey[BLOCK_CACHE_BAT], BLOCK_SIZE * 8 );
#else
			else continue;
#endif
			//memcpy( ((uint8_t*)vol->disk) + n * BLOCK_SIZE, vol->usekey[BLOCK_CACHE_BAT], BLOCK_SIZE );
			((BLOCKINDEX*)(((uint8_t*)vol->disk) + n * BLOCK_SIZE))[0] = EOBBLOCK ^ ((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT])[0];
			memset( ((BLOCKINDEX*)(((uint8_t*)vol->disk) + n * BLOCK_SIZE))+1, 0, BLOCK_SIZE - sizeof( BLOCKINDEX ) );
		}
	}
	else if( !oldsize )  {
		memset( vol->disk, 0, vol->dwSize );
	} else if( oldsize )  {
		memset( ((uint8_t*)vol->disk) + oldsize, 0, vol->dwSize - oldsize );
	}
	if( !oldsize ) {
		// can't recover dirents and nameents dynamically; so just assume
		// use the GetFreeBlock because it will update encypted
		//vol->disk->BAT[0] = EOFBLOCK;  // allocate 1 directory entry block
		//vol->disk->BAT[1] = EOFBLOCK;  // allocate 1 name block
		if( created && vol->disk == vol->diskReal ) {
			UpdateSegmentKey( vol, BLOCK_CACHE_BAT, 1 );
			((BLOCKINDEX*)(((uintptr_t)vol->disk) + 0))[0] = EOBBLOCK ^ ((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT])[0];
		}
		/* vol->dirents = */
GetFreeBlock( vol, GFB_INIT_DIRENT );
		/* vol->nameents = */
GetFreeBlock( vol, GFB_INIT_NAMES );
	}
	return TRUE;
}
// shared with fuse module
uintptr_t vfs_SEEK( struct volume *vol, FPI offset, enum block_cache_entries *cache_index ) {
	while( offset >= vol->dwSize ) if( !ExpandVolume( vol ) ) return 0;
	if( vol->key ) {
		BLOCKINDEX seg = ( offset / BLOCK_SIZE ) + 1;
		if( seg != vol->segment[cache_index[0]] ) {
			//vol->segment[cache_index] = seg;
			cache_index[0] = UpdateSegmentKey( vol, cache_index[0], seg );
		}
	}
	return ((uintptr_t)vol->disk) + offset;
}
// shared with fuse module
uintptr_t vfs_BSEEK( struct volume *vol, BLOCKINDEX block, enum block_cache_entries *cache_index ) {
	BLOCKINDEX b = BLOCK_SIZE + (block >> BLOCK_SHIFT) * (BLOCKS_PER_SECTOR*BLOCK_SIZE) + ( block & (BLOCKS_PER_BAT-1) ) * BLOCK_SIZE;
	while( b >= vol->dwSize ) if( !ExpandVolume( vol ) ) return 0;
	if( vol->key ) {
		BLOCKINDEX seg = ( b / BLOCK_SIZE ) + 1;
		if( seg != vol->segment[cache_index[0]] ) {
			//vol->segment[cache_index] = seg;
			cache_index[0] = UpdateSegmentKey( vol, cache_index[0], seg );
		}
	}
	return ((uintptr_t)vol->disk) + b;
}
static BLOCKINDEX GetFreeBlock( struct volume *vol, int init )
{
	size_t n;
	int b = 0;
	enum block_cache_entries cache = BLOCK_CACHE_BAT;
	BLOCKINDEX *current_BAT = TSEEK( BLOCKINDEX*, vol, 0, cache );
	if( !current_BAT ) return 0;
	do
	{
		BLOCKINDEX check_val;
		BLOCKINDEX *blockKey;
		blockKey = ((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT]);
		for( n = 0; n < BLOCKS_PER_BAT; n++ )
		{
			check_val = current_BAT[0] ^ blockKey[0];
			if( !check_val || (check_val == 1) )
			{
				// mark it as claimed; will be enf of file marker...
				// adn thsi result will overwrite previous EOF.
				current_BAT[0] = EOFBLOCK ^ blockKey[0];
				if( init )
				{
					enum block_cache_entries cache;
					cache = UpdateSegmentKey( vol, BLOCK_CACHE_FILE, b * (BLOCKS_PER_SECTOR)+n + 1 + 1 );
					while( ((vol->segment[cache]-1)*BLOCK_SIZE) > vol->dwSize ){
						LoG( "looping to get a size %d", ((vol->segment[cache]-1)*BLOCK_SIZE) );
						if( !ExpandVolume( vol ) ) return 0;
					}
					if( init == GFB_INIT_DIRENT )
						((struct directory_entry*)(((uint8_t*)vol->disk) + (vol->segment[cache]-1) * BLOCK_SIZE))[0].first_block = 1^((struct directory_entry*)vol->usekey[cache])->first_block;
					else if( init == GFB_INIT_NAMES )
						((char*)(((uint8_t*)vol->disk) + (vol->segment[cache]-1) * BLOCK_SIZE))[0] = ((char*)vol->usekey[cache])[0];
					//else
					//	memcpy( ((uint8_t*)vol->disk) + (vol->segment[cache]-1) * BLOCK_SIZE, vol->usekey[cache], BLOCK_SIZE );
				}
				if( (check_val == EOBBLOCK) )
					if(n < (BLOCKS_PER_BAT-1))
						current_BAT[1] = EOBBLOCK ^ blockKey[1];
					else {
						current_BAT = TSEEK( BLOCKINDEX*, vol, (b + 1) * (BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
						blockKey = ((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT]);
						current_BAT[0] = EOBBLOCK ^ blockKey[0];
					}
				return b * BLOCKS_PER_BAT + n;
			}
			current_BAT++;
			blockKey++;
		}
		b++;
		current_BAT = TSEEK( BLOCKINDEX*, vol, b * ( BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
	}while( 1 );
}
static BLOCKINDEX vfs_GetNextBlock( struct volume *vol, BLOCKINDEX block, int init, LOGICAL expand ) {
	BLOCKINDEX sector = block >> BLOCK_SHIFT;
	enum block_cache_entries cache = BLOCK_CACHE_BAT;
	BLOCKINDEX *this_BAT = TSEEK( BLOCKINDEX *, vol, sector * (BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
	BLOCKINDEX seg;
	BLOCKINDEX check_val = (this_BAT[block & (BLOCKS_PER_BAT-1)]);
 // if this passes, later ones will also.
	if( !this_BAT ) return 0;
	seg = ( ((uintptr_t)this_BAT - (uintptr_t)vol->disk) / BLOCK_SIZE ) + 1;
	if( seg != vol->segment[BLOCK_CACHE_BAT] ) {
		//vol->segment[BLOCK_CACHE_BAT] = seg;
		UpdateSegmentKey( vol, BLOCK_CACHE_BAT, seg );
	}
	check_val ^= ((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT])[block & (BLOCKS_PER_BAT-1)];
	if( check_val == EOFBLOCK ) {
		if( expand ) {
			BLOCKINDEX key = vol->key?((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT])[block & (BLOCKS_PER_BAT-1)]:0;
			check_val = GetFreeBlock( vol, init );
			// free block might have expanded...
			this_BAT = TSEEK( BLOCKINDEX*, vol, sector * ( BLOCKS_PER_SECTOR*BLOCK_SIZE ), cache );
			if( !this_BAT ) return 0;
			// segment could already be set from the GetFreeBlock...
			this_BAT[block & (BLOCKS_PER_BAT-1)] = check_val ^ key;
		}
	}
	return check_val;
}
static void AddSalt( uintptr_t psv, POINTER *salt, size_t *salt_size ) {
	struct volume *vol = (struct volume *)psv;
	if( vol->sigsalt ) {
		(*salt_size) = vol->sigkeyLength;
		(*salt) = (POINTER)vol->sigsalt;
		vol->sigsalt = NULL;
	}
	else if( vol->datakey ) {
		(*salt_size) = BLOCK_SIZE;
		(*salt) = (POINTER)vol->datakey;
		vol->datakey = NULL;
	}
	else if( vol->userkey ) {
		(*salt_size) = StrLen( vol->userkey );
		(*salt) = (POINTER)vol->userkey;
		vol->userkey = NULL;
	}
	else if( vol->devkey ) {
		(*salt_size) = StrLen( vol->devkey );
		(*salt) = (POINTER)vol->devkey;
		vol->devkey = NULL;
	}
	else if( vol->segment[vol->curseg] ) {
		BLOCKINDEX sector = vol->segment[vol->curseg];
		switch( vol->clusterKeyVersion ) {
		case 0:
			( *salt_size ) = sizeof( vol->segment[vol->curseg] );
			( *salt ) = &vol->segment[vol->curseg];
			break;
		case 1:
			memcpy( vol->tmpSalt, vol->key, 16 );
			vol->tmpSalt[sector & 0xF] ^= ( (uint8_t*)( &vol->segment[vol->curseg] ) )[0];
			vol->tmpSalt[( sector >> 4 ) & 0xF] ^= ( (uint8_t*)( &vol->segment[vol->curseg] ) )[1];
			vol->tmpSalt[( sector >> 8 ) & 0xF] ^= ( (uint8_t*)( &vol->segment[vol->curseg] ) )[2];
			vol->tmpSalt[( sector >> 12 ) & 0xF] ^= ( (uint8_t*)( &vol->segment[vol->curseg] ) )[3];
			( (BLOCKINDEX*)vol->tmpSalt )[0] ^= sector;
			( (BLOCKINDEX*)vol->tmpSalt )[1] ^= sector;
// sizeof( vol->segment[vol->curseg] );
			( *salt_size ) = 12;
			( *salt ) = vol->tmpSalt;
			break;
		}
	}
	else
		(*salt_size) = 0;
}
static void AssignKey( struct volume *vol, const char *key1, const char *key2 )
{
	vol->userkey = key1;
	vol->devkey = key2;
	if( key1 || key2 )
	{
		uintptr_t size = BLOCK_SIZE + BLOCK_SIZE * BLOCK_CACHE_COUNT + BLOCK_SIZE + SHORTKEY_LENGTH;
		int n;
		if( !vol->entropy )
			vol->entropy = SRG_CreateEntropy2( AddSalt, (uintptr_t)vol );
		else
			SRG_ResetEntropy( vol->entropy );
		vol->key = (uint8_t*)OpenSpace( NULL, NULL, &size );
		for( n = 0; n < BLOCK_CACHE_COUNT; n++ ) {
			vol->usekey[n] = vol->key + (n + 1) * BLOCK_SIZE;
			vol->segment[n] = 0;
		}
		vol->segkey = vol->key + BLOCK_SIZE * (BLOCK_CACHE_COUNT + 1);
		vol->sigkey = vol->key + BLOCK_SIZE * (BLOCK_CACHE_COUNT + 1) + SHORTKEY_LENGTH;
		vol->curseg = BLOCK_CACHE_DIRECTORY;
		vol->segment[BLOCK_CACHE_DIRECTORY] = 0;
		SRG_GetEntropyBuffer( vol->entropy, (uint32_t*)vol->key, BLOCK_SIZE * 8 );
	}
	else {
		int n;
		for( n = 0; n < BLOCK_CACHE_COUNT; n++ )
			vol->usekey[n] = l.zerokey;
		vol->segkey = l.zerokey;
		vol->sigkey = l.zerokey;
		vol->key = NULL;
	}
}
struct volume *sack_vfs_load_volume( const char * filepath )
{
	struct volume *vol = New( struct volume );
	memset( vol, 0, sizeof( struct volume ) );
	vol->volname = SaveText( filepath );
	AssignKey( vol, NULL, NULL );
	if( !ExpandVolume( vol ) || !ValidateBAT( vol ) ) { Deallocate( struct volume*, vol ); return NULL; }
	return vol;
}
struct volume *sack_vfs_load_crypt_volume( const char * filepath, uintptr_t version, const char * userkey, const char * devkey ) {
	struct volume *vol = New( struct volume );
	MemSet( vol, 0, sizeof( struct volume ) );
	if( !version ) version = 2;
	vol->clusterKeyVersion = version - 1;
	vol->volname = SaveText( filepath );
	vol->userkey = userkey;
	vol->devkey = devkey;
	AssignKey( vol, userkey, devkey );
	if( !ExpandVolume( vol ) || !ValidateBAT( vol ) ) { sack_vfs_unload_volume( vol ); return NULL; }
	return vol;
}
struct volume *sack_vfs_use_crypt_volume( POINTER memory, size_t sz, uintptr_t version, const char * userkey, const char * devkey ) {
	struct volume *vol = New( struct volume );
	MemSet( vol, 0, sizeof( struct volume ) );
	vol->read_only = 1;
	AssignKey( vol, userkey, devkey );
	if( !version ) version = 2;
	vol->clusterKeyVersion = version - 1;
	vol->external_memory = TRUE;
	vol->diskReal = (struct disk*)memory;
	vol->dwSize = sz;
#ifdef WIN32
	// elf has a different signature to check for .so extended data...
	struct disk *actual_disk;
	if( ((char*)memory)[0] == 'M' && ((char*)memory)[1] == 'Z' ) {
		actual_disk = (struct disk*)GetExtraData( memory );
		if( actual_disk ) {
			if( ( ( (uintptr_t)actual_disk - (uintptr_t)memory ) < vol->dwSize ) ) {
				const uint8_t *sig = sack_vfs_get_signature2( (POINTER)((uintptr_t)actual_disk-BLOCK_SIZE), memory );
				if( memcmp( sig, (POINTER)(((uintptr_t)actual_disk)-BLOCK_SIZE), BLOCK_SIZE ) ) {
					lprintf( "Signature failed comparison; the core has changed since it was attached" );
					vol->diskReal = NULL;
					vol->dwSize = 0;
					sack_vfs_unload_volume( vol );
					return FALSE;
				}
				vol->dwSize -= ((uintptr_t)actual_disk - (uintptr_t)memory);
				memory = (POINTER)actual_disk;
			} else {
				lprintf( "Signature failed comparison; the core is not attached to anything." );
				vol->diskReal = NULL;
				vol->disk = NULL;
				vol->dwSize = 0;
				sack_vfs_unload_volume( vol );
				return NULL;
			}
		}
	}
#endif
	vol->disk = (struct disk*)memory;
	if( !ValidateBAT( vol ) ) { sack_vfs_unload_volume( vol );  return NULL; }
	return vol;
}
void sack_vfs_unload_volume( struct volume * vol ) {
	INDEX idx;
	struct sack_vfs_file *file;
	LIST_FORALL( vol->files, idx, struct sack_vfs_file *, file )
		break;
	if( file ) {
		vol->closed = TRUE;
		return;
	}
	DeleteListEx( &vol->files DBG_SRC );
	if( !vol->external_memory )	CloseSpace( vol->diskReal );
	if( vol->key ) {
		Deallocate( uint8_t*, vol->key );
		SRG_DestroyEntropy( &vol->entropy );
	}
	Deallocate( struct volume*, vol );
}
void sack_vfs_shrink_volume( struct volume * vol ) {
	size_t n;
	int b = 0;
	//int found_free; // this block has free data; should be last BAT?
	BLOCKINDEX last_block = 0;
	int last_bat = 0;
	enum block_cache_entries cache = BLOCK_CACHE_BAT;
	BLOCKINDEX *current_BAT = TSEEK( BLOCKINDEX*, vol, 0, cache );
 // expand failed, tseek failed in response, so don't do anything
	if( !current_BAT ) return;
	do {
		BLOCKINDEX check_val;
		BLOCKINDEX *blockKey;
		blockKey = (BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT];
		for( n = 0; n < BLOCKS_PER_BAT; n++ ) {
			check_val = *(current_BAT++);
			if( vol->key )	check_val ^= *(blockKey++);
			if( check_val ) {
				last_bat = b;
				last_block = n;
			}
		}
		b++;
		if( b * ( BLOCKS_PER_SECTOR*BLOCK_SIZE) < vol->dwSize ) {
			current_BAT = TSEEK( BLOCKINDEX*, vol, b * ( BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
		} else
			break;
	}while( 1 );
	Deallocate( struct disk *, vol->diskReal );
	SetFileLength( vol->volname,
			((uintptr_t)vol->disk - (uintptr_t)vol->diskReal) +
			last_bat * BLOCKS_PER_SECTOR * BLOCK_SIZE + ( last_block + 1 + 1 )* BLOCK_SIZE );
	// setting 0 size will cause expand to do an initial open instead of expanding
	vol->dwSize = 0;
}
static void mask_block( struct volume *vol, size_t n ) {
	BLOCKINDEX b = ( 1 + (n >> BLOCK_SHIFT) * (BLOCKS_PER_SECTOR) + (n & (BLOCKS_PER_BAT - 1)));
	UpdateSegmentKey( vol, BLOCK_CACHE_DATAKEY, b + 1 );
	{
#ifdef __64__
		uint64_t* usekey = (uint64_t*)vol->usekey[BLOCK_CACHE_DATAKEY];
		uint64_t* block = (uint64_t*)(((uintptr_t)vol->disk) + b * BLOCK_SIZE );
		for( n = 0; n < (BLOCK_SIZE / 16); n++ ) {
			block[0] = block[0] ^ usekey[0];
			block[1] = block[1] ^ usekey[1];
			block += 2; usekey += 2;
		}
#else
		uint32_t* usekey = (uint32_t*)vol->usekey[BLOCK_CACHE_DATAKEY];
		uint32_t* block = (uint32_t*)(((uintptr_t)vol->disk) + b * BLOCK_SIZE );
		for( n = 0; n < (BLOCK_SIZE / 16); n++ ) {
			block[0] = block[0] ^ usekey[0];
			block[1] = block[1] ^ usekey[1];
			block[2] = block[2] ^ usekey[2];
			block[3] = block[3] ^ usekey[3];
			block += 4; usekey += 4;
		}
#endif
	}
}
LOGICAL sack_vfs_decrypt_volume( struct volume *vol )
{
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
 // volume is already decrypted, cannot remove key
	if( !vol->key ) { vol->lock = 0; return FALSE; }
	{
		enum block_cache_entries cache = BLOCK_CACHE_BAT;
		size_t n;
		BLOCKINDEX slab = vol->dwSize / ( BLOCKS_PER_SECTOR * BLOCK_SIZE );
		for( n = 0; n < slab; n++  ) {
			size_t m;
			BLOCKINDEX *blockKey;
// = (BLOCKINDEX*)(((uint8_t*)vol->disk) + n * (BLOCKS_PER_SECTOR * BLOCK_SIZE));
			BLOCKINDEX *block;
			block = TSEEK( BLOCKINDEX*, vol, n * (BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
			blockKey = ((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT]);
			for( m = 0; m < BLOCKS_PER_BAT; m++ ) {
				block[0] ^= blockKey[0];
				if( block[0] == EOBBLOCK ) break;
				else if( block[0] ) mask_block( vol, (n*BLOCKS_PER_BAT) + m );
				block++;
				blockKey++;
			}
			if( m < BLOCKS_PER_BAT ) break;
		}
	}
	AssignKey( vol, NULL, NULL );
	vol->lock = 0;
	return TRUE;
}
LOGICAL sack_vfs_encrypt_volume( struct volume *vol, uintptr_t version, CTEXTSTR key1, CTEXTSTR key2 ) {
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
 // volume already has a key, cannot apply new key
	if( vol->key ) { vol->lock = 0; return FALSE; }
	if( !version ) version = 2;
	vol->clusterKeyVersion = version-1;
	AssignKey( vol, key1, key2 );
	{
		int done;
		size_t n;
		enum block_cache_entries cache = BLOCK_CACHE_BAT;
		BLOCKINDEX slab = (vol->dwSize + (BLOCKS_PER_SECTOR*BLOCK_SIZE-1)) / ( BLOCKS_PER_SECTOR * BLOCK_SIZE );
		done = 0;
		for( n = 0; n < slab; n++  ) {
			size_t m;
			BLOCKINDEX *blockKey;
// = (BLOCKINDEX*)(((uint8_t*)vol->disk) + n * (BLOCKS_PER_SECTOR * BLOCK_SIZE));
			BLOCKINDEX *block;
			block = TSEEK( BLOCKINDEX*, vol, n * (BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
			blockKey = ((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT]);
			//vol->segment[BLOCK_CACHE_BAT] = n + 1;
			for( m = 0; m < BLOCKS_PER_BAT; m++ ) {
				if( block[0] == EOBBLOCK ) done = TRUE;
				else if( block[0] ) mask_block( vol, (n*BLOCKS_PER_BAT) + m );
				block[0] ^= blockKey[0];
				if( done ) break;
				block++;
				blockKey++;
			}
			if( done ) break;
		}
	}
	vol->lock = 0;
	return TRUE;
}
const char *sack_vfs_get_signature( struct volume *vol ) {
	static char signature[257];
	static const char *output = "0123456789ABCDEF";
	if( !vol )
		return NULL;
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
	{
		static BLOCKINDEX datakey[BLOCKS_PER_BAT];
		uint8_t* usekey = vol->key?vol->usekey[BLOCK_CACHE_DATAKEY]:l.zerokey;
		signature[256] = 0;
		memset( datakey, 0, sizeof( datakey ) );
		{
			{
				size_t n;
				BLOCKINDEX this_dir_block = 0;
				BLOCKINDEX next_dir_block;
				BLOCKINDEX *next_entries;
				do {
					enum block_cache_entries cache = BLOCK_CACHE_DATAKEY;
					next_entries = BTSEEK( BLOCKINDEX *, vol, this_dir_block, cache );
					for( n = 0; n < BLOCKS_PER_BAT; n++ )
						datakey[n] ^= next_entries[n] ^ ((BLOCKINDEX*)(((uint8_t*)usekey)))[n];
					next_dir_block = vfs_GetNextBlock( vol, this_dir_block, GFB_INIT_DIRENT, FALSE );
					if( this_dir_block == next_dir_block )
						DebugBreak();
					if( next_dir_block == 0 )
						DebugBreak();
					this_dir_block = next_dir_block;
				}
				while( next_dir_block != EOFBLOCK );
			}
		}
		if( !vol->entropy )
			vol->entropy = SRG_CreateEntropy2( AddSalt, (uintptr_t)vol );
		SRG_ResetEntropy( vol->entropy );
		vol->curseg = BLOCK_CACHE_DIRECTORY;
		vol->segment[vol->curseg] = 0;
		vol->datakey = (const char *)datakey;
		SRG_GetEntropyBuffer( vol->entropy, (uint32_t*)usekey, 128 * 8 );
		{
			int n;
			for( n = 0; n < 128; n++ ) {
				signature[n*2] = output[( usekey[n] >> 4 ) & 0xF];
				signature[n*2+1] = output[usekey[n] & 0xF];
			}
		}
	}
	vol->lock = 0;
	return signature;
}
struct directory_entry * ScanDirectory( struct volume *vol, const char * filename, struct directory_entry *dirkey, int path_match ) {
	size_t n;
	BLOCKINDEX this_dir_block = 0;
	BLOCKINDEX next_dir_block;
	struct directory_entry *next_entries;
	if( filename && filename[0] == '.' && filename[1] == '/' ) filename += 2;
	do {
		enum block_cache_entries cache = BLOCK_CACHE_DIRECTORY;
		next_entries = BTSEEK( struct directory_entry *, vol, this_dir_block, cache );
		for( n = 0; n < VFS_DIRECTORY_ENTRIES; n++ ) {
			BLOCKINDEX bi;
			enum block_cache_entries name_cache = BLOCK_CACHE_NAMES;
			struct directory_entry *entkey = ( vol->key)?((struct directory_entry *)vol->usekey[BLOCK_CACHE_DIRECTORY])+n:&l.zero_entkey;
			//const char * testname;
			FPI name_ofs = next_entries[n].name_offset ^ entkey->name_offset;
 // done.
			if( filename && !name_ofs )	return NULL;
			//LoG( "%d name_ofs = %" _size_f "(%" _size_f ") block = %d  vs %s"
			//   , n, name_ofs
			//   , next_entries[n].name_offset ^ entkey->name_offset
			//   , next_entries[n].first_block ^ entkey->first_block
			//   , filename );
			bi = next_entries[n].first_block ^ entkey->first_block;
			// if file is deleted; don't check it's name.
			if( !bi ) continue;
			// if file is end of directory, done sanning.
 // done.
			if( bi == 1 ) return filename?NULL:((struct directory_entry*)1);
			if( name_ofs > vol->dwSize ) { return NULL; }
			//testname =
			if( filename ) {
 // have to do the seek to the name block otherwise it might not be loaded.
				TSEEK( const char *, vol, name_ofs, name_cache );
				if( MaskStrCmp( vol, filename, name_ofs, path_match ) == 0 ) {
					if( dirkey ) dirkey[0] = (*entkey);
					LoG( "return found entry: %p (%" _size_f ":%" _size_f ") %s", next_entries + n, name_ofs, next_entries[n].first_block ^ dirkey->first_block, filename );
					return next_entries + n;
				}
			}
		}
		next_dir_block = vfs_GetNextBlock( vol, this_dir_block, FALSE, TRUE );
#ifdef _DEBUG
		if( this_dir_block == next_dir_block ) DebugBreak();
#endif
  // should have a last-entry before no more blocks....
		if( next_dir_block == 0 ) { DebugBreak(); return NULL; }
		this_dir_block = next_dir_block;
	}
	while( 1 );
}
// this results in an absolute disk position
static FPI SaveFileName( struct volume *vol, const char * filename ) {
	size_t n;
	BLOCKINDEX this_name_block = 1;
	while( 1 ) {
		enum block_cache_entries cache = BLOCK_CACHE_NAMES;
		TEXTSTR names = BTSEEK( TEXTSTR, vol, this_name_block, cache );
		unsigned char *name = (unsigned char*)names;
		while( name < ( (unsigned char*)names + BLOCK_SIZE ) ) {
			int c = name[0];
			if( vol->key ) c = c ^ vol->usekey[BLOCK_CACHE_NAMES][name-(unsigned char*)names];
			if( !c ) {
				size_t namelen;
				if( ( namelen = StrLen( filename ) ) < (size_t)( ( (unsigned char*)names + BLOCK_SIZE ) - name ) ) {
					LoG( "using unused entry for new file...%" _size_f "  %" _size_f " %s", this_name_block, (uintptr_t)name - (uintptr_t)names, filename );
					if( vol->key ) {
						for( n = 0; n < namelen + 1; n++ )
							name[n] = filename[n] ^ vol->usekey[BLOCK_CACHE_NAMES][n + (name-(unsigned char*)names)];
						if( (namelen + 1) < (size_t)(((unsigned char*)names + BLOCK_SIZE) - name) )
							name[n] = vol->usekey[BLOCK_CACHE_NAMES][n + (name - (unsigned char*)names)];
					} else
						memcpy( name, filename, ( namelen + 1 ) );
					return ((uintptr_t)name) - ((uintptr_t)vol->disk);
				}
			}
			else
				if( MaskStrCmp( vol, filename, name - (unsigned char*)vol->disk, 0 ) == 0 ) {
					LoG( "using existing entry for new file...%s", filename );
					return ((uintptr_t)name) - ((uintptr_t)vol->disk);
				}
			if( vol->key ) {
				while( ( name[0] ^ vol->usekey[BLOCK_CACHE_NAMES][name-(unsigned char*)names] ) ) name++;
				name++;
			} else
				name = name + StrLen( (const char*)name ) + 1;
			LoG( "new position is %" _size_f "  %" _size_f, this_name_block, (uintptr_t)name - (uintptr_t)names );
		}
		this_name_block = vfs_GetNextBlock( vol, this_name_block, GFB_INIT_DIRENT, TRUE );
		LoG( "Need a new directory block....", this_name_block );
	}
}
static struct directory_entry * GetNewDirectory( struct volume *vol, const char * filename ) {
	size_t n;
	BLOCKINDEX this_dir_block = 0;
	struct directory_entry *next_entries;
	do {
		enum block_cache_entries cache = BLOCK_CACHE_DIRECTORY;
		next_entries = BTSEEK( struct directory_entry *, vol, this_dir_block, cache );
		for( n = 0; n < VFS_DIRECTORY_ENTRIES; n++ ) {
			struct directory_entry *entkey = ( vol->key )?((struct directory_entry *)vol->usekey[cache])+n:&l.zero_entkey;
			struct directory_entry *ent = next_entries + n;
			FPI name_ofs = ent->name_offset ^ entkey->name_offset;
			BLOCKINDEX first_blk = ent->first_block ^ entkey->first_block;
			// not name_offset (end of list) or not first_block(free entry) use this entry
			if( name_ofs && (first_blk > 1) )  continue;
			name_ofs = SaveFileName( vol, filename ) ^ entkey->name_offset;
			first_blk = GetFreeBlock( vol, FALSE ) ^ entkey->first_block;
			// get free block might have expanded and moved the disk; reseek and get ent address
			next_entries = BTSEEK( struct directory_entry *, vol, this_dir_block, cache );
			ent = next_entries + n;
			ent->filesize = entkey->filesize;
			ent->name_offset = name_ofs;
			ent->first_block = first_blk;
			if( n < (VFS_DIRECTORY_ENTRIES - 1) ) {
				struct directory_entry *enttmp = next_entries + (n+1);
				enttmp->first_block = 1 ^ entkey[1].first_block;
			} else {
				// otherwise pre-init the next directory sector
				this_dir_block = vfs_GetNextBlock( vol, this_dir_block, GFB_INIT_DIRENT, TRUE );
			}
			return ent;
		}
		this_dir_block = vfs_GetNextBlock( vol, this_dir_block, GFB_INIT_DIRENT, TRUE );
	}
	while( 1 );
}
struct sack_vfs_file * CPROC sack_vfs_openfile( struct volume *vol, const char * filename ) {
	struct sack_vfs_file *file = New( struct sack_vfs_file );
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
	if( filename[0] == '.' && filename[1] == '/' ) filename += 2;
	LoG( "sack_vfs open %s = %p on %s", filename, file, vol->volname );
	file->entry = ScanDirectory( vol, filename, &file->dirent_key, 0 );
	if( !file->entry ) {
		if( vol->read_only ) { LoG( "Fail open: readonly" ); vol->lock = 0; Deallocate( struct sack_vfs_file *, file ); return NULL; }
		else file->entry = GetNewDirectory( vol, filename );
	}
	if( vol->key )
		memcpy( &file->dirent_key, vol->usekey[BLOCK_CACHE_DIRECTORY] + ( (uintptr_t)file->entry & BLOCK_MASK ), sizeof( struct directory_entry ) );
	else
		memset( &file->dirent_key, 0, sizeof( struct directory_entry ) );
	file->vol = vol;
	file->fpi = 0;
	file->delete_on_close = 0;
	file->first_block = file->block = file->entry->first_block ^ file->dirent_key.first_block;
	AddLink( &vol->files, file );
	vol->lock = 0;
	return file;
}
static struct sack_vfs_file * CPROC sack_vfs_open( uintptr_t psvInstance, const char * filename, const char *opts ) {
	return sack_vfs_openfile( (struct volume*)psvInstance, filename );
}
int CPROC sack_vfs_exists( struct volume *vol, const char * file ) {
	struct directory_entry entkey;
	struct directory_entry *ent;
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
	if( file[0] == '.' && file[1] == '/' ) file += 2;
	ent = ScanDirectory( vol, file, &entkey, 0 );
	//lprintf( "sack_vfs exists %s %s", ent?"ya":"no", file );
	vol->lock = 0;
	if( ent ) return TRUE;
	return FALSE;
}
size_t CPROC sack_vfs_tell( struct sack_vfs_file *file ) { return file->fpi; }
size_t CPROC sack_vfs_size( struct sack_vfs_file *file ) {	return file->entry->filesize ^ file->dirent_key.filesize; }
size_t CPROC sack_vfs_seek( struct sack_vfs_file *file, size_t pos, int whence )
{
	FPI old_fpi = file->fpi;
	if( whence == SEEK_SET ) file->fpi = pos;
	if( whence == SEEK_CUR ) file->fpi += pos;
	if( whence == SEEK_END ) file->fpi = ( file->entry->filesize  ^ file->dirent_key.filesize ) + pos;
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
	{
		if( ( file->fpi & ( ~BLOCK_MASK ) ) >= ( old_fpi & ( ~BLOCK_MASK ) ) ) {
			do {
				if( ( file->fpi & ( ~BLOCK_MASK ) ) == ( old_fpi & ( ~BLOCK_MASK ) ) ) {
					file->vol->lock = 0;
					return file->fpi;
				}
				file->block = vfs_GetNextBlock( file->vol, file->block, FALSE, TRUE );
				old_fpi += BLOCK_SIZE;
			} while( 1 );
		}
	}
	{
		size_t n = 0;
		BLOCKINDEX b = file->first_block;
		while( n * BLOCK_SIZE < ( pos & ~BLOCK_MASK ) ) {
			b = vfs_GetNextBlock( file->vol, b, FALSE, TRUE );
			n++;
		}
		file->block = b;
	}
	file->vol->lock = 0;
	return file->fpi;
}
static void MaskBlock( struct volume *vol, uint8_t* usekey, uint8_t* block, BLOCKINDEX block_ofs, size_t ofs, const char *data, size_t length ) {
	size_t n;
	block += block_ofs;
	usekey += ofs;
	if( vol->key )
		for( n = 0; n < length; n++ ) (*block++) = (*data++) ^ (*usekey++);
	else
		memcpy( block, data, length );
}
size_t CPROC sack_vfs_write( struct sack_vfs_file *file, const char * data, size_t length ) {
	size_t written = 0;
	size_t ofs = file->fpi & BLOCK_MASK;
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
	LoG( "Write to file %p %" _size_f "  @%" _size_f, file, length, ofs );
	if( ofs ) {
		enum block_cache_entries cache = BLOCK_CACHE_FILE;
		uint8_t* block = (uint8_t*)vfs_BSEEK( file->vol, file->block, &cache );
		if( length >= ( BLOCK_SIZE - ( ofs ) ) ) {
			MaskBlock( file->vol, file->vol->usekey[cache], block, ofs, ofs, data, BLOCK_SIZE - ofs );
			data += BLOCK_SIZE - ofs;
			written += BLOCK_SIZE - ofs;
			file->fpi += BLOCK_SIZE - ofs;
			if( file->fpi > ( file->entry->filesize ^ file->dirent_key.filesize ) )
				file->entry->filesize = file->fpi ^ file->dirent_key.filesize;
			file->block = vfs_GetNextBlock( file->vol, file->block, FALSE, TRUE );
			length -= BLOCK_SIZE - ofs;
		} else {
			MaskBlock( file->vol, file->vol->usekey[cache], block, ofs, ofs, data, length );
			data += length;
			written += length;
			file->fpi += length;
			if( file->fpi > ( file->entry->filesize ^ file->dirent_key.filesize ) )
				file->entry->filesize = file->fpi ^ file->dirent_key.filesize;
			length = 0;
		}
	}
	// if there's still length here, FPI is now on the start of blocks
	while( length )
	{
		enum block_cache_entries cache = BLOCK_CACHE_FILE;
		uint8_t* block = (uint8_t*)vfs_BSEEK( file->vol, file->block, &cache );
		if( length >= BLOCK_SIZE ) {
			MaskBlock( file->vol, file->vol->usekey[cache], block, 0, 0, data, BLOCK_SIZE - ofs );
			data += BLOCK_SIZE;
			written += BLOCK_SIZE;
			file->fpi += BLOCK_SIZE;
			if( file->fpi > ( file->entry->filesize ^ file->dirent_key.filesize ) )
				file->entry->filesize = file->fpi ^ file->dirent_key.filesize;
			file->block = vfs_GetNextBlock( file->vol, file->block, FALSE, TRUE );
			length -= BLOCK_SIZE;
		} else {
			MaskBlock( file->vol, file->vol->usekey[cache], block, 0, 0, data, length );
			data += length;
			written += length;
			file->fpi += length;
			if( file->fpi > ( file->entry->filesize ^ file->dirent_key.filesize ) )
				file->entry->filesize = file->fpi ^ file->dirent_key.filesize;
			length = 0;
		}
	}
	file->vol->lock = 0;
	return written;
}
size_t CPROC sack_vfs_read( struct sack_vfs_file *file, char * data, size_t length ) {
	size_t written = 0;
	size_t ofs = file->fpi & BLOCK_MASK;
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
	if( ( file->entry->filesize  ^ file->dirent_key.filesize ) < ( file->fpi + length ) ) {
		if( ( file->entry->filesize  ^ file->dirent_key.filesize ) < file->fpi )
			length = 0;
		else
			length = ( file->entry->filesize  ^ file->dirent_key.filesize ) - file->fpi;
	}
	if( !length ) {  file->vol->lock = 0; return 0; }
	if( ofs ) {
		enum block_cache_entries cache = BLOCK_CACHE_FILE;
		uint8_t* block = (uint8_t*)vfs_BSEEK( file->vol, file->block, &cache );
		if( length >= ( BLOCK_SIZE - ( ofs ) ) ) {
			MaskBlock( file->vol, file->vol->usekey[cache], (uint8_t*)data, 0, ofs, (const char*)(block+ofs), BLOCK_SIZE - ofs );
			written += BLOCK_SIZE - ofs;
			data += BLOCK_SIZE - ofs;
			length -= BLOCK_SIZE - ofs;
			file->fpi += BLOCK_SIZE - ofs;
			file->block = vfs_GetNextBlock( file->vol, file->block, FALSE, TRUE );
		} else {
			MaskBlock( file->vol, file->vol->usekey[cache], (uint8_t*)data, 0, ofs, (const char*)(block+ofs), length );
			written += length;
			file->fpi += length;
			length = 0;
		}
	}
	// if there's still length here, FPI is now on the start of blocks
	while( length ) {
		enum block_cache_entries cache = BLOCK_CACHE_FILE;
		uint8_t* block = (uint8_t*)vfs_BSEEK( file->vol, file->block, &cache );
		if( length >= BLOCK_SIZE ) {
			MaskBlock( file->vol, file->vol->usekey[cache], (uint8_t*)data, 0, 0, (const char*)block, BLOCK_SIZE - ofs );
			written += BLOCK_SIZE;
			data += BLOCK_SIZE;
			length -= BLOCK_SIZE;
			file->fpi += BLOCK_SIZE;
			file->block = vfs_GetNextBlock( file->vol, file->block, FALSE, TRUE );
		} else {
			MaskBlock( file->vol, file->vol->usekey[cache], (uint8_t*)data, 0, 0, (const char*)block, length );
			written += length;
			file->fpi += length;
			length = 0;
		}
	}
	file->vol->lock = 0;
	return written;
}
static void sack_vfs_unlink_file_entry( struct volume *vol, struct directory_entry *entry, struct directory_entry *entkey, BLOCKINDEX first_block ) {
	BLOCKINDEX block, _block;
	struct sack_vfs_file *file_found = NULL;
	struct sack_vfs_file *file;
	INDEX idx;
	LIST_FORALL( vol->files, idx, struct sack_vfs_file *, file  ) {
		if( file->entry == entry ) {
			file_found = file;
			//file->first_block = file->entry->first_block ^ file->dirent_key.first_block;
			file->delete_on_close = TRUE;
		}
	}
	if( file_found ) {
		LoG( "Marking physical directory deleted." );
		file_found->entry->first_block = file_found->dirent_key.first_block;
	}
	if( !file_found ) {
// entry->first_block ^ entkey->first_block;
		_block = block = first_block;
		LoG( "(marking physical deleted (again?)) entry starts at %d", block );
 // zero the block... keep the name.
		entry->first_block = entkey->first_block;
		// wipe out file chain BAT
		do {
			enum block_cache_entries cache = BLOCK_CACHE_BAT;
			BLOCKINDEX *this_BAT = TSEEK( BLOCKINDEX*, vol, ( ( block >> BLOCK_SHIFT ) * ( BLOCKS_PER_SECTOR*BLOCK_SIZE) ), cache );
			BLOCKINDEX _thiskey = ( vol->key )?((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT])[_block & (BLOCKS_PER_BAT-1)]:0;
			BLOCKINDEX b = BLOCK_SIZE + (block >> BLOCK_SHIFT) * (BLOCKS_PER_SECTOR*BLOCK_SIZE) + (block & (BLOCKS_PER_BAT - 1)) * BLOCK_SIZE;
			//uint8_t* blockData = (uint8_t*)vfs_BSEEK( vol, block, BLOCK_CACHE_DATAKEY );
			uint8_t* blockData = (uint8_t*)(((uintptr_t)vol->disk) + b);
			//LoG( "Clearing file datablock...%p", (uintptr_t)blockData - (uintptr_t)vol->disk );
			memset( blockData, 0, BLOCK_SIZE );
			block = vfs_GetNextBlock( vol, block, FALSE, FALSE );
			this_BAT[_block & (BLOCKS_PER_BAT-1)] = _thiskey;
			_block = block;
		} while( block != EOFBLOCK );
	}
}
static void shrinkBAT( struct sack_vfs_file *file ) {
	struct volume *vol = file->vol;
	struct directory_entry *entry = file->entry;
	struct directory_entry *entkey = &file->dirent_key;
	BLOCKINDEX block, _block;
	size_t bsize = 0;
	_block = block = entry->first_block ^ entkey->first_block;
	do {
		enum block_cache_entries cache = BLOCK_CACHE_BAT;
		enum block_cache_entries data_cache = BLOCK_CACHE_DATAKEY;
		BLOCKINDEX *this_BAT = TSEEK( BLOCKINDEX*, vol, ( ( block >> BLOCK_SHIFT ) * ( BLOCKS_PER_SECTOR*BLOCK_SIZE) ), cache );
		BLOCKINDEX _thiskey;
		_thiskey = ( vol->key )?((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT])[_block & (BLOCKS_PER_BAT-1)]:0;
		block = vfs_GetNextBlock( vol, block, FALSE, FALSE );
		if( bsize > (entry->filesize ^ entkey->filesize) ) {
			uint8_t* blockData = (uint8_t*)vfs_BSEEK( file->vol, _block, &data_cache );
			//LoG( "clearing a datablock after a file..." );
			memset( blockData, 0, BLOCK_SIZE );
			this_BAT[_block & (BLOCKS_PER_BAT-1)] = _thiskey;
		} else {
			bsize++;
			if( bsize > (entry->filesize ^ entkey->filesize) ) {
				uint8_t* blockData = (uint8_t*)vfs_BSEEK( file->vol, _block, &data_cache );
				//LoG( "clearing a partial datablock after a file..., %d, %d", BLOCK_SIZE-(entry->filesize & (BLOCK_SIZE-1)), ( entry->filesize & (BLOCK_SIZE-1)) );
				memset( blockData + ( entry->filesize & (BLOCK_SIZE-1)), 0, BLOCK_SIZE-(entry->filesize & (BLOCK_SIZE-1)) );
				this_BAT[_block & (BLOCKS_PER_BAT-1)] = ~_thiskey;
			}
		}
		_block = block;
	} while( block != EOFBLOCK );
}
size_t CPROC sack_vfs_truncate( struct sack_vfs_file *file ) { file->entry->filesize = file->fpi ^ file->dirent_key.filesize; shrinkBAT( file ); return file->fpi; }
int CPROC sack_vfs_close( struct sack_vfs_file *file ) {
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
#ifdef DEBUG_TRACE_LOG
	{
		enum block_cache_entries cache = BLOCK_CACHE_NAMES;
		static char fname[256];
		FPI name_ofs = file->entry->name_offset ^ file->dirent_key.name_offset;
 // have to do the seek to the name block otherwise it might not be loaded.
		TSEEK( const char *, file->vol, name_ofs, cache );
		MaskStrCpy( fname, sizeof( fname ), file->vol, name_ofs );
		LoG( "close file:%s(%p)", fname, file );
	}
#endif
	DeleteLink( &file->vol->files, file );
	if( file->delete_on_close ) sack_vfs_unlink_file_entry( file->vol, file->entry, &file->dirent_key, file->first_block );
	file->vol->lock = 0;
	if( file->vol->closed ) sack_vfs_unload_volume( file->vol );
	Deallocate( struct sack_vfs_file *, file );
	return 0;
}
int CPROC sack_vfs_unlink_file( struct volume *vol, const char * filename ) {
	int result = 0;
	struct directory_entry entkey;
	struct directory_entry *entry;
	if( !vol ) return 0;
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
	LoG( "unlink file:%s", filename );
	if( ( entry  = ScanDirectory( vol, filename, &entkey, 0 ) ) ) {
		sack_vfs_unlink_file_entry( vol, entry, &entkey, entry->first_block ^ entkey.first_block );
		result = 1;
	}
	vol->lock = 0;
	return result;
}
	/* noop */
int CPROC sack_vfs_flush( struct sack_vfs_file *file ) {	return 0; }
static LOGICAL CPROC sack_vfs_need_copy_write( void ) {	return FALSE; }
struct find_info {
	BLOCKINDEX this_dir_block;
	char filename[BLOCK_SIZE];
	struct volume *vol;
	CTEXTSTR base;
	size_t base_len;
	size_t filenamelen;
	size_t filesize;
	CTEXTSTR mask;
	size_t thisent;
};
struct find_info * CPROC sack_vfs_find_create_cursor(uintptr_t psvInst,const char *base,const char *mask )
{
	struct find_info *info = New( struct find_info );
	info->base = base;
	info->base_len = StrLen( base );
	info->mask = mask;
	info->vol = (struct volume *)psvInst;
	return info;
}
static int iterate_find( struct find_info *info ) {
	struct directory_entry *next_entries;
	size_t n;
	do {
		enum block_cache_entries cache = BLOCK_CACHE_DIRECTORY;
		enum block_cache_entries name_cache = BLOCK_CACHE_NAMES;
		next_entries = BTSEEK( struct directory_entry *, info->vol, info->this_dir_block, cache );
		for( n = info->thisent; n < VFS_DIRECTORY_ENTRIES; n++ ) {
			struct directory_entry *entkey = ( info->vol->key)?((struct directory_entry *)info->vol->usekey[cache])+n:&l.zero_entkey;
			FPI name_ofs = next_entries[n].name_offset ^ entkey->name_offset;
			if( !name_ofs )
				return 0;
			// if file is deleted; don't check it's name.
			if( !(next_entries[n].first_block ^ entkey->first_block ) )
				continue;
			if( (next_entries[n].first_block ^ entkey->first_block ) == 1 )
 // end of directory.
				return 0;
			info->filesize = next_entries[n].filesize ^ entkey->filesize;
			if( (name_ofs) > info->vol->dwSize ) {
				LoG( "corrupted volume." );
				return 0;
			}
			TSEEK( const char *, info->vol, name_ofs, name_cache );
			if( info->vol->key ) {
				int c;
				info->filenamelen = 0;
				while( ( c = ( ((uint8_t*)info->vol->disk)[name_ofs] ^ info->vol->usekey[name_cache][name_ofs&BLOCK_MASK] ) ) ) {
					info->filename[info->filenamelen++] = c;
					name_ofs++;
				}
				info->filename[info->filenamelen]	 = c;
				LoG( "Scan return filename: %s", info->filename );
				if( info->base
				    && ( info->base[0] != '.' && info->base_len != 1 )
				    && StrCaseCmpEx( info->base, info->filename, info->base_len ) )
					continue;
			} else {
				StrCpy( info->filename, (const char *)(((uint8_t*)info->vol->disk) + name_ofs) );
				LoG( "Scan return filename: %s", info->filename );
				if( info->base
				    && ( info->base[0] != '.' && info->base_len != 1 )
				    && StrCaseCmpEx( info->base, info->filename, info->base_len ) )
					continue;
			}
			info->thisent = n + 1;
			return 1;
		}
 // new block, set new starting index.
		info->thisent = 0;
		info->this_dir_block = vfs_GetNextBlock( info->vol, info->this_dir_block, FALSE, FALSE );
	}
	while( info->this_dir_block != EOFBLOCK );
	return 0;
}
int CPROC sack_vfs_find_first( struct find_info *info ) {
	info->this_dir_block = 0;
	info->thisent = 0;
	return iterate_find( info );
}
int CPROC sack_vfs_find_close( struct find_info *info ) { Deallocate( struct find_info*, info ); return 0; }
int CPROC sack_vfs_find_next( struct find_info *info ) { return iterate_find( info ); }
char * CPROC sack_vfs_find_get_name( struct find_info *info ) { return info->filename; }
size_t CPROC sack_vfs_find_get_size( struct find_info *info ) { return info->filesize; }
LOGICAL CPROC sack_vfs_find_is_directory( struct find_cursor *cursor ) { return FALSE; }
LOGICAL CPROC sack_vfs_is_directory( uintptr_t psvInstance, const char *path ) {
	struct volume *vol = (struct volume *)psvInstance;
	if( ScanDirectory( vol, path, NULL, 1 ) ) {
		return TRUE;
	}
	return FALSE;
}
static LOGICAL CPROC sack_vfs_rename( uintptr_t psvInstance, const char *original, const char *newname ) {
	struct volume *vol = (struct volume *)psvInstance;
	if( vol ) {
		struct directory_entry entkey;
		struct directory_entry *entry;
		while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
		if( ( entry  = ScanDirectory( vol, original, &entkey, 0 ) ) ) {
			struct directory_entry new_entkey;
			struct directory_entry *new_entry;
			if( ( new_entry = ScanDirectory( vol, newname, &new_entkey, 0 ) ) ) return FALSE;
			entry->name_offset = SaveFileName( vol, newname ) ^ entkey.name_offset;
			vol->lock = 0;
			return TRUE;
		}
		vol->lock = 0;
	}
	return FALSE;
}
static struct file_system_interface sack_vfs_fsi = {
                                                     (void*(CPROC*)(uintptr_t,const char *, const char*))sack_vfs_open
                                                   , (int(CPROC*)(void*))sack_vfs_close
                                                   , (size_t(CPROC*)(void*,char*,size_t))sack_vfs_read
                                                   , (size_t(CPROC*)(void*,const char*,size_t))sack_vfs_write
                                                   , (size_t(CPROC*)(void*,size_t,int))sack_vfs_seek
                                                   , (void(CPROC*)(void*))sack_vfs_truncate
                                                   , (int(CPROC*)(uintptr_t,const char*))sack_vfs_unlink_file
                                                   , (size_t(CPROC*)(void*))sack_vfs_size
                                                   , (size_t(CPROC*)(void*))sack_vfs_tell
                                                   , (int(CPROC*)(void*))sack_vfs_flush
                                                   , (int(CPROC*)(uintptr_t,const char*))sack_vfs_exists
                                                   , sack_vfs_need_copy_write
                                                   , (struct find_cursor*(CPROC*)(uintptr_t,const char *,const char *))             sack_vfs_find_create_cursor
                                                   , (int(CPROC*)(struct find_cursor*))             sack_vfs_find_first
                                                   , (int(CPROC*)(struct find_cursor*))             sack_vfs_find_close
                                                   , (int(CPROC*)(struct find_cursor*))             sack_vfs_find_next
                                                   , (char*(CPROC*)(struct find_cursor*))           sack_vfs_find_get_name
                                                   , (size_t(CPROC*)(struct find_cursor*))          sack_vfs_find_get_size
                                                   , sack_vfs_find_is_directory
                                                   , sack_vfs_is_directory
                                                   , sack_vfs_rename
                                                   };
PRIORITY_PRELOAD( Sack_VFS_Register, CONFIG_SCRIPT_PRELOAD_PRIORITY - 2 )
{
#ifdef ALT_VFS_NAME
#   define DEFAULT_VFS_NAME SACK_VFS_FILESYSTEM_NAME ".runner"
#else
#   define DEFAULT_VFS_NAME SACK_VFS_FILESYSTEM_NAME
#endif
	sack_register_filesystem_interface( DEFAULT_VFS_NAME, &sack_vfs_fsi );
}
PRIORITY_PRELOAD( Sack_VFS_RegisterDefaultFilesystem, SQL_PRELOAD_PRIORITY + 1 ) {
	if( SACK_GetProfileInt( GetProgramName(), "SACK/VFS/Mount VFS", 0 ) ) {
		struct volume *vol;
		TEXTCHAR volfile[256];
		TEXTSTR tmp;
		SACK_GetProfileString( GetProgramName(), "SACK/VFS/File", "*/../assets.svfs", volfile, 256 );
		tmp = ExpandPath( volfile );
		vol = sack_vfs_load_volume( tmp );
		Deallocate( TEXTSTR, tmp );
		sack_mount_filesystem( "sack_shmem", sack_get_filesystem_interface( DEFAULT_VFS_NAME )
		                     , 900, (uintptr_t)vol, TRUE );
	}
}
SACK_VFS_NAMESPACE_END
#define NO_UNICODE_C
#ifdef _MSC_VER
//#define NO_CRT_SECURE_WARNINGS
#endif
#define DEFINE_DEFAULT_IMAGE_INTERFACE
/* Crafted by Jim Buckeyne (c)1999-2006++ Freedom Collective
   Image building tracking, and simple manipulations.        */
// if the library is to have it's own idea of what
// an image is - then it should have included
// the definition for 'SFTFont', and 'Image' before
// including this... otherwise, it is assumed to
// be a client, and therefore does not need the information
// if a custom structure is used - then it MUST define
// it's ACTUAL x,y,width,height as the first 4 int32_t bit values.
#ifndef IMAGE_H
// multiple inclusion protection symbol
#define IMAGE_H
#if defined( _MSC_VER ) && defined( SACK_BAG_EXPORTS ) && 0
#define HAS_ASSEMBLY
#endif
/* Define COLOR type. Basically the image library regards color
   as 32 bits of data. User applications end up needing to
   specify colors in the correct method for the platform they
   are working on. This provides aliases to rearrange colors.
   For instance the colors on windows and the colors for OpenGL
   are not exactly the same. If the OpenGL driver is specified
   as the output device, the entire code would need to be
   rebuilt for specifying colors correctly for opengl. While
   otherwise they are both 32 bits, and peices work, they get
   very ugly colors output.
   See Also
   <link Colors>                                                */
#ifndef COLOR_STRUCTURE_DEFINED
/* An exclusion symbol for defining CDATA and color operations. */
#define COLOR_STRUCTURE_DEFINED
#ifdef __cplusplus
SACK_NAMESPACE
	namespace image {
#endif
		// byte index values for colors on the video buffer...
		enum color_byte_index {
 I_BLUE  = 0,
 I_GREEN = 1,
 I_RED   = 2,
 I_ALPHA = 3
		};
#if defined( __ANDROID__ ) || defined( _OPENGL_DRIVER )
#  define USE_OPENGL_COMPAT_COLORS
#endif
#if ( !defined( IMAGE_LIBRARY_SOURCE_MAIN ) && ( !defined( FORCE_NO_INTERFACE ) || defined( ALLOW_IMAGE_INTERFACE ) ) )      && !defined( FORCE_COLOR_MACROS )
#define Color( r,g,b ) MakeColor(r,g,b)
#define AColor( r,g,b,a ) MakeAlphaColor(r,g,b,a)
#define SetAlpha( rgb, a ) SetAlphaValue( rgb, a )
#define SetGreen( rgb, g ) SetGreeValue(rgb,g )
#define AlphaVal(color) GetAlphaValue( color )
#define RedVal(color)   GetRedValue(color)
#define GreenVal(color) GetGreenValue(color)
#define BlueVal(color)  GetBlueValue(color)
#else
#if defined( _OPENGL_DRIVER ) || defined( USE_OPENGL_COMPAT_COLORS )
#  define Color( r,g,b ) (((uint32_t)( ((uint8_t)(r))|((uint16_t)((uint8_t)(g))<<8))|(((uint32_t)((uint8_t)(b))<<16)))|0xFF000000)
#  define AColor( r,g,b,a ) (((uint32_t)( ((uint8_t)(r))|((uint16_t)((uint8_t)(g))<<8))|(((uint32_t)((uint8_t)(b))<<16)))|((a)<<24))
#  define SetAlpha( rgb, a ) ( ((rgb)&0x00FFFFFF) | ( (a)<<24 ) )
#  define SetGreen( rgb, g ) ( ((rgb)&0xFFFF00FF) | ( ((g)&0xFF)<<8 ) )
#  define SetBlue( rgb, b )  ( ((rgb)&0xFF00FFFF) | ( ((b)&0xFF)<<16 ) )
#  define SetRed( rgb, r )   ( ((rgb)&0xFFFFFF00) | ( ((r)&0xFF)<<0 ) )
#  define GLColor( c )  (c)
#  define AlphaVal(color) ((color&0xFF000000) >> 24)
#  define RedVal(color)   ((color&0x000000FF) >> 0)
#  define GreenVal(color) ((color&0x0000FF00) >> 8)
#  define BlueVal(color)  ((color&0x00FF0000) >> 16)
#else
#  ifdef _WIN64
#    define AND_FF &0xFF
#  else
/* This is a macro to cure a 64bit warning in visual studio. */
#    define AND_FF
#  endif
/* A macro to create a solid color from R G B coordinates.
   Example
   <code lang="c++">
   CDATA color1 = Color( 255,0,0 ); // Red only, so this is bright red
   CDATA color2 = Color( 0,255,0); // green only, this is bright green
   CDATA color3 = Color( 0,0,255); // blue only, this is birght blue
   CDATA color4 = Color(93,93,32); // this is probably a goldish grey
   </code>                                                             */
#define Color( r,g,b ) (((uint32_t)( ((uint8_t)((b)AND_FF))|((uint16_t)((uint8_t)((g))AND_FF)<<8))|(((uint32_t)((uint8_t)((r))AND_FF)<<16)))|0xFF000000)
/* Build a color with alpha specified. */
#define AColor( r,g,b,a ) (((uint32_t)( ((uint8_t)((b)AND_FF))|((uint16_t)((uint8_t)((g))AND_FF)<<8))|(((uint32_t)((uint8_t)((r))AND_FF)<<16)))|(((a)AND_FF)<<24))
/* Sets the alpha part of a color. (0-255 value, 0 being
   transparent, and 255 solid(opaque))
   Example
   <code lang="c++">
   CDATA color = BASE_COLOR_RED;
   CDATA hazy_color = SetAlpha( color, 128 );
   </code>
 */
#define SetAlpha( rgb, a ) ( ((rgb)&0x00FFFFFF) | ( (a)<<24 ) )
/* Sets the green channel of a color. Expects a value 0-255.  */
#define SetGreen( rgb, g ) ( ((rgb)&0xFFFF00FF) | ( ((g)&0x0000FF)<<8 ) )
/* Sets the blue channel of a color. Expects a value 0-255.  */
#define SetBlue( rgb, b ) ( ((rgb)&0xFFFFFF00) | ( ((b)&0x0000FF)<<0 ) )
/* Sets the red channel of a color. Expects a value 0-255.  */
#define SetRed( rgb, r ) ( ((rgb)&0xFF00FFFF) | ( ((r)&0x0000FF)<<16 ) )
/* Return a CDATA that is meant for output to OpenGL. */
#define GLColor( c )  (((c)&0xFF00FF00)|(((c)&0xFF0000)>>16)|(((c)&0x0000FF)<<16))
/* Get the alpha value of a color. This is a 0-255 unsigned
   byte.                                                    */
#define AlphaVal(color) (((color) >> 24) & 0xFF)
/* Get the red value of a color. This is a 0-255 unsigned byte. */
#define RedVal(color)   (((color) >> 16) & 0xFF)
/* Get the green value of a color. This is a 0-255 unsigned
   byte.                                                    */
#define GreenVal(color) (((color) >> 8) & 0xFF)
/* Get the blue value of a color. This is a 0-255 unsigned byte. */
#define BlueVal(color)  (((color)) & 0xFF)
#endif
 // IMAGE_LIBRARY_SOURCE
#endif
		/* a definition for a single color channel - for function replacements for ___Val macros*/
		typedef unsigned char COLOR_CHANNEL;
        /* a 4 byte array of color (not really used, we mostly went with CDATA and PCDATA instead of COLOR and PCOLOR */
		typedef COLOR_CHANNEL COLOR[4];
		// color data raw...
		typedef uint32_t CDATA;
		/* pointer to an array of 32 bit colors */
		typedef uint32_t *PCDATA;
		/* A Pointer to <link COLOR>. Probably an array of color (a
		 block of pixels for instance)                            */
		typedef COLOR *PCOLOR;
//-----------------------------------------------
// common color definitions....
//-----------------------------------------------
// both yellows need to be fixed.
#define BASE_COLOR_BLACK         Color( 0,0,0 )
#define BASE_COLOR_BLUE          Color( 0, 0, 128 )
#define BASE_COLOR_DARKBLUE          Color( 0, 0, 42 )
/* An opaque Green.
   See Also
   <link Colors>    */
#define BASE_COLOR_GREEN         Color( 0, 128, 0 )
/* An opaque cyan - kind of a light sky like blue.
   See Also
   <link Colors>                                   */
#define BASE_COLOR_CYAN          Color( 0, 128, 128 )
/* An opaque red.
   See Also
   <link Colors>  */
#define BASE_COLOR_RED           Color( 192, 32, 32 )
/* An opaque BROWN. Brown is dark yellow... so this might be
   more like a gold sort of color instead.
   See Also
   <link Colors>                                             */
#define BASE_COLOR_BROWN         Color( 140, 140, 0 )
#define BASE_COLOR_LIGHTBROWN         Color( 221, 221, 85 )
#define BASE_COLOR_MAGENTA       Color( 160, 0, 160 )
#define BASE_COLOR_LIGHTGREY     Color( 192, 192, 192 )
/* An opaque darker grey (gray?).
   See Also
   <link Colors>                  */
#define BASE_COLOR_DARKGREY      Color( 128, 128, 128 )
/* An opaque a bight or light color blue.
   See Also
   <link Colors>                          */
#define BASE_COLOR_LIGHTBLUE     Color( 0, 0, 255 )
/* An opaque lighter, brighter green color.
   See Also
   <link Colors>                            */
#define BASE_COLOR_LIGHTGREEN    Color( 0, 255, 0 )
/* An opaque a lighter, more bight cyan color.
   See Also
   <link Colors>                               */
#define BASE_COLOR_LIGHTCYAN     Color( 0, 255, 255 )
/* An opaque bright red.
   See Also
   <link Colors>         */
#define BASE_COLOR_LIGHTRED      Color( 255, 0, 0 )
/* An opaque Lighter pink sort of red-blue color.
   See Also
   <link Colors>                                  */
#define BASE_COLOR_LIGHTMAGENTA  Color( 255, 0, 255 )
/* An opaque bright yellow.
   See Also
   <link Colors>            */
#define BASE_COLOR_YELLOW        Color( 255, 255, 0 )
/* An opaque White.
   See Also
   <link Colors>    */
#define BASE_COLOR_WHITE         Color( 255, 255, 255 )
#define BASE_COLOR_ORANGE        Color( 204,96,7 )
#define BASE_COLOR_NICE_ORANGE   Color( 0xE9, 0x7D, 0x26 )
#define BASE_COLOR_PURPLE        Color( 0x7A, 0x11, 0x7C )
#ifdef __cplusplus
 //	 namespace image {
};
SACK_NAMESPACE_END
using namespace sack::image;
#endif
#endif
// $Log: colordef.h,v $
// Revision 1.4  2003/04/24 00:03:49  panther
// Added ColorAverage to image... Fixed a couple macros
//
// Revision 1.3  2003/03/25 08:38:11  panther
// Add logging
//
/* Defines a simple FRACTION type. Fractions are useful for
   scaling one value to another. These operations are handles
   continously. so iterating a fraction like 13 denominations of
   100 will be smooth.                                           */
#ifndef FRACTIONS_DEFINED
/* Multiple inclusion protection symbol. */
#define FRACTIONS_DEFINED
#ifdef __cplusplus
#  define _FRACTION_NAMESPACE namespace fraction {
#  define _FRACTION_NAMESPACE_END }
#  ifndef _MATH_NAMESPACE
#    define _MATH_NAMESPACE namespace math {
#  endif
#  define	 SACK_MATH_FRACTION_NAMESPACE_END } } }
#else
#  define _FRACTION_NAMESPACE
#  define _FRACTION_NAMESPACE_END
#  ifndef _MATH_NAMESPACE
#    define _MATH_NAMESPACE
#  endif
#  define	 SACK_MATH_FRACTION_NAMESPACE_END
#endif
SACK_NAMESPACE
	/* Namespace of custom math routines.  Contains operators
	 for Vectors and fractions. */
	_MATH_NAMESPACE
	/* Fraction namespace contains a PFRACTION type which is used to
   store integer fraction values. Provides for ration and
   proportion scaling. Can also represent fractions that contain
   a whole part and a fractional part (5 2/3 : five and
	two-thirds).                                                  */
	_FRACTION_NAMESPACE
/* Define the call type of the function. */
#define FRACTION_API CPROC
#  ifdef FRACTION_SOURCE
#    define FRACTION_PROC EXPORT_METHOD
#  else
/* Define the library linkage for a these functions. */
#    define FRACTION_PROC IMPORT_METHOD
#  endif
/* The faction type. Stores a fraction as integer
   numerator/denominator instead of a floating point scalar. */
/* Pointer to a <link sack::math::fraction::FRACTION, FRACTION>. */
/* The faction type. Stores a fraction as integer
   numerator/denominator instead of a floating point scalar. */
typedef struct fraction_tag {
	/* Numerator of the fraction. (This is the number on top of a
	   fraction.)                                                 */
	int numerator;
	/* Denominator of the fraction. (This is the number on bottom of
	   a fraction.) This specifies the denominations.                */
	int denominator;
} FRACTION, *PFRACTION;
#ifdef HAVE_ANONYMOUS_STRUCTURES
typedef struct coordpair_tag {
	union {
		FRACTION x;
		FRACTION width;
	};
	union {
		FRACTION y;
		FRACTION height;
	};
} COORDPAIR, *PCOORDPAIR;
#else
/* A coordinate pair is a 2 dimensional fraction expression. can
   be regarded as x, y or width,height. Each coordiante is a
   Fraction type.                                                */
typedef struct coordpair_tag {
	       /* The x part of the coordpair. */
	       FRACTION x;
	       /* The y part of the coordpair. */
	       FRACTION y;
} COORDPAIR, *PCOORDPAIR;
#endif
/* \ \
   Parameters
   fraction :     the fraction to set
   numerator :    numerator of the fraction
   demoninator :  denominator of the fraction */
#define SetFraction(f,n,d) ((((f).numerator=((int)(n)) ),((f).denominator=((int)(d)))),(f))
/* Sets the value of a FRACTION. This is passed as the whole
   number and the fraction.
   Parameters
   fraction :  the fraction to set
   w :         this is the whole number to set
   n :         numerator of remainder to set
   d :         denominator of fraction to set.
   Example
   Fraction f = 3 1/2;
   <code lang="c++">
   FRACTION f;
   SetFractionV( f, 3, 1, 2 );
   // the resulting fraction will be 7/2
   </code>                                                   */
#define SetFractionV(f,w,n,d) (  (d)?	 ((((f).numerator=((int)((n)*(w))) )	  ,((f).denominator=((int)(d)))),(f))	  :	 ((((f).numerator=((int)((w))) )	  ,((f).denominator=((int)(1)))),(f))  )
/* \ \
   Parameters
   base :    origin point (content is modified by adding offset
             to it)
   offset :  offset point                                       */
FRACTION_PROC  void FRACTION_API  AddCoords ( PCOORDPAIR base, PCOORDPAIR offset );
/* Add one fraction to another.
   Parameters
   base :    This is the starting value, and recevies the result
             of (base+offset)
   offset :  This is the fraction to add to base.
   Returns
   base                                                          */
FRACTION_PROC  PFRACTION FRACTION_API  AddFractions ( PFRACTION base, PFRACTION offset );
/* Add one fraction to another.
   Parameters
   base :    This is the starting value, and recevies the result
             of (base+offset)
   offset :  This is the fraction to add to base.
   Returns
   base                                                          */
FRACTION_PROC  PFRACTION FRACTION_API  SubtractFractions ( PFRACTION base, PFRACTION offset );
/* NOT IMPLEMENTED */
FRACTION_PROC  PFRACTION FRACTION_API  MulFractions ( PFRACTION f, PFRACTION x );
/* Log a fraction into a string. */
FRACTION_PROC  int FRACTION_API  sLogFraction ( TEXTCHAR *string, PFRACTION x );
/* Unsafe log of a coordinate pair's value into a string. The
   string should be at least 69 characters long.
   Parameters
   string :  the string to print the fraction into
   pcp :     the coordinate pair to print                     */
FRACTION_PROC  int FRACTION_API  sLogCoords ( TEXTCHAR *string, PCOORDPAIR pcp );
/* Log coordpair to logfile. */
FRACTION_PROC  void FRACTION_API  LogCoords ( PCOORDPAIR pcp );
/* scales a fraction by a signed integer value.
   Parameters
   result\ :  pointer to a FRACTION to receive the result
   value :    the amount to be scaled
   f :        the fraction to multiply the value by
   Returns
   \result; the pointer the fraction to receive the result. */
FRACTION_PROC  PFRACTION FRACTION_API  ScaleFraction ( PFRACTION result, int32_t value, PFRACTION f );
/* Results in the integer part of the fraction. If the faction
   was 330/10 then the result would be 33.                     */
FRACTION_PROC  int32_t FRACTION_API  ReduceFraction ( PFRACTION f );
/* Scales a 32 bit integer value by a fraction. The result is
   the scaled value result.
   Parameters
   f :      pointer to the faction to multiply value by
   value :  the value to scale
   Returns
   The (value * f) integer value of.                          */
FRACTION_PROC  uint32_t FRACTION_API  ScaleValue ( PFRACTION f, int32_t value );
/* \ \
   Parameters
   f :      The fraction to scale the value by
   value :  the value to scale by (1/f)
   Returns
   the value of ( value * 1/ f )               */
FRACTION_PROC  uint32_t FRACTION_API  InverseScaleValue ( PFRACTION f, int32_t value );
	SACK_MATH_FRACTION_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::math::fraction;
#endif
#endif
//---------------------------------------------------------------------------
// $Log: fractions.h,v $
// Revision 1.6  2004/09/03 14:43:40  d3x0r
// flexible frame reactions to font changes...
//
// Revision 1.5  2003/03/25 08:38:11  panther
// Add logging
//
// Revision 1.4  2003/01/27 09:45:03  panther
// Fix lack of anonymous structures
//
// Revision 1.3  2002/10/09 13:16:02  panther
// Support for linux shared memory mapping.
// Support for better linux compilation of configuration scripts...
// Timers library is now Threads AND Timers.
//
//
#ifndef __NO_INTERFACES__
#endif
# ifndef SECOND_IMAGE_LEVEL
#  define SECOND_IMAGE_LEVEL _2
/* This is a macro used for building name changes for
   interfaces.                                        */
#  define PASTE(sym,name) name
# else
#  define PASTE2(sym,name) sym##name
#  define PASTE(sym,name) PASTE2(sym,name)
# endif
/* Macro to do symbol concatenation. */
#define _PASTE2(sym,name) sym##name
/* A second level paste macro so macro substitution is done on
   \parameters.                                                */
#define _PASTE(sym,name) _PASTE2(sym,name)
/* Define the default call type of image routines. CPROC is
   __cdecl.                                                 */
#define IMAGE_API CPROC
#     ifdef IMAGE_LIBRARY_SOURCE
#        define IMAGE_PROC  EXPORT_METHOD
// this sometimes needs an extra 'extern'
//#           ifdef IMAGE_MAIN
//#        define IMAGE_PROC_D EXPORT_METHOD
//#           else
//#        define IMAGE_PROC_D extern EXPORT_METHOD
//#           endif
#     else
/* Define the linkage type of the routine... probably
   __declspec(dllimport) if not building the library. */
#        define IMAGE_PROC IMPORT_METHOD
// this sometimes needs an extra 'extern'
//#        define IMAGE_PROC_D  IMPORT_METHOD
#     endif
#if defined( _WIN32 ) && !defined( _OPENGL_DRIVER ) && !defined( _D3D_DRIVER ) && !defined( _D3D10_DRIVER ) && !defined( _D3D11_DRIVER )
#define _INVERT_IMAGE
#endif
#ifdef __cplusplus
/* Define the namespace of image routines, when building under
   C++.                                                        */
#ifdef _D3D_DRIVER
#  define IMAGE_NAMESPACE namespace sack { namespace image { namespace d3d {
#  define _IMAGE_NAMESPACE namespace image { namespace d3d {
#  define BASE_IMAGE_NAMESPACE namespace image {
/* Define the namespace of image routines, when building under
   C++. This ends a namespace.                                 */
#  define IMAGE_NAMESPACE_END }}}
#elif defined( _D3D10_DRIVER )
#  define IMAGE_NAMESPACE namespace sack { namespace image { namespace d3d10 {
#  define _IMAGE_NAMESPACE namespace image { namespace d3d10 {
#  define BASE_IMAGE_NAMESPACE namespace image {
/* Define the namespace of image routines, when building under
   C++. This ends a namespace.                                 */
#  define IMAGE_NAMESPACE_END }}}
#elif defined( _D3D11_DRIVER )
#  define IMAGE_NAMESPACE namespace sack { namespace image { namespace d3d11 {
#  define _IMAGE_NAMESPACE namespace image { namespace d3d11 {
#  define BASE_IMAGE_NAMESPACE namespace image {
/* Define the namespace of image routines, when building under
   C++. This ends a namespace.                                 */
#  define IMAGE_NAMESPACE_END }}}
#else
#  define BASE_IMAGE_NAMESPACE namespace image {
#  define IMAGE_NAMESPACE namespace sack { namespace image {
#  define _IMAGE_NAMESPACE namespace image {
/* Define the namespace of image routines, when building under
   C++. This ends a namespace.                                 */
#  define IMAGE_NAMESPACE_END }}
#endif
/* Define the namespace of image routines, when building under
   C++. This ends the namespace. Assembly routines only have the
   ability to export C names, so extern"c" { } is used instead
   of namespace ___ { }.                                         */
#define ASM_IMAGE_NAMESPACE extern "C" {
/* Define the namespace of image routines, when building under
   C++. This ends the namespace. Assembly routines only have the
   ability to export C names, so extern"c" { } is used instead
   of namespace ___ { }.                                         */
#define ASM_IMAGE_NAMESPACE_END }
#else
#define BASE_IMAGE_NAMESPACE
#define IMAGE_NAMESPACE
#define _IMAGE_NAMESPACE
#define IMAGE_NAMESPACE_END
#define ASM_IMAGE_NAMESPACE
 /* Defined Image API.
   See Also
   <link sack::image::Image, Image>
   <link sack::image::SFTFont, SFTFont>
   <link Colors>
                                    */
#define ASM_IMAGE_NAMESPACE_END
#endif
SACK_NAMESPACE
/* Deals with images and image processing.
   Image is the primary type of this.
   SFTFont is a secondary type for putting text on images.
   render namespace is contained in image, because without
   image, there could be no render. see PRENDERER.         */
	_IMAGE_NAMESPACE
/* A fixed point decimal number (for freetype font rendering) */
typedef int64_t fixed;
//#ifndef IMAGE_STRUCTURE_DEFINED
//#define IMAGE_STRUCTURE_DEFINED
// consider minimal size - +/- 32000 should be enough for display purposes.
// print... well that's another matter.
   typedef int32_t IMAGE_COORDINATE;
   /* Represents the width and height of an image (unsigned values) */
   typedef uint32_t  IMAGE_SIZE_COORDINATE;
   /* An array of 2 IMAGE_COORDINATES - [0] = x, [1] = y */
   typedef IMAGE_COORDINATE IMAGE_POINT[2];
   /* An unsigned value coordinate pair to track the size of
      images.                                                */
   typedef IMAGE_SIZE_COORDINATE IMAGE_EXTENT[2];
   /* Pointer to an <link sack::image::IMAGE_POINT, IMAGE_POINT> */
   typedef IMAGE_COORDINATE *P_IMAGE_POINT;
   /* Pointer to a <link sack::image::IMAGE_EXTENT, IMAGE_EXTENT> */
   typedef IMAGE_SIZE_COORDINATE *P_IMAGE_EXTENT;
#ifdef HAVE_ANONYMOUS_STRUCTURES
typedef struct boundry_rectangle_tag
{
   union {
      IMAGE_POINT position;
      struct {
         IMAGE_COORDINATE x, y;
      };
   };
   union {
      IMAGE_EXTENT size;
      struct {
         IMAGE_SIZE_COORDINATE width, height;
      };
   };
} IMAGE_RECTANGLE, *P_IMAGE_RECTANGLE;
#else
/* Defines the coordinates of a rectangle. */
/* Pointer to an image rectangle.  */
typedef struct boundry_rectangle_tag
{
   /* anonymous union containing position information. */
   union {
      /* An anonymous structure containing x,y and width,height of a
         rectangle.                                                  */
      struct {
         /* the left coordinate of a rectangle. */
         /* the top coordinate of a rectangle */
         IMAGE_COORDINATE x, y;
         /* The Y span of the rectangle */
         /* the X Span of the rectangle */
         IMAGE_SIZE_COORDINATE width, height;
      };
      /* Anonymous structure containing position (x,y) and size
         (width,height).                                        */
      struct {
         /* The location of a rectangle (upper left x, y) */
         IMAGE_POINT position;
         /* the size of a rectangle (width and height) */
         IMAGE_EXTENT size;
      };
   };
} IMAGE_RECTANGLE, *P_IMAGE_RECTANGLE;
#endif
/* A macro for accessing vertical (Y) information of an <link sack::image::IMAGE_POINT, IMAGE_POINT>. */
#define IMAGE_POINT_H(ImagePoint) ((ImagePoint)[0])
/* A macro for accessing vertical (Y) information of an <link sack::image::IMAGE_POINT, IMAGE_POINT>. */
#define IMAGE_POINT_V(ImagePoint) ((ImagePoint)[1])
// the image at exactly this position and size
// is the one being referenced, the actual size and position
// may vary depending on use (a sub-image outside the
// boundry of its parent).
#define ImageData union {                                 struct {                                               IMAGE_COORDINATE x, y;                              IMAGE_SIZE_COORDINATE width, height;             };                                                  struct {                                               IMAGE_POINT position;                               IMAGE_EXTENT size;                               };                                               }
/* One of the two primary types that the image library works
   with.
   Example
   <code lang="c++">
   void LoadImage( char *name )
   {
       Image image = LoadImageFile( name );
       if( image )
       {
          // the image file loaded successfully.
       }
   }
   </code>                                                   */
typedef struct ImageFile_tag *Image;
typedef struct SlicedImageFile *SlicedImage;
#if defined( IMAGE_STRUCTURE_DEFINED )
#if defined(__cplusplus_cli ) && !defined( IMAGE_SOURCE )
IMAGE_PROC  PCDATA IMAGE_API ImageAddress( Image image, int32_t x, int32_t y );
#define IMG_ADDRESS(i,x,y) ImageAddress( i,x,y )
#endif
#endif
#if defined( __cplusplus )
IMAGE_NAMESPACE_END
#endif
#ifndef IMAGE_STRUCTURE_DEFINED
#ifdef _D3D_DRIVER
#include <d3d9.h>
#endif
#ifdef _D3D10_DRIVER
#include <D3D10_1.h>
#include <D3D10.h>
#endif
#ifdef _D3D11_DRIVER
#include <D3D11.h>
#endif
#ifdef _VULKAN_DRIVER
#include <vulkan/vulkan.h>
#endif
// one day I'd like to make a multidimensional library
// but for now - 3D is sufficient - it can handle everything
// under 2D ignoring the Z axis... although it would be more
// efficient to do 2D implementation alone...
// but without function overloading the names of all the functions
// become much too complex.. well perhaps - maybe I can
// make all the required functions with a suffix - and
// supply defines to choose the default based on the dimension number
#ifndef ROTATE_DECLARATION
// vector multiple inclusion protection
#define ROTATE_DECLARATION
#if !defined(__STATIC__) && !defined(__LINUX__)
#  ifdef VECTOR_LIBRARY_SOURCE
#    define MATHLIB_EXPORT EXPORT_METHOD
#    if defined( __WATCOMC__ ) || defined( _MSC_VER )
// data requires an extra extern to generate the correct code *boggle*
#      define MATHLIB_DEXPORT extern EXPORT_METHOD
#    else
#      define MATHLIB_DEXPORT EXPORT_METHOD
#    endif
#  else
#    define MATHLIB_EXPORT IMPORT_METHOD
#    if ( defined( __WATCOMC__ ) || defined( _MSC_VER ) || defined( __GNUC__ ) ) && !defined( __ANDROID__ )
// data requires an extra extern to generate the correct code *boggle*
#      ifndef __cplusplus_cli
#        define MATHLIB_DEXPORT extern IMPORT_METHOD
#      else
#        define MATHLIB_DEXPORT extern IMPORT_METHOD
#      endif
#    else
#      define MATHLIB_DEXPORT IMPORT_METHOD
#    endif
#  endif
#else
#ifndef VECTOR_LIBRARY_SOURCE
#define MATHLIB_EXPORT extern
#define MATHLIB_DEXPORT extern
#else
#define MATHLIB_EXPORT
#define MATHLIB_DEXPORT
#endif
#endif
#define DIMENSIONS 3
#if( DIMENSIONS > 0 )
   #define vRight   0
   #define _1D(exp)  exp
   #if( DIMENSIONS > 1 )
      #define vUp      1
      #define _2D(exp)  exp
      #if( DIMENSIONS > 2 )
         #define vForward 2
         #define _3D(exp)  exp
         #if( DIMENSIONS > 3 )
  // 4th dimension 'IN'/'OUT' since projection is scaled 3d...
            #define vIn      3
            #define _4D(exp)  exp
         #else
            #define _4D(exp)
         #endif
      #else
         #define _3D(exp)
         #define _4D(exp)
      #endif
   #else
      #define _2D(exp)
      #define _3D(exp)
      #define _4D(exp)
   #endif
#else
   // print out a compiler message can't perform zero-D transformations...
#endif
#if defined( _D3D_DRIVER ) || defined( _D3D10_DRIVER )
#  ifndef MAKE_RCOORD_SINGLE
#    define MAKE_RCOORD_SINGLE
#  endif
#endif
#ifdef __cplusplus
#  ifndef MAKE_RCOORD_SINGLE
#    define VECTOR_NAMESPACE SACK_NAMESPACE namespace math { namespace vector { namespace Double {
#    define _MATH_VECTOR_NAMESPACE namespace math { namespace vector { namespace Double {
#    define _VECTOR_NAMESPACE namespace vector { namespace Double {
#    define USE_VECTOR_NAMESPACE using namespace sack::math::vector::Double;
#  else
#    define VECTOR_NAMESPACE SACK_NAMESPACE namespace math { namespace vector { namespace Float {
#    define _MATH_VECTOR_NAMESPACE namespace math { namespace vector { Float {
#    define _VECTOR_NAMESPACE namespace vector { namespace Float {
#    define USE_VECTOR_NAMESPACE using namespace sack::math::vector::Float;
#  endif
#  define _MATH_NAMESPACE namespace math {
#  define VECTOR_NAMESPACE_END } } } SACK_NAMESPACE_END
#else
#  define VECTOR_NAMESPACE
#  define _MATH_VECTOR_NAMESPACE
#  define _MATH_NAMESPACE
#  define _VECTOR_NAMESPACE
#  define VECTOR_NAMESPACE_END
#  define USE_VECTOR_NAMESPACE
#endif
#ifdef MAKE_RCOORD_SINGLE
#  define VECTOR_METHOD(r,n,args) MATHLIB_EXPORT r n##f args;
#  define EXTERNAL_NAME(n)  n##f
#else
#  define VECTOR_METHOD(r,n,args) MATHLIB_EXPORT r n##d args;
#  define EXTERNAL_NAME(n)  n##d
#endif
#ifndef VECTOR_TYPES_DEFINED
#define VECTOR_TYPES_DEFINED
// this file merely defines the basic calculation unit...
// more types are defined in VECTLIB.H which has the number
// of dimensions defined...
#include <math.h>
#include <float.h>
SACK_NAMESPACE
	_MATH_NAMESPACE
   _VECTOR_NAMESPACE
   // requires C++ to make RCOORD single - otherwise it is a double.
#ifndef MAKE_RCOORD_SINGLE
/* Define that an RCOORD is represented by the basic type
   'double' for platforms with smaller fast floating point
   types, this could be float.                             */
#define RCOORD_IS_DOUBLE 1
	/* basic type that Vectlib is based on.
	 This specifies a 'real' (aka float) coordinate.
	 Combinations of coordinates create vectors and points.  */
typedef double RCOORD;
/* <combine sack::math::vector::double::RCOORD>
   \ \                                  */
	typedef double *PRCOORD;
#else
	/* basic type that Vectlib is based on.
	 This specifies a 'real' (aka float) coordinate.
	 Combinations of coordinates create vectors and points.  */
typedef float RCOORD;
/* <combine sack::math::vector::float::RCOORD>
   \ \                                  */
typedef float *PRCOORD;
#endif
// these SHOULD be dimension relative, but we lack much code for that...
typedef RCOORD MATRIX[4][4];
typedef MATRIX *PMatrix;
/* Describes the rotation matrix for a PTRANSFORM. */
typedef RCOORD PMATRIX[][4];
typedef RCOORD RQUATERNION[4];
typedef RCOORD PRQUATERNION[4];
#ifdef RCOORD_IS_DOUBLE
#define RCOORDBITS(v)  (*(uint64_t*)&(v))
#else
/* A macro to get the literal bits into an unsigned value of the
   same size. Shift and binary operators do not apply to
   floating point values, but floating point values are fields
   of bits that represent fractional parts of integers. This
   gets the bits so the fields can be tested.                    */
#define RCOORDBITS(v)  (*(uint32_t*)&(v))
#endif
/* a symbol which is effectively the largest negative value of
   the space, anything less than this is untrackable, and is the
   same as infinity.                                             */
#define NEG_INFINITY ((RCOORD)-9999999999.0)
/* a symbol which is effectively the largest value of the space,
   anything more than this is untrackable, and is the same as
   infinity.                                                     */
#define POS_INFINITY ((RCOORD)9999999999.0)
/* This is 'epsilon' that is used with by NearZero comparison
   macro.                                                     */
#define e1 (0.00001)
/* Checks to see if a coordinate is 0 or near 0. */
#define NearZero( n ) (fabs(n)<e1)
#ifndef __cplusplus
#endif
#ifdef RCOORD_IS_DOUBLE
// THRESHOLD may be any number more than 1.
// eveything 0 or more makes pretty much every number
// which is anything like another number equal...
// threshold is in count of bits...
// therefore for 1millionth digit accuracy that would be 20 bits.
// 10 bits is thousanths different are near
// 0 bits is if the same magnitude of number... but may be
//   quite different
// -10 bits is thousands different are near
// 1 == 1.5
// 1 == 1.01
#define THRESHOLD 16
#ifdef _MSC_VER
#define EXPON(f) ((int)(( RCOORDBITS(f) & 0x4000000000000000I64 ) ?                       (( RCOORDBITS(f) &  0x3FF0000000000000I64 ) >> (20+32)) :                        ((( RCOORDBITS(f) & 0x3FF0000000000000I64 ) >> (20+32)) - 1024)))
#else
#define EXPON(f) ((int)(( RCOORDBITS(f) & 0x4000000000000000LL ) ?                       (( RCOORDBITS(f) &  0x3FF0000000000000LL ) >> (20+32)) :                        ((( RCOORDBITS(f) & 0x3FF0000000000000LL ) >> (20+32)) - 1024)))
#endif
#else
// THRESHOLD may be any number more than 1.
// eveything 0 or more makes pretty much every number
// which is anything like another number equal...
// threshold is in count of bits...
// therefore for 1millionth digit accuracy that would be 20 bits.
// 10 bits is thousanths different are near
// 0 bits is if the same magnitude of number... but may be
//   quite different
// -10 bits is thousands different are near
// 1 == 1.5
// 1 == 1.01
#define THRESHOLD 10
/* Macro to extract the exponent part of a RCOORD.
                                                   */
#define EXPON(f) ((int)(( RCOORDBITS(f) & 0x40000000L ) ?                       (( RCOORDBITS(f) & 0x3F800000L ) >> 23) :                        ((( RCOORDBITS(f) & 0x3F800000L ) >> 23) - 128)))
#endif
#ifdef NEED_VECTLIB_COMPARE
//cpg26Dec2006 c:\work\sack\include\vectypes.h(75): Warning! W202: Symbol 'COMPARE' has been defined, but not referenced
static int COMPARE( RCOORD n1, RCOORD n2 )
{
	RCOORD tmp1, tmp2;
	int compare_result;
	tmp1=n1-n2;
	//lprintf( WIDE("exponents %ld %ld"), EXPON( n1 ), EXPON( n2 ) );
	 //lprintf("%9.9g-%9.9g=%9.9g %s %s %ld %ld %ld"
	//		 , (n1),(n2),(tmp1)
	//		 ,!RCOORDBITS(n1)?"zero":"    ",!RCOORDBITS(n2)?"zero":"    "
	  //	 ,EXPON(n1)-THRESHOLD
	//	    ,EXPON(n2)-THRESHOLD
	//		 ,EXPON(tmp1) );
	tmp2=n2-n1;
	//lprintf("%9.9g-%9.9g=%9.9g %s %s %ld %ld %ld"
	//		 , (n2),(n1),(tmp2)
	//		 ,!RCOORDBITS(n2)?"zero":"    ",!RCOORDBITS(n1)?"zero":"    "
	//		 ,EXPON(n2)-THRESHOLD,EXPON(n1)-THRESHOLD,EXPON(tmp2));
	compare_result = ( ( !RCOORDBITS(n1) )?( (n2) <  0.0000001 &&
														 (n2) > -0.0000001 )?1:0
							:( !RCOORDBITS(n2) )?( (n1) <  0.0000001 &&
														 (n1) > -0.0000001 )?1:0
							:( (n1) == (n2) )?1
							:( ( EXPON(n1) - THRESHOLD ) >=
							  ( EXPON( tmp1 ) ) ) &&
							( ( EXPON(n2) - THRESHOLD ) >=
							 ( EXPON( tmp2) ) ) ? 1 : 0
						  );
	return compare_result;
}
/*
static RCOORD CompareTemp1, CompareTemp2;
#define COMPARE( n1, n2 ) ( RCOORDBITS(n1)                                            ? ( CompareTemp1 = (n1)+(n1),                                 CompareTemp2 = (n1)+(n2),                   (RCOORDBITS(CompareTemp1)&0xFFFFFFF0)==                                     (RCOORDBITS(CompareTemp2)&0xFFFFFFF0) )                                         : RCOORDBITS(n2)                                              ? ( CompareTemp1 = (n2)+(n1),                                   CompareTemp2 = (n2)+(n2),                                  (RCOORDBITS(CompareTemp1)&0xFFFFFFF0)==                                   (RCOORDBITS(CompareTemp2)&0xFFFFFFF0) )                                                  : 1 )
*/
/*
                           ( ( ( RCOORDBITS(n1) & 0x80000000 ) !=                                      ( RCOORDBITS(n2) & 0x80000000 ) )                                       ? ( NearZero(n1)                                                           && ( ( RCOORDBITS(n1)&0x7FFFFFF0 ) ==                                        ( RCOORDBITS(n2)&0x7FFFFFF0 ) ) )                               : ( ( RCOORDBITS(n1)&0xFFFFFFF0 ) ==                                        ( RCOORDBITS(n2)&0xFFFFFFF0 ) ) )
*/
#if 1
#else
inline int COMPARE( RCOORD n1, RCOORD n2 )
{
	RCOORD CompareTemp1, CompareTemp2;
   return  RCOORDBITS(n1)                                            ? ( CompareTemp1 = (n1)+(n1),                                 CompareTemp2 = (n1)+(n2),                   (RCOORDBITS(CompareTemp1)&0xFFFFFFF0)==                                     (RCOORDBITS(CompareTemp2)&0xFFFFFFF0) )                                         : RCOORDBITS(n2)                                              ? ( CompareTemp1 = (n2)+(n1),                                   CompareTemp2 = (n2)+(n2),                                  (RCOORDBITS(CompareTemp1)&0xFFFFFFF0)==                                   (RCOORDBITS(CompareTemp2)&0xFFFFFFF0) )                                                  : 1;
}
#endif
#endif
VECTOR_NAMESPACE_END
#endif
// $Log: vectypes.h,v $
// Revision 1.12  2005/01/27 08:21:39  panther
// Linux cleaned.
//
// Revision 1.11  2004/02/08 05:42:29  d3x0r
// associate comparetemp1, 2 with routine which needs it.
//
// Revision 1.10  2003/11/28 00:10:39  panther
// fix compare function...
//
// Revision 1.9  2003/11/23 08:42:41  panther
// Toying with the nearness floating point operator
//
// Revision 1.8  2003/09/01 20:04:37  panther
// Added OpenGL Interface to windows video lib, Modified RCOORD comparison
//
// Revision 1.7  2003/08/29 10:26:17  panther
// Checkpoint - converted vectlib to be native double
//
// Revision 1.6  2003/08/29 02:07:41  panther
// Fixed logging, and nearness comparison
//
// Revision 1.5  2003/08/27 07:56:40  panther
// Replace COMPARE macro with one that works a little better
//
// Revision 1.4  2003/03/25 08:38:11  panther
// Add logging
//
SACK_NAMESPACE
	_MATH_NAMESPACE
	/* Vector namespace contains methods for operating on vectors. Vectors
	   are multi-dimensional scalar quantities, often used to
	   represent coordinates and directions in space.                      */
   _VECTOR_NAMESPACE
//#include "../src/vectlib/vecstruc.h"
typedef RCOORD _POINT4[4];
typedef RCOORD _POINT[DIMENSIONS];
/* pointer to a point. */
typedef RCOORD *P_POINT;
/* pointer to a constant point. */
typedef const RCOORD *PC_POINT;
/* A vector type. Contains 3 values by default, library can
   handle 4 dimensional transformations(?)                  */
typedef _POINT VECTOR;
/* pointer to a vector. */
typedef P_POINT PVECTOR;
/* pointer to a constant vector. */
typedef PC_POINT PCVECTOR;
/* <combine sack::math::vector::RAY@1>
   \ \                                 */
typedef struct vectlib_ray_type *PRAY;
/* <combine sack::math::vector::RAY@1>
   \ \                                 */
typedef struct vectlib_ray_type RAY;
/* A ray is a type that has an origin and a direction. (It is a
   pair of vectors actually)                                    */
struct vectlib_ray_type {
 // origin
   _POINT o;
 // normal
   _POINT n;
};
/* <combinewith sack::math::vector::lineseg_tag>
   \ \                                           */
typedef struct lineseg_tag  LINESEG;
/* <combine sack::math::vector::lineseg_tag>
   \ \                                       */
typedef struct lineseg_tag *PLINESEG;
/* This is a pure abstraction of a Line. It is used in the basis
   of 3d graphics.                                               */
struct lineseg_tag {
   /* a ray type that is the origin and slope of the line. */
	RAY r;
	/* scalar along direction vector that indicates where the line
	   segment ends. (origin + (direction * dTo) ) = end           */
	/* scalar along direction vector that indicates where the line
	   segment ends. (origin + (direction * dTo) ) = start         */
	RCOORD dFrom, dTo;
};
/* <combine sack::math::vector::orthoarea_tag>
   \ \                                         */
typedef struct orthoarea_tag ORTHOAREA;
/* <combine sack::math::vector::orthoarea_tag>
   \ \                                         */
typedef struct orthoarea_tag *PORTHOAREA;
/* A representation of a rectangular 2 dimensional area. */
struct orthoarea_tag {
    /* x coorindate of a rectangular area. */
    /* y coordinate of a rectangular area. */
    RCOORD x, y;
    /* height (y + h = area end). height may be negative. */
    /* with (x + w = area end). with may be negative. */
    RCOORD w, h;
} ;
// relics from fixed point math dayz....
#define ZERO (0.0f)
/* Special symbol that is the unit quantity. */
#define ONE  (1.0f)
#ifndef M_PI
/* symbol to define a double precision value for PI if it
   doesn't exist in the compiler.                         */
#ifdef MAKE_RCOORD_SINGLE
#  define M_PI (3.1415926535f)
#else
#  define M_PI (3.1415926535)
#endif
#endif
/* a hard coded define that represents a 5 degree angle in
   radians.                                                */
#define _5  (RCOORD)((5.0/180.0)*M_PI )
/* a hard coded define that represents a 15 degree angle in
   radians.                                                 */
#define _15 (RCOORD)((15.0/180.0)*M_PI )
/* a hard coded define that represents a 30 degree angle in
   radians.                                                 */
#define _30 (RCOORD)((30.0/180.0)*M_PI )
/* a hard coded define that represents a 45 degree angle in
   radians.                                                 */
#define _45 (RCOORD)((45.0/180.0)*M_PI )
#define SetPoint( d, s ) ( (d)[0] = (s)[0], (d)[1]=(s)[1], (d)[2]=(s)[2] )
#define SetPoint4( d, s ) ( (d)[0] = (s)[0], (d)[1]=(s)[1], (d)[2]=(s)[2], (d)[3]=(s)[3] )
/* Inverts a vector. that is vector * -1. (a,b,c) = (-a,-b,-c)
   <b>Parameters</b>
                                                               */
VECTOR_METHOD( P_POINT, Invert, ( P_POINT a ) );
/* Macro which can be used to make a vector's direction be
   exactly opposite of what it is now.                     */
#define InvertVector( a ) ( a[0] = -a[0], a[1]=-a[1], a[2]=-a[2] )
/* Logs the vector and leader to log. the leader is called
   lpName, cause it was inteded to be used by just the vector
   name.
   Parameters
   lpName :  text leader to print before the vector.
   v :       vector to log
   Example
   <code lang="c++">
   PrintVector( _X );
   // expands to
   PrintVectorEx( "_X", _X DBG_SRC );
   </code>                                                    */
VECTOR_METHOD( void, PrintVectorEx, ( CTEXTSTR lpName, PCVECTOR v DBG_PASS ) );
/* <combine sack::math::vector::PrintVectorEx@CTEXTSTR@PCVECTOR v>
   \ \                                                               */
#define PrintVector(v) PrintVectorEx( WIDE(#v), v DBG_SRC )
/* Same as PrintVectorEx, but prints to standard output using
   printf.                                                    */
VECTOR_METHOD( void, PrintVectorStdEx, ( CTEXTSTR lpName, VECTOR v DBG_PASS ) );
/* <combine sack::math::vector::PrintVectorStdEx@CTEXTSTR@VECTOR v>
   \ \                                                                */
#define PrintVectorStd(v) PrintVectorStd( WIDE(#v), v DBG_SRC )
/* Dumps to syslog a current matrix. Shows both matrix content,
   and the cross products between the matrix that cross1 should
   be row 0, cross2 should be row 1 and cross3 should be row2.
   Pass a text name to identify this matrix from others.
   Parameters
   lpName :    Name to write into the log.
   m :         the matrix to dump.
   DBG_PASS :  standard debug paramters
   Remarks
   A PTRANSFORM is not a MATRIX; there is a matrix in a
   transform, and is the first member, so a ptransform can be
   cast to a matrix and logged with this function.              */
VECTOR_METHOD( void, PrintMatrixEx, ( CTEXTSTR lpName, MATRIX m DBG_PASS ) );
/* <combine sack::math::vector::PrintMatrixEx@CTEXTSTR@MATRIX m>
   \ \                                                             */
#define PrintMatrix(m) PrintMatrixEx( WIDE(#m), m DBG_SRC )
/* <combine sack::math::vector::TransformationMatrix>
   \ \                                                */
typedef struct transform_tag *PTRANSFORM;
/* <combine sack::math::vector::TransformationMatrix>
   \ \                                                */
typedef struct transform_tag	 TRANSFORM;
/* Pointer to a constant transform. */
typedef const TRANSFORM *PCTRANSFORM;
/* Constant pointer to a constant transform. For things like _I
   transformation which is the identity translation.            */
typedef const PCTRANSFORM *CPCTRANSFORM;
#define VectorConst_0 EXTERNAL_NAME(VectorConst_0)
#define VectorConst_X EXTERNAL_NAME(VectorConst_X)
#define VectorConst_Y EXTERNAL_NAME(VectorConst_Y)
#define VectorConst_Z EXTERNAL_NAME(VectorConst_Z)
#define VectorConst_I EXTERNAL_NAME(VectorConst_I)
//------ Constants for origin(0,0,0), and axii
#ifndef VECTOR_LIBRARY_SOURCE
MATHLIB_DEXPORT const PC_POINT VectorConst_0;
/* Specifies the coordinate system's X axis direction. static
   constant.                                                  */
MATHLIB_DEXPORT const PC_POINT VectorConst_X;
/* Specifies the coordinate system's Y axis direction. static
   constant.                                                  */
MATHLIB_DEXPORT const PC_POINT VectorConst_Y;
/* Specifies the coordinate system's Z axis direction. static
   constant.                                                  */
MATHLIB_DEXPORT const PC_POINT VectorConst_Z;
/* This is a static constant identity matrix, which can be used
   to initialize a matrix transform (internally).               */
MATHLIB_DEXPORT const PCTRANSFORM VectorConst_I;
#define _0 ((PC_POINT)VectorConst_0)
#  ifndef _X
#    define _X ((PC_POINT)VectorConst_X)
#  else
#  endif
#define _Y ((PC_POINT)VectorConst_Y)
#define _Z ((PC_POINT)VectorConst_Z)
#define _I ((PC_POINT)VectorConst_I)
#endif
/* compares two vectors to see if they are near each other. Boundary
   \conditions exist around 0, when the values are on opposite
   sides, but it's pretty good.                                      */
#define Near( a, b ) ( COMPARE(a[0],b[0]) && COMPARE( a[1], b[1] ) && COMPARE( a[2], b[2] ) )
/* Add two vectors together. (a1,b1,c1) + (a2,b2,c2) =
   (a1+a2,b1+b2,c1+c2)
   Remarks
   The result vector may be the same as one of the source
   vectors.                                               */
VECTOR_METHOD( P_POINT, add, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2 ) );
/* subtracts two vectors and stores the result in another
   vector.
   Remarks
   The result vector may be the same as one of the source
   vectors.                                               */
VECTOR_METHOD( P_POINT, sub, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2 ) );
/* Scales a vector by a scalar
   Parameters
   pr :   \result vector
   pv1 :  vector to scale
   k :    constant scalar to apply to vector
   Example
   <code lang="c#">
   VECTOR result;
   VECTOR start;
   SetPoint( start, _X );
   scale( result, start, 3 );
   </code>                                   */
VECTOR_METHOD( P_POINT, scale, ( P_POINT pr, PC_POINT pv1, RCOORD k ) );
/* Adds a vector scaled by a scalar to another vector, results
   in a third vector.
   Parameters
   pr :   pointer to a result vector
   pv1 :  pointer to vector 1
   pv2 :  pointer to vector 2
   k :    scalar quantity to apply to vector 2 when adding to
          vector 1.
   Remarks
   The pointer to the result vector may be the same vector as
   vector 1 or vector 2.
   Example
   <code lang="c++">
   _POINT result;
   P_POINT v1 = _X;
   P_POINT v2 = _Y;
   RCOORD k = 1.414;
   addscaled( result, v1, v2, k );
   // result is ( 1, 1.414, 0 )
   </code>                                                     */
VECTOR_METHOD( P_POINT, addscaled, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2, RCOORD k ) );
/* Normalizes a non-zero vector. That is the resulting length of
   the vector is 1.0. Modifies the vector in place.              */
VECTOR_METHOD( void, normalize, ( P_POINT pv ) );
VECTOR_METHOD( void, crossproduct, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2 ) );
/* \Returns the sin of the angle between two vectors.
   Parameters
   pv1 :  one vector
   pv2 :  another vector
   Remarks
   If the length of either vector is 0, then a divide by zero
   exception will happen.                                     */
VECTOR_METHOD( RCOORD, SinAngle, ( PC_POINT pv1, PC_POINT pv2 ) );
/* \Returns the cos (cosine) of the angle between two vectors.
   Parameters
   pv1 :  one vector
   pv2 :  another vector
   Remarks
   If the length of either vector is 0, then a divide by zero
   exception will happen.                                      */
VECTOR_METHOD( RCOORD, CosAngle, ( PC_POINT pv1, PC_POINT pv2 ) );
VECTOR_METHOD( RCOORD, dotproduct, ( PC_POINT pv1, PC_POINT pv2 ) );
// result is the projection of project onto onto
VECTOR_METHOD( P_POINT, project, ( P_POINT pr, PC_POINT onto, PC_POINT project ) );
/* \Returns the scalar length of a vector. */
VECTOR_METHOD( RCOORD, Length, ( PC_POINT pv ) );
/* \Returns the distance between two points.
   Parameters
   v1 :  some point
   v2 :  another point
   Returns
   The distance between the two points.      */
VECTOR_METHOD( RCOORD, Distance, ( PC_POINT v1, PC_POINT v2 ) );
/* \Returns the distance a point is as projected on another
   vector. The result is the distance along that vector from the
   origin.
   Parameters
   pvOn :  Vector to project on
   pvOf :  vector to get projection length of.                   */
VECTOR_METHOD( RCOORD, DirectedDistance, ( PC_POINT pvOn, PC_POINT pvOf ) );
/* copies the value of a ray into another ray
   Parameters
   ray to set :   target value
   ray to copy :  value to copy.
   Example
   <code>
   RAY ray;
   RAY ray2;
   // set ray to ray2
   SetRay( ray, ray2 );
   </code>                                    */
#define SetRay( pr1, pr2 ) { SetPoint( (pr1)->o, (pr2)->o ),                               SetPoint( (pr1)->n, (pr2)->n ); }
		/* Allocates and initializes a new transform for the user.
		 if name is NULL, allocates an unnamed transform; otherwise
       the transform is created in a known namespace that can be browsed.
		 */
VECTOR_METHOD( PTRANSFORM, CreateNamedTransform, ( CTEXTSTR name ) );
#define CreateTransform() CreateNamedTransform( NULL )
VECTOR_METHOD( PTRANSFORM, CreateTransformMotion, ( PTRANSFORM pt ) );
VECTOR_METHOD( PTRANSFORM, CreateTransformMotionEx, ( PTRANSFORM pt, int rocket ) );
VECTOR_METHOD( void, DestroyTransform     , ( PTRANSFORM pt ) );
/* Resets a transform back to initial conitions. */
VECTOR_METHOD( void, ClearTransform       , ( PTRANSFORM pt ) );
/* Badly named function.
   InvertTransform turns a transform sideways, that is takes
   axis-normal transforms and turns them for sending to other
   graphic systems.
   <code lang="c++">
     \+-         -+
     | 0   1   2 |
     | 3   4   5 |
     | 6   7   8 |
     \+-         -+
   becomes
     \+-         -+
     | 0   3   6 |
     | 1   4   7 |
     | 2   5   8 |
     \+-         -+
   Not entirely useful at all :)
   </code>                                                    */
VECTOR_METHOD( void, InvertTransform        , ( PTRANSFORM pt ) );
VECTOR_METHOD( void, Scale                 , ( PTRANSFORM pt, RCOORD sx, RCOORD sy, RCOORD sz ) );
VECTOR_METHOD( void, Translate             , ( PTRANSFORM pt, RCOORD tx, RCOORD ty, RCOORD tz ) );
VECTOR_METHOD( void, TranslateV            , ( PTRANSFORM pt, PC_POINT t ) );
VECTOR_METHOD( void, TranslateRel          , ( PTRANSFORM pt, RCOORD tx, RCOORD ty, RCOORD tz ) );
VECTOR_METHOD( void, TranslateRelV         , ( PTRANSFORM pt, PC_POINT t ) );
VECTOR_METHOD( void, RotateAbs, ( PTRANSFORM pt, RCOORD rx, RCOORD ry, RCOORD rz ) );
VECTOR_METHOD( void, RotateAbsV, ( PTRANSFORM pt, PC_POINT ) );
/* Updates the current rotation matrix of a transform by a
   relative amount. Amounts to rotate about the x, y and z axii
   are given in radians.
   Parameters
   pt :  transform to rotate
   rx :  amount around the x axis to rotate (pitch)(positive is
         clockwise looking at the object from the right, axis up is
         moved towards forward )
   ry :  amount around the y axis to rotate (yaw) (positive is
         counter clockwise, moves right to forward)
   rz :  amount around the z axis to rotate (roll) (positive is
         clockwise, moves up towards right )
   See Also
   RotateRelV                                                       */
VECTOR_METHOD( void, RotateRel, ( PTRANSFORM pt, RCOORD rx, RCOORD ry, RCOORD rz ) );
/* Update a transformation matrix by relative degress about the
   x axix, y axis and z axis.
   Parameters
   pt :  transform to update
   v :   vector containing x,y and z relative roll coordinate.  */
VECTOR_METHOD( void, RotateRelV, ( PTRANSFORM pt, PC_POINT ) );
/* Rotates a transform around some arbitrary axis. (any line may
   be used to rotate the transformation's rotation matrix)
   Parameters
   pt :      transform to update
   p :       P defines an axis around which the rotation portion
             of the matrix is rotated by an amount. Can be any
             arbitrary axis.
   amount :  an amount to rotate by.
   Note
   coded from
   http://www.mines.edu/~gmurray/ArbitraryAxisRotation/ArbitraryAxisRotation.html
   and
   http://www.siggraph.org/education/materials/HyperGraph/modeling/mod_tran/3drota.htm
   and http://astronomy.swin.edu.au/~pbourke/geometry/rotate/.
                                                                                       */
VECTOR_METHOD( void, RotateAround, ( PTRANSFORM pt, PC_POINT p, RCOORD amount ) );
/* Sets the current 'up' axis of a transformation. The forward
   axis is adjusted so that it remains perpendicular to the mast
   axis vs the right axis. After the forward axis is updated,
   the right axis is adjusted to be perpendicular to up and
   forward.
   Parameters
   pt :   transform to set the up direction of
   vup :  new direction for 'up'
   Remarks
   RotateMast is based on the idea that your current frame is
   something like a boat. As the boat moves along a surface,
   it's version of 'up' may change depending on the landscape. This
   keeps up up. (Actually, the computation was used for an
   object running along the interior of a sphere, and this
   normalizes their 'up' to the center of the sphere.               */
VECTOR_METHOD( void, RotateMast, ( PTRANSFORM pt, PCVECTOR vup ) );
/* Rotates around the 'up' of the current rotation matrix. Same
   as a yaw rotation.
   Parameters
   pt :     transformation to rotate
   angle :  angle to rotate \- positive should be clockwise,
            looking from top down.                              */
VECTOR_METHOD( void, RotateAroundMast, ( PTRANSFORM pt, RCOORD angle ) );
/* Recovers a transformation state from a file.
   Parameters
   pt :        transform to read into
   filename :  filename with the transform in it. */
VECTOR_METHOD( void, LoadTransform, ( PTRANSFORM pt, CTEXTSTR filename ) );
/* Provides a way to save a matrix ( direct binary file dump)
   Parameters
   pt :        transform matrix to save
   filename :  \file to save the transformation in.           */
VECTOR_METHOD( void, SaveTransform, ( PTRANSFORM pt, CTEXTSTR filename ) );
VECTOR_METHOD( void, RotateTo, ( PTRANSFORM pt, PCVECTOR vforward, PCVECTOR vright ) );
VECTOR_METHOD( void, RotateRight, ( PTRANSFORM pt, int A1, int A2 ) );
VECTOR_METHOD( void, Apply           , ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyR          , ( PCTRANSFORM pt, PRAY dest, PRAY src ) );
VECTOR_METHOD( void, ApplyT          , ( PCTRANSFORM pt, PTRANSFORM dest, PCTRANSFORM src ) );
// I know this was a result - unsure how it was implented...
//void ApplyT              (PTRANFORM pt, PTRANSFORM pt1, PTRANSFORM pt2 );
VECTOR_METHOD( void, ApplyInverse    , ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyInverseR   , ( PCTRANSFORM pt, PRAY dest, PRAY src ) );
VECTOR_METHOD( void, ApplyInverseT   , ( PCTRANSFORM pt, PTRANSFORM dest, PCTRANSFORM src ) );
// again note there was a void ApplyInverseT
VECTOR_METHOD( void, ApplyRotation        , ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyRotationT       , ( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts ) );
VECTOR_METHOD( void, ApplyInverseRotation , ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyInverseRotationT, ( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts ) );
VECTOR_METHOD( void, ApplyTranslation     , ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyTranslationT    , ( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts ) );
VECTOR_METHOD( void, ApplyInverseTranslation, ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyInverseTranslationT, ( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts ) );
// after Move() these callbacks are invoked.
typedef void (*MotionCallback)( uintptr_t, PTRANSFORM );
/* When Move is called on the transform, these callbacks are
   invoked so user code can get even update for motion.
   Parameters
   pt :        PTRANSFORM transform matrix to hook to
   callback :  user callback routine
   psv :       pointer size value data to be passed to user
               callback routine.                             */
VECTOR_METHOD( void, AddTransformCallback, ( PTRANSFORM pt, MotionCallback callback, uintptr_t psv ) );
/* Set the speed vector used when Move is applied to a
   PTRANSFORM.
   Parameters
   pt :  transform to set the current speed of.
   s :   the speed vector to set.                      */
VECTOR_METHOD( PC_POINT, SetSpeed, ( PTRANSFORM pt, PC_POINT s ) );
VECTOR_METHOD( P_POINT, GetSpeed, ( PTRANSFORM pt, P_POINT s ) );
/* Sets the acceleration applied to the speed when Move is
   called.                                                 */
VECTOR_METHOD( PC_POINT, SetAccel, ( PTRANSFORM pt, PC_POINT s ) );
VECTOR_METHOD( P_POINT, GetAccel, ( PTRANSFORM pt, P_POINT s ) );
/* Sets the forward direction speed in a PTRANSFORM.
   Parameters
   pt :        Transform to set the right speed of.
   distance :  How far it should go in the next time interval. */
VECTOR_METHOD( void, Forward, ( PTRANSFORM pt, RCOORD distance ) );
VECTOR_METHOD( void, MoveForward, ( PTRANSFORM pt, RCOORD distance ) );
VECTOR_METHOD( void, MoveRight, ( PTRANSFORM pt, RCOORD distance ) );
VECTOR_METHOD( void, MoveUp, ( PTRANSFORM pt, RCOORD distance ) );
/* Sets the up direction speed in a PTRANSFORM.
   Parameters
   pt :        Transform to set the right speed of.
   distance :  How far it should go in the next time interval. */
VECTOR_METHOD( void, Up, ( PTRANSFORM pt, RCOORD distance ) );
/* Sets the right direction speed in a PTRANSFORM.
   Parameters
   pt :        Transform to set the right speed of.
   distance :  How far it should go in the next time interval. */
VECTOR_METHOD( void, Right, ( PTRANSFORM pt, RCOORD distance ) );
VECTOR_METHOD( PC_POINT, SetRotation, ( PTRANSFORM pt, PC_POINT r ) );
VECTOR_METHOD( P_POINT, GetRotation, ( PTRANSFORM pt, P_POINT r ) );
VECTOR_METHOD( PC_POINT, SetRotationAccel, ( PTRANSFORM pt, PC_POINT r ) );
/* Set how long it takes, in milliseconds, to move 1 unit of
   speed vector or rotate 1 unit of rotation vector when Move is
   called. Each matrix maintains a last tick. If many thousands
   of matrixes were used, probably a batch move could be
   implemented that would maintain tick counts for a group of
   matrixes... don't know how long it takes to compute move, but
   timeGetTime will slow it down a lot.
   Parameters
   pt :                 transform to set the time interval on.
   speed_interval :     what the time interval should be for
                        speed.
   rotation_interval :  what the time interval should be for
                        rotation.
   Remarks
   A default interval of 1000 is used. So it will take 1000
   milliseconds to move one unit of speed. This could be set to
   3600000 and then it would take one hour to move one unit of
   speed. (miles per hour)
   Rotation has its own interval that affects rotation the same
   way; If your rotation was set to roll 2*pi radians, then it
   would revolve one full rotation in the said time.
                                                                 */
VECTOR_METHOD( void, SetTimeInterval, ( PTRANSFORM pt, RCOORD speed_interval, RCOORD rotation_interval ) );
/* Updates a transform by it's current speed and rotation
   assuming speed and rotation are specified in x per 1 second.
   Applies the fraction of time between now and the prior time
   move was called and scales speed and rotation by that when
   applying it.
   Parameters
   pt :  Pointer to a transform to update.
   See Also
   <link sack::math::vector::SetTimeInterval@PTRANSFORM@RCOORD@RCOORD, SetTimeInterval> */
VECTOR_METHOD( LOGICAL, Move, ( PTRANSFORM pt ) );
#if 0
	VECTOR_METHOD( void, Unmove, ( PTRANSFORM pt ) );
#endif
VECTOR_METHOD( void, showstdEx, ( PTRANSFORM pt, char *header ) );
VECTOR_METHOD( void, ShowTransformEx, ( PTRANSFORM pt, char *header DBG_PASS ) );
/* <combine sack::math::vector::ShowTransformEx@PTRANSFORM@char *header>
   \ \                                                                   */
#define ShowTransform( n ) ShowTransformEx( n, #n DBG_SRC )
VECTOR_METHOD( void, showstd, ( PTRANSFORM pt, char *header ) );
VECTOR_METHOD( void, GetOriginV, ( PTRANSFORM pt, P_POINT o ) );
VECTOR_METHOD( PC_POINT, GetOrigin, ( PTRANSFORM pt ) );
VECTOR_METHOD( void, GetAxisV, ( PTRANSFORM pt, P_POINT a, int n ) );
VECTOR_METHOD( PC_POINT, GetAxis, ( PTRANSFORM pt, int n ) );
VECTOR_METHOD( void, SetAxis, ( PTRANSFORM pt, RCOORD a, RCOORD b, RCOORD c, int n ) );
VECTOR_METHOD( void, SetAxisV, ( PTRANSFORM pt, PC_POINT a, int n ) );
// matrix is suitable to set as the first matrix for opengl rendering.
// it is an inverse application that uses the transform's origin as camera origin
// and the rotation matrix as what to look at.
VECTOR_METHOD( void, GetGLCameraMatrix, ( PTRANSFORM pt, PMATRIX out ) );
VECTOR_METHOD( void, GetGLMatrix, ( PTRANSFORM pt, PMATRIX out ) );
VECTOR_METHOD( void, SetGLMatrix, ( PMATRIX in, PTRANSFORM pt ) );
VECTOR_METHOD( void, SetRotationMatrix, ( PTRANSFORM pt, RCOORD *quat ) );
VECTOR_METHOD( void, GetRotationMatrix, ( PTRANSFORM pt, RCOORD *quat ) );
  // line m, b
VECTOR_METHOD( RCOORD, IntersectLineWithPlane, (PCVECTOR Slope, PCVECTOR Origin,
  // plane n, o
	PCVECTOR n, PCVECTOR o,
	RCOORD *time) );
VECTOR_METHOD( RCOORD, PointToPlaneT, (PCVECTOR n, PCVECTOR o, PCVECTOR p) );
#if !defined( VECTOR_LIBRARY_SOURCE ) && !defined( NO_AUTO_VECTLIB_NAMES )
#define add EXTERNAL_NAME(add)
#define sub EXTERNAL_NAME(sub)
#define scale EXTERNAL_NAME(scale)
#define Scale EXTERNAL_NAME(Scale)
#define Invert EXTERNAL_NAME(Invert)
#define GetOrigin EXTERNAL_NAME(GetOrigin)
#define GetOriginV EXTERNAL_NAME(GetOriginV)
#define GetAxis EXTERNAL_NAME(GetAxis)
#define GetAxisV EXTERNAL_NAME(GetAxisV)
#define GetGLCameraMatrix EXTERNAL_NAME(GetGLCameraMatrix)
#define ApplyInverse EXTERNAL_NAME(ApplyInverse)
#define Move EXTERNAL_NAME(Move)
#define MoveForward EXTERNAL_NAME(MoveForward)
#define MoveRight EXTERNAL_NAME(MoveRight)
#define MoveUp EXTERNAL_NAME(MoveUp)
#define Forward EXTERNAL_NAME(Forward)
#define Right EXTERNAL_NAME(Right)
#define Up EXTERNAL_NAME(Up)
#define PrintVectorEx EXTERNAL_NAME(PrintVectorEx)
#define PrintMatrixEx EXTERNAL_NAME(PrintMatrixEx)
#define ShowTransformEx EXTERNAL_NAME(ShowTransformEx)
#define addscaled EXTERNAL_NAME(addscaled)
#define Length EXTERNAL_NAME(Length)
#define PointToPlaneT EXTERNAL_NAME(PointToPlaneT)
#define normalize EXTERNAL_NAME(normalize)
#define Translate EXTERNAL_NAME(Translate)
#define TranslateV EXTERNAL_NAME(TranslateV)
#define Apply EXTERNAL_NAME(Apply)
#define ApplyR EXTERNAL_NAME(ApplyR)
#define ApplyT EXTERNAL_NAME(ApplyT)
#define ApplyTranslation EXTERNAL_NAME(ApplyTranslation)
#define ApplyTranslationR EXTERNAL_NAME(ApplyTranslationR)
#define ApplyTranslationT EXTERNAL_NAME(ApplyTranslationT)
#define ApplyInverseRotation EXTERNAL_NAME(ApplyInverseRotation)
#define ApplyInverseR EXTERNAL_NAME(ApplyInverseR)
#define ApplyRotation EXTERNAL_NAME(ApplyRotation)
#define ApplyRotationT EXTERNAL_NAME(ApplyRotationT)
#define RotateAround EXTERNAL_NAME(RotateAround)
#define RotateRel EXTERNAL_NAME(RotateRel)
#define SetRotation EXTERNAL_NAME(SetRotation)
#define GetRotation EXTERNAL_NAME(GetRotation)
#define SetRotationAccel EXTERNAL_NAME(SetRotationAccel)
#define RotateRight EXTERNAL_NAME(RotateRight)
#define dotproduct EXTERNAL_NAME(dotproduct)
#define DestroyTransform EXTERNAL_NAME(DestroyTransform)
#define SinAngle EXTERNAL_NAME(SinAngle)
#define CosAngle EXTERNAL_NAME(CosAngle)
#define crossproduct EXTERNAL_NAME(crossproduct)
#define CreateTransformMotion EXTERNAL_NAME(CreateTransformMotion)
#define CreateTransformMotionEx EXTERNAL_NAME(CreateTransformMotionEx)
#define CreateNamedTransform EXTERNAL_NAME(CreateNamedTransform)
#define ClearTransform EXTERNAL_NAME(ClearTransform)
#define RotateTo EXTERNAL_NAME(RotateTo)
#define SetSpeed EXTERNAL_NAME(SetSpeed)
#define SetAccel EXTERNAL_NAME(SetAccel)
#define TranslateRel EXTERNAL_NAME( TranslateRel )
#define TranslateRelV EXTERNAL_NAME( TranslateRelV )
#define RotateAbs EXTERNAL_NAME(RotateAbs)
#define RotateAbsV EXTERNAL_NAME(RotateAbsV)
#define GetRotationMatrix EXTERNAL_NAME(GetRotationMatrix)
#define SetRotationMatrix EXTERNAL_NAME(SetRotationMatrix)
#endif
#ifdef __cplusplus
#if 0
#include "../src/vectlib/vectstruc.h"
class TransformationMatrix {
private:
#ifndef TRANSFORM_STRUCTURE
	//char data[32*4 + 4];
//   // requires [4][4] for use with opengl
//   MATRIX m;       // s*rcos[0][0]*rcos[0][1] sin sin   (0)
//                   // sin s*rcos[1][0]*rcos[1][1] sin   (0)
//                   // sin sin s*rcos[2][0]*rcos[2][0]   (0)
//                   // tx  ty  tz                        (1)
//
//   RCOORD s[3];
//        // [x][0] [x][1] = partials... [x][2] = multiplied value.
//
//   RCOORD speed[3]; // speed right, up, forward
//   RCOORD rotation[3]; // pitch, yaw, roll delta
//   int nTime; // rotation stepping for consistant rotation
	struct transform_tag data;
#else
	struct transform_tag data;
#endif
public:
	TransformationMatrix() {
  //	 clear();
	}
 // no result.
	~TransformationMatrix() {}
	inline void Translate( PC_POINT o )
   {	TranslateV( &data, o );	}
	inline void TranslateRel( PC_POINT o )
	{	TranslateRelV( &data, o );	}
	inline void Translate( RCOORD x, RCOORD y, RCOORD z )
	{	TranslateV( &data, &x );	}
	inline void _RotateTo( PC_POINT forward, PC_POINT right )
	//extern void RotateTo( PTRANSFORM pt, PCVECTOR vforward, PCVECTOR vright );
	{
		RotateTo( &data, forward, right );
	}
	inline void RotateRel( RCOORD up, RCOORD right, RCOORD forward )
	{
		RotateRelV( &data, &up );
	}
	inline void RotateRel( PC_POINT p )
	{
		RotateRelV( &data, p );
	}
#if 0
	inline void Apply( P_POINT dest, PC_POINT src )
	//void Apply( PTRANSFORM pt, P_POINT dest, PC_POINT src );
	{
		Apply( &data, dest, src );
	}
	inline void ApplyRotation( P_POINT dest, PC_POINT src )
	//void ApplyRotation( PTRANSFORM pt, P_POINT dest, PC_POINT src );
	{
		ApplyRotation( &data, dest, src );
	}
	inline void Apply( PRAY dest, PRAY src )
	//void ApplyR( PTRANSFORM pt, PRAY dest, PRAY src );
	{
		ApplyR( &data, dest, src );
	}
	inline void ApplyInverse( P_POINT dest, PC_POINT src )
 // void ApplyInverse( PTRANSFORM pt, P_POINT dest, PC_POINT src );
	{
		ApplyInverse( &data, dest, src );
	}
	inline void ApplyInverse( PRAY dest, PRAY src )
	{	void ApplyInverseR( PTRANSFORM pt, PRAY dest, PRAY src );
		ApplyInverseR( &data, dest, src );
	}
	inline void ApplyInverseRotation( P_POINT dest, PC_POINT src )
	{	void ApplyInverseRotation( PTRANSFORM pt, P_POINT dest, PC_POINT src );
		ApplyInverseRotation( &data, dest, src );
	}
	inline void SetSpeed( RCOORD x, RCOORD y, RCOORD z )
	{	sack::math::vector::SetSpeed( &data, &x );
	}
	inline void SetSpeed( PC_POINT p )
	{	sack::math::vector::SetSpeed( &data, p );
	}
	inline void SetRotation( PC_POINT p )
	{	sack::math::vector::SetRotation( &data, p );
	}
	inline LOGICAL Move( void )
	{
		void Move( PTRANSFORM pt );
		return sack::math::vector::Move( &data );
	}
	inline void Unmove( void )
	{
		void Unmove( PTRANSFORM pt );
		sack::math::vector::Unmove( &data );
	}
	inline void clear( void )
	{
		sack::math::vector::ClearTransform( &data );
	}
	inline void RotateAbs( RCOORD x, RCOORD y, RCOORD z )
	{
		sack::math::vector::RotateAbsV( (PTRANSFORM)&data, &x );
	}
#endif
	inline void _GetAxis( P_POINT result, int n )
	{
		GetAxisV( (PTRANSFORM)&data, result, n );
	}
	inline PC_POINT _GetAxis( int n )
	{
		return GetAxis( (PTRANSFORM)&data, n);
	}
	PC_POINT _GetOrigin( void )
	{	return GetOrigin( (PTRANSFORM)&data );
	}
	void _GetOrigin( P_POINT p )
	{	GetOriginV( &data, p );
	}
	void show( char *header )
	{
		ShowTransformEx( &data, header DBG_SRC );
	}
	void _RotateRight( int a, int b )
	{
		RotateRight( (PTRANSFORM)&data, a, b );
	}
};
#endif
#endif
VECTOR_NAMESPACE_END
USE_VECTOR_NAMESPACE
#endif
// $Log: vectlib.h,v $
// Revision 1.13  2004/08/22 09:56:41  d3x0r
// checkpoint...
//
// Revision 1.12  2004/02/02 22:43:35  d3x0r
// Add lineseg type and orthoarea (min/max box)
//
// Revision 1.11  2004/01/11 23:24:15  panther
// Fix type warnings, conflicts, fix const issues
//
// Revision 1.10  2004/01/11 23:11:49  panther
// Fix const typings
//
// Revision 1.9  2004/01/11 23:10:38  panther
// Include keyboard to avoid windows errors
//
// Revision 1.8  2004/01/04 20:54:18  panther
// Use PCTRANSFORM for prototypes
//
// Revision 1.7  2003/12/29 08:10:18  panther
// Added more functions for applying transforms
//
// Revision 1.6  2003/11/22 23:27:11  panther
// Fix type passed to printvector
//
// Revision 1.5  2003/09/01 20:04:37  panther
// Added OpenGL Interface to windows video lib, Modified RCOORD comparison
//
// Revision 1.4  2003/03/25 08:38:11  panther
// Add logging
//
#if defined( _WIN32 ) && !defined( _INVERT_IMAGE ) && !defined( _OPENGL_DRIVER ) && !defined( _D3D_DRIVER )
#define _INVERT_IMAGE
#endif
#define WILL_DEFINE_IMAGE_STRUCTURE
#define IMAGE_STRUCTURE_DEFINED
IMAGE_NAMESPACE
#ifdef __cplusplus
	namespace Interface
{
	struct image_interface_tag;
}
#ifdef _D3D_DRIVER
	using namespace sack::image::d3d::Interface;
#elif defined( _D3D10_DRIVER )
	using namespace sack::image::d3d10::Interface;
#elif defined( _D3D11_DRIVER )
	using namespace sack::image::d3d11::Interface;
#else
	using namespace sack::image::Interface;
#endif
#endif
#ifndef PSPRITE_METHOD
#define PSPRITE_METHOD PSPRITE_METHOD
/* pointer to a structure defining a sprite draw method this should be defined in render namespace...*/
	typedef struct sprite_method_tag *PSPRITE_METHOD;
#endif
	/* Flags which may be combined in <link sack::image::ImageFile_tag::flags, Image.flags> */
	enum ImageFlags {
 // this has been freed - but contains sub images
IF_FLAG_FREE   =0x00001,
 // moved beyond parent image's bound
IF_FLAG_HIDDEN =0x00002,
 // built with a *image from external sources
IF_FLAG_EXTERN_COLORS =0x00004,
 // pay attention to (clips) array.
IF_FLAG_HAS_CLIPS     =0x00008,
// with no _X_STRING flag - characters are shown as literal character glyph.
 // strings on this use 'c' processing
IF_FLAG_C_STRING       = 0x00010,
 // strings on this use menu processing ( &underline )
IF_FLAG_MENU_STRING    = 0x00020,
 // strings use control chars (newline, tab)
IF_FLAG_CONTROL_STRING = 0x00040,
 // this has been freed - but contains sub images
IF_FLAG_OWN_DATA       = 0x00080,
  // image is inverted (standard under windows, but this allows images to be configured dynamically - a hack to match SDL lameness )
IF_FLAG_INVERTED       = 0x00100,
// DisplayLib uses this flag - indicates panel root
 // please #define user flag to this
IF_FLAG_USER1          = 0x10000,
// DisplayLib uses this flag - indicates is part of a displayed panel
IF_FLAG_USER2          = 0x20000,
IF_FLAG_USER3          = 0x40000,
 // output should render to opengl target (with transform); also used with proxy
IF_FLAG_FINAL_RENDER   = 0x00200,
 // set when a operation has changed the surface of a local image; requires update to remote device(s)
IF_FLAG_UPDATED        = 0x00400,
 // set when a operation has changed the surface of a local image; requires update to remote device(s)
IF_FLAG_HAS_PUTSTRING  = 0x00800,
 // is an in-memory image; that is the surface can be written to directly with pixel ops (putstring)
IF_FLAG_IN_MEMORY      = 0x01000,
	};
//#define _DRAWPOINT_X 0
//#define _DRAWPOINT_Y 1
struct ImageFile_tag
{
#if defined( IMAGE_LIBRARY_SOURCE ) || defined( NEED_REAL_IMAGE_STRUCTURE )
	int real_x;
	int real_y;
   // desired height and width may not be actual cause of
	int real_width;
  // resizing of parent image....
	int real_height;
# ifdef HAVE_ANONYMOUS_STRUCTURES
	IMAGE_RECTANGLE;
# else
 // need this for sub images - otherwise is irrelavent
	int x;
	int y;
  /// Width of image.
	int width;
 /// Height of image.
	int height;
# endif
#else
	/* X coordinate of the image within another image. */
	int x;
	/* Y coordinate of an image within another image. */
	int y;
   // desired height and width may not be actual cause of
	int width;
  // resizing of parent image....
	int height;
 // need this for sub images - otherwise is irrelavent
	int actual_x;
	int actual_y;
  // Width of image.
	int actual_width;
 // Height of image.
	int actual_height;
#endif
 // width of real physical layer
	int pwidth;
	// The image data.
	PCOLOR image;
	/* a combination of <link ImageFlags, IF_FLAG_> (ImageFile Flag)
	   which apply to this image.                                    */
	int flags;
	/* This points to a peer image that existed before this one. If
	   NULL, there is no elder, otherwise, contains the next peer
	   image in the same parent image.                              */
	/* Points to the parent image of a sub-image. (The parent image
	   contains this image)                                         */
	/* Pointer to the youngest child sub-image. If there are no sub
	   images pChild will be NULL. Otherwise, pchild points at the
	   first of one or more sub images. Other sub images in this one
	   are found by following the pElder link of the pChild.         */
	/* This points at a more recently created sub-image. (another
	   sub image within the same parent, but younger)             */
	struct ImageFile_tag *pParent, *pChild, *pElder, *pYounger;
	   // effective x - clipped by reality real coordinate.
	           // (often eff_x = -real_x )
	int eff_x;
	/* this is used internally for knowing what the effective y of
	   the image is. If the sub-image spans a boundry of a parent
	   image, then the effective Y that will be worked with is only
	   a part of the subimage.                                      */
	int eff_y;
		// effective max - maximum coordinate...
	int eff_maxx;
		// effective maximum Y
	int eff_maxy;
		/* An extra rectangle that can be used to carry additional
		 information like update region.                         */
	IMAGE_RECTANGLE auxrect;
	// fonts need a way to output the font character subimages to the real image...
	// or for 3D; to reverse scale appropriately
	struct image_interface_tag  *reverse_interface;
 // what the interface thinks this is...
	POINTER reverse_interface_instance;
	void (*extra_close)( struct ImageFile_tag *);
//DOM-IGNORE-BEGIN
#if defined( __3D__ )
	PTRANSFORM transform;
#endif
#ifdef _OPENGL_DRIVER
	/* gl context? */
	LOGICAL depthTest;
	PLIST glSurface;
 // most things will still use this, since reload image is called first, reload will set active
	int glActiveSurface;
  // updated with SetTransformRelation, otherwise defaults to image size.
	VECTOR coords[4];
#endif
#ifdef _D3D10_DRIVER
	PLIST Surfaces;
	ID3D10Texture2D *pActiveSurface;
#endif
#ifdef _D3D11_DRIVER
	PLIST Surfaces;
	ID3D11Texture2D *pActiveSurface;
#endif
#ifdef _D3D_DRIVER
	/* gl context? */
	PLIST Surfaces;
	IDirect3DBaseTexture9 *pActiveSurface;
#endif
#ifdef _VULKAN_DRIVER
	LOGICAL depthTest;
	PLIST vkSurface;
 // most things will still use this, since reload image is called first, reload will set active
	int vkActiveSurface;
  // updated with SetTransformRelation, otherwise defaults to image size.
	VECTOR coords[4];
#endif
#ifdef __cplusplus
 // watcom limits protections in structs to protected and public
#ifndef __WATCOMC__
private:
#endif
#endif
//DOM-IGNORE-END
};
enum SlicedImageSection {
	SLICED_IMAGE_TOP_LEFT,
	SLICED_IMAGE_TOP,
	SLICED_IMAGE_TOP_RIGHT,
	SLICED_IMAGE_LEFT,
	SLICED_IMAGE_CENTER,
	SLICED_IMAGE_RIGHT,
	SLICED_IMAGE_BOTTOM_LEFT,
	SLICED_IMAGE_BOTTOM,
	SLICED_IMAGE_BOTTOM_RIGHT,
};
struct SlicedImageFile {
	struct ImageFile_tag *image;
	struct ImageFile_tag *slices[9];
	uint32_t left, right, top, bottom;
	uint32_t center_w, center_h;
	uint32_t right_w;
	uint32_t bottom_h;
	LOGICAL output_center;
	LOGICAL extended_slice;
};
/* The basic structure. This is referenced by applications as '<link sack::image::Image, Image>'
	This is the primary type that the image library works with.
	This is the internal definition.
	This is a actual data content, Image is (ImageFile *).                                        */
typedef struct ImageFile_tag ImageFile;
/* A simple wrapper to add dynamic changing position and
	orientation to an image. Sprites can be output at any angle. */
struct sprite_tag
{
	/* Current location of the sprite's origin. */
	/* Current location of the sprite's origin. */
  // current x and current y for placement on image.
	int32_t curx, cury;
  // int of bitmap hotspot... centers cur on hot
	int32_t hotx, hoty;
	Image image;
	// curx,y are kept for moving the sprite independantly
	fixed scalex, scaley;
	// radians from 0 -> 2*pi.  there is no negative...
 // radians for now... (used internally, set by blot rotated sprite)
	float angle;
	// should consider keeping the angle of rotation
	// and also should cosider keeping velocity/acceleration
	// but then limits would have to be kept also... so perhaps
	// the game module should keep such silly factors... but then couldn't
	// it also keep curx, cury ?  though hotx hoty is the actual
	// origin to rotate this image about, and to draw ON curx 0 cury 0
	// int orgx, orgy;  // rotated origin of bitmap.
	// after being drawn the min(x,y) and max(x,y) are set.
 // after draw, these are the extent of the sprite.
	int32_t minx, maxx;
 // after draw, these are the extent of the sprite.
	int32_t miny, maxy;
	PSPRITE_METHOD pSpriteMethod;
};
/* A Sprite type. Adds position and rotation and motion factors
	to an image. Hooks into the render system to get an update to
	draw on a temporary layer after the base rendering is done.   */
typedef struct sprite_tag SPRITE;
#ifdef _INVERT_IMAGE
// inversion does not account for eff_y - only eff_maxy
// eff maxy - eff_minY???
/*+((i)->eff_y)*/
#define INVERTY(i,y)     ( (((i)->eff_maxy) - (y)))
#else
/* This is a macro is used when image data is inverted on a
	platform. (Windows images, the first row of data is the
	bottom of the image, all Image operations are specified from
	the top-left as 0,0)                                         */
#define INVERTY(i,y)     ((y) - (i)->eff_y)
#endif
/*+((i)->eff_y)*/
#define INVERTY_INVERTED(i,y)     ( (((i)->eff_maxy) - (y)))
#define INVERTY_NON_INVERTED(i,y)     ((y) - (i)->eff_y)
#if defined(__cplusplus_cli ) && !defined( IMAGE_SOURCE )
//IMAGE_PROC( PCDATA, ImageAddress )( Image image, int32_t x, int32_t y );
//#define IMG_ADDRESS(i,x,y) ImageAddress( i,x,y )
#else
#define IMG_ADDRESS(i,x,y)    ((CDATA*)	                             ((i)->image + (( (x) - (i)->eff_x )	 +(((i)->flags&IF_FLAG_INVERTED)?(INVERTY_INVERTED( (i), (y) ) * (i)->pwidth ):(INVERTY_NON_INVERTED( (i), (y) ) * (i)->pwidth ))	                             ))										   )
#endif
#if 0
#if defined( __arm__ ) && defined( IMAGE_LIBRARY_SOURCE ) && !defined( DISPLAY_SOURCE )
extern unsigned char AlphaTable[256][256];
static CDATA DOALPHA( CDATA over, CDATA in, uint8_t a )
{
	int r, g, b, aout;
	if( !a )
		return over;
	if( a > 255 )
		a = 255;
	if( a == 255 )
 // force alpha full on.
		return (in | 0xFF000000);
	aout = AlphaTable[a][AlphaVal( over )] << 24;
	r = ((((RedVal(in))  *(a+1)) + ((RedVal(over))  *(256-(a)))) >> 8 );
	if( r > (255) ) r = (255);
	g = (((GreenVal(in))*(a+1)) + ((GreenVal(over))*(256-(a)))) >> 8;
	if( g > (255) ) g = (255);
	b = ((((BlueVal(in)) *(a+1)) + ((BlueVal(over)) *(256-(a)))) >> 8 );
	if( b > 255 ) b = 255;
	return aout|(r<<16)|(g<<8)|b;
	//return AColor( r, g, b, aout );
}
#endif
#endif
IMAGE_NAMESPACE_END
// end if_not_included
#endif
// $Log: imagestruct.h,v $
// Revision 1.2  2005/04/05 11:56:04  panther
// Adding sprite support - might have added an extra draw callback...
//
// Revision 1.1  2004/06/21 07:38:39  d3x0r
// Move structures into common...
//
// Revision 1.20  2003/10/14 20:48:55  panther
// Tweak mmx a bit - no improvement visible but shorter
//
// Revision 1.19  2003/10/14 16:36:45  panther
// Oops doalpha was outside of known inclusion frame
//
// Revision 1.18  2003/10/14 00:43:03  panther
// Arm optimizations.  Looks like I'm about maxed.
//
// Revision 1.17  2003/09/15 17:06:37  panther
// Fixed to image, display, controls, support user defined clipping , nearly clearing correct portions of frame when clearing hotspots...
//
// Revision 1.16  2003/04/25 08:33:09  panther
// Okay move the -1's back out of IMG_ADDRESS
//
// Revision 1.15  2003/04/21 23:33:09  panther
// fix certain image ops - should check blot direct...
//
// Revision 1.14  2003/03/30 18:39:03  panther
// Update image blotters to use IMG_ADDRESS
//
// Revision 1.13  2003/03/30 16:11:03  panther
// Clipping images works now... blat image untested
//
// Revision 1.12  2003/03/30 06:24:56  panther
// Turns out I had badly implemented clipping...
//
// Revision 1.11  2003/03/25 08:45:51  panther
// Added CVS logging tag
//
#if defined( __cplusplus )
IMAGE_NAMESPACE
#endif
/* pointer to a sprite type. */
typedef struct sprite_tag *PSPRITE;
//#endif
// at some point, it may be VERY useful
// to have this structure also have a public member.
//
#ifndef NO_FONT
typedef struct simple_font_tag {
 // all characters same height
   uint16_t height;
 // number of characters in the set
   uint16_t characters;
 // open ended array size characters...
   uint8_t char_width[1];
} FontData;
/* Contains information about a font for drawing and rendering
   from a font file.                                           */
typedef struct font_tag *SFTFont;
#endif
/* A definition of a block structure to transport font and image
   data across message queues.                                   */
/* Type of buffer used to transfer data across message queues. */
typedef struct data_transfer_state_tag {
   /* size of this block of data. */
   uint32_t size;
   /* offset of the data in the total message. Have to break up
      large buffers into smaller chunks for transfer.           */
   uint32_t offset;
   /* buffer containing the data to transfer. */
   CDATA buffer;
} *DataState;
//-----------------------------------------------------
enum string_behavior {
   // every character assumed to have a glyph-including '\0'
   STRING_PRINT_RAW
 // control characters perform 'typical' actions - newline, tab, backspace...
   ,STRING_PRINT_CONTROL
  // c style escape characters are handled \n \b \x## - literal text
   ,STRING_PRINT_C
   ,STRING_PRINT_MENU
 /* &amp; performs an underline, also does C style handling. \\&amp;
                         == &amp;                                                         */
};
/* Definitions of symbols to pass to <link SetBlotMethod> to
   specify optimization method.                              */
enum blot_methods {
    /* A Symbol to pass to <link SetBlotMethod> to specify using C
      coded primitives. (for shading and alpha blending).         */
    BLOT_C
   , BLOT_ASM
/* A Symbol to pass to <link SetBlotMethod> to specify using
      primitives with assembly optimization (for shading and alpha
      blending).                                                   */
						,
                  /* A Symbol to pass to <link SetBlotMethod> to specify using
      primitives with MMX optimization (for shading and alpha
      blending).                                                */
    BLOT_MMX
};
// specify the method that pixels are copied from one image to another
enum BlotOperation {
   /* copy the pixels from one image to another with no color transform*/
 BLOT_COPY = 0,
   // copy the pixels from one image to another with no color transform, scaling by a single color
 BLOT_SHADED = 1,
   // copy the pixels from one image to another with no color transform, scaling independant R, G and B color channels to a combination of an R Color, B Color, G Color
 BLOT_MULTISHADE = 2,
   /* copy the pixels from one image to another with simple color inversion transform*/
 BLOT_INVERTED = 3,
 /* orientation blots for fonts to 3D and external displays */
 BLOT_ORIENT_NORMAL = 0x00,
 BLOT_ORIENT_INVERT = 0x04,
 BLOT_ORIENT_VERTICAL = 0x08,
 BLOT_ORIENT_VERTICAL_INVERT = 0x0C,
 BLOT_ORIENTATTION = 0x0C,
};
/* Transparency parameter definition
   0 : no transparency - completely opaque
   1 (TRUE): 0 colors (absolute transparency) only
   2-255 : 0 color transparent, plus transparency factor applied
   to all 2 - mostly almost completely transparent 255 not
   transparent (opaque)
   257-511 : alpha transparency in pixel plus transparency value
   \- 256 0 pixels will be transparent 257 - slightly more
   opaquen than the original 511 - image totally opaque - alpha
   will be totally overriden no addition 511 nearly completely
   transparent 512-767 ; the low byte of this is subtracted from
   the alpha of the image ; this allows images to be more
   transparent than they were originally 512 - no modification
   alpha imge normal 600 - mid range... more transparent 767 -
   totally transparent any value of transparent greater than the
   max will be clipped to max this will make very high values
   opaque totally...                                             */
enum AlphaModifier {
   /* Direct alpha copy - whatever the alpha is is what the output will be.  Adding a value of 0-255 here will increase the base opacity by that much */
	ALPHA_TRANSPARENT = 0x100,
   // Inverse alpha copy - whatever the alpha is is what the output will be.  Adding a value of 0-255 here will decrease the base opacity by that much
ALPHA_TRANSPARENT_INVERT = 0x200,
   // more than this clips to total transparency
	// for line, plot more than 255 will
// be total opaque... this max only
	// applies to blotted images
ALPHA_TRANSPARENT_MAX = 0x2FF
};
/* library global changes. string behavior cannot be tracked per
   image. string behavior should, for all strings, be the same
   usage for an application... so behavior is associated with
   the particular stream and/or image family. does not modify
   character handling behavior - only strings.
   See Also
   <link sack::image::string_behavior, String Behaviors>         */
   IMAGE_PROC  void IMAGE_API  SetStringBehavior( Image pImage, uint32_t behavior );
   /* Specify the optimized code to draw with. There are 3 levels,
      C - routines coded in C, ASM - assembly optimization (32bit
      NASM), MMX assembly but taking advantage of MMX features.    */
   IMAGE_PROC  void IMAGE_API  SetBlotMethod    ( uint32_t method );
   /* This routine can be used to generically scale to any point
      between two colors.
      Parameters
      Color 1 :   CDATA color to scale from
      Color 2 :   CDATA color to scale to
      distance :  How from from 0 to max distance to scale.
      max :       How wide the scalar is.
      Remarks
      Max is the scale that distance can go from. Distance 0 is the
      first color, Distance == max is the second color. The
      distance from 0 to max proportionately scaled the color....
      Example
      <code lang="c++">
      CDATA green = BASE_COLOR_GREEN;
      CDATA blue = BASE_COLOR_BLUE;
      CDATA red = BASE_COLOR_RED;
      </code>
      Compute a color that is halfway from blue to green. (if the
      total distance is 100, then 50 is half way).
      <code lang="c++">
      CDATA blue_green = ColorAverage( blue, green, 50, 100 );
      </code>
      Compute a color that's mostly red.
      <code lang="c++">
      CDATA red_blue_green = ColorAverage( blue_green, red, 240, 255 );
      </code>
      Iterate through a whole scaled range...
      <code lang="c++">
      int n;
      for( n = 0; n \< 100; n++ )
      {
          CDATA scaled = ColorAverage( BASE_COLOR_WHITE, BASE_COLOR_BLACK, n, 100 );
          // as n increases, the color slowly goes from WHITE to BLACK.
      }
      </code>                                                                        */
   IMAGE_PROC  CDATA ColorAverage( CDATA c1, CDATA c2, int d, int max );
   /* Creates an image from user defined parts. The buffer used is
      from the user. This was used by the video library, but
      RemakeImage accomplishes this also.
      Parameters
      pc :      the color buffer to use for the image.
      width :   how wide the color buffer is
      height :  How tall the color buffer is                       */
   IMAGE_PROC  Image IMAGE_API BuildImageFileEx ( PCOLOR pc, uint32_t width, uint32_t height DBG_PASS);
   /* <combine sack::image::MakeImageFile>
      Adds <link sack::DBG_PASS, DBG_PASS> parameter. */
   /* Creates an Image with a specified width and height. The
      image's color is undefined to start.
      Parameters
      Width :     how wide to make the image. Cannot be negative.
      Height :    how tall to make the image. Cannot be negative.
      DBG_PASS :  _nt_
      Example
      See <link sack::image::Image, Image>                        */
   IMAGE_PROC  Image IMAGE_API MakeImageFileEx  (uint32_t Width, uint32_t Height DBG_PASS);
   /* Creates a sub image region on an image. Sub-images may be
      used like any other image. There are two uses for this sort
      of thing. OH, the sub image shares the exact data of the
      parent image, and is not a copy.
      Parameters
      pImage :  image to make the sub image in
      x :       signed location of the top side of the sub\-image
      y :       signed location of the left side of the sub\-image
      width :   how wide to make the sub\-image
      height :  how tall to make the sub\-image
      Returns
      NULL if the input image is NULL.
      Otherwise returns an Image.
      Example
      Use 1: An image might contain a grid of symbols or
      characters, each exactly the same size. These may be token
      peices used in a game or a special graphic font.
      <code lang="c++">
      Image peices_image = LoadImageFile( "Game Peices.image" );
      PLIST peices = NULL;
      int x, y;
      \#define PEICE_WIDTH 32
      \#define PEICE_HEIGHT 32
      for( x = 0; x \< 10; x++ )
         for( y = 0; y \< 2; y++ )
         {
             AddLink( &amp;peices, MakeSubImage( peices_image
                                           , x * PEICE_WIDTH, y * PEICE_HEIGHT
                                           , PEICE_WIDTH, PEICE_HEIGHT );
         }
      // at this point there we have a list with all the tokens,
      // which were 32x32 pixels each.
      // Any of these peice images may be output using a scaled or direct blot.
      </code>
      Use 2: Partitioning views on an image for things like
      controls and other clipped regions.
      <code lang="c++">
      Image image = MakeImageFile( 1024, 768 );
      Image clock = MakeSubImage( image, 32, 32, 150, 16 );
      DrawString( clock, 0, 0, BASE_COLOR_WHITE, BASE_COLOR_BLACK, "Current Time..." );
      </code>                                                                           */
   IMAGE_PROC  Image IMAGE_API MakeSubImageEx   ( Image pImage, int32_t x, int32_t y, uint32_t width, uint32_t height DBG_PASS );
   /* Adds an image as a sub-image of another image. The image
      being added as a sub image must not already have a parent.
      Sub-images are like views into the parent, and share the same
      pixel buffer that the parent has.
      Parameters
      pFoster :  This is the parent image to received the new
                 subimage
      pOrphan :  this is the subimage to be added                   */
   IMAGE_PROC  void IMAGE_API  AdoptSubImage    ( Image pFoster, Image pOrphan );
   /* Removes a sub-image (child image) from a parent image. The
      sub image my then be moved to another image with
      AdoptSubImage.
      Parameters
      pImage :  the sub\-image to orphan.                        */
   IMAGE_PROC  void IMAGE_API  OrphanSubImage   ( Image pImage );
   /* Create or recreate an image using the specified color buffer,
      and size. All sub-images have their color data reference
      updated.
      Example
      <code>
      Image image = NULL;
      POINTER data = NewArray( CDATA, 100* 100 );
      image = RemakeImage( image, data, 100, 100 );
      </code>
      Remarks
      If the source image is NULL, a new image will be built using
      the color buffer and size specified.
      Image.flags has IF_FLAG_EXTERN_COLORS set if made this way,
      since the color buffer is an external resource. This causes
      UnmakeImage() to not attempt to free the color buffer.
      If the original image does exist, its color buffer is swapped
      for the one specified, and coordinates are updated. The video
      system uses this to create an image that has the color data
      surface the surface of the display.
      See Also
      <link sack::image::BuildImageFile, BuildImageFile>
      GetDisplayImage
      Parameters
      data :    Pointer to a buffer of 32 bit color data. ARGB and
                ABGR available via compile option.
      width :   the width of the data in pixels.
      height :  the height of the data in pixels.
      Returns
      \Returns the original image if not NULL, otherwise results
      with an image who's color plane is defined by a user defined
      buffer of width by height size. The user must have allocated
      this buffer appropriately, and is responsible for its
      destruction.                                                  */
   IMAGE_PROC  Image IMAGE_API RemakeImageEx    ( Image pImage, PCOLOR pc, uint32_t width, uint32_t height DBG_PASS);
   /* Load an image file. Today we support PNG, JPG, GIF, BMP.
      Tomorrow consider tapping into that FreeImage project on
      sourceforge, that combines all readers into one.
      Parameters
      name :      Filename to read from. Opens in 'Current Directory'
                  if not an absolute path.
      DBG_PASS :  _nt_
      Example
      See <link sack::image::Image, Image>                            */
	IMAGE_PROC  Image IMAGE_API LoadImageFileEx  ( CTEXTSTR name DBG_PASS );
	/* <combinewith sack::image::LoadImageFileEx@CTEXTSTR name>
	   Extended load image file. This allows specifying a file group
	   to load from. (Groups were added for platforms without
	   support of current working directory).
	   Parameters
	   group :  Group to load the file from
	   _nt_ :   _nt_                                                 */
	IMAGE_PROC Image  IMAGE_API LoadImageFileFromGroupEx ( INDEX group, CTEXTSTR filename DBG_PASS );
   /* Decodes a block of memory into an image. This is used
      internally so, LoadImageFile() opens the file and reads it
      into a buffer, which it then passes to DecodeMemoryToImage().
      Images stored in custom user structures may be passed for
      decoding also.
      Parameters
      buf :   Pointer to bytes of data to decode
      size :  the size of the buffer to decode
      Returns
      NULL is returned if the data does not decode as an image.
      an Image is returned otherwise.
      Example
      This pretends that you have a FILE* open to some image
      already, and that the image is tiny (less than 4k bytes).
      <code lang="c#">
      char buffer[4096];
      int length;
      length = fread( buffer, 1, 4096, some_file );
      Image image = DecodeMemoryToImage( buffer, length );
      if( image )
      {
         // buffer decoded okay.
      }
      </code>                                                       */
			IMAGE_PROC  Image IMAGE_API  DecodeMemoryToImage ( uint8_t* buf, size_t size );
#ifdef __cplusplus
		namespace loader{
#endif
	IMAGE_PROC  LOGICAL IMAGE_API  PngImageFile ( Image image, uint8_t* *buf, size_t *size );
	IMAGE_PROC  LOGICAL IMAGE_API  JpgImageFile ( Image image, uint8_t* *buf, size_t *size, int Q );
#ifdef __cplusplus
		}
#endif
      /* direct hack for processing clipboard data... probably does some massaging of the databefore calling DecodeMemoryToImage */
   IMAGE_PROC  Image IMAGE_API  ImageRawBMPFile (uint8_t* ptr, uint32_t filesize);
	/* Releases an image, has extra debug parameters.
	   Parameters
	   Image :     the Image to release.
	   DBG_PASS :  Adds <link sack::DBG_PASS, DBG_PASS> parameter for
	               the release memory tracking.                       */
	IMAGE_PROC  void IMAGE_API UnmakeImageFileEx ( Image pif DBG_PASS );
   /* Sets the active image rectangle to the bounding rectangle
      specified. This can be used to limit artificially drawing
      onto an image. (It is easier to track to create a subimage in
      the location to draw instead of masking with a bound rect,
      which has problems restoring back to initial conditions)
      Parameters
      pImage :  Image to set the drawing clipping rectangle.
      bound :   a pointer to an IMAGE_RECTANGLE to set the image
                boundaries to.                                      */
   IMAGE_PROC  void  IMAGE_API SetImageBound    ( Image pImage, P_IMAGE_RECTANGLE bound );
// reset clip rectangle to the full image (subimage part )
// Some operations (move, resize) will also reset the bound rect,
// this must be re-set afterwards.
// ALSO - one SHOULD be nice and reset the rectangle when done,
// otherwise other people may not have checked this.
/* Change the size of an image, reallocating the color buffer as
   necessary.
   <b>Parameters</b>
   <b>Remarks</b>
   If the image is a sub image (located within a parent), the
   subimage view on the parent image is updated to the new width
   and height. The color buffer remains the parent's buffer.
   If the image is a parent, a new buffer is allocated. If the
   previous buffer was specified by the user in RemakeImage,
   that buffer is not freed, but a new buffer is still created.
   <b>Bugs</b>
   If the image is a parent image, the child images are not
   updated to the newly allocated buffer. Resize works really
   well for subimages though.                                    */
   IMAGE_PROC  void IMAGE_API ResizeImageEx     ( Image pImage, int32_t width, int32_t height DBG_PASS);
   /* Moves an image within a parent image. Top level images and
      images which have a user color buffer do not move.
      Parameters
      pImage :  The image to move.
      x :       the new X coordinate of the image.
      y :       the new Y coordinate of the image.               */
   IMAGE_PROC  void IMAGE_API MoveImage         ( Image pImage, int32_t x, int32_t y );
//-----------------------------------------------------
   IMAGE_PROC  void IMAGE_API BlatColor         ( Image pifDest, int32_t x, int32_t y, uint32_t w, uint32_t h, CDATA color );
   /* Blat is the sound a trumpet makes when it spews forth
      noise... so Blat color is just fill a rectangle with a color,
      quickly. Apply alpha transparency of the color specified.
      Parameters
      pifDest :  The destination image to fill the rectangle on
      x :        left coordinate of the rectangle
      y :        right coordinate of the rectangle
      w :        width of the rectangle
      h :        height of the rectangle
      color :    color to fill the rectangle with. The alpha of this
                 color will be applied.                              */
   IMAGE_PROC  void IMAGE_API BlatColorAlpha    ( Image pifDest, int32_t x, int32_t y, uint32_t w, uint32_t h, CDATA color );
   /* \ \
      Parameters
      pDest :         destination image (the one to copy to)
      pIF :           source image
      x :             destination top coordinate
      y :             destination left coordinate
      nTransparent :  <link sack::image::AlphaModifier, Alpha Operation>
      method :        <link sack::image::blot_methods, Blot Method>
      _nt_ :          _nt_                                               */
   IMAGE_PROC  void IMAGE_API BlotImageEx       ( Image pDest, Image pIF, int32_t x, int32_t y, uint32_t nTransparent, uint32_t method, ... );
   /* Copies an image from one image onto another. The copy is done
      directly and no scaling is applied. If a width or height
      larget than the image to copy is specified, only the amount
      of the image that is valid is copied.
      Parameters
      pDest :         Destination image
      pIF :           Image file to copy
      x :             X position to put copy at
      y :             Y position to put copy at
      xs :            X position to copy from.
      ys :            Y position to copy from.
      wd :            how much of the image horizontally to copy
      ht :            how much of the image vertically to copy
      nTransparent :  <link sack::image::AlphaModifier, Alpha Transparency method>
      method :        <link sack::image::blot_methods, BlotMethods>
      <b>Method == BLOT_SHADED extra parameters</b>
      red :    Color to use the red channel to output the scale from
               black to color
      green :  Color to use the red channel to output the scale from
               black to color
      blue :   Color to use the red channel to output the scale from
               black to color
      <b>Method == BLOT_SHADED extra parameters</b>
      shade :  _nt_
      See Also                                                                     */
   IMAGE_PROC  void IMAGE_API BlotImageSizedEx  ( Image pDest, Image pIF, int32_t x, int32_t y, int32_t xs, int32_t ys, uint32_t wd, uint32_t ht, uint32_t nTransparent, uint32_t method, ... );
   /* Copies some or all of an image to a destination image of
      specified width and height. This does linear interpolation
      scaling.
      There are simple forms of this function as macros, since
      commonly you want to output the entire image, a macro which
      automatically sets (0,0),(width,height) as the source
      \parameters to output the whole image exists.
      Parameters
      \ \
      pifDest :       Destination image
      pifSrc :        image to copy from
      xd :            destination x coordinate
      yd :            destination y coordinate
      wd :            destination width (source image width will be
                      scaled to this)
      hd :            destination height (source image height will
                      be scaled to this)
      xs :            source x coordinate (where to copy from)
      ys :            source y coordinate (where to copy from)
      ws :            source width (how much of the image to copy)
      hs :            source height (how much of the image to copy)
      nTransparent :  Alpha method...
      method :        specifies how the source color data is
                      transformed if at all. See BlotMethods
      ... :           possible extra parameters depending on method
      <b>Method == BLOT_MULTISHADE extra parameters</b>
      red :    Color to use the red channel to output the scale from
               black to color
      green :  Color to use the red channel to output the scale from
               black to color
      blue :   Color to use the red channel to output the scale from
               black to color
      <b>Method == BLOT_SHADED extra parameters</b>
      shade :  _nt_
      See Also
      <link sack::image::AlphaModifier, Alpha Methods>
      <link sack::image::blot_methods, Blot Methods>
      <link sack::image::BlotScaledImage, BlotScaledImage>
      <link sack::image::BlotScaledImageShaded, BlotScaledImageShaded>
      <link sack::image::BlotScaledImageShadedAlpha, BlotScaledImageShadedAlpha>
                                                                                 */
   IMAGE_PROC  void IMAGE_API BlotScaledImageSizedEx( Image pifDest, Image pifSrc
                                   , int32_t xd, int32_t yd
                                   , uint32_t wd, uint32_t hd
                                   , int32_t xs, int32_t ys
                                   , uint32_t ws, uint32_t hs
                                   , uint32_t nTransparent
                                   , uint32_t method, ... );
/* Your basic PLOT functions (Image.C, plotasm.asm)
   A function pointer to the function which sets a pixel in an
   image at a specified x, y coordinate.
   Parameters
   Image :  The image to get the pixel from
   X :      x coordinate to get pixel color
   Y :      y coordinate to get pixel color
   Color :  color to put at the coordinate. image will be set
            exactly to this color, and whatever the alpha of the
            color is.                                            */
   IMAGE_PROC  void plot       ( Image pi, int32_t x, int32_t y, CDATA c );
   /* A function pointer to the function which sets a pixel in an
      image at a specified x, y coordinate.
      Parameters
      Image :  The image to get the pixel from
      X :      x coordinate to get pixel color
      Y :      y coordinate to get pixel color
      Color :  color to put at the coordinate. Alpha blending will be
               done.                                                  */
   IMAGE_PROC  void plotalpha  ( Image pi, int32_t x, int32_t y, CDATA c );
   /* A function pointer to the function which gets a pixel from an
      image at a specified x, y coordinate.
      Parameters
      Image :  The image to get the pixel from
      X :      x coordinate to get pixel color
      Y :      y coordinate to get pixel color
      Returns
      CDATA color in the Image at the specified coordinate.         */
   IMAGE_PROC  CDATA getpixel  ( Image pi, int32_t x, int32_t y );
//-------------------------------
// Line functions  (lineasm.asm) // should include a line.c ... for now core was assembly...
//-------------------------------
  // d is color data...
   IMAGE_PROC  void do_line      ( Image pBuffer, int32_t x, int32_t y, int32_t xto, int32_t yto, CDATA color );
  // d is color data...
   IMAGE_PROC  void do_lineAlpha ( Image pBuffer, int32_t x, int32_t y, int32_t xto, int32_t yto, CDATA color);
   /* This is a function pointer that references a function to do
      optimized horizontal lines. The function pointer is updated
      when SetBlotMethod() is called.
      Parameters
      Image :   the image to draw to
      Y :       the y coordinate of the line (how far down from top to
                draw it)
      x_from :  X coordinate to draw from
      x_to :    X coordinate to draw to
      color :   the color of the line. This color will be set to the
                surface, the alpha result will be the alpha of this
                color.                                                 */
   IMAGE_PROC  void do_hline      ( Image pImage, int32_t y, int32_t xfrom, int32_t xto, CDATA color );
   /* This is a function pointer that references a function to do
      optimized vertical lines. The function pointer is updated
      when SetBlotMethod() is called.
      Parameters
      Image :   the image to draw to
      X :       the x coordinate of the line (how far over to draw
                it)
      y_from :  Y coordinate to draw from
      y_to :    Y coordinate to draw to
      color :   the color of the line. This color will be set to the
                surface, the alpha result will be the alpha of this
                color.                                               */
   IMAGE_PROC  void do_vline      ( Image pImage, int32_t x, int32_t yfrom, int32_t yto, CDATA color );
   /* This is a function pointer that references a function to do
      optimized horizontal lines with alpha blending. The function
      pointer is updated when SetBlotMethod() is called.
      Parameters
      Image :   the image to draw to
      Y :       the Y coordinate of the line (how far down from top
                of image to draw it)
      x_from :  X coordinate to draw from
      x_to :    X coordinate to draw to
      color :   the color of the line (alpha component of the color
                will be applied)                                    */
   IMAGE_PROC  void do_hlineAlpha ( Image pImage, int32_t y, int32_t xfrom, int32_t xto, CDATA color );
   /* This is a function pointer that references a function to do
      optimized vertical lines with alpha blending. The function
      pointer is updated when SetBlotMethod() is called.
      Parameters
      Image :   the image to draw to
      X :       the x coordinate of the line (how far over to draw
                it)
      y_from :  Y coordinate to draw from
      y_to :    Y coordinate to draw to
      color :   the color of the line (alpha component of the color
                will be applied)                                    */
   IMAGE_PROC  void do_vlineAlpha ( Image pImage, int32_t x, int32_t yfrom, int32_t yto, CDATA color );
	/* routine which iterates through the points along a lone from
	   x,y to xto,yto, calling a user function at each point.
	   Parameters
	   Image :  the image to pretend to draw on
	   x :      draw from this x coordinate
	   y :      draw from this y coordinate
	   xto :    draw to this x coordinate
	   yto :    draw to this y coordinate
	   d :      userdata (color data)
	   func :   user callback function to a function of type...<p />void
	            func( Image pif, int32_t x, int32_t y, int d ) ;
	   Remarks
	   The Image passed does not HAVE to be an Image, it can be any
	   user POINTER.
	   The data passed is limited to 32 bits, and will not hold a
	   pointer if built for 64 bit platform.
	   Example
	   <code lang="c++">
	   Image image;
	   void MyPlotter( Image image, int32_t x, int32_t y, CDATA color )
	   {
	       // do something with the image at x,y
	   }
	   void UseMyPlotter( Image image )
	   {
	       do_lineExV( image, 10, 10, 80, 80, BASE_COLOR_BLACK, MyPlotter );
	   }
	   </code>                                                               */
	IMAGE_PROC  void do_lineExV    ( Image pImage, int32_t x, int32_t y
									, int32_t xto, int32_t yto, uintptr_t color
		                            , void (*func)( Image pif, int32_t x, int32_t y, uintptr_t d ) );
   /* \Returns the correct SFTFont pointer to the default font. In all
      font functions, NULL may be used as the font, and this is the
      font that will be used.
      Parameters
      None.
      Example
      <code lang="c++">
      SFTFont font = GetDefaultFont();
      </code>                                                       */
   IMAGE_PROC  SFTFont IMAGE_API GetDefaultFont ( void );
   /* \Returns the height of a font for purposes of spacing between
      lines. Characters may render outside of this height.
      Parameters
      SFTFont :  SFTFont to get the height of. if NULL returns an internal
              font's height.
      Returns
      the height of the font.                                        */
   IMAGE_PROC  uint32_t  IMAGE_API GetFontHeight  ( SFTFont );
   /* \Returns the approximate rectangle that would be used for a
      string. It only counts using the line measurement. Newlines
      in strings count to wrap text to subsequent lines and start
      recounting the width, returning the maximum length of string
      horizontally.
      Parameters
      pString :  The string to measure
      len :      the length of characters to count in string
      width :    a pointer to a uint32_t to receive the width of the
                 string
      height :   a pointer to a uint32_t to receive the height of the
                 string
      UseFont :  A SFTFont to use.
      Returns
      \Returns the width parameter. If NULL are passed for width
      and height, this is OK. One of the simple macros just passes
      the string and gets the return - this is for how wide the
      string would be.                                             */
   IMAGE_PROC  uint32_t  IMAGE_API GetStringSizeFontEx( CTEXTSTR pString, size_t len, uint32_t *width, uint32_t *height, SFTFont UseFont );
   /* Fill the width and height with the actual size of the string
      as it is drawn. (may be above or below the original
      rectangle)
      Parameters
      pString :     the string to measure
      nLen :        the number of characters in the string
      width :       a pointer to a 32 bit value to get resulting
                    width
      height :      a pointer to a 32 bit value to get resulting
                    height
      charheight :  the actual height of the characters (as reports
                    by line)
      UseFont :     a SFTFont to use. If NULL use a default internal
                    font.                                           */
   IMAGE_PROC  uint32_t IMAGE_API  GetStringRenderSizeFontEx ( CTEXTSTR pString, size_t nLen, uint32_t *width, uint32_t *height, uint32_t *charheight, SFTFont UseFont );
// background of color 0,0,0 is transparent - alpha component does not
// matter....
   IMAGE_PROC  void IMAGE_API PutCharacterFont              ( Image pImage
                                                  , int32_t x, int32_t y
                                                  , CDATA color, CDATA background,
                                                   TEXTCHAR c, SFTFont font );
   /* Outputs a string in the specified font, from the specified
      point, text is drawn from the point up, with the characters
      aligned with the top to the left; it goes up from the point.
      the point becomes the bottom left of the rectangle output.
      Parameters
      pImage :      image to draw string into
      x :           x position of the string
      y :           y position of the string
      color :       color of the data drawn in the font
      background :  color of the data not drawn in the font
      c :           the character to output
      font :        the font to use. NULL use an internal default
                    font.                                          */
   IMAGE_PROC  void IMAGE_API PutCharacterVerticalFont      ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
   /* Outputs a string in the specified font, from the specified
      point, text is drawn from the point to the left, with the
      characters aligned with the top to the left; it goes up from
      the point. the point becomes the bottom left of the rectangle
      \output.
      Parameters
      pImage :      image to draw string into
      x :           x position of the string
      y :           y position of the string
      color :       color of the data drawn in the font
      background :  color of the data not drawn in the font
      pc :          pointer to constant text
      nLen :        length of text to output
      font :        the font to use. NULL use an internal default
                    font.                                           */
   IMAGE_PROC  void IMAGE_API PutCharacterInvertFont        ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
   /* Outputs a character in the specified font, from the specified
      point, text is drawn from the point up, with the characters
      aligned with the top to the left; it goes up from the point. the
      point becomes the bottom left of the rectangle output.
      Parameters
                                                                       */
   IMAGE_PROC  void IMAGE_API PutCharacterVerticalInvertFont( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
   /* Outputs a string in the specified font, from the specified
      point, text is drawn right side up and godes from left to
      right. The point becomes the top left of the rectangle
      \output.
      Parameters
      pImage :      image to draw string into
      x :           x position of the string
      y :           y position of the string
      color :       color of the data drawn in the font
      background :  color of the data not drawn in the font
      pc :          pointer to constant text
      nLen :        length of text to output
      font :        the font to use. NULL use an internal default
                    font.                                         */
   IMAGE_PROC  void IMAGE_API PutStringFontEx              ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
   /* justification 0 is left, 1 is right, 2 is center */
   IMAGE_PROC  void IMAGE_API PutStringFontExx              ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font, int justication, uint32_t _width );
   /* Outputs a string in the specified font, from the specified
      point, text is drawn from the point down, with the characters
      aligned with the top to the right; it goes down from the
      point. the point becomes the top right of the rectangle
      \output.
      Parameters
      pImage :      image to draw string into
      x :           x position of the string
      y :           y position of the string
      color :       color of the data drawn in the font
      background :  color of the data not drawn in the font
      pc :          pointer to constant text
      nLen :        length of text to output
      font :        the font to use. NULL use an internal default
                    font.                                           */
   IMAGE_PROC  void IMAGE_API PutStringVerticalFontEx      ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
   /* Outputs a string in the specified font, from the specified
      point, text is drawn upside down, and goes to the left from
      the point. the point becomes the bottom right of the
      rectangle output.
      Parameters
      pImage :      image to draw string into
      x :           x position of the string
      y :           y position of the string
      color :       color of the data drawn in the font
      background :  color of the data not drawn in the font
      pc :          pointer to constant text
      nLen :        length of text to output
      font :        the font to use. NULL use an internal default
                    font.                                         */
   IMAGE_PROC  void IMAGE_API PutStringInvertFontEx        ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
   /* Outputs a string in the specified font, from the specified
      point, text is drawn from the point up, with the characters
      aligned with the top to the left; it goes up from the point. the
      point becomes the bottom left of the rectangle output.
      Parameters
      pImage :      image to draw string into
      x :           x position of the string
      y :           y position of the string
      color :       color of the data drawn in the font
      background :  color of the data not drawn in the font
      pc :          pointer to constant text
      nLen :        length of text to output
      font :        the font to use. NULL use an internal default
                    font.                                              */
   IMAGE_PROC  void IMAGE_API PutStringInvertVerticalFontEx( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
   //uint32_t (*PutMenuStringFontEx)            ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, uint32_t nLen, SFTFont font );
   //uint32_t (*PutCStringFontEx)               ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, uint32_t nLen, SFTFont font );
   IMAGE_PROC  uint32_t IMAGE_API  GetMaxStringLengthFont  ( uint32_t width, SFTFont UseFont );
   /* Used as a proper accessor method to get an image's width and
      height. Decided to allow the image structure to be mostly
      public, so the first 4 members are the images x,y, width and
      height, and are immediately accessable by the Image pointer.
      Parameters
      pImage :  image to get the size of
      width :   pointer to a 32 bit unsigned value to result with the
                width, if NULL ignored.
      height :  pointer to a 32 bit unsigned value to result with the
                height, if NULL ignored.                              */
   IMAGE_PROC  void IMAGE_API  GetImageSize            ( Image pImage, uint32_t *width, uint32_t *height );
   /* \Returns the pointer to the color buffer currently used
      \internal to the image.
      Parameters
      pImage :  Image to get the surface of.
      Example
      <code lang="c#">
      Image image = MakeImageFile( 100, 100 );
      PCDATA pointer_color_data = GetImageSurface( image );
      </code>
      Note
      This might be used to do an optimized output routine. Drawing
      to the image with plot and line are not necessarily the best
      for things like circles. Provides ability for user to output
      directly to the color buffer.                                 */
   IMAGE_PROC  PCDATA IMAGE_API  GetImageSurface        ( Image pImage );
   // would seem silly to load fonts - but for server implementations
   // the handle received is not the same as the font sent.
   IMAGE_PROC  SFTFont IMAGE_API  LoadFont                ( SFTFont font );
   /* Destroys a font, releasing all resources associated with
      character data and font rendering.                       */
   IMAGE_PROC  void IMAGE_API  UnloadFont              ( SFTFont font );
	/* This is a function used to synchronize image operations when
	   the image interface is across a message server.              */
	IMAGE_PROC  void IMAGE_API  SyncImage                  ( void );
	// intersect rectangle, results with the overlapping portion of R1 and R2
   // into R ...
   IMAGE_PROC  int IMAGE_API  IntersectRectangle ( IMAGE_RECTANGLE *r, IMAGE_RECTANGLE *r1, IMAGE_RECTANGLE *r2 );
   /* Merges two image rectangles. The resulting rectangle is a
      rectangle that includes both rectangles.
      Parameters
      r :   Pointer to an IMAGE_RECTANGLE for the result.
      r1 :  PIMAGE_RECTANGLE one rectangle.
      r2 :  PIMAGE_RECTANGLE the other rectangle.               */
   IMAGE_PROC  int IMAGE_API  MergeRectangle ( IMAGE_RECTANGLE *r, IMAGE_RECTANGLE *r1, IMAGE_RECTANGLE *r2 );
   /* User applications may use an aux rect attatched to an image. The
      'Display' render library used this itself however, making
      this mostly an internal feature.
      Parameters
      pImage :  image to get the aux rect of.
      pRect :   pointer to an IMAGE_RECTANGLE to get the aux
                rectangle data in.                                     */
   IMAGE_PROC  void IMAGE_API  GetImageAuxRect    ( Image pImage, P_IMAGE_RECTANGLE pRect );
   /* User applications may use an aux rect attatched to an image.
      The 'Display' render library used this itself however, making
      this mostly an internal feature.
      Parameters
      pImage :  image to set the aux rect of.
      pRect :   pointer to an IMAGE_RECTANGLE to set the aux
                rectangle to.                                       */
   IMAGE_PROC  void IMAGE_API  SetImageAuxRect    ( Image pImage, P_IMAGE_RECTANGLE pRect );
	/* \ \
	   Parameters
	   Filename :  \file name of image to load. Converts image into
	               sprite automatically, resulting with a sprite.
	   DBG_PASS :  See <link sack::DBG_PASS, DBG_PASS>              */
		IMAGE_PROC  PSPRITE IMAGE_API  MakeSpriteImageFileEx ( CTEXTSTR fname DBG_PASS );
      /* create a sprite from an Image */
	IMAGE_PROC  PSPRITE IMAGE_API  MakeSpriteImageEx ( Image image DBG_PASS );
	/* Release a Sprite. */
	IMAGE_PROC  void IMAGE_API  UnmakeSprite ( PSPRITE sprite, int bForceImageAlso );
	// angle is a fixed scaled integer with 0x1 0000 0000 being the full circle.
	IMAGE_PROC  void IMAGE_API  rotate_scaled_sprite (Image bmp, PSPRITE sprite, fixed angle, fixed scale_width, fixed scale_height );
   /* output a rotated sprite to destination image, using and angle specified.  The angle is represented as 0x1 0000 0000 is 360 degrees */
	IMAGE_PROC  void IMAGE_API  rotate_sprite (Image bmp, PSPRITE sprite, fixed angle);
   /* output a sprite at its current location */
	IMAGE_PROC  void IMAGE_API  BlotSprite ( Image pdest, PSPRITE ps );
/* Sets the point on a sprite which is the 'hotspot' the hotspot
   is the point that is drawn at the specified coordinate when
   outputting a sprite.
   Parameters
   sprite :  The PSPRITE to set the hotspot of.
   x :       x coordinate in the sprite's image that becomes the
             hotspot.
   y :       y coordinate in the sprite's image that becomes the
             hotspot.                                            */
IMAGE_PROC  PSPRITE IMAGE_API  SetSpriteHotspot ( PSPRITE sprite, int32_t x, int32_t y );
/* This function sets the current location of a sprite. When
   asked to render, the sprite will draw itself here.
   Parameters
   sprite :  the sprite to move
   x :       the new x coordinate of the parent image to draw at
   y :       the new y coordinate of the parent image to draw at */
IMAGE_PROC  PSPRITE IMAGE_API  SetSpritePosition ( PSPRITE sprite, int32_t x, int32_t y );
/* Use a font file to get a font that can be used for outputting
   characters and strings.
   Parameters
   file\ :    Filename of a font to render.
   nWidth :   desired width in pixels to render the font.
   nHeight :  desired height in pixels to render the font.
   flags :    0 = render mono. 2=render 2 bits, 3=render 8 bit.  */
IMAGE_PROC  SFTFont IMAGE_API  InternalRenderFontFile ( CTEXTSTR file
																		, int32_t nWidth
																		, int32_t nHeight
																		, PFRACTION width_scale
																		, PFRACTION height_scale
																		, uint32_t flags
																		);
/* Rerender the current font with a new size. */
IMAGE_PROC void IMAGE_API RerenderFont( SFTFont font, int32_t width, int32_t height, PFRACTION width_scale, PFRACTION height_scale );
	/* Dumps the whole cache to log file, shows family, style, path and filename.
    Is the same sort of dump that OpenFontFile uses.
	 */
IMAGE_PROC void IMAGE_API DumpFontCache( void );
#ifndef INTERNAL_DUMP_FONT_FILE
/* takes a font and dumps a header-file formatted file; then the font can be
 statically built into code. */
IMAGE_PROC void IMAGE_API DumpFontFile( CTEXTSTR name, SFTFont font_to_dump );
#endif
/* Creates a font based on indexes from the internal font cache.
   This is used by the FontPicker dialog to choose a font. The
   data the dialog used to render the font is available to the
   application, and may be passed back for rendering a font
   without knowing specifically what the values mean.
   Parameters
   nFamily :  The number of the family in the cache.
   nStyle :   The number of the style in the cache.
   nFile :    The number of the file in the cache.
   nWidth :   the width to use for rendering characters (in
              pixels)
   nHeight :  the height to use for rendering characters (in
              pixels)
   flags :    0 = render mono. 2=render 2 bits, 3=render 8 bit.
   Returns
   A SFTFont which can be used to output. If the file exists. NULL
   on failure.
   Example
   Used internally for FontPicker dialog, see <link sack::image::InternalRenderFontFile@CTEXTSTR@int32_t@int32_t@uint32_t, InternalRenderFontFile> */
IMAGE_PROC  SFTFont IMAGE_API  InternalRenderFont ( uint32_t nFamily
																  , uint32_t nStyle
																  , uint32_t nFile
																  , int32_t nWidth
																  , int32_t nHeight
																  , PFRACTION width_scale
																  , PFRACTION height_scale
																  , uint32_t flags
																  );
/* Releases all resources for a SFTFont.  */
IMAGE_PROC  void IMAGE_API  DestroyFont( SFTFont *font );
/* Get the global font data structure. This is an internal
   structure, and it's definition may not be exported. Currently
   the definition is in documentation.
   See Also
   <link sack::image::FONT_GLOBAL, SFTFont Global>                  */
IMAGE_PROC  struct font_global_tag * IMAGE_API  GetGlobalFonts( void );
// types of data which may result...
typedef struct font_data_tag *PFONTDATA;
/* Information to render a font from a file to memory. */
typedef struct render_font_data_tag *PRENDER_FONTDATA;
/* Recreates a SFTFont based on saved FontData. The resulting font
   may be scaled from its original size.
   Parameters
   pfd :           pointer to font data.
   width_scale :   FRACTION to scale the original font height
                   \description by. if NULL uses the original
                   font's size.
   height_scale :  FRACTION to scale the original font height
                   \description by.  if NULL uses the original
                   font's size.
   Example
   <code lang="c++">
   POINTER some_loaded_data; // pretend it is initialized to something valid
   SFTFont font = RenderScaledFontData( some_loaded_data, NULL, NULL );
   PutStringFont( image, 0, 0, BASE_COLOR_WHITE, 0, "Hello World", font );
   </code>
   Or, maybe your original designed screen was 1024x768, and
   it's now showing on 1600x1200, for the text to remain the
   same...
   <code lang="c++">
   FRACTION width_scale;
   FRACTION height_scale;
   uint32_t w, h;
   GetDisplaySize( &amp;w, &amp;h );
   SetFraction( width_scale, w, 1024 );
   SetFraction( height_scale, h, 768 );
   SFTFont font2 = RenderScaledFontData( some_loaded_data, &amp;width_scale, &amp;height_scale );
   PutStringFont( image, 0, 0, BASE_COLOR_WHITE, 0, "Hello World", font2 );
   </code>                                                                                     */
IMAGE_PROC  SFTFont IMAGE_API  RenderScaledFontData( PFONTDATA pfd, PFRACTION width_scale, PFRACTION height_scale );
/* <combine sack::image::RenderScaledFontData@PFONTDATA@PFRACTION@PFRACTION>
   \ \                                                                       */
#define RenderFontData(pfd) RenderScaledFontData( pfd,NULL,NULL )
/* <combinewith sack::image::RenderScaledFontEx@CTEXTSTR@uint32_t@uint32_t@PFRACTION@PFRACTION@uint32_t@size_t *@POINTER *, sack::image::RenderScaledFontData@PFONTDATA@PFRACTION@PFRACTION>
   \ \                                                                                                                                                                        */
IMAGE_PROC SFTFont IMAGE_API RenderScaledFontEx( CTEXTSTR name, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags, size_t *pnFontDataSize, POINTER *pFontData );
/* Renders a font with a FRACTION scalar for the X and Y sizes.
   Parameters
   name :          Name of the font (file).
   width :         Original width (in pels) to make the font.
   height :        Original height (in pels) to make the font.
   width_scale :   scalar to apply to the width
   height_scale :  scalar to apply to the height
   flags :         Flags specifying how many bits to render the
                   font with (and other info?) See enum
                   FontFlags.                                   */
IMAGE_PROC SFTFont IMAGE_API RenderScaledFont( CTEXTSTR name, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags );
#define RenderScaledFont(n,w,h,ws,hs) RenderScaledFontEx(n,w,h,ws,hs,NULL,NULL)
/* Renders a font file and returns a SFTFont. The font can then be
   used in string output functions to images.
   Parameters
   file\ :           \File name of a font to render. Any font
                     that freetype supports.
   width :           width of characters to render in.
   height :          height of characters to render.
   flags :           if( ( flags &amp; 3 ) == 3 )<p /> font\-\>flags
                     = FONT_FLAG_8BIT;<p /> else if( ( flags &amp;
                     3 ) == 2 )<p /> font\-\>flags =
                     FONT_FLAG_2BIT;<p /> else<p /> font\-\>flags
                     = FONT_FLAG_MONO;<p />
   pnFontDataSize :  optional pointer to a 32 bit value to
                     receive the size of rendered data.
   pFontData :       The render data. This data can be used to
                     recreate this font.                             */
IMAGE_PROC  SFTFont IMAGE_API  RenderFontFileScaledEx ( CTEXTSTR file, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags, size_t *pnFontDataSize, POINTER *pFontData );
/* <combine sack::image::RenderFontFileEx@CTEXTSTR@uint32_t@uint32_t@uint32_t@uint32_t*@POINTER *>
   \ \                                                                         */
#define RenderFontFile(file,w,h,flags) RenderFontFileScaledEx(file,w,h,NULL,NULL,flags,NULL,NULL)
#define RenderFontFileEx(file,w,h,flags,a,b) RenderFontFileScaledEx(file,w,h,NULL,NULL,flags,a,b )
		/* This can be used to get the internal description of a font,
		   which the user may then save, and use later to recreate the
		   font the same way.
		   Parameters
		   font :         SFTFont to get the render description from.
		   fontdata :     a pointer to a pointer which will be filled
		                  with a pointer buffer that has the font data.
		   fontdatalen :  a pointer to 32 bit value to receive the length
		                  of data.                                        */
		IMAGE_PROC  int IMAGE_API  GetFontRenderData ( SFTFont font, POINTER *fontdata, size_t *fontdatalen );
// exported for the PSI font chooser to set the data for the font
// to be retreived later when only the font handle remains.
IMAGE_PROC  void IMAGE_API  SetFontRendererData ( SFTFont font, POINTER pResult, size_t size );
#ifndef PSPRITE_METHOD
/* <combine sack::image::PSPRITE_METHOD>
   \ \                                   */
#define PSPRITE_METHOD PSPRITE_METHOD
	typedef struct sprite_method_tag *PSPRITE_METHOD;
#endif
	// provided for display rendering portion to define this method for sprites to use.
   // deliberately out of namespace... please do not move this up.
IMAGE_PROC  void IMAGE_API  SetSavePortion ( void (CPROC*_SavePortion )( PSPRITE_METHOD psm, uint32_t x, uint32_t y, uint32_t w, uint32_t h ) );
/* \Returns the red channel of the color
   Parameters
   color :  Color to get the red channel of.
   Returns
   The COLOR_CHANNEL (byte) of the red channel in the color. */
IMAGE_PROC COLOR_CHANNEL IMAGE_API GetRedValue( CDATA color ) ;
/* \Returns the green channel of the color
   Parameters
   color :  Color to get the green channel of.
   Returns
   The COLOR_CHANNEL (byte) of the green channel in the color. */
IMAGE_PROC COLOR_CHANNEL IMAGE_API GetGreenValue( CDATA color );
/* \Returns the blue channel of the color
   Parameters
   color :  Color to get the blue channel of.
   Returns
   The COLOR_CHANNEL (byte) of the blue channel in the color. */
IMAGE_PROC COLOR_CHANNEL IMAGE_API GetBlueValue( CDATA color );
/* \Returns the alpha channel of the color
   Parameters
   color :  Color to get the alpha channel of.
   Returns
   The COLOR_CHANNEL (byte) of the alpha channel in the color. */
IMAGE_PROC COLOR_CHANNEL IMAGE_API GetAlphaValue( CDATA color );
/* Sets the red channel in a color value.
   Parameters
   color :  Original color to modify
   b :      new red channel value         */
IMAGE_PROC CDATA IMAGE_API SetRedValue( CDATA color, COLOR_CHANNEL r ) ;
/* Sets the green channel in a color value.
   Parameters
   color :  Original color to modify
   g :      new green channel value         */
IMAGE_PROC CDATA IMAGE_API SetGreenValue( CDATA color, COLOR_CHANNEL green );
/* Sets the blue channel in a color value.
   Parameters
   color :  Original color to modify
   b :      new blue channel value         */
IMAGE_PROC CDATA IMAGE_API SetBlueValue( CDATA color, COLOR_CHANNEL b );
/* Sets the alpha channel in a color value.
   Parameters
   color :  Original color to modify
   a :      new alpha channel value         */
IMAGE_PROC CDATA IMAGE_API SetAlphaValue( CDATA color, COLOR_CHANNEL a );
/* Makes a CDATA color from the RGB components. Sets the alpha
   as 100% opaque.
   Parameters
   r :      red channel of new color
   green :  green channel of new color
   b :      blue channel of new color                          */
IMAGE_PROC CDATA IMAGE_API MakeColor( COLOR_CHANNEL r, COLOR_CHANNEL green, COLOR_CHANNEL b );
/* Create a CDATA color from components.
   Parameters
   r :      Red channel value
   green :  green channel value
   b :      blue channel value
   a :      alpha channel value
   Returns
   A CDATA representing the color specified. */
IMAGE_PROC CDATA IMAGE_API MakeAlphaColor( COLOR_CHANNEL r, COLOR_CHANNEL green, COLOR_CHANNEL b, COLOR_CHANNEL a );
/* With 3d renderer, images have a transformation matrix. This
   function allows you to get the transformation matrix.
   Parameters
   pImage :  image to get the transformation matrix of.        */
IMAGE_PROC  PTRANSFORM IMAGE_API GetImageTransformation( Image pImage );
enum image_translation_relation
{
   IMAGE_TRANSFORM_RELATIVE_CENTER = 0,
   IMAGE_TRANSFORM_RELATIVE_LEFT,
   IMAGE_TRANSFORM_RELATIVE_RIGHT,
   IMAGE_TRANSFORM_RELATIVE_TOP,
   IMAGE_TRANSFORM_RELATIVE_BOTTOM,
   IMAGE_TRANSFORM_RELATIVE_TOP_LEFT,
   IMAGE_TRANSFORM_RELATIVE_TOP_RIGHT,
   IMAGE_TRANSFORM_RELATIVE_BOTTOM_LEFT,
   IMAGE_TRANSFORM_RELATIVE_BOTTOM_RIGHT,
 // only mode that uses the 'aux' parameter of SetImageTransformRelation
   IMAGE_TRANSFORM_RELATIVE_OTHER
};
/*
 This sets flags on the image, so when it's called for rendering to the screen
 this is how
    */
IMAGE_PROC  void IMAGE_API SetImageTransformRelation( Image pImage, enum image_translation_relation relation, PRCOORD aux );
/*
 This just draws the image into the current 3d context.
 This is a point-sprite engine too....
 It does not setup anything about rendering this, just generates the texture at the right coords.
 Parameters
 render_pixel_scaled : when drawing, reverse compute from the angle of the view, and the depth of the thing to scale orthagonal, but at depth.  (help 3d vision)
 */
IMAGE_PROC  void IMAGE_API Render3dImage( Image pImage, PCVECTOR o, LOGICAL render_pixel_scaled );
IMAGE_PROC  void IMAGE_API Render3dText( CTEXTSTR string, int characters, CDATA color, SFTFont font, PCVECTOR o, LOGICAL render_pixel_scaled );
/*
  Utilized by fonts with images with reverse_interface set to transfer child images;
  may be generally useful; but had to be exposed through interface
  Might be a shallow move....
 */
IMAGE_PROC  void IMAGE_API TransferSubImages( Image pImageTo, Image pImageFrom );
IMAGE_PROC  LOGICAL IMAGE_API IsImageTargetFinal( Image image );
/* These flags are used in SetImageRotation and RotateImageAbout
   functions - these are part of the 3D driver interface
   extension. They allow for controlling how the rotation is
   performed.                                                    */
enum image_rotation_flags {
 // relative to center of image (center if not left, right, top or bottom )
	IMAGE_ROTATE_FLAG_CENTER = 0,
 // relative to top edge (center if not left or right)
   IMAGE_ROTATE_FLAG_TOP,
 // relative to left edge (center if not top or bottom)
   IMAGE_ROTATE_FLAG_LEFT,
 // relative to right edge (center if not top or bottom)
   IMAGE_ROTATE_FLAG_RIGHT,
 // relative to bottom edge (center if not left or right )
   IMAGE_ROTATE_FLAG_BOTTOM,
 // use the offset relative to the image orientation
	IMAGE_ROTATE_FLAG_ADD_CUSTOM_OFFSET
};
/* Sets the rotation matrix of an image to an arbitrary
   yaw/pitch/roll coordinate.
   Parameters
   pImage :     Image to rotate
   edge_flag :  what edge the rotation is relative to
   offset_x :   offset from the edge to get the center
   offset_y :   offset from the edge to get the center
   rx :         rotation about x axis (horizontal)
   ry :         rotation about y axis (vertical)
   rz :         rotation about z axis (into screen)     */
IMAGE_PROC void IMAGE_API SetImageRotation( Image pImage, int edge_flag, RCOORD offset_x, RCOORD offset_y, RCOORD rx, RCOORD ry, RCOORD rz );
/* Allows arbitrary rotation of an image in 3d render mode.
   Parameters
   pImage :     image to rotate
   edge_flag :  see enum image_rotation_flags
   offset_x :   offset from top left of image to center the
                rotation
   offset_y :   offset from top left of image to center the
                rotation
   vAxis :      axis to rotate around, can be any arbitrary
                direction
   angle :      angle of rotation around the axis.
   Remarks
   \See Also <link sack::image::image_rotation_flags, image_rotation_flags Enumeration> */
IMAGE_PROC void IMAGE_API RotateImageAbout( Image pImage, int edge_flag, RCOORD offset_x, RCOORD offset_y, PVECTOR vAxis, RCOORD angle );
IMAGE_PROC void IMAGE_API MarkImageDirty( Image pImage );
_INTERFACE_NAMESPACE
/* Defines a pointer member of the interface structure. */
#define IMAGE_PROC_PTR(type,name) type (CPROC*_##name)
/* Macro to build function pointer entries in the image
   interface.                                           */
//#define DIMAGE_PROC_PTR(type,name) type (CPROC**_##name)
/* This defines the interface call table. each function
   available in the API is reflected in this interface. It
   provdes a function table so applications don't have to be
   directly linked to the image API. This allows replacing the
   image API.                                                  */
typedef struct image_interface_tag
{
/* <combine sack::image::SetStringBehavior@Image@uint32_t>
   Internal
   Interface index 4                                  */
 IMAGE_PROC_PTR( void, SetStringBehavior) ( Image pImage, uint32_t behavior );
/* <combine sack::image::SetBlotMethod@uint32_t>
   \ \
   Internal
   Interface index 5                        */
 IMAGE_PROC_PTR( void, SetBlotMethod)     ( uint32_t method );
/*
   Internal
   Interface index 6*/
   IMAGE_PROC_PTR( Image,BuildImageFileEx) ( PCOLOR pc, uint32_t width, uint32_t height DBG_PASS);
/* <combine sack::image::MakeImageFileEx@uint32_t@uint32_t Height>
   Internal
   Interface index 7*/
  IMAGE_PROC_PTR( Image,MakeImageFileEx)  (uint32_t Width, uint32_t Height DBG_PASS);
/* <combine sack::image::MakeSubImageEx@Image@int32_t@int32_t@uint32_t@uint32_t height>
   Internal
   Interface index 8                                                                    */
   IMAGE_PROC_PTR( Image,MakeSubImageEx)   ( Image pImage, int32_t x, int32_t y, uint32_t width, uint32_t height DBG_PASS );
/* <combine sack::image::RemakeImageEx@Image@PCOLOR@uint32_t@uint32_t height>
   \ \
   <b>Internal</b>
   Interface index 9                                                */
   IMAGE_PROC_PTR( Image,RemakeImageEx)    ( Image pImage, PCOLOR pc, uint32_t width, uint32_t height DBG_PASS);
/* <combine sack::image::LoadImageFileEx@CTEXTSTR name>
   Internal
   Interface index 10                                                   */
  IMAGE_PROC_PTR( Image,LoadImageFileEx)  ( CTEXTSTR name DBG_PASS );
/* <combine sack::image::UnmakeImageFileEx@Image pif>
   Internal
   Interface index 11                                                 */
  IMAGE_PROC_PTR( void,UnmakeImageFileEx) ( Image pif DBG_PASS );
#define UnmakeImageFile(pif) UnmakeImageFileEx( pif DBG_SRC )
//-----------------------------------------------------
/* <combine sack::image::ResizeImageEx@Image@int32_t@int32_t height>
   Internal
   Interface index 14                                                          */
  IMAGE_PROC_PTR( void,ResizeImageEx)     ( Image pImage, int32_t width, int32_t height DBG_PASS);
/* <combine sack::image::MoveImage@Image@int32_t@int32_t>
   Internal
   Interface index 15                                               */
   IMAGE_PROC_PTR( void,MoveImage)         ( Image pImage, int32_t x, int32_t y );
//-----------------------------------------------------
/* <combine sack::image::BlatColor@Image@int32_t@int32_t@uint32_t@uint32_t@CDATA>
   Internal
   Interface index 16                                                             */
   IMAGE_PROC_PTR( void,BlatColor)     ( Image pifDest, int32_t x, int32_t y, uint32_t w, uint32_t h, CDATA color );
/* <combine sack::image::BlatColorAlpha@Image@int32_t@int32_t@uint32_t@uint32_t@CDATA>
   Internal
   Interface index 17                                                                  */
   IMAGE_PROC_PTR( void,BlatColorAlpha)( Image pifDest, int32_t x, int32_t y, uint32_t w, uint32_t h, CDATA color );
/* <combine sack::image::BlotImageEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@...>
   Internal
	Interface index 18*/
   IMAGE_PROC_PTR( void,BlotImageEx)     ( Image pDest, Image pIF, int32_t x, int32_t y, uint32_t nTransparent, uint32_t method, ... );
 /* <combine sack::image::BlotImageSizedEx@Image@Image@int32_t@int32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   Internal
	Interface index 19*/
   IMAGE_PROC_PTR( void,BlotImageSizedEx)( Image pDest, Image pIF, int32_t x, int32_t y, int32_t xs, int32_t ys, uint32_t wd, uint32_t ht, uint32_t nTransparent, uint32_t method, ... );
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
  Internal
   Interface index  20                                                                                                        */
   IMAGE_PROC_PTR( void,BlotScaledImageSizedEx)( Image pifDest, Image pifSrc
                                   , int32_t xd, int32_t yd
                                   , uint32_t wd, uint32_t hd
                                   , int32_t xs, int32_t ys
                                   , uint32_t ws, uint32_t hs
                                   , uint32_t nTransparent
                                   , uint32_t method, ... );
/*Internal
   Interface index 21*/
   IMAGE_PROC_PTR( void,plot)      ( Image pi, int32_t x, int32_t y, CDATA c );
/*Internal
   Interface index 22*/
   IMAGE_PROC_PTR( void,plotalpha) ( Image pi, int32_t x, int32_t y, CDATA c );
/*Internal
   Interface index 23*/
   IMAGE_PROC_PTR( CDATA,getpixel) ( Image pi, int32_t x, int32_t y );
/*Internal
   Interface index 24*/
  // d is color data...
   IMAGE_PROC_PTR( void,do_line)     ( Image pBuffer, int32_t x, int32_t y, int32_t xto, int32_t yto, CDATA color );
/*Internal
   Interface index 25*/
  // d is color data...
   IMAGE_PROC_PTR( void,do_lineAlpha)( Image pBuffer, int32_t x, int32_t y, int32_t xto, int32_t yto, CDATA color);
/*Internal
   Interface index 26*/
   IMAGE_PROC_PTR( void,do_hline)     ( Image pImage, int32_t y, int32_t xfrom, int32_t xto, CDATA color );
/*Internal
   Interface index 27*/
   IMAGE_PROC_PTR( void,do_vline)     ( Image pImage, int32_t x, int32_t yfrom, int32_t yto, CDATA color );
/*Internal
   Interface index 28*/
   IMAGE_PROC_PTR( void,do_hlineAlpha)( Image pImage, int32_t y, int32_t xfrom, int32_t xto, CDATA color );
/*Internal
   Interface index 29*/
   IMAGE_PROC_PTR( void,do_vlineAlpha)( Image pImage, int32_t x, int32_t yfrom, int32_t yto, CDATA color );
/* <combine sack::image::GetDefaultFont>
   Internal
   Interface index 30                    */
   IMAGE_PROC_PTR( SFTFont,GetDefaultFont) ( void );
/* <combine sack::image::GetFontHeight@SFTFont>
   Internal
   Interface index 31                                        */
   IMAGE_PROC_PTR( uint32_t ,GetFontHeight)  ( SFTFont );
/* <combine sack::image::GetStringSizeFontEx@CTEXTSTR@size_t@uint32_t *@uint32_t *@SFTFont>
   Internal
   Interface index 32                                                          */
   IMAGE_PROC_PTR( uint32_t ,GetStringSizeFontEx)( CTEXTSTR pString, size_t len, uint32_t *width, uint32_t *height, SFTFont UseFont );
/* <combine sack::image::PutCharacterFont@Image@int32_t@int32_t@CDATA@CDATA@uint32_t@SFTFont>
   Internal
   Interface index 33                                                           */
   IMAGE_PROC_PTR( void,PutCharacterFont)              ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
/* <combine sack::image::PutCharacterVerticalFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   Internal
   Interface index 34                                                                                        */
   IMAGE_PROC_PTR( void,PutCharacterVerticalFont)      ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
/* <combine sack::image::PutCharacterInvertFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   Internal
   Interface index 35                                                                                      */
   IMAGE_PROC_PTR( void,PutCharacterInvertFont)        ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
/* <combine sack::image::PutCharacterVerticalInvertFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   Internal
   Interface index 36                                                                                              */
   IMAGE_PROC_PTR( void,PutCharacterVerticalInvertFont)( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
/* <combine sack::image::PutStringFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   Internal
   Interface index 37                                                                                   */
   IMAGE_PROC_PTR( void,PutStringFontEx)              ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
/* <combine sack::image::PutStringVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   Internal
   Interface index 38                                                                                           */
   IMAGE_PROC_PTR( void,PutStringVerticalFontEx)      ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
/* <combine sack::image::PutStringInvertFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   Internal
   Interface index 39                                                                                         */
   IMAGE_PROC_PTR( void,PutStringInvertFontEx)        ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
/* <combine sack::image::PutStringInvertVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   Internal
   Interface index 40                                                                                                 */
   IMAGE_PROC_PTR( void,PutStringInvertVerticalFontEx)( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
/* <combine sack::image::GetMaxStringLengthFont@uint32_t@SFTFont>
   Internal
   Interface index 41                                     */
   IMAGE_PROC_PTR( uint32_t, GetMaxStringLengthFont )( uint32_t width, SFTFont UseFont );
/* <combine sack::image::GetImageSize@Image@uint32_t *@uint32_t *>
   Internal
   Interface index 42                                                    */
   IMAGE_PROC_PTR( void, GetImageSize)                ( Image pImage, uint32_t *width, uint32_t *height );
/* <combine sack::image::LoadFont@SFTFont>
   Internal
   Interface index 43                                   */
   IMAGE_PROC_PTR( SFTFont, LoadFont )                   ( SFTFont font );
         /* <combine sack::image::UnloadFont@SFTFont>
            \ \                                    */
         IMAGE_PROC_PTR( void, UnloadFont )                 ( SFTFont font );
/* Internal
   Interface index 44
   This is used by internal methods to transfer image and font
   data to the render agent.                                   */
   IMAGE_PROC_PTR( DataState, BeginTransferData )    ( uint32_t total_size, uint32_t segsize, CDATA data );
/* Internal
   Interface index 45
   Used internally to transfer data to render agent. */
   IMAGE_PROC_PTR( void, ContinueTransferData )      ( DataState state, uint32_t segsize, CDATA data );
/* Internal
   Interface index 46
   Command issues at end of data transfer to decode the data
   into an image.                                            */
   IMAGE_PROC_PTR( Image, DecodeTransferredImage )    ( DataState state );
/* After a data transfer decode the information as a font.
   Internal
   Interface index 47                                      */
   IMAGE_PROC_PTR( SFTFont, AcceptTransferredFont )     ( DataState state );
/*Internal
   Interface index 48*/
   IMAGE_PROC_PTR( CDATA, ColorAverage )( CDATA c1, CDATA c2
                                              , int d, int max );
/* <combine sack::image::SyncImage>
   Internal
   Interface index 49               */
   IMAGE_PROC_PTR( void, SyncImage )                 ( void );
         /* <combine sack::image::GetImageSurface@Image>
            \ \                                          */
         IMAGE_PROC_PTR( PCDATA, GetImageSurface )       ( Image pImage );
         /* <combine sack::image::IntersectRectangle@IMAGE_RECTANGLE *@IMAGE_RECTANGLE *@IMAGE_RECTANGLE *>
            \ \                                                                                             */
         IMAGE_PROC_PTR( int, IntersectRectangle )      ( IMAGE_RECTANGLE *r, IMAGE_RECTANGLE *r1, IMAGE_RECTANGLE *r2 );
   /* <combine sack::image::MergeRectangle@IMAGE_RECTANGLE *@IMAGE_RECTANGLE *@IMAGE_RECTANGLE *>
      \ \                                                                                         */
   IMAGE_PROC_PTR( int, MergeRectangle )( IMAGE_RECTANGLE *r, IMAGE_RECTANGLE *r1, IMAGE_RECTANGLE *r2 );
   /* <combine sack::image::GetImageAuxRect@Image@P_IMAGE_RECTANGLE>
      \ \                                                            */
   IMAGE_PROC_PTR( void, GetImageAuxRect )   ( Image pImage, P_IMAGE_RECTANGLE pRect );
   /* <combine sack::image::SetImageAuxRect@Image@P_IMAGE_RECTANGLE>
      \ \                                                            */
   IMAGE_PROC_PTR( void, SetImageAuxRect )   ( Image pImage, P_IMAGE_RECTANGLE pRect );
   /* <combine sack::image::OrphanSubImage@Image>
      \ \                                         */
   IMAGE_PROC_PTR( void, OrphanSubImage )  ( Image pImage );
   /* <combine sack::image::AdoptSubImage@Image@Image>
      \ \                                              */
   IMAGE_PROC_PTR( void, AdoptSubImage )   ( Image pFoster, Image pOrphan );
	/* <combine sack::image::MakeSpriteImageFileEx@CTEXTSTR fname>
	   \ \                                                         */
	IMAGE_PROC_PTR( PSPRITE, MakeSpriteImageFileEx )( CTEXTSTR fname DBG_PASS );
	/* <combine sack::image::MakeSpriteImageEx@Image image>
	   \ \                                                  */
	IMAGE_PROC_PTR( PSPRITE, MakeSpriteImageEx )( Image image DBG_PASS );
	/* <combine sack::image::rotate_scaled_sprite@Image@PSPRITE@fixed@fixed@fixed>
	   \ \                                                                         */
	IMAGE_PROC_PTR( void   , rotate_scaled_sprite )(Image bmp, PSPRITE sprite, fixed angle, fixed scale_width, fixed scale_height);
	/* <combine sack::image::rotate_sprite@Image@PSPRITE@fixed>
	   \ \                                                      */
	IMAGE_PROC_PTR( void   , rotate_sprite )(Image bmp, PSPRITE sprite, fixed angle);
 /* <combine sack::image::BlotSprite@Image@PSPRITE>
	 Internal
   Interface index 61                                              */
		IMAGE_PROC_PTR( void   , BlotSprite )( Image pdest, PSPRITE ps );
    /* <combine sack::image::DecodeMemoryToImage@uint8_t*@uint32_t>
       \ \                                                */
    IMAGE_PROC_PTR( Image, DecodeMemoryToImage )( uint8_t* buf, size_t size );
   /* <combine sack::image::InternalRenderFontFile@CTEXTSTR@int32_t@int32_t@uint32_t>
      \returns a SFTFont                                                      */
	IMAGE_PROC_PTR( SFTFont, InternalRenderFontFile )( CTEXTSTR file
																 , int32_t nWidth
																 , int32_t nHeight
																		, PFRACTION width_scale
																		, PFRACTION height_scale
																 , uint32_t flags
																 );
   /* <combine sack::image::InternalRenderFont@uint32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t>
      requires knowing the font cache....                                 */
	IMAGE_PROC_PTR( SFTFont, InternalRenderFont )( uint32_t nFamily
															, uint32_t nStyle
															, uint32_t nFile
															, int32_t nWidth
															, int32_t nHeight
																		, PFRACTION width_scale
																		, PFRACTION height_scale
															, uint32_t flags
															);
/* <combine sack::image::RenderScaledFontData@PFONTDATA@PFRACTION@PFRACTION>
   \ \                                                                       */
IMAGE_PROC_PTR( SFTFont, RenderScaledFontData)( PFONTDATA pfd, PFRACTION width_scale, PFRACTION height_scale );
/* <combine sack::image::RenderFontFileEx@CTEXTSTR@uint32_t@uint32_t@uint32_t@uint32_t*@POINTER *>
   \ \                                                                         */
IMAGE_PROC_PTR( SFTFont, RenderFontFileScaledEx )( CTEXTSTR file, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags, size_t *size, POINTER *pFontData );
/* <combine sack::image::DestroyFont@SFTFont *>
   \ \                                       */
IMAGE_PROC_PTR( void, DestroyFont)( SFTFont *font );
/* <combine sack::image::GetGlobalFonts>
   global_font_data in interface is really a global font data. Don't
   have to call GetGlobalFont to get this.                           */
struct font_global_tag *_global_font_data;
/* <combine sack::image::GetFontRenderData@SFTFont@POINTER *@uint32_t *>
   \ \                                                           */
IMAGE_PROC_PTR( int, GetFontRenderData )( SFTFont font, POINTER *fontdata, size_t *fontdatalen );
/* <combine sack::image::SetFontRendererData@SFTFont@POINTER@uint32_t>
   \ \                                                         */
IMAGE_PROC_PTR( void, SetFontRendererData )( SFTFont font, POINTER pResult, size_t size );
/* <combine sack::image::SetSpriteHotspot@PSPRITE@int32_t@int32_t>
   \ \                                                       */
IMAGE_PROC_PTR( PSPRITE, SetSpriteHotspot )( PSPRITE sprite, int32_t x, int32_t y );
/* <combine sack::image::SetSpritePosition@PSPRITE@int32_t@int32_t>
   \ \                                                        */
IMAGE_PROC_PTR( PSPRITE, SetSpritePosition )( PSPRITE sprite, int32_t x, int32_t y );
	/* <combine sack::image::UnmakeImageFileEx@Image pif>
	   \ \                                                */
	IMAGE_PROC_PTR( void, UnmakeSprite )( PSPRITE sprite, int bForceImageAlso );
/* <combine sack::image::GetGlobalFonts>
   \ \                                   */
IMAGE_PROC_PTR( struct font_global_tag *, GetGlobalFonts)( void );
/* <combinewith sack::image::GetStringRenderSizeFontEx@CTEXTSTR@uint32_t@uint32_t *@uint32_t *@uint32_t *@SFTFont, sack::image::GetStringRenderSizeFontEx@CTEXTSTR@size_t@uint32_t *@uint32_t *@uint32_t *@SFTFont>
   \ \                                                                                                                                                                     */
IMAGE_PROC_PTR( uint32_t, GetStringRenderSizeFontEx )( CTEXTSTR pString, size_t nLen, uint32_t *width, uint32_t *height, uint32_t *charheight, SFTFont UseFont );
IMAGE_PROC_PTR( Image, LoadImageFileFromGroupEx )( INDEX group, CTEXTSTR filename DBG_PASS );
IMAGE_PROC_PTR( SFTFont, RenderScaledFont )( CTEXTSTR name, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags );
IMAGE_PROC_PTR( SFTFont, RenderScaledFontEx )( CTEXTSTR name, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags, size_t *pnFontDataSize, POINTER *pFontData );
IMAGE_PROC_PTR( COLOR_CHANNEL, GetRedValue )( CDATA color ) ;
IMAGE_PROC_PTR( COLOR_CHANNEL, GetGreenValue )( CDATA color );
IMAGE_PROC_PTR( COLOR_CHANNEL, GetBlueValue )( CDATA color );
IMAGE_PROC_PTR( COLOR_CHANNEL, GetAlphaValue )( CDATA color );
IMAGE_PROC_PTR( CDATA, SetRedValue )( CDATA color, COLOR_CHANNEL r ) ;
IMAGE_PROC_PTR( CDATA, SetGreenValue )( CDATA color, COLOR_CHANNEL green );
IMAGE_PROC_PTR( CDATA, SetBlueValue )( CDATA color, COLOR_CHANNEL b );
IMAGE_PROC_PTR( CDATA, SetAlphaValue )( CDATA color, COLOR_CHANNEL a );
IMAGE_PROC_PTR( CDATA, MakeColor )( COLOR_CHANNEL r, COLOR_CHANNEL green, COLOR_CHANNEL b );
IMAGE_PROC_PTR( CDATA, MakeAlphaColor )( COLOR_CHANNEL r, COLOR_CHANNEL green, COLOR_CHANNEL b, COLOR_CHANNEL a );
IMAGE_PROC_PTR( PTRANSFORM, GetImageTransformation )( Image pImage );
IMAGE_PROC_PTR( void, SetImageRotation )( Image pImage, int edge_flag, RCOORD offset_x, RCOORD offset_y, RCOORD rx, RCOORD ry, RCOORD rz );
IMAGE_PROC_PTR( void, RotateImageAbout )( Image pImage, int edge_flag, RCOORD offset_x, RCOORD offset_y, PVECTOR vAxis, RCOORD angle );
IMAGE_PROC_PTR( void, MarkImageDirty )( Image pImage );
IMAGE_PROC_PTR( void, DumpFontCache )( void );
IMAGE_PROC_PTR( void, RerenderFont )( SFTFont font, int32_t width, int32_t height, PFRACTION width_scale, PFRACTION height_scale );
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
IMAGE_PROC_PTR( int, ReloadTexture )( Image child_image, int option );
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
IMAGE_PROC_PTR( int, ReloadShadedTexture )( Image child_image, int option, CDATA color );
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
IMAGE_PROC_PTR( int, ReloadMultiShadedTexture )( Image child_image, int option, CDATA red, CDATA green, CDATA blue );
IMAGE_PROC_PTR( void, SetImageTransformRelation )( Image pImage, enum image_translation_relation relation, PRCOORD aux );
IMAGE_PROC_PTR( void, Render3dImage )( Image pImage, PCVECTOR o, LOGICAL render_pixel_scaled );
IMAGE_PROC_PTR( void, DumpFontFile )( CTEXTSTR name, SFTFont font_to_dump );
IMAGE_PROC_PTR( void, Render3dText )( CTEXTSTR string, int characters, CDATA color, SFTFont font, PCVECTOR o, LOGICAL render_pixel_scaled );
// transfer all sub images to new image using appropriate methods
// extension for internal fonts to be utilized by external plugins...
IMAGE_PROC_PTR( void, TransferSubImages )( Image pImageTo, Image pImageFrom );
// when using reverse interfaces, need a way to get the real image
// from the fake image (proxy image)
IMAGE_PROC_PTR( Image, GetNativeImage )( Image pImageTo );
// low level support for proxy; this exposes some image_common.c routines
IMAGE_PROC_PTR( Image, GetTintedImage )( Image child_image, CDATA color );
IMAGE_PROC_PTR( Image, GetShadedImage )( Image child_image, CDATA red, CDATA green, CDATA blue );
// test for IF_FLAG_FINAL_RENDER (non physical surface/prevent local copy-restore)
IMAGE_PROC_PTR( LOGICAL, IsImageTargetFinal )( Image image );
// use image data to create a clone of the image for the new application instance...
// this is used when a common image resource is used for all application instances
// it should be triggered during onconnect.
// it is a new image instance that should be used for future app references...
IMAGE_PROC_PTR( Image, ReuseImage )( Image image );
IMAGE_PROC_PTR( void, PutStringFontExx )( Image pImage
											 , int32_t x, int32_t y
											 , CDATA color, CDATA background
											 , CTEXTSTR pc, size_t nLen, SFTFont font, int justification, uint32_t _width );
// sometimes it's not possible to use blatcolor to clear an imate...
// sometimes its parent is not redrawn?
IMAGE_PROC_PTR( void, ResetImageBuffers )( Image image, LOGICAL image_only );
	IMAGE_PROC_PTR(  LOGICAL, PngImageFile )( Image image, uint8_t* *buf, size_t *size );
	IMAGE_PROC_PTR(  LOGICAL, JpgImageFile )( Image image, uint8_t* *buf, size_t *size, int Q );
	IMAGE_PROC_PTR(  void, SetFontBias )( SFTFont font, int32_t x, int32_t y );
	IMAGE_PROC_PTR( SlicedImage, MakeSlicedImage )( Image source, uint32_t left, uint32_t right, uint32_t top, uint32_t bottom, LOGICAL output_center );
	IMAGE_PROC_PTR( SlicedImage, MakeSlicedImageComplex )( Image source
										, uint32_t top_left_x, uint32_t top_left_y, uint32_t top_left_width, uint32_t top_left_height
										, uint32_t top_x, uint32_t top_y, uint32_t top_width, uint32_t top_height
										, uint32_t top_right_x, uint32_t top_right_y, uint32_t top_right_width, uint32_t top_right_height
										, uint32_t left_x, uint32_t left_y, uint32_t left_width, uint32_t left_height
										, uint32_t center_x, uint32_t center_y, uint32_t center_width, uint32_t center_height
										, uint32_t right_x, uint32_t right_y, uint32_t right_width, uint32_t right_height
										, uint32_t bottom_left_x, uint32_t bottom_left_y, uint32_t bottom_left_width, uint32_t bottom_left_height
										, uint32_t bottom_x, uint32_t bottom_y, uint32_t bottom_width, uint32_t bottom_height
										, uint32_t bottom_right_x, uint32_t bottom_right_y, uint32_t bottom_right_width, uint32_t bottom_right_height
										, LOGICAL output_center );
	IMAGE_PROC_PTR( void, UnmakeSlicedImage )( SlicedImage image );
	IMAGE_PROC_PTR( void, BlotSlicedImageEx )( Image dest, SlicedImage source, int32_t x, int32_t y, uint32_t width, uint32_t height, int alpha, enum BlotOperation op, ... );
} IMAGE_INTERFACE, *PIMAGE_INTERFACE;
/* Method to define automatic name translation from standard
   names Like BlatColorAlphaEx to the interface the user has
   specified to be using.                                    */
#define PROC_ALIAS(name) ((USE_IMAGE_INTERFACE)->_##name)
/* Method to define automatic name translation from standard
   names Like BlatColorAlphaEx to the interface the user has
   specified to be using. For function pointers.             */
#define PPROC_ALIAS(name) (*(USE_IMAGE_INTERFACE)->_##name)
#ifdef DEFINE_DEFAULT_IMAGE_INTERFACE
//static PIMAGE_INTERFACE always_defined_interface_that_makes_this_efficient;
#  define USE_IMAGE_INTERFACE GetImageInterface()
#endif
#if defined( FORCE_NO_INTERFACE ) && !defined( ALLOW_IMAGE_INTERFACES )
#  undef USE_IMAGE_INTERFACE
#else
#  define GetImageInterface() (PIMAGE_INTERFACE)GetInterface( WIDE("image") )
/* <combine sack::image::DropImageInterface@PIMAGE_INTERFACE>
   \ \                                                        */
#  define DropImageInterface(x) DropInterface( WIDE("image"), NULL )
#endif
#ifdef USE_IMAGE_INTERFACE
#define GetRedValue                          PROC_ALIAS(GetRedValue )
#define GetBlueValue                          PROC_ALIAS(GetBlueValue )
#define GetGreenValue                          PROC_ALIAS(GetGreenValue )
#define GetAlphaValue                          PROC_ALIAS(GetAlphaValue )
#define SetRedValue                          PROC_ALIAS(SetRedValue )
#define SetBlueValue                          PROC_ALIAS(SetBlueValue )
#define SetGreenValue                          PROC_ALIAS(SetGreenValue )
#define SetAlphaValue                          PROC_ALIAS(SetAlphaValue )
#define MakeColor                          PROC_ALIAS(MakeColor )
#define MakeAlphaColor                          PROC_ALIAS(MakeAlphaColor )
#define MarkImageDirty                    PROC_ALIAS(MarkImageDirty)
#define GetStringRenderSizeFontEx          PROC_ALIAS(GetStringRenderSizeFontEx )
#define LoadImageFileFromGroupEx          PROC_ALIAS(LoadImageFileFromGroupEx )
#define SetStringBehavior                  PROC_ALIAS(SetStringBehavior )
                      //PROC_ALIAS(SetBlotMethod )
#define SetBlotMethod
#define BuildImageFileEx                   PROC_ALIAS(BuildImageFileEx )
#define MakeImageFileEx                    PROC_ALIAS(MakeImageFileEx )
#define MakeSubImageEx                     PROC_ALIAS(MakeSubImageEx )
#define RemakeImageEx                      PROC_ALIAS(RemakeImageEx )
#define ResizeImageEx                      PROC_ALIAS(ResizeImageEx )
#define MoveImage                          PROC_ALIAS(MoveImage )
#define LoadImageFileEx                    PROC_ALIAS(LoadImageFileEx )
#define DecodeMemoryToImage                PROC_ALIAS(DecodeMemoryToImage )
#define UnmakeImageFileEx                  PROC_ALIAS(UnmakeImageFileEx )
#define BlatColor                          PROC_ALIAS(BlatColor )
#define BlatColorAlpha                     PROC_ALIAS(BlatColorAlpha )
#define BlotImageSizedEx                   PROC_ALIAS(BlotImageSizedEx )
#define BlotImageEx                        PROC_ALIAS(BlotImageEx )
#define BlotScaledImageSizedEx             PROC_ALIAS(BlotScaledImageSizedEx )
#define plot                               PPROC_ALIAS(plot )
#define plotalpha                          PPROC_ALIAS(plotalpha )
#define getpixel                           PPROC_ALIAS(getpixel )
#define do_line                            PPROC_ALIAS(do_line )
#define do_lineAlpha                       PPROC_ALIAS(do_lineAlpha )
#define do_hline                           PPROC_ALIAS(do_hline )
#define do_vline                           PPROC_ALIAS(do_vline )
#define do_hlineAlpha                      PPROC_ALIAS(do_hlineAlpha )
#define do_vlineAlpha                      PPROC_ALIAS(do_vlineAlpha )
#define GetDefaultFont                     PROC_ALIAS(GetDefaultFont )
#define GetFontHeight                      PROC_ALIAS(GetFontHeight )
#define GetStringSizeFontEx                PROC_ALIAS(GetStringSizeFontEx )
#define PutCharacterFont                   PROC_ALIAS(PutCharacterFont )
#define PutCharacterVerticalFont           PROC_ALIAS(PutCharacterVerticalFont )
#define PutCharacterInvertFont             PROC_ALIAS(PutCharacterInvertFont )
#define PutCharacterVerticalInvertFont     PROC_ALIAS(PutCharacterVerticalInvertFont )
#define PutStringFontExx                   PROC_ALIAS(PutStringFontExx)
#define PutStringFontEx                    PROC_ALIAS(PutStringFontEx )
#define PutStringVerticalFontEx            PROC_ALIAS(PutStringVerticalFontEx )
#define PutStringInvertFontEx              PROC_ALIAS(PutStringInvertFontEx )
#define PutStringInvertVerticalFontEx      PROC_ALIAS(PutStringInvertVerticalFontEx )
#define GetMaxStringLengthFont             PROC_ALIAS(GetMaxStringLengthFont )
#define GetImageSize                       PROC_ALIAS(GetImageSize )
#define LoadFont                           PROC_ALIAS(LoadFont )
#define UnloadFont                         PROC_ALIAS(UnloadFont )
#define ColorAverage                       PPROC_ALIAS(ColorAverage)
#define TransferSubImages                  PROC_ALIAS(TransferSubImages)
#define SyncImage                          PROC_ALIAS(SyncImage )
#define IntersectRectangle                 PROC_ALIAS(IntersectRectangle)
#define MergeRectangle                     PROC_ALIAS(MergeRectangle)
#define GetImageSurface                    PROC_ALIAS(GetImageSurface)
#define SetImageAuxRect                    PROC_ALIAS(SetImageAuxRect)
#define GetImageAuxRect                    PROC_ALIAS(GetImageAuxRect)
#define OrphanSubImage                     PROC_ALIAS(OrphanSubImage)
#define GetGlobalFonts                     PROC_ALIAS(GetGlobalFonts)
#define GetTintedImage                     PROC_ALIAS(GetTintedImage)
#define GetShadedImage                     PROC_ALIAS(GetShadedImage)
#define AdoptSubImage                      PROC_ALIAS(AdoptSubImage)
#define MakeSpriteImageFileEx   PROC_ALIAS(MakeSpriteImageFileEx)
#define MakeSpriteImageEx       PROC_ALIAS(MakeSpriteImageEx)
#define UnmakeSprite            PROC_ALIAS(UnmakeSprite )
#define rotate_scaled_sprite    PROC_ALIAS(rotate_scaled_sprite)
#define rotate_sprite           PROC_ALIAS(rotate_sprite)
#define BlotSprite              PROC_ALIAS(BlotSprite)
#define SetSpritePosition  PROC_ALIAS(  SetSpritePosition )
#define SetSpriteHotspot  PROC_ALIAS(  SetSpriteHotspot )
#define InternalRenderFont          PROC_ALIAS(InternalRenderFont)
#define InternalRenderFontFile      PROC_ALIAS(InternalRenderFontFile)
#define RenderScaledFontData              PROC_ALIAS(RenderScaledFontData)
//#define RenderScaledFont              PROC_ALIAS(RenderScaledFont)
#define RenderScaledFontEx              PROC_ALIAS(RenderScaledFontEx)
#define DumpFontCache              PROC_ALIAS(DumpFontCache)
#define RerenderFont              PROC_ALIAS(RerenderFont)
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
#define ReloadTexture              PROC_ALIAS(ReloadTexture)
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
#define ReloadShadedTexture              PROC_ALIAS(ReloadShadedTexture)
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
#define ReloadMultiShadedTexture              PROC_ALIAS(ReloadMultiShadedTexture)
#define DestroyFont              PROC_ALIAS(DestroyFont)
#define GetFontRenderData              PROC_ALIAS(GetFontRenderData)
#define SetFontRendererData              PROC_ALIAS(SetFontRendererData)
#define RenderFontFileScaledEx              PROC_ALIAS(RenderFontFileScaledEx)
#define GetImageTransformation              PROC_ALIAS(GetImageTransformation)
#define SetImageTransformRelation      PROC_ALIAS( SetImageTransformRelation )
#define Render3dImage                  PROC_ALIAS( Render3dImage )
#define Render3dText                   PROC_ALIAS( Render3dText )
#define DumpFontFile                   PROC_ALIAS( DumpFontFile )
#define IsImageTargetFinal                   PROC_ALIAS( IsImageTargetFinal )
#define ReuseImage                      if((USE_IMAGE_INTERFACE)->_ReuseImage) PROC_ALIAS( ReuseImage )
#define ResetImageBuffers                      if((USE_IMAGE_INTERFACE)->_ResetImageBuffers) PROC_ALIAS( ResetImageBuffers )
#define PngImageFile                    PROC_ALIAS( PngImageFile )
#define JpgImageFile                    PROC_ALIAS( JpgImageFile )
#define SetFontBias                     PROC_ALIAS( SetFontBias )
#define MakeSlicedImage                 PROC_ALIAS( MakeSlicedImage )
#define MakeSlicedImageComplex          PROC_ALIAS( MakeSlicedImageComplex )
#define UnmakeSlicedImage                 PROC_ALIAS( UnmakeSlicedImage )
#define BlotSlicedImageEx               PROC_ALIAS( BlotSlicedImageEx )
//#define global_font_data         (*PROC_ALIAS(global_font_data))
#endif
/* <combine sack::image::GetMaxStringLengthFont@uint32_t@SFTFont>
   \ \                                                    */
#define GetMaxStringLength(w) GetMaxStringLengthFont(w, NULL )
#ifdef DEFINE_IMAGE_PROTOCOL
//#include <msgprotocol.h>
// need to define BASE_IMAGE_MESSAGE_ID before hand to determine what the base message is.
//#define MSG_ID(method)  ( ( offsetof( struct image_interface_tag, _##method ) / sizeof( void(*)(void) ) ) + BASE_IMAGE_MESSAGE_ID + MSG_EventUser )
#define MSG_SetStringBehavior                  MSG_ID( SetStringBehavior )
#define MSG_SetBlotMethod                      MSG_ID( SetBlotMethod )
#define MSG_BuildImageFileEx                   MSG_ID( BuildImageFileEx )
#define MSG_MakeImageFileEx                    MSG_ID( MakeImageFileEx )
#define MSG_MakeSubImageEx                     MSG_ID( MakeSubImageEx )
#define MSG_RemakeImageEx                      MSG_ID( RemakeImageEx )
#define MSG_UnmakeImageFileEx                  MSG_ID( UnmakeImageFileEx )
#define MSG_ResizeImageEx                      MSG_ID( ResizeImageEx )
#define DecodeMemoryToImage                    MSG_ID( DecodeMemoryToImage )
#define MSG_MoveImage                          MSG_ID( MoveImage )
#define MSG_BlatColor                          MSG_ID( BlatColor )
#define MSG_BlatColorAlpha                     MSG_ID( BlatColorAlpha )
#define MSG_BlotImageSizedEx                   MSG_ID( BlotImageSizedEx )
#define MSG_BlotImageEx                        MSG_ID( BlotImageEx )
#define MSG_BlotScaledImageSizedEx             MSG_ID( BlotScaledImageSizedEx )
#define MSG_plot                               MSG_ID( plot )
#define MSG_plotalpha                          MSG_ID( plotalpha )
#define MSG_getpixel                           MSG_ID( getpixel )
#define MSG_do_line                            MSG_ID( do_line )
#define MSG_do_lineAlpha                       MSG_ID( do_lineAlpha )
#define MSG_do_hline                           MSG_ID( do_hline )
#define MSG_do_vline                           MSG_ID( do_vline )
#define MSG_do_hlineAlpha                      MSG_ID( do_hlineAlpha )
#define MSG_do_vlineAlpha                      MSG_ID( do_vlineAlpha )
#define MSG_GetDefaultFont                     MSG_ID( GetDefaultFont )
#define MSG_GetFontHeight                      MSG_ID( GetFontHeight )
#define MSG_GetStringSizeFontEx                MSG_ID( GetStringSizeFontEx )
#define MSG_PutCharacterFont                   MSG_ID( PutCharacterFont )
#define MSG_PutCharacterVerticalFont           MSG_ID( PutCharacterVerticalFont )
#define MSG_PutCharacterInvertFont             MSG_ID( PutCharacterInvertFont )
#define MSG_PutCharacterVerticalInvertFont     MSG_ID( PutCharacterVerticalInvertFont )
#define MSG_PutStringFontEx                    MSG_ID( PutStringFontEx )
#define MSG_PutStringVerticalFontEx            MSG_ID( PutStringVerticalFontEx )
#define MSG_PutStringInvertFontEx              MSG_ID( PutStringInvertFontEx )
#define MSG_PutStringInvertVerticalFontEx      MSG_ID( PutStringInvertVerticalFontEx )
#define MSG_GetMaxStringLengthFont             MSG_ID( GetMaxStringLengthFont )
#define MSG_GetImageSize                       MSG_ID( GetImageSize )
#define MSG_ColorAverage                       MSG_IC( ColorAverage )
// these messages follow all others... and are present to handle
// LoadImageFile
// #define MSG_LoadImageFile (no message)
// #define MSG_LoadFont      (no message)
#define MSG_UnloadFont                         MSG_ID( UnloadFont )
#define MSG_BeginTransferData                  MSG_ID( BeginTransferData )
#define MSG_ContinueTransferData               MSG_ID( ContinueTransferData )
#define MSG_DecodeTransferredImage             MSG_ID( DecodeTransferredImage )
#define MSG_AcceptTransferredFont              MSG_ID( AcceptTransferredFont )
#define MSG_SyncImage                          MSG_ID( SyncImage )
#define MSG_IntersectRectangle                 MSG_ID( IntersectRectangle )
#define MSG_MergeRectangle                     MSG_ID( MergeRectangle)
#define MSG_GetImageSurface                    MSG_ID( GetImageSurface )
#define MSG_SetImageAuxRect                    MSG_ID(SetImageAuxRect)
#define MSG_GetImageAuxRect                    MSG_ID(GetImageAuxRect)
#define MSG_OrphanSubImage                     MSG_ID(OrphanSubImage)
#define MSG_GetGlobalFonts                     MSG_ID(GetGlobalFonts)
#define MSG_AdoptSubImage                      MSG_ID(AdoptSubImage)
#define MSG_MakeSpriteImageFileEx   MSG_ID(MakeSpriteImageFileEx)
#define MSG_MakeSpriteImageEx       MSG_ID(MakeSpriteImageEx)
#define MSG_UnmakeSprite            MSG_ID(UnmakeSprite )
#define MSG_rotate_scaled_sprite    MSG_ID(rotate_scaled_sprite)
#define MSG_rotate_sprite           MSG_ID(rotate_sprite)
#define MSG_BlotSprite              MSG_ID(BlotSprite)
#define MSG_SetSpritePosition  MSG_ID(  SetSpritePosition )
#define MSG_SetSpriteHotspot  MSG_ID(  SetSpriteHotspot )
#define MSG_InternalRenderFont          MSG_ID(InternalRenderFont)
#define MSG_InternalRenderFontFile      MSG_ID(InternalRenderFontFile)
#define MSG_RenderScaledFontData              MSG_ID(RenderScaledFontData)
#define MSG_RenderScaledFont              MSG_ID(RenderScaledFont)
#define MSG_RenderFontData              MSG_ID(RenderFontData)
#define MSG_DestroyFont              MSG_ID(DestroyFont)
#define MSG_GetFontRenderData              MSG_ID(GetFontRenderData)
#define MSG_SetFontRendererData              MSG_ID(SetFontRendererData)
#endif
#ifdef USE_IMAGE_LEVEL
#define PASTELEVEL(level,name) level##name
#define LEVEL_ALIAS(name)      PASTELEVEL(USE_IMAGE_LEVEL,name)
#  ifdef STUPID_NO_DATA_EXPORTS
#define PLEVEL_ALIAS(name)      (*PASTELEVEL(USE_IMAGE_LEVEL,_PASTE(_,name)))
#  else
#define PLEVEL_ALIAS(name)      (*PASTELEVEL(USE_IMAGE_LEVEL,name))
#  endif
#define SetStringBehavior                  LEVEL_ALIAS(SetStringBehavior )
                      //LEVEL_ALIAS(SetBlotMethod )
#define SetBlotMethod
#define BuildImageFileEx                   LEVEL_ALIAS(BuildImageFileEx )
#define MakeImageFileEx                    LEVEL_ALIAS(MakeImageFileEx )
#define MakeSubImageEx                     LEVEL_ALIAS(MakeSubImageEx )
#define RemakeImageEx                      LEVEL_ALIAS(RemakeImageEx )
#define ResizeImageEx                      LEVEL_ALIAS(ResizeImageEx )
#define MoveImage                          LEVEL_ALIAS(MoveImage )
#define LoadImageFileEx                    LEVEL_ALIAS(LoadImageFileEx )
#define DecodeMemoryToImage                LEVEL_ALIAS(DecodeMemoryToImage )
#define UnmakeImageFileEx                  LEVEL_ALIAS(UnmakeImageFileEx )
#define BlatColor                          LEVEL_ALIAS(BlatColor )
#define BlatColorAlpha                     LEVEL_ALIAS(BlatColorAlpha )
#define BlotImageSizedEx                   LEVEL_ALIAS(BlotImageSizedEx )
#define BlotImageEx                        LEVEL_ALIAS(BlotImageEx )
#define BlotScaledImageSizedEx             LEVEL_ALIAS(BlotScaledImageSizedEx )
#define plot                               LEVEL_ALIAS(plot )
#define plotalpha                          LEVEL_ALIAS(plotalpha )
#error 566
#define getpixel                           LEVEL_ALIAS(getpixel )
#define do_line                            LEVEL_ALIAS(do_line )
#define do_lineAlpha                       LEVEL_ALIAS(do_lineAlpha )
#define do_hline                           LEVEL_ALIAS(do_hline )
#define do_vline                           LEVEL_ALIAS(do_vline )
#define do_hlineAlpha                      LEVEL_ALIAS(do_hlineAlpha )
#define do_vlineAlpha                      LEVEL_ALIAS(do_vlineAlpha )
#define GetDefaultFont                     LEVEL_ALIAS(GetDefaultFont )
#define GetFontHeight                      LEVEL_ALIAS(GetFontHeight )
#define GetStringSizeFontEx                LEVEL_ALIAS(GetStringSizeFontEx )
#define PutCharacterFont                   LEVEL_ALIAS(PutCharacterFont )
#define PutCharacterVerticalFont           LEVEL_ALIAS(PutCharacterVerticalFont )
#define PutCharacterInvertFont             LEVEL_ALIAS(PutCharacterInvertFont )
#define PutCharacterVerticalInvertFont     LEVEL_ALIAS(PutCharacterVerticalInvertFont )
#define PutStringFontEx                    LEVEL_ALIAS(PutStringFontEx )
#define PutStringVerticalFontEx            LEVEL_ALIAS(PutStringVerticalFontEx )
#define PutStringInvertFontEx              LEVEL_ALIAS(PutStringInvertFontEx )
#define PutStringInvertVerticalFontEx      LEVEL_ALIAS(PutStringInvertVerticalFontEx )
#define GetMaxStringLengthFont             LEVEL_ALIAS(GetMaxStringLengthFont )
#define GetImageSize                       LEVEL_ALIAS(GetImageSize )
#define LoadFont                           LEVEL_ALIAS(LoadFont )
#define UnloadFont                         LEVEL_ALIAS(UnloadFont )
#define ColorAverage                       LEVEL_ALIAS(ColorAverage)
#define SyncImage                          LEVEL_ALIAS(SyncImage )
#define IntersectRectangle                 LEVEL_ALIAS( IntersectRectangle )
#define MergeRectangle                     LEVEL_ALIAS(MergeRectangle)
#define GetImageSurface                    LEVEL_ALIAS(GetImageSurface)
#define SetImageAuxRect                    LEVEL_ALIAS(SetImageAuxRect)
#define GetImageAuxRect                    LEVEL_ALIAS(GetImageAuxRect)
#define OrphanSubImage                     LEVEL_ALIAS(OrphanSubImage)
#define GetGlobalFonts                     LEVEL_ALIAS(GetGlobalFonts)
#define AdoptSubImage                      LEVEL_ALIAS(AdoptSubImage)
#define InternalRenderFont          LEVEL_ALIAS(InternalRenderFont)
#define InternalRenderFontFile      LEVEL_ALIAS(InternalRenderFontFile)
#define RenderScaledFontData              LEVEL_ALIAS(RenderScaledFontData)
#define RenderFontData              LEVEL_ALIAS(RenderFontData)
#define RenderFontFileScaledEx              LEVEL_ALIAS(RenderFontFileScaledEx)
#endif
_INTERFACE_NAMESPACE_END
#ifdef __cplusplus
#ifdef _D3D_DRIVER
	using namespace sack::image::d3d::Interface;
#elif defined( _D3D10_DRIVER )
	using namespace sack::image::d3d10::Interface;
#elif defined( _D3D11_DRIVER )
	using namespace sack::image::d3d11::Interface;
#else
	using namespace sack::image::Interface;
#endif
#endif
// these macros provide common extensions for
// commonly used shorthands of the above routines.
// no worry - one way or another, the extra data is
// created, and the base function called, it's a sad
// truth of life, that one codebase is easier to maintain
// than a duplicate copy for each minor case.
// although - special forwards - such as DBG_SRC will just dissappear
// in certain compilation modes (NON_DEBUG)
/* <combine sack::image::BuildImageFileEx@PCOLOR@uint32_t@uint32_t>
   \ \                                                           */
#define BuildImageFile(p,w,h) BuildImageFileEx( p,w,h DBG_SRC )
/* <combine sack::image::MakeImageFileEx@uint32_t@uint32_t>
   \ \                                                   */
#define MakeImageFile(w,h) MakeImageFileEx( w,h DBG_SRC )
/* <combine sack::image::MakeSubImageEx@Image@int32_t@int32_t@uint32_t@uint32_t>
   \ \                                                                  */
#define MakeSubImage( image, x, y, w, h ) MakeSubImageEx( image, x, y, w, h DBG_SRC )
/* <combine sack::image::RemakeImageEx@Image@PCOLOR@uint32_t@uint32_t>
   \ \                                                              */
#define RemakeImage(p,pc,w,h) RemakeImageEx(p,pc,w,h DBG_SRC)
/* <combine sack::image::ResizeImageEx@Image@uint32_t@uint32_t>
   \ \                                                              */
#define ResizeImage( p,w,h) ResizeImageEx( p,w,h DBG_SRC )
/* <combine sack::image::UnmakeImageFileEx@Image pif>
   Destroys an image. Does not automatically destroy child
   images created on the image.
   Parameters
   Image :  an image to destroy
   Example
   <code lang="c++">
   Image image = MakeImageFile( 100, 100 );
   UnmakeImageFile( image );
   </code>                                                 */
#define UnmakeImageFile(pif) UnmakeImageFileEx( pif DBG_SRC )
/* <combine sack::image::MakeSpriteImageEx@Image image>
   \ \                                                  */
#define MakeSpriteImage(image) MakeSpriteImageEx(image DBG_SRC)
/* <combine sack::image::MakeSpriteImageFileEx@CTEXTSTR fname>
   \ \                                                         */
#define MakeSpriteImageFile(file) MakeSpriteImageFileEx( image DBG_SRC )
/* This function flips an image top to bottom. This if for
   building windows compatible images. Internally images are
   kept in platform-native direction. If an image is created
   from another source, this might be a method to flip the image
   top-to-bottom if required.
   Parameters
   pImage :                           Image to flip.
   <link sack::DBG_PASS, DBG_PASS> :  _nt_
   Note
   There has been a warning around flip image for a while, it
   does its job right now (reversing jpeg images on windows),
   but not necessarily suited for the masses.                    */
IMAGE_PROC  void IMAGE_API  FlipImageEx ( Image pif DBG_PASS );
/* <combine sack::image::FlipImageEx@Image pif>
   \ \                                          */
#define FlipImage(pif) FlipImageEx( pif DBG_SRC )
/* <combine sack::image::LoadImageFileEx@CTEXTSTR name>
   \ \                                                  */
#define LoadImageFile(file) LoadImageFileEx( file DBG_SRC )
/* <combine sack::image::LoadImageFileEx@CTEXTSTR name>
   \ \                                                  */
#define LoadImageFileFromGroup(group,file) LoadImageFileFromGroupEx( group, file DBG_SRC )
/* <combine sack::image::BlatColor@Image@int32_t@int32_t@uint32_t@uint32_t@CDATA>
   \ \                                                            */
#define ClearImageTo(img,color) BlatColor(img,0,0,(img)->width,(img)->height, color )
/* <combine sack::image::BlatColor@Image@int32_t@int32_t@uint32_t@uint32_t@CDATA>
   \ \                                                            */
#define ClearImage(img) BlatColor(img,0,0,(img)->width,(img)->height, 0 )
/* Copy one image to another. Copies the source from 0,0 to the
   destination 0,0 of the minimum width and height of the
   smaller of the source or destination.
   Parameters
   pifDest :  Image to copy to
   pifSrc :   Image to copy from
   X :        left coordinate to copy image to
   Y :        upper coordinate to copy image to
   Example
   This creates an image to write to, creates an image to copy
   (a 64 by 64 square that is filled with 50% green color). And
   copies the image to the output buffer.
   <code>
   Image output = MakeImageFile( 1024, 768 );
   Image source = MakeImageFile( 64, 64 );
   // 50% transparent
   ClearImageTo( source, SetAlpha( BASE_COLOR_GREEN, 128 ) );
   ClearImage( output );
   BlotImage( output, source, 100, 100 );
   BlotImageAlpha( output, source, 200, 200 );
   </code>                                                      */
#define BlotImage( pd, ps, x, y ) BlotImageEx( pd, ps, x, y, 0, BLOT_COPY )
/* Output a sliced image to an image surface
  sliced images scale center portions, but copy output corner images
  */
#define BlotSlicedImage( pd, ps, x, y, w, h ) BlotSlicedImageEx( pd, ps, x, y, w, h, ALPHA_TRANSPARENT, BLOT_COPY )
/* Copy one image to another at the specified coordinate in the
   destination.
   Parameters
   Destination :  Image to output to
   Source :       Image to copy
   X :            Location to copy to
   Y :            Location to copy to <link sack::image::AlphaModifier, Alpha>
                  \: Specify how to write the alpha                            */
#define BlotImageAlpha( pd, ps, x, y, a ) BlotImageEx( pd, ps, x, y, a, BLOT_COPY )
/* <combine sack::image::BlotImageSizedEx@Image@Image@int32_t@int32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                         */
#define BlotImageSized( pd, ps, x, y, w, h ) BlotImageSizedEx( pd, ps, x, y, 0, 0, w, h, TRUE, BLOT_COPY )
/* <combine sack::image::BlotImageSizedEx@Image@Image@int32_t@int32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                         */
#define BlotImageSizedAlpha( pd, ps, x, y, w, h, a ) BlotImageSizedEx( pd, ps, x, y, 0, 0, w, h, a, BLOT_COPY )
/* <combine sack::image::BlotImageSizedEx@Image@Image@int32_t@int32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                         */
#define BlotImageSizedTo( pd, ps, xd, yd, xs, ys, w, h )  BlotImageSizedEx( pd, ps, xd, yd, xs, ys, w, h, TRUE, BLOT_COPY )
/* Copy one image to another at the specified coordinate in the
   destination. Shade the image on copy with a color.
   Parameters
   Destination :  Image to output to
   Source :       Image to copy
   X :            Location to copy to
   Y :            Location to copy to
   Color :        color to multiply the source color by to shade
                  on copy.                                       */
#define BlotImageShaded( pd, ps, xd, yd, c ) BlotImageEx( pd, ps, xd, yd, TRUE, BLOT_SHADED, c )
/* <combine sack::image::BlotImageSizedEx@Image@Image@int32_t@int32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                         */
#define BlotImageShadedSized( pd, ps, xd, yd, xs, ys, ws, hs, c ) BlotImageSizedEx( pd, ps, xd, yd, xs, ys, ws, hs, TRUE, BLOT_SHADED, c )
/* Copy one image to another at the specified coordinate in the
   destination. Scale RGB channels to specified colors.
   Parameters
   Destination :  Image to output to
   Source :       Image to copy
   X :            Location to copy to
   Y :            Location to copy to
   X_source :     the left coordinate of the image source
   Y_source :     the top coordinate of the image source
   Width :        How wide to copy the image
   Height :       How wide to copy the image
   color :        color mutiplier to shade the image.           */
#define BlotImageMultiShaded( pd, ps, xd, yd, r, g, b ) BlotImageEx( pd, ps, xd, yd, ALPHA_TRANSPARENT, BLOT_MULTISHADE, r, g, b )
/* Copy one image to another at the specified coordinate in the
   destination. Scale RGB channels to specified colors.
   Parameters
   Destination :  Image to output to
   Source :       Image to copy
   X :            Location to copy to
   Y :            Location to copy to
   X_source :     the left coordinate of the image source
   Y_source :     the top coordinate of the image source
   Width :        How wide to copy the image
   Height :       How wide to copy the image
   color :        color mutiplier to shade the image.           */
#define BlotImageMultiShadedSized( pd, ps, xd, yd, xs, ys, ws, hs, r, g, b ) BlotImageSizedEx( pd, ps, xd, yd, xs, ys, ws, hs, TRUE, BLOT_MULTISHADE, r, g, b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSized( pd, ps, xd, yd, wd, hd, xs, ys, ws, hs ) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, xs, ys, ws, hs, 0, BLOT_COPY )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedMultiShaded( pd, ps, xd, yd, wd, hd, xs, ys, ws, hs,r,g,b ) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, xs, ys, ws, hs, 0, BLOT_MULTISHADE,r,g,b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedTo( pd, ps, xd, yd, wd, hd) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, 0, BLOT_COPY )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedToAlpha( pd, ps, xd, yd, wd, hd, a) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, a, BLOT_COPY )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedToShaded( pd, ps, xd, yd, wd, hd,shade) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, 0,BLOT_SHADED, shade )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedToShadedAlpha( pd, ps, xd, yd, wd, hd,a,shade) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, a, BLOT_SHADED, shade )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedToMultiShaded( pd, ps, xd, yd, wd, hd,r,g,b) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, 0,BLOT_MULTISHADE, r,g,b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedToMultiShadedAlpha( pd, ps, xd, yd, wd, hd,a,r,g,b) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, a,BLOT_MULTISHADE, r,g,b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageAlpha( pd, ps, t ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, t, BLOT_COPY )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageShadedAlpha( pd, ps, t, shade ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, t, BLOT_SHADED, shade )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageMultiShadedAlpha( pd, ps, t, r, g, b ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, t, BLOT_MULTISHADE, r, g, b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImage( pd, ps ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, 0, BLOT_COPY )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageShaded( pd, ps, shade ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, 0, BLOT_SHADED, shade )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageMultiShaded( pd, ps, r, g, b ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, 0, BLOT_MULTISHADE, r, g, b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageTo( pd, ps )  BlotScaledImageToEx( pd, ps, FALSE, BLOT_COPY )
/* now why would we need an inverse line? I don't get it....
   anyhow this would draw from the end to the start... basically
   this accounts for rounding errors on the orward way.          */
#define do_inv_line(pb,x,y,xto,yto,d) do_line( pb,y,x,yto,xto,d)
/* <combine sack::image::PutCharacterFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   \ \                                                                               */
#define PutCharacter(i,x,y,fore,back,c)               PutCharacterFont(i,x,y,fore,back,c,NULL )
/* <combine sack::image::PutCharacterVerticalFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   Passes default font if not specified.                                                     */
#define PutCharacterVertical(i,x,y,fore,back,c)       PutCharacterVerticalFont(i,x,y,fore,back,c,NULL )
/* <combine sack::image::PutCharacterInvertFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   \ \                                                                                     */
#define PutCharacterInvert(i,x,y,fore,back,c)         PutCharacterInvertFont(i,x,y,fore,back,c,NULL )
/* <combine sack::image::PutCharacterVerticalInvertFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   \ \                                                                                             */
#define PutCharacterInvertVertical(i,x,y,fore,back,c) PutCharacterInvertVerticalFont(i,x,y,fore,back,c,NULL )
/* <combine sack::image::PutCharacterVerticalInvertFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   \ \                                                                                             */
#define PutCharacterInvertVerticalFont(i,x,y,fore,back,c,f) PutCharacterVerticalInvertFont(i,x,y,fore,back,c,f )
/* <combine sack::image::PutStringFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                  */
#define PutString(pi,x,y,fore,back,pc) PutStringFontEx( pi, x, y, fore, back, pc, StrLen(pc), NULL )
/* <combine sack::image::PutStringFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                  */
#define PutStringEx(pi,x,y,color,back,pc,len) PutStringFontEx( pi, x, y, color,back,pc,len,NULL )
/* <combine sack::image::PutStringFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                  */
#define PutStringFont(pi,x,y,fore,back,pc,font) PutStringFontEx(pi,x,y,fore,back,pc,StrLen(pc), font )
/* <combine sack::image::PutStringVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                          */
#define PutStringVertical(pi,x,y,fore,back,pc) PutStringVerticalFontEx( pi, x, y, fore, back, pc, StrLen(pc), NULL )
/* <combine sack::image::PutStringVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                          */
#define PutStringVerticalEx(pi,x,y,color,back,pc,len) PutStringVerticalFontEx( pi, x, y, color,back,pc,len,NULL )
/* <combine sack::image::PutStringVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                          */
#define PutStringVerticalFont(pi,x,y,fore,back,pc,font) PutStringVerticalFontEx(pi,x,y,fore,back,pc,StrLen(pc), font )
/* <combine sack::image::PutStringInvertFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                        */
#define PutStringInvert( pi, x, y, fore, back, pc ) PutStringInvertFontEx( pi, x, y, fore, back, pc,StrLen(pc), NULL )
/* <combine sack::image::PutStringInvertFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                        */
#define PutStringInvertEx( pi, x, y, fore, back, pc, nLen ) PutStringInvertFontEx( pi, x, y, fore, back, pc, nLen, NULL )
/* <combine sack::image::PutStringInvertFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   The non Ex Version doesn't pass the string length.                                         */
#define PutStringInvertFont( pi, x, y, fore, back, pc, nLen ) PutStringInvertFontEx( pi, x, y, fore, back, pc, StrLen(pc), font )
/* <combine sack::image::PutStringInvertVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                                */
#define PutStringInvertVertical( pi, x, y, fore, back, pc ) PutStringInvertVerticalFontEx( pi, x, y, fore, back, pc, StrLen(pc), NULL )
/* <combine sack::image::PutStringInvertVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                                */
#define PutStringInvertVerticalEx( pi, x, y, fore, back, pc, nLen ) PutStringInvertVerticalFontEx( pi, x, y, fore, back, pc, nLen, NULL )
/* <combine sack::image::PutStringInvertVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                                */
#define PutStringInvertVerticalFont( pi, x, y, fore, back, pc, font ) PutStringInvertVerticalFontEx( pi, x, y, fore, back, pc, StrLen(pc), font )
//IMG_PROC uint32_t PutMenuStringFontEx        ( ImageFile *pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, uint32_t nLen, PFONT font );
//#define PutMenuStringFont(img,x,y,fore,back,string,font) PutMenuStringFontEx( img,x,y,fore,back,string,StrLen(string),font)
//#define PutMenuString(img,x,y,fore,back,str)           PutMenuStringFont(img,x,y,fore,back,str,NULL)
//
//IMG_PROC uint32_t PutCStringFontEx           ( ImageFile *pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, uint32_t nLen, PFONT font );
//#define PutCStringFont(img,x,y,fore,back,string,font) PutCStringFontEx( img,x,y,fore,back,string,StrLen(string),font)
//#define PutCString( img,x,y,fore,back,string) PutCStringFont(img,x,y,fore,back,string,NULL )
/* <combine sack::image::GetStringSizeFontEx@CTEXTSTR@uint32_t@uint32_t *@uint32_t *@SFTFont>
   \ \                                                                      */
#define GetStringSizeEx(s,len,pw,ph) GetStringSizeFontEx( (s),len,pw,ph,NULL)
/* <combine sack::image::GetStringSizeFontEx@CTEXTSTR@size_t@uint32_t *@uint32_t *@SFTFont>
   \ \                                                                         */
#define GetStringSize(s,pw,ph)       GetStringSizeFontEx( (s),StrLen(s),pw,ph,NULL)
/* <combine sack::image::GetStringSizeFontEx@CTEXTSTR@uint32_t@uint32_t *@uint32_t *@SFTFont>
   \ \                                                                      */
#define GetStringSizeFont(s,pw,ph,f) GetStringSizeFontEx( (s),StrLen(s),pw,ph,f )
#ifdef __cplusplus
IMAGE_NAMESPACE_END
#ifdef _D3D_DRIVER
using namespace sack::image::d3d;
#elif defined( _D3D10_DRIVER )
using namespace sack::image::d3d10;
#elif defined( _D3D11_DRIVER )
using namespace sack::image::d3d11;
#else
using namespace sack::image;
#endif
#endif
#endif
/*   */
 // sockaddr, createaddress(str,defport)
#ifndef NETWORK_HEADER_INCLUDED
#define NETWORK_HEADER_INCLUDED
#ifdef NETWORK_SOURCE
#define NETWORK_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define NETWORK_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
#define _NETWORK_NAMESPACE  namespace network {
#define _NETWORK_NAMESPACE_END }
#define _TCP_NAMESPACE  namespace tcp {
#define _TCP_NAMESPACE_END }
#define USE_TCP_NAMESPACE using namespace tcp;
#define _UDP_NAMESPACE  namespace udp {
#define _UDP_NAMESPACE_END }
#define USE_UDP_NAMESPACE using namespace tcp;
#else
#define _NETWORK_NAMESPACE
#define _NETWORK_NAMESPACE_END
#define _TCP_NAMESPACE
#define _TCP_NAMESPACE_END
#define _UDP_NAMESPACE
#define _UDP_NAMESPACE_END
#define USE_TCP_NAMESPACE
#define USE_UDP_NAMESPACE
#endif
#define SACK_NETWORK_NAMESPACE  SACK_NAMESPACE _NETWORK_NAMESPACE
#define SACK_NETWORK_NAMESPACE_END _NETWORK_NAMESPACE_END SACK_NAMESPACE_END
#define SACK_NETWORK_TCP_NAMESPACE  SACK_NAMESPACE _NETWORK_NAMESPACE _TCP_NAMESPACE
#define SACK_NETWORK_TCP_NAMESPACE_END _TCP_NAMESPACE_END _NETWORK_NAMESPACE_END SACK_NAMESPACE_END
#define SACK_NETWORK_UDP_NAMESPACE  SACK_NAMESPACE _NETWORK_NAMESPACE _UDP_NAMESPACE
#define SACK_NETWORK_UDP_NAMESPACE_END _UDP_NAMESPACE_END _NETWORK_NAMESPACE_END SACK_NAMESPACE_END
SACK_NAMESPACE
	/* Event based networking interface.
	   Example
	   \Example One : A simple client side application. Reads
	   standard input, and writes it to a server it connects to. Read
	   the network and write as standard output.
	   <code lang="c++">
	   \#include \<network.h\>
	   </code>
	   <code>
	   \#include \<logging.h\>
	   \#include \<sharemem.h\>
	   </code>
	   <code lang="c++">
	   void CPROC ReadComplete( PCLIENT pc, void *bufptr, int sz )
	   {
	      char *buf = (char*)bufptr;
	       if( buf )
	       {
	           buf[sz] = 0;
	           printf( "%s", buf );
	           fflush( stdout );
	       }
	       else
	       {
	           buf = (char*)Allocate( 4097 );
	           //SendTCP( pc, "Yes, I've connected", 12 );
	       }
	       ReadTCP( pc, buf, 4096 );
	   }
	   PCLIENT pc_user;
	   void CPROC Closed( PCLIENT pc )
	   {
	      pc_user = NULL;
	   }
	   int main( int argc, char** argv )
	   {
	       SOCKADDR *sa;
	       if( argc \< 2 )
	       {
	           printf( "usage: %s \<Telnet IP[:port]\>\\n", argv[0] );
	           return 0;
	       }
	       SystemLog( "Starting the network" );
	       NetworkStart();
	       SystemLog( "Started the network" );
	       sa = CreateSockAddress( argv[1], 23 );
	       pc_user = OpenTCPClientAddrEx( sa, ReadComplete, Closed, NULL, 0 );
	       if( !pc_user )
	       {
	           SystemLog( "Failed to open some port as telnet" );
	           printf( "failed to open %s%s\\n", argv[1], strchr(argv[1],':')?"":":telnet[23]" );
	           return 0;
	       }
	      //SendTCP( pc_user, "Some data here...", 12 );
	       while( pc_user )
	       {
	           char buf[256];
	           if( !fgets( buf, 256, stdin ) )
	           {
	               RemoveClient( pc_user );
	               return 0;
	           }
	           SendTCP( pc_user, buf, strlen( buf ) );
	       }
	       return -1;
	   }
	   </code>
	   \Example Two : A server application, opens a socket that it
	   accepts connections on. Reads the socket, and writes the
	   information it reads back to the socket as an echo.
	   <code lang="c++">
	   \#include \<stdhdrs.h\>
	   \#include \<sharemem.h\>
	   \#include \<timers.h\>
	   \#include \<network.h\>
	   void CPROC ServerRecieve( PCLIENT pc, POINTER buf, int size )
	   {
	       //int bytes;
	       if( !buf )
	       {
	           buf = Allocate( 4096 );
	           //SendTCP( pc, (void*)"Hi, welccome to...", 15 );
	       }
	       //else
	           //SendTCP( pc, buf, size );
	       // test for waitread support...
	       // read will not result until the data is read.
	       //bytes = WaitReadTCP( pc, buf, 4096 );
	       //if( bytes \> 0 )
	       //   SendTCP( pc, buf, bytes );
	       ReadTCP( pc, buf, 4095 );
	       // buffer does not have anything in it....
	   }
	   void CPROC ClientConnected( PCLIENT pListen, PCLIENT pNew )
	   {
	       SetNetworkReadComplete( pNew, ServerRecieve );
	   }
	   int main( int argc, char **argv )
	   {
	       PCLIENT pcListen;
	       SOCKADDR *port;
	       if( argc \< 2 )
	       {
	           printf( "usage: %s \<listen port\> (defaulting to telnet)\\n", argv[0] );
	           port = CreateSockAddress( "localhost:23", 23 );
	       }
	       else
	           port = CreateSockAddress( argv[1], 23 );
	       NetworkStart();
	       pcListen = OpenTCPListenerAddrEx( port, ClientConnected );
	       if(pcListen)
	           while(1) WakeableSleep( SLEEP_FOREVER );
	       else
	           printf( "Failed to listen on port %s\\n", argv[1] );
	       return 0;
	   }
	   </code>                                                                                    */
	_NETWORK_NAMESPACE
//#ifndef CLIENT_DEFINED
typedef struct NetworkClient *PCLIENT;
//typedef struct Client
//{
//   unsigned char Private_Structure_information_here;
//}CLIENT, *PCLIENT;
//#endif
NETWORK_PROC( CTEXTSTR, GetSystemName )( void );
NETWORK_PROC( PCLIENT, NetworkLockEx )( PCLIENT pc, int readWrite DBG_PASS );
NETWORK_PROC( void, NetworkUnlockEx )( PCLIENT pc, int readWrite DBG_PASS );
/* <combine sack::network::NetworkLockEx@PCLIENT pc>
   \ \                                               */
#define NetworkLock(pc,rw) NetworkLockEx( pc,rw DBG_SRC )
/* <combine sack::network::NetworkUnlockEx@PCLIENT pc>
   \ \                                                 */
#define NetworkUnlock(pc,rw) NetworkUnlockEx( pc,rw DBG_SRC )
typedef void (CPROC*cReadComplete)(PCLIENT, POINTER, size_t );
typedef void (CPROC*cReadCompleteEx)(PCLIENT, POINTER, size_t, SOCKADDR * );
typedef void (CPROC*cCloseCallback)(PCLIENT);
typedef void (CPROC*cWriteComplete)(PCLIENT );
typedef void (CPROC*cNotifyCallback)(PCLIENT server, PCLIENT newClient);
typedef void (CPROC*cConnectCallback)(PCLIENT, int);
typedef void (CPROC*cppReadComplete)(uintptr_t, POINTER, size_t );
typedef void (CPROC*cppReadCompleteEx)(uintptr_t,POINTER, size_t, SOCKADDR * );
typedef void (CPROC*cppCloseCallback)(uintptr_t);
typedef void (CPROC*cppWriteComplete)(uintptr_t );
typedef void (CPROC*cppNotifyCallback)(uintptr_t, PCLIENT newClient);
typedef void (CPROC*cppConnectCallback)(uintptr_t, int);
NETWORK_PROC( void, SetNetworkWriteComplete )( PCLIENT, cWriteComplete );
#ifdef __cplusplus
/* <combine sack::network::SetNetworkWriteComplete@PCLIENT@cWriteComplete>
   \ \                                                                     */
NETWORK_PROC( void, SetCPPNetworkWriteComplete )( PCLIENT, cppWriteComplete, uintptr_t );
#endif
/* <combine sack::network::SetNetworkWriteComplete@PCLIENT@cWriteComplete>
   \ \                                                                     */
#define SetWriteCallback SetNetworkWriteComplete
NETWORK_PROC( void, SetNetworkReadComplete )( PCLIENT, cReadComplete );
#ifdef __cplusplus
/* <combine sack::network::SetNetworkReadComplete@PCLIENT@cReadComplete>
   \ \                                                                   */
NETWORK_PROC( void, SetCPPNetworkReadComplete )( PCLIENT, cppReadComplete, uintptr_t );
#endif
/* <combine sack::network::SetNetworkReadComplete@PCLIENT@cReadComplete>
   \ \                                                                   */
#define SetReadCallback SetNetworkReadComplete
NETWORK_PROC( void, SetNetworkCloseCallback )( PCLIENT, cCloseCallback );
#ifdef __cplusplus
/* <combine sack::network::SetNetworkCloseCallback@PCLIENT@cCloseCallback>
   \ \                                                                     */
NETWORK_PROC( void, SetCPPNetworkCloseCallback )( PCLIENT, cppCloseCallback, uintptr_t );
#endif
/* <combine sack::network::SetNetworkCloseCallback@PCLIENT@cCloseCallback>
   \ \                                                                     */
#define SetCloseCallback SetNetworkCloseCallback
 // wwords is BYTES and wClients=16 is defaulted to 16
#ifdef __LINUX__
NETWORK_PROC( LOGICAL, NetworkWait )(POINTER unused,uint32_t wClients,int wUserData);
#else
NETWORK_PROC( LOGICAL, NetworkWait )(HWND hWndNotify,uint32_t wClients,int wUserData);
#endif
/* <combine sack::network::NetworkWait@HWND@uint16_t@int>
   \ \                                               */
#define NetworkStart() NetworkWait( NULL, 0, 0 )
 // returns true if network layer still active...
NETWORK_PROC( LOGICAL, NetworkAlive )( void );
/* Shutdown these network services, stop the network thread, and
   close all sockets open, releasing all internal resources.
   Parameters
   None.                                                         */
NETWORK_PROC( int, NetworkQuit )(void);
// preferred method is to call Idle(); if in doubt.
//NETWORK_PROC( int, ProcessNetworkMessages )( void );
// dwIP would be for 1.2.3.4  (0x01020304 - memory 04 03 02 01) - host order
// VERY RARE!
NETWORK_PROC( SOCKADDR *, CreateAddress_hton )( uint32_t dwIP,uint16_t nHisPort);
// dwIP would be for 1.2.3.4  (0x04030201 - memory 01 02 03 04) - network order
#ifndef WIN32
NETWORK_PROC( SOCKADDR *, CreateUnixAddress )( CTEXTSTR path );
#endif
NETWORK_PROC( SOCKADDR *, CreateAddress )( uint32_t dwIP,uint16_t nHisPort);
NETWORK_PROC( SOCKADDR *, SetAddressPort )( SOCKADDR *pAddr, uint16_t nDefaultPort );
NETWORK_PROC( SOCKADDR *, SetNonDefaultPort )( SOCKADDR *pAddr, uint16_t nDefaultPort );
/*
 * this is the preferred method to create an address
 * name may be "* / *" with a slash, then the address result will be a unix socket (if supported)
 * name may have an options ":port" port number associated, if there is no port, then the default
 * port is used.
 *
 */
NETWORK_PROC( SOCKADDR *, CreateSockAddress )( CTEXTSTR name, uint16_t nDefaultPort );
/*
 * set (*data) and (*datalen) to a binary buffer representation of the sockete address.
 */
NETWORK_PROC( void, GetNetworkAddressBinary )( SOCKADDR *addr, uint8_t **data, size_t *datalen );
/*
 * create a socket address form data and datalen binary buffer representation of the sockete address.
 */
NETWORK_PROC( SOCKADDR *, MakeNetworkAddressFromBinary )( uintptr_t *data, size_t datalen );
NETWORK_PROC( SOCKADDR *, CreateRemote )( CTEXTSTR lpName,uint16_t nHisPort);
NETWORK_PROC( SOCKADDR *, CreateLocal )(uint16_t nMyPort);
NETWORK_PROC( int, GetAddressParts )( SOCKADDR *pAddr, uint32_t *pdwIP, uint16_t *pwPort );
 // release a socket resource that has been created by an above routine
NETWORK_PROC( void, ReleaseAddress )(SOCKADDR *lpsaAddr);
// result with TRUE if equal, else FALSE
NETWORK_PROC( LOGICAL, CompareAddress )(SOCKADDR *sa1, SOCKADDR *sa2 );
#define SA_COMPARE_FULL 1
#define SA_COMPARE_IP   0
NETWORK_PROC( LOGICAL, CompareAddressEx )(SOCKADDR *sa1, SOCKADDR *sa2, int method );
/*
 * compare this address to see if it is any of my IPv4 interfaces
 */
NETWORK_PROC( LOGICAL, IsThisAddressMe )( SOCKADDR *addr, uint16_t myport );
/*
 *  Get the list of SOCKADDR addresses that are on this box (for this name)
 */
NETWORK_PROC( PLIST, GetLocalAddresses )( void );
/*
 * Return the text of a socket's IP address
 */
NETWORK_PROC( const char *, GetAddrName )( SOCKADDR *addr );
/*
 * Return the numeric form of the address (might have been created by name).
 */
NETWORK_PROC( const char *, GetAddrString )(SOCKADDR *addr);
/*
 * test an address to see if it is v6 (switch connect From behavior at application level)
 */
NETWORK_PROC( LOGICAL, IsAddressV6 )( SOCKADDR *addr );
/*
 *  Duplicate a sockaddr appropriately for the specified network.
 *  SOCKADDR has in(near) it the size of the address block, so this
 * can safely duplicate the the right amount of memory.
 */
 // return a copy of this address...
NETWORK_PROC( SOCKADDR *, DuplicateAddressEx )( SOCKADDR *pAddr DBG_PASS );
#define DuplicateAddress(a) DuplicateAddressEx( a DBG_SRC )
NETWORK_PROC( void, SackNetwork_SetSocketSecure )( PCLIENT lpClient );
NETWORK_PROC( void, SackNetwork_AllowSecurityDowngrade )( PCLIENT lpClient );
/* Transmission Control Protocol connection methods. This
   controls opening sockets that are based on TCP.        */
_TCP_NAMESPACE
#ifdef __cplusplus
/* <combine sack::network::tcp::OpenTCPListenerAddrEx@SOCKADDR *@cNotifyCallback>
   \ \                                                                            */
NETWORK_PROC( PCLIENT, CPPOpenTCPListenerAddrExx )( SOCKADDR *, cppNotifyCallback NotifyCallback, uintptr_t psvConnect DBG_PASS );
#define CPPOpenTCPListenerAddrEx(a,b,c)  CPPOpenTCPListenerAddrExx(a,b,c DBG_SRC )
#endif
/* Opens a TCP socket which listens for connections. Other TCP
   sockets may be connected to this one once it has been
   created.
   Parameters
   Address :         address to serve at. See
                     CreateSockAddress().
   Port :            specified the port to listen at. This family
                     that takes just a port FAILS if there are
                     multiple network interfaces and or virtual
                     private networks.
   NotifyCallback :  user callback which will be invoked when a
                     new connection to the TCP server has been
                     made.
   Returns
   NULL if no clients available, or if address bind on listen
   side fails.
   otherwise is a valid network connection to send and receive
   UDP data on.
   The read_complete callback, if specified, will be called,
   with a NULL pointer and 0 size, before the connect complete.   */
NETWORK_PROC( PCLIENT, OpenTCPListenerAddrExx )( SOCKADDR *, cNotifyCallback NotifyCallback DBG_PASS );
#define OpenTCPListenerAddrEx(sa,ca) OpenTCPListenerAddrExx( sa, ca DBG_SRC )
/* <combine sack::network::tcp::OpenTCPListenerAddrEx@SOCKADDR *@cNotifyCallback>
   \ \                                                                            */
#define OpenTCPListenerAddr( pAddr ) OpenTCPListenerAddrEx( paddr, NULL );
#ifdef __cplusplus
/* <combine sack::network::tcp::OpenTCPListenerEx@uint16_t@cNotifyCallback>
   \ \                                                                 */
NETWORK_PROC( PCLIENT, CPPOpenTCPListenerExx )( uint16_t wPort, cppNotifyCallback NotifyCallback, uintptr_t psvConnect DBG_PASS );
#define CPPOpenTCPListenerEx(a,b,c) CPPOpenTCPListenerExx(a,b,c DBG_SRC )
#endif
/* <combine sack::network::tcp::OpenTCPListenerAddrEx@SOCKADDR *@cNotifyCallback>
   \ \                                                                            */
NETWORK_PROC( PCLIENT, OpenTCPListenerExx )( uint16_t wPort, cNotifyCallback NotifyCallback DBG_PASS );
#define OpenTCPListenerEx(a,b) OpenTCPListenerExx(a,b DBG_SRC )
/* <combine sack::network::tcp::OpenTCPListenerEx@uint16_t@cNotifyCallback>
   \ \                                                                 */
#define OpenTCPListener( wPort )    OpenTCPListenerEx( wPort, NULL )
/* <combine sack::network::tcp::OpenTCPListener>
   \ \                                           */
#define OpenTCPServer OpenTCPListener
/* <combine sack::network::tcp::OpenTCPListenerEx@uint16_t@cNotifyCallback>
   \ \                                                                 */
#define OpenTCPServerEx OpenTCPListenerEx
/* <combine sack::network::tcp::OpenTCPListenerAddrEx@SOCKADDR *@cNotifyCallback>
   \ \                                                                            */
#define OpenTCPServerAddr OpenTCPListenerAddr
/* <combine sack::network::tcp::OpenTCPListenerEx@uint16_t@cNotifyCallback>
   \ \                                                                 */
#define OpenTCPServerAddrEx OpenTCPListenerAddrEx
#define OPEN_TCP_FLAG_DELAY_CONNECT 1
#ifdef __cplusplus
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
NETWORK_PROC( PCLIENT, CPPOpenTCPClientAddrExxx )(SOCKADDR *lpAddr,
																  cppReadComplete  pReadComplete, uintptr_t,
																  cppCloseCallback CloseCallback, uintptr_t,
																  cppWriteComplete WriteComplete, uintptr_t,
																  cppConnectCallback pConnectComplete,  uintptr_t, int DBG_PASS );
#define CPPOpenTCPClientAddrExx(a,b,c,d,e,f,g,h,i,j) CPPOpenTCPClientAddrExxx(a,b,c,d,e,f,g,h,i,j DBG_SRC )
#endif
NETWORK_PROC( PCLIENT, OpenTCPClientAddrFromAddrEx )( SOCKADDR *lpAddr, SOCKADDR *pFromAddr
                                                     , cReadComplete     pReadComplete
                                                     , cCloseCallback    CloseCallback
                                                     , cWriteComplete    WriteComplete
                                                     , cConnectCallback  pConnectComplete
                                                     , int flags
                                                     DBG_PASS
                                                     );
#define OpenTCPClientAddrFromAddr( a,f,r,cl,wr,cc ) OpenTCPClientAddrFromAddrEx( a,f,r,cl,wr,cc, 0 DBG_SRC )
NETWORK_PROC( PCLIENT, OpenTCPClientAddrFromEx )( SOCKADDR *lpAddr, int port
                                                , cReadComplete     pReadComplete
                                                , cCloseCallback    CloseCallback
                                                , cWriteComplete    WriteComplete
                                                , cConnectCallback  pConnectComplete
                                                , int flags
                                                DBG_PASS
                                                );
#define OpenTCPClientAddrFrom( a,f,r,cl,wr,cc ) OpenTCPClientAddrFromEx( a,f,r,cl,wr,cc,0 DBG_SRC )
/* Opens a socket which connects to an already existing,
   listening, socket.
   Parameters
   lpAddr :            _nt_
   lpName :            lpName and wPort are passed to
                       CreateSockAddress, and that address is
                       passed as a lpAddr.
   wPort :             lpName and wPort are passed to
                       CreateSockAddress, and that address is
                       passed as a lpAddr.
   pReadComplete :     user callback which is invoked when a
                       buffer now contains data.
   CloseCallback :     user callback when this socket is closed.
   WriteComplete :     user callback which is invoked when a
                       write operation completes.
   pConnectComplete :  user callback which is called when this
                       client connects. The callback gets this
                       network connection as the first parameter.
   Remarks
   WriteComplete is often unused, unless you are using bMsg
   option on do
   Returns
   NULL if no clients available, or if address bind on listen
   side fails.
   otherwise is a valid network connection to send and receive
   UDP data on.
   The read_complete callback, if specified, will be called,
   with a NULL pointer and 0 size, before the connect complete.   */
NETWORK_PROC( PCLIENT, OpenTCPClientAddrExxx )(SOCKADDR *lpAddr,
                                               cReadComplete  pReadComplete,
                                               cCloseCallback CloseCallback,
                                               cWriteComplete WriteComplete,
                                               cConnectCallback pConnectComplete,
                                               int flags
                                               DBG_PASS );
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
#define OpenTCPClientAddrExx(a,r,clo,w,con) OpenTCPClientAddrExxx( a,r,clo,w,con,0 DBG_SRC )
#ifdef __cplusplus
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
NETWORK_PROC( PCLIENT, CPPOpenTCPClientAddrEx )(SOCKADDR *
                                               , cppReadComplete, uintptr_t
                                               , cppCloseCallback, uintptr_t
                                               , cppWriteComplete, uintptr_t
                                               , int flags
                                               );
#endif
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
NETWORK_PROC( PCLIENT, OpenTCPClientAddrExEx )(SOCKADDR *, cReadComplete,
                         cCloseCallback, cWriteComplete DBG_PASS );
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
#define OpenTCPClientAddrEx(a,b,c,d) OpenTCPClientAddrExEx(a,b,c,d DBG_SRC )
#ifdef __cplusplus
/* <combine sack::network::tcp::OpenTCPClientExx@CTEXTSTR@uint16_t@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                      */
NETWORK_PROC( PCLIENT, CPPOpenTCPClientExEx )(CTEXTSTR lpName,uint16_t wPort
                         , cppReadComplete  pReadComplete, uintptr_t
                         , cppCloseCallback CloseCallback, uintptr_t
                         , cppWriteComplete WriteComplete, uintptr_t
															, cppConnectCallback pConnectComplete, uintptr_t, int DBG_PASS );
#define CPPOpenTCPClientExx(name,port,read,rd,close,cd,write,wd,connect,cod,flg) CPPOpenTCPClientExEx(name,port,read,rd,close,cd,write,wd,connect,cod,flg DBG_SRC)
#endif
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
NETWORK_PROC( PCLIENT, OpenTCPClientExxx )(CTEXTSTR lpName,uint16_t wPort
                                           , cReadComplete  pReadComplete
                                           , cCloseCallback CloseCallback
                                           , cWriteComplete WriteComplete
                                           , cConnectCallback pConnectComplete
                                           , int flags
                                           DBG_PASS );
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
#define OpenTCPClientExx( lpName, wPort, pReadComplete, CloseCallback, WriteComplete, pConnectComplete ) OpenTCPClientExxx( lpName, wPort, pReadComplete, CloseCallback, WriteComplete, pConnectComplete, 0 DBG_SRC )
/* <combine sack::network::tcp::OpenTCPClientExx@CTEXTSTR@uint16_t@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                      */
#define OpenTCPClient( name, port, read ) OpenTCPClientExxx(name,port,read,NULL,NULL,NULL,0 DBG_SRC )
/* <combine sack::network::tcp::OpenTCPClientExx@CTEXTSTR@uint16_t@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                      */
NETWORK_PROC( PCLIENT, OpenTCPClientExEx )( CTEXTSTR, uint16_t, cReadComplete,
													  cCloseCallback, cWriteComplete DBG_PASS );
/* <combine sack::network::tcp::OpenTCPClientExx@CTEXTSTR@uint16_t@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                      */
#define OpenTCPClientEx( addr,port,read,close,write ) OpenTCPClientExEx( addr,port,read,close,write DBG_SRC )
/* Do the connect to
*/
int NetworkConnectTCPEx( PCLIENT pc DBG_PASS );
#define NetworkConnectTCP( pc ) NetworkConnectTCPEx( pc DBG_SRC )
/* Drain is an operation on a TCP socket to just drop the next X
   bytes. They are ignored and not stored into any user buffer.
   Drain reads take precedence over any other queued reads.
   Parameters
   pClient :  network connection to drain data from.
   nLength :  how much data to skip.
   bExact :   if TRUE, will consume all of nLength bytes. if
              FALSE, if there are less than nLength bytes
              available right now, the drain will end when no
              further data is available now.                     */
NETWORK_PROC( LOGICAL, TCPDrainEx )( PCLIENT pClient, size_t nLength, int bExact );
/* <combine sack::network::tcp::TCPDrainEx@PCLIENT@int@int>
   \ \                                                      */
#define TCPDrain(c,l) TCPDrainEx( (c), (l), TRUE )
/* TCP sockets have what is called a NAGLE algorithm that helps
   them gather small packets into larger packets. This implies a
   latency on sent communications, but can provide a boost to
   overall speed.
   Parameters
   pClient :  network client to control the nagle algorithm.
   bEnable :  (TRUE)disable NAGLE or (FALSE)enable NAGLE
              (TRUE)nodelay (FALSE)packet gather delay           */
NETWORK_PROC( void, SetTCPNoDelay )( PCLIENT pClient, int bEnable );
/* TCP Connections have a keep-alive option, that data will be
   automatically sent to make sure the connection is still
   alive.
   Parameters
   pClient :  network connection enable or disable the keep alive
              on.
   bEnable :  TRUE to enable keep\-alive else disable keep\-alive. */
NETWORK_PROC( void, SetClientKeepAlive)( PCLIENT pClient, int bEnable );
/* \    Parameters
   lpClient :   network client to read from
   lpBuffer :   buffer to read into
   nBytes :     size of the buffer to read or maximum amount of
                the read desired.
   bIsStream :  if TRUE, any opportunity to return a packet is
                used to pass data to the user's read callback. If
                FALSE, will read to the complete size nBytes
                specified.
   bWait :      if TRUE, will block in the read until there is
                data, or the buffer is filled completely
                depending on the value of bIsStream. If FALSE,
                \returns immediately, the read completion will be
					 notified later by callback.
	user_timeout : user specified timeout to be used if bWait is specified.
                uses internal configurable timeout if 0.
   Returns
   size of the packet read if bWait is TRUE,
   else TRUE for sent, FALSE if the packet could not be sent.
   This buffer needs to continue existing until the socket is
   closed, or the read callback returns.
   Example
   Used in a normal read callback...
   <code lang="c++">
   void CPROC ReadComplete( PCLIENT pc, POINTER buffer, int size )
   {
       if( buffer == NULL )
           buffer = malloc( 4096 );
       else
       {
          // size will be non 0, process buffer
       }
       ReadTCP( pc, buffer, 4096 );
   }
   </code>                                                         */
NETWORK_PROC( size_t, doReadExx2)(PCLIENT lpClient,POINTER lpBuffer,size_t nBytes, LOGICAL bIsStream, LOGICAL bWait, int user_timeout DBG_PASS );
#define doReadExx(p,b,n,s,w) DoReadExx2( p,b,n,s,w,0 )
/* \    Parameters
   lpClient :   network client to read from
   lpBuffer :   buffer to read into
   nBytes :     size of the buffer to read or maximum amount of
                the read desired.
   bIsStream :  if TRUE, any opportunity to return a packet is
                used to pass data to the user's read callback. If
                FALSE, will read to the complete size nBytes
                specified.
   bWait :      if TRUE, will block in the read until there is
                data, or the buffer is filled completely
                depending on the value of bIsStream. If FALSE,
                \returns immediately, the read completion will be
                notified later by callback.
   Returns
   size of the packet read if bWait is TRUE,
   else TRUE for sent, FALSE if the packet could not be sent.
   This buffer needs to continue existing until the socket is
   closed, or the read callback returns.
   Example
   Used in a normal read callback...
   <code lang="c++">
   void CPROC ReadComplete( PCLIENT pc, POINTER buffer, int size )
   {
       if( buffer == NULL )
           buffer = malloc( 4096 );
       else
       {
          // size will be non 0, process buffer
       }
       ReadTCP( pc, buffer, 4096 );
   }
   </code>                                                         */
//NETWORK_PROC( size_t, doReadExx )(PCLIENT lpClient, POINTER lpBuffer, size_t nBytes
//										, LOGICAL bIsStream, LOGICAL bWait );
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \    Remarks
   if bWait is not specifed, it is passed as FALSE.                            */
//NETWORK_PROC( size_t, doReadEx )(PCLIENT lpClient,POINTER lpBuffer,size_t nBytes, LOGICAL bIsStream DBG_PASS );
#define doReadEx( p,b,n,s )  doReadExx2( p,b,n,s,FALSE, 0 DBG_SRC)
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \ \                                                                         */
#define ReadStream(pc,pBuf,nSize) doReadExx2( pc, pBuf, nSize, TRUE, FALSE, 0 DBG_SRC )
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \ \                                                                         */
#define doRead(pc,pBuf,nSize)     doReadExx2(pc, pBuf, nSize, FALSE, FALSE, 0 DBG_SRC )
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \ \                                                                         */
#define ReadTCP ReadStream
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \ \                                                                         */
#define ReadTCPMsg doRead
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \ \                                                                         */
#define WaitReadTCP(pc,buf,nSize)    doReadExx2(pc,buf, nSize, TRUE, TRUE, 0 DBG_SRC )
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \ \                                                                         */
#define WaitReadTCPMsg(pc,buf,nSize) doReadExx2(pc,buf, nSize, FALSE, TRUE, 0  DBG_SRC)
/* \#The buffer will be sent in the order of the writes to the
   socket, and released when empty. If the socket is immediatly
   able to write, the buffer will be sent, and any remai
   Parameters
   lpClient :     network connection to write to
   pInBuffer :    buffer to write
   nInLen :       Length of the buffer to send
   bLongBuffer :  if TRUE, then the buffer written is maintained
                  exactly by the network layer. A WriteComplete
                  callback will be invoked when the buffer has
                  been sent so the application might delete the
                  buffer.
   failpending :  Uhmm... maybe if it goes to pending, fail?
   Remarks
   If bLongBuffer is not set, then if the write cannot
   immediately complete, then a new buffer is allocated
   internally, and unsent data is buffered by the network
   collection. This allows the user to not worry about slowdowns
   due to blocking writes. Often writes complete immediately,
   and are not buffered other than in the user's own buffer
   passed to this write.                                         */
NETWORK_PROC( LOGICAL, doTCPWriteExx )( PCLIENT lpClient
						, CPOINTER pInBuffer
						, size_t nInLen, int bLongBuffer
                                   , int failpending
                                   DBG_PASS
                                  );
/* <combine sack::network::tcp::doTCPWriteExx@PCLIENT@CPOINTER@int@int@int failpending>
   \ \                                                                                  */
#define doTCPWriteEx( c,b,l,f1,f2) doTCPWriteExx( (c),(b),(l),(f1),(f2) DBG_SRC )
/* <combine sack::network::tcp::doTCPWriteExx@PCLIENT@CPOINTER@int@int@int failpending>
   \ \                                                                                  */
#define SendTCPEx( c,b,l,p) doTCPWriteExx( c,b,l,FALSE,p DBG_SRC)
/* <combine sack::network::tcp::doTCPWriteExx@PCLIENT@CPOINTER@int@int@int failpending>
   \ \                                                                                  */
#define SendTCP(c,b,l) doTCPWriteExx(c,b,l, FALSE, FALSE DBG_SRC)
/* <combine sack::network::tcp::doTCPWriteExx@PCLIENT@CPOINTER@int@int@int failpending>
   \ \                                                                                  */
#define SendTCPLong(c,b,l) doTCPWriteExx(c,b,l, TRUE, FALSE DBG_SRC)
_TCP_NAMESPACE_END
NETWORK_PROC( void, SetNetworkLong )(PCLIENT lpClient,int nLong,uintptr_t dwValue);
NETWORK_PROC( void, SetNetworkInt )(PCLIENT lpClient,int nLong, int value);
/* Obsolete. See SetNetworkLong. */
NETWORK_PROC( void, SetNetworkWord )(PCLIENT lpClient,int nLong,uint16_t wValue);
NETWORK_PROC( uintptr_t, GetNetworkLong )(PCLIENT lpClient,int nLong);
NETWORK_PROC( int, GetNetworkInt )(PCLIENT lpClient,int nLong);
NETWORK_PROC( uint16_t, GetNetworkWord )(PCLIENT lpClient,int nLong);
/* Symbols which may be passed to GetNetworkLong to get internal
   parts of the client.                                          */
enum GetNetworkLongAccessInternal{
 GNL_IP      = (-1),
 /* Gets the IP of the remote side of the connection, if
    applicable. UDP Sockets don't have a bound destination. */
 GNL_PORT    = (-4),
 /* Gets the port at the remote side of the connection that is
    being sent to.                                             */
 GNL_MYIP    = (-3),
 /* Gets the 4 byte IPv4 address that is what I am using on my
    side. After a socket has sent, it will have a set source IP
    under windows.                                              */
 GNL_MYPORT  = (-2),
 /* Gets the 16 bit port of the TCP or UDP connection that you
    are sending from locally.                                  */
 GNL_MAC_LOW = (-5),
 GNL_MAC_HIGH= (-6),
 GNL_REMOTE_ADDRESS = (-7),
 GNL_LOCAL_ADDRESS = (-8),
};
//int get_mac_addr (char *device, unsigned char *buffer)
NETWORK_PROC( int, GetMacAddress)(PCLIENT pc, uint8_t* buf, size_t *buflen );
//NETWORK_PROC( int, GetMacAddress)(PCLIENT pc );
//int get_mac_addr (char *device, unsigned char *buffer)
NETWORK_PROC( PLIST, GetMacAddresses)( void );
NETWORK_PROC( void, RemoveClientExx )(PCLIENT lpClient, LOGICAL bBlockNofity, LOGICAL bLinger DBG_PASS );
/* <combine sack::network::RemoveClientExx@PCLIENT@LOGICAL@LOGICAL bLinger>
   \ \                                                                      */
#define RemoveClientEx(c,b,l) RemoveClientExx(c,b,l DBG_SRC)
/* <combine sack::network::RemoveClientExx@PCLIENT@LOGICAL@LOGICAL bLinger>
   \ \                                                                      */
#define RemoveClient(c) RemoveClientEx(c, FALSE, FALSE )
/* Begin an SSL Connection.  This ends up replacing ReadComplete callback with an inbetween layer*/
NETWORK_PROC( LOGICAL, ssl_BeginClientSession )( PCLIENT pc, CPOINTER keypair, size_t keylen, CPOINTER keypass, size_t keypasslen, CPOINTER rootCert, size_t rootCertLen );
NETWORK_PROC( LOGICAL, ssl_BeginServer )( PCLIENT pc, CPOINTER cert, size_t certlen, CPOINTER keypair, size_t keylen, CPOINTER keypass, size_t keypasslen);
NETWORK_PROC( LOGICAL, ssl_GetPrivateKey )(PCLIENT pc, POINTER *keydata, size_t *keysize);
NETWORK_PROC( LOGICAL, ssl_IsClientSecure )(PCLIENT pc);
NETWORK_PROC( void, ssl_SetIgnoreVerification )(PCLIENT pc);
/* use this to send on SSL Connection instead of SendTCP. */
NETWORK_PROC( LOGICAL, ssl_Send )( PCLIENT pc, CPOINTER buffer, size_t length );
/* User Datagram Packet connection methods. This controls
   opening sockets that are based on UDP.                 */
_UDP_NAMESPACE
/* Open a UDP socket. Since the address to send to is implied on
   each message that is sent, all that is required is to setup
   where the UDP socket is listening.
   Parameters
   pAddr :          Pointer to a string address to listen at. Can
                    be NULL to listen on any interface, (also
                    specified as "0.0.0.0"), see
                    CreateSockAddress notes.
   wPort :          16 bit value for the port to listen at.
   pReadComplete :  user callback which is invoked when a read
                    completes on a UDP socket.
   Close :          close callback which is invoked when the new
                    network connection is closed.
   Returns
   NULL if no clients available, or if address bind on listen
   side fails.
   otherwise is a valid network connection to send and receive
   UDP data on.
   The read_complete callback, if specified, will be called,
	with a NULL pointer and 0 size, before the connect complete.   */
NETWORK_PROC( PCLIENT, CPPServeUDPAddrEx )( SOCKADDR *pAddr
                  , cReadCompleteEx pReadComplete
                  , uintptr_t psvRead
                  , cCloseCallback Close
													 , uintptr_t psvClose
													 , int bCPP DBG_PASS );
NETWORK_PROC( PCLIENT, ServeUDPEx )( CTEXTSTR pAddr, uint16_t wPort,
                  cReadCompleteEx pReadComplete,
                  cCloseCallback Close DBG_PASS );
#define ServeUDP( addr,port,read,close) ServeUDPEx( addr, port, read, close DBG_SRC )
//NETWORK_PROC( PCLIENT, ServeUDP )( CTEXTSTR pAddr, uint16_t wPort,
//                  cReadCompleteEx pReadComplete,
//                  cCloseCallback Close);
//NETWORK_PROC( PCLIENT, ServeUDP )( CTEXTSTR pAddr, uint16_t wPort,
//                  cReadCompleteEx pReadComplete,
//                  cCloseCallback Close);
/* Creates a client to listen for messages or to send UDP
   messages.
   Parameters
   pAddr :          address to listen for UDP messages on.
   pReadComplete :  user callback to received read events.
   Close :          user callback to be invoked when the network
                    connection is closed. (network interface
                    disabled?)
   Returns
   NULL if no sockets are available, or the bind fails. (consult
   log?)
   \returns a network connection which is listening on the
   specified address. The read complete will be called. if it is
	specified, before this function returns.                      */
NETWORK_PROC( PCLIENT, ServeUDPAddrEx )( SOCKADDR *pAddr,
                     cReadCompleteEx pReadComplete,
													 cCloseCallback Close DBG_PASS );
#define ServeUDPAddr(addr,read,close) ServeUDPAddrEx( addr,read,close DBG_SRC )
/* \    Parameters
   address :         Address to listen at (interface
                     specification). Can be NULL to specify ANY
                     address, See notes on CreateSockAddress.
   port :            16 bit port to listen at
   dest_address :    Address to connect to. Can be NULL to
                     specify ANY address, See notes on
                     CreateSockAddress.
   dest_port :       16 bit port to send to. Ignored if
                     dest_address is NULL.
   read_complete :   User event handler which is invoked when
                     data is read from the socket.
   close_callback :  user event handler which is invoked when
                     this socket is closed.
   Returns
   NULL if no clients available, or if address bind on listen
   side fails.
   otherwise is a valid network connection to send and receive
   UDP data on.
   The read_complete callback, if specified, will be called,
   with a NULL pointer and 0 size, before the connect complete. */
NETWORK_PROC( PCLIENT, ConnectUDPEx )( CTEXTSTR , uint16_t ,
                    CTEXTSTR, uint16_t,
                    cReadCompleteEx,
												  cCloseCallback DBG_PASS );
#define ConnectUDP(a,b,c,d,e,f) ConnectUDPEx(a,b,c,d,e,f DBG_SRC )
/* \    Parameters
   sa :             address to listen for UDP messages at.
   saTo :           address to send UDP messages to, if the sa
                    parameter of send is NULL.
   pReadComplete :  user callback which will be invoked when
                    reads complete on the network connection.
   Close :          user callback which will be invoked when the
                    listening socket closes.
   Returns
   NULL if no sockets are available, or the bind fails. (consult
   log?)
   \returns a network connection which is listening on the
   specified address. The read complete will be called. if it is
   specified, before this function returns.                      */
NETWORK_PROC( PCLIENT, ConnectUDPAddrEx )( SOCKADDR *sa,
                        SOCKADDR *saTo,
                    cReadCompleteEx pReadComplete,
													 cCloseCallback Close DBG_PASS );
#define ConnectUDPAddr(a,b,c,d)  ConnectUDPAddrEx(a,b,c,d DBG_SRC )
/* Specify a different default address to send UDP messages to.
   Parameters
   pc :       network connection to change the default target
              address of.
   pToAddr :  text address to connect to. See notes in
              CreateSockAddress.
   wPort :    16 bit port address to connect to.
   Returns
   TRUE if it was a valid address specification.
   FALSE if it could not set the address.                       */
NETWORK_PROC( LOGICAL, ReconnectUDP )( PCLIENT pc, CTEXTSTR pToAddr, uint16_t wPort );
/* Sets the target default address of a UDP connection.
   Parameters
   pc :  network connection to set the target address of.
   sa :  See CreateSockAddress(), this is a network structure that
         is a struct sockaddr{} something.                         */
NETWORK_PROC( LOGICAL, GuaranteeAddr )( PCLIENT pc, SOCKADDR *sa );
/* A UDP message may be sent to a broadcast address or a subnet
   broadcast address, in either case, this must be called to
   enable broadcast communications, else the address must be a
   direct connection.
   Parameters
   pc :       network connection to enable broadcast on.
   bEnable :  TRUE to enable broadcast ability on this socket. FALSE
              to disable broadcast ability.                          */
NETWORK_PROC( void, UDPEnableBroadcast )( PCLIENT pc, int bEnable );
/* Sends to a UDP Network connection.
   Parameters
   pc :     pointer to a network connection to send on.
   pBuf :   buffer to send
   nSize :  size of the buffer to send
   sa :     pointer to a SOCKADDR which this message is destined
            to. Can be NULL, if GuaranteeAddr, or ConnectUDP is
            used.
   Returns
   The number of bytes in the buffer sent? Probably a TRUE if
   success else failure?                                         */
NETWORK_PROC( LOGICAL, SendUDPEx )( PCLIENT pc, CPOINTER pBuf, size_t nSize, SOCKADDR *sa );
/* <combine sack::network::udp::SendUDPEx@PCLIENT@CPOINTER@int@SOCKADDR *>
   \ \                                                                     */
#define SendUDP(pc,pbuf,size) SendUDPEx( pc, pbuf, size, NULL )
/* Queue a read to a UDP socket. A read cannot complete if it
   does not have a buffer to read into. A UDP socket will stall
   if the read callback returns without queuing a read.
   Parameters
   pc :        network connection to read from.
   lpBuffer :  buffer which the next data available on the network
               connection will be read into.
   nBytes :    size of the buffer.                                 */
NETWORK_PROC( int, doUDPRead )( PCLIENT pc, POINTER lpBuffer, int nBytes );
/* <combine sack::network::udp::doUDPRead@PCLIENT@POINTER@int>
   \ \                                                         */
#define ReadUDP doUDPRead
/* Logs to the log file the content of a socket address.
   Parameters
   name :  text leader to print before the address
   sa :    the socket address to dump.                   */
NETWORK_PROC( void, DumpAddrEx )( CTEXTSTR name, SOCKADDR *sa DBG_PASS );
/* <combine sack::network::udp::DumpAddrEx@CTEXTSTR@SOCKADDR *sa>
   \ \                                                            */
#define DumpAddr(n,sa) DumpAddrEx(n,sa DBG_SRC )
NETWORK_PROC( int, SetSocketReuseAddress )( PCLIENT pClient, int32_t enable );
NETWORK_PROC( int, SetSocketReusePort )( PCLIENT pClient, int32_t enable );
_UDP_NAMESPACE_END
USE_UDP_NAMESPACE
struct interfaceAddress {
	SOCKADDR *sa;
	SOCKADDR *saBroadcast;
	SOCKADDR *saMask;
};
NETWORK_PROC( SOCKADDR*, GetBroadcastAddressForInterface )(SOCKADDR *addr);
NETWORK_PROC( SOCKADDR*, GetInterfaceAddressForBroadcast )(SOCKADDR *addr);
NETWORK_PROC( struct interfaceAddress*, GetInterfaceForAddress )( SOCKADDR *addr );
NETWORK_PROC( LOGICAL, IsBroadcastAddressForInterface )( struct interfaceAddress *address, SOCKADDR *addr );
NETWORK_PROC( void, LoadNetworkAddresses )(void);
//----- PING.C ------
NETWORK_PROC( LOGICAL, DoPing )( CTEXTSTR pstrHost,
             int maxTTL,
             uint32_t dwTime,
             int nCount,
             PVARTEXT pResult,
             LOGICAL bRDNS,
             void (*ResultCallback)( uint32_t dwIP, CTEXTSTR name, int min, int max, int avg, int drop, int hops ) );
NETWORK_PROC( LOGICAL, DoPingEx )( CTEXTSTR pstrHost,
             int maxTTL,
             uint32_t dwTime,
             int nCount,
             PVARTEXT pResult,
             LOGICAL bRDNS,
											 void (*ResultCallback)( uintptr_t psv, uint32_t dwIP, CTEXTSTR name, int min, int max, int avg, int drop, int hops )
											, uintptr_t psv );
//----- WHOIS.C -----
NETWORK_PROC( LOGICAL, DoWhois )( CTEXTSTR pHost, CTEXTSTR pServer, PVARTEXT pvtResult );
#ifdef __cplusplus
typedef class network *PNETWORK;
/* <combine sack::network::network>
   \ \                              */
typedef class network
{
	PCLIENT pc;
	int TCP;
	static void CPROC WrapTCPReadComplete( uintptr_t psv, POINTER buffer, size_t nSize );
	static void CPROC WrapUDPReadComplete( uintptr_t psv, POINTER buffer, size_t nSize, SOCKADDR *sa );
	static void CPROC WrapWriteComplete( uintptr_t psv );
	static void CPROC WrapClientConnectComplete( uintptr_t psv, int nError );
	static void CPROC WrapServerConnectComplete( uintptr_t psv, PCLIENT pcNew );
	static void CPROC WrapCloseCallback( uintptr_t psv );
   // notify == server (listen)
	static void CPROC SetNotify( PCLIENT pc, cppNotifyCallback, uintptr_t psv );
   // connect == client (connect)
   static void CPROC SetConnect( PCLIENT pc, cppConnectCallback, uintptr_t psv );
   static void CPROC SetRead( PCLIENT pc, cppReadComplete, uintptr_t psv );
   static void CPROC SetWrite( PCLIENT pc, cppWriteComplete, uintptr_t psv );
   static void CPROC SetClose( PCLIENT pc, cppCloseCallback, uintptr_t psv );
public:
	network() { NetworkStart(); pc = NULL; TCP = TRUE; };
	network( PCLIENT pc ) { NetworkStart(); this->pc = pc; TCP = TRUE; };
	network( network &cp ) { cp.pc = pc; cp.TCP = TCP; };
	~network() { if( pc ) RemoveClientEx( pc, TRUE, FALSE ); pc = NULL; };
	inline void MakeUDP( void ) { TCP = FALSE; }
	virtual void ReadComplete( POINTER buffer, size_t nSize ) {}
	virtual void ReadComplete( POINTER buffer, size_t nSize, SOCKADDR *sa ) {}
	virtual void WriteComplete( void ) {}
	virtual void ConnectComplete( int nError ) {}
	// received on the server listen object...
	virtual void ConnectComplete( class network &pNewClient ) {}
	virtual void CloseCallback( void ) {}
	inline int Connect( SOCKADDR *sa )
	{
		if( !pc )
		pc = CPPOpenTCPClientAddrExx( sa
									, WrapTCPReadComplete
									, (uintptr_t)this
									, WrapCloseCallback
									, (uintptr_t)this
									, WrapWriteComplete
									, (uintptr_t)this
									, WrapClientConnectComplete
									, (uintptr_t)this
									, 0
									);
		return (int)(pc!=NULL);
	};
	inline int Connect( CTEXTSTR name, uint16_t port )
	{
		if( !pc )
		pc = CPPOpenTCPClientExx( name, port
									, WrapTCPReadComplete
									, (uintptr_t)this
									, WrapCloseCallback
									, (uintptr_t)this
									, WrapWriteComplete
									, (uintptr_t)this
									, WrapClientConnectComplete
									, (uintptr_t)this
									, 0
									);
		return (int)(pc!=NULL);
	};
	inline int Listen( SOCKADDR *sa )
	{
		if( !pc )
		{
			if( ( pc = CPPOpenTCPListenerAddrEx( sa
				                        , (cppNotifyCallback)WrapServerConnectComplete
												, (uintptr_t)this
														)  ) != NULL )
			{
				SetRead( pc, (cppReadComplete)WrapTCPReadComplete, (uintptr_t)this );
				SetWrite( pc, (cppWriteComplete)WrapWriteComplete, (uintptr_t)this );
				SetClose( pc, network::WrapCloseCallback, (uintptr_t)this );
			}
		}
		return (int)(pc!=NULL);
	};
	inline int Listen( uint16_t port )
	{
		if( !pc )
		{
			if( ( pc = CPPOpenTCPListenerEx( port
			                      , (cppNotifyCallback)WrapServerConnectComplete
											 , (uintptr_t)this ) ) )
			{
				SetRead( pc, (cppReadComplete)WrapTCPReadComplete, (uintptr_t)this );
				SetWrite( pc, (cppWriteComplete)WrapWriteComplete, (uintptr_t)this );
				SetClose( pc, network::WrapCloseCallback, (uintptr_t)this );
			}
		}
		return (int)(pc!=NULL);
	};
	inline void Write( POINTER p, int size )
	{
		if( pc ) SendTCP( pc, p, size );
	};
	inline void WriteLong( POINTER p, int size )
	{
		if( pc ) SendTCPLong( pc, p, size );
	};
	inline void Read( POINTER p, int size )
	{
		if( pc ) ReadTCP( pc, p, size );
	};
	inline void ReadBlock( POINTER p, int size )
	{
		if( pc ) ReadTCPMsg( pc, p, size );
	};
	inline void SetLong( int l, uint32_t value )
	{
      if( pc ) SetNetworkLong( pc, l, value );
	}
	inline void SetNoDelay( LOGICAL bTrue )
	{
      if( pc ) SetTCPNoDelay( pc, bTrue );
	}
	inline void SetClientKeepAlive( LOGICAL bTrue )
	{
		if( pc ) sack::network::SetClientKeepAlive( pc, bTrue );
	}
	inline uintptr_t GetLong( int l )
	{
		if( pc )
			return GetNetworkLong( pc, l );
	      return 0;
	}
}NETWORK;
#endif
SACK_NETWORK_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::network;
using namespace sack::network::tcp;
using namespace sack::network::udp;
#endif
#endif
//------------------------------------------------------------------
// $Log: network.h,v $
// Revision 1.36  2005/05/23 19:29:24  jim
// Added definition to support WaitReadTCP...
//
// Revision 1.35  2005/03/15 20:22:32  chrisd
// Declare NotifyCallback with meaningful parameters
//
// Revision 1.34  2005/03/15 20:14:15  panther
// Define a routine to build a PF_UNIX socket for unix... this can be used with TCP_ routines to open a unix socket instead of an IP socket.
//
// Revision 1.33  2004/09/29 00:49:47  d3x0r
// Added fancy wait for PSI frames which allows non-polling sleeping... Extended Idle() to result in meaningful information.
//
// Revision 1.32  2004/08/18 23:52:24  d3x0r
// Cleanups - also enhanced network init to expand if called with larger params.
//
// Revision 1.31  2004/07/28 16:47:18  jim
// added support for get address parts.
//
// Revision 1.31  2004/07/27 18:28:17  d3x0r
// Added definition for getaddressparts
//
// Revision 1.30  2004/01/26 23:47:20  d3x0r
// Misc edits.  Fixed filemon.  Export net startup, added def to edit frame
//
// Revision 1.29  2003/12/03 10:21:34  panther
// Tinkering with C++ networking
//
// Revision 1.28  2003/11/09 03:32:22  panther
// Added some address functions to set port and override default port
//
// Revision 1.27  2003/09/25 08:34:00  panther
// Restore callback defs to proper place
//
// Revision 1.26  2003/09/25 08:29:16  panther
// ...New test
//
// Revision 1.25  2003/09/25 00:22:35  panther
// Move cpp wrapper functions into network library
//
// Revision 1.24  2003/09/25 00:21:49  panther
// Move cpp wrapper functions into network library
//
// Revision 1.23  2003/09/24 15:10:54  panther
// Much mangling to extend C++ network interface...
//
// Revision 1.22  2003/09/24 02:26:02  panther
// Fix C++ methods, extend and correct.
//
// Revision 1.21  2003/07/29 09:27:14  panther
// Add Keep Alive option, enable use on proxy
//
// Revision 1.20  2003/07/24 16:56:41  panther
// Updates to expliclity define C procedure model for callbacks and assembly modules - incomplete
//
// Revision 1.19  2003/06/04 11:38:01  panther
// Define PACKED
//
// Revision 1.18  2003/03/25 08:38:11  panther
// Add logging
//
// Revision 1.17  2002/12/22 00:14:11  panther
// Cleanup function declarations and project defines.
//
// Revision 1.16  2002/11/24 21:37:40  panther
// Mods - network - fix server->accepted client method inheritance
// display - fix many things
// types - merge chagnes from verious places
// ping - make function result meaningful yes/no
// controls - fixes to handle lack of image structure
// display - fixes to handle moved image structure.
//
// Revision 1.16  2002/11/21 19:13:11  jim
// Added CreateAddress, CreateAddress_hton
//
// Revision 1.15  2002/07/25 12:59:02  panther
// Added logging, removed logging....
// Network: Added NetworkLock/NetworkUnlock
// Timers: Modified scheduling if the next timer delta was - how do you say -
// to fire again before now.
//
// Revision 1.14  2002/07/23 11:24:26  panther
// Added new function to TCP networking - option on write to disable
// queuing of pending data.
//
// Revision 1.13  2002/07/17 11:33:26  panther
// Added new function to tcp network - dotcpwriteex - allows option to NOT pend
// buffers.
//
// Revision 1.12  2002/07/15 08:34:07  panther
// Include function to set udp broadcast or not.
//
//
// $Log: network.h,v $
// Revision 1.36  2005/05/23 19:29:24  jim
// Added definition to support WaitReadTCP...
//
// Revision 1.35  2005/03/15 20:22:32  chrisd
// Declare NotifyCallback with meaningful parameters
//
// Revision 1.34  2005/03/15 20:14:15  panther
// Define a routine to build a PF_UNIX socket for unix... this can be used with TCP_ routines to open a unix socket instead of an IP socket.
//
// Revision 1.33  2004/09/29 00:49:47  d3x0r
// Added fancy wait for PSI frames which allows non-polling sleeping... Extended Idle() to result in meaningful information.
//
// Revision 1.32  2004/08/18 23:52:24  d3x0r
// Cleanups - also enhanced network init to expand if called with larger params.
//
// Revision 1.31  2004/07/28 16:47:18  jim
// added support for get address parts.
//
// Revision 1.31  2004/07/27 18:28:17  d3x0r
// Added definition for getaddressparts
//
// Revision 1.30  2004/01/26 23:47:20  d3x0r
// Misc edits.  Fixed filemon.  Export net startup, added def to edit frame
//
// Revision 1.29  2003/12/03 10:21:34  panther
// Tinkering with C++ networking
//
// Revision 1.28  2003/11/09 03:32:22  panther
// Added some address functions to set port and override default port
//
// Revision 1.27  2003/09/25 08:34:00  panther
// Restore callback defs to proper place
//
// Revision 1.26  2003/09/25 08:29:16  panther
// ...New test
//
// Revision 1.25  2003/09/25 00:22:35  panther
// Move cpp wrapper functions into network library
//
// Revision 1.24  2003/09/25 00:21:49  panther
// Move cpp wrapper functions into network library
//
// Revision 1.23  2003/09/24 15:10:54  panther
// Much mangling to extend C++ network interface...
//
// Revision 1.22  2003/09/24 02:26:02  panther
// Fix C++ methods, extend and correct.
//
// Revision 1.21  2003/07/29 09:27:14  panther
// Add Keep Alive option, enable use on proxy
//
// Revision 1.20  2003/07/24 16:56:41  panther
// Updates to expliclity define C procedure model for callbacks and assembly modules - incomplete
//
// Revision 1.19  2003/06/04 11:38:01  panther
// Define PACKED
//
// Revision 1.18  2003/03/25 08:38:11  panther
// Add logging
//
/* and then we could be really evil
#define send(s,b,x,t,blah)
#define recv
#define socket
#define getsockopt ?
#define heh yeah these have exact equivalents ....
*/
#define FULL_TRACE
#define LOG_LINES_READ
////#define DEBUG_SLOWNESS
//#define DEBUG_SAVE_CONFIG
//#if defined( GCC ) && !defined( __arm__ )
//#define NEED_ASSEMBLY_CALLER
//#endif
#define DO_LOGGING
/*
 *  Creator: Jim Buckeyne
 *  Header for configscript.lib(bag.lib)
 *  Provides definitions for handling configuration files
 *  or any particular file which has machine generated
 *  characteristics, it can handle translators to decrypt
 *  encrypt.  Method of operation is to create a configuration
 *  evaluator, then AddConfiguratMethod()s to it.
 *  configuration methods are format descriptors for the lines
 *  and a routine which is called when such a line is matched.
 *  One might think of it as a trigger library for MUDs ( a
 *  way to trigger an event based on certain text input,
 *  variations in the text input may be assigned as variables
 *  to be used within the event.
 *
 *  More about configuration string parsing is available in
 *  $(SACK_BASE)/src/configlib/config.rules text file.
 *
 *  A vague attempt at providing a class to derrive a config-
 *  uration reader class, which may contain private data
 *  within such a class, or otherwise provide an object with
 *  simple namespace usage. ( add(), go() )
 *
 *  This library also imlements several PTEXT based methods
 *  which can evaluate text segments into valid binary types
 *  such as text to integer, float, color, etc.  Some of the type
 *  validators applied for the format argument matching of added
 *  methods are available for external reference.
 *
 */
#ifndef CONFIGURATION_SCRIPT_HANDLER
#define CONFIGURATION_SCRIPT_HANDLER
#ifdef CONFIGURATION_LIBRARY_SOURCE
#define CONFIGSCR_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define CONFIGSCR_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
SACK_NAMESPACE namespace config {
#endif
typedef char *__arg_list[1];
typedef __arg_list arg_list;
// declare 'va_list args = NULL;' to use successfully...
// the resulting thing is of type va_list.
typedef struct va_args_tag va_args;
enum configArgType {
	CONFIG_ARG_STRING,
	CONFIG_ARG_INT64,
	CONFIG_ARG_FLOAT,
	CONFIG_ARG_DATA,
	CONFIG_ARG_DATA_SIZE,
	CONFIG_ARG_LOGICAL,
	CONFIG_ARG_FRACTION,
	CONFIG_ARG_COLOR,
};
struct va_args_tag {
	int argsize; arg_list *args; arg_list *tmp_args; int argCount;
};
//#define va_args struct { int argsize; arg_list *args; arg_list *tmp_args; }
#define init_args(name) name.argCount = 0; name.argsize = 0; name.args = NULL;
  // 32 bits.
#define ARG_STACK_SIZE 4
#define PushArgument( argset, argType, type, arg )	 ((argset.args = (arg_list*)Preallocate( argset.args		  , argset.argsize += ((sizeof( enum configArgType )				 + sizeof( type )				  + (ARG_STACK_SIZE-1) )&-ARG_STACK_SIZE) ) )	 ?(argset.argCount++),((*(enum configArgType*)(argset.args))=(argType)),(*(type*)(((uintptr_t)argset.args)+sizeof(enum configArgType)) = (arg)),0	   :0)
#define PopArguments( argset ) { Release( argset.args ); argset.args=NULL; }
#define pass_args(argset) (( (argset).tmp_args = (argset).args ),(*(arg_list*)(&argset.tmp_args)))
/*
 * Config methods are passed an arg_list
 * parameters from arg_list are retrieved using
 * PARAM( arg_list_param_name, arg_type, arg_name );
 * ex.
 *
 *   PARAM( args, char *, name );
 *    // results in a variable called name
 *    // initialized from the first argument in arg_list args;
 */
#define my_va_arg(ap,type)     ((ap)[0]+=        ((sizeof(enum configArgType)+sizeof(type)+ARG_STACK_SIZE-1)&~(ARG_STACK_SIZE-1)),        (*(type *)((ap)[0]-((sizeof(type)+ARG_STACK_SIZE-1)&~(ARG_STACK_SIZE-1)))))
#define my_va_arg_type(ap,type)     (         (*(type *)((ap)[0]-(sizeof(enum configArgType)+(sizeof(type)+ARG_STACK_SIZE-1)&~(ARG_STACK_SIZE-1)))))
//#define my_va_next_arg_type(ap,type)     (*(type *)((ap)[0]))
#define my_va_next_arg_type(ap)     ( ( *(enum configArgType *)((ap)[0]) ) )
#define PARAM_COUNT( args ) (((int*)(args+1))[0])
#define PARAM( args, type, name ) type name = my_va_arg( args, type )
#define PARAMEX( args, type, name, argTypeName ) type name = my_va_arg( args, type ); enum configArgType argTypeName = my_va_arg_type(args)
#define FP_PARAM( args, type, name, fa ) type (CPROC*name)fa = (type (CPROC*)fa)(my_va_arg( args, void *))
typedef struct config_file_tag* PCONFIG_HANDLER;
CONFIGSCR_PROC( PCONFIG_HANDLER, CreateConfigurationEvaluator )( void );
#define CreateConfigurationHandler CreateConfigurationEvaluator
CONFIGSCR_PROC( void, DestroyConfigurationEvaluator )( PCONFIG_HANDLER pch );
#define DestroyConfigurationHandler DestroyConfigurationEvaluator
// this pushes all prior state information about configuration file
// processing, and allows a new set of rules to be made...
CONFIGSCR_PROC( void, BeginConfiguration )( PCONFIG_HANDLER pch );
// begins a sub configuration, and marks to save it for future use
// so we don't have to always recreate the configuration states...
CONFIGSCR_PROC( LOGICAL, BeginNamedConfiguration )( PCONFIG_HANDLER pch, CTEXTSTR name );
// then, when you're done with the new set of rules (end of config section)
// use this to restore the prior configuration state.
CONFIGSCR_PROC( void, EndConfiguration )( PCONFIG_HANDLER pch );
typedef uintptr_t (CPROC*USER_CONFIG_HANDLER)( uintptr_t, arg_list args );
typedef uintptr_t( CPROC*USER_CONFIG_HANDLER_EX )(uintptr_t, uintptr_t, arg_list args);
CONFIGSCR_PROC( void, AddConfigurationEx )( PCONFIG_HANDLER pch
														, CTEXTSTR format
														, USER_CONFIG_HANDLER Process DBG_PASS );
CONFIGSCR_PROC( void, AddConfigurationExx )(PCONFIG_HANDLER pch
	, CTEXTSTR format
	, USER_CONFIG_HANDLER_EX Process, uintptr_t processHandler DBG_PASS);
//CONFIGSCR_PROC( void, AddConfiguration )( PCONFIG_HANDLER pch
//					, char *format
//													 , USER_CONFIG_HANDLER Process );
// make a nice wrapper - otherwise we get billions of complaints.
//#define AddConfiguration(pch,format,process) AddConfiguration( (pch), (format), process )
#define AddConfiguration(pch,f,pr) AddConfigurationEx(pch,f,pr DBG_SRC )
#define AddConfigurationMethod AddConfiguration
// FILTER receives a uintptr_t that was given at configuration (addition to handler)
// it receives a PTEXT block of (binary) data... and must result with
// PTEXT segments which are lines which may or may not have \r\n\\ all
// of which are removed before being resulted to the application.
//   POINTER* is a pointer to a pointer, this pointer may be used
//      for private state data.  The last line of the configuration will
//      call the filter chain with NULL to flush data...
typedef PTEXT (CPROC*USER_FILTER)( POINTER *, PTEXT );
CONFIGSCR_PROC( void, AddConfigurationFilter )( PCONFIG_HANDLER pch, USER_FILTER filter );
CONFIGSCR_PROC( void, ClearDefaultFilters )( PCONFIG_HANDLER pch );
CONFIGSCR_PROC( void, SetConfigurationEndProc )( PCONFIG_HANDLER pch, uintptr_t (CPROC *Process)( uintptr_t ) );
CONFIGSCR_PROC( void, SetConfigurationUnhandled )( PCONFIG_HANDLER pch
																, uintptr_t (CPROC *Process)( uintptr_t, CTEXTSTR ) );
CONFIGSCR_PROC( int, ProcessConfigurationFile )( PCONFIG_HANDLER pch
															  , CTEXTSTR name
															  , uintptr_t psv
															  );
CONFIGSCR_PROC( uintptr_t, ProcessConfigurationInput )( PCONFIG_HANDLER pch, CTEXTSTR block, size_t size, uintptr_t psv );
/*
 * TO BE IMPLEMENTED
 *
CONFIGSCR_PROC( int, vcsprintf )( PCONFIG_HANDLER pch, CTEXTSTR format, va_list args );
CONFIGSCR_PROC( int, csprintf )( PCONFIG_HANDLER pch, CTEXTSTR format, ... );
*/
CONFIGSCR_PROC( int, GetBooleanVar )( PTEXT *start, LOGICAL *data );
CONFIGSCR_PROC( int, GetColorVar )( PTEXT *start, CDATA *data );
//CONFIGSCR_PROC( int, IsBooleanVar )( PCONFIG_ELEMENT pce, PTEXT *start );
//CONFIGSCR_PROC( int, IsColorVar )( PCONFIG_ELEMENT pce, PTEXT *start );
// takes a binary block of data and creates a base64-like string which may be stored.
CONFIGSCR_PROC( void, EncodeBinaryConfig )( TEXTSTR *encode, POINTER data, size_t length );
// this isn't REALLY the same function that's used, but serves the same purpose...
CONFIGSCR_PROC( int, DecodeBinaryConfig )( CTEXTSTR String, POINTER *binary_buffer, size_t *buflen );
CONFIGSCR_PROC( CTEXTSTR, FormatColor )( CDATA color );
CONFIGSCR_PROC( void, StripConfigString )( TEXTSTR out, CTEXTSTR in );
CONFIGSCR_PROC( void, ExpandConfigString )( TEXTSTR out, CTEXTSTR in );
#ifdef __cplusplus
//typedef uintptr_t CPROC ::(*USER_CONFIG_METHOD)( ... );
typedef class config_reader {
   PCONFIG_HANDLER pch;
public:
	config_reader() {
      pch = CreateConfigurationEvaluator();
	}
	~config_reader() {
		if( pch ) DestroyConfigurationEvaluator( pch );
      pch = (PCONFIG_HANDLER)NULL;
	}
	inline void add( CTEXTSTR format, USER_CONFIG_HANDLER Process )
	{
      AddConfiguration( pch, format, Process );
	}
   /*
	inline void add( char *format, USER_CONFIG_METHOD Process )
	{
		union {
			struct {
				uint32_t junk;
            USER_CONFIG_HANDLER Process
			} c;
         USER_CONFIG_METHOD Process;
		} x;
      x.Process = Process;
      AddConfiguration( pch, format, x.c.Process );
		}
      */
	inline int go( CTEXTSTR file, POINTER p )
	{
		return ProcessConfigurationFile( pch, file, (uintptr_t)p );
	}
} CONFIG_READER;
#endif
#ifdef __cplusplus
 //namespace sack { namespace config {
}
SACK_NAMESPACE_END
using namespace sack::config;
#endif
#endif
// $Log: configscript.h,v $
// Revision 1.17  2004/12/05 15:32:06  panther
// Some minor cleanups fixed a couple memory leaks
//
// Revision 1.16  2004/08/13 16:48:19  d3x0r
// added ability to put filters on config script data read.
//
// Revision 1.15  2004/02/18 20:46:37  d3x0r
// Add some aliases for badly named routines
//
// Revision 1.14  2004/02/08 23:33:15  d3x0r
// Add a iList class for c++, public access to building parameter va_lists
//
// Revision 1.13  2003/12/09 16:15:56  panther
// Define unhnalded callback set
//
// Revision 1.12  2003/11/09 22:31:58  panther
// Fix CPROC indication on endconfig method
//
// Revision 1.11  2003/10/13 04:25:14  panther
// Fix configscript library... make sure types are consistant (watcom)
//
// Revision 1.10  2003/10/12 02:47:05  panther
// Cleaned up most var-arg stack abuse ARM seems to work.
//
// Revision 1.9  2003/09/24 02:53:58  panther
// Define c++ wrapper for config script library
//
// Revision 1.8  2003/07/24 22:49:01  panther
// Modify addconfig method macro to auto typecast - dangerous by simpler
//
// Revision 1.7  2003/07/24 16:56:41  panther
// Updates to expliclity define C procedure model for callbacks and assembly modules - incomplete
//
// Revision 1.6  2003/04/17 09:32:51  panther
// Added true/false result from processconfigfile.  Added default load from /etc to msgsvr and display
//
// Revision 1.5  2003/03/25 08:38:11  panther
// Add logging
//
#ifdef __cplusplus
namespace sack { namespace config {
using namespace sack::math::fraction;
#endif
#ifdef __LINUX__
#define stricmp strcasecmp
#define strnicmp strncasecmp
#endif
#define CompareText(l1,l2)	( StrCaseCmp( GetText(l1), GetText(l2) ) )
// all matches to content are done case insensitive.
// consider vector/array declarations
enum config_types {
	CONFIG_UNKNOWN
	// must match case-insensative exact length.
	// literal text
	, CONFIG_TEXT
	// a yes/no field may be 0/1, y[es]/n[o], on/off
	//
	, CONFIG_YESNO
	, CONFIG_TRUEFALSE = CONFIG_YESNO
	, CONFIG_ONOFF = CONFIG_YESNO
	, CONFIG_OPENCLOSE = CONFIG_YESNO
	, CONFIG_BOOLEAN = CONFIG_YESNO
	// may not have a . point - therefore the . is a terminator and needs
	// to match the next word.
	, CONFIG_INTEGER
	// has to be a floating point number (perhaps integral ie. no decimal)
	, CONFIG_FLOAT
	// binary data storage - stored as base64 encoded passed as PDATA
	, CONFIG_BINARY
	// formated number [+/-][[ ]## ]##[/##]
	, CONFIG_FRACTION
	// matches any single word.
	, CONFIG_SINGLE_WORD
	// protocol://[user[:password]](ip/name)[:port][/filepath][?cgi]
	// by convention this will not contain spaces... but perhaps
	// &20; (?)
	, CONFIG_URL
	// matches several words in a row - the end word to match is supplied.
	, CONFIG_MULTI_WORD
	// file name - does not have any path part.
	// the following are all treated like multi_word since file names/paths
	// may contain spaces
	, CONFIG_FILE
	// ends in a / or \,
	, CONFIG_PATH
	// may have path and filename
	, CONFIG_FILEPATH
	// (IP/name)[:port]
	, CONFIG_ADDRESS
	// end of configuration line (match assumed)
	, CONFIG_PROCEDURE
	, CONFIG_PROCEDURE_EX
	, CONFIG_COLOR
 // to save as an option after variables
	, CONFIG_NOTHING
};
typedef struct config_element_tag CONFIG_ELEMENT, *PCONFIG_ELEMENT;
struct config_element_tag
{
	enum config_types type;
// if a match is found, follow this to next.
	struct config_test_tag *next;
	struct config_element_tag *prior;
 // this is where we came from
	struct config_element_tag **ppMe;
	struct {
		BIT_FIELD vector : 1;
 // prior == actual segment...
		BIT_FIELD multiword_terminator : 1;
 // prior == actual segment...
		BIT_FIELD singleword_terminator : 1;
		// careful - assembly here requires absolute known
		// posisitioning - -fpack-struct will short-change
		// this structure to the minimal number of bits.
		BIT_FIELD filler:29;
	} flags;
 // used with vector fields.
	uint32_t element_count;
	union {
		PTEXT pText;
		struct {
				LOGICAL bTrue;
		} truefalse;
		uint64_t integer_number;
		double float_number;
 // also pFilename, pPath, pURL
		TEXTSTR pWord;
		struct {
 // also pFilename, pPath, pURL
			TEXTSTR pWord;
 // also this ends single word...
			PLIST pEnds;
			struct config_element_tag *pWhichEnd;
		} singleword;
		// maybe pURL should be burst into
		//	( address, user, password, path, page, params )
		SOCKADDR *psaSockaddr;
		struct {
			TEXTSTR pWords;
				 // next thing to match...
				 // this is probably a constant text thing, but
				 // may be say an integer, filename, or some known
				 // format thing...
//struct config_element_tag *pEnd;
			PLIST pEnds;
			struct config_element_tag *pWhichEnd;
		} multiword;
		FRACTION fraction;
		USER_CONFIG_HANDLER Process;
		struct {
			USER_CONFIG_HANDLER_EX Process;
			uintptr_t arg;
		} ProcessEx;
		CDATA Color;
		struct {
			size_t length;
			POINTER data;
		} binary;
 // these are value holders... if there is a vector field,
	} data[1];
				// either the count will be specified, or this will have to
				// be auto expanded....
};
typedef struct config_test_tag
{
	// this constant list could be a more optimized structure like
	// a tree...
  // list of words which are constant to be checked.
	PLIST pConstElementList;
	// list of fields which are variables.
	PLIST pVarElementList;
} CONFIG_TEST, *PCONFIG_TEST;
#define MAXCONFIG_TESTSPERSET 128
DeclareSet( CONFIG_TEST );
#define MAXCONFIG_ELEMENTSPERSET 128
DeclareSet( CONFIG_ELEMENT );
typedef struct config_file_tag CONFIG_HANDLER;
struct config_file_tag
{
	// this needs to be the first element -
	// address of this IS the address of main structure
	CONFIG_TEST ConfigTestRoot;
	PDATASTACK ConfigStateStack;
	FILE *file;
	//gcroot<System::IO::StreamReader^> sr;
	//gcroot<System::IO::FileStream^> fs;
	PTEXT blocks;
	// this should be more than one...
	// and each will be called in order that it was
	// added, very importatn first in first process
	PLIST filters;
 // a scratch pointer addrss passd to each filter ... (per config handler)
	PLIST filter_data;
	//uintptr_t (CPROC *filter)(uintptr_t,int *,char**);
	uintptr_t psvUser;
	uintptr_t (CPROC *EndProcess)( uintptr_t );
	uintptr_t (CPROC *Unhandled)( uintptr_t, CTEXTSTR );
	PCONFIG_ELEMENTSET elements;
	PCONFIG_TESTSET test_elements;
	LOGICAL config_recovered;
	CTEXTSTR save_config_as;
 // history of saved coniguration states...
	PLIST states;
	struct config_file_flags {
 // if used, don't release
		BIT_FIELD bConfigSaveNameUsed : 1;
		BIT_FIELD bUnicode : 1;
		BIT_FIELD bUnicode8 : 1;
	} flags;
};
typedef struct configuation_state *PCONFIG_STATE;
typedef struct configuation_state {
	LOGICAL recovered;
	CTEXTSTR name;
	CONFIG_TEST ConfigTestRoot;
	uintptr_t psvUser;
	uintptr_t (CPROC *EndProcess)( uintptr_t );
	uintptr_t (CPROC *Unhandled)( uintptr_t, CTEXTSTR );
} CONFIG_STATE;
struct configscript_global {
	//LOGICAL bSaveMemDebug;
	int _last_allocate_logging;
	int _disabled_allocate_logging;
	struct {
		BIT_FIELD bInitialized : 1;
		BIT_FIELD bDisableMemoryLogging : 1;
		BIT_FIELD bLogUnhandled : 1;
		BIT_FIELD bLogTrace : 1;
		BIT_FIELD bLogLines : 1;
	} flags;
};
#ifdef g
#  undef g
#endif
#ifndef __STATIC_GLOBALS__
static struct configscript_global *global_config_data;
PRIORITY_PRELOAD( InitGlobalConfigScript, CONFIG_SCRIPT_PRELOAD_PRIORITY )
{
	SimpleRegisterAndCreateGlobal( global_config_data );
}
#else
static struct configscript_global _global_config_data;
static struct configscript_global *global_config_data = &_global_config_data;
#endif
#define g (*global_config_data)
void DoInit( void )
{
#ifndef __STATIC_GLOBALS__
	if( !global_config_data )
		SimpleRegisterAndCreateGlobal( global_config_data );
#endif
	if( !g.flags.bInitialized )
	{
		g.flags.bDisableMemoryLogging = 1;
		g.flags.bLogUnhandled = 0;
		g.flags.bInitialized = 1;
	}
}
PRELOAD( InitGlobalConfig2 )
{
	DoInit();
#if !defined( __NO_OPTIONS__ )
	// later, set options - core startup configs like sql.config cannot read options.
	g.flags.bDisableMemoryLogging = SACK_GetProfileIntEx( WIDE( "SACK/Config Script" ), WIDE( "Disable Memory Logging" ), g.flags.bDisableMemoryLogging, TRUE );
	g.flags.bLogUnhandled = SACK_GetProfileIntEx( WIDE( "SACK/Config Script" ), WIDE( "Log Unhandled if no application handler" ), g.flags.bLogUnhandled, TRUE );
	g.flags.bLogTrace = SACK_GetProfileIntEx( WIDE( "SACK/Config Script" ), WIDE( "Log configuration processing(trace)" ), g.flags.bLogTrace, TRUE );
	g.flags.bLogLines = SACK_GetProfileIntEx( WIDE( "SACK/Config Script" ), WIDE( "Log configuration line input" ), g.flags.bLogLines, TRUE );
#endif
}
//#else
//#define g global_config_data
//static GLOBAL g;
//#endif
//---------------------------------------------------------------------
void LogElementEx( CTEXTSTR leader, PCONFIG_ELEMENT pce DBG_PASS)
#define LogElement(leader,pc) LogElementEx(leader,pc DBG_SRC )
{
	if( !pce )
	{
		_lprintf(DBG_RELAY)( WIDE("Nothing.") );
		return;
	}
	switch( pce->type )
	{
	case CONFIG_UNKNOWN:
		_lprintf(DBG_RELAY)( WIDE("This thing was never configured?") );
		break;
	case CONFIG_TEXT:
		_lprintf(DBG_RELAY)( WIDE("%s text constant: %s"), leader, GetText( pce->data[0].pText ) );
		break;
	case CONFIG_BOOLEAN:
		_lprintf(DBG_RELAY)( WIDE("%s a boolean"), leader );
		break;
	case CONFIG_INTEGER:
		_lprintf(DBG_RELAY)( WIDE("%s integer"), leader );
		break;
	case CONFIG_COLOR:
		_lprintf(DBG_RELAY)( WIDE("%s color"), leader );
		break;
	case CONFIG_BINARY:
		_lprintf(DBG_RELAY)( WIDE("%s binary"), leader );
		break;
	case CONFIG_FLOAT:
		_lprintf(DBG_RELAY)( WIDE("%s Floating"), leader );
		break;
	case CONFIG_FRACTION:
		_lprintf(DBG_RELAY)( WIDE("%s fraction"), leader );
		break;
	case CONFIG_SINGLE_WORD:
		_lprintf(DBG_RELAY)( WIDE("%s a single word:%p"), leader, pce->data[0].pWord );
		break;
	case CONFIG_MULTI_WORD:
		_lprintf(DBG_RELAY)( WIDE("%s a multi word"), leader );
		break;
	case CONFIG_PROCEDURE:
		_lprintf(DBG_RELAY)( WIDE("%s a procedure to call."), leader );
		break;
	case CONFIG_PROCEDURE_EX:
		_lprintf( DBG_RELAY )(WIDE( "%s a procedure to call." ), leader);
		break;
	case CONFIG_URL:
	_lprintf(DBG_RELAY)( WIDE("%s a url?"), leader );
	break;
	case CONFIG_FILE:
	_lprintf(DBG_RELAY)( WIDE("%s a filename"), leader );
	break;
	case CONFIG_PATH:
	_lprintf(DBG_RELAY)( WIDE("%s a path name"), leader );
	break;
	case CONFIG_FILEPATH:
	_lprintf(DBG_RELAY)( WIDE("%s a full path and file name"), leader );
	break;
	case CONFIG_ADDRESS:
	_lprintf(DBG_RELAY)( WIDE("%s an address"), leader );
	break;
	default:
		_lprintf(DBG_RELAY)( WIDE("Do not know what this is.") );
		break;
	}
}
//---------------------------------------------------------------------
void DumpConfigurationEvaluator( PCONFIG_HANDLER pch )
{
	INDEX idx;
	PCONFIG_ELEMENT pce;
	LIST_FORALL( pch->ConfigTestRoot.pConstElementList, idx, PCONFIG_ELEMENT, pce )
	{
		LogElement( WIDE("const"), pce );
	}
	LIST_FORALL( pch->ConfigTestRoot.pVarElementList, idx, PCONFIG_ELEMENT, pce )
	{
		LogElement( WIDE( "var" ), pce );
	}
}
//---------------------------------------------------------------------
// man what a friggin mess just to deal with ANY
// kind of mangled input and spit out some kinda lines
// uhmm...
static PTEXT CPROC FilterLines( POINTER *scratch, PTEXT buffer )
{
	struct my_scratch_data {
		size_t skip;
		int lastread;
		PTEXT linebuf;
	} *data = (struct my_scratch_data*)scratch[0];
	size_t total_length;
	size_t n;
	size_t thisskip;
	if( !data && buffer )
	{
		scratch[0] = data = New( struct my_scratch_data );
		data[0].skip = 0;
		data[0].linebuf = 0;
		data[0].lastread = 0;
	}
	else if( !data )
		return NULL;
 // skip N characters in first buffer.
	thisskip = data->skip;
	if( buffer )
	{
		data->lastread = FALSE;
		data->linebuf = SegAppend( data->linebuf, buffer );
	}
#if 0
	// this routine is a low level raw data input, line result routine.
	// it would be the sort of thing that produces zerosegs.
	// this will NEVER run - the above condition catches it.
	else if( buffer && !GetTextSize( buffer ) )
	{
		// if the buffer is a zeroseg, then it's a end of line marker.
		// assuming other things filter before this.... in reality
		// burst returns newlines I think?
		PTEXT text = data->linebuf;
		data->lastread = FALSE;
		Release( scratch[0] );
		scratch[0] = NULL;
		if( text )
		{
			LineRelease( buffer );
			lprintf( WIDE( "Returning buffer [%s]" ), GetText( text ) );
			return text;
		}
		else
		{
			lprintf( WIDE( "Returning buffer [%s]" ), GetText( buffer ) );
 // pass it on to others - end of stream..
			return buffer;
		}
	}
#endif
	else if( !buffer )
	{
		if( data->lastread )
		{
			PTEXT final = NULL;
			if( data->linebuf )
				final = SegCreateFromText( GetText( data->linebuf ) + data->skip );
			LineRelease( data->linebuf );
			Release( scratch[0] );
			scratch[0] = NULL;
			if( g.flags.bLogLines )
				lprintf( WIDE( "Returning buffer [%s]" ), GetText( final ) );
			return final;
		}
	}
	buffer = data->linebuf;
	total_length = 0;
	while( buffer )
	{
		// full new buffer, which may or may not add to prior segments...
		int end = 0;
		size_t length = GetTextSize( buffer );
		CTEXTSTR chardata = GetText( buffer );
		//lprintf( WIDE( "Considering buffer %s" ), GetText( buffer ) + data->skip );
		if( !length )
			LineRelease( SegGrab( buffer ) );
		for( n = thisskip; n < length; n++ )
		{
			if( chardata[n] == '\n' ||
				chardata[n] == '\r' )
			{
				if( chardata[n] == '\n' )
				{
					end = 1;
 // include this character.
					n++;
					//lprintf( WIDE("BLANK LINE - CONSUMED") );
					break;
				}
 // \r\r is two lines too
				if( end )
				{
					break;
				}
				end = 1;
			}
			else if( end )
			{
				// any other character... after a \r.. don't include the character.
				break;
			}
		}
		total_length += n - thisskip;
		if( end )
		{
			// new character, trim at -1 from here...
			PTEXT result = SegCreate( (int32_t)total_length );
			size_t ofs;
			buffer = data->linebuf;
			thisskip = data->skip;
			n = thisskip;
			ofs = 0;
			while( ofs < total_length )
			{
				size_t len = GetTextSize( buffer );
				if( len > ( len - thisskip ) )
					len = len - thisskip;
				if( len > ( total_length - ofs ) )
					len = total_length - ofs;
				MemCpy( GetText( result ) + ofs
					, GetText( buffer ) + thisskip
					, sizeof( TEXTCHAR)*len );
				ofs += len;
				n += len;
				if( ofs < total_length )
				{
					n = 0;
					thisskip = 0;
					buffer = NEXTLINE( buffer );
				}
			}
			if( buffer )
			{
				data->skip = n;
				LineRelease( SegBreak( buffer ) );
				data->linebuf = buffer;
			}
			else
				data->skip = 0;
			GetText(result)[total_length] = 0;
			//lprintf( "Considering buffer %s", GetText( result ) );
			if( g.flags.bLogLines )
				lprintf( WIDE( "Returning buffer [%s]" ), GetText( result ) );
			return result;
		}
		else
		{
			//lprintf( WIDE("Had no end within the buffer, waiting for another...") );
		}
 // no more skips.
		thisskip = 0;
		buffer = NEXTLINE( buffer );
	}
	data->lastread = TRUE;
	return NULL;
}
//---------------------------------------------------------------------
static PTEXT CPROC FilterTerminators( POINTER *scratch, PTEXT buffer )
{
	struct my_scratch_data {
		PTEXT newline;
	} *data = (struct my_scratch_data*)scratch[0];
	if( !data && buffer )
	{
		scratch[0] = data = New( struct my_scratch_data );
		data[0].newline = NULL;
	}
	else if( !data )
		return NULL;
	if( !buffer )
	{
		if( data[0].newline )
		{
			PTEXT tmp = data[0].newline;
			data[0].newline = NULL;
			return tmp;
		}
		else
			return NULL;
	}
	{
		int modified;
		int end = TRUE;
		// filter \r\n\\ just cause...
		data[0].newline = SegAppend( data[0].newline, buffer );
		while( buffer )
		{
			TEXTSTR chardata = GetText( buffer );
			size_t length = GetTextSize( buffer );
			//LogBinary( chardata, length );
			do
			{
				modified = 0;
				if( length && chardata[length-1] == '\n' )
				{
					//Log( WIDE("Removing newline...") );
					end = TRUE;
					length--;
					modified = 1;
				}
				if( length && chardata[length-1] == '\r' )
				{
					//lprintf( WIDE("Removing cr...") );
					end = TRUE;
					length--;
					modified = 1;
				}
				if( length && chardata[length-1] == '\\' )
				{
					if( ( length > 1 ) && ( chardata[length-2] != '\\' ) )
					{
						//lprintf( WIDE("Removing continue slash...") );
						end = FALSE;
						length--;
						modified = 1;
					}
				}
			} while( modified );
			if( !length )
			{
				LineRelease( SegGrab( buffer ) );
				data[0].newline = NULL;
				return NULL;
			}
			chardata[length] = 0;
			//lprintf( WIDE("Resulting line: %s"), chardata );
			SetTextSize( buffer, length );
			buffer = NEXTLINE( buffer );
		}
		if( end )
		{
			PTEXT result = data[0].newline;
			data[0].newline = NULL;
			return result;
		}
	}
	return NULL;
}
//---------------------------------------------------------------------------
/* does not need scratch buffer... */
static PTEXT CPROC FilterEscapesAndComments( POINTER *scratch, PTEXT pText )
{
	CTEXTSTR text = GetText( pText );
	PTEXT pNewText;
 /*&& strchr( text, '\\' )*/
	if( text )
	{
		PTEXT tmp;
		tmp = pNewText = TextDuplicate( pText, FALSE );
		while( tmp )
		{
			int dest = 0, src = 0;
			TEXTSTR text = GetText( tmp );
			while( text && text[src] )
			{
				if( text[src] == '\\' )
				{
					src++;
					switch( text[src] )
					{
					case 0:
						lprintf( WIDE( "Continuation at end of line... save this and append next line please." ) );
						break;
					default:
						text[dest++] = text[src];
						break;
					}
				}
				else
				{
					if( text[src] == '#' )
						break;
					text[dest++] = text[src];
				}
				src++;
			}
			text[dest] = 0;
			SetTextSize( tmp, dest );
			tmp = NEXTLINE( tmp );
		}
		LineRelease( pText );
	}
	else
		pNewText = pText;
	return pNewText;
}
//---------------------------------------------------------------------
static PTEXT get_line(PCONFIG_HANDLER pch
							, int bReturnBlank )
{
  // character for workspace
#define WORKSPACE 1024
	FILE *source = pch->file;
	PLIST *filters = &pch->filters;
	PLIST *filter_data = &pch->filter_data;
	PTEXT newline = NULL;
	int one_more_read = 0;
	//if( !source && !pch->blocks )
	//	return NULL;
	// create a workspace to read input from the file.
	// read a line of input from the file.
	// can't use fgets with encrypted data, but have to use something
	// more like read(), pass to decrypt, then decode lines.
	{
		INDEX idx;
		PTEXT (CPROC *filter)(POINTER*,PTEXT);
		size_t readlen;
		do
		{
			int didone;
		do_filters:
			do
			{
				didone = FALSE;
				LIST_FORALL( filters[0], idx, PTEXT (CPROC *)(POINTER*,PTEXT), filter )
				{
					// request any existing data without adding more...
					newline = filter( GetLinkAddress( filter_data, idx ), newline );
					//lprintf( WIDE( "Process line: %s" ), GetText( newline ) );
					//lprintf( WIDE("after filter %d line = %s"), idx, GetText( newline ) );
					if( newline )
					{
						one_more_read = 0;
						didone = TRUE;
					}
					else
					{
						//lprintf( WIDE("no more newline... it's been deleted...") );
 // had one, lost it, try for another from the top of blank...
						if( didone )
						{
							if( bReturnBlank )
								return SegCreate(0);
							didone = 0;
							break;
						}
					}
				}
			}
			while( !newline && didone );
			if( !newline )
			{
				if( source )
				{
					char buffer[WORKSPACE];
					wchar_t wbuffer[WORKSPACE];
					newline = NULL;
					if( pch->flags.bUnicode )
					{
						if( !one_more_read )
						{
							if( ( readlen = sack_fread( wbuffer, sizeof( wchar_t ), WORKSPACE-1, source ) ) )
							{
								wbuffer[readlen] = 0;
								newline = SegCreateFromWideLen( wbuffer, readlen );
							}
							else
							{
								newline = NULL;
								one_more_read = 1;
							}
						}
						else
							one_more_read = 0;
					}
					else
					{
						if( !one_more_read )
						{
							if( ( readlen = sack_fread( buffer, sizeof( char ), WORKSPACE-1, source ) ) )
							{
								buffer[readlen] = 0;
								newline = SegCreateFromCharLen( buffer, readlen );
							}
							else
							{
								newline = NULL;
								one_more_read = 1;
							}
						}
						else
							one_more_read = 0;
					}
				}
				else
				{
					if( !one_more_read )
					{
						newline = pch->blocks;
 // received block.
						pch->blocks = NULL;
						one_more_read = 1;
					}
					else if( !newline )
					{
						readlen = 0;
						one_more_read = 0;
					}
				}
				if( newline || one_more_read )
					goto do_filters;
				/*
				LIST_FORALL( filters[0], idx, PTEXT (CPROC *)(POINTER*,PTEXT), filter )
				{
					newline = filter( GetLinkAddress( filter_data, idx ), newline );
					//lprintf( WIDE( "Process line: %s" ), GetText( newline ) );
					if( !newline )
						break; // get next bit of data ....
				}
				*/
			}
		}
		while( !newline && readlen );
	}
		// return the line read from the file.
	return newline;
}
//---------------------------------------------------------------------
static PTEXT GetConfigurationLine( PCONFIG_HANDLER pConfigHandler )
{
	PTEXT line, p;
	while( ( line = get_line( pConfigHandler
									, pConfigHandler->Unhandled?TRUE:FALSE ) ) )
	{
		if( g.flags.bLogLines )
			lprintf( WIDE( "Process line: %s" ), GetText( line ) );
		p = burst( line );
		LineRelease( line );
		if( g.flags.bLogTrace || g.flags.bLogLines )
		{
			{
				PTEXT x = p;
				while( x )
				{
					lprintf( WIDE("Word is: %s (%")_size_f WIDE(",%d)"), GetText( x ), GetTextSize( x ), x->format.position.offset.spaces );
					x = NEXTLINE( x );
				}
			}
			{
				PTEXT tmp = BuildLine( p );
				lprintf( WIDE("input: %s"), GetText( tmp ) );
				LineRelease( tmp );
			}
		}
		if( p &&
			GetTextSize( p ) )
		{
			return p;
		}
 // drop and consume blank lines.
		else
		{
			//lprintf( WIDE("Okay got a blank line... might handle it with 'unhandled'") );
			if( pConfigHandler->Unhandled )
				pConfigHandler->Unhandled( pConfigHandler->psvUser, NULL );
			LineRelease(p);
		}
	}
	return NULL;
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
// Is____Var results in true/false, plus the config element is filled
// with the current value.  start will also be updated to the current
// location to process.  Otherwise, false will be returned, the element
// will remain uninitialized, and start will not be updated.
//---------------------------------------------------------------------
int IsAnyVarEx( PCONFIG_ELEMENT pce, PTEXT *start DBG_PASS );
int IsAnyVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	return IsAnyVarEx( pce, start DBG_SRC );
}
#define IsAnyVar(a,b) IsAnyVarEx(a,b DBG_SRC )
//---------------------------------------------------------------------
int IsConstTextEx( PCONFIG_ELEMENT pce, PTEXT *start DBG_PASS )
#define IsConstText(a,b) IsConstTextEx(a,b DBG_SRC )
{
	if( pce->type != CONFIG_TEXT )
	{
		return FALSE;
	}
	if( g.flags.bLogTrace )
		_lprintf(DBG_RELAY)( WIDE("Testing %s vs %s"), GetText( *start ), GetText( pce->data[0].pText ) );
	if( CompareText( *start, pce->data[0].pText ) == 0 )
	{
		if( g.flags.bLogTrace )
			lprintf( WIDE("%s matched %s"), GetText( *start ), GetText( pce->data[0].pText ) );
		*start = NEXTLINE( *start );
		return TRUE;
	}
	if( g.flags.bLogTrace )
		lprintf( WIDE("isn't constant...") );
	return FALSE;
}
//---------------------------------------------------------------------
static CTEXTSTR charset1 = WIDE("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-+");
static CTEXTSTR charset2 = WIDE("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY.-Z+");
typedef union bintobase{
	struct {
		uint8_t bytes[3];
	} bin;
	// these need to be unsigned.
	// the warning is 'nonstandard extension used : bit field types other than int'
	// but 'int' will NOT work, because it's signed.
	struct {
		uint32_t data1 : 6;
		uint32_t data2 : 6;
		uint32_t data3 : 6;
		uint32_t data4 : 6;
	} base;
} BINBASE;
void EncodeBinaryConfig( TEXTSTR *encode, POINTER data, size_t length )
{
	BINBASE convert;
	CTEXTSTR charset = charset2;
	unsigned char *p;
	TEXTCHAR *q;
	uint32_t l;
	int bExtraBytes;
	q = (TEXTCHAR*)((*encode) = NewArray( TEXTCHAR, ( ( ( 1 + (length + 2) / 3 ) * 4 ) + 3 ) * 2 ));
	(q++)[0]= '[';
	p = (unsigned char*)&length;
	convert.bin.bytes[0] = (p++)[0];
	convert.bin.bytes[1] = (p++)[0];
	convert.bin.bytes[2] = (p++)[0];
#define EXPLOIT_BURST_FEATURE()	if( ((q[-1] == '+')?(q[0]='0'),1:0 ) ||	 ((q[-1] == '.')?(q[0]='1'),1:0 ) ||											((q[-1] == '-')?(q[0]='2'),1:0 ) )												{																	q[-1] = '.';											q++;														}
	(q++)[0] = charset[convert.base.data1];
	EXPLOIT_BURST_FEATURE();
	(q++)[0] = charset[convert.base.data2];
	EXPLOIT_BURST_FEATURE();
	(q++)[0] = charset[convert.base.data3];
	EXPLOIT_BURST_FEATURE();
	(q++)[0] = charset[convert.base.data4];
	EXPLOIT_BURST_FEATURE();
	p = (unsigned char*)data;
	for( l = 0; l < length - 2; l += 3 )
	{
		convert.bin.bytes[0] = (p++)[0];
		convert.bin.bytes[1] = (p++)[0];
		convert.bin.bytes[2] = (p++)[0];
		(q++)[0] = charset[convert.base.data1];
	EXPLOIT_BURST_FEATURE();
		(q++)[0] = charset[convert.base.data2];
	EXPLOIT_BURST_FEATURE();
		(q++)[0] = charset[convert.base.data3];
	EXPLOIT_BURST_FEATURE();
		(q++)[0] = charset[convert.base.data4];
	EXPLOIT_BURST_FEATURE();
	}
	bExtraBytes = 0;
	if( l < length )
	{
		bExtraBytes = 1;
		convert.bin.bytes[0] = (p++)[0];
		l++;
	}
	if( l < length )
	{
		bExtraBytes = 1;
		convert.bin.bytes[1] = (p++)[0];
		l++;
	}
	else if( bExtraBytes )
		convert.bin.bytes[1] = 0;
	if( l < length )
	{
		bExtraBytes = 1;
		convert.bin.bytes[2] = (p++)[0];
		l++;
	}
	else if( bExtraBytes )
		convert.bin.bytes[2] = 0;
	if( bExtraBytes )
	{
		(q++)[0] = charset[convert.base.data1];
	EXPLOIT_BURST_FEATURE();
		(q++)[0] = charset[convert.base.data2];
	EXPLOIT_BURST_FEATURE();
		(q++)[0] = charset[convert.base.data3];
	EXPLOIT_BURST_FEATURE();
		(q++)[0] = charset[convert.base.data4];
	EXPLOIT_BURST_FEATURE();
	}
	(q++)[0]= '}';
	(q++)[0] = 0;
}
//---------------------------------------------------------------------
int DoDecodeBinary( PTEXT *start, POINTER *binary_buffer, size_t *buflen )
{
	static int *reverse;
	static int reverse1[256];
	static int reverse2[256];
	size_t failsafe_len;
	CTEXTSTR charset;
	POINTER failsafe_buffer;
	if( reverse1['B'] == 0 )
	{
		int c;
		for( c = 0; charset2[c]; c++ )
		{
			reverse1[(int)charset1[c]] = c;
			reverse2[(int)charset2[c]] = c;
		}
	}
	if( !buflen )
		buflen = &failsafe_len;
	if( !binary_buffer )
		binary_buffer = &failsafe_buffer;
	(*buflen) = 0;
	(*binary_buffer) = NULL;
	if( GetText( *start )[0] == '{' )
	{
		reverse = reverse1;
		charset = charset1;
	}
	else if( GetText( *start )[0] == '[' )
	{
		reverse = reverse2;
		charset = charset2;
	}
	else
		charset = NULL;
	if( charset )
	{
		BINBASE convert;
		size_t len;
		CTEXTSTR p = GetText( NEXTLINE( *start ) );
		// looks like a good chance this is a binary blob
		char *q;
		TEXTCHAR ch;
#define HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION()	  if( (ch=(p++)[0]) == '.' ) {	if( p[0] == '0' ) {p++;ch='+';}								else if ( p[0] == '1' ) {p++;ch = '.';}					else if ( p[0] == '2' ) {p++;ch = '-';}					}
		// if it is empty data... null, and 0
		if( NEXTLINE( *start ) &&
			( ( charset == charset1 && GetText( NEXTLINE( *start  ) )[0] == '}' )
			|| ( charset == charset2 && GetText( NEXTLINE( *start  ) )[0] == ']' ) ) )
		{
			(*binary_buffer) = NULL;
			(*buflen) = 0;
 // step from { onto }
			(*start) = NEXTLINE( *start );
 // step from } onto next token
			(*start) = NEXTLINE( *start );
			return TRUE;
		}
		if( !GetText( NEXTLINE( NEXTLINE( *start  ) ) ) ||
			( GetText( NEXTLINE( NEXTLINE( *start  ) ) )[0] != '}'
			&& GetText( NEXTLINE( NEXTLINE( *start  ) ) )[0] != ']' )
		)
		{
			return FALSE;
		}
		// HANLDE_BURST_EXPLOIT converts .0, .1, .2 into .-+ characters... and sets 'ch'
		// to the character to find.
		HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
		convert.base.data1 = reverse[(int)ch];
		HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
		convert.base.data2 = reverse[(int)ch];
		HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
		convert.base.data3 = reverse[(int)ch];
		HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
		convert.base.data4 = reverse[(int)ch];
		q = (char*)buflen;
		q[0] = convert.bin.bytes[0];
		q[1] = convert.bin.bytes[1];
		q[2] = convert.bin.bytes[2];
		// may be as much as 2 extra bytes (expressed as 3)
		(*binary_buffer) = Allocate( len = (*buflen) );
		q = (char*)(*binary_buffer);
		while( p[0] && len )
		{
			HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
			convert.base.data1 = reverse[(int)ch];
			HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
			convert.base.data2 = reverse[(int)ch];
			HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
			convert.base.data3 = reverse[(int)ch];
			HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
			convert.base.data4 = reverse[(int)ch];
			if( len && len-- )
				(q++)[0] = convert.bin.bytes[0];
			if( len && len-- )
				(q++)[0] = convert.bin.bytes[1];
			if( len && len-- )
				(q++)[0] = convert.bin.bytes[2];
		}
 // step from { onto 0235
		(*start) = NEXTLINE( *start );
 // step from 25234 onto }
		(*start) = NEXTLINE( *start );
 // step from } onto next token
		(*start) = NEXTLINE( *start );
		return TRUE;
	}
	else
	{
		(*binary_buffer) = NULL;
		(*buflen) = 0;
	}
	return FALSE;
}
int DecodeBinaryConfig( CTEXTSTR string, POINTER *binary_buffer, size_t *buflen )
{
	int status;
	PTEXT tmp1 = SegCreateFromText( string );
	PTEXT start = burst( tmp1 );
 // save this decode updates position...
	PTEXT delete_string = start;
	LineRelease( tmp1 );
	status = DoDecodeBinary( &start, binary_buffer, buflen );
	LineRelease( delete_string );
	return status;
}
int IsBinaryVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	if( pce->type != CONFIG_BINARY )
		return FALSE;
	if( pce->data[0].binary.data )
	{
		Release( pce->data[0].binary.data );
		//pce->data[0].binary.data = NULL; // decode binary should do this?!
	}
	return DoDecodeBinary( start, &pce->data[0].binary.data, &pce->data[0].binary.length );
}
//---------------------------------------------------------------------
int IsBooleanVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	size_t len = GetTextSize( *start );
	int bOkay = FALSE;
	if( pce && pce->type != CONFIG_BOOLEAN )
		return FALSE;
	//lprintf( WIDE("Is %s boolean?"), GetText( *start ) );
#define CmpMin(constlen)  ((len <= (constlen))?(len):0)
#define NearText(text,const)	( CmpMin( sizeof( const ) - 1 ) &&							( StrCaseCmpEx( GetText( text ), const, len ) == 0 ) )
	if( NearText( *start, WIDE("yes") ) ||
		NearText( *start, WIDE("1") ) ||
		NearText( *start, WIDE("on") ) ||
		NearText( *start, WIDE("true") ) ||
		NearText( *start, WIDE("open") )
		)
	{
		if(pce)pce->data[0].truefalse.bTrue = 1;
		bOkay = TRUE;
	}
	else if( NearText( *start, WIDE("no") ) ||
			NearText( *start, WIDE("0") ) ||
			NearText( *start, WIDE("off") ) ||
		NearText( *start, WIDE("false") ) ||
		NearText( *start, WIDE("close") )
		)
	{
		if(pce)pce->data[0].truefalse.bTrue = 0;
		bOkay = TRUE;
	}
	else if( NearText( *start, WIDE("are") ) ||
			NearText( *start, WIDE("is") ) )
	{
		PTEXT word;
		bOkay = TRUE;
		if(pce)pce->data[0].truefalse.bTrue = 1;
		if( ( word = NEXTLINE( *start ) ) )
		{
		if( NearText( *start, WIDE("not") ) )
		{
				if(pce)pce->data[0].truefalse.bTrue = 0;
				*start = word;
		}
		}
	}
	if( bOkay )
	{
		*start = NEXTLINE( *start );
		return bOkay;
	}
	return FALSE;
}
int GetBooleanVar( PTEXT *start, LOGICAL *data )
{
	CONFIG_ELEMENT element = { CONFIG_BOOLEAN };
	if( IsBooleanVar( &element, start ) )
	{
		if( data )
			(*data) = element.data[0].truefalse.bTrue;
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
static TEXTCHAR maxbase1[] = WIDE("0123456789abcdefghijklmnopqrstuvwxyz");
static TEXTCHAR maxbase2[] = WIDE("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ");
int TextToInt( CTEXTSTR text, int64_t* out )
{
	struct {
		uint32_t neg : 1;
		uint32_t success : 1;
	} flags;
	uint32_t base;
	int64_t accum;
	flags.neg = 0;
	flags.success = 1;
	if( text[0] == '-' )
	{
		flags.neg = 1;
		text++;
	}
	else if( text[0] == '+' )
	{
		text++;
	}
	base = 10;
	if( text[0] == '0' )
	{
		base = 8;
		text++;
		if( text[0] == 'x' )
		{
				base = 16;
				text++;
		}
		else if( text[0] == 'b' )
		{
				base = 2;
				text++;
		}
	}
	accum = 0;
	while( text[0] )
	{
		CTEXTSTR c;
		uint32_t val;
		if( ( c = StrChr( maxbase1, text[0] ) ) ) val = (uint32_t)(c - maxbase1);
		if( !c ) if( ( c = StrChr( maxbase2, text[0] ) ) ) val = (uint32_t)(c - maxbase2);
		if( !c ) { flags.success = 0; break; }
		if( val < base )
		{
				accum *= base;
				accum += val;
		}
		else
		{
			// yeah this works... there are times when badly behaved programs generate
			// output that should not match...
			// launch at screenX by ScreenY	"launch at %i by %i" fails
			// launch at 50 by 59						"					works
			// another rule that took launchat %w by %w could also work... in case
			// there is some variadric thing .. but a different config proc will probably be
			// called for such a case.
				//Log3( WIDE("Base Error : [%c]%s is not within base %d"), text[0], text+1, base );
				flags.success = 0;
				break;
		}
		text++;
	}
	if( flags.success )
	{
		if( out )
		{
			if( flags.neg )
				*out = -accum;
			else
				*out = accum;
		}
		return TRUE;
	}
	return FALSE;
}
int IsIntegerVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	CTEXTSTR text;
	int64_t accum;
	if( pce->type != CONFIG_INTEGER )
		return FALSE;
	text = GetText( *start );
	if( TextToInt( text, &accum ) )
	{
		pce->data[0].integer_number = accum;
		*start = NEXTLINE( *start );
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
int IsColorVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	if( pce->type != CONFIG_COLOR )
		return FALSE;
	// might consider color names also, (of course that table
	// would have to be configurable)
	//lprintf( WIDE("COlor testing: %s"), GetText( *start ) );
	if( GetText( *start )[0] == '$' )
	{
		int ofs = 0;
		PTEXT val = NEXTLINE( *start );
		if( GetTextSize( *start ) == 1 )
			val = NEXTLINE( *start );
		else
		{
			val = *start;
			ofs = 1;
		}
		// potentially a hex variation...
		if( val )
		{
			uint32_t accum = 0;
			CTEXTSTR digit;
			digit = GetText( val ) + ofs;
			//lprintf( WIDE("COlor testing: %s"), digit );
			while( digit && digit[0] )
			{
				int n;
				CTEXTSTR p;
				n = 16;
				p = StrChr( maxbase1, digit[0] );
				if( p )
					n = (uint32_t)(p-maxbase1);
				else
				{
					p = StrChr( maxbase2, digit[0] );
					if( p )
						n = (uint32_t)(p-maxbase2);
				}
				if( n < 16 )
				{
					accum *= 16;
					accum += n;
				}
				else
					break;
				digit++;
			}
			if( ( digit - GetText( val ) ) < 6 )
			{
				lprintf( WIDE("Perhaps an error in color variable...") );
				pce->data[0].Color = accum | 0xFF000000;
			}
			else
			{
				if( ( digit - GetText( val ) ) == 6 )
					pce->data[0].Color = accum | 0xFF000000;
				else
					pce->data[0].Color = accum;
			}
			{
				uint32_t file_color = pce->data[0].Color;
				COLOR_CHANNEL a = (COLOR_CHANNEL)( file_color >> 24 ) & 0xFF;
				COLOR_CHANNEL r = (COLOR_CHANNEL)( file_color >> 16 ) & 0xFF;
				COLOR_CHANNEL grn = (COLOR_CHANNEL)( file_color >> 8 ) & 0xFF;
				COLOR_CHANNEL b = (COLOR_CHANNEL)( file_color >> 0 ) & 0xFF;
				pce->data[0].Color = AColor( r,grn,b,a );
			}
			//Log4( WIDE("Color is: $%08X/(%d,%d,%d)")
			//		, pce->data[0].Color
			//		, RedVal( pce->data[0].Color ), GreenVal(pce->data[0].Color), BlueVal(pce->data[0].Color) );
			*start = NEXTLINE( val );
		}
		return TRUE;
	}
	else if( GetText( *start )[0] == '(' )
	{
		// potentially a parenthetical variation.
		PTEXT val;
		int components = 0;
		uint32_t color = 0;
		for( val = *start;
			val && GetText( val )[0] != ')';
			val = NEXTLINE( val ) )
		{
			int64_t accum = 0;
			//lprintf( WIDE("Test : %s"), GetText( val ) );
			if( GetText(val)[0] == ',' )
				continue;
			if( TextToInt( GetText( val ), &accum ) )
			{
				components++;
				color <<= 8;
				color |= ( accum & 0xFF );
			}
		}
		if( val )
		{
			pce->data[0].Color = color;
			if( components < 4 )
				pce->data[0].Color |= 0xFF000000;
			//Log4( WIDE("Color is: $%08X/(%d,%d,%d)")
			//		, pce->data[0].Color
			//		, RedVal( pce->data[0].Color ), GreenVal(pce->data[0].Color), BlueVal(pce->data[0].Color) );
			*start = NEXTLINE( val );
			return TRUE;
		}
	}
	return FALSE;
}
int GetColorVar( PTEXT *start, CDATA *data )
{
	CONFIG_ELEMENT element = { CONFIG_COLOR };
	if( IsColorVar( &element, start ) )
	{
		if( data )
			(*data) = element.data[0].Color;
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
int IsFloatVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	//char *text;
	if( pce->type != CONFIG_FLOAT )
		return FALSE;
	//text = GetText( *start );
	lprintf( WIDE("Floating values are not processed yet.") );
	return FALSE;
}
//---------------------------------------------------------------------
int IsFractionVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	int32_t accum1, accum2, accum3;
	int neg1, neg2, neg3;
	PTEXT current;
	CTEXTSTR text;
	if( pce->type != CONFIG_FRACTION )
		return FALSE;
	// this may consume multiple segments (4?)  (+/-)##(1) ##(2)/(3)##(4)
	current = *start;
	text = GetText( current );
	accum1 = 0;
	neg1 = 1;
	if( text[0] == '-' )
	{
		neg1 = -1;
		text++;
	}
	else if( text[0] == '+' )
	{
		text++;
	}
	while( text[0] && text[0] >= '0' && text[0] <= '9' )
	{
		accum1 *= 10;
		accum1 += text[0] - '0';
		text++;
	}
	if( text[0] )
	{
		lprintf( WIDE("Error in first argument of format of fraction.") );
		return FALSE;
	}
// collect numerator after whole number.
	current = NEXTLINE( current );
	if( current )
	{
	text = GetText( current );
	accum2 = 0;
		neg2 = 1;
	if( text[0] == '/' )
	{
		//lprintf( WIDE("Promoting whole to numerator, getting denominaotr") );
		neg2	= neg1;
		accum2 = accum1;
		neg1	= 1;
		accum1 = 0;
		goto collect_denominator;
	}
	if( text[0] == '-' )
	{
		neg2 = -1;
		text++;
		}
		else if( text[0] == '+' )
		{
		text++;
		}
		while( text[0] && text[0] >= '0' && text[0] <= '9' )
		{
		accum2 *= 10;
		accum2 += text[0] - '0';
		text++;
		}
		if( text[0] )
		lprintf( WIDE("Error in format of numerator") );
	}
	else
	{
	//lprintf( WIDE("End of line before numerator") );
		pce->data[0].fraction.numerator = accum1;
		pce->data[0].fraction.denominator = neg1;
		*start = NEXTLINE( current );
	return TRUE;
	}
	current = NEXTLINE( current );
	if( current )
	{
	text = GetText( current );
	if( text[0] != '/' )
	{
		lprintf( WIDE("No denominator specified - error in fraction.") );
		return FALSE;
	}
	}
	else
	{
	lprintf( WIDE("End of line before '/'") );
	}
collect_denominator:
	current = NEXTLINE( current );
	if( current )
	{
		text = GetText( current );
		accum3 = 0;
		neg3 = 1;
		if( text[0] == '-' )
		{
		neg3 = -1;
		text++;
		}
		else if( text[0] == '+' )
		{
		text++;
		}
		while( text[0] && text[0] >= '0' && text[0] <= '9' )
		{
		accum3 *= 10;
		accum3 += text[0] - '0';
		text++;
		}
		if( text[0] )
		{
		lprintf( WIDE("Error in format of denominator.") );
		return FALSE;
		}
		//Log7( WIDE("%d*%d+%d / %d*%d*%d*%d"), accum1, accum3, accum2, neg1, neg2, neg3, accum3 );
		pce->data[0].fraction.numerator = accum1 * accum3 + accum2;
		pce->data[0].fraction.denominator = neg1 * neg2 * neg3 * accum3;
		*start = NEXTLINE( current );
	}
	else
	{
		lprintf( WIDE("End of line before denominator.") );
		return FALSE;
	}
	return TRUE;
}
//---------------------------------------------------------------------
int IsSingleWordVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	struct config_element_tag *pEnd;
	PTEXT pWords = NULL;
	int matched = 1;
	struct config_element_tag *default_EOL = NULL;
	//PTEXT __start = *start;
	if( pce->type != CONFIG_SINGLE_WORD )
		return FALSE;
	if( pce->data[0].singleword.pWord )
	{
		Release( pce->data[0].singleword.pWord );
		pce->data[0].singleword.pWord = NULL;
	}
	while( *start )
	{
		if( pWords )
		{
			INDEX idx;
			if( (*start)->format.position.offset.spaces )
			{
				//if( pWords )
				//	LineRelease( pWords );
				// so at a space, stop appending.
				if( g.flags.bLogTrace )
					lprintf( WIDE( "next word has spaces... [%s](%d)" ), GetText( *start ), (*start)->format.position.offset.spaces );
				break;
			}
			LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd ){
				PTEXT _start = *start;
				if( matched = IsAnyVar( pEnd, start ) )
				{
					pce->data[0].singleword.pWhichEnd = pEnd;
					pce->next = pEnd->next;
					if( g.flags.bLogTrace )
						lprintf( WIDE("Failed check for var check..") );
 // restore start..
					*start = _start;
					break;
				}
				else if( pEnd->type == CONFIG_NOTHING ) {
					if( !default_EOL )
						default_EOL = pce;
				}
				//*start = _start;
				//return TRUE;
			}
		}
		// was more than one word.
		if( pWords && ( (*start)->format.position.offset.spaces || (*start)->format.position.offset.tabs ) ) {
			LineRelease( pWords );
			pWords = NULL;
			return FALSE;
		}
		pWords = SegAppend( pWords, SegDuplicate( *start ) );
		if( g.flags.bLogTrace )
			lprintf( WIDE("Appending more to single word...[%s]"), GetText( (*start) ) );
		*start = NEXTLINE( *start );
	}
	if( (!*start) )
	{
		if( !matched && !default_EOL )
		{
			LineRelease( pWords );
			pWords = NULL;
			// multiword ended - end of line, and no match on the next tag...
			return FALSE;
		}
		else if( g.flags.bLogTrace )
			lprintf( WIDE( "is alright - gathered to end of line ok." ) );
	}
	if( pWords )
	{
		PTEXT pText;
		pWords->format.position.offset.spaces= 0;
		pText = BuildLine( pWords );
		LineRelease( pWords );
		if( g.flags.bLogTrace )
			lprintf( WIDE("Setting text word...") );
		pce->data[0].singleword.pWord = StrDup( GetText( pText ) );
		LineRelease( pText );
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
int IsMultiWordVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	struct config_element_tag *pEnd;
	int matched = 1;
	PTEXT pWords = NULL;
	struct config_element_tag *default_EOL = NULL;
	if( pce->type != CONFIG_MULTI_WORD )
		return FALSE;
	if( pce->data[0].multiword.pWords )
	{
		Release( pce->data[0].multiword.pWords );
		pce->data[0].multiword.pWords = NULL;
	}
	while( *start )
	{
		INDEX idx;
		LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd )
		{
			if( matched = IsAnyVar( pEnd, start ) ) {
				pce->data[0].multiword.pWhichEnd = pEnd;
				if( g.flags.bLogTrace )
					lprintf( "Matched one of several?  set next to %p", pEnd, pEnd->next );
				pce->next = pEnd->next;
				break;
			}
			else if( !default_EOL && pEnd->type == CONFIG_NOTHING ) {
				default_EOL = pEnd;
			}
		}
		if( pEnd )
			break;
		pWords = SegAppend( pWords, SegDuplicate( *start ) );
		*start = NEXTLINE( *start );
	}
	if( (!*start) )
	{
		if( !matched && !default_EOL )
		{
			LineRelease( pWords );
			pWords = NULL;
			// multiword ended - end of line, and no match on the next tag...
			return FALSE;
		}
		else {
			if( default_EOL )
				pce->next = default_EOL->next;
			if( g.flags.bLogTrace )
				lprintf( WIDE( "is alright - gathered to end of line ok. (or matched)" ) );
		}
	}
	//if( !pWords )
	//	pWords = SegCreate(0);
	if( pWords )
	{
		pWords->format.position.offset.spaces = 0;
		{
			PTEXT out = BuildLine( pWords );
			TEXTSTR buf = StrDup( GetText( out ) );
			LineRelease( out );
			LineRelease( pWords );
			pce->data[0].multiword.pWords = buf;
		}
		return TRUE;
	}
	/* can have empty space for multiword, but was an OK result anyway...*/
	return matched;
}
//---------------------------------------------------------------------
int IsPathVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	struct config_element_tag *pEnd;
	PTEXT pWords = NULL;
	if( pce->type != CONFIG_PATH )
		return FALSE;
	if( pce->data[0].multiword.pWords )
	{
		Release( pce->data[0].multiword.pWords );
		pce->data[0].multiword.pWords = NULL;
	}
	while( *start  )
	{
		INDEX idx;
		LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd )
		{
			if( IsAnyVar( pEnd, start ) ) {
				pce->data[0].multiword.pWhichEnd = pEnd;
				if( g.flags.bLogTrace )
					lprintf( "Matched one of several?  set next to %p", pEnd->next );
				pce->next = pEnd->next;
				break;
			}
		}
		if( pEnd )
         break;
		pWords = SegAppend( pWords, SegDuplicate( *start ) );
		*start = NEXTLINE( *start );
	}
	if( pWords )
	{
		pWords->format.position.offset.spaces = 0;
		{
			PTEXT out = BuildLine( pWords );
			size_t length;
			TEXTSTR buf = NewArray( TEXTCHAR, length = GetTextSize( out ) + 1 );
			StrCpyEx( buf, GetText( out ), length * sizeof( TEXTCHAR ) );
			LineRelease( out );
			LineRelease( pWords );
			pce->data[0].multiword.pWords = buf;
		}
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
int IsFileVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	struct config_element_tag *pEnd;
	PTEXT pWords = NULL;
	if( pce->type != CONFIG_FILE )
		return FALSE;
	if( pce->data[0].multiword.pWords )
	{
		Release( pce->data[0].multiword.pWords );
		pce->data[0].multiword.pWords = NULL;
	}
	while( *start )
	{
		INDEX idx;
		LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd )
		{
			if( IsAnyVar( pEnd, start ) ) {
				pce->data[0].multiword.pWhichEnd = pEnd;
				lprintf( "Matched one of several?  set next to %p", pEnd->next );
				pce->next = pEnd->next;
				break;
			}
		}
		if( pEnd )
			break;
		pWords = SegAppend( pWords, SegDuplicate( *start ) );
		*start = NEXTLINE( *start );
	}
	if( pWords )
	{
		pWords->format.position.offset.spaces = 0;
		{
			PTEXT out = BuildLine( pWords );
			size_t length;
			TEXTSTR buf = NewArray( TEXTCHAR, length = GetTextSize( out ) + 1 );
			StrCpyEx( buf, GetText( out ), length * sizeof( TEXTCHAR ) );
			LineRelease( out );
			LineRelease( pWords );
			pce->data[0].multiword.pWords = buf;
		}
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
int IsFilePathVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	struct config_element_tag *pEnd;
	PTEXT pWords = NULL;
	if( pce->type != CONFIG_FILEPATH )
		return FALSE;
	if( pce->data[0].multiword.pWords )
	{
		Release( pce->data[0].multiword.pWords );
		pce->data[0].multiword.pWords = NULL;
	}
	while( *start )
	{
		INDEX idx;
		LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd )
		{
			if( IsAnyVar( pEnd, start ) ) {
				pce->data[0].multiword.pWhichEnd = pEnd;
				pce->next = pEnd->next;
				break;
			}
		}
		if( pEnd )
         break;
		pWords = SegAppend( pWords, SegDuplicate( *start ) );
		*start = NEXTLINE( *start );
	}
	if( pWords )
	{
		INDEX idx;
		LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd )
		{
			if( IsAnyVar( pEnd, start ) ) {
				pce->data[0].multiword.pWhichEnd = pEnd;
				pce->next = pEnd->next;
				break;
			}
		}
		pWords->format.position.offset.spaces = 0;
		{
			PTEXT out = BuildLine( pWords );
			size_t length;
			TEXTSTR buf = NewArray( TEXTCHAR, length = GetTextSize( out ) + 1 );
			StrCpyEx( buf, GetText( out ), length * sizeof( TEXTCHAR ) );
			LineRelease( out );
			LineRelease( pWords );
			pce->data[0].multiword.pWords = buf;
		}
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
#if !defined( __NO_NETWORK__ ) && 0
int IsAddressVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	PTEXT pWords = NULL;
	if( pce->type != CONFIG_ADDRESS )
		return FALSE;
	if( pce->data[0].psaSockaddr )
	{
		ReleaseAddress( pce->data[0].psaSockaddr );
		pce->data[0].psaSockaddr = NULL;
	}
	while( *start && !(*start)->format.position.offset.spaces )
	{
		pWords = SegAppend( pWords, SegDuplicate( *start ) );
		*start = NEXTLINE( *start );
	}
	if( pWords )
	{
		pWords->format.position.offset.spaces = 0;
		{
			PTEXT pText = BuildLine( pWords );
			LineRelease( pWords );
			pce->data[0].psaSockaddr = CreateSockAddress( (CTEXTSTR)GetText( pText ), 0 );
			LineRelease( pText );
		}
		return TRUE;
	}
	return FALSE;
}
#endif
//---------------------------------------------------------------------
int IsURLVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	if( pce->type != CONFIG_URL )
		return FALSE;
	return FALSE;
}
//---------------------------------------------------------------------
int IsAnyVarEx( PCONFIG_ELEMENT pce, PTEXT *start DBG_PASS )
{
	if( !pce || !start )
	{
		//lprintf( WIDE("No pce or no start") );
		return FALSE;
	}
	if( g.flags.bLogTrace )
		_lprintf(DBG_RELAY)( WIDE("IsAnyVar") );
	if( pce->type == CONFIG_NOTHING && !(*start) )
		return TRUE;
	return( ( IsConstText( pce, start ) ) ||
			( IsBooleanVar( pce, start ) ) ||
			( IsBinaryVar( pce, start ) ) ||
			( IsIntegerVar( pce, start ) ) ||
			( IsFloatVar( pce, start ) ) ||
			( IsFractionVar( pce, start ) ) ||
			( IsSingleWordVar( pce, start ) ) ||
			( IsMultiWordVar( pce, start ) ) ||
			( IsPathVar( pce, start ) ) ||
			( IsFileVar( pce, start ) ) ||
			( IsFilePathVar( pce, start ) ) ||
			( IsURLVar( pce, start ) ) ||
			( IsColorVar( pce, start ) ) );
}
//---------------------------------------------------------------------
//#define PushArgument( type, arg ) ( (parampack = Preallocate( parampack, argsize += sizeof( arg )) )?(*(type*)(parampack) = (arg)),0:0)
//#define PopArguments( sz ) Release( parampack )
//---------------------------------------------------------------------
void DoProcedure( uintptr_t *ppsvUser, PCONFIG_TEST Check )
{
	INDEX idx;
	PCONFIG_ELEMENT pce = NULL;
	va_args parampack;
#ifdef __WATCOMC__
	va_args save_parampack;
#endif
	init_args( parampack );
	LIST_FORALL( Check->pVarElementList, idx, PCONFIG_ELEMENT, pce )
	{
		if( pce->type == CONFIG_PROCEDURE || pce->type == CONFIG_PROCEDURE_EX )
		{
			if( pce->data[0].Process)
			{
#ifdef NEED_ASSEMBLY_CALLER
				CallProcedure( ppsvUser, pce );
#else
				PCONFIG_ELEMENT pcePush = pce->prior;
				// push arguments in reverse order...
				//lprintf( WIDE("Calling process... ") );
				while( pcePush )
				{
					if( g.flags.bLogTrace )
						LogElement( WIDE("pushing"), pcePush );
					switch( pcePush->type )
					{
					case CONFIG_TEXT:
						break;
					case CONFIG_BINARY:
						PushArgument( parampack, CONFIG_ARG_DATA, POINTER, pcePush->data[0].binary.data );
						PushArgument( parampack, CONFIG_ARG_DATA_SIZE, size_t, pcePush->data[0].binary.length );
						break;
					case CONFIG_BOOLEAN:
						{
							LOGICAL val = pcePush->data[0].truefalse.bTrue;
							PushArgument( parampack, CONFIG_ARG_LOGICAL, LOGICAL, val );
						}
						break;
					case CONFIG_INTEGER:
						PushArgument( parampack, CONFIG_ARG_INT64, int64_t, pcePush->data[0].integer_number );
						break;
					case CONFIG_FLOAT:
						PushArgument( parampack, CONFIG_ARG_FLOAT, float, (float)pcePush->data[0].float_number );
						break;
					case CONFIG_FRACTION:
						PushArgument( parampack, CONFIG_ARG_FRACTION, FRACTION, pcePush->data[0].fraction );
						break;
					case CONFIG_SINGLE_WORD:
						PushArgument( parampack, CONFIG_ARG_STRING, CTEXTSTR, pcePush->data[0].pWord );
						break;
					case CONFIG_COLOR:
						PushArgument( parampack, CONFIG_ARG_COLOR, CDATA, pcePush->data[0].Color );
						break;
					case CONFIG_MULTI_WORD:
					case CONFIG_FILEPATH:
						PushArgument( parampack, CONFIG_ARG_STRING, CTEXTSTR, pcePush->data[0].multiword.pWords );
						break;
					default:
						break;
					}
					//lprintf( WIDE("Total args are now: %d"), argsize );
					pcePush = pcePush->prior;
				}
				if( pce->type == CONFIG_PROCEDURE_EX )
					(*ppsvUser) = pce->data[0].ProcessEx.Process( *ppsvUser, pce->data[0].ProcessEx.arg, pass_args( parampack ) );
				else
					(*ppsvUser) = pce->data[0].Process( *ppsvUser, pass_args(parampack) );
				PopArguments( parampack );
#endif
 // done, end of list, please leave and do not iterate further!
				break;
			}
		}
		else
		{
			switch( pce->type )
			{
			case CONFIG_MULTI_WORD:
			case CONFIG_SINGLE_WORD:
				// null content ?
				break;
			default:
				// actually this probably means that there was no content to complete
				// the match, and NULL is not a valid responce to data...
				lprintf( WIDE("Multiple options here for what to do at end of line?") );
			}
		}
	}
}
void ProcessConfigurationLine( PCONFIG_HANDLER pch, PTEXT line )
		{
			PCONFIG_TEST Check = &pch->ConfigTestRoot;
			PTEXT word = line;
			while( word && Check )
			{
					INDEX idx;
					PCONFIG_ELEMENT pce = NULL;
					if( g.flags.bLogTrace )
						lprintf( WIDE("Test word (%s) vs constant elements"), GetText( word ) );
					LIST_FORALL( Check->pConstElementList, idx, PCONFIG_ELEMENT, pce )
					{
						if( g.flags.bLogTrace )
							lprintf( WIDE("Is %s == %s?"), GetText( word ), GetText( pce->data[0].pText ) );
						if( IsConstText( pce, &word ) )
						{
							Check = pce->next;
							break;
						}
					}
					if( g.flags.bLogTrace )
						lprintf( WIDE("Test word (%s) vs variable elements"), GetText( word ) );
					{
						if( !pce )
						{
							int found = 0;
							LIST_FORALL( Check->pVarElementList, idx, PCONFIG_ELEMENT, pce )
							{
								// end of the line, match should be the process...
								if( g.flags.bLogTrace )
								{
									lprintf( WIDE("Is %s a Thing"), GetText( word ) );
									LogElement( WIDE("Thing is"), pce );
								}
								if( IsAnyVar( pce, &word ) )
								{
									if( g.flags.bLogTrace )
										lprintf( WIDE("Yes, it is any var.") );
									found = 1;
									if( g.flags.bLogTrace )
										lprintf( "pce->next is %p  word is %p(%s)", pce->next, word, GetText( word ) );
									Check = pce->next;
									break;
								}
								else if( g.flags.bLogTrace )
								{
									lprintf( WIDE("But it's not anything I know.") );
								}
							}
							if( g.flags.bLogTrace )
								lprintf( WIDE("is %s"), found?WIDE("found"):WIDE("Not found") );
							if( !found )
							{
								PTEXT pLine = BuildLine( line );
								if( g.flags.bLogTrace )
									lprintf( WIDE("Line not matched[%s]"), GetText( pLine ) );
								if( pch->Unhandled )
									pch->Unhandled( pch->psvUser, GetText( pLine ) );
								else
								{
									if( g.flags.bLogUnhandled )
										xlprintf(LOG_NOISE)( WIDE("Unknown Configuration Line(No unhandled proc): %s"), GetText( pLine ) );
								}
								break;
							}
						}
					}
			}
			if( !Check )
			{
				lprintf( WIDE("Fell off the end the line processor, still have data...") );
				{
					PTEXT pLine = BuildLine( line );
					if( pch->Unhandled )
						pch->Unhandled( pch->psvUser, GetText( pLine ) );
					else
					{
						// I didn't want to get rid of this...
						// but ahh well, it's noisy and it works.
						//lprintf( WIDE("Unknown Configuration Line: %s"), GetText( pLine ) );
					}
				}
			}
	// otherwise we may have bailed early.
			else if( !word )
			{
				// check here for Procedure at end of line (word == NULL)
				DoProcedure( &pch->psvUser, Check );
			}
#if 0
			else
			{
				if( g.flags.bLogTrace )
					lprintf( WIDE("line partially matched... need to recover and re-evaluate..") );
				{
					PTEXT pLine = BuildLine( line );
					if( pch->Unhandled )
						pch->Unhandled( pch->psvUser, GetText( pLine ) );
					else
					{
						// I didn't want to get rid of this...
						// but ahh well, it's noisy and it works.
						//lprintf( WIDE("Unknown Configuration Line: %s"), GetText( pLine ) );
					}
				}
			}
#endif
		}
static void TestUnicode( PCONFIG_HANDLER pch )
{
	int return_pos = 0;
	pch->flags.bUnicode	= 0;
	{
		char charbuf[64];
 // could be really short
		size_t len_read;
		size_t char_check;
		int ascii_unicode = 1;
		len_read = sack_fread( charbuf, 1, 64, pch->file );
		if( ( ((uint16_t*)charbuf)[0] == 0xFEFF )
			|| ( ((uint16_t*)charbuf)[0] == 0xFFFE )
			|| ( ((uint16_t*)charbuf)[0] == 0xFDEF ) )
		{
			return_pos = 2;
			pch->flags.bUnicode = 1;
		}
		else if( ( charbuf[0] == (char)0xef ) && ( charbuf[1] == (char)0xbb ) && ( charbuf[0] == (char)0xbf ) )
		{
			return_pos = 1;
			pch->flags.bUnicode8 = 1;
		}
		else for( char_check = 0; char_check < len_read; char_check++ )
		{
		// every other byte is a 0 for flat unicode text...
			if( ( char_check & 1 ) && ( charbuf[char_check] != 0 ) )
			{
				ascii_unicode = 0;
				break;
			}
		}
		if( ascii_unicode )
		{
			pch->flags.bUnicode = 1;
		}
		else
		{
			int ascii = 1;
			for( char_check = 0; char_check < len_read; char_check++ )
				if( charbuf[char_check] & 0x80 )
				{
					ascii = 0;
					break;
				}
			if( ascii )
			{
				// hmm this is probably a binary thing?
			}
		}
	}
	sack_fseek( pch->file, return_pos, SEEK_SET );
	// rewind
}
//---------------------------------------------------------------------
CONFIGSCR_PROC( int, ProcessConfigurationFile )( PCONFIG_HANDLER pch, CTEXTSTR name, uintptr_t psv )
{
	PTEXT line;
#ifndef __ANDROID__
 // don't prefix with anything.
	int absolute_path = IsAbsolutePath( name );
#endif
	pch->file = sack_fopen( 0, name, WIDE("rb") );
#ifndef __ANDROID__
#  ifndef UNDER_CE
	if( !pch->file && !absolute_path )
	{
		TEXTCHAR pathname[255];
		tnprintf( pathname, sizeof( pathname ), WIDE("./%s"), name );
#	ifdef _MSC_VER
		pathname[sizeof(pathname)/sizeof(pathname[0])-1]=0;
#	endif
		pch->file = sack_fopen( 0, pathname, WIDE("rb") );
	}
	if( !pch->file && !absolute_path )
	{
		TEXTCHAR pathname[255];
		tnprintf( pathname, sizeof( pathname ), WIDE("@/%s"), name );
#	ifdef _MSC_VER
		pathname[sizeof(pathname)/sizeof(pathname[0])-1]=0;
#	endif
		pch->file = sack_fopen( 0, pathname, WIDE("rb") );
	}
#  endif
	if( !pch->file && !absolute_path )
	{
		TEXTCHAR pathname[255];
		tnprintf( pathname, sizeof( pathname ), WIDE("*/%s"), name );
#	ifdef _MSC_VER
		pathname[sizeof(pathname)/sizeof(pathname[0])-1]=0;
#	endif
		pch->file = sack_fopen( 0, pathname, WIDE("rb") );
	}
	if( !pch->file && !absolute_path )
	{
		TEXTCHAR pathname[255];
		tnprintf( pathname, sizeof( pathname ), WIDE("#/%s"), name );
#	ifdef _MSC_VER
		pathname[sizeof(pathname)/sizeof(pathname[0])-1]=0;
#	endif
		pch->file = sack_fopen( 0, pathname, WIDE("rb") );
	}
	if( !pch->file && !absolute_path )
	{
		TEXTCHAR pathname[255];
		tnprintf( pathname, sizeof( pathname ), WIDE("/etc/%s"), name );
#  ifdef _MSC_VER
		pathname[sizeof(pathname)/sizeof(pathname[0])-1]=0;
#  endif
		pch->file = sack_fopen( 0, pathname, WIDE("rb") );
	}
#endif
	pch->psvUser = psv;
	if( pch->file )
	{
		TestUnicode( pch );
		while( ( line = GetConfigurationLine( pch ) ) )
		{
			ProcessConfigurationLine( pch, line );
			LineRelease( line );
		}
		sack_fclose( pch->file );
		if( pch->EndProcess )
			pch->EndProcess( pch->psvUser );
		pch->file = NULL;
		return TRUE;
	}
	else
	{
		//lprintf( WIDE("Failed to open config file: %s"), name );
		return FALSE;
	}
}
//---------------------------------------------------------------------
CONFIGSCR_PROC( uintptr_t, ProcessConfigurationInput )( PCONFIG_HANDLER pch, CTEXTSTR data, size_t size, uintptr_t psv )
{
	pch->psvUser = psv;
	{
		PTEXT line;
		PTEXT block = SegCreate( size + 1 );
		MemCpy( GetText( block ), data, size );
		GetText( block )[size] = 0;
		SetTextSize( block, size );
		pch->blocks = block;
		while( ( line = GetConfigurationLine( pch ) ) )
		{
			ProcessConfigurationLine( pch, line );
			LineRelease( line );
		}
		// this block will have been moved into internal accumulators.
		//LineRelease( block );
	}
	return pch->psvUser;
}
//---------------------------------------------------------------------
static PCONFIG_ELEMENT NewConfigTestElement( PCONFIG_HANDLER pch )
{
 //&(PCONFIG_ELEMENT)Allocate( sizeof( CONFIG_ELEMENT ) );
	PCONFIG_ELEMENT pceNew = GetFromSet( CONFIG_ELEMENT, &pch->elements );
	MemSet( pceNew, 0, sizeof( CONFIG_ELEMENT ) );
	return pceNew;
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
static PCONFIG_TEST NewConfigTest( PCONFIG_HANDLER pch )
{
 //(PCONFIG_TEST)AllocateEx( sizeof( CONFIG_TEST ) DBG_RELAY );
	PCONFIG_TEST pctNew = GetFromSet( CONFIG_TEST, &pch->test_elements );
	MemSet( pctNew, 0, sizeof( CONFIG_TEST ) );
	// I don't actually have to create list...
	// they will be filled in and allocated on demand.
//CreateListEx( DBG_VOIDRELAY );
	pctNew->pConstElementList = NULL;
//CreateListEx( DBG_VOIDRELAY );
	pctNew->pVarElementList = NULL;
	return pctNew;
}
//---------------------------------------------------------------------
void DestroyConfigElement( PCONFIG_HANDLER pch, PCONFIG_ELEMENT pct );
//---------------------------------------------------------------------
void BeginConfiguration( PCONFIG_HANDLER pch )
{
	// pushes the config file handler state...
	if( pch )
	{
		CONFIG_STATE save_state;
		if( !pch->ConfigStateStack )
			pch->ConfigStateStack = CreateDataStack( sizeof( CONFIG_STATE ) );
#ifdef DEBUG_SAVE_CONFIG
		lprintf( "Saving config and psvUser is %08x", pch->psvUser );
		DumpConfigurationEvaluator( pch );
#endif
		save_state.recovered = pch->config_recovered;
		save_state.ConfigTestRoot = pch->ConfigTestRoot;
		save_state.psvUser = pch->psvUser;
		save_state.EndProcess = pch->EndProcess;
		save_state.Unhandled = pch->Unhandled;
		save_state.name = pch->save_config_as;
		pch->flags.bConfigSaveNameUsed = 1;
		PushData( &pch->ConfigStateStack, &save_state );
#ifdef DEBUG_SAVE_CONFIG
		lprintf( "<BEGIN>" );
#endif
		pch->ConfigTestRoot.pConstElementList = NULL;
		pch->ConfigTestRoot.pVarElementList = NULL;
		pch->EndProcess = NULL;
		pch->Unhandled = NULL;
		pch->config_recovered = FALSE;
#ifdef DEBUG_SAVE_CONFIG
		lprintf( "Setting config as not savable." );
#endif
		pch->save_config_as = NULL;
	}
}
LOGICAL BeginNamedConfiguration( PCONFIG_HANDLER pch, CTEXTSTR name )
{
	// returns true if the configuration previously exists...
	// returns false if it needs to be built.
	INDEX idx;
	PCONFIG_STATE state;
	LIST_FORALL( pch->states, idx, PCONFIG_STATE, state )
	{
		if( StrCmp( state->name, name ) == 0 )
		{
#ifdef DEBUG_SAVE_CONFIG
			lprintf( "found previous config, setting this up, and resulting." );
#endif
			BeginConfiguration( pch );
			pch->ConfigTestRoot = state->ConfigTestRoot;
			pch->EndProcess = state->EndProcess;
			pch->Unhandled = state->Unhandled;
			pch->config_recovered = TRUE;
#ifdef DEBUG_SAVE_CONFIG
			lprintf( "Beginning a named configuration..." );
#endif
			pch->save_config_as = state->name;
#ifdef DEBUG_SAVE_CONFIG
			DumpConfigurationEvaluator( pch );
#endif
			return TRUE;
		}
	}
#ifdef DEBUG_SAVE_CONFIG
	lprintf( "No previous found, setting this up to save at end config..." );
#endif
	BeginConfiguration( pch );
	pch->config_recovered = FALSE;
#ifdef DEBUG_SAVE_CONFIG
	lprintf( "Setting named configuration." );
#endif
	pch->flags.bConfigSaveNameUsed = 0;
	pch->save_config_as = StrDup( name );
	return FALSE;
}
void DestroyConfigTest( PCONFIG_HANDLER pch, PCONFIG_TEST pct, int dealloc );
// this is more like a pop configuration.
void EndConfiguration( PCONFIG_HANDLER pch )
{
	PCONFIG_STATE prior_state;
	//PCONFIG_TEST prior;
	if( pch->EndProcess )
		pch->EndProcess( pch->psvUser );
#ifdef DEBUG_SAVE_CONFIG
	lprintf( "<END>" );
#endif
	prior_state = (PCONFIG_STATE)PopData( &pch->ConfigStateStack );
	if( prior_state )
	{
		if( pch->save_config_as )
		{
			if( !pch->config_recovered )
			{
				CONFIG_STATE *state = New( CONFIG_STATE );
				state->ConfigTestRoot = pch->ConfigTestRoot;
				state->EndProcess = pch->EndProcess;
				state->Unhandled = pch->Unhandled;
				pch->flags.bConfigSaveNameUsed = 1;
				state->name = pch->save_config_as;
				AddLink( &pch->states, state );
			}
			// otherwise there's no action to do... already have it saved.
		}
		else
		{
			//lprintf( WIDE("Config was not saved, destroying.") );
			DestroyConfigTest( pch, &pch->ConfigTestRoot, FALSE );
		}
		// didn't recover from states list.
		pch->config_recovered = prior_state->recovered;
		pch->ConfigTestRoot = prior_state->ConfigTestRoot;
		pch->EndProcess = prior_state->EndProcess;
		pch->Unhandled = prior_state->Unhandled;
		pch->psvUser = prior_state->psvUser;
		pch->save_config_as = prior_state->name;
	}
}
PCONFIG_ELEMENT _AddConfigurationEx( PCONFIG_HANDLER pch, CTEXTSTR format, USER_CONFIG_HANDLER Process DBG_PASS )
{
	PTEXT pTemp = SegCreateFromText( format );
	PTEXT pLine;
	PTEXT pWord;
	struct {
		uint32_t vartag : 1;
		uint32_t vector : 1;
		uint32_t ignore_new : 1;
		uint32_t store_next_as_end : 1;
		uint32_t also_store_next_as_end : 1;
		uint32_t store_as_end : 1;
		uint32_t also_store_as_end : 1;
	}flags;
	PCONFIG_TEST pct;
	PCONFIG_ELEMENT pceNew, pcePrior;
	((uint32_t*)&flags)[0] = 0;
	//flags.dw = 0;
//#if defined( FULL_TRACE ) || defined( DEBUG_SLOWNESS )
	if( g.flags.bLogTrace )
		lprintf( WIDE( "Burst..." ) );
//#endif
	pLine = burst( pTemp );
	LineRelease( pTemp );
	pct = &pch->ConfigTestRoot;
	pceNew = NewConfigTestElement( pch );
	pcePrior = NULL;
	pWord = pLine;
	while( pWord )
	{
		if( g.flags.bLogTrace )
			lprintf( WIDE("Evaluating %s ... "), GetText( pWord ) );
		if( flags.vartag )
		{
			CTEXTSTR pWordText = GetText( pWord );
			if( pWordText[0] == 'v' )
			{
				flags.vector = 1;
				pWordText++;
				if( !pWordText[0] )
				{
					lprintf( WIDE("Format: %s"), format );
					lprintf( WIDE("Configuration error %%v[no type]") );
				}
				LineRelease( pLine );
				lprintf( WIDE( "Destroy config element %p" ), pceNew );
				DestroyConfigElement( pch, pceNew );
				return NULL;
			}
			switch( pWordText[0] )
			{
			case 'b':
				//lprintf( WIDE("is a boolean...") );
				pceNew->type = CONFIG_BOOLEAN;
				pceNew->flags.vector = flags.vector;
				break;
			case 'B':
				//lprintf( WIDE("is a binary...") );
				pceNew->type = CONFIG_BINARY;
				pceNew->flags.vector = flags.vector;
				break;
			case 'i':
				//lprintf( WIDE("Is an integer... ")) ;
				pceNew->type = CONFIG_INTEGER;
				pceNew->flags.vector = flags.vector;
				break;
			case 'c':
				pceNew->type = CONFIG_COLOR;
				pceNew->flags.vector = flags.vector;
				break;
			case 'f':
				pceNew->type = CONFIG_FLOAT;
				pceNew->flags.vector = flags.vector;
				break;
			case 'q':
				pceNew->type = CONFIG_FRACTION;
				pceNew->flags.vector = flags.vector;
				break;
			case 'w':
				if( g.flags.bLogTrace )
					lprintf( WIDE("Setting new as type SINGLE_WORD") );
				pceNew->type = CONFIG_SINGLE_WORD;
				pceNew->flags.vector = flags.vector;
				flags.also_store_next_as_end = 1;
				break;
			case 'm':
				if( g.flags.bLogTrace )
					lprintf( WIDE("Setting new as type MULTI_WORD") );
				pceNew->type = CONFIG_MULTI_WORD;
				pceNew->flags.vector = flags.vector;
				flags.store_next_as_end = 1;
				break;
			case 'u':
				pceNew->type = CONFIG_URL;
				pceNew->flags.vector = flags.vector;
				break;
			case 'd':
				pceNew->type = CONFIG_PATH;
				pceNew->flags.vector = flags.vector;
				flags.store_next_as_end = 1;
				break;
			case 'n':
				pceNew->type = CONFIG_FILE;
				pceNew->flags.vector = flags.vector;
				flags.store_next_as_end = 1;
				break;
			case 'p':
				pceNew->type = CONFIG_FILEPATH;
				pceNew->flags.vector = flags.vector;
				flags.store_next_as_end = 1;
				break;
			case 'a':
				pceNew->type = CONFIG_ADDRESS;
				pceNew->flags.vector = flags.vector;
				break;
			default:
				lprintf( WIDE("Format: %s"), format );
				lprintf( WIDE("Unknown format character: %c"), pWordText[0] );
				flags.ignore_new = 1;
				break;
			}
			if( !flags.ignore_new )
			{
				if( g.flags.bLogTrace )
					lprintf( WIDE("Not ignoring the new thing...") );
				if( flags.store_as_end )
				{
					if( g.flags.bLogTrace )
						lprintf( WIDE("Storing as end...") );
					{
						INDEX idx;
						struct config_element_tag *pEnd;
						LIST_FORALL( pcePrior->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd ){
							if( pceNew->type == pEnd->type ) {
								break;
							}
						}
						if( !pEnd ){
							AddLink( &pcePrior->data[0].multiword.pEnds, pceNew );
							pceNew->flags.multiword_terminator = 1;
							pceNew->prior = pcePrior;
							pct = pceNew->next = NewConfigTest( pch );
							if( g.flags.bLogTrace )
								lprintf( "%p pceNew next is %p", pceNew, pct );
						}
						else{
							if( g.flags.bLogTrace )
								lprintf( "Need to do something with original to chain?" );
							DestroyConfigElement( pch, pceNew );
							pceNew = pEnd;
							pct = pEnd->next;
						}
					}
					pcePrior = pceNew;
					pceNew = NewConfigTestElement( pch );
					flags.store_as_end = 0;
				}
				else
				{
					if( flags.store_next_as_end )
					{
 // flag to store next thing as end condition.
						flags.store_as_end = 1;
						flags.store_next_as_end = 0;
					}
					if( flags.also_store_as_end )
					{
						if( g.flags.bLogTrace )
							lprintf( WIDE("Also Storing as end...") );
						AddLink( &pcePrior->data[0].singleword.pEnds, pceNew );
						pceNew->flags.singleword_terminator = 1;
						flags.also_store_as_end = 0;
					}
					if( flags.also_store_next_as_end )
					{
 // flag to store next thing as end condition.
						flags.also_store_as_end = 1;
						flags.also_store_next_as_end = 0;
					}
					{
						INDEX idx;
						PCONFIG_ELEMENT pceCheck;
						LIST_FORALL( pct->pVarElementList, idx, PCONFIG_ELEMENT, pceCheck )
						{
							if( pceCheck->type == pceNew->type )
							{
								// any data set will be overwritten...
								// uhmm should probably update to new links.
								if( !pceCheck->next )
								{
									lprintf( WIDE("Something fishy here... second instance of same type...") );
								}
								pcePrior = pceCheck;
								pct = pceCheck->next;
								break;
							}
						}
						if( !pceCheck )
						{
//#if defined( FULL_TRACE ) || defined( DEBUG_SLOWNESS )
							if( g.flags.bLogTrace )
								lprintf( WIDE("Adding into a new config test") );
//#endif
							AddLink( &pct->pVarElementList, pceNew );
							pct = pceNew->next = NewConfigTest( pch );
							pceNew->prior = pcePrior;
							pcePrior = pceNew;
							pceNew = NewConfigTestElement( pch );
//#if defined( FULL_TRACE ) || defined( DEBUG_SLOWNESS )
							if( g.flags.bLogTrace )
								lprintf( WIDE( "Added." ) );
//#endif
						}
					}
				}
			}
			else
			{
				lprintf( WIDE("ignoreing NEW!?") );
			}
			flags.vartag = 0;
			flags.vector = 0;
			flags.ignore_new = 0;
		}
		else
		{
			if( TextIs( pWord, WIDE("%") ) )
			{
				if( g.flags.bLogTrace )
					lprintf( WIDE("next thing is a format character") );
				flags.vartag = 1;
			}
 // is static text - literal match.
			else
			{
				INDEX idx;
				PCONFIG_ELEMENT pConst = NULL;
				if( g.flags.bLogTrace )
					lprintf( WIDE("Storing %s as a constant text"), GetText( pWord ) );
				if( flags.store_as_end )
				{
					pceNew->type = CONFIG_TEXT;
					if( g.flags.bLogTrace )
						lprintf( WIDE("Adding %s as the terminator"), GetText( pWord ) );
					pceNew->data[0].pText = SegDuplicate( pWord );
					{
						INDEX idx;
						struct config_element_tag *pEnd;
						LIST_FORALL( pcePrior->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd ){
							if( pceNew->type == pEnd->type ) {
								if( pceNew->type == CONFIG_TEXT ) {
									if( SameText( pceNew->data[0].pText, pEnd->data[0].pText ) == 0 )
										break;
								}
							}
						}
						if( !pEnd ){
							if( g.flags.bLogTrace )
								lprintf( "Added new terminator branch... pce needs a pct" );
							AddLink( &pcePrior->data[0].multiword.pEnds, pceNew );
							pceNew->flags.multiword_terminator = 1;
							pceNew->prior = pcePrior;
                     pct = pceNew->next = NewConfigTest( pch );
						}
						else{
                     // use existing one, so delete this one.
                     DestroyConfigElement( pch, pceNew );
							pceNew = pEnd;
                     pct = pEnd->next;
							if( g.flags.bLogTrace )
								lprintf( "Recovered an old pce to resume from...%p", pEnd );
						}
					}
					pcePrior = pceNew;
					pceNew = NewConfigTestElement( pch );
					flags.store_as_end = 0;
				}
				else
				{
					LIST_FORALL( pct->pConstElementList, idx, PCONFIG_ELEMENT, pConst )
					{
						if( IsConstText( pConst, &pWord ) )
						{
							pct = pConst->next;
							break;
						}
 // this is not always cleared...
						pConst = NULL;
					}
 // continue outer loop (while word)
					if( pConst )
					{
						if( g.flags.bLogTrace )
							lprintf( WIDE("Found constant already in tree") );
						if( flags.also_store_as_end )
						{
							if( g.flags.bLogTrace )
								lprintf( WIDE("Also Storing as end... %s"), GetText( pceNew->data[0].pText ) );
							AddLink( &pcePrior->data[0].singleword.pEnds, pceNew );
							pceNew->flags.singleword_terminator = 1;
							flags.also_store_as_end = 0;
						}
						continue;
					}
					else
					{
						if( g.flags.bLogTrace )
							lprintf( WIDE("Adding new constant to tree:%s"), GetText( pWord ) );
						if( flags.also_store_as_end )
						{
							if( g.flags.bLogTrace )
								lprintf( WIDE("Also Storing as end... %s"), GetText( pceNew->data[0].pText ) );
							AddLink( &pcePrior->data[0].singleword.pEnds, pceNew );
							pceNew->flags.singleword_terminator = 1;
							flags.also_store_as_end = 0;
						}
						pceNew->type = CONFIG_TEXT;
						pceNew->data[0].pText = SegDuplicate( pWord );
						AddLink( &pct->pConstElementList, pceNew );
						pct = pceNew->next = NewConfigTest( pch);
						pceNew->prior = pcePrior;
						pcePrior = pceNew;
						pceNew = NewConfigTestElement(pch );
					}
				}
			}
		}
		pWord = NEXTLINE( pWord );
	}
	if( flags.store_as_end ) {
		pceNew->type = CONFIG_NOTHING;
		AddLink( &pcePrior->data[0].multiword.pEnds, pceNew );
		pceNew->flags.multiword_terminator = 1;
		pceNew->prior = pcePrior;
		pct = pceNew->next = NewConfigTest( pch );
		if( g.flags.bLogTrace )
			lprintf( "%p pceNew next is %p", pceNew, pct );
		pcePrior = pceNew;
		pceNew = NewConfigTestElement( pch );
		flags.store_as_end = 0;
	}
	LineRelease( pLine );
	// end of the format line - add the procedure.
	pceNew->prior = pcePrior;
	// no need to update pcePrior - we're done.
	pceNew->type = CONFIG_PROCEDURE;
	pceNew->data[0].Process = Process;
	AddLink( &pct->pVarElementList, pceNew );
	return pceNew;
}
void AddConfigurationExx( PCONFIG_HANDLER pch, CTEXTSTR format, USER_CONFIG_HANDLER_EX Process, uintptr_t arg DBG_PASS ) {
	PCONFIG_ELEMENT element = _AddConfigurationEx( pch, format, (USER_CONFIG_HANDLER)Process DBG_RELAY );
	if( !element )
		return;
	element->type = CONFIG_PROCEDURE_EX;
	element->data[0].ProcessEx.Process = Process;
	element->data[0].ProcessEx.arg = arg;
}
void AddConfigurationEx( PCONFIG_HANDLER pch, CTEXTSTR format, USER_CONFIG_HANDLER Process DBG_PASS ) {
	_AddConfigurationEx( pch, format, Process DBG_RELAY );
}
//---------------------------------------------------------------------
#undef AddConfiguration
CONFIGSCR_PROC( void, AddConfiguration )( PCONFIG_HANDLER pch, CTEXTSTR format, USER_CONFIG_HANDLER Process )
{
	AddConfigurationEx( pch, format, Process DBG_SRC );
}
//---------------------------------------------------------------------
	CONFIGSCR_PROC( void, SetConfigurationEndProc )( PCONFIG_HANDLER pch
													, uintptr_t (CPROC *Process)( uintptr_t ) )
{
	pch->EndProcess = Process;
}
//---------------------------------------------------------------------
CONFIGSCR_PROC( void, SetConfigurationUnhandled )( PCONFIG_HANDLER pch
																, uintptr_t (CPROC *Process)( uintptr_t, CTEXTSTR ) )
{
	pch->Unhandled = Process;
}
//---------------------------------------------------------------------
CONFIGSCR_PROC( PCONFIG_HANDLER, CreateConfigurationEvaluator )( void )
{
	PCONFIG_HANDLER pch;
	DoInit();
	if( g.flags.bDisableMemoryLogging )
	{
		if( !(g._disabled_allocate_logging++) )
		{
			g._last_allocate_logging = SetAllocateLogging( FALSE );
		}
	}
	pch = (PCONFIG_HANDLER)Allocate( sizeof( CONFIG_HANDLER ) );
	MemSet( pch, 0, sizeof( *pch ) );
	// break input chunks into lines....
	AddLink( &pch->filters, FilterLines );
	SetLink( &pch->filter_data, FindLink( &pch->filters, (POINTER)FilterLines ), 0 );
	// end the lines at # (also remove \r, \n)
	AddLink( &pch->filters, FilterTerminators );
	SetLink( &pch->filter_data, FindLink( &pch->filters, (POINTER)FilterTerminators ), 0 );
	// get rid of \\ and \# to replace with appropriate things
	// since \# might be escaped, this is the only place I can handle the '#' character
	// to terminate lines at comment points.
	AddLink( &pch->filters, FilterEscapesAndComments );
	SetLink( &pch->filter_data, FindLink( &pch->filters, (POINTER)FilterEscapesAndComments ), 0 );
	//pch->ConfigTestRoot.pConstElementList = NULL; //CreateList();
	//pch->ConfigTestRoot.pVarElementList = NULL;//CreateList();
	return pch;
}
//---------------------------------------------------------------------
CONFIGSCR_PROC( void, ClearDefaultFilters )( PCONFIG_HANDLER pch )
{
	EmptyList( &pch->filters );
}
CONFIGSCR_PROC( void, AddConfigurationFilter )( PCONFIG_HANDLER pch, USER_FILTER filter )
{
	AddLink( &pch->filters, filter );
}
//---------------------------------------------------------------------
void DestroyConfigElement( PCONFIG_HANDLER pch, PCONFIG_ELEMENT pce )
{
#ifdef DEBUG_SAVE_CONFIG
	lprintf( "Destroy element %p %p", pch, pce );
#endif
	DestroyConfigTest( pch, pce->next, TRUE );
	switch( pce->type )
	{
	case CONFIG_BINARY:
		if( pce->data[0].binary.data )
			Release( pce->data[0].binary.data );
		break;
	case CONFIG_TEXT:
		if( pce->data[0].pText )
			LineRelease( pce->data[0].pText );
		break;
	case CONFIG_SINGLE_WORD:
		if( pce->data[0].pWord )
			Release( pce->data[0].pWord );
		DeleteList( &pce->data[0].singleword.pEnds );
		break;
	case CONFIG_MULTI_WORD:
		if( pce->data[0].multiword.pWords )
			Release( pce->data[0].multiword.pWords );
		if( pce->data[0].multiword.pEnds )
		{
			struct config_element_tag *pEnd;
			INDEX idx;
			LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd )
			{
#ifdef DEBUG_SAVE_CONFIG
				lprintf( "Destroy config element %p", pEnd );
#endif
				DestroyConfigElement( pch, pEnd );
			}
		}
		DeleteList( &pce->data[0].multiword.pEnds );
		break;
	case CONFIG_URL:
	case CONFIG_PATH:
	case CONFIG_FILE:
	case CONFIG_FILEPATH:
	case CONFIG_ADDRESS:
		break;
	case CONFIG_COLOR:
	case CONFIG_PROCEDURE:
	case CONFIG_PROCEDURE_EX:
	case CONFIG_UNKNOWN:
	case CONFIG_BOOLEAN:
	case CONFIG_INTEGER:
	case CONFIG_FRACTION:
	case CONFIG_FLOAT:
	case CONFIG_NOTHING:
		break;
	}
	DeleteFromSet( CONFIG_ELEMENT, pch->elements, pce );
	//Release( pce );
}
void DestroyConfigTest( PCONFIG_HANDLER pch, PCONFIG_TEST pct, int deallocate )
{
	PCONFIG_ELEMENT pce;
	INDEX idx;
	if( !pct )
		return;
#ifdef DEBUG_SAVE_CONFIG
	lprintf( "Destroy Config %p %p", pch, pct );
#endif
	LIST_FORALL( pct->pConstElementList, idx, PCONFIG_ELEMENT, pce )
	{
#ifdef DEBUG_SAVE_CONFIG
		lprintf( "Delete const element" );
#endif
		DestroyConfigElement( pch, pce );
	}
	DeleteList( &pct->pConstElementList );
	LIST_FORALL( pct->pVarElementList, idx, PCONFIG_ELEMENT, pce )
	{
#ifdef DEBUG_SAVE_CONFIG
		lprintf( "Delete var element" );
#endif
		DestroyConfigElement( pch, pce );
	}
	DeleteList( &pct->pVarElementList );
	// a pconfig_handler has one static root - guaranteed root.
	// if this pct IS the root, don't attempt to delete from set
	if( deallocate )
		//if( pct != &pch->ConfigTestRoot )
		DeleteFromSet( CONFIG_TEST, pch->test_elements, pct );
	//Release( pct );
}
//---------------------------------------------------------------------
CONFIGSCR_PROC( void, DestroyConfigurationEvaluator )( PCONFIG_HANDLER pch )
{
	// since as noted in the structure
	//	// address of this IS the address of main structure
	// the configtest Release() will quickly free this .
	PLIST save_list_pConstElementList = pch->ConfigTestRoot.pConstElementList;
	PLIST save_list_pVarElementList = pch->ConfigTestRoot.pVarElementList;
#ifdef DEBUG_SAVE_CONFIG
	lprintf( "Destroy evaluator %p", pch );
#endif
	DestroyConfigTest( pch, &pch->ConfigTestRoot, FALSE );
	{
		INDEX idx;
		PCONFIG_STATE state;
		LIST_FORALL( pch->states, idx, PCONFIG_STATE, state )
		{
			if( ( save_list_pConstElementList
				&& (state->ConfigTestRoot.pConstElementList == save_list_pConstElementList ))
				|| ( save_list_pVarElementList
					&& (state->ConfigTestRoot.pVarElementList == save_list_pVarElementList ) )
			)
			{
				//probably this was the error I found in the field... there were
				// probably macros or something that caused excessive layering.
				// or - it was the old bug of not saving the state quite correctly.
				continue;
			}
			DestroyConfigTest( pch, &state->ConfigTestRoot, FALSE );
		}
		LIST_FORALL( pch->states, idx, PCONFIG_STATE, state )
		{
			Release( (POINTER)state->name );
			Release( state );
		}
	}
	if( pch->save_config_as && !pch->flags.bConfigSaveNameUsed )
		Release( (POINTER)pch->save_config_as );
	//lprintf( WIDE("Setting memory logging to %d"), _last_allocate_logging );
	if( g.flags.bDisableMemoryLogging )
		if( g._disabled_allocate_logging )
		{
			g._disabled_allocate_logging--;
			if( !g._disabled_allocate_logging )
			{
				SetAllocateLogging( g._last_allocate_logging );
			}
		}
	DeleteList( &pch->states );
	DeleteList( &pch->filters );
	DeleteList( &pch->filter_data );
	DeleteSet( (PGENERICSET*)&(pch->elements) );
	DeleteSet( (PGENERICSET*)&(pch->test_elements) );
	Release( pch );
}
void StripConfigString( TEXTSTR out, CTEXTSTR in )
{
	// convert \r\n to literal characters...
	if( !in )
	{
		out[0] = 0;
		return;
	}
	for( ; in[0]; in++,out++ )
	{
		if( in[0] == '\\' )
		{
			switch( in[1] )
			{
			case 'n':
				in++;
				out[0] = '\n';
				break;
			default:
				out[0] = in[1];
				in++;
				break;
			}
		}
		else
			out[0] = in[0];
	}
	out[0] = in[0];
}
void ExpandConfigString( TEXTSTR out, CTEXTSTR in )
{
	// convert \r\n to literal characters...
	if( !in )
	{
		out[0] = 0;
		return;
	}
	for( ; in[0]; in++,out++ )
	{
		if( in[0] == '\n' )
		{
			out[0] = '\\';
			out++;
			out[0] = 'n';
		}
		else if( in[0] == '\\' )
		{
			out[0] = '\\';
			out++;
			out[0] = '\\';
		}
		else if( in[0] == '#' )
		{
			out[0] = '\\';
			out++;
			out[0] = '#';
		}
		else
			out[0] = in[0];
	}
	out[0] = in[0];
}
CTEXTSTR FormatColor( CDATA color )
{
	static TEXTCHAR color_buf[14];
	tnprintf( color_buf, sizeof( color_buf ), WIDE("$%02X%02X%02X%02X")
			, (int)AlphaVal( color )
			, (int)RedVal( color )
			, (int)GreenVal( color )
			, (int)BlueVal( color )
			);
	return color_buf;
}
#ifdef __cplusplus
 //namespace sack { namespace config {
}}
#endif
/*
 *  sha1.h
 *
 *  Description:
 *      This is the header file for code which implements the Secure
 *      Hashing Algorithm 1 as defined in FIPS PUB 180-1 published
 *      April 17, 1995.
 *
 *      Many of the variable names in this code, especially the
 *      single character names, were used because those were the names
 *      used in the publication.
 *
 *      Please read the file sha1.c for more information.
 *
 */
#ifndef _SHA1_H_
#define _SHA1_H_
#ifdef SHA1_SOURCE
#define SHA1_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SHA1_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#if !defined(  HAS_STDINT )
#ifndef __WATCOMC__
	typedef unsigned long uint32_t;
	typedef short int_least16_t;
	typedef unsigned char uint8_t;
#else
#endif
//typedef unsigned char uint8_t;
//typedef int int_least16_t;
#endif
/*
 * If you do not have the ISO standard stdint.h header file, then you
 * must typdef the following:
 *    name              meaning
 *  uint32_t         unsigned 32 bit integer
 *  uint8_t          unsigned 8 bit integer (i.e., unsigned char)
 *  int_least16_t    integer of >= 16 bits
 *
 */
#ifndef _SHA_enum_
#define _SHA_enum_
enum
{
    shaSuccess = 0,
    shaNull,
    shaInputTooLong,
    shaStateError
};
#endif
#define SHA1HashSize 20
/*
 *  This structure will hold context information for the SHA-1
 *  hashing operation
 */
typedef struct SHA1Context
{
    uint32_t Intermediate_Hash[SHA1HashSize/4];
    uint32_t Length_Low;
    uint32_t Length_High;
                               /* Index into message block array   */
    int_least16_t Message_Block_Index;
    uint8_t Message_Block[64];
    int Computed;
    int Corrupted;
} SHA1Context;
/*
 *  Function Prototypes
 */
SHA1_PROC( int, SHA1Reset )(  SHA1Context *);
SHA1_PROC( int, SHA1Input )(  SHA1Context *,
                const uint8_t *,
                size_t);
SHA1_PROC( int, SHA1Result )( SHA1Context *,
                uint8_t Message_Digest[SHA1HashSize]);
#endif
// $Log: $
#ifdef SACK_BAG_EXPORTS
#define SHA2_SOURCE
#endif
/*
 * FIPS 180-2 SHA-224/256/384/512 implementation
 * Last update: 02/02/2007
 * Issue date:  04/30/2005
 *
 * Copyright (C) 2005, 2007 Olivier Gay <olivier.gay@a3.epfl.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#ifndef SHA2_H
#define SHA2_H
#ifdef SHA2_SOURCE
#define SHA2_PROC   EXPORT_METHOD
#else
#define SHA2_PROC   IMPORT_METHOD
#endif
#define SHA224_DIGEST_SIZE ( 224 / 8)
#define SHA256_DIGEST_SIZE ( 256 / 8)
#define SHA384_DIGEST_SIZE ( 384 / 8)
#define SHA512_DIGEST_SIZE ( 512 / 8)
#define SHA256_BLOCK_SIZE  ( 512 / 8)
#define SHA512_BLOCK_SIZE  (1024 / 8)
#define SHA384_BLOCK_SIZE  SHA512_BLOCK_SIZE
#define SHA224_BLOCK_SIZE  SHA256_BLOCK_SIZE
#ifndef SHA2_TYPES
#define SHA2_TYPES
typedef unsigned char uint8;
typedef unsigned int  uint32;
typedef unsigned long long uint64;
#endif
#ifdef __cplusplus
extern "C" {
#endif
typedef struct {
    unsigned int tot_len;
    unsigned int len;
    unsigned char block[2 * SHA256_BLOCK_SIZE];
    uint32 h[8];
}sha256_ctx;
typedef struct {
    unsigned int tot_len;
    unsigned int len;
    unsigned char block[2 * SHA512_BLOCK_SIZE];
    uint64 h[8];
}sha512_ctx;
typedef sha512_ctx sha384_ctx;
typedef sha256_ctx sha224_ctx;
SHA2_PROC void sha224_init(sha224_ctx *ctx);
SHA2_PROC void sha224_update(sha224_ctx *ctx, const unsigned char *message,
                   unsigned int len);
SHA2_PROC void sha224_final(sha224_ctx *ctx, unsigned char *digest);
SHA2_PROC void sha224(const unsigned char *message, unsigned int len,
            unsigned char *digest);
SHA2_PROC void sha256_init(sha256_ctx * ctx);
SHA2_PROC void sha256_update(sha256_ctx *ctx, const unsigned char *message,
                   unsigned int len);
SHA2_PROC void sha256_final(sha256_ctx *ctx, unsigned char *digest);
SHA2_PROC void sha256(const unsigned char *message, unsigned int len,
            unsigned char *digest);
SHA2_PROC void sha384_init(sha384_ctx *ctx);
SHA2_PROC void sha384_update(sha384_ctx *ctx, const unsigned char *message,
                   unsigned int len);
SHA2_PROC void sha384_final(sha384_ctx *ctx, unsigned char *digest);
SHA2_PROC void sha384(const unsigned char *message, unsigned int len,
            unsigned char *digest);
SHA2_PROC void sha512_init(sha512_ctx *ctx);
SHA2_PROC void sha512_update(sha512_ctx *ctx, const unsigned char *message,
                   unsigned int len);
SHA2_PROC void sha512_final(sha512_ctx *ctx, unsigned char *digest);
SHA2_PROC void sha512(const unsigned char *message, unsigned int len,
            unsigned char *digest);
#ifdef __cplusplus
}
#endif
#endif
#ifndef SALTY_RANDOM_GENERATOR_SOURCE
#define SALTY_RANDOM_GENERATOR_SOURCE
#endif
#define MY_MASK_MASK(n,length)	(MASK_TOP_MASK(length) << ((n)&0x7) )
#define MY_GET_MASK(v,n,mask_size)  ( ( ((MASKSET_READTYPE*)((((uintptr_t)v))+(n)/CHAR_BIT))[0]											 & MY_MASK_MASK(n,mask_size) )																										>> (((n))&0x7))
struct random_context {
	LOGICAL use_version2;
	SHA1Context sha1_ctx;
	sha512_ctx  sha512;
	POINTER salt;
	size_t salt_size;
	void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size );
	uintptr_t psv_user;
	uint8_t entropy[SHA1HashSize];
	uint8_t entropy2[SHA512_DIGEST_SIZE];
	size_t bits_used;
	size_t bits_avail;
};
static void NeedBits( struct random_context *ctx )
{
	if( ctx->getsalt )
		ctx->getsalt( ctx->psv_user, &ctx->salt, &ctx->salt_size );
	else
		ctx->salt_size = 0;
	if( ctx->use_version2 )
	{
		if( ctx->salt_size )
			sha512_update( &ctx->sha512, (const uint8_t*)ctx->salt, (unsigned int)ctx->salt_size );
		sha512_final( &ctx->sha512, ctx->entropy2 );
		sha512_init( &ctx->sha512 );
		sha512_update( &ctx->sha512, ctx->entropy2, SHA512_DIGEST_SIZE );
		ctx->bits_avail = sizeof( ctx->entropy2 ) * 8;
	}
	else
	{
		if( ctx->salt_size )
			SHA1Input( &ctx->sha1_ctx, (const uint8_t*)ctx->salt, ctx->salt_size );
		SHA1Result( &ctx->sha1_ctx, ctx->entropy );
		SHA1Reset( &ctx->sha1_ctx );
		SHA1Input( &ctx->sha1_ctx, ctx->entropy, SHA1HashSize );
		ctx->bits_avail = sizeof( ctx->entropy ) * 8;
	}
	ctx->bits_used = 0;
}
struct random_context *SRG_CreateEntropyInternal( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user, LOGICAL version2 )
{
	struct random_context *ctx = New( struct random_context );
	ctx->use_version2 = version2;
	if( ctx->use_version2 )
		sha512_init( &ctx->sha512 );
	else
		SHA1Reset( &ctx->sha1_ctx );
	ctx->getsalt = getsalt;
	ctx->psv_user = psv_user;
	ctx->bits_used = 0;
	ctx->bits_avail = 0;
	return ctx;
}
struct random_context *SRG_CreateEntropy( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user )
{
	return SRG_CreateEntropyInternal( getsalt, psv_user, FALSE );
}
struct random_context *SRG_CreateEntropy2( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user )
{
	return SRG_CreateEntropyInternal( getsalt, psv_user, TRUE );
}
void SRG_DestroyEntropy( struct random_context **ppEntropy )
{
	Release( (*ppEntropy) );
	(*ppEntropy) = NULL;
}
void SRG_GetEntropyBuffer( struct random_context *ctx, uint32_t *buffer, uint32_t bits )
{
	uint32_t tmp;
	uint32_t partial_tmp;
	uint32_t partial_bits = 0;
	uint32_t get_bits;
	uint32_t resultBits = 0;
	do
	{
		if( bits > sizeof( tmp ) * 8 )
			get_bits = sizeof( tmp ) * 8;
		else
			get_bits = bits;
		// if there were 1-31 bits of data in partial, then can only get 32-partial max.
		if( ( 32 - partial_bits ) < get_bits )
			get_bits = 32-partial_bits;
		// check1 :
		//    if get_bits == 32
		//    but bits_used is 1-7, then it would have to pull 5 bytes to get the 32 required
		//    so truncate get_bits to 25-31 bits
		if( ( 32 - ( ctx->bits_used & 0x7 ) ) < get_bits )
			get_bits = ( 32 - ( ctx->bits_used & 0x7 ) );
		// if resultBits is 1-7 offset, then would have to store up to 5 bytes of value
		//    so have to truncate to just the up to 4 bytes that will fit.
		if( get_bits > (32 - resultBits ) )
			get_bits = 32-resultBits;
		// only greater... if equal just grab the bits.
		if( get_bits > ( ctx->bits_avail - ctx->bits_used ) )
		{
			// if there are any bits left, grab the partial bits.
			if( ctx->bits_avail - ctx->bits_used )
			{
				partial_bits = (uint32_t)(ctx->bits_avail - ctx->bits_used);
				// partial can never be greater than 32; input is only max of 32
				//if( partial_bits > (sizeof( partial_tmp ) * 8) )
				//	partial_bits = (sizeof( partial_tmp ) * 8);
				if( ctx->use_version2 )
					partial_tmp = MY_GET_MASK( ctx->entropy2, ctx->bits_used, partial_bits );
				else
					partial_tmp = MY_GET_MASK( ctx->entropy, ctx->bits_used, partial_bits );
			}
			NeedBits( ctx );
			bits -= partial_bits;
		}
		else
		{
			if( ctx->use_version2 )
				tmp = MY_GET_MASK( ctx->entropy2, ctx->bits_used, get_bits );
			else
				tmp = MY_GET_MASK( ctx->entropy, ctx->bits_used, get_bits );
			ctx->bits_used += get_bits;
			if( partial_bits )
			{
				tmp = partial_tmp | ( tmp << partial_bits );
				partial_bits = 0;
			}
			(*buffer) = tmp << resultBits;
			resultBits += get_bits;
			while( resultBits >= 8 ) {
#if defined( __cplusplus ) || defined( __GNUC__ )
				buffer = (uint32_t*)(((uintptr_t)buffer) + 1);
#else
				((intptr_t)buffer)++;
#endif
				resultBits -= 8;
			}
			bits -= get_bits;
		}
	} while( bits );
}
int32_t SRG_GetEntropy( struct random_context *ctx, int bits, int get_signed )
{
	int32_t result;
	SRG_GetEntropyBuffer( ctx, (uint32_t*)&result, bits );
	if( get_signed )
		if( result & ( 1 << ( bits - 1 ) ) )
		{
			uint32_t negone = ~0;
			negone <<= bits;
			return (int32_t)( result | negone );
		}
	return result;
}
void SRG_ResetEntropy( struct random_context *ctx )
{
	if( ctx->use_version2 )
		sha512_init( &ctx->sha512 );
	else
		SHA1Reset( &ctx->sha1_ctx );
	ctx->bits_used = 0;
	ctx->bits_avail = 0;
}
void SRG_SaveState( struct random_context *ctx, POINTER *external_buffer_holder )
{
	if( !(*external_buffer_holder) )
		(*external_buffer_holder) = New( struct random_context );
	MemCpy( (*external_buffer_holder), ctx, sizeof( struct random_context ) );
}
void SRG_RestoreState( struct random_context *ctx, POINTER external_buffer_holder )
{
	MemCpy( ctx, (external_buffer_holder), sizeof( struct random_context ) );
}
static void salt_generator(uintptr_t psv, POINTER *salt, size_t *salt_size ) {
	static uint32_t tick;
	tick = GetTickCount();
	salt[0] = &tick;
	salt_size[0] = sizeof( tick );
}
char *SRG_ID_Generator( void ) {
	static struct random_context *ctx;
	uint32_t buf[2*(16+16)];
	size_t outlen;
	if( !ctx ) ctx = SRG_CreateEntropy2( salt_generator, 0 );
	SRG_GetEntropyBuffer( ctx, buf, 8*(16+16) );
	return EncodeBase64Ex( (uint8*)buf, (16+16), &outlen, (const char *)1 );
}
#ifdef WIN32
#if 0
// if standalone?
BOOL WINAPI DllMain(
	HINSTANCE hinstDLL,
	DWORD fdwReason,
	LPVOID lpvReserved
						 )
{
	return TRUE;
}
#endif
// this is the watcom deadstart entry point.
// by supplying this routine, then the native runtime doesn't get pulled
// and no external clbr symbols are required.
//void __DLLstart( void )
//{
//}
#endif
#ifndef SALTY_RANDOM_GENERATOR_SOURCE
#define SALTY_RANDOM_GENERATOR_SOURCE
#endif
static struct crypt_local
{
	char * use_salt;
	struct random_context *entropy;
} crypt_local;
static void FeedSalt( uintptr_t psv, POINTER *salt, size_t *salt_size )
{
	if( crypt_local.use_salt)
	{
		(*salt) = crypt_local.use_salt;
		(*salt_size) = 4;
	}
	else
	{
		static uint32_t tick;
		tick = timeGetTime();
		(*salt) = &tick;
		(*salt_size) = 4;
	}
}
void SRG_DecryptRawData( CPOINTER binary, size_t length, uint8_t* *buffer, size_t *chars )
{
	if( !crypt_local.entropy )
		crypt_local.entropy = SRG_CreateEntropy( FeedSalt, (uintptr_t)0 );
	{
		uint32_t mask;
		uint8_t* pass_byte_in;
		uint8_t* pass_byte_out;
		int index;
		//if( length < chars )
		{
			SRG_ResetEntropy( crypt_local.entropy );
			crypt_local.use_salt = (char *)binary;
			pass_byte_in = ((uint8_t*)binary) + 4;
			length -= 4;
			(*buffer) = NewArray( uint8_t, length );
			pass_byte_out = (*buffer);
			for( index = 0; length; length--, index++ )
			{
				if( ( index & 3 ) == 0 )
					mask = SRG_GetEntropy( crypt_local.entropy, 32, FALSE );
				pass_byte_out[0] = pass_byte_in[0] ^ ((uint8_t*)&mask)[ index & 0x3 ];
				pass_byte_out++;
				pass_byte_in++;
			}
			(*chars) = pass_byte_out - (*buffer);
		}
	}
}
void SRG_DecryptData( CTEXTSTR local_password, uint8_t* *buffer, size_t *chars )
{
	{
		POINTER binary;
		size_t length;
		if( local_password && DecodeBinaryConfig( local_password, &binary, &length ) )
		{
			SRG_DecryptRawData( (uint8_t*)binary, length, buffer, chars );
		}
		else
		{
			(*buffer) = 0;
			(*chars) = 0;
			//lprintf( WIDE("failed to decode data") );
		}
	}
}
TEXTSTR SRG_DecryptString( CTEXTSTR local_password )
{
	uint8_t* buffer;
	size_t chars;
	SRG_DecryptData( local_password, &buffer, &chars );
	return (TEXTSTR)buffer;
}
void SRG_EncryptRawData( CPOINTER buffer, size_t buflen, uint8_t* *result_buf, size_t *result_size )
{
	if( !crypt_local.entropy )
		crypt_local.entropy = SRG_CreateEntropy( FeedSalt, 0 );
	{
		{
			uint32_t mask;
			uint32_t seed;
			uint8_t* pass_byte_in;
			uint8_t* pass_byte_out;
			int index;
			uint8_t* tmpbuf;
			crypt_local.use_salt = NULL;
			(*result_buf) = tmpbuf = NewArray( uint8_t, buflen + 4 );
			(*result_size) = buflen + 4;
			SRG_ResetEntropy( crypt_local.entropy );
			seed = (uint32_t)GetCPUTick();
			tmpbuf[0] = ((seed >> 17) & 0xFF) ^ ((seed >> 8) & 0xFF);
			tmpbuf[1] = ((seed >> 11) & 0xFF) ^ ((seed >> 4) & 0xFF);
			tmpbuf[2] = ((seed >> 5) & 0xFF) ^ ((seed >> 12) & 0xFF);
			tmpbuf[3] = ((seed >> 0) & 0xFF) ^ ((seed >> 13) & 0xFF);
			crypt_local.use_salt = (char*)tmpbuf;
			SRG_ResetEntropy( crypt_local.entropy );
			pass_byte_in = ((uint8_t*)buffer);
			pass_byte_out = (uint8_t*)tmpbuf + 4;
			for( index = 0; buflen; buflen--, index++ )
			{
				if( ( index & 3 ) == 0 )
					mask = SRG_GetEntropy( crypt_local.entropy, 32, FALSE );
				pass_byte_out[0] = pass_byte_in[0] ^ ((uint8_t*)&mask)[ index & 0x3 ];
				pass_byte_out++;
				pass_byte_in++;
			}
		}
	}
}
TEXTCHAR * SRG_EncryptData( CPOINTER buffer, size_t buflen )
{
	if( !crypt_local.entropy )
		crypt_local.entropy = SRG_CreateEntropy( FeedSalt, 0 );
	{
		uint8_t* result_buf;
		size_t result_size;
		TEXTSTR tmpbuf;
		SRG_EncryptRawData( buffer, buflen, &result_buf, &result_size );
		EncodeBinaryConfig( &tmpbuf, result_buf, buflen + 4 );
		return tmpbuf;
	}
	return NULL;
}
TEXTSTR SRG_EncryptString( CTEXTSTR buffer )
{
	return SRG_EncryptData( (uint8_t*)buffer, StrLen( buffer ) + 1 );
}
/* MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm
 */
/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.
License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.
License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.
RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.
These notices must be retained in any copies of any part of this
documentation and/or software.
 */
#define MD5_SOURCE
/* MD5.H - header file for MD5C.C
 */
/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.
License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.
License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.
RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.
These notices must be retained in any copies of any part of this
documentation and/or software.
 */
#ifndef MD5_ALGORITHM_DEFINED
#define MD5_ALGORITHM_DEFINED
#ifdef MD5_SOURCE
#define MD5_PROC(type,name) EXPORT_METHOD type name
#else
#define MD5_PROC(type,name) IMPORT_METHOD type name
#endif
/* MD5 context. */
typedef struct {
	uint32_t state[4];
	uint32_t count[2];
  unsigned char buffer[64];
} MD5_CTX;
MD5_PROC( void, MD5Init )(MD5_CTX *);
MD5_PROC( void, MD5Update )(MD5_CTX *, unsigned char *, unsigned int);
MD5_PROC( void, MD5Final )(unsigned char [16], MD5_CTX *);
#endif
/* Constants for MD5Transform routine.
 */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21
static void MD5Transform (uint32_t [4], unsigned char [64]);
static void Encode (unsigned char *, uint32_t *, unsigned int);
static void Decode (uint32_t *, unsigned char *, unsigned int);
static void MD5_memcpy (uint8_t*, uint8_t*, unsigned int);
static void MD5_memset (uint8_t*, int, unsigned int);
static unsigned char PADDING[64] = {
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
/* F, G, H and I are basic MD5 functions.
 */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))
/* ROTATE_LEFT rotates x left n bits.
 */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
Rotation is separate from addition to prevent recomputation.
 */
#define FF(a, b, c, d, x, s, ac) {  (a) += F ((b), (c), (d)) + (x) + (uint32_t)(ac);  (a) = ROTATE_LEFT ((a), (s));  (a) += (b);   }
#define GG(a, b, c, d, x, s, ac) {  (a) += G ((b), (c), (d)) + (x) + (uint32_t)(ac);  (a) = ROTATE_LEFT ((a), (s));  (a) += (b);   }
#define HH(a, b, c, d, x, s, ac) {  (a) += H ((b), (c), (d)) + (x) + (uint32_t)(ac);  (a) = ROTATE_LEFT ((a), (s));  (a) += (b);   }
#define II(a, b, c, d, x, s, ac) {  (a) += I ((b), (c), (d)) + (x) + (uint32_t)(ac);  (a) = ROTATE_LEFT ((a), (s));  (a) += (b);   }
/* MD5 initialization. Begins an MD5 operation, writing a new context.
 */
MD5_PROC( void, MD5Init )( MD5_CTX *context )
{
  context->count[0] = context->count[1] = 0;
  /* Load magic initialization constants.
*/
  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
  context->state[3] = 0x10325476;
}
/* MD5 block update operation. Continues an MD5 message-digest
  operation, processing another message block, and updating the
  context.
 */
MD5_PROC( void, MD5Update ) ( MD5_CTX *context
									 , unsigned char *input
									 , unsigned int inputLen)
{
  unsigned int i, index, partLen;
  /* Compute number of bytes mod 64 */
  index = (unsigned int)((context->count[0] >> 3) & 0x3F);
  /* Update number of bits */
  if ((context->count[0] += ((uint32_t)inputLen << 3))
   < ((uint32_t)inputLen << 3))
 context->count[1]++;
  context->count[1] += ((uint32_t)inputLen >> 29);
  partLen = 64 - index;
  /* Transform as many times as possible.
*/
  if (inputLen >= partLen) {
 MD5_memcpy
   ((uint8_t*)&context->buffer[index], (uint8_t*)input, partLen);
 MD5Transform (context->state, context->buffer);
 for (i = partLen; i + 63 < inputLen; i += 64)
   MD5Transform (context->state, &input[i]);
 index = 0;
  }
  else
 i = 0;
  /* Buffer remaining input */
  MD5_memcpy
 ((uint8_t*)&context->buffer[index], (uint8_t*)&input[i],
  inputLen-i);
}
/* MD5 finalization. Ends an MD5 message-digest operation, writing the
  the message digest and zeroizing the context.
 */
MD5_PROC( void, MD5Final )(unsigned char *digest, MD5_CTX *context)
{
  unsigned char bits[8];
  unsigned int index, padLen;
  /* Save number of bits */
  Encode (bits, context->count, 8);
  /* Pad out to 56 mod 64.
*/
  index = (unsigned int)((context->count[0] >> 3) & 0x3f);
  padLen = (index < 56) ? (56 - index) : (120 - index);
  MD5Update (context, PADDING, padLen);
  /* Append length (before padding) */
  MD5Update (context, bits, 8);
  /* Store state in digest */
  Encode (digest, context->state, 16);
  /* Zeroize sensitive information.
*/
  MD5_memset ((uint8_t*)context, 0, sizeof (*context));
}
/* MD5 basic transformation. Transforms state based on block.
 */
static void MD5Transform (uint32_t state[4], unsigned char block[64])
{
  uint32_t a = state[0], b = state[1], c = state[2], d = state[3], x[16];
  Decode (x, block, 64);
  /* Round 1 */
  FF (a, b, c, d, x[ 0], S11, 0xd76aa478);
  FF (d, a, b, c, x[ 1], S12, 0xe8c7b756);
  FF (c, d, a, b, x[ 2], S13, 0x242070db);
  FF (b, c, d, a, x[ 3], S14, 0xc1bdceee);
  FF (a, b, c, d, x[ 4], S11, 0xf57c0faf);
  FF (d, a, b, c, x[ 5], S12, 0x4787c62a);
  FF (c, d, a, b, x[ 6], S13, 0xa8304613);
  FF (b, c, d, a, x[ 7], S14, 0xfd469501);
  FF (a, b, c, d, x[ 8], S11, 0x698098d8);
  FF (d, a, b, c, x[ 9], S12, 0x8b44f7af);
  FF (c, d, a, b, x[10], S13, 0xffff5bb1);
  FF (b, c, d, a, x[11], S14, 0x895cd7be);
  FF (a, b, c, d, x[12], S11, 0x6b901122);
  FF (d, a, b, c, x[13], S12, 0xfd987193);
  FF (c, d, a, b, x[14], S13, 0xa679438e);
  FF (b, c, d, a, x[15], S14, 0x49b40821);
 /* Round 2 */
  GG (a, b, c, d, x[ 1], S21, 0xf61e2562);
  GG (d, a, b, c, x[ 6], S22, 0xc040b340);
  GG (c, d, a, b, x[11], S23, 0x265e5a51);
  GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa);
  GG (a, b, c, d, x[ 5], S21, 0xd62f105d);
  GG (d, a, b, c, x[10], S22,  0x2441453);
  GG (c, d, a, b, x[15], S23, 0xd8a1e681);
  GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8);
  GG (a, b, c, d, x[ 9], S21, 0x21e1cde6);
  GG (d, a, b, c, x[14], S22, 0xc33707d6);
  GG (c, d, a, b, x[ 3], S23, 0xf4d50d87);
  GG (b, c, d, a, x[ 8], S24, 0x455a14ed);
  GG (a, b, c, d, x[13], S21, 0xa9e3e905);
  GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8);
  GG (c, d, a, b, x[ 7], S23, 0x676f02d9);
  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a);
  /* Round 3 */
  HH (a, b, c, d, x[ 5], S31, 0xfffa3942);
  HH (d, a, b, c, x[ 8], S32, 0x8771f681);
  HH (c, d, a, b, x[11], S33, 0x6d9d6122);
  HH (b, c, d, a, x[14], S34, 0xfde5380c);
  HH (a, b, c, d, x[ 1], S31, 0xa4beea44);
  HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9);
  HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60);
  HH (b, c, d, a, x[10], S34, 0xbebfbc70);
  HH (a, b, c, d, x[13], S31, 0x289b7ec6);
  HH (d, a, b, c, x[ 0], S32, 0xeaa127fa);
  HH (c, d, a, b, x[ 3], S33, 0xd4ef3085);
  HH (b, c, d, a, x[ 6], S34,  0x4881d05);
  HH (a, b, c, d, x[ 9], S31, 0xd9d4d039);
  HH (d, a, b, c, x[12], S32, 0xe6db99e5);
  HH (c, d, a, b, x[15], S33, 0x1fa27cf8);
  HH (b, c, d, a, x[ 2], S34, 0xc4ac5665);
  /* Round 4 */
  II (a, b, c, d, x[ 0], S41, 0xf4292244);
  II (d, a, b, c, x[ 7], S42, 0x432aff97);
  II (c, d, a, b, x[14], S43, 0xab9423a7);
  II (b, c, d, a, x[ 5], S44, 0xfc93a039);
  II (a, b, c, d, x[12], S41, 0x655b59c3);
  II (d, a, b, c, x[ 3], S42, 0x8f0ccc92);
  II (c, d, a, b, x[10], S43, 0xffeff47d);
  II (b, c, d, a, x[ 1], S44, 0x85845dd1);
  II (a, b, c, d, x[ 8], S41, 0x6fa87e4f);
  II (d, a, b, c, x[15], S42, 0xfe2ce6e0);
  II (c, d, a, b, x[ 6], S43, 0xa3014314);
  II (b, c, d, a, x[13], S44, 0x4e0811a1);
  II (a, b, c, d, x[ 4], S41, 0xf7537e82);
  II (d, a, b, c, x[11], S42, 0xbd3af235);
  II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb);
  II (b, c, d, a, x[ 9], S44, 0xeb86d391);
  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;
  /* Zeroize sensitive information.
   */
  MD5_memset ((uint8_t*)x, 0, sizeof (x));
}
/* Encodes input (uint32_t) into output (unsigned char). Assumes len is
  a multiple of 4.
 */
static void Encode (unsigned char *output, uint32_t *input, unsigned int len)
{
  unsigned int i, j;
  for (i = 0, j = 0; j < len; i++, j += 4) {
 output[j] = (unsigned char)(input[i] & 0xff);
 output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
 output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
 output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
  }
}
/* Decodes input (unsigned char) into output (uint32_t). Assumes len is
  a multiple of 4.
 */
static void Decode (uint32_t *output, unsigned char *input, unsigned int len)
{
  unsigned int i, j;
  for (i = 0, j = 0; j < len; i++, j += 4)
 output[i] = ((uint32_t)input[j]) | (((uint32_t)input[j+1]) << 8) |
   (((uint32_t)input[j+2]) << 16) | (((uint32_t)input[j+3]) << 24);
}
/* Note: Replace "for loop" with standard memcpy if possible.
 */
static void MD5_memcpy (uint8_t* output, uint8_t* input, unsigned int len)
{
  unsigned int i;
  for (i = 0; i < len; i++)
    output[i] = input[i];
}
/* Note: Replace "for loop" with standard memset if possible.
 */
static void MD5_memset (uint8_t* output, int value, unsigned int len)
{
  unsigned int i;
  for (i = 0; i < len; i++)
 ((char *)output)[i] = (char)value;
}
/*
 *  sha1.c
 *
 *  Description:
 *      This file implements the Secure Hashing Algorithm 1 as
 *      defined in FIPS PUB 180-1 published April 17, 1995.
 *
 *      The SHA-1, produces a 160-bit message digest for a given
 *      data stream.  It should take about 2**n steps to find a
 *      message with the same digest as a given message and
 *      2**(n/2) to find any two messages with the same digest,
 *      when n is the digest size in bits.  Therefore, this
 *      algorithm can serve as a means of providing a
 *      "fingerprint" for a message.
 *
 *  Portability Issues:
 *      SHA-1 is defined in terms of 32-bit "words".  This code
 *      uses <stdint.h> (included via "sha1.h" to define 32 and 8
 *      bit unsigned integer types.  If your C compiler does not
 *      support 32 bit unsigned integers, this code is not
 *      appropriate.
 *
 *  Caveats:
 *      SHA-1 is designed to work with messages less than 2^64 bits
 *      long.  Although SHA-1 allows a message digest to be generated
 *      for messages of any number of bits less than 2^64, this
 *      implementation only works with messages with a length that is
 *      a multiple of the size of an 8-bit character.
 *
 */
/*
 *  sha1.h
 *
 *  Description:
 *      This is the header file for code which implements the Secure
 *      Hashing Algorithm 1 as defined in FIPS PUB 180-1 published
 *      April 17, 1995.
 *
 *      Many of the variable names in this code, especially the
 *      single character names, were used because those were the names
 *      used in the publication.
 *
 *      Please read the file sha1.c for more information.
 *
 */
#ifndef _SHA1_H_
#define _SHA1_H_
#ifdef SHA1_SOURCE
#define SHA1_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SHA1_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#if !defined(  HAS_STDINT )
#ifndef __WATCOMC__
	typedef unsigned long uint32_t;
	typedef short int_least16_t;
	typedef unsigned char uint8_t;
#else
#endif
//typedef unsigned char uint8_t;
//typedef int int_least16_t;
#endif
/*
 * If you do not have the ISO standard stdint.h header file, then you
 * must typdef the following:
 *    name              meaning
 *  uint32_t         unsigned 32 bit integer
 *  uint8_t          unsigned 8 bit integer (i.e., unsigned char)
 *  int_least16_t    integer of >= 16 bits
 *
 */
#ifndef _SHA_enum_
#define _SHA_enum_
enum
{
    shaSuccess = 0,
    shaNull,
    shaInputTooLong,
    shaStateError
};
#endif
#define SHA1HashSize 20
/*
 *  This structure will hold context information for the SHA-1
 *  hashing operation
 */
typedef struct SHA1Context
{
    uint32_t Intermediate_Hash[SHA1HashSize/4];
    uint32_t Length_Low;
    uint32_t Length_High;
                               /* Index into message block array   */
    int_least16_t Message_Block_Index;
    uint8_t Message_Block[64];
    int Computed;
    int Corrupted;
} SHA1Context;
/*
 *  Function Prototypes
 */
SHA1_PROC( int, SHA1Reset )(  SHA1Context *);
SHA1_PROC( int, SHA1Input )(  SHA1Context *,
                const uint8_t *,
                size_t);
SHA1_PROC( int, SHA1Result )( SHA1Context *,
                uint8_t Message_Digest[SHA1HashSize]);
#endif
// $Log: $
#ifndef SHA1HashSize
#define SHA1Context SHA1_CTX
#endif
/*
 *  Define the SHA1 circular left shift macro
 */
#define SHA1CircularShift(bits,word)                 (((word) << (bits)) | ((word) >> (32-(bits))))
/* Local Function Prototyptes */
void SHA1PadMessage(SHA1Context *);
void SHA1ProcessMessageBlock(SHA1Context *);
/*
 *  SHA1Reset
 *
 *  Description:
 *      This function will initialize the SHA1Context in preparation
 *      for computing a new SHA1 message digest.
 *
 *  Parameters:
 *      context: [in/out]
 *          The context to reset.
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int SHA1Reset(SHA1Context *context)
{
    if (!context)
    {
        return shaNull;
    }
    context->Length_Low             = 0;
    context->Length_High            = 0;
    context->Message_Block_Index    = 0;
    context->Intermediate_Hash[0]   = 0x67452301;
    context->Intermediate_Hash[1]   = 0xEFCDAB89;
    context->Intermediate_Hash[2]   = 0x98BADCFE;
    context->Intermediate_Hash[3]   = 0x10325476;
    context->Intermediate_Hash[4]   = 0xC3D2E1F0;
    context->Computed   = 0;
    context->Corrupted  = 0;
    return shaSuccess;
}
/*
 *  SHA1Result
 *
 *  Description:
 *      This function will return the 160-bit message digest into the
 *      Message_Digest array  provided by the caller.
 *      NOTE: The first octet of hash is stored in the 0th element,
 *            the last octet of hash in the 19th element.
 *
 *  Parameters:
 *      context: [in/out]
 *          The context to use to calculate the SHA-1 hash.
 *      Message_Digest: [out]
 *          Where the digest is returned.
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int SHA1Result( SHA1Context *context,
                uint8_t Message_Digest[SHA1HashSize])
{
    int i;
    if (!context || !Message_Digest)
    {
        return shaNull;
    }
    if (context->Corrupted)
    {
        return context->Corrupted;
    }
    if (!context->Computed)
    {
        SHA1PadMessage(context);
        for(i=0; i<64; ++i)
        {
            /* message may be sensitive, clear it out */
            context->Message_Block[i] = 0;
        }
        context->Length_Low = 0;
        context->Length_High = 0;
        context->Computed = 1;
    }
    for(i = 0; i < SHA1HashSize; ++i)
    {
        Message_Digest[i] = (uint8_t)(context->Intermediate_Hash[i>>2]
                            >> 8 * ( 3 - ( i & 0x03 ) ));
    }
    return shaSuccess;
}
/*
 *  SHA1Input
 *
 *  Description:
 *      This function accepts an array of octets as the next portion
 *      of the message.
 *
 *  Parameters:
 *      context: [in/out]
 *          The SHA context to update
 *      message_array: [in]
 *          An array of characters representing the next portion of
 *          the message.
 *      length: [in]
 *          The length of the message in message_array
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int SHA1Input(    SHA1Context    *context,
                  const uint8_t  *message_array,
                  size_t       length)
{
    if (!length)
    {
        return shaSuccess;
    }
    if (!context || !message_array)
    {
        return shaNull;
    }
    if (context->Computed)
    {
        context->Corrupted = shaStateError;
        return shaStateError;
    }
    if (context->Corrupted)
    {
         return context->Corrupted;
    }
    while(length-- && !context->Corrupted)
    {
    context->Message_Block[context->Message_Block_Index++] =
                    (*message_array & 0xFF);
    context->Length_Low += 8;
    if (context->Length_Low == 0)
    {
        context->Length_High++;
        if (context->Length_High == 0)
        {
            /* Message is too long */
            context->Corrupted = 1;
        }
    }
    if (context->Message_Block_Index == 64)
    {
        SHA1ProcessMessageBlock(context);
    }
    message_array++;
    }
    return shaSuccess;
}
/*
 *  SHA1ProcessMessageBlock
 *
 *  Description:
 *      This function will process the next 512 bits of the message
 *      stored in the Message_Block array.
 *
 *  Parameters:
 *      None.
 *
 *  Returns:
 *      Nothing.
 *
 *  Comments:
 *      Many of the variable names in this code, especially the
 *      single character names, were used because those were the
 *      names used in the publication.
 *
 *
 */
void SHA1ProcessMessageBlock(SHA1Context *context)
{
    const uint32_t K[] =    {
                            0x5A827999,
                            0x6ED9EBA1,
                            0x8F1BBCDC,
                            0xCA62C1D6
                            };
    int           t;
    uint32_t      temp;
    uint32_t      W[80];
    uint32_t      A, B, C, D, E;
    /*
     *  Initialize the first 16 words in the array W
     */
    for(t = 0; t < 16; t++)
    {
        W[t] = context->Message_Block[t * 4] << 24;
        W[t] |= context->Message_Block[t * 4 + 1] << 16;
        W[t] |= context->Message_Block[t * 4 + 2] << 8;
        W[t] |= context->Message_Block[t * 4 + 3];
    }
    for(t = 16; t < 80; t++)
    {
       W[t] = SHA1CircularShift(1,W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16]);
    }
    A = context->Intermediate_Hash[0];
    B = context->Intermediate_Hash[1];
    C = context->Intermediate_Hash[2];
    D = context->Intermediate_Hash[3];
    E = context->Intermediate_Hash[4];
    for(t = 0; t < 20; t++)
    {
        temp =  SHA1CircularShift(5,A) +
                ((B & C) | ((~B) & D)) + E + W[t] + K[0];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }
    for(t = 20; t < 40; t++)
    {
        temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[1];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }
    for(t = 40; t < 60; t++)
    {
        temp = SHA1CircularShift(5,A) +
               ((B & C) | (B & D) | (C & D)) + E + W[t] + K[2];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }
    for(t = 60; t < 80; t++)
    {
        temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[3];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }
    context->Intermediate_Hash[0] += A;
    context->Intermediate_Hash[1] += B;
    context->Intermediate_Hash[2] += C;
    context->Intermediate_Hash[3] += D;
    context->Intermediate_Hash[4] += E;
    context->Message_Block_Index = 0;
}
/*
 *  SHA1PadMessage
 *
 *  Description:
 *      According to the standard, the message must be padded to an even
 *      512 bits.  The first padding bit must be a '1'.  The last 64
 *      bits represent the length of the original message.  All bits in
 *      between should be 0.  This function will pad the message
 *      according to those rules by filling the Message_Block array
 *      accordingly.  It will also call the ProcessMessageBlock function
 *      provided appropriately.  When it returns, it can be assumed that
 *      the message digest has been computed.
 *
 *  Parameters:
 *      context: [in/out]
 *          The context to pad
 *      ProcessMessageBlock: [in]
 *          The appropriate SHA*ProcessMessageBlock function
 *  Returns:
 *      Nothing.
 *
 */
void SHA1PadMessage(SHA1Context *context)
{
    /*
     *  Check to see if the current message block is too small to hold
     *  the initial padding bits and length.  If so, we will pad the
     *  block, process it, and then continue padding into a second
     *  block.
     */
    if (context->Message_Block_Index > 55)
    {
        context->Message_Block[context->Message_Block_Index++] = 0x80;
        while(context->Message_Block_Index < 64)
        {
            context->Message_Block[context->Message_Block_Index++] = 0;
        }
        SHA1ProcessMessageBlock(context);
        while(context->Message_Block_Index < 56)
        {
            context->Message_Block[context->Message_Block_Index++] = 0;
        }
    }
    else
    {
        context->Message_Block[context->Message_Block_Index++] = 0x80;
        while(context->Message_Block_Index < 56)
        {
            context->Message_Block[context->Message_Block_Index++] = 0;
        }
    }
    /*
     *  Store the message length as the last 8 octets
     */
    context->Message_Block[56] = (uint8_t)(context->Length_High >> 24);
    context->Message_Block[57] = (uint8_t)(context->Length_High >> 16);
    context->Message_Block[58] = (uint8_t)(context->Length_High >> 8);
    context->Message_Block[59] = (uint8_t)(context->Length_High);
    context->Message_Block[60] = (uint8_t)(context->Length_Low >> 24);
    context->Message_Block[61] = (uint8_t)(context->Length_Low >> 16);
    context->Message_Block[62] = (uint8_t)(context->Length_Low >> 8);
    context->Message_Block[63] = (uint8_t)(context->Length_Low);
    SHA1ProcessMessageBlock(context);
}
// $Log: sha1.c,v $
// Revision 1.5  2003/05/13 09:14:08  panther
// Remove carriage returns
//
// Revision 1.4  2003/03/25 08:45:57  panther
// Added CVS logging tag
//
/*
 * FIPS 180-2 SHA-224/256/384/512 implementation
 * Last update: 02/02/2007
 * Issue date:  04/30/2005
 *
 * Copyright (C) 2005, 2007 Olivier Gay <olivier.gay@a3.epfl.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#if 0
#define UNROLL_LOOPS
#endif
#define SHA2_SOURCE
#define SHFR(x, n)    (x >> n)
#define ROTR(x, n)   ((x >> n) | (x << ((sizeof(x) << 3) - n)))
#define ROTL(x, n)   ((x << n) | (x >> ((sizeof(x) << 3) - n)))
#define CH(x, y, z)  ((x & y) ^ (~x & z))
#define MAJ(x, y, z) ((x & y) ^ (x & z) ^ (y & z))
#define SHA256_F1(x) (ROTR(x,  2) ^ ROTR(x, 13) ^ ROTR(x, 22))
#define SHA256_F2(x) (ROTR(x,  6) ^ ROTR(x, 11) ^ ROTR(x, 25))
#define SHA256_F3(x) (ROTR(x,  7) ^ ROTR(x, 18) ^ SHFR(x,  3))
#define SHA256_F4(x) (ROTR(x, 17) ^ ROTR(x, 19) ^ SHFR(x, 10))
#define SHA512_F1(x) (ROTR(x, 28) ^ ROTR(x, 34) ^ ROTR(x, 39))
#define SHA512_F2(x) (ROTR(x, 14) ^ ROTR(x, 18) ^ ROTR(x, 41))
#define SHA512_F3(x) (ROTR(x,  1) ^ ROTR(x,  8) ^ SHFR(x,  7))
#define SHA512_F4(x) (ROTR(x, 19) ^ ROTR(x, 61) ^ SHFR(x,  6))
#define UNPACK32(x, str)                      {                                                 *((str) + 3) = (uint8) ((x)      );           *((str) + 2) = (uint8) ((x) >>  8);           *((str) + 1) = (uint8) ((x) >> 16);           *((str) + 0) = (uint8) ((x) >> 24);       }
#define PACK32(str, x)                        {                                                 *(x) =   ((uint32) *((str) + 3)      )               | ((uint32) *((str) + 2) <<  8)               | ((uint32) *((str) + 1) << 16)               | ((uint32) *((str) + 0) << 24);   }
#define UNPACK64(x, str)                      {                                                 *((str) + 7) = (uint8) ((x)      );           *((str) + 6) = (uint8) ((x) >>  8);           *((str) + 5) = (uint8) ((x) >> 16);           *((str) + 4) = (uint8) ((x) >> 24);           *((str) + 3) = (uint8) ((x) >> 32);           *((str) + 2) = (uint8) ((x) >> 40);           *((str) + 1) = (uint8) ((x) >> 48);           *((str) + 0) = (uint8) ((x) >> 56);       }
#define PACK64(str, x)                        {                                                 *(x) =   ((uint64) *((str) + 7)      )               | ((uint64) *((str) + 6) <<  8)               | ((uint64) *((str) + 5) << 16)               | ((uint64) *((str) + 4) << 24)               | ((uint64) *((str) + 3) << 32)               | ((uint64) *((str) + 2) << 40)               | ((uint64) *((str) + 1) << 48)               | ((uint64) *((str) + 0) << 56);   }
/* Macros used for loops unrolling */
#define SHA256_SCR(i)                         {                                                 w[i] =  SHA256_F4(w[i -  2]) + w[i -  7]            + SHA256_F3(w[i - 15]) + w[i - 16]; }
#define SHA512_SCR(i)                         {                                                 w[i] =  SHA512_F4(w[i -  2]) + w[i -  7]            + SHA512_F3(w[i - 15]) + w[i - 16]; }
#define SHA256_EXP(a, b, c, d, e, f, g, h, j)               {                                                               t1 = wv[h] + SHA256_F2(wv[e]) + CH(wv[e], wv[f], wv[g])          + sha256_k[j] + w[j];                                  t2 = SHA256_F1(wv[a]) + MAJ(wv[a], wv[b], wv[c]);           wv[d] += t1;                                                wv[h] = t1 + t2;                                        }
#define SHA512_EXP(a, b, c, d, e, f, g ,h, j)               {                                                               t1 = wv[h] + SHA512_F2(wv[e]) + CH(wv[e], wv[f], wv[g])          + sha512_k[j] + w[j];                                  t2 = SHA512_F1(wv[a]) + MAJ(wv[a], wv[b], wv[c]);           wv[d] += t1;                                                wv[h] = t1 + t2;                                        }
static uint32 sha224_h0[8] =
            {0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
             0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4};
static uint32 sha256_h0[8] =
            {0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
             0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};
static uint64 sha384_h0[8] =
            {0xcbbb9d5dc1059ed8ULL, 0x629a292a367cd507ULL,
             0x9159015a3070dd17ULL, 0x152fecd8f70e5939ULL,
             0x67332667ffc00b31ULL, 0x8eb44a8768581511ULL,
             0xdb0c2e0d64f98fa7ULL, 0x47b5481dbefa4fa4ULL};
static uint64 sha512_h0[8] =
            {0x6a09e667f3bcc908ULL, 0xbb67ae8584caa73bULL,
             0x3c6ef372fe94f82bULL, 0xa54ff53a5f1d36f1ULL,
             0x510e527fade682d1ULL, 0x9b05688c2b3e6c1fULL,
             0x1f83d9abfb41bd6bULL, 0x5be0cd19137e2179ULL};
static uint32 sha256_k[64] =
            {0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
             0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
             0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
             0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
             0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
             0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
             0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
             0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
             0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
             0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
             0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
             0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
             0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
             0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
             0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
             0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};
static uint64 sha512_k[80] =
            {0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL,
             0xb5c0fbcfec4d3b2fULL, 0xe9b5dba58189dbbcULL,
             0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL,
             0x923f82a4af194f9bULL, 0xab1c5ed5da6d8118ULL,
             0xd807aa98a3030242ULL, 0x12835b0145706fbeULL,
             0x243185be4ee4b28cULL, 0x550c7dc3d5ffb4e2ULL,
             0x72be5d74f27b896fULL, 0x80deb1fe3b1696b1ULL,
             0x9bdc06a725c71235ULL, 0xc19bf174cf692694ULL,
             0xe49b69c19ef14ad2ULL, 0xefbe4786384f25e3ULL,
             0x0fc19dc68b8cd5b5ULL, 0x240ca1cc77ac9c65ULL,
             0x2de92c6f592b0275ULL, 0x4a7484aa6ea6e483ULL,
             0x5cb0a9dcbd41fbd4ULL, 0x76f988da831153b5ULL,
             0x983e5152ee66dfabULL, 0xa831c66d2db43210ULL,
             0xb00327c898fb213fULL, 0xbf597fc7beef0ee4ULL,
             0xc6e00bf33da88fc2ULL, 0xd5a79147930aa725ULL,
             0x06ca6351e003826fULL, 0x142929670a0e6e70ULL,
             0x27b70a8546d22ffcULL, 0x2e1b21385c26c926ULL,
             0x4d2c6dfc5ac42aedULL, 0x53380d139d95b3dfULL,
             0x650a73548baf63deULL, 0x766a0abb3c77b2a8ULL,
             0x81c2c92e47edaee6ULL, 0x92722c851482353bULL,
             0xa2bfe8a14cf10364ULL, 0xa81a664bbc423001ULL,
             0xc24b8b70d0f89791ULL, 0xc76c51a30654be30ULL,
             0xd192e819d6ef5218ULL, 0xd69906245565a910ULL,
             0xf40e35855771202aULL, 0x106aa07032bbd1b8ULL,
             0x19a4c116b8d2d0c8ULL, 0x1e376c085141ab53ULL,
             0x2748774cdf8eeb99ULL, 0x34b0bcb5e19b48a8ULL,
             0x391c0cb3c5c95a63ULL, 0x4ed8aa4ae3418acbULL,
             0x5b9cca4f7763e373ULL, 0x682e6ff3d6b2b8a3ULL,
             0x748f82ee5defb2fcULL, 0x78a5636f43172f60ULL,
             0x84c87814a1f0ab72ULL, 0x8cc702081a6439ecULL,
             0x90befffa23631e28ULL, 0xa4506cebde82bde9ULL,
             0xbef9a3f7b2c67915ULL, 0xc67178f2e372532bULL,
             0xca273eceea26619cULL, 0xd186b8c721c0c207ULL,
             0xeada7dd6cde0eb1eULL, 0xf57d4f7fee6ed178ULL,
             0x06f067aa72176fbaULL, 0x0a637dc5a2c898a6ULL,
             0x113f9804bef90daeULL, 0x1b710b35131c471bULL,
             0x28db77f523047d84ULL, 0x32caab7b40c72493ULL,
             0x3c9ebe0a15c9bebcULL, 0x431d67c49c100d4cULL,
             0x4cc5d4becb3e42b6ULL, 0x597f299cfc657e2aULL,
             0x5fcb6fab3ad6faecULL, 0x6c44198c4a475817ULL};
/* SHA-256 functions */
void sha256_transf(sha256_ctx *ctx, const unsigned char *message,
                   unsigned int block_nb)
{
    uint32 w[64];
    uint32 wv[8];
    uint32 t1, t2;
    const unsigned char *sub_block;
    int i;
#ifndef UNROLL_LOOPS
    int j;
#endif
    for (i = 0; i < (int) block_nb; i++) {
        sub_block = message + (i << 6);
#ifndef UNROLL_LOOPS
        for (j = 0; j < 16; j++) {
            PACK32(&sub_block[j << 2], &w[j]);
        }
        for (j = 16; j < 64; j++) {
            SHA256_SCR(j);
        }
        for (j = 0; j < 8; j++) {
            wv[j] = ctx->h[j];
        }
        for (j = 0; j < 64; j++) {
            t1 = wv[7] + SHA256_F2(wv[4]) + CH(wv[4], wv[5], wv[6])
                + sha256_k[j] + w[j];
            t2 = SHA256_F1(wv[0]) + MAJ(wv[0], wv[1], wv[2]);
            wv[7] = wv[6];
            wv[6] = wv[5];
            wv[5] = wv[4];
            wv[4] = wv[3] + t1;
            wv[3] = wv[2];
            wv[2] = wv[1];
            wv[1] = wv[0];
            wv[0] = t1 + t2;
        }
        for (j = 0; j < 8; j++) {
            ctx->h[j] += wv[j];
        }
#else
        PACK32(&sub_block[ 0], &w[ 0]); PACK32(&sub_block[ 4], &w[ 1]);
        PACK32(&sub_block[ 8], &w[ 2]); PACK32(&sub_block[12], &w[ 3]);
        PACK32(&sub_block[16], &w[ 4]); PACK32(&sub_block[20], &w[ 5]);
        PACK32(&sub_block[24], &w[ 6]); PACK32(&sub_block[28], &w[ 7]);
        PACK32(&sub_block[32], &w[ 8]); PACK32(&sub_block[36], &w[ 9]);
        PACK32(&sub_block[40], &w[10]); PACK32(&sub_block[44], &w[11]);
        PACK32(&sub_block[48], &w[12]); PACK32(&sub_block[52], &w[13]);
        PACK32(&sub_block[56], &w[14]); PACK32(&sub_block[60], &w[15]);
        SHA256_SCR(16); SHA256_SCR(17); SHA256_SCR(18); SHA256_SCR(19);
        SHA256_SCR(20); SHA256_SCR(21); SHA256_SCR(22); SHA256_SCR(23);
        SHA256_SCR(24); SHA256_SCR(25); SHA256_SCR(26); SHA256_SCR(27);
        SHA256_SCR(28); SHA256_SCR(29); SHA256_SCR(30); SHA256_SCR(31);
        SHA256_SCR(32); SHA256_SCR(33); SHA256_SCR(34); SHA256_SCR(35);
        SHA256_SCR(36); SHA256_SCR(37); SHA256_SCR(38); SHA256_SCR(39);
        SHA256_SCR(40); SHA256_SCR(41); SHA256_SCR(42); SHA256_SCR(43);
        SHA256_SCR(44); SHA256_SCR(45); SHA256_SCR(46); SHA256_SCR(47);
        SHA256_SCR(48); SHA256_SCR(49); SHA256_SCR(50); SHA256_SCR(51);
        SHA256_SCR(52); SHA256_SCR(53); SHA256_SCR(54); SHA256_SCR(55);
        SHA256_SCR(56); SHA256_SCR(57); SHA256_SCR(58); SHA256_SCR(59);
        SHA256_SCR(60); SHA256_SCR(61); SHA256_SCR(62); SHA256_SCR(63);
        wv[0] = ctx->h[0]; wv[1] = ctx->h[1];
        wv[2] = ctx->h[2]; wv[3] = ctx->h[3];
        wv[4] = ctx->h[4]; wv[5] = ctx->h[5];
        wv[6] = ctx->h[6]; wv[7] = ctx->h[7];
        SHA256_EXP(0,1,2,3,4,5,6,7, 0); SHA256_EXP(7,0,1,2,3,4,5,6, 1);
        SHA256_EXP(6,7,0,1,2,3,4,5, 2); SHA256_EXP(5,6,7,0,1,2,3,4, 3);
        SHA256_EXP(4,5,6,7,0,1,2,3, 4); SHA256_EXP(3,4,5,6,7,0,1,2, 5);
        SHA256_EXP(2,3,4,5,6,7,0,1, 6); SHA256_EXP(1,2,3,4,5,6,7,0, 7);
        SHA256_EXP(0,1,2,3,4,5,6,7, 8); SHA256_EXP(7,0,1,2,3,4,5,6, 9);
        SHA256_EXP(6,7,0,1,2,3,4,5,10); SHA256_EXP(5,6,7,0,1,2,3,4,11);
        SHA256_EXP(4,5,6,7,0,1,2,3,12); SHA256_EXP(3,4,5,6,7,0,1,2,13);
        SHA256_EXP(2,3,4,5,6,7,0,1,14); SHA256_EXP(1,2,3,4,5,6,7,0,15);
        SHA256_EXP(0,1,2,3,4,5,6,7,16); SHA256_EXP(7,0,1,2,3,4,5,6,17);
        SHA256_EXP(6,7,0,1,2,3,4,5,18); SHA256_EXP(5,6,7,0,1,2,3,4,19);
        SHA256_EXP(4,5,6,7,0,1,2,3,20); SHA256_EXP(3,4,5,6,7,0,1,2,21);
        SHA256_EXP(2,3,4,5,6,7,0,1,22); SHA256_EXP(1,2,3,4,5,6,7,0,23);
        SHA256_EXP(0,1,2,3,4,5,6,7,24); SHA256_EXP(7,0,1,2,3,4,5,6,25);
        SHA256_EXP(6,7,0,1,2,3,4,5,26); SHA256_EXP(5,6,7,0,1,2,3,4,27);
        SHA256_EXP(4,5,6,7,0,1,2,3,28); SHA256_EXP(3,4,5,6,7,0,1,2,29);
        SHA256_EXP(2,3,4,5,6,7,0,1,30); SHA256_EXP(1,2,3,4,5,6,7,0,31);
        SHA256_EXP(0,1,2,3,4,5,6,7,32); SHA256_EXP(7,0,1,2,3,4,5,6,33);
        SHA256_EXP(6,7,0,1,2,3,4,5,34); SHA256_EXP(5,6,7,0,1,2,3,4,35);
        SHA256_EXP(4,5,6,7,0,1,2,3,36); SHA256_EXP(3,4,5,6,7,0,1,2,37);
        SHA256_EXP(2,3,4,5,6,7,0,1,38); SHA256_EXP(1,2,3,4,5,6,7,0,39);
        SHA256_EXP(0,1,2,3,4,5,6,7,40); SHA256_EXP(7,0,1,2,3,4,5,6,41);
        SHA256_EXP(6,7,0,1,2,3,4,5,42); SHA256_EXP(5,6,7,0,1,2,3,4,43);
        SHA256_EXP(4,5,6,7,0,1,2,3,44); SHA256_EXP(3,4,5,6,7,0,1,2,45);
        SHA256_EXP(2,3,4,5,6,7,0,1,46); SHA256_EXP(1,2,3,4,5,6,7,0,47);
        SHA256_EXP(0,1,2,3,4,5,6,7,48); SHA256_EXP(7,0,1,2,3,4,5,6,49);
        SHA256_EXP(6,7,0,1,2,3,4,5,50); SHA256_EXP(5,6,7,0,1,2,3,4,51);
        SHA256_EXP(4,5,6,7,0,1,2,3,52); SHA256_EXP(3,4,5,6,7,0,1,2,53);
        SHA256_EXP(2,3,4,5,6,7,0,1,54); SHA256_EXP(1,2,3,4,5,6,7,0,55);
        SHA256_EXP(0,1,2,3,4,5,6,7,56); SHA256_EXP(7,0,1,2,3,4,5,6,57);
        SHA256_EXP(6,7,0,1,2,3,4,5,58); SHA256_EXP(5,6,7,0,1,2,3,4,59);
        SHA256_EXP(4,5,6,7,0,1,2,3,60); SHA256_EXP(3,4,5,6,7,0,1,2,61);
        SHA256_EXP(2,3,4,5,6,7,0,1,62); SHA256_EXP(1,2,3,4,5,6,7,0,63);
        ctx->h[0] += wv[0]; ctx->h[1] += wv[1];
        ctx->h[2] += wv[2]; ctx->h[3] += wv[3];
        ctx->h[4] += wv[4]; ctx->h[5] += wv[5];
        ctx->h[6] += wv[6]; ctx->h[7] += wv[7];
#endif
    }
}
void sha256(const unsigned char *message, unsigned int len, unsigned char *digest)
{
    sha256_ctx ctx;
    sha256_init(&ctx);
    sha256_update(&ctx, message, len);
    sha256_final(&ctx, digest);
}
void sha256_init(sha256_ctx *ctx)
{
#ifndef UNROLL_LOOPS
    int i;
    for (i = 0; i < 8; i++) {
        ctx->h[i] = sha256_h0[i];
    }
#else
    ctx->h[0] = sha256_h0[0]; ctx->h[1] = sha256_h0[1];
    ctx->h[2] = sha256_h0[2]; ctx->h[3] = sha256_h0[3];
    ctx->h[4] = sha256_h0[4]; ctx->h[5] = sha256_h0[5];
    ctx->h[6] = sha256_h0[6]; ctx->h[7] = sha256_h0[7];
#endif
    ctx->len = 0;
    ctx->tot_len = 0;
}
void sha256_update(sha256_ctx *ctx, const unsigned char *message,
                   unsigned int len)
{
    unsigned int block_nb;
    unsigned int new_len, rem_len, tmp_len;
    const unsigned char *shifted_message;
    tmp_len = SHA256_BLOCK_SIZE - ctx->len;
    rem_len = len < tmp_len ? len : tmp_len;
    memcpy(&ctx->block[ctx->len], message, rem_len);
    if (ctx->len + len < SHA256_BLOCK_SIZE) {
        ctx->len += len;
        return;
    }
    new_len = len - rem_len;
    block_nb = new_len / SHA256_BLOCK_SIZE;
    shifted_message = message + rem_len;
    sha256_transf(ctx, ctx->block, 1);
    sha256_transf(ctx, shifted_message, block_nb);
    rem_len = new_len % SHA256_BLOCK_SIZE;
    memcpy(ctx->block, &shifted_message[block_nb << 6],
           rem_len);
    ctx->len = rem_len;
    ctx->tot_len += (block_nb + 1) << 6;
}
void sha256_final(sha256_ctx *ctx, unsigned char *digest)
{
    unsigned int block_nb;
    unsigned int pm_len;
    unsigned int len_b;
#ifndef UNROLL_LOOPS
    int i;
#endif
    block_nb = (1 + ((SHA256_BLOCK_SIZE - 9)
                     < (ctx->len % SHA256_BLOCK_SIZE)));
    len_b = (ctx->tot_len + ctx->len) << 3;
    pm_len = block_nb << 6;
    memset(ctx->block + ctx->len, 0, pm_len - ctx->len);
    ctx->block[ctx->len] = 0x80;
    UNPACK32(len_b, ctx->block + pm_len - 4);
    sha256_transf(ctx, ctx->block, block_nb);
#ifndef UNROLL_LOOPS
    for (i = 0 ; i < 8; i++) {
        UNPACK32(ctx->h[i], &digest[i << 2]);
    }
#else
   UNPACK32(ctx->h[0], &digest[ 0]);
   UNPACK32(ctx->h[1], &digest[ 4]);
   UNPACK32(ctx->h[2], &digest[ 8]);
   UNPACK32(ctx->h[3], &digest[12]);
   UNPACK32(ctx->h[4], &digest[16]);
   UNPACK32(ctx->h[5], &digest[20]);
   UNPACK32(ctx->h[6], &digest[24]);
   UNPACK32(ctx->h[7], &digest[28]);
#endif
}
/* SHA-512 functions */
void sha512_transf(sha512_ctx *ctx, const unsigned char *message,
                   unsigned int block_nb)
{
    uint64 w[80];
    uint64 wv[8];
    uint64 t1, t2;
    const unsigned char *sub_block;
    int i, j;
    for (i = 0; i < (int) block_nb; i++) {
        sub_block = message + (i << 7);
#ifndef UNROLL_LOOPS
        for (j = 0; j < 16; j++) {
            PACK64(&sub_block[j << 3], &w[j]);
        }
        for (j = 16; j < 80; j++) {
            SHA512_SCR(j);
        }
        for (j = 0; j < 8; j++) {
            wv[j] = ctx->h[j];
        }
        for (j = 0; j < 80; j++) {
            t1 = wv[7] + SHA512_F2(wv[4]) + CH(wv[4], wv[5], wv[6])
                + sha512_k[j] + w[j];
            t2 = SHA512_F1(wv[0]) + MAJ(wv[0], wv[1], wv[2]);
            wv[7] = wv[6];
            wv[6] = wv[5];
            wv[5] = wv[4];
            wv[4] = wv[3] + t1;
            wv[3] = wv[2];
            wv[2] = wv[1];
            wv[1] = wv[0];
            wv[0] = t1 + t2;
        }
        for (j = 0; j < 8; j++) {
            ctx->h[j] += wv[j];
        }
#else
        PACK64(&sub_block[  0], &w[ 0]); PACK64(&sub_block[  8], &w[ 1]);
        PACK64(&sub_block[ 16], &w[ 2]); PACK64(&sub_block[ 24], &w[ 3]);
        PACK64(&sub_block[ 32], &w[ 4]); PACK64(&sub_block[ 40], &w[ 5]);
        PACK64(&sub_block[ 48], &w[ 6]); PACK64(&sub_block[ 56], &w[ 7]);
        PACK64(&sub_block[ 64], &w[ 8]); PACK64(&sub_block[ 72], &w[ 9]);
        PACK64(&sub_block[ 80], &w[10]); PACK64(&sub_block[ 88], &w[11]);
        PACK64(&sub_block[ 96], &w[12]); PACK64(&sub_block[104], &w[13]);
        PACK64(&sub_block[112], &w[14]); PACK64(&sub_block[120], &w[15]);
        SHA512_SCR(16); SHA512_SCR(17); SHA512_SCR(18); SHA512_SCR(19);
        SHA512_SCR(20); SHA512_SCR(21); SHA512_SCR(22); SHA512_SCR(23);
        SHA512_SCR(24); SHA512_SCR(25); SHA512_SCR(26); SHA512_SCR(27);
        SHA512_SCR(28); SHA512_SCR(29); SHA512_SCR(30); SHA512_SCR(31);
        SHA512_SCR(32); SHA512_SCR(33); SHA512_SCR(34); SHA512_SCR(35);
        SHA512_SCR(36); SHA512_SCR(37); SHA512_SCR(38); SHA512_SCR(39);
        SHA512_SCR(40); SHA512_SCR(41); SHA512_SCR(42); SHA512_SCR(43);
        SHA512_SCR(44); SHA512_SCR(45); SHA512_SCR(46); SHA512_SCR(47);
        SHA512_SCR(48); SHA512_SCR(49); SHA512_SCR(50); SHA512_SCR(51);
        SHA512_SCR(52); SHA512_SCR(53); SHA512_SCR(54); SHA512_SCR(55);
        SHA512_SCR(56); SHA512_SCR(57); SHA512_SCR(58); SHA512_SCR(59);
        SHA512_SCR(60); SHA512_SCR(61); SHA512_SCR(62); SHA512_SCR(63);
        SHA512_SCR(64); SHA512_SCR(65); SHA512_SCR(66); SHA512_SCR(67);
        SHA512_SCR(68); SHA512_SCR(69); SHA512_SCR(70); SHA512_SCR(71);
        SHA512_SCR(72); SHA512_SCR(73); SHA512_SCR(74); SHA512_SCR(75);
        SHA512_SCR(76); SHA512_SCR(77); SHA512_SCR(78); SHA512_SCR(79);
        wv[0] = ctx->h[0]; wv[1] = ctx->h[1];
        wv[2] = ctx->h[2]; wv[3] = ctx->h[3];
        wv[4] = ctx->h[4]; wv[5] = ctx->h[5];
        wv[6] = ctx->h[6]; wv[7] = ctx->h[7];
        j = 0;
        do {
            SHA512_EXP(0,1,2,3,4,5,6,7,j); j++;
            SHA512_EXP(7,0,1,2,3,4,5,6,j); j++;
            SHA512_EXP(6,7,0,1,2,3,4,5,j); j++;
            SHA512_EXP(5,6,7,0,1,2,3,4,j); j++;
            SHA512_EXP(4,5,6,7,0,1,2,3,j); j++;
            SHA512_EXP(3,4,5,6,7,0,1,2,j); j++;
            SHA512_EXP(2,3,4,5,6,7,0,1,j); j++;
            SHA512_EXP(1,2,3,4,5,6,7,0,j); j++;
        } while (j < 80);
        ctx->h[0] += wv[0]; ctx->h[1] += wv[1];
        ctx->h[2] += wv[2]; ctx->h[3] += wv[3];
        ctx->h[4] += wv[4]; ctx->h[5] += wv[5];
        ctx->h[6] += wv[6]; ctx->h[7] += wv[7];
#endif
    }
}
void sha512(const unsigned char *message, unsigned int len,
            unsigned char *digest)
{
    sha512_ctx ctx;
    sha512_init(&ctx);
    sha512_update(&ctx, message, len);
    sha512_final(&ctx, digest);
}
void sha512_init(sha512_ctx *ctx)
{
#ifndef UNROLL_LOOPS
    int i;
    for (i = 0; i < 8; i++) {
        ctx->h[i] = sha512_h0[i];
    }
#else
    ctx->h[0] = sha512_h0[0]; ctx->h[1] = sha512_h0[1];
    ctx->h[2] = sha512_h0[2]; ctx->h[3] = sha512_h0[3];
    ctx->h[4] = sha512_h0[4]; ctx->h[5] = sha512_h0[5];
    ctx->h[6] = sha512_h0[6]; ctx->h[7] = sha512_h0[7];
#endif
    ctx->len = 0;
    ctx->tot_len = 0;
}
void sha512_update(sha512_ctx *ctx, const unsigned char *message,
                   unsigned int len)
{
    unsigned int block_nb;
    unsigned int new_len, rem_len, tmp_len;
    const unsigned char *shifted_message;
    tmp_len = SHA512_BLOCK_SIZE - ctx->len;
    rem_len = len < tmp_len ? len : tmp_len;
    memcpy(&ctx->block[ctx->len], message, rem_len);
    if (ctx->len + len < SHA512_BLOCK_SIZE) {
        ctx->len += len;
        return;
    }
    new_len = len - rem_len;
    block_nb = new_len / SHA512_BLOCK_SIZE;
    shifted_message = message + rem_len;
    sha512_transf(ctx, ctx->block, 1);
    sha512_transf(ctx, shifted_message, block_nb);
    rem_len = new_len % SHA512_BLOCK_SIZE;
    memcpy(ctx->block, &shifted_message[block_nb << 7],
           rem_len);
    ctx->len = rem_len;
    ctx->tot_len += (block_nb + 1) << 7;
}
void sha512_final(sha512_ctx *ctx, unsigned char *digest)
{
    unsigned int block_nb;
    unsigned int pm_len;
    unsigned int len_b;
#ifndef UNROLL_LOOPS
    int i;
#endif
    block_nb = 1 + ((SHA512_BLOCK_SIZE - 17)
                     < (ctx->len % SHA512_BLOCK_SIZE));
    len_b = (ctx->tot_len + ctx->len) << 3;
    pm_len = block_nb << 7;
    memset(ctx->block + ctx->len, 0, pm_len - ctx->len);
    ctx->block[ctx->len] = 0x80;
    UNPACK32(len_b, ctx->block + pm_len - 4);
    sha512_transf(ctx, ctx->block, block_nb);
#ifndef UNROLL_LOOPS
    for (i = 0 ; i < 8; i++) {
        UNPACK64(ctx->h[i], &digest[i << 3]);
    }
#else
    UNPACK64(ctx->h[0], &digest[ 0]);
    UNPACK64(ctx->h[1], &digest[ 8]);
    UNPACK64(ctx->h[2], &digest[16]);
    UNPACK64(ctx->h[3], &digest[24]);
    UNPACK64(ctx->h[4], &digest[32]);
    UNPACK64(ctx->h[5], &digest[40]);
    UNPACK64(ctx->h[6], &digest[48]);
    UNPACK64(ctx->h[7], &digest[56]);
#endif
}
/* SHA-384 functions */
void sha384(const unsigned char *message, unsigned int len,
            unsigned char *digest)
{
    sha384_ctx ctx;
    sha384_init(&ctx);
    sha384_update(&ctx, message, len);
    sha384_final(&ctx, digest);
}
void sha384_init(sha384_ctx *ctx)
{
#ifndef UNROLL_LOOPS
    int i;
    for (i = 0; i < 8; i++) {
        ctx->h[i] = sha384_h0[i];
    }
#else
    ctx->h[0] = sha384_h0[0]; ctx->h[1] = sha384_h0[1];
    ctx->h[2] = sha384_h0[2]; ctx->h[3] = sha384_h0[3];
    ctx->h[4] = sha384_h0[4]; ctx->h[5] = sha384_h0[5];
    ctx->h[6] = sha384_h0[6]; ctx->h[7] = sha384_h0[7];
#endif
    ctx->len = 0;
    ctx->tot_len = 0;
}
void sha384_update(sha384_ctx *ctx, const unsigned char *message,
                   unsigned int len)
{
    unsigned int block_nb;
    unsigned int new_len, rem_len, tmp_len;
    const unsigned char *shifted_message;
    tmp_len = SHA384_BLOCK_SIZE - ctx->len;
    rem_len = len < tmp_len ? len : tmp_len;
    memcpy(&ctx->block[ctx->len], message, rem_len);
    if (ctx->len + len < SHA384_BLOCK_SIZE) {
        ctx->len += len;
        return;
    }
    new_len = len - rem_len;
    block_nb = new_len / SHA384_BLOCK_SIZE;
    shifted_message = message + rem_len;
    sha512_transf(ctx, ctx->block, 1);
    sha512_transf(ctx, shifted_message, block_nb);
    rem_len = new_len % SHA384_BLOCK_SIZE;
    memcpy(ctx->block, &shifted_message[block_nb << 7],
           rem_len);
    ctx->len = rem_len;
    ctx->tot_len += (block_nb + 1) << 7;
}
void sha384_final(sha384_ctx *ctx, unsigned char *digest)
{
    unsigned int block_nb;
    unsigned int pm_len;
    unsigned int len_b;
#ifndef UNROLL_LOOPS
    int i;
#endif
    block_nb = (1 + ((SHA384_BLOCK_SIZE - 17)
                     < (ctx->len % SHA384_BLOCK_SIZE)));
    len_b = (ctx->tot_len + ctx->len) << 3;
    pm_len = block_nb << 7;
    memset(ctx->block + ctx->len, 0, pm_len - ctx->len);
    ctx->block[ctx->len] = 0x80;
    UNPACK32(len_b, ctx->block + pm_len - 4);
    sha512_transf(ctx, ctx->block, block_nb);
#ifndef UNROLL_LOOPS
    for (i = 0 ; i < 6; i++) {
        UNPACK64(ctx->h[i], &digest[i << 3]);
    }
#else
    UNPACK64(ctx->h[0], &digest[ 0]);
    UNPACK64(ctx->h[1], &digest[ 8]);
    UNPACK64(ctx->h[2], &digest[16]);
    UNPACK64(ctx->h[3], &digest[24]);
    UNPACK64(ctx->h[4], &digest[32]);
    UNPACK64(ctx->h[5], &digest[40]);
#endif
}
/* SHA-224 functions */
void sha224(const unsigned char *message, unsigned int len,
            unsigned char *digest)
{
    sha224_ctx ctx;
    sha224_init(&ctx);
    sha224_update(&ctx, message, len);
    sha224_final(&ctx, digest);
}
void sha224_init(sha224_ctx *ctx)
{
#ifndef UNROLL_LOOPS
    int i;
    for (i = 0; i < 8; i++) {
        ctx->h[i] = sha224_h0[i];
    }
#else
    ctx->h[0] = sha224_h0[0]; ctx->h[1] = sha224_h0[1];
    ctx->h[2] = sha224_h0[2]; ctx->h[3] = sha224_h0[3];
    ctx->h[4] = sha224_h0[4]; ctx->h[5] = sha224_h0[5];
    ctx->h[6] = sha224_h0[6]; ctx->h[7] = sha224_h0[7];
#endif
    ctx->len = 0;
    ctx->tot_len = 0;
}
void sha224_update(sha224_ctx *ctx, const unsigned char *message,
                   unsigned int len)
{
    unsigned int block_nb;
    unsigned int new_len, rem_len, tmp_len;
    const unsigned char *shifted_message;
    tmp_len = SHA224_BLOCK_SIZE - ctx->len;
    rem_len = len < tmp_len ? len : tmp_len;
    memcpy(&ctx->block[ctx->len], message, rem_len);
    if (ctx->len + len < SHA224_BLOCK_SIZE) {
        ctx->len += len;
        return;
    }
    new_len = len - rem_len;
    block_nb = new_len / SHA224_BLOCK_SIZE;
    shifted_message = message + rem_len;
    sha256_transf(ctx, ctx->block, 1);
    sha256_transf(ctx, shifted_message, block_nb);
    rem_len = new_len % SHA224_BLOCK_SIZE;
    memcpy(ctx->block, &shifted_message[block_nb << 6],
           rem_len);
    ctx->len = rem_len;
    ctx->tot_len += (block_nb + 1) << 6;
}
void sha224_final(sha224_ctx *ctx, unsigned char *digest)
{
    unsigned int block_nb;
    unsigned int pm_len;
    unsigned int len_b;
#ifndef UNROLL_LOOPS
    int i;
#endif
    block_nb = (1 + ((SHA224_BLOCK_SIZE - 9)
                     < (ctx->len % SHA224_BLOCK_SIZE)));
    len_b = (ctx->tot_len + ctx->len) << 3;
    pm_len = block_nb << 6;
    memset(ctx->block + ctx->len, 0, pm_len - ctx->len);
    ctx->block[ctx->len] = 0x80;
    UNPACK32(len_b, ctx->block + pm_len - 4);
    sha256_transf(ctx, ctx->block, block_nb);
#ifndef UNROLL_LOOPS
    for (i = 0 ; i < 7; i++) {
        UNPACK32(ctx->h[i], &digest[i << 2]);
    }
#else
   UNPACK32(ctx->h[0], &digest[ 0]);
   UNPACK32(ctx->h[1], &digest[ 4]);
   UNPACK32(ctx->h[2], &digest[ 8]);
   UNPACK32(ctx->h[3], &digest[12]);
   UNPACK32(ctx->h[4], &digest[16]);
   UNPACK32(ctx->h[5], &digest[20]);
   UNPACK32(ctx->h[6], &digest[24]);
#endif
}
#ifdef TEST_VECTORS
/* FIPS 180-2 Validation tests */
void test(const char *vector, unsigned char *digest,
          unsigned int digest_size)
{
    char output[2 * SHA512_DIGEST_SIZE + 1];
    int i;
    output[2 * digest_size] = '\0';
    for (i = 0; i < (int) digest_size ; i++) {
       sprintf(output + 2 * i, "%02x", digest[i]);
    }
    printf("H: %s\n", output);
    if (strcmp(vector, output)) {
        fprintf(stderr, "Test failed.\n");
        exit(EXIT_FAILURE);
    }
}
int main(void)
{
    static const char *vectors[4][3] =
    {
        {
        "23097d223405d8228642a477bda255b32aadbce4bda0b3f7e36c9da7",
        "75388b16512776cc5dba5da1fd890150b0c6455cb4f58b1952522525",
        "20794655980c91d8bbb4c1ea97618a4bf03f42581948b2ee4ee7ad67",
        },
        /* SHA-256 */
        {
        "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad",
        "248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1",
        "cdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0",
        },
        /* SHA-384 */
        {
        "cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed"
        "8086072ba1e7cc2358baeca134c825a7",
        "09330c33f71147e83d192fc782cd1b4753111b173b3b05d22fa08086e3b0f712"
        "fcc7c71a557e2db966c3e9fa91746039",
        "9d0e1809716474cb086e834e310a4a1ced149e9c00f248527972cec5704c2a5b"
        "07b8b3dc38ecc4ebae97ddd87f3d8985",
        },
        /* SHA-512 */
        {
        "ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a"
        "2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f",
        "8e959b75dae313da8cf4f72814fc143f8f7779c6eb9f7fa17299aeadb6889018"
        "501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909",
        "e718483d0ce769644e2e42c7bc15b4638e1f98b13b2044285632a803afa973eb"
        "de0ff244877ea60a4cb0432ce577c31beb009c5c2c49aa2e4eadb217ad8cc09b"
        }
    };
    static const char message1[] = "abc";
    static const char message2a[] = "abcdbcdecdefdefgefghfghighijhi"
                                    "jkijkljklmklmnlmnomnopnopq";
    static const char message2b[] = "abcdefghbcdefghicdefghijdefghijkefghij"
                                    "klfghijklmghijklmnhijklmnoijklmnopjklm"
                                    "nopqklmnopqrlmnopqrsmnopqrstnopqrstu";
    unsigned char *message3;
    unsigned int message3_len = 1000000;
    unsigned char digest[SHA512_DIGEST_SIZE];
    message3 = malloc(message3_len);
    if (message3 == NULL) {
        fprintf(stderr, "Can't allocate memory\n");
        return -1;
    }
    memset(message3, 'a', message3_len);
    printf("SHA-2 FIPS 180-2 Validation tests\n\n");
    printf("SHA-224 Test vectors\n");
    sha224((const unsigned char *) message1, strlen(message1), digest);
    test(vectors[0][0], digest, SHA224_DIGEST_SIZE);
    sha224((const unsigned char *) message2a, strlen(message2a), digest);
    test(vectors[0][1], digest, SHA224_DIGEST_SIZE);
    sha224(message3, message3_len, digest);
    test(vectors[0][2], digest, SHA224_DIGEST_SIZE);
    printf("\n");
    printf("SHA-256 Test vectors\n");
    sha256((const unsigned char *) message1, strlen(message1), digest);
    test(vectors[1][0], digest, SHA256_DIGEST_SIZE);
    sha256((const unsigned char *) message2a, strlen(message2a), digest);
    test(vectors[1][1], digest, SHA256_DIGEST_SIZE);
    sha256(message3, message3_len, digest);
    test(vectors[1][2], digest, SHA256_DIGEST_SIZE);
    printf("\n");
    printf("SHA-384 Test vectors\n");
    sha384((const unsigned char *) message1, strlen(message1), digest);
    test(vectors[2][0], digest, SHA384_DIGEST_SIZE);
    sha384((const unsigned char *)message2b, strlen(message2b), digest);
    test(vectors[2][1], digest, SHA384_DIGEST_SIZE);
    sha384(message3, message3_len, digest);
    test(vectors[2][2], digest, SHA384_DIGEST_SIZE);
    printf("\n");
    printf("SHA-512 Test vectors\n");
    sha512((const unsigned char *) message1, strlen(message1), digest);
    test(vectors[3][0], digest, SHA512_DIGEST_SIZE);
    sha512((const unsigned char *) message2b, strlen(message2b), digest);
    test(vectors[3][1], digest, SHA512_DIGEST_SIZE);
    sha512(message3, message3_len, digest);
    test(vectors[3][2], digest, SHA512_DIGEST_SIZE);
    printf("\n");
    printf("All tests passed.\n");
    return 0;
}
#endif
#ifdef _WIN64
#ifndef __64__
#define __64__
#endif
#endif
#ifdef WIN32
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x501
#endif
#endif
// debugging only gets you the ordering(priority) logging and something else...
// useful logging is now controlled with l.flags.bLog
#define DISABLE_DEBUG_REGISTER_AND_DISPATCH
//#define DEBUG_SHUTDOWN
#define LOG_ALL 0
//
// core library load
//    all procs scheduled, initial = 0
// Application starts, invokes preloads
//    additional libraries load, scheduling because of suspend
//    library load completes by invoking the newly registered list
// final core application schedulging happens, after initial preload completes
//    additional preload scheduligin happens( not suspended, is initial)
//#define DEBUG_CYGWIN_START
//#ifndef __LINUX__
#define IS_DEADSTART
#ifdef __LINUX__
#include <signal.h>
#endif
#ifdef WIN32
 // GetConsoleWindow()
#include <wincon.h>
#endif
#ifdef __NO_BAG__
#undef lprintf
#define lprintf printf
#define BAG_Exit exit
#else
#endif
//#define lprintf(f,...) printf(f "\n",##__VA_ARGS__)
//#define _lprintf(n) lprintf
#ifdef UNDER_CE
#define LockedExchange InterlockedExchange
#endif
SACK_DEADSTART_NAMESPACE
//#undef PRELOAD
EXPORT_METHOD void RunDeadstart( void );
typedef struct startup_proc_tag {
	DeclareLink( struct startup_proc_tag );
	int bUsed;
	int priority;
	void (CPROC*proc)(void);
	CTEXTSTR func;
#ifdef _DEBUG
	CTEXTSTR file;
	int line;
#endif
} STARTUP_PROC, *PSTARTUP_PROC;
typedef struct shutdown_proc_tag {
	DeclareLink( struct shutdown_proc_tag );
	int bUsed;
	int priority;
	void (CPROC*proc)(void);
	CTEXTSTR func;
#ifdef _DEBUG
	CTEXTSTR file;
	int line;
#endif
} SHUTDOWN_PROC, *PSHUTDOWN_PROC;
struct deadstart_local_data_
{
	// this is a lot of procs...
	int nShutdownProcs;
#define nShutdownProcs l.nShutdownProcs
	SHUTDOWN_PROC shutdown_procs[512];
#define shutdown_procs l.shutdown_procs
	int bInitialDone;
#define bInitialDone l.bInitialDone
	LOGICAL bInitialStarted;
#define bInitialStarted l.bInitialStarted
	int bSuspend;
#define bSuspend l.bSuspend
	int bDispatched;
//#define bDispatched l.bDispatched
	PSHUTDOWN_PROC shutdown_proc_schedule;
#define shutdown_proc_schedule l.shutdown_proc_schedule
 // count of used procs...
	int nProcs;
#define nProcs l.nProcs
	STARTUP_PROC procs[1024];
#define procs l.procs
	PSTARTUP_PROC proc_schedule;
#define proc_schedule l.proc_schedule
	struct
	{
		BIT_FIELD bInitialized : 1;
		BIT_FIELD bLog : 1;
	} flags;
};
#ifdef UNDER_CE
#  ifndef __STATIC_GLOBALS__
#    define __STATIC_GLOBALS__
#  endif
#endif
#ifndef __STATIC_GLOBALS__
static struct deadstart_local_data_ *deadstart_local_data;
#define l (*deadstart_local_data)
#else
static struct deadstart_local_data_ deadstart_local_data;
#define l (deadstart_local_data)
#endif
EXPORT_METHOD void RunExits( void )
{
	InvokeExits();
}
static void InitLocal( void )
{
#ifndef __STATIC_GLOBALS__
	if( !deadstart_local_data )
	{
		SimpleRegisterAndCreateGlobal( deadstart_local_data );
	}
#endif
	if( !l.flags.bInitialized )
	{
		//atexit( RunExits );
		l.flags.bInitialized = 1;
	}
}
#ifndef  DISABLE_DEBUG_REGISTER_AND_DISPATCH
#define ENQUE_STARTUP_DBG_SRC DBG_SRC
void EnqueStartupProc( PSTARTUP_PROC *root, PSTARTUP_PROC proc DBG_PASS )
#else
#define ENQUE_STARTUP_DBG_SRC
void EnqueStartupProc( PSTARTUP_PROC *root, PSTARTUP_PROC proc )
#endif
{
	PSTARTUP_PROC check;
	PSTARTUP_PROC last;
		if( proc->next || proc->me )
		{
			if( ( (*proc->me) = proc->next ) )
				proc->next->me = proc->me;
		}
		for( last = check = (*root); check; check = check->next )
		{
			// if the current one being added is less then the one in the list
			// then the one in the list becomes the new one's next...
			if( proc->priority < check->priority )
			{
#ifndef  DISABLE_DEBUG_REGISTER_AND_DISPATCH
				_lprintf(DBG_RELAY)( WIDE("%s(%d) is to run before %s and after %s first is %s")
						 , proc->func
						 , proc - procs
						 , check->func
						 , (check->me==root)?WIDE("Is First"):((PSTARTUP_PROC)check->me)->func
						 , (*root)?(*root)->func:WIDE("First")
						 );
#endif
				proc->next = check;
				proc->me = check->me;
				(*check->me) = proc;
				check->me = &proc->next;
				break;
			}
			last = check;
		}
		if( !check )
		{
#ifndef  DISABLE_DEBUG_REGISTER_AND_DISPATCH
			lprintf( WIDE("%s(%d) is to run after all")
					 , proc->func
					 , proc - procs
					 );
#endif
			proc->next = NULL;
			if( last )
			{
				last->next = proc;
				proc->me = &last->next;
			}
			else
			{
				(*root) = proc;
				proc->me = root;
			}
		}
}
// parameter 4 is just used so the external code is not killed
// we don't actually do anything with this?
void RegisterPriorityStartupProc( void (CPROC*proc)(void), CTEXTSTR func,int priority, void *use_label DBG_PASS )
{
	int use_proc;
	InitLocal();
	if( LOG_ALL ||
#ifndef __STATIC_GLOBALS__
		 (deadstart_local_data
#else
		(1
#endif
		&& l.flags.bLog ))
		lprintf( WIDE("Register %s@") DBG_FILELINEFMT_MIN WIDE(" %d"), func DBG_RELAY, priority);
	if( nProcs == 1024 )
	{
		for( use_proc = 0; use_proc < 1024; use_proc++ )
			if( !procs[use_proc].bUsed )
				break;
		if( use_proc == 1024 )
		{
			lprintf( WIDE( "Used all 1024, and, have 1024 startups total scheduled." ) );
			DebugBreak();
		}
	}
	else
		use_proc = nProcs;
	procs[use_proc].proc = proc;
	procs[use_proc].func = func;
#ifdef _DEBUG
	procs[use_proc].file = pFile;
	procs[use_proc].line = nLine;
#endif
	procs[use_proc].priority = priority;
	procs[use_proc].bUsed = 1;
 // initialize so it doesn't try unlink in requeue common routine.
	procs[use_proc].next = NULL;
 // initialize so it doesn't try unlink in requeue common routine.
	procs[use_proc].me = NULL;
	EnqueStartupProc( &proc_schedule, procs + use_proc ENQUE_STARTUP_DBG_SRC );
	if( nProcs < 1024 )
		nProcs++;
	/*
	if( nProcs == 1024 )
	{
		lprintf( WIDE( "Excessive number of startup procs!" ) );
		DebugBreak();
	}
	*/
	if( bInitialDone && !bSuspend )
	{
#define ONE_MACRO(a,b) a,b
#ifdef _DEBUG
		_xlprintf(LOG_NOISE,pFile,nLine)( WIDE( "Initial done, not suspended, dispatch immediate." ) );
#endif
		InvokeDeadstart();
	}
	//lprintf( WIDE("Total procs %d"), nProcs );
}
#ifdef __LINUX__
// this handles the peculiarities of fork() and exit()
void ClearDeadstarts( void )
{
	// this is reserved for the sole use of
	// fork() success and then exec() failing...
	// when oh wait - __attribute__((destructor))
	// if( registered_pid != getppid() )
	shutdown_proc_schedule = NULL;
	// be rude - yes we lose resources. but everything goes away cause
	// this is just a clone..
}
#endif
#ifndef UNDER_CE
#  if defined( WIN32 )
#    ifndef __cplusplus_cli
static BOOL WINAPI CtrlC( DWORD dwCtrlType )
{
	switch( dwCtrlType )
	{
	case CTRL_BREAK_EVENT:
	case CTRL_C_EVENT:
		InvokeExits();
		// allow C api to exit, whatever C api we're using
		// (allows triggering atexit functions)
		exit(3);
		return TRUE;
	case CTRL_CLOSE_EVENT:
		break;
	case CTRL_LOGOFF_EVENT:
		break;
	case CTRL_SHUTDOWN_EVENT:
		break;
	}
	// default... return not processed.
	return FALSE;
}
#    endif
#  endif
#  ifndef WIN32
static void CtrlC( int signal )
{
	exit(3);
}
#  endif
#endif
// wow no such thing as static-izing this... it's
// always retrieved with dynamic function loading, therefore
// MUST be exported if at all possible.
// this one is used when a library is loaded.
void InvokeDeadstart( void )
{
	PSTARTUP_PROC proc;
	PSTARTUP_PROC resumed_proc;
	//if( !bInitialDone /*|| bDispatched*/ )
	//   return;
	InitLocal();
	if( bInitialStarted )
		return;
	bInitialStarted = 1;
	// allowing initial start to be set lets final resume do this invoke.
	if( bSuspend )
	{
		if( l.flags.bLog )
			lprintf( WIDE("Suspended, first proc is %s"), proc_schedule?proc_schedule->func:WIDE("No First") );
		return;
	}
#ifdef WIN32
	if( !bInitialDone && !l.bDispatched )
	{
#  ifndef UNDER_CE
		if( GetConsoleWindow() )
		{
#    ifndef __cplusplus_cli
			//MessageBox( NULL, "!!--!! CtrlC", "blah", MB_OK );
			SetConsoleCtrlHandler( CtrlC, TRUE );
#    endif
		}
		else
		{
			//MessageBox( NULL, "!!--!! NO CtrlC", "blah", MB_OK );
 // do nothing if we're no actually a console window. this should fix ctrl-c not working in CMD prompts launched by MILK/InterShell
			;
		}
#  endif
	}
#endif
	while( ( proc = (PSTARTUP_PROC)LockedExchangePtrSzVal( (PVPTRSZVAL)&proc_schedule, 0 ) ) != NULL )
	{
		// need to set this to point to new head of list... it's not in proc_schedule anymore
		//proc->me = &proc;
		if( LOG_ALL ||
#ifndef __STATIC_GLOBALS__
		 (deadstart_local_data
#else
		(1
#endif
		&& l.flags.bLog ))
		{
#ifdef _DEBUG
			lprintf( WIDE("Dispatch %s@%s(%d)p:%d "), proc->func,proc->file,proc->line, proc->priority );
#else
			lprintf( WIDE("Dispatch %s@p:%d "), proc->func, proc->priority );
#endif
		}
		{
			l.bDispatched = 1;
#ifdef _DEBUG
			if( proc->proc
#  ifndef __LINUX__
#    if  __WATCOMC__ >= 1280
				&& !IsBadCodePtr( (int(STDCALL*)(void))proc->proc )
#    elif defined( __64__ )
				&& !IsBadCodePtr( (FARPROC)proc->proc )
#    else
//				&& !IsBadCodePtr( (int STDCALL(*)(void))proc->proc )
#    endif
#  endif
			  )
#endif
			{
				proc->proc();
			}
			proc->bUsed = 0;
			l.bDispatched = 0;
		}
		// look to see if anything new was scheduled.  Grab the list, add it to the one's we're processing.
		{
			{
				PSTARTUP_PROC newly_scheduled_things;
				proc->me = &proc;
				resumed_proc = proc;
				if( ( newly_scheduled_things = (PSTARTUP_PROC)LockedExchangePtrSzVal( (PVPTRSZVAL)&proc_schedule, 0 ) ) != NULL )
				{
					newly_scheduled_things->me = &newly_scheduled_things;
					//lprintf( "------------------  newly scheduled startups; requeue old startups into new list ------------------ " );
					while( newly_scheduled_things )
					{
						EnqueStartupProc( &proc, newly_scheduled_things ENQUE_STARTUP_DBG_SRC );
					}
				}
				else
					resumed_proc = NULL;
			}
			proc_schedule = proc;
			proc_schedule->me = &proc_schedule;
		}
		if( resumed_proc )
			UnlinkThing( resumed_proc );
		else
			UnlinkThing( proc );
	}
	bInitialStarted = 0;
}
void MarkRootDeadstartComplete( void )
{
	bInitialDone = 1;
}
#ifndef __NO_OPTIONS__
// options initializes at SQL+1
PRIORITY_PRELOAD( InitDeadstartOptions, NAMESPACE_PRELOAD_PRIORITY+1 )
{
#ifdef DISABLE_DEBUG_REGISTER_AND_DISPATCH
#  ifndef __NO_OPTIONS
	l.flags.bLog = SACK_GetProfileIntEx( WIDE( "SACK/Deadstart" ), WIDE( "Logging Enabled?" ), 0, TRUE );
#  else
	l.flags.bLog = 0;
#  endif
#else
	l.flags.bLog = 1;
#endif
}
#endif
// parameter 4 is just used so the external code is not killed
// we don't actually do anything with this?
void RegisterPriorityShutdownProc( void (CPROC*proc)(void), CTEXTSTR func, int priority,void *use_label DBG_PASS )
{
	InitLocal();
	if( LOG_ALL ||
#ifndef __STATIC_GLOBALS__
		(deadstart_local_data
#else
		 (1
#endif
		  && l.flags.bLog ))
		lprintf( WIDE("Exit Proc %s(%p) from ") DBG_FILELINEFMT_MIN WIDE(" registered...")
				 , func
				 , proc DBG_RELAY );
	shutdown_procs[nShutdownProcs].proc = proc;
	shutdown_procs[nShutdownProcs].func = func;
#ifdef _DEBUG
	shutdown_procs[nShutdownProcs].file = pFile;
	shutdown_procs[nShutdownProcs].line = nLine;
#endif
	shutdown_procs[nShutdownProcs].bUsed = 1;
	shutdown_procs[nShutdownProcs].priority = priority;
	{
		PSHUTDOWN_PROC check;
		for( check = shutdown_proc_schedule; check; check = check->next )
		{
			if( shutdown_procs[nShutdownProcs].priority >= check->priority )
			{
#ifdef DEBUG_SHUTDOWN
				lprintf( WIDE("%s(%d) is to run before %s(%d) %s")
						 , shutdown_procs[nShutdownProcs].func
						 , nShutdownProcs
						 , check->file
						 , check->line
						 , check->func );
#endif
				shutdown_procs[nShutdownProcs].next = check;
				shutdown_procs[nShutdownProcs].me = check->me;
				(*check->me) = shutdown_procs + nShutdownProcs;
				check->me = &shutdown_procs[nShutdownProcs].next;
				break;
			}
		}
		if( !check )
			LinkLast( shutdown_proc_schedule, PSHUTDOWN_PROC, shutdown_procs + nShutdownProcs );
		//lprintf( WIDE("first routine is %s(%d)")
		//		 , shutdown_proc_schedule->func
		//		 , shutdown_proc_schedule->line );
	}
	nShutdownProcs++;
	//lprintf( WIDE("Total procs %d"), nProcs );
}
void InvokeExits( void )
{
	// okay well since noone previously scheduled exits...
	// this runs a prioritized list of exits - all within
	// a single moment of exited-ness.
	PSHUTDOWN_PROC proc;
	// shutdown is much easier than startup cause more
	// procedures shouldn't be added as a property of shutdown.
	// don't allow shutdown procs to schedule more shutdown procs...
	// although in theory we could; if the first list contained
	// ReleaseAllMemory(); then there is no memory.
	if(
#ifndef __STATIC_GLOBALS__
		deadstart_local_data &&
#endif
			( proc = (PSHUTDOWN_PROC)LockedExchangePtrSzVal( (PVPTRSZVAL)&shutdown_proc_schedule, 0 ) ) != NULL
		  )
	{
		// just before all memory goes away
		// global memory goes away (including mine) so deadstart_local_data is invalidated.
#ifndef __STATIC_GLOBALS__
		struct deadstart_local_data_ *local_pointer = (struct deadstart_local_data_*)(((uintptr_t)deadstart_local_data)-sizeof(PLIST));
#endif
		PSHUTDOWN_PROC proclist = proc;
		// link list to myself..
#ifndef __STATIC_GLOBALS__
		Hold( local_pointer );
#endif
		proc->me = &proclist;
		while( ( proc = proclist ) )
		{
#if defined( DEBUG_SHUTDOWN )
			lprintf( WIDE("Exit Proc %s(%p)(%d) priority %d from %s(%d)...")
			       , proc->func
			       , proc->proc
			       , proc - shutdown_procs
			       , proc->priority
			       , proc->file
			       , proc->line );
#endif
			if( proc->priority == 0 )
			{
				//atexit( proc->proc );
				//continue;
			}
			// don't release this stuff... memory might be one of the autoexiters.
			UnlinkThing( proc );
			if( proc->proc
#ifndef __LINUX__
				&& !IsBadCodePtr( (FARPROC)proc->proc )
#endif
			  )
			{
#ifdef DEBUG_SHUTDOWN
				lprintf( "Dispatching..." );
#endif
				proc->proc();
			}
			// okay I have the whol elist... so...
#ifdef DEBUG_SHUTDOWN
			lprintf( WIDE("Okay and that's done... next is %p %p"), proclist, shutdown_proc_schedule );
#endif
		}
		// nope by this time memory doesn't exist anywhere.
		//Release( local_pointer );
		//shutdown_proc_schedule = proc;
	}
#ifndef __STATIC_GLOBALS__
	deadstart_local_data = (struct deadstart_local_data_*)NULL;
#endif
	//shutdown_proc_schedule = NULL;
}
void DispelDeadstart( void )
{
	shutdown_proc_schedule = NULL;
}
#ifdef __cplusplus
ROOT_ATEXIT(AutoRunExits)
{
	InvokeExits();
}
#endif
void SuspendDeadstart( void )
{
	bSuspend++;
}
void ResumeDeadstart( void )
{
	bSuspend--;
	if( !bSuspend )
	{
		if( bInitialDone )
			InvokeDeadstart();
	}
}
SACK_DEADSTART_NAMESPACE_END
SACK_NAMESPACE
// linked into BAG to provide a common definition for function Exit()
// this then invokes an exit in the mainline program (if available)
void BAG_Exit( int code )
{
#ifndef __cplusplus_cli
	InvokeExits();
#endif
#undef exit
	exit( code );
}
// legacy linking code - might still be usin this for linux...
LOGICAL is_deadstart_complete( void )
{
	//extern uint32_t deadstart_complete;
#ifndef __STATIC_GLOBALS__
	if( deadstart_local_data )
//deadstart_complete;
		return bInitialDone;
#endif
	return FALSE;
}
SACK_NAMESPACE_END
SACK_DEADSTART_NAMESPACE
LOGICAL IsRootDeadstartStarted( void )
{
#ifndef __STATIC_GLOBALS__
	if( deadstart_local_data )
		return bInitialStarted;
	return 0;
#else
	return bInitialStarted;
#endif
}
LOGICAL IsRootDeadstartComplete( void )
{
#ifndef __STATIC_GLOBALS__
	if( deadstart_local_data )
		return bInitialDone;
	return 0;
#else
	return bInitialDone;
#endif
}
#ifndef __STATIC__
#ifndef __WATCOMC__
#if !defined( __cplusplus_cli )
#if !defined( NO_DEADSTART_DLLMAIN ) && !defined( BUILD_PORTABLE_EXECUTABLE )
#  if !defined( __LINUX__ ) && !defined( __GNUC__ )
#    ifdef __cplusplus
extern "C"
#    endif
__declspec(dllexport)
	BOOL WINAPI DllMain(  HINSTANCE hinstDLL,
   DWORD fdwReason,
   LPVOID lpvReserved
		   )
{
	if( fdwReason == DLL_PROCESS_DETACH )
		InvokeExits();
	return TRUE;
}
#  else
void RootDestructor(void) __attribute__((destructor));
void RootDestructor( void )
{
	InvokeExits();
}
#  endif
#endif
#endif
#endif
#endif
SACK_DEADSTART_NAMESPACE_END
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2017++
 *
 *   created to provide standard logging features
 *   lprintf( format, ... ); simple, basic
 *   if DEBUG, then logs to a file of the same name as the program
 *   if RELEASE most of this logging goes away at compile time.
 *
 *  standardized to never use int.
 *
 * see also - include/logging.h
 *
 */
//#define SUPPORT_LOG_ALLOCATE
//#define DEFAULT_OUTPUT_STDERR
#define COMPUTE_CPU_FREQUENCY
#define NO_UNICODE_C
//#undef UNICODE
#ifdef __LCC__
#include <intrinsics.h>
#endif
#ifdef __LINUX__
#include <time.h>
 // struct sockaddr_un
#include <sys/un.h>
#endif
#ifdef __ANDROID__
#include <android/log.h>
#endif
#ifdef WIN32
#ifndef _ARM_
 // unlink
#endif
#endif
#ifndef IDLE_FUNCTIONS_DEFINED
#define IDLE_FUNCTIONS_DEFINED
# ifdef IDLE_SOURCE
#  define IDLE_PROC(type,name) EXPORT_METHOD type CPROC name
# else
#  define IDLE_PROC(type,name) IMPORT_METHOD type CPROC name
# endif
#ifdef __cplusplus
namespace sack {
	namespace timers {
#endif
// return -1 if not the correct thread
// return 0 if no events processed
// return 1 if events were processed
typedef int (CPROC *IdleProc)(uintptr_t);
IDLE_PROC( void, AddIdleProc )( IdleProc Proc, uintptr_t psvUser );
IDLE_PROC( int, RemoveIdleProc )( IdleProc Proc );
IDLE_PROC( int, Idle )( void );
IDLE_PROC( int, IdleFor )( uint32_t dwMilliseconds );
#ifdef __cplusplus
//	namespace timers {
	};
//namespace sack {
};
using namespace sack::timers;
#endif
#endif
// okay this brings TIGHT integration.... but standardization for core levels.
#ifndef __NO_OPTIONS__
#endif
#ifdef __cplusplus
#include <cstdio>
LOGGING_NAMESPACE
#endif
#ifndef _SH_DENYWR
#  define _SH_COMPAT 0x00
#  define _SH_DENYRW 0x10
#  define _SH_DENYWR 0x20
#  define _SH_DENYRD 0x30
#  define _SH_DENYNO 0x40
#  define _SH_SECURE 0x80
#endif
struct syslog_local_data {
int cannot_log;
#define cannot_log (*syslog_local).cannot_log
uint64_t cpu_tick_freq;
#define cpu_tick_freq (*syslog_local).cpu_tick_freq
// (*syslog_local).flags that control the operation of system logging....
struct state_flags{
	BIT_FIELD bInitialized : 1;
	BIT_FIELD bUseDay : 1;
	BIT_FIELD bUseDeltaTime : 1;
	BIT_FIELD bLogTime : 1;
	BIT_FIELD bLogHighTime : 1;
	BIT_FIELD bLogCPUTime : 1;
	BIT_FIELD bProtectLoggedFilenames : 1;
	BIT_FIELD bLogProgram : 1;
	BIT_FIELD bLogThreadID : 1;
	BIT_FIELD bLogOpenAppend : 1;
	BIT_FIELD bLogOpenBackup : 1;
	BIT_FIELD bLogSourceFile : 1;
	BIT_FIELD bOptionsLoaded : 1;
	BIT_FIELD group_ok : 1;
} flags;
// a conserviative minimalistic configuration...
//} (*syslog_local).flags = { 0,0,1,0,1,0,1,1,0};
 TEXTCHAR *pProgramName;
#define pProgramName (*syslog_local).pProgramName
 UserLoggingCallback UserCallback;
//#define User1Callback (*syslog_local).UserCallback
 enum syslog_types logtype;
#define logtype (*syslog_local).logtype
 // default log EVERYTHING
 uint32_t nLogLevel;
#define nLogLevel (*syslog_local).nLogLevel
 // bits enabled and disabled for custom mesasges...
 uint32_t nLogCustom;
#define nLogCustom (*syslog_local).nLogCustom
// = "LOG";
 CTEXTSTR gFilename;
#define gFilename (*syslog_local).gFilename
 FILE *file;
 SOCKET   hSock;
#define hSock (*syslog_local).hSock
 SOCKET   hSyslogdSock;
 // assume this works, until it fails
 int bCPUTickWorks;
#define bCPUTickWorks (*syslog_local).bCPUTickWorks
 uint64_t tick_bias;
 uint64_t lasttick;
 uint64_t lasttick2;
 LOGICAL bStarted;
 LOGICAL bLogging;
 LOGICAL bSyslogdLogging;
	PLINKQUEUE buffers;
#if defined( WIN32 )
	DWORD next_lprintf_tls;
#elif defined( __LINUX__ )
	pthread_key_t next_lprintf_tls;
#endif
};
#ifdef __ANDROID__
//#  if !USE_CUSTOM_ALLOCER
//#    define __STATIC_GLOBALS__
//#  endif //!USE_CUSTOM_ALLOCER
#endif
#ifndef __STATIC_GLOBALS__
struct syslog_local_data *syslog_local;
#else
struct syslog_local_data _syslog_local;
struct syslog_local_data *syslog_local = &_syslog_local;
#endif
static void DoSystemLog( const TEXTCHAR *buffer );
//----------------------------------------------------------------------------
// we should really wait until the very end to cleanup?
PRIORITY_ATEXIT( CleanSyslog, ATEXIT_PRIORITY_SYSLOG )
{
	enum syslog_types _logtype;
#ifndef __STATIC_GLOBALS__
	if( !syslog_local )
		return;
#endif
	_logtype = logtype;
	if( ( _logtype == SYSLOG_AUTO_FILE && (*syslog_local).file ) || ( _logtype == SYSLOG_NONE ) )
		lprintf( WIDE( "Final log - syslog clos(ing)ed." ) );
 // this was dynamic allocated memory, and it is now gone.
	pProgramName = NULL;
	logtype = SYSLOG_NONE;
	switch( _logtype )
	{
  // usually this is stderr ... don't do anything
	case SYSLOG_FILE:
		break;
	case SYSLOG_FILENAME:
		sack_fclose( (*syslog_local).file );
		break;
#ifdef __LINUX__
#  ifndef __DISABLE_SYSLOGD_SYSLOG__
	case SYSLOG_SOCKET_SYSLOGD:
		closesocket( (*syslog_local).hSyslogdSock );
		(*syslog_local).hSyslogdSock = INVALID_SOCKET;
		break;
#  endif
#endif
#ifndef __DISABLE_UDP_SYSLOG__
	case SYSLOG_UDP:
	case SYSLOG_UDPBROADCAST:
		closesocket( hSock );
		hSock = INVALID_SOCKET;
		break;
#endif
	default:
		// else... no resources to cleanup
		break;
	}
}
#if 0
        /*
         * this code would ideally check to see if
         * the cpu rdtsc instruction worked....
         * someday we should consider using the rdtscp instruction
         * but that will require fetching CPU characteristics
         * - SEE mmx.asm in src/imglib/
         */
void TestCPUTick( void )
{
	uint64_t tick, _tick;
	int n;
	bCPUTickWorks = 1;
	_tick = tick = GetCPUTick();
	for( n = 0; n < 10000000; n++ )
	{
#ifdef GCC
		//asm( "cpuid\n" );
#endif
		tick = GetCPUTick();
		if( tick > _tick )
		{
			//lprintf( "%020Ld %020Ld", _tick, tick );
			_tick = tick;
		}
		else
		{
			lprintf( "CPU TICK FAILED!" );
			bCPUTickWorks = 0;
			break;
		}
		Relinquish();
	}
}
#endif
#ifdef __WATCOMC__
unsigned __int64 rdtsc( void);
#pragma aux rdtsc = 0x0F 0x31 value [edx eax] parm nomemory modify exact [edx eax] nomemory;
//#pragma aux GetCPUTicks3 = "rdtsc"   "mov dword ptr tick, eax"	   "mov dword ptr tick+4, edx "
#endif
uint64_t GetCPUTick(void )
{
/*
 * being the core of CPU tick layer type stuff
 * this should result in ticks, and fail ticks
 * to return reasonable defaults...
 * I guess there should be a tick_base to result
 * the same type of number when it does go backwards
 */
	if( bCPUTickWorks )
	{
#if defined( __LCC__ )
		return _rdtsc();
#elif defined( __WATCOMC__ )
		uint64_t tick = rdtsc();
#ifndef __WATCOMC__
		// haha a nasty compiler trick to get the variable used
		// but it's also a 'meaningless expression' so watcom pukes.
		(1)?(0):(tick = 0);
#endif
		if( !(*syslog_local).lasttick )
			(*syslog_local).lasttick = tick;
		else if( tick < (*syslog_local).lasttick )
		{
			bCPUTickWorks = 0;
			cpu_tick_freq = 1;
/*GetTickCount()*/
			(*syslog_local).tick_bias = (*syslog_local).lasttick - ( timeGetTime() * 1000 );
 // more than prior, but no longer valid.
			tick = (*syslog_local).lasttick + 1;
		}
		(*syslog_local).lasttick = tick;
		return tick;
#elif defined( _MSC_VER )
#ifdef _M_CEE_PURE
		//return System::DateTime::now;
		return 0;
#else
#   if defined( _WIN64 )
		uint64_t tick = __rdtsc();
#   else
		static uint64_t tick;
#     if _ARM_
		tick = tick+1;
#     else
		_asm rdtsc;
		_asm mov dword ptr [tick], eax;
		_asm mov dword ptr [tick + 4], edx;
#     endif
#   endif
		if( !(*syslog_local).lasttick )
			(*syslog_local).lasttick = tick;
		else if( tick < (*syslog_local).lasttick )
		{
			bCPUTickWorks = 0;
			cpu_tick_freq = 1;
/*GetTickCount()*/
			(*syslog_local).tick_bias = (*syslog_local).lasttick - ( timeGetTime() * 1000 );
 // more than prior, but no longer valid.
			tick = (*syslog_local).lasttick + 1;
		}
		(*syslog_local).lasttick = tick;
		return tick;
		if( !(*syslog_local).lasttick )
			(*syslog_local).lasttick = tick;
		else if( tick < (*syslog_local).lasttick )
		{
			bCPUTickWorks = 0;
			cpu_tick_freq = 1;
/*GetTickCount()*/
			(*syslog_local).tick_bias = (*syslog_local).lasttick - ( timeGetTime() * 1000 );
 // more than prior, but no longer valid.
			tick = (*syslog_local).lasttick + 1;
		}
		(*syslog_local).lasttick = tick;
		return tick;
#endif
#elif defined( __GNUC__ ) && !defined( __arm__ ) && !defined( __aarch64__ )
		union {
			uint64_t tick;
			PREFIX_PACKED struct { uint32_t low, high; } PACKED parts;
		}tick;
		asm( "rdtsc\n" : "=a"(tick.parts.low), "=d"(tick.parts.high) );
		if( !(*syslog_local).lasttick )
			(*syslog_local).lasttick = tick.tick;
		else if( tick.tick < (*syslog_local).lasttick )
		{
			bCPUTickWorks = 0;
			cpu_tick_freq = 1;
/*GetTickCount()*/
			(*syslog_local).tick_bias = (*syslog_local).lasttick - ( timeGetTime() * 1000 );
 // more than prior, but no longer valid.
			tick.tick = (*syslog_local).lasttick + 1;
		}
		(*syslog_local).lasttick = tick.tick;
		return tick.tick;
#else
		DebugBreak();
#endif
	}
/*GetTickCount()*/
	return (*syslog_local).tick_bias + (timeGetTime() * 1000);
}
uint64_t GetCPUFrequency( void )
{
#ifdef COMPUTE_CPU_FREQUENCY
	{
		uint64_t cpu_tick, _cpu_tick;
		uint32_t tick, _tick;
		cpu_tick = _cpu_tick = GetCPUTick();
/*GetTickCount()*/
		tick = _tick = timeGetTime();
		cpu_tick_freq = 0;
/*GetTickCount()*/
		while( bCPUTickWorks && ( ( tick = timeGetTime() ) - _tick ) < 25 );
		cpu_tick = GetCPUTick();
		if( bCPUTickWorks )
 // microseconds;
			cpu_tick_freq = ( ( cpu_tick - _cpu_tick ) / ( tick - _tick ) )  / 1000;
	}
#else
	cpu_tick_freq = 1;
#endif
	return cpu_tick_freq;
}
void SetDefaultName( CTEXTSTR path, CTEXTSTR name, CTEXTSTR extra )
{
	TEXTCHAR *newpath;
	size_t len;
// = GetProgramPath();
	static CTEXTSTR filepath;
// = GetProgramName();
	static CTEXTSTR filename;
	if( path )
	{
		if( filepath )
			Release( (POINTER)filepath );
		filepath = StrDup( path );
	}
	if( name )
	{
		if( filename )
			Release( (POINTER)filename );
		filename = StrDup( name );
	}
	if( !filepath )
		filepath = ExpandPath( WIDE("*/") );
	if( !filename )
		filename = StrDup( GetProgramName() );
	if( !filename )
		filename = "org.d3x0r.sack";
	// this has to come from C heap.. my init isn't done yet probably and
	// sharemem will just fai(*syslog_local).  (it's probably trying to log... )
	newpath = (TEXTCHAR*)malloc( len = sizeof(TEXTCHAR)*(9 + StrLen( filepath ) + StrLen( filename ) + (extra?StrLen(extra):0) + 5) );
#ifdef __cplusplus_cli
	tnprintf( newpath, len, WIDE("%s/%s%s.cli.log"), filepath, filename, extra?extra:WIDE("") );
#else
	tnprintf( newpath, len, WIDE("%s/%s%s.log"), filepath, filename, extra?extra:WIDE("") );
#endif
//( newpath ); // use the C heap.
	gFilename = newpath;
	//free( newpath ); // get rid of this ...
}
#ifndef __NO_OPTIONS__
static void LoadOptions( void )
{
	if( !(*syslog_local).flags.bOptionsLoaded )
	{
		(*syslog_local).flags.bLogSourceFile = SACK_GetProfileIntEx( GetProgramName()
																 , WIDE( "SACK/Logging/Log Source File")
																 , (*syslog_local).flags.bLogSourceFile, TRUE );
#ifndef __ANDROID__
		// android has a system log that does just fine/ default startup sets that.
		if( SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Enable System Log" )
										, 0
										, TRUE ) )
		{
			logtype = SYSLOG_SYSTEM;
			(*syslog_local).flags.bLogProgram = 1;
		}
		else if( SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Enable File Log" )
										, ( logtype == SYSLOG_AUTO_FILE )
										, TRUE ) )
		{
			//logtype = SYSLOG_AUTO_FILE;
			(*syslog_local).flags.bLogOpenAppend = 0;
			(*syslog_local).flags.bLogOpenBackup = 1;
			(*syslog_local).flags.bLogProgram = 1;
		}
		// set all default parts of the name.
		// this overrides options with options available from SQL database.
		if( SACK_GetProfileIntEx( GetProgramName(), WIDE("SACK/Logging/Default Log Location is current directory"), 0, TRUE ) )
		{
			// override filepath, if log exception.
			TEXTCHAR buffer[256];
			GetCurrentPath( buffer, sizeof( buffer ) );
			SetDefaultName( buffer, NULL, NULL );
		}
		else if( SACK_GetProfileIntEx( GetProgramName(), WIDE("SACK/Logging/Default Log Location is exectuable directory"), 0, TRUE ) )
		{
			SetDefaultName( GetProgramPath(), NULL, NULL );
		}
		else if( SACK_GetProfileIntEx( GetProgramName(), WIDE("SACK/Logging/Default Log Location is common data directory"), 1, TRUE ) )
		{
			SetDefaultName( NULL, NULL, NULL );
		}
		else
		{
			TEXTCHAR buffer[256];
			// if this is blank, then length result from getprofilestring is 0, and default is with the program.
			// so I'll lave functionality as expected for a default.
			SACK_GetProfileStringEx( GetProgramName(), WIDE( "SACK/Logging/Default Log Location" ), WIDE( "" ), buffer, sizeof( buffer ), TRUE );
			if( buffer[0] )
			{
				SetDefaultName( buffer, NULL, NULL );
			}
		}
#endif
		if( SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Send Log to UDP" ), 0, TRUE ) )
		{
			if( SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Broadcast UDP" ), 0, TRUE ) )
				logtype = SYSLOG_UDPBROADCAST;
			else
				logtype = SYSLOG_UDP;
		}
		nLogLevel = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Default Log Level (1001:all, 100:least)" ), nLogLevel, TRUE );
		// use the defaults; they may be overriden by reading the options.
		(*syslog_local).flags.bLogThreadID = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Log Thread ID" ), (*syslog_local).flags.bLogThreadID, TRUE );
		(*syslog_local).flags.bLogProgram = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Log Program" ), (*syslog_local).flags.bLogProgram, TRUE );
		(*syslog_local).flags.bLogSourceFile = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Log Source File" ), (*syslog_local).flags.bLogSourceFile, TRUE );
		if( SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Log CPU Tick Time and Delta" ), (*syslog_local).flags.bLogCPUTime, TRUE ) )
		{
			SystemLogTime( SYSLOG_TIME_CPU|SYSLOG_TIME_DELTA );
		}
		else if( SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Log Time as Delta" ), (*syslog_local).flags.bUseDeltaTime, TRUE ) )
		{
			SystemLogTime( SYSLOG_TIME_HIGH|SYSLOG_TIME_DELTA );
		}
		else if( SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Log Time" ), (*syslog_local).flags.bLogTime, TRUE ) )
		{
			if( SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Log Date" ), (*syslog_local).flags.bUseDay, TRUE ) )
			{
				SystemLogTime( SYSLOG_TIME_LOG_DAY|SYSLOG_TIME_HIGH );
			}
			else
				SystemLogTime( SYSLOG_TIME_HIGH );
		}
		else
			SystemLogTime( 0 );
		(*syslog_local).flags.bOptionsLoaded = 1;
	}
}
#endif
//static int init_complete;
void InitSyslog( int ignore_options )
{
#ifndef __STATIC_GLOBALS__
	if( syslog_local )
	{
#ifndef __NO_OPTIONS__
		if( !ignore_options )
			LoadOptions();
#endif
		return;
	}
	SimpleRegisterAndCreateGlobal( syslog_local );
	if( !(*syslog_local).flags.bInitialized )
#endif
	{
		//logtype = SYSLOG_FILE;
		//(*syslog_local).file = stderr;
#if defined( WIN32 )
		(*syslog_local).next_lprintf_tls = TlsAlloc();
#elif defined( __LINUX__ )
		pthread_key_create( &((*syslog_local).next_lprintf_tls), NULL );
#endif
		(*syslog_local).flags.bLogThreadID = 1;
		hSock = INVALID_SOCKET;
		(*syslog_local).hSyslogdSock = INVALID_SOCKET;
		bCPUTickWorks = 1;
 // default log EVERYTHING
		nLogLevel = LOG_NOISE-1;
#ifdef __ANDROID__
		{
			logtype = SYSLOG_SYSTEM;
 // default log EVERYTHING
			nLogLevel = LOG_NOISE + 1000;
			(*syslog_local).flags.bLogSourceFile = 1;
			(*syslog_local).flags.bUseDeltaTime = 1;
			(*syslog_local).flags.bLogCPUTime = 1;
			(*syslog_local).flags.bLogThreadID = 1;
			(*syslog_local).flags.bLogProgram = 0;
			SystemLogTime( SYSLOG_TIME_HIGH );
		}
#else
#  if defined( _DEBUG ) || 1
		{
#    if defined( __LINUX__ ) && 0
			logtype = SYSLOG_SOCKET_SYSLOGD;
			(*syslog_local).flags.bLogProgram = 1;
#    else
			/* using SYSLOG_AUTO_FILE option does not require this to be open.
			* it is opened on demand.
			*/
#      if !defined( DEFAULT_OUTPUT_STDERR )
			logtype = SYSLOG_AUTO_FILE;
#      else
			logtype = SYSLOG_FILE;
			(*syslog_local).file = stderr;
#      endif
			(*syslog_local).flags.bLogOpenBackup = 1;
			(*syslog_local).flags.bUseDeltaTime = 1;
			(*syslog_local).flags.bLogCPUTime = 1;
			(*syslog_local).flags.bUseDeltaTime = 1;
			(*syslog_local).flags.bLogCPUTime = 1;
			(*syslog_local).flags.bLogProgram = 0;
			SystemLogTime( SYSLOG_TIME_HIGH );
#    endif
 // default log EVERYTHING
			nLogLevel = LOG_NOISE + 1000;
			(*syslog_local).flags.bLogOpenAppend = 0;
			(*syslog_local).flags.bLogSourceFile = 1;
			(*syslog_local).flags.bLogThreadID = 1;
			//SetDefaultName( NULL, NULL, NULL );
			//lprintf( WIDE("Syslog Initializing, debug mode, startup programname.log\n") );
		}
#  else
		// stderr?
		logtype = SYSLOG_NONE;
		(*syslog_local).file = NULL;
#  endif
#endif
		(*syslog_local).flags.bInitialized = 1;
	}
#ifndef __NO_OPTIONS__
	if( !ignore_options )
		LoadOptions();
#else
	(*syslog_local).flags.bOptionsLoaded = 1;
#  ifndef __ANDROID__
	SetDefaultName( NULL, NULL, NULL );
#  endif
#endif
}
PRIORITY_PRELOAD( InitSyslogPreload, SYSLOG_PRELOAD_PRIORITY )
{
	InitSyslog( 1 );
}
// delay reading options (unless we had to because of a logging requirement) but all core
// logging should be disabled (usually) until after init.
// that will allow these to be set with interface.conf defaults.
// but still fairly early...
PRIORITY_PRELOAD( InitSyslogPreloadWithOptions, NAMESPACE_PRELOAD_PRIORITY + 1 )
{
	InitSyslog( 0 );
}
PRIORITY_PRELOAD( InitSyslogPreloadAllowGroups, DEFAULT_PRELOAD_PRIORITY + 1 )
{
	(*syslog_local).flags.group_ok = 1;
}
//----------------------------------------------------------------------------
CTEXTSTR GetTimeEx( int bUseDay )
{
	/* used by sqlite extension to support now() */
#ifdef _WIN32
#  ifndef WIN32
#    define WIN32 _WIN32
#  endif
#endif
#if defined( WIN32 ) && !defined( __ANDROID__ )
	static TEXTCHAR timebuffer[256];
	SYSTEMTIME st;
	GetLocalTime( &st );
	if( bUseDay )
		tnprintf( timebuffer, sizeof(timebuffer), WIDE("%02d/%02d/%d %02d:%02d:%02d")
		       , st.wMonth, st.wDay, st.wYear
		       , st.wHour, st.wMinute, st.wSecond );
	else
		tnprintf( timebuffer, sizeof(timebuffer), WIDE("%02d:%02d:%02d")
		       , st.wHour, st.wMinute, st.wSecond );
	return timebuffer;
#else
	static char timebuffer[256];
	struct tm *timething;
	time_t timevalnow;
	time(&timevalnow);
	timething = localtime( &timevalnow );
	strftime( timebuffer
				, sizeof( timebuffer )
				, (bUseDay)?"%m/%d/%Y %H:%M:%S":"%H:%M:%S"
			  , timething );
#endif
	return timebuffer;
}
CTEXTSTR GetTime( void )
{
	return GetTimeEx( (*syslog_local).flags.bUseDay );
}
CTEXTSTR GetPackedTime( void )
{
	/* used by sqlite extension to support now() */
#ifdef _WIN32
#  ifndef WIN32
#    define WIN32 _WIN32
#  endif
#endif
#if defined( WIN32 ) && !defined( __ANDROID__ )
	static TEXTCHAR timebuffer[256];
	SYSTEMTIME st;
	GetLocalTime( &st );
	tnprintf( timebuffer, sizeof(timebuffer), WIDE("%04d%02d%02d%02d%02d%02d")
	        , st.wYear
	        , st.wMonth, st.wDay
	        , st.wHour, st.wMinute, st.wSecond );
#else
	static char timebuffer[256];
	struct tm *timething;
	time_t timevalnow;
	time(&timevalnow);
	timething = localtime( &timevalnow );
	strftime( timebuffer
	        , sizeof( timebuffer )
	        , "%Y%m%d%H%M%S"
	        , timething );
#endif
	return timebuffer;
}
//----------------------------------------------------------------------------
 // no gettime of day - no milliseconds
#ifndef BCC16
static TEXTCHAR *GetTimeHigh( void )
{
#  if defined WIN32 && !defined( __ANDROID__ )
	 static TEXTCHAR timebuffer[256];
	static SYSTEMTIME _st;
	SYSTEMTIME st, st_save;
	if( (*syslog_local).flags.bUseDeltaTime )
	{
		GetLocalTime( &st );
		st_save = st;
		if( !_st.wYear )
			_st = st;
		st.wMilliseconds -= _st.wMilliseconds;
		if( st.wMilliseconds & 0x8000 )
		{
			st.wMilliseconds = (st.wMilliseconds+1000) & 0xFFFF;
			st.wSecond--;
		}
		st.wSecond -= _st.wSecond;
		if( st.wSecond & 0x8000 )
		{
			st.wSecond += 60;
			st.wMinute--;
		}
		st.wMinute -= _st.wMinute;
		if( st.wMinute & 0x8000 )
		{
			st.wMinute += 60;
			st.wHour--;
		}
		st.wHour -= _st.wHour;
		if( st.wHour & 0x8000 )
			st.wHour += 24;
		_st = st_save;
	}
	else
		GetLocalTime( &st );
	if( (*syslog_local).flags.bUseDay )
		tnprintf( timebuffer, sizeof(timebuffer), WIDE("%02d/%02d/%d %02d:%02d:%02d.%03d")
		        , st.wMonth, st.wDay, st.wYear
		        , st.wHour, st.wMinute, st.wSecond, st.wMilliseconds );
	else
		tnprintf( timebuffer, sizeof(timebuffer), WIDE("%02d:%02d:%02d.%03d")
		        , st.wHour, st.wMinute, st.wSecond, st.wMilliseconds );
#  else
	static char timebuffer[256];
	static struct timeval _tv;
	static struct tm _tm;
	struct timeval tv, tv_save;
	struct tm *timething, tm, tm_save;
	int len;
	gettimeofday( &tv, NULL );
	if( (*syslog_local).flags.bUseDeltaTime )
	{
		tv_save = tv;
		timething = localtime( &tv.tv_sec );
		tm = tm_save = *timething;
		if( !_tm.tm_year )
		{
			_tm = *timething;
			_tv = tv;
		}
		tv.tv_usec -= _tv.tv_usec;
		if( tv.tv_usec < 0 )
		{
			tv.tv_usec += 1000000;
			tm.tm_sec--;
		}
		tm.tm_sec -= _tm.tm_sec;
		if( tm.tm_sec < 0 )
		{
			tm.tm_sec += 60;
			tm.tm_min--;
		}
		tm.tm_min -= _tm.tm_min;
		if( tm.tm_min < 0 )
		{
			tm.tm_min += 60;
			tm.tm_hour--;
		}
		tm.tm_hour -= _tm.tm_hour;
		if( tm.tm_hour < 0 )
			tm.tm_hour += 24;
		_tm = tm_save;
		_tv = tv_save;
	}
	else
	{
		timething = localtime( &tv.tv_sec );
		tm = *timething;
	}
	len = strftime( timebuffer
	               , sizeof( timebuffer )
	               , ((*syslog_local).flags.bUseDay)?"%m/%d/%Y %H:%M:%S":"%H:%M:%S"
					  , &tm );
#  undef snprintf
	snprintf( timebuffer + len, 5, ".%03ld", tv.tv_usec / 1000 );
	/*
	// this code is kept in case borland's compiler don't like it.
	{
		time_t timevalnow;
		time(&timevalnow);
		timething = localtime( &timevalnow );
		strftime( timebuffer
		        , sizeof( timebuffer )
		        , WIDE("%m/%d/%Y %H:%M:%S.000")
		        , timething );
	}
	*/
#  endif
	return timebuffer;
}
#else
#  define GetTimeHigh GetTime
#endif
uint32_t ConvertTickToMicrosecond( uint64_t tick )
{
	if( bCPUTickWorks )
	{
		if( !cpu_tick_freq )
			GetCPUFrequency();
		if( !cpu_tick_freq )
			return 0;
		return (uint32_t)(tick / cpu_tick_freq);
	}
	else
		return (uint32_t)tick;
}
void PrintCPUDelta( TEXTCHAR *buffer, size_t buflen, uint64_t tick_start, uint64_t tick_end )
{
#ifdef COMPUTE_CPU_FREQUENCY
	if( !cpu_tick_freq )
		GetCPUFrequency();
	if( cpu_tick_freq )
		tnprintf( buffer, buflen, WIDE("%")_64f WIDE(".%03") _64f
				 , ((tick_end-tick_start) / cpu_tick_freq ) / 1000
				 , ((tick_end-tick_start) / cpu_tick_freq ) % 1000
				 );
	else
#endif
		tnprintf( buffer, buflen, WIDE("%")_64fs, tick_end - tick_start
			    );
}
static TEXTCHAR *GetTimeHighest( void )
{
	uint64_t tick;
	static TEXTCHAR timebuffer[64];
	tick = GetCPUTick();
	if( !(*syslog_local).lasttick2 )
		(*syslog_local).lasttick2 = tick;
	if( (*syslog_local).flags.bUseDeltaTime )
	{
#ifdef UNICODE
		size_t ofs = 0;
		tnprintf( timebuffer, sizeof( timebuffer ), WIDE("%20lld") WIDE(" "), tick );
		ofs += StrLen( timebuffer );
#else
		int ofs = tnprintf( timebuffer, sizeof( timebuffer ), WIDE("%20") _64fs WIDE(" "), tick );
#endif
		PrintCPUDelta( timebuffer + ofs, sizeof( timebuffer ) - ofs, (*syslog_local).lasttick2, tick );
		(*syslog_local).lasttick2 = tick;
	}
	else
		tnprintf( timebuffer, sizeof( timebuffer ), WIDE("%20") _64fs, tick );
	// have to find a generic way to get this from _asm( rdtsc );
	return timebuffer;
}
static CTEXTSTR GetLogTime( void )
{
	if( (*syslog_local).flags.bLogTime )
	{
		if( (*syslog_local).flags.bLogHighTime )
		{
			return GetTimeHigh();
		}
		else if( (*syslog_local).flags.bLogCPUTime )
		{
			return GetTimeHighest();
		}
		else
		{
			return GetTime();
		}
	}
	return WIDE("");
}
//----------------------------------------------------------------------------
#ifndef __DISABLE_UDP_SYSLOG__
#  if !defined( FBSD ) && !defined(__QNX__)
#    if defined( __MAC__ )
static SOCKADDR saLogBroadcast  = { 8, 2, { 0x02, 0x02, (char)0xff, (char)0xff, (char)0xff, (char)0xff } };
static SOCKADDR saLog  = { 8, 2, { 0x02, 0x02, 0x7f, 0x00, 0x00, 0x01 } };
static SOCKADDR saBind = { 8, 2, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } };
#    else
static SOCKADDR saLogBroadcast  = { 2, { 0x02, 0x02, (char)0xff, (char)0xff, (char)0xff, (char)0xff } };
static SOCKADDR saLog  = { 2, { 0x02, 0x02, 0x7f, 0x00, 0x00, 0x01 } };
static SOCKADDR saBind = { 2, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } };
#    endif
#  else
static SOCKADDR saLogBroadcast  = { 2, 0x02, 0x02, (char)0xff, (char)0xff, (char)0xff, (char)0xff };
static SOCKADDR saLog  = { 2, 0x02, 0x02, 0x7f, 0x00, 0x00, 0x01  };
static SOCKADDR saBind = { 2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  };
#  endif
static void UDPSystemLog( const TEXTCHAR *message )
{
#ifdef HAVE_IDLE
	while( (*syslog_local).bLogging )
		Idle();
#endif
	(*syslog_local).bLogging = 1;
	if( !(*syslog_local).bStarted )
	{
#ifdef _WIN32
#ifndef MAKEWORD
#define MAKEWORD(a,b) (((a)<<8)|(b))
#endif
  // used to start up the socket services...
		WSADATA ws;
		if( WSAStartup( MAKEWORD(1,1), &ws ) )
		{
			(*syslog_local).bLogging = 0;
			return;
		}
#endif
		(*syslog_local).bStarted = TRUE;
	}
	if( hSock == INVALID_SOCKET )
	{
		LOGICAL bEnable = TRUE;
		hSock = socket(PF_INET,SOCK_DGRAM,0);
		if( hSock == INVALID_SOCKET )
		{
			(*syslog_local).bLogging = 0;
			return;
		}
		if( bind(hSock,&saBind,sizeof(SOCKADDR)) )
		{
			closesocket( hSock );
			hSock = INVALID_SOCKET;
			(*syslog_local). bLogging = 0;
			return;
		}
#ifndef BCC16
		if( setsockopt( hSock, SOL_SOCKET
		              , SO_BROADCAST, (char*)&bEnable, sizeof( bEnable ) ) )
		{
			Log( WIDE("Failed to set sock opt - BROADCAST") );
		}
#endif
	}
	{
		//INDEX nSent;
		int nSend;
		static TEXTCHAR realmsg[1024];
 /*"[%s]"*/
		nSend = tnprintf( realmsg, sizeof( realmsg ), WIDE("%s")
				  //, pProgramName
		                , message );
		message = realmsg;
#ifdef __cplusplus_cli
		char *tmp = CStrDup( realmsg );
#  define SENDBUF tmp
#else
#  define SENDBUF message
#endif
		sendto( hSock, (const char *)SENDBUF, nSend, 0
		      , (logtype == SYSLOG_UDPBROADCAST)
		        ? &saLogBroadcast
		        : &saLog
		      , sizeof( SOCKADDR ) );
#ifdef __cplusplus_cli
		Release( tmp );
#endif
		if( logtype != SYSLOG_UDPBROADCAST )
 // allow logging agents time to pick this up...
			Relinquish();
	}
	(*syslog_local).bLogging = 0;
}
#endif
//----------------------------------------------------------------------------
#ifdef __LINUX__
#  ifndef __DISABLE_SYSLOGD_SYSLOG__
#    if !defined( FBSD ) && !defined(__QNX__)
#       if defined( __MAC__ )
static struct sockaddr_un saSyslogdAddr  = { 11, AF_UNIX, "/dev/log" };
#       else
static struct sockaddr_un saSyslogdAddr  = { AF_UNIX, "/dev/log" };
#       endif
#    else
static struct sockaddr_un saSyslogdAddr  = { AF_UNIX, {"/dev/log"} };
#    endif
static void SyslogdSystemLog( const TEXTCHAR *message )
{
	while( (*syslog_local).bSyslogdLogging )
#    ifdef HAVE_IDLE
		Idle();
#    else
		Relinquish();
#    endif
	//fprintf( stderr, "present." );
	(*syslog_local).bSyslogdLogging = 1;
	if( (*syslog_local).hSyslogdSock == INVALID_SOCKET )
	{
		(*syslog_local).hSyslogdSock = socket(AF_UNIX,SOCK_DGRAM,0);
		if( (*syslog_local).hSyslogdSock == INVALID_SOCKET )
		{
			//fprintf( stderr, "failed..." );
			(*syslog_local).bSyslogdLogging = 0;
			return;
		}
		if(connect((*syslog_local).hSyslogdSock,(struct sockaddr *)&saSyslogdAddr,sizeof(saSyslogdAddr)) )
		{
			//fprintf( stderr, "failed..." );
			closesocket( (*syslog_local).hSyslogdSock );
			(*syslog_local).hSyslogdSock = INVALID_SOCKET;
			(*syslog_local).bSyslogdLogging = 0;
			return;
		}
	}
	if( (*syslog_local).hSyslogdSock != INVALID_SOCKET )
	{
		if( send( (*syslog_local).hSyslogdSock, message, StrLen( message ), 0 ) == 0 )
		{
			//fprintf( stderr, "failed..." );
			closesocket( (*syslog_local).hSyslogdSock );
			(*syslog_local).hSyslogdSock = INVALID_SOCKET;
		}
	}
	(*syslog_local).bSyslogdLogging = 0;
}
#  endif
#endif
#ifdef __LINUX__
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
LOGICAL IsBadReadPtr( CPOINTER pointer, uintptr_t len )
{
	static FILE *maps;
	//return FALSE;
	//DebugBreak();
	if( !maps )
		maps = fopen( "/proc/self/maps", "rt" );
	else
		fseek( maps, 0, SEEK_SET );
	//fprintf( stderr, WIDE("Testing a pointer..\n") );
	if( maps )
	{
		uintptr_t ptr = (uintptr_t)pointer;
		char line[256];
		while( fgets( line, sizeof(line)-1, maps ) )
		{
			uintptr_t low, high;
			sscanf( line, "%" cPTRSZVALfx "-%" cPTRSZVALfx, &low, &high );
			//fprintf( stderr, WIDE("%s") WIDE("Find: %08") PTRSZVALfx WIDE(" Low: %08") PTRSZVALfx WIDE(" High: %08") PTRSZVALfx WIDE("\n")
			//		 , line, pointer, low, high );
			if( ptr >= low && ptr <= high )
			{
				return FALSE;
			}
		}
	}
	//fprintf( stderr, WIDE("%p is not valid. %d"), pointer, errno );
	return TRUE;
}
//---------------------------------------------------------------------------
#endif
static void FileSystemLog( CTEXTSTR message )
{
	if( (*syslog_local).file )
	{
#ifdef SUPPORT_LOG_ALLOCATE
		fputs( message, (*syslog_local).file );
		fputs( "\n", (*syslog_local).file );
		fflush( (*syslog_local).file );
#else
#  ifdef UNICODE
		fputws( message, (*syslog_local).file );
		fputws( WIDE("\n"), (*syslog_local).file );
#  else
		sack_fputs( message, (*syslog_local).file );
		sack_fputs( "\n", (*syslog_local).file );
#  endif
		sack_fflush( (*syslog_local).file );
#endif
	}
}
static void BackupFile( const TEXTCHAR *source, int source_name_len, int n )
{
	FILE *testfile;
	INDEX group;
	testfile = sack_fsopenEx( group = GetFileGroup( WIDE( "system.logs" ), GetProgramPath() ), source, WIDE("rt"), _SH_DENYWR, NULL );
	if( testfile )
	{
		TEXTCHAR backup[256];
		sack_fclose( testfile );
		// move file to backup..
		tnprintf( backup, sizeof( backup ), WIDE("%*.*s.%d")
				  , source_name_len
				  , source_name_len
				  , source, n );
		if( n < 10 )
		{
			BackupFile( backup
							, source_name_len
							, n+1 );
		}
		else
			sack_unlink( group, source );
		//lprintf( WIDE( "%s->%s" ), source, backup );
		sack_rename( source, backup );
	}
}
void DoSystemLog( const TEXTCHAR *buffer )
{
#ifndef __STATIC_GLOBALS__
	if( !syslog_local )
	{
		InitSyslog( 1 );
		if( logtype == SYSLOG_AUTO_FILE && !(*syslog_local).file )
		{
			// cannot log until system log is complete
			return;
		}
		if( ( logtype == SYSLOG_UDPBROADCAST ) || ( logtype == SYSLOG_UDP ) )
			return;
	}
#endif
#ifdef __LINUX__
#  ifndef __DISABLE_SYSLOGD_SYSLOG__
	if( logtype == SYSLOG_SOCKET_SYSLOGD )
		SyslogdSystemLog( buffer );
#  endif
#endif
#ifndef __DISABLE_UDP_SYSLOG__
	if( logtype == SYSLOG_UDP
		|| logtype == SYSLOG_UDPBROADCAST )
		UDPSystemLog( buffer );
#else
	if( 0 )
		;
#endif
	else if( ( logtype == SYSLOG_FILE ) || ( logtype == SYSLOG_AUTO_FILE ) )
	{
		if( logtype == SYSLOG_AUTO_FILE )
		{
			if( !(*syslog_local).file && gFilename )
			{
				int n_retry = 0;
			retry_again:
 // disable logging - internal functions might inadvertantly log something...
				logtype = SYSLOG_NONE;
				if(
#ifdef SUPPORT_LOG_ALLOCATE
					0 &&
#endif
					!(*syslog_local).flags.bOptionsLoaded )
				{
#ifdef SUPPORT_LOG_ALLOCATE
					(*syslog_local).file = fopen( gFilename, WIDE( "wt" ) );
#else
					(*syslog_local).file = sack_fsopen( 0, gFilename, WIDE("wt")
#  ifdef _UNICODE
						WIDE(", ccs=UNICODE")
#  endif
						, _SH_DENYWR );
#endif
				}
				else
				{
					if(
#ifdef SUPPORT_LOG_ALLOCATE
						0 &&
#endif
						(*syslog_local).flags.bLogOpenBackup )
					{
						BackupFile( gFilename, (int)StrLen( gFilename ), 1 );
					}
					else if( (*syslog_local).flags.bLogOpenAppend )
#ifdef SUPPORT_LOG_ALLOCATE
					(*syslog_local).file = fopen( gFilename, WIDE( "at+" ) );
#else
					(*syslog_local).file = sack_fsopen( (*syslog_local).flags.group_ok?GetFileGroup( WIDE( "system.logs" ), GetProgramPath() ):(INDEX)0, gFilename, WIDE("at+")
#  ifdef _UNICODE
						WIDE(", ccs=UNICODE")
#  endif
						, _SH_DENYWR );
#endif
					if( (*syslog_local).file )
						fseek( (*syslog_local).file, 0, SEEK_END );
					else
#ifdef SUPPORT_LOG_ALLOCATE
					(*syslog_local).file = fopen( gFilename, WIDE( "wt" ) );
#else
					(*syslog_local).file = sack_fsopenEx( (*syslog_local).flags.group_ok?GetFileGroup( WIDE( "system.logs" ), GetProgramPath() ):(INDEX)0, gFilename, WIDE("wt")
#  ifdef _UNICODE
							WIDE(", ccs=UNICODE")
#  endif
							, _SH_DENYWR, NULL );
#endif
				}
				//logtype = SYSLOG_AUTO_FILE;
				if( !(*syslog_local).file )
				{
					if( n_retry < 500 )
					{
						TEXTCHAR tmp[10];
						tnprintf( tmp, sizeof( tmp ), WIDE("%d"), n_retry++ );
						SetDefaultName( NULL, NULL, tmp );
						goto retry_again;
					}
					else
						// can't open the logging file, stop trying now, will save us trouble in the future
						logtype = SYSLOG_NONE;
				}
				logtype = SYSLOG_AUTO_FILE;
			}
		}
		FileSystemLog( buffer );
	}
#if defined( _WIN32 ) || defined( __ANDROID__ )
	else if( logtype == SYSLOG_SYSTEM )
	{
#  ifdef __cplusplus_cli
		// requires referenced xperdex.classes... if this doesn't compile, please add the reference
		//xperdex::classes::Log::log( gcnew System::String( buffer ) );
		//System::Console::WriteLine( gcnew System::String( buffer ) );
		//System::Diagnostics::Debug
#  else
#    ifdef __ANDROID__
		{
			static char *program_string;
			char *string = CStrDup( buffer );
			if( !program_string )
				program_string = CStrDup( GetProgramName() );
			if( !program_string )
				program_string = "com.unknown.app";
			__android_log_print( ANDROID_LOG_INFO, program_string, string );
			Release( string );
		}
#    else
		OutputDebugString( buffer );
		OutputDebugString( "\n" );
#    endif
#  endif
	}
	else
#endif
	if( logtype == SYSLOG_CALLBACK )
		(*syslog_local).UserCallback( buffer );
}
	static uint32_t openLock;
	static uint32_t lowLevelLock;
void SystemLogFL( const TEXTCHAR *message FILELINE_PASS )
{
	static TEXTCHAR buffer[4096];
	static TEXTCHAR threadid[32];
	static TEXTCHAR sourcefile[256];
	CTEXTSTR logtime;
#ifndef __STATIC_GLOBALS__
	if( !syslog_local )
	{
		if( !openLock ) {
			openLock = 1;
			InitSyslog( 1 );
		} else
			return;
		openLock = 0;
	}
#endif
	if( cannot_log )
		return;
	if( !(*syslog_local).flags.group_ok && openLock )
		return;
#ifdef WIN32
	while( InterlockedExchange( (long volatile*)&lowLevelLock, 1 ) ) Relinquish();
#else
	while( LockedExchange( &lowLevelLock, 1 ) ) Relinquish();
#endif
	logtime = GetLogTime();
	if( (*syslog_local).flags.bLogSourceFile && pFile )
	{
#ifndef _LOG_FULL_FILE_NAMES
		CTEXTSTR p;
		for( p = pFile + StrLen(pFile) -1;p > pFile;p-- )
			if( p[0] == '/' || p[0] == '\\' )
			{
				pFile = p+1;break;
			}
#endif
		tnprintf( sourcefile, sizeof( sourcefile ), WIDE("") FILELINE_FILELINEFMT  FILELINE_RELAY );
	}
	else
		sourcefile[0] = 0;
	if( (*syslog_local).flags.bLogThreadID )
		tnprintf( threadid, sizeof( threadid ), WIDE("%012") _64fX WIDE("~"), GetMyThreadID() );
	if( pFile )
		tnprintf( buffer, sizeof( buffer )
				  , WIDE("%s%s%s%s%s%s%s")
				  , logtime, logtime[0]?WIDE("|"):WIDE("")
				  , (*syslog_local).flags.bLogThreadID?threadid:WIDE("")
				  , (*syslog_local).flags.bLogProgram?(GetProgramName()):WIDE("")
				  , (*syslog_local).flags.bLogProgram?WIDE("@"):WIDE("")
				  , (*syslog_local).flags.bLogSourceFile?sourcefile:WIDE("")
				  , message );
	else
		tnprintf( buffer, sizeof( buffer )
				  , WIDE("%s%s%s%s%s%s")
				  , logtime, logtime[0]?WIDE("|"):WIDE("")
				  , (*syslog_local).flags.bLogThreadID?threadid:WIDE("")
				  , (*syslog_local).flags.bLogProgram?(GetProgramName()):WIDE("")
				  , (*syslog_local).flags.bLogProgram?WIDE("@"):WIDE("")
				  , message );
	DoSystemLog( buffer );
	lowLevelLock = 0;
}
#undef SystemLogEx
void SystemLogEx ( const TEXTCHAR *message DBG_PASS )
{
#ifdef _DEBUG
	SystemLogFL( message DBG_RELAY );
#else
	SystemLogFL( message FILELINE_NULL );
#endif
}
#undef SystemLog
 void  SystemLog ( const TEXTCHAR *message )
{
	SystemLogFL( message, NULL, 0 );
}
 void  LogBinaryFL ( const uint8_t* buffer, size_t size FILELINE_PASS )
{
	size_t nOut = size;
	const uint8_t* data = buffer;
#ifndef _LOG_FULL_FILE_NAMES
	if( pFile )
	{
		CTEXTSTR p;
		for( p = pFile + (pFile?StrLen(pFile) -1:0);p > pFile;p-- )
			if( p[0] == '/' || p[0] == '\\' )
			{
				pFile = p+1;break;
			}
	}
#endif
	// should make this expression something in signed_usigned_comparison...
	while( nOut && !( nOut & ( ((size_t)1) << ( ( sizeof( nOut ) * CHAR_BIT ) - 1 ) ) ) )
	{
		TEXTCHAR cOut[96];
		size_t ofs = 0;
		size_t x;
		ofs = 0;
		for ( x=0; x<nOut && x<16; x++ )
			ofs += tnprintf( cOut+ofs, sizeof(cOut)/sizeof(TEXTCHAR)-ofs, WIDE("%02X "), (unsigned char)data[x] );
		// space fill last partial buffer
		for( ; x < 16; x++ )
			ofs += tnprintf( cOut+ofs, sizeof(cOut)/sizeof(TEXTCHAR)-ofs, WIDE("   ") );
		for ( x=0; x<nOut && x<16; x++ )
		{
			if( data[x] >= 32 && data[x] < 127 )
				ofs += tnprintf( cOut+ofs, sizeof(cOut)/sizeof(TEXTCHAR)-ofs, WIDE("%c"), (unsigned char)data[x] );
			else
				ofs += tnprintf( cOut+ofs, sizeof(cOut)/sizeof(TEXTCHAR)-ofs, WIDE(".") );
		}
		SystemLogFL( cOut FILELINE_RELAY );
		nOut -= x;
		data += x;
	}
}
#undef LogBinaryEx
 void  LogBinaryEx ( const uint8_t* buffer, size_t size DBG_PASS )
{
#ifdef _DEBUG
	LogBinaryFL( buffer,size DBG_RELAY );
#else
	LogBinaryFL( buffer,size FILELINE_NULL );
#endif
}
#undef LogBinary
 void  LogBinary ( const uint8_t* buffer, size_t size )
{
	LogBinaryFL( buffer,size, NULL, 0 );
}
void  SetSystemLog ( enum syslog_types type, const void *data )
{
	if( (*syslog_local).file && ( logtype != SYSLOG_FILE ) )
	{
		FILE *close_file = (*syslog_local).file;
  // reset this first, in case logging closing.
		(*syslog_local).file = NULL;
		sack_fclose( close_file );
	}
	if( type == SYSLOG_FILE )
	{
		if( data )
		{
			logtype = type;
			(*syslog_local).file = (FILE*)data;
		}
	}
	else if( type == SYSLOG_FILENAME )
	{
		FILE *log;
		log = sack_fsopen( GetFileGroup( WIDE( "system.logs" ), GetProgramPath() ), (CTEXTSTR)data, WIDE("wt")
#ifdef _UNICODE
				WIDE(", ccs=UNICODE")
#endif
				, _SH_DENYWR );
		(*syslog_local).file = log;
		logtype = SYSLOG_FILE;
	}
	else if( type == SYSLOG_CALLBACK )
	{
		(*syslog_local).UserCallback = (UserLoggingCallback)data;
	}
	else
	{
		logtype = type;
	}
	//SystemLog( WIDE("thing is: ") STRSYM( (SYSLOG_EXTERN) ) );
}
 void  SystemLogTime ( LOGICAL enable )
{
	(*syslog_local).flags.bLogTime = FALSE;
	(*syslog_local).flags.bUseDay = FALSE;
	(*syslog_local).flags.bUseDeltaTime = FALSE;
	(*syslog_local).flags.bLogHighTime = FALSE;
	(*syslog_local).flags.bLogCPUTime = FALSE;
	if( enable )
	{
		(*syslog_local).flags.bLogTime = TRUE;
		if( enable & SYSLOG_TIME_HIGH )
			(*syslog_local).flags.bLogHighTime = TRUE;
		if( enable & SYSLOG_TIME_LOG_DAY )
			(*syslog_local).flags.bUseDay = TRUE;
		if( enable & SYSLOG_TIME_DELTA )
			(*syslog_local).flags.bUseDeltaTime = TRUE;
		if( enable & SYSLOG_TIME_CPU )
			(*syslog_local).flags.bLogCPUTime = TRUE;
	}
}
// information for the call to _real_lprintf file and line information...
struct next_lprint_info{
	// please use this enter when resulting a function, and leave from said function.
	// oh - but then we couldn't exist before crit sec code...
	//CRITICALSECTION cs;
	uint32_t nLevel;
	CTEXTSTR pFile;
	int nLine;
};
#define next_lprintf (*_next_lprintf)
static struct next_lprint_info *GetNextInfo( void )
{
	struct next_lprint_info *next;
#ifdef USE_CUSTOM_ALLOCER
#  if defined( WIN32 )
	if( !( next = (struct next_lprint_info*)TlsGetValue( (*syslog_local).next_lprintf_tls ) ) )
		TlsSetValue( (*syslog_local).next_lprintf_tls, next = (struct next_lprint_info*)malloc( sizeof( struct next_lprint_info ) ) );
#  elif defined( __LINUX__ )
	if( !( next = (struct next_lprint_info*)pthread_getspecific( (*syslog_local).next_lprintf_tls ) ) )
		pthread_setspecific( (*syslog_local).next_lprintf_tls, next = New( struct next_lprint_info ) );
#  endif
#else
#  if defined( WIN32 )
	if( !(next = (struct next_lprint_info*)TlsGetValue( (*syslog_local).next_lprintf_tls )) )
		TlsSetValue( (*syslog_local).next_lprintf_tls, next = New( struct next_lprint_info ) );
#  elif defined( __LINUX__ )
	if( !(next = (struct next_lprint_info*)pthread_getspecific( (*syslog_local).next_lprintf_tls )) )
		pthread_setspecific( (*syslog_local).next_lprintf_tls, next = New( struct next_lprint_info ) );
#  endif
#endif
	return next;
}
static INDEX CPROC _null_vlprintf ( CTEXTSTR format, va_list args )
{
	return 0;
}
static INDEX CPROC _real_vlprintf ( CTEXTSTR format, va_list args )
{
#ifdef _DEBUG
	// this can be used to force logging early to stdout
	struct next_lprint_info *_next_lprintf = GetNextInfo();
#endif
	if( cannot_log )
		return 0;
	if( logtype != SYSLOG_NONE )
	{
		CTEXTSTR logtime = GetLogTime();
		size_t ofs;
		// because of threading concerns... either I dynamically allocate this...
		// or lock it.... or ...
		TEXTCHAR *buffer;
		TEXTCHAR threadid[32];
		cannot_log = 1;
		if( !(*syslog_local).buffers )
		{
			int n;
			(*syslog_local).buffers = CreateLinkQueue();
			for( n = 0; n < 6; n++ )
				EnqueLink( &(*syslog_local).buffers, (POINTER)1 );
			for( n = 0; n < 6; n++ )
				DequeLink( &(*syslog_local).buffers );
		}
		buffer = (TEXTCHAR*)DequeLink( &(*syslog_local).buffers );
		if( !buffer )
		{
			//DoSystemLog( WIDE( "Adding Logging Buffer" ) );
			buffer = NewArray( TEXTCHAR, 4096 );
		}
		// at this point we're not doing internal allocations...
		cannot_log = 0;
		if( logtime[0] )
#ifdef UNDER_CE
		{
			StringCbPrintf( buffer, 4096, WIDE("%s|")
							  , logtime );
			ofs = StrLen( buffer );
		}
#else
			ofs = tnprintf( buffer, 4095, WIDE("%s|")
							  , logtime );
#endif
		else
			ofs = 0;
		// argsize - the program's giving us file and line
		// debug for here or not, this must be used.
		if( (*syslog_local).flags.bLogThreadID )
			tnprintf( threadid, sizeof( threadid ), WIDE("%012") _64fX WIDE("~"), GetMyThreadID() );
#ifdef UNDER_CE
		tnprintf( buffer + ofs, 4095 - ofs, WIDE("%s%s%s")
				  , (*syslog_local).flags.bLogThreadID?threadid:WIDE("")
				  , (*syslog_local).flags.bLogProgram?GetProgramName():WIDE("")
				  , (*syslog_local).flags.bLogProgram?WIDE("@"):WIDE("")
				  );
		ofs += StrLen( buffer + ofs );
#else
		tnprintf( buffer + ofs, 4095 - ofs, WIDE("%s%s%s")
				  , (*syslog_local).flags.bLogThreadID?threadid:WIDE("")
				  , (*syslog_local).flags.bLogProgram?GetProgramName():WIDE("")
				  , (*syslog_local).flags.bLogProgram?WIDE("@"):WIDE("")
				  );
		ofs += StrLen( buffer + ofs );
#endif
		{
#ifdef _DEBUG
			CTEXTSTR pFile;
#ifndef _LOG_FULL_FILE_NAMES
			CTEXTSTR p;
#endif
			uint32_t nLine;
			if( (*syslog_local).flags.bLogSourceFile && ( pFile = next_lprintf.pFile ) )
			{
				if( (*syslog_local).flags.bProtectLoggedFilenames )
					if( IsBadReadPtr( pFile, 2 ) )
						pFile = WIDE("(Unloaded file?)");
#   ifndef _LOG_FULL_FILE_NAMES
				for( p = pFile + StrLen(pFile) -1;p > pFile;p-- )
					if( p[0] == '/' || p[0] == '\\' )
					{
						pFile = p+1;break;
					}
#   endif
				nLine = next_lprintf.nLine;
#   ifdef UNDER_CE
				tnprintf( buffer + ofs, 4095 - ofs, WIDE("%s(%") _32f WIDE("):")
									, pFile, nLine );
				ofs += StrLen( buffer + ofs );
#   else
				tnprintf( buffer + ofs, 4095 - ofs, WIDE("%s(%") _32f WIDE("):")
									, pFile, nLine );
				ofs += StrLen( buffer + ofs );
#   endif
			}
#endif
#ifdef UNICODE
			vswprintf( buffer + ofs, 4095 - ofs, format, args );
#else
			vsnprintf( buffer + ofs, 4095 - ofs, format, args );
#endif
			// okay, so even the above is unsafe, because Micro$oft has
			// decreed to be stupid.
			buffer[4095] = 0;
		}
		DoSystemLog( buffer );
		{
			cannot_log = 1;
			EnqueLink( &(*syslog_local).buffers, buffer );
			cannot_log = 0;
		}
	}
	//LeaveCriticalSec( &next_lprintf.cs );
	return 0;
}
static INDEX CPROC _real_lprintf( CTEXTSTR f, ... )
{
	va_list args;
	va_start( args, f );
	return _real_vlprintf( f, args );
}
static INDEX CPROC _null_lprintf( CTEXTSTR f, ... )
{
	return 0;
}
RealVLogFunction  _vxlprintf ( uint32_t level DBG_PASS )
{
	struct next_lprint_info *_next_lprintf;
	//EnterCriticalSec( &next_lprintf.cs );
	_next_lprintf = GetNextInfo();
	next_lprintf.nLevel = level;
#if _DEBUG
	next_lprintf.pFile = pFile;
	next_lprintf.nLine = nLine;
#endif
	if( level & LOG_CUSTOM )
	{
		if( !(level & nLogCustom) )
			return _null_vlprintf;
		return _real_vlprintf;
	}
	else if( level <= nLogLevel )
	{
		return _real_vlprintf;
	}
	return _null_vlprintf;
}
RealLogFunction _xlprintf( uint32_t level DBG_PASS )
{
	struct next_lprint_info *_next_lprintf;
	//EnterCriticalSec( &next_lprintf.cs );
#ifndef __STATIC_GLOBALS__
	if( !syslog_local )
	{
		if( !openLock ) {
			openLock = 1;
			InitSyslog( 1 );
		} else
			return _null_lprintf;
		//return _null_lprintf;
		openLock = 0;
	}
#endif
	_next_lprintf = GetNextInfo();
#if _DEBUG
	next_lprintf.pFile = pFile;
	next_lprintf.nLine = nLine;
#endif
	if( level & LOG_CUSTOM )
	{
		if( !(level & nLogCustom) )
			return _null_lprintf;
		next_lprintf.nLevel = level;
		return _real_lprintf;
	}
	else if( level <= nLogLevel )
	{
		next_lprintf.nLevel = level;
		return _real_lprintf;
	}
	return _null_lprintf;
}
#ifdef __WATCOMC__
// # again - WATCOM Compiler warning here, function
// defined, but never referenced.  This is true,
// but when the linker comes around to it, it cares for the
// presense of this function in order to force floating support
// for printf and scanf, since this is module is passed ANY
// format and ANY paramter, it may require floating point.
// no special handling required for GCC, lcc, MSVC
static int f(void )
{
	extern int fltused_;
	return fltused_ + (int)f;
	//int n = fltused_; // force inclusion of math libs...
}
#endif
void ProtectLoggedFilenames( LOGICAL bEnable )
{
	(*syslog_local).flags.bProtectLoggedFilenames = bEnable;
}
void SetSystemLoggingLevel( uint32_t nLevel )
{
	if( nLevel & LOG_CUSTOM )
	{
		nLogCustom |= nLevel & ( LOG_CUSTOM_BITS );
	}
	else if( nLevel & LOG_CUSTOM_DISABLE )
	{
		nLogCustom &= ~( nLevel & ( LOG_CUSTOM_BITS ) );
	}
	else
		nLogLevel = nLevel;
}
void SetSyslogOptions( FLAGSETTYPE *options )
{
	// the mat operations don't turn into valid bitfield operators. (watcom)
 // open for append, else open for write
	(*syslog_local).flags.bLogOpenAppend = TESTFLAG( options, SYSLOG_OPT_OPENAPPEND )?1:0;
 // open for append, else open for write
	(*syslog_local).flags.bLogOpenBackup = TESTFLAG( options, SYSLOG_OPT_OPEN_BACKUP )?1:0;
 // open for append, else open for write
	(*syslog_local).flags.bLogProgram = TESTFLAG( options, SYSLOG_OPT_LOG_PROGRAM_NAME )?1:0;
 // open for append, else open for write
	(*syslog_local).flags.bLogThreadID = TESTFLAG( options, SYSLOG_OPT_LOG_THREAD_ID )?1:0;
 // open for append, else open for write
	(*syslog_local).flags.bLogSourceFile = TESTFLAG( options, SYSLOG_OPT_LOG_SOURCE_FILE )?1:0;
}
#ifdef __cplusplus_cli
static public ref class Log
{
public:
	static void log( System::String^ ouptut )
	{
				pin_ptr<const WCHAR> _output = PtrToStringChars(ouptut);
				TEXTSTR __ouptut = DupWideToText( _output );
		lprintf( WIDE("%s"), __ouptut );
		Release( __ouptut );
	}
};
#endif
#ifdef __cplusplus
LOGGING_NAMESPACE_END
#endif
//---------------------------------------------------------------------------
// $Log: syslog.c,v $
// Revision 1.74  2005/05/30 11:56:36  d3x0r
// various fixes... working on psilib update optimization... various stabilitizations... also extending msgsvr functionality.
//
// < --- CUT ALL LOGGING --- >
//
// Revision 1.56  2003/12/04 10:41:30  panther
// remove watcom compile only option code
//
//
//#define DEBUG_LIBRARY_LOADING
#define NO_UNICODE_C
#define SYSTEM_CORE_SOURCE
#define FIX_RELEASE_COM_COLLISION
#define TASK_INFO_DEFINED
#ifndef NO_FILEOP_ALIAS
#  define NO_FILEOP_ALIAS
#endif
#ifdef WIN32
//#undef StrDup
//#undef StrRChr
#endif
#ifdef WIN32
#include <tlhelp32.h>
#include <psapi.h>
#endif
#ifdef __QNX__
#include <devctl.h>
#include <sys/procfs.h>
#endif
#ifdef __LINUX__
#include <sys/wait.h>
extern char **environ;
#  ifndef __MAC__
#    include <elf.h>
#  endif
#endif
#ifdef __cplusplus
using namespace sack::timers;
#endif
//--------------------------------------------------------------------------
struct task_info_tag;
SACK_SYSTEM_NAMESPACE
//typedef void (CPROC*TaskEnd)(uintptr_t, struct task_info_tag *task_ended);
typedef struct handle_info_tag
{
	//struct mydatapath_tag *pdp;
 // partial inputs...
   PTEXT pLine;
   char *name;
	int       bNextNew;
   PTHREAD   hThread;
#ifdef WIN32
   // read/write handle
   HANDLE    handle;
#else
   int       pair[2];
   // read/write handle
   int       handle;
#endif
} HANDLEINFO, *PHANDLEINFO;
//typedef void (CPROC*TaskEnd)(uintptr_t, struct task_info_tag *task_ended);
struct task_info_tag {
	struct {
		BIT_FIELD closed : 1;
		BIT_FIELD process_ended : 1;
		BIT_FIELD bSentIoTerminator : 1;
		BIT_FIELD log_input : 1;
	} flags;
	TaskEnd EndNotice;
	TaskOutput OutputEvent;
	uintptr_t psvEnd;
	HANDLEINFO hStdIn;
	HANDLEINFO hStdOut;
	volatile PTHREAD pOutputThread;
	//HANDLEINFO hStdErr;
#if defined(WIN32)
	HANDLE hReadOut, hWriteOut;
	//HANDLE hReadErr, hWriteErr;
	HANDLE hReadIn, hWriteIn;
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
   DWORD exitcode;
#elif defined( __LINUX__ )
   int hReadOut, hWriteOut;
   //HANDLE hReadErr, hWriteErr;
	int hReadIn, hWriteIn;
   pid_t pid;
   uint32_t exitcode;
#endif
};
typedef struct loaded_function_tag
{
	uint32_t references;
	void (CPROC*function)(void );
	struct loaded_library_tag *library;
	DeclareLink( struct loaded_function_tag );
  // can be an integer value... instead of a string...
	CTEXTSTR name;
 // this is more than 1; allocation pads extra bytes for the name.
	TEXTCHAR _name[1];
} FUNCTION, *PFUNCTION;
#ifdef WIN32
typedef HMODULE HLIBRARY;
#else
typedef void* HLIBRARY;
#endif
typedef struct loaded_library_tag
{
 // when unloading...
	uintptr_t nLibrary;
	HLIBRARY library;
	LOGICAL mapped;
	PFUNCTION functions;
	DeclareLink( struct loaded_library_tag );
 // points into full_name after last slash - just library name
	TEXTCHAR *name;
	int loading;
// this is appended after full_name and is l.library_path
	TEXTCHAR *alt_full_name;
// this is more than 1; allocation pads extra bytes for the name. prefixed iwth l.load_path
	TEXTCHAR full_name[1];
} LIBRARY, *PLIBRARY;
#ifndef SYSTEM_CORE_SOURCE
extern
#endif
  struct local_systemlib_data {
	CTEXTSTR load_path;
	CTEXTSTR library_path;
	CTEXTSTR common_data_path;
	struct system_local_flags{
		BIT_FIELD bLog : 1;
		BIT_FIELD bInitialized : 1;
	} flags;
  // pointer to just filename part...
	CTEXTSTR filename;
	TEXTCHAR *work_path;
	PLIST system_tasks;
	PLIBRARY libraries;
	PTREEROOT pFunctionTree;
	int nLibrary;
	LOGICAL (CPROC*ExternalLoadLibrary)( const char *filename );
 // please Release or Deallocate the reutrn value
	char * (CPROC*ExternalFindProgram)( const char *filename );
	// on XP this is in PSAPI.DLL later it's in Kernel32.DLL
#ifdef WIN32
	BOOL (WINAPI* EnumProcessModules)( HANDLE hProcess, HMODULE *lphModule
	                                 , DWORD cb, LPDWORD lpcbNeeded );
#endif
} *local_systemlib;
#ifdef l
#   undef l
#endif
#define l (*local_systemlib)
int TryShellExecute( PTASK_INFO task, CTEXTSTR path, CTEXTSTR program, PTEXT cmdline );
#ifdef __MAC__
//sourced from https://github.com/comex/myvmmap/blob/master/myvmmap.c Jan/7/2018
#  include <mach/mach.h>
#  if __IPHONE_OS_VERSION_MIN_REQUIRED
kern_return_t mach_vm_read_overwrite(vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, mach_vm_address_t data, mach_vm_size_t *outsize);
kern_return_t mach_vm_region(vm_map_t target_task, mach_vm_address_t *address, mach_vm_size_t *size, vm_region_flavor_t flavor, vm_region_info_t info, mach_msg_type_number_t *infoCnt, mach_port_t *object_name);
int proc_pidpath(int pid, void * buffer, uint32_t  buffersize);
int proc_regionfilename(int pid, uint64_t address, void * buffer, uint32_t buffersize);
#  else
#    include <mach/mach_vm.h>
#    include <libproc.h>
#  endif
//#include <stdio.h>
#  include <assert.h>
#  include <mach-o/loader.h>
#  include <mach-o/nlist.h>
//#include <string.h>
//#include <stdbool.h>
//#include <stdlib.h>
//#include <setjmp.h>
//#include <sys/queue.h>
//#include <sys/param.h>
#  if !__IPHONE_OS_VERSION_MIN_REQUIRED
#    include <Security/Security.h>
#  endif
#endif
//-------------------------------------------------------------------------
//  Function/library manipulation routines...
//-------------------------------------------------------------------------
typedef struct task_info_tag TASK_INFO;
#ifdef __ANDROID__
static CTEXTSTR program_name;
static CTEXTSTR program_path;
static CTEXTSTR library_path;
static CTEXTSTR working_path;
void SACKSystemSetProgramPath( char *path )
{
	program_path = DupCStr( path );
}
void SACKSystemSetProgramName( char *name )
{
	program_name = DupCStr( name );
}
void SACKSystemSetWorkingPath( char *name )
{
	working_path = DupCStr( name );
}
void SACKSystemSetLibraryPath( char *name )
{
	library_path = DupCStr( name );
}
#endif
#ifdef HAVE_ENVIRONMENT
CTEXTSTR OSALOT_GetEnvironmentVariable(CTEXTSTR name)
{
#ifdef WIN32
	static int env_size;
	static TEXTCHAR *env;
	int size;
	if( size = GetEnvironmentVariable( name, NULL, 0 ) )
	{
		if( size > env_size )
		{
			if( env )
				ReleaseEx( (POINTER)env DBG_SRC );
			env = NewArray( TEXTCHAR, size + 10 );
			env_size = size + 10;
		}
		if( GetEnvironmentVariable( name, env, env_size ) )
			return env;
	}
	return NULL;
#else
#ifdef UNICODE
	{
		char *tmpname = CStrDup( name );
		static TEXTCHAR *result;
		if( result )
			ReleaseEx( result DBG_SRC );
		result = DupCStr( getenv( tmpname ) );
		ReleaseEx( tmpname DBG_SRC );
	}
#else
	return getenv( name );
#endif
#endif
}
void OSALOT_SetEnvironmentVariable(CTEXTSTR name, CTEXTSTR value)
{
#if defined( WIN32 ) || defined( __CYGWIN__ )
	SetEnvironmentVariable( name, value );
#else
#ifdef UNICODE
	{
		char *tmpname = CStrDup( name );
		char * tmpvalue = CStrDup( value );
		setenv( tmpname, tmpvalue, TRUE );
		ReleaseEx( tmpname DBG_SRC );
		ReleaseEx( tmpvalue DBG_SRC );
	}
#else
	setenv( name, value, TRUE );
#endif
#endif
}
void OSALOT_AppendEnvironmentVariable(CTEXTSTR name, CTEXTSTR value)
{
#if defined( WIN32 ) || defined( __CYGWIN__ )
	TEXTCHAR *oldpath;
	TEXTCHAR *newpath;
	uint32_t length;
	{
		int oldlen;
		oldpath = NewArray( TEXTCHAR, oldlen = ( GetEnvironmentVariable( name, NULL, 0 ) + 1 ) );
		GetEnvironmentVariable( name, oldpath, oldlen );
	}
	newpath = NewArray( TEXTCHAR, length = (uint32_t)(StrLen( oldpath ) + 2 + StrLen(value)) );
#  ifdef UNICODE
	snwprintf( newpath, length, WIDE("%s;%s"), oldpath, value );
#  else
	snprintf( newpath, length, WIDE("%s;%s"), oldpath, value );
#  endif
	SetEnvironmentVariable( name, newpath );
	ReleaseEx( newpath DBG_SRC );
	ReleaseEx( oldpath DBG_SRC );
#else
#ifdef UNICODE
	char *tmpname = CStrDup( name );
	char *_oldpath = getenv( tmpname );
	TEXTCHAR *oldpath = DupCStr( _oldpath );
#else
	char *oldpath = getenv( name );
#endif
	TEXTCHAR *newpath;
	size_t maxlen;
	newpath = NewArray( TEXTCHAR, maxlen = ( StrLen( oldpath ) + StrLen( value ) + 2 ) );
	tnprintf( newpath, maxlen, WIDE("%s:%s"), oldpath, value );
#ifdef UNICODE
	{
		char * tmpvalue = CStrDup( newpath );
		setenv( tmpname, tmpvalue, TRUE );
		ReleaseEx( tmpvalue DBG_SRC );
	}
	ReleaseEx( oldpath DBG_SRC );
	ReleaseEx( tmpname DBG_SRC );
#else
	setenv( name, newpath, TRUE );
#endif
	ReleaseEx( newpath DBG_SRC );
#endif
}
void OSALOT_PrependEnvironmentVariable(CTEXTSTR name, CTEXTSTR value)
{
#if defined( WIN32 )|| defined( __CYGWIN__ )
	TEXTCHAR *oldpath;
	TEXTCHAR *newpath;
	int length;
	{
		int oldlen;
		oldpath = NewArray( TEXTCHAR, oldlen = ( GetEnvironmentVariable( name, NULL, 0 ) + 1 ) );
		GetEnvironmentVariable( name, oldpath, oldlen );
	}
	newpath = NewArray( TEXTCHAR, length = (uint32_t)(StrLen( oldpath ) + 2 + StrLen(value)) );
#  ifdef UNICODE
	snwprintf( newpath, length, WIDE("%s;%s"), value, oldpath );
#  else
	snprintf( newpath, length, WIDE("%s;%s"), value, oldpath );
#  endif
	SetEnvironmentVariable( name, newpath );
	ReleaseEx( newpath DBG_SRC );
	ReleaseEx( oldpath DBG_SRC );
#else
#ifdef UNICODE
	char *tmpname = CStrDup( name );
	char *_oldpath = getenv( tmpname );
	TEXTCHAR *oldpath = DupCStr( _oldpath );
#else
	char *oldpath = getenv( name );
#endif
	TEXTCHAR *newpath;
	int length;
	newpath = NewArray( TEXTCHAR, length = StrLen( oldpath ) + StrLen( value ) + 1 );
	tnprintf( newpath, length, WIDE("%s:%s"), value, oldpath );
#ifdef UNICODE
	{
		char *tmpname = CStrDup( name );
		char * tmpvalue = CStrDup( newpath );
		setenv( tmpname, tmpvalue, TRUE );
		ReleaseEx( tmpname DBG_SRC );
		ReleaseEx( tmpvalue DBG_SRC );
	}
#else
	setenv( name, newpath, TRUE );
#endif
	ReleaseEx( newpath DBG_SRC );
#endif
}
#endif
#ifdef __MAC__
static bool is_64bit;
static mach_port_t task;
static int pid;
static task_dyld_info_data_t dyld_info;
static jmp_buf recovery_buf;
static int read_from_task(void *p, mach_vm_address_t addr, mach_vm_size_t size) {
    mach_vm_size_t outsize;
    kern_return_t kr = mach_vm_read_overwrite(task, addr, size, (mach_vm_address_t) p, &outsize);
    if(kr || outsize != size) {
#if 0
        fprintf(stderr, "read_from_task(0x%llx, 0x%llx): ", (long long) addr, (long long) size);
        if(kr)
            fprintf(stderr, "kr=%d\n", (int) kr);
        else
            fprintf(stderr, "short read\n");
#endif
				return 0;
        //_longjmp(recovery_buf, 1);
    }
		return 1;
}
static uint64_t read_64(char **pp) {
    return *(*(uint64_t **)pp)++;
}
static uint32_t read_32(char **pp) {
    return *(*(uint32_t **)pp)++;
}
static mach_vm_address_t read_ptr(char **pp) {
    return is_64bit ? read_64(pp) : read_32(pp);
}
static void lookup_dyld_images() {
    char all_images[12], *p = all_images;
    if( !read_from_task(p, dyld_info.all_image_info_addr + 4, 12) )
			return;
    uint32_t info_array_count = read_32(&p);
    mach_vm_address_t info_array = read_ptr(&p);
    if(info_array_count > 10000) {
        fprintf(stderr, "** dyld image info had malformed data.\n");
        return;
    }
    size_t size = (is_64bit ? 24 : 12) * info_array_count;
    char *image_info = NewArray( char, size);
    p = image_info;
    if( !read_from_task(p, info_array, size) )
			return;
    for(uint32_t i = 0; i < info_array_count; i++) {
        mach_vm_address_t
            load_address = read_ptr(&p),
            file_path_addr = read_ptr(&p);
 // file_mod_date
        read_ptr(&p);
        //if(_setjmp(recovery_buf))
        //    continue;
        char path[MAXPATHLEN + 1];
        if( !read_from_task(path, file_path_addr, sizeof(path)) )
				   continue;
        if(strnlen(path, sizeof(path)) == sizeof(path))
            fprintf(stderr, "** dyld image info had malformed data.\n");
        else {
					  AddMappedLibrary( path, dlopen( path, 0 ) );
            //printf( "PATH:%s %p", path, load_address );
            //printf( "  load is %p\n", dlopen( path, 0 ) );
            //if( dlsym( load_address, "dlsym" )) printf( "** FOUND DLSYM**\n");
          }
    }
    return;
}
void loadMacLibraries(struct local_systemlib_data *init_l) {
    bool got_showaddr = false;
    mach_vm_address_t showaddr;
    pid = getpid();
    task = mach_task_self();
    char path[MAXPATHLEN];
    size_t path_size;
    if((path_size = proc_pidpath(pid, path, sizeof(path))))
        path[path_size] = 0;
    else
        strcpy(path, "????");
    //printf("%d: %s\n", pid, path);
    {
				TEXTCHAR *ext, *ext1;
				ext = (TEXTSTR)StrRChr( (CTEXTSTR)path, '.' );
				if( ext )
						ext[0] = 0;
				ext1 = (TEXTSTR)pathrchr( path );
				if( ext1 )
				{
						ext1[0] = 0;
						(*init_l).filename = StrDupEx( ext1 + 1 DBG_SRC );
						(*init_l).load_path = StrDupEx( path DBG_SRC );
				}
				else
				{
						(*init_l).filename = StrDupEx( path DBG_SRC );
						(*init_l).load_path = StrDupEx( WIDE("") DBG_SRC );
				}
		}
    assert(!task_info(task, TASK_DYLD_INFO, (task_info_t) &dyld_info, (mach_msg_type_number_t[]) {TASK_DYLD_INFO_COUNT}));
    is_64bit = dyld_info.all_image_info_addr >= (1ull << 32);
    lookup_dyld_images();
}
#endif
static void CPROC SetupSystemServices( POINTER mem, uintptr_t size )
{
	struct local_systemlib_data *init_l = (struct local_systemlib_data *)mem;
#ifdef _WIN32
	extern void InitCo( void );
	InitCo();
	{
		TEXTCHAR filepath[256];
		TEXTCHAR *ext, *ext1;
		GetModuleFileName( NULL, filepath, sizeof( filepath ) );
		ext = (TEXTSTR)StrRChr( (CTEXTSTR)filepath, '.' );
		if( ext )
			ext[0] = 0;
		ext1 = (TEXTSTR)pathrchr( filepath );
		if( ext1 )
		{
			ext1[0] = 0;
			(*init_l).filename = StrDupEx( ext1 + 1 DBG_SRC );
			(*init_l).load_path = StrDupEx( filepath DBG_SRC );
		}
		else
		{
			(*init_l).filename = StrDupEx( filepath DBG_SRC );
			(*init_l).load_path = StrDupEx( WIDE("") DBG_SRC );
		}
		GetModuleFileName( LoadLibrary( TARGETNAME ), filepath, sizeof( filepath ) );
		ext1 = (TEXTSTR)pathrchr( filepath );
		if( ext1 )
		{
			ext1[0] = 0;
			if( filepath[0] == '\\' && filepath[1] == '\\' && filepath[2] == '?' && filepath[3] == '\\' )
				(*init_l).library_path = StrDupEx( filepath +4 DBG_SRC );
			else
				(*init_l).library_path = StrDupEx( filepath DBG_SRC );
		}
		else
		{
			(*init_l).load_path = StrDupEx( WIDE("") DBG_SRC );
		}
#ifdef HAVE_ENVIRONMENT
		OSALOT_SetEnvironmentVariable( WIDE("MY_LOAD_PATH"), filepath );
#endif
	}
#else
#  if defined( __QNX__ )
	{
		struct dinfo_s {
			procfs_debuginfo info;
			char pathbuffer[_POSIX_PATH_MAX];
		};
		struct dinfo_s dinfo;
		char buf[256], *pb;
		int proc_fd;
		proc_fd = open("/proc/self/as",O_RDONLY);
		if( proc_fd >= 0 )
		{
			int status;
			status = devctl( proc_fd, DCMD_PROC_MAPDEBUG_BASE, &dinfo, sizeof(dinfo),
								 0 );
			if( status != EOK )
			{
				lprintf( "Error in devctl() call. %s",
						  strerror(status) );
				(*init_l).filename = "FailedToReadFilenaem";
				(*init_l).load_path = ".";
				(*init_l).work_path = ".";
				return;
			}
			close(proc_fd);
		}
		snprintf( buf, 256, "/%s", dinfo.info.path );
		pb = (char*)pathrchr(buf);
		if( pb )
		{
			pb[0]=0;
			(*init_l).filename = StrDupEx( pb + 1 DBG_SRC );
		}
		else
		{
			(*init_l).filename = StrDupEx( buf DBG_SRC );
			buf[0] = '.';
			buf[1] = 0;
		}
		if( StrCmp( buf, WIDE("/.") ) == 0 )
			GetCurrentPath( buf, 256 );
		//lprintf( WIDE("My execution: %s"), buf);
		(*init_l).load_path = StrDupEx( buf DBG_SRC );
		OSALOT_SetEnvironmentVariable( WIDE("MY_LOAD_PATH"), (*init_l).load_path );
		//strcpy( pMyPath, buf );
		GetCurrentPath( buf, sizeof( buf ) );
		OSALOT_SetEnvironmentVariable( WIDE( "MY_WORK_PATH" ), buf );
		(*init_l).work_path = StrDupEx( buf DBG_SRC );
		SetDefaultFilePath( (*init_l).work_path );
	}
#  else
	// this might be clever to do, auto export the LD_LIBRARY_PATH
	// but if we loaded this library, then didn't we already have a good path?
	// use /proc/self to get to cmdline
	// which has the whole invokation of this process.
#    ifdef __ANDROID__
	(*init_l).filename = GetProgramName();
	(*init_l).load_path = GetProgramPath();
	if( !(*init_l).filename || !(*init_l).load_path )
	{
		char buf[256];
		FILE *maps = fopen( "/proc/self/maps", "rt" );
		while( maps && fgets( buf, 256, maps ) )
		{
			unsigned long start;
			unsigned long end;
			sscanf( buf, "%lx", &start );
			sscanf( buf+9, "%lx", &end );
			if( ((unsigned long)SetupSystemServices >= start ) && ((unsigned long)SetupSystemServices <= end ) )
			{
				char *myname;
				char *mypath;
				void *lib;
				char *myext;
				void (*InvokeDeadstart)(void );
				void (*MarkRootDeadstartComplete)(void );
				fclose( maps );
				maps = NULL;
				if( strlen( buf ) > 49 )
				mypath = strdup( buf + 49 );
				myext = strrchr( mypath, '.' );
				myname = strrchr( mypath, '/' );
				if( myname )
				{
					myname[0] = 0;
					myname++;
				}
				else
					myname = mypath;
				if( myext )
				{
					myext[0] = 0;
				}
				//LOGI( "my path [%s][%s]", mypath, myname );
				// do not auto load libraries
				SACKSystemSetProgramPath( mypath );
				(*init_l).load_path =  DupCStr( mypath );
				SACKSystemSetProgramName( myname );
				(*init_l).filename = DupCStr( myname );
				SACKSystemSetWorkingPath( buf );
				break;
			}
		}
	}
#    else
	//if( !(*init_l).filename || !(*init_l).load_path )
	{
		/* #include unistd.h, stdio.h, string.h */
		{
			char buf[256];
#       ifndef __MAC__
			char *pb;
			int n;
			n = readlink("/proc/self/exe",buf,256);
			if( n >= 0 )
			{
 //linux
				buf[n]=0;
				if( !n )
				{
					strcpy( buf, WIDE(".") );
 // fbsd
					buf[ n = readlink( WIDE("/proc/curproc/"),buf,256)]=0;
				}
			}
			else
				strcpy( buf, WIDE(".")) ;
			pb = strrchr(buf,'/');
			if( pb )
				pb[0]=0;
			else
				pb = buf - 1;
			//lprintf( WIDE("My execution: %s"), buf);
			(*init_l).filename = StrDupEx( pb + 1 DBG_SRC );
			(*init_l).load_path = StrDupEx( buf DBG_SRC );
#       endif
			local_systemlib = init_l;
			AddMappedLibrary( "dummy", NULL );
#       ifdef __MAC__
			loadMacLibraries( init_l );
#       endif
			local_systemlib = NULL;
			{
				PLIBRARY library = (*init_l).libraries;
				while( library )
				{
					if( StrCaseCmp( library->name, TARGETNAME ) == 0 )
						break;
					library = library->next;
				}
				//if( library )
				{
					char *dupname;
					char *path;
					dupname = StrDup( library->full_name );
					path = strrchr( dupname, '/' );
					if( path )
						path[0] = 0;
					(*init_l).library_path = dupname;
				}
			}
			setenv( WIDE("MY_LOAD_PATH"), (*init_l).load_path, TRUE );
			//strcpy( pMyPath, buf );
			GetCurrentPath( buf, sizeof( buf ) );
			setenv( WIDE( "MY_WORK_PATH" ), buf, TRUE );
			(*init_l).work_path = StrDupEx( buf DBG_SRC );
		}
		{
			TEXTCHAR *oldpath;
			TEXTCHAR *newpath;
			oldpath = getenv( "LD_LIBRARY_PATH" );
			if( oldpath )
			{
				newpath = NewArray( char, (uint32_t)((oldpath?StrLen( oldpath ):0) + 2 + StrLen((*init_l).library_path)) );
				sprintf( newpath, WIDE("%s:%s"), (*init_l).library_path
						 , oldpath );
				setenv( WIDE("LD_LIBRARY_PATH"), newpath, 1 );
				ReleaseEx( newpath DBG_SRC );
			}
		}
		{
			TEXTCHAR *oldpath;
			TEXTCHAR *newpath;
			oldpath = getenv( "PATH" );
			if( oldpath )
			{
				newpath = NewArray( char, (uint32_t)((oldpath?StrLen( oldpath ):0) + 2 + StrLen((*init_l).load_path)) );
				sprintf( newpath, WIDE("%s:%s"), (*init_l).load_path
						 , oldpath );
				setenv( WIDE("PATH"), newpath, 1 );
				ReleaseEx( newpath DBG_SRC );
			}
		}
		//<x`int> rathar: main() { char buf[1<<7]; buf[readlink("/proc/self/exe",buf,1<<7)]=0; puts(buf); }
		//<x`int> main() {  }
		//<x`int>
	}
#    endif
#  endif
#endif
}
static void SystemInit( void )
{
	if( !local_systemlib )
	{
		RegisterAndCreateGlobalWithInit( (POINTER*)&local_systemlib, sizeof( *local_systemlib ), WIDE("system"), SetupSystemServices );
#ifdef WIN32
		if( !l.flags.bInitialized )
		{
			TEXTCHAR filepath[256];
			GetCurrentPath( filepath, sizeof( filepath ) );
			l.work_path = StrDupEx( filepath DBG_SRC );
			SetDefaultFilePath( l.work_path );
#ifdef HAVE_ENVIRONMENT
			OSALOT_SetEnvironmentVariable( WIDE( "MY_WORK_PATH" ), filepath );
#endif
			l.flags.bInitialized = 1;
#  ifdef WIN32
			l.EnumProcessModules = (BOOL(WINAPI*)(HANDLE,HMODULE*,DWORD,LPDWORD))LoadFunction( WIDE("psapi.dll"), WIDE("EnumProcessModules"));
			if( !l.EnumProcessModules )
				l.EnumProcessModules = (BOOL(WINAPI*)(HANDLE,HMODULE*,DWORD,LPDWORD))LoadFunction(WIDE("kernel32.dll"), WIDE("EnumProcessModules"));
			if( !l.EnumProcessModules )
				l.EnumProcessModules = (BOOL(WINAPI*)(HANDLE,HMODULE*,DWORD,LPDWORD))LoadFunction(WIDE("kernel32.dll"), WIDE("K32EnumProcessModules") );
#  endif
		}
#endif
	}
}
PRIORITY_PRELOAD( SetupPath, OSALOT_PRELOAD_PRIORITY )
{
	SystemInit();
}
#ifndef __NO_OPTIONS__
PRELOAD( SetupSystemOptions )
{
	//lprintf( "SYSTEM OPTION INIT" );
	l.flags.bLog = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/System/Enable Logging" ), 0, TRUE );
	if( SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/System/Auto prepend program location to PATH environment" ), 0, TRUE ) ){
		//lprintf( "Add %s to path", l.load_path );
		OSALOT_PrependEnvironmentVariable( WIDE("PATH"), l.load_path );
	}
}
#endif
//--------------------------------------------------------------------------
#ifdef WIN32
#ifndef _M_CEE_PURE
static BOOL CALLBACK CheckWindowAndSendKill( HWND hWnd, LPARAM lParam )
{
	uint32_t idThread, idProcess;
	PTASK_INFO task = (PTASK_INFO)lParam;
	idThread = GetWindowThreadProcessId( hWnd, (LPDWORD)&idProcess );
	/*
	{
		TEXTCHAR title[256];
		GetWindowText( hWnd, title, sizeof( title ) );
		lprintf( "Window [%s] = %d %d", title, idProcess, idThread );
	}
	*/
	if( task->pi.dwProcessId == idProcess )
	{
		// found the window to kill...
		PostThreadMessage( idThread, WM_QUIT, 0xD1E, 0 );
		return FALSE;
	}
	return TRUE;
}
#endif
//--------------------------------------------------------------------------
int CPROC EndTaskWindow( PTASK_INFO task )
{
	return EnumWindows( CheckWindowAndSendKill, (LPARAM)task );
}
#endif
//--------------------------------------------------------------------------
#ifdef WIN32
#if _MSC_VER
#pragma runtime_checks( "sru", off )
#endif
static DWORD STDCALL SendCtrlCThreadProc( void *data )
{
	return GenerateConsoleCtrlEvent( CTRL_BREAK_EVENT, 0 );
}
#if _MSC_VER
#pragma runtime_checks( "sru", restore )
#endif
#endif
LOGICAL CPROC StopProgram( PTASK_INFO task )
{
	task->flags.process_ended = 1;
	if( task->pOutputThread )
		WakeThread( task->pOutputThread );
#ifdef WIN32
#ifndef UNDER_CE
	int error;
	if( !GenerateConsoleCtrlEvent( CTRL_C_EVENT, task->pi.dwProcessId ) )
	{
		error = GetLastError();
		lprintf( WIDE( "Failed to send CTRL_C_EVENT %d" ), error );
		if( !GenerateConsoleCtrlEvent( CTRL_BREAK_EVENT, task->pi.dwProcessId ) )
		{
			error = GetLastError();
			lprintf( WIDE( "Failed to send CTRL_BREAK_EVENT %d" ), error );
		}
	}
	// try and copy some code to it..
	{
		POINTER mem = VirtualAllocEx( task->pi.hProcess, NULL, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE );
		DWORD err = GetLastError();
		if( mem ) {
			SIZE_T written;
			if( WriteProcessMemory( task->pi.hProcess, mem,
				(LPCVOID)SendCtrlCThreadProc, 1024, &written ) ) {
				DWORD dwThread;
				HANDLE hThread = CreateRemoteThread( task->pi.hProcess, NULL, 0
					, (LPTHREAD_START_ROUTINE)mem, NULL, 0, &dwThread );
				err = GetLastError();
				if( hThread )
					if( WaitForSingleObject( task->pi.hProcess, 50 ) != WAIT_OBJECT_0 )
						return FALSE;
					else
						return TRUE;
			}
		}
	}
#endif
	if( WaitForSingleObject( task->pi.hProcess, 1 ) != WAIT_OBJECT_0 )
		return FALSE;
	else
		return TRUE;
#else
   lprintf( "need to send kill() to signal process to top" );
#endif
	 return FALSE;
}
uintptr_t CPROC TerminateProgram( PTASK_INFO task )
{
	if( task )
	{
#if defined( WIN32 )
		int bDontCloseProcess = 0;
#endif
		if( !task->flags.closed )
		{
			task->flags.closed = 1;
			//lprintf( WIDE( "%ld, %ld %p %p" ), task->pi.dwProcessId, task->pi.dwThreadId, task->pi.hProcess, task->pi.hThread );
#if defined( WIN32 )
			if( WaitForSingleObject( task->pi.hProcess, 0 ) != WAIT_OBJECT_0 )
			{
				int nowait = 0;
				// try using ctrl-c, ctrl-break to end process...
				if( !StopProgram( task ) )
				{
					xlprintf(LOG_LEVEL_DEBUG+1)( WIDE("Program did not respond to ctrl-c or ctrl-break...") );
					// if ctrl-c fails, try finding the window, and sending exit (systray close)
					if( EndTaskWindow( task ) )
					{
						xlprintf(LOG_LEVEL_DEBUG+1)( WIDE("failed to find task window to send postquitmessage...") );
						// didn't find the window - result was continue_enum with no more (1)
						// so didn't find the window - nothing to wait for, fall through
						nowait = 1;
					}
				}
				if( nowait || ( WaitForSingleObject( task->pi.hProcess, 500 ) != WAIT_OBJECT_0 ) )
				{
					xlprintf(LOG_LEVEL_DEBUG+1)( WIDE("Terminating process....") );
					bDontCloseProcess = 1;
					if( !TerminateProcess( task->pi.hProcess, 0xD1E ) )
					{
						HANDLE hTmp;
						lprintf( WIDE("Failed to terminate process... %p %ld : %d (will try again with OpenProcess)"), task->pi.hProcess, task->pi.dwProcessId, GetLastError() );
						hTmp = OpenProcess( SYNCHRONIZE|PROCESS_TERMINATE, FALSE, task->pi.dwProcessId);
						if( !TerminateProcess( hTmp, 0xD1E ) )
						{
							lprintf( WIDE("Failed to terminate process... %p %ld : %d"), task->pi.hProcess, task->pi.dwProcessId, GetLastError() );
						}
						CloseHandle( hTmp );
					}
				}
			}
			if( !task->EndNotice )
			{
				lprintf( WIDE( "Closing handle (no end notification)" ) );
				// task end notice - will get the event and close these...
				CloseHandle( task->pi.hThread );
				task->pi.hThread = 0;
				if( !bDontCloseProcess )
				{
					lprintf( WIDE( "And close process handle" ) );
					CloseHandle( task->pi.hProcess );
					task->pi.hProcess = 0;
				}
				else
					lprintf( WIDE( "Keeping process handle" ) );
			}
//			else
//				lprintf( WIDE( "Would have close handles rudely." ) );
#else
			kill( task->pid, SIGTERM );
			// wait a moment for it to die...
#endif
		}
		//if( !task->EndNotice )
		//{
		//	Release( task );
		//}
		//task = NULL;
	}
	return 0;
}
//--------------------------------------------------------------------------
SYSTEM_PROC( void, SetProgramUserData )( PTASK_INFO task, uintptr_t psv )
{
	if( task )
		task->psvEnd = psv;
}
//--------------------------------------------------------------------------
uint32_t GetTaskExitCode( PTASK_INFO task )
{
	if( task )
		return task->exitcode;
	return 0;
}
uintptr_t CPROC WaitForTaskEnd( PTHREAD pThread )
{
	PTASK_INFO task = (PTASK_INFO)GetThreadParam( pThread );
#ifdef __LINUX__
	while( !task->pid ) {
		Relinquish();
	}
#endif
	// this should be considered the owner of this.
	if( !task->EndNotice )
	{
		// application is dumb, hold the task for him; otherwise
		// the application is aware that after EndNotification the task is no longer valid.
		Hold( task );
	}
	//if( task->EndNotice )
	{
		// allow other people to delete it...
		//Hold( task );
#if defined( WIN32 )
		WaitForSingleObject( task->pi.hProcess, INFINITE );
		GetExitCodeProcess( task->pi.hProcess, &task->exitcode );
#elif defined( __LINUX__ )
		waitpid( task->pid, NULL, 0 );
#endif
		task->flags.process_ended = 1;
		if( task->hStdOut.hThread )
		{
#ifdef _WIN32
			// vista++ so this won't work for XP support...
			static BOOL (WINAPI *MyCancelSynchronousIo)( HANDLE hThread ) = (BOOL(WINAPI*)(HANDLE))-1;
			if( (uintptr_t)MyCancelSynchronousIo == (uintptr_t)-1 )
				MyCancelSynchronousIo = (BOOL(WINAPI*)(HANDLE))LoadFunction( WIDE( "kernel32.dll" ), WIDE( "CancelSynchronousIo" ) );
			if( MyCancelSynchronousIo )
			{
				if( !MyCancelSynchronousIo( GetThreadHandle( task->hStdOut.hThread ) ) )
				{
					// maybe the read wasn't queued yet....
					//lprintf( "Failed to cancel IO on thread %d %d", GetThreadHandle( task->hStdOut.hThread ), GetLastError() );
				}
			}
			else
			{
				static BOOL (WINAPI *MyCancelIoEx)( HANDLE hFile,LPOVERLAPPED ) = (BOOL(WINAPI*)(HANDLE,LPOVERLAPPED))-1;
				if( (uintptr_t)MyCancelIoEx == (uintptr_t)-1 )
					MyCancelIoEx = (BOOL(WINAPI*)(HANDLE,LPOVERLAPPED))LoadFunction( WIDE( "kernel32.dll" ), WIDE( "CancelIoEx" ) );
				if( MyCancelIoEx )
					MyCancelIoEx( task->hStdOut.handle, NULL );
				else
				{
					DWORD written;
					//lprintf( WIDE( "really? You're still using xp or less?" ) );
					task->flags.bSentIoTerminator = 1;
					if( !WriteFile( task->hWriteOut, WIDE( "\x04" ), 1, &written, NULL ) )
					lprintf( WIDE( "write pipe failed! %d" ), GetLastError() );
					//lprintf( "Pipe write was %d", written );
				}
			}
#endif
		}
		// wait for task last output before notification of end of task.
		while( task->pOutputThread )
			Relinquish();
		if( task->EndNotice )
			task->EndNotice( task->psvEnd, task );
#if defined( WIN32 )
		//lprintf( WIDE( "Closing process and thread handles." ) );
		if( task->pi.hProcess )
		{
			CloseHandle( task->pi.hProcess );
			task->pi.hProcess = 0;
		}
		if( task->pi.hThread )
		{
			CloseHandle( task->pi.hThread );
			task->pi.hThread = 0;
		}
#endif
		ReleaseEx( task DBG_SRC );
	}
	//TerminateProgram( task );
	return 0;
}
//--------------------------------------------------------------------------
#ifdef WIN32
static int DumpError( void )
{
#ifdef _DEBUG
	lprintf( WIDE("Failed create process:%d"), GetLastError() );
#endif
	return 0;
}
#endif
#ifdef WIN32
static BOOL CALLBACK EnumDesktopProc( LPTSTR lpszDesktop,
												 LPARAM lParam
												)
{
	lprintf( WIDE( "Desktop found [%s]" ), lpszDesktop );
	return 1;
}
void EnumDesktop( void )
{
	// I'm running on some windows station, right?
	//HWINSTA GetProcessWindowStation();
	if( EnumDesktops( NULL, EnumDesktopProc, (LPARAM)(uintptr_t)0 ) )
	{
		// returned non-zero value from enumdesktopproc?
		// failed to find?
	}
}
static BOOL CALLBACK EnumStationProc( LPTSTR lpszWindowStation, LPARAM lParam )
{
	lprintf( WIDE( "station found [%s]" ), lpszWindowStation );
	return 1;
}
void EnumStations( void )
{
	if( EnumWindowStations( EnumStationProc, 0 ) )
	{
	}
}
void SetDefaultDesktop( void )
{
	//return;
	{
	HDESK lngDefaultDesktop;
	HWINSTA lngWinSta0;
	HWINSTA station = GetProcessWindowStation();
	HDESK desk = GetThreadDesktop( GetCurrentThreadId() );
	DWORD length;
	char buffer[256];
	lprintf( WIDE( "Desktop this is %p %p" ), station, desk );
	GetUserObjectInformation( desk, UOI_NAME, buffer, sizeof( buffer ), &length );
	lprintf( WIDE( "desktop is %s" ), buffer );
	GetUserObjectInformation( station, UOI_NAME, buffer, sizeof( buffer ), &length );
	lprintf( WIDE( "station is %s" ), buffer );
	EnumDesktop();
	EnumStations();
	// these should be const strings, but they're not... add typecast for GCC
	lngWinSta0 = OpenWindowStation( (LPTSTR)WIDE( "WinSta0" ), FALSE, WINSTA_ALL_ACCESS );
	//lngWinSta0 = OpenWindowStation(WIDE( "msswindowstation" ), FALSE, WINSTA_ALL_ACCESS );
	lprintf( WIDE( "sta = %p %d" ), lngWinSta0, GetLastError() );
	if( !SetProcessWindowStation(lngWinSta0) )
		lprintf( WIDE( "Failed station set?" ) );
	// these should be const strings, but they're not... add typecast for GCC
	lngDefaultDesktop = OpenDesktop( (LPTSTR)WIDE( "Default" ), 0, FALSE, 0x10000000);
	//lngDefaultDesktop = OpenDesktop(WIDE( "WinSta0" ), 0, FALSE, 0x10000000);
	lprintf( WIDE( "defa = %p" ), lngDefaultDesktop );
	if( !SetThreadDesktop(lngDefaultDesktop) )
		lprintf( WIDE( "Failed desktop set?" ) );
	}
}
		/*
 HDESK WINAPI OpenInputDesktop(
  __in  DWORD dwFlags,
  __in  BOOL fInherit,
  __in  ACCESS_MASK dwDesiredAccess
);
*/
DWORD GetExplorerProcessID()
{
	static TEXTCHAR process_find[128];
	HANDLE hSnapshot;
	PROCESSENTRY32 pe32;
	DWORD temp = 0;
	ZeroMemory(&pe32,sizeof(pe32));
	if( !process_find[0] )
	{
#ifndef __NO_OPTIONS__
		SACK_GetProfileStringEx( GetProgramName(), WIDE( "SACK/System/Impersonate Process" ), WIDE( "explorer.exe" ), process_find, sizeof( process_find ), TRUE );
#endif
	}
	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	pe32.dwSize = sizeof(PROCESSENTRY32);
	if(Process32First(hSnapshot,&pe32))
	{
		do
		{
			//lprintf( WIDE( "Thing is %s" ), pe32.szExeFile );
			if(!StrCmp(pe32.szExeFile,process_find))
			{
				//MessageBox(0,pe32.szExeFile,WIDE( "test" ),0);
				temp = pe32.th32ProcessID;
				break;
			}
		}while(Process32Next(hSnapshot,&pe32));
	}
	return temp;
}
void ImpersonateInteractiveUser( void )
{
	HANDLE hToken = NULL;
	HANDLE hProcess = NULL;
	DWORD processID;
	SetDefaultDesktop();
	processID = GetExplorerProcessID();
	//lprintf( WIDE( "Enum EDesktops..." ) );
	//EnumDesktop();
	//lprintf( WIDE( "explorer is %p" ), processID );
	if( processID)
	{
		hProcess =
			OpenProcess(
							PROCESS_ALL_ACCESS,
							TRUE,
							processID );
		if( hProcess)
		{
			//lprintf( WIDE( "Success getting process %p" ), hProcess );
			if( OpenProcessToken(
										hProcess,
										TOKEN_EXECUTE |
										TOKEN_READ |
										TOKEN_QUERY |
										TOKEN_ASSIGN_PRIMARY |
										TOKEN_QUERY_SOURCE |
										TOKEN_WRITE |
										TOKEN_DUPLICATE |
										TOKEN_IMPERSONATE,
										&hToken))
			{
				//lprintf( WIDE( "Sucess opening token" ) );
				if( ImpersonateLoggedOnUser( hToken ) )
					;
				else
					lprintf( WIDE( "Fail impersonate %d" ), GetLastError() );
				CloseHandle( hToken );
			}
			else
				lprintf( WIDE( "Failed opening token %d" ), GetLastError() );
			CloseHandle( hProcess );
		}
		else
			lprintf( WIDE( "Failed open process: %d" ), GetLastError() );
	}
	else
		lprintf( WIDE( "Failed get explorer process: %d" ), GetLastError() );
}
HANDLE GetImpersonationToken( void )
{
	HANDLE hToken = NULL;
	HANDLE hProcess = NULL;
	DWORD processID;
	processID = GetExplorerProcessID();
	//lprintf( WIDE( "Enum EDesktops..." ) );
	//EnumDesktop();
	//lprintf( WIDE( "explorer is %p" ), processID );
	if( processID)
	{
		hProcess =
			OpenProcess(
							PROCESS_ALL_ACCESS,
							TRUE,
							processID );
		if( hProcess)
		{
			//lprintf( WIDE( "Success getting process %p" ), hProcess );
			if( OpenProcessToken(
										hProcess,
										TOKEN_EXECUTE |
										TOKEN_READ |
										TOKEN_QUERY |
										TOKEN_ASSIGN_PRIMARY |
										TOKEN_QUERY_SOURCE |
										TOKEN_WRITE |
										TOKEN_DUPLICATE |
										TOKEN_IMPERSONATE,
										&hToken))
			{
				//lprintf( WIDE( "Sucess opening token" ) );
				//if( ImpersonateLoggedOnUser( hToken ) )
				//   ;
				//else
				//   lprintf( WIDE( "Fail impersonate %d" ), GetLastError() );
				//CloseHandle( hToken );
			}
			else
				lprintf( WIDE( "Failed opening token %d" ), GetLastError() );
			CloseHandle( hProcess );
		}
		else
			lprintf( WIDE( "Failed open process: %d" ), GetLastError() );
	}
	else
		lprintf( WIDE( "Failed get explorer process: %d" ), GetLastError() );
	return hToken;
}
void EndImpersonation( void )
{
	RevertToSelf();
}
#endif
//--------------------------------------------------------------------------
#ifdef WIN32
int TryShellExecute( PTASK_INFO task, CTEXTSTR path, CTEXTSTR program, PTEXT cmdline )
{
#if 0
#if defined( OLD_MINGW_SUX ) || defined( __WATCOMC__ )
	typedef struct _SHELLEXECUTEINFO {
		DWORD     cbSize;
		ULONG     fMask;
		HWND      hwnd;
 // null default
		LPCTSTR   lpVerb;
		LPCTSTR   lpFile;
		LPCTSTR   lpParameters;
		LPCTSTR   lpDirectory;
		int       nShow;
		HINSTANCE hInstApp;
		LPVOID    lpIDList;
		LPCTSTR   lpClass;
		HKEY      hkeyClass;
		DWORD     dwHotKey;
		union {
			HANDLE hIcon;
			HANDLE hMonitor;
		} DUMMYUNIONNAME;
		HANDLE    hProcess;
	} SHELLEXECUTEINFO, *LPSHELLEXECUTEINFO;
#endif
#endif
	SHELLEXECUTEINFO execinfo;
	MemSet( &execinfo, 0, sizeof( execinfo ) );
	execinfo.cbSize = sizeof( SHELLEXECUTEINFO );
  // need this to get process handle back for terminate later
	execinfo.fMask = SEE_MASK_NOCLOSEPROCESS
		| SEE_MASK_FLAG_NO_UI
		| SEE_MASK_NO_CONSOLE
		//| SEE_MASK_NOASYNC
		;
	execinfo.lpFile = program;
	execinfo.lpDirectory = path;
	{
		TEXTCHAR *params;
		for( params = GetText( cmdline ); params[0] && params[0] != ' '; params++ );
		if( params[0] )
		{
			//lprintf( WIDE( "adding extra parames [%s]" ), params );
			execinfo.lpParameters = params;
		}
	}
	execinfo.nShow = SW_SHOWNORMAL;
	if( ShellExecuteEx( &execinfo ) )
	{
		if( (uintptr_t)execinfo.hInstApp > 32)
		{
			switch( (uintptr_t)execinfo.hInstApp )
			{
			case 42:
#ifdef _DEBUG
				lprintf( WIDE( "No association picked : %p (gle:%d)" ), (uintptr_t)execinfo.hInstApp , GetLastError() );
#endif
				break;
			}
#ifdef _DEBUG
			lprintf( WIDE( "sucess with shellexecute of(%p) %s " ), execinfo.hInstApp, program );
#endif
			task->pi.hProcess = execinfo.hProcess;
			task->pi.hThread = 0;
			return TRUE;
		}
		else
		{
			//switch( (uintptr_t)execinfo.hInstApp )
			{
			//default:
				lprintf( WIDE( "Shell exec error : %p (gle:%d)" ), (uintptr_t)execinfo.hInstApp , GetLastError() );
				//break;
			}
			return FALSE;
		}
	}
	else
		lprintf( WIDE( "Shellexec error %d" ), GetLastError() );
	return FALSE;
}
#endif
//--------------------------------------------------------------------------
// Run a program completely detached from the current process
// it runs independantly.  Program does not suspend until it completes.
// Use GetTaskExitCode() to get the return code of the process
SYSTEM_PROC( PTASK_INFO, LaunchProgramEx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args, TaskEnd EndNotice, uintptr_t psv )
{
	return LaunchPeerProgramExx( program, path, args
						            , LPP_OPTION_DO_NOT_HIDE | LPP_OPTION_NEW_GROUP
										, NULL, EndNotice, psv DBG_SRC );
}
SYSTEM_PROC( PTASK_INFO, LaunchProgram )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args )
{
	return LaunchProgramEx( program, path, args, NULL, 0 );
}
//--------------------------------------------------------------------------
void InvokeLibraryLoad( void )
{
	void (CPROC *f)(void);
	PCLASSROOT data = NULL;
	PCLASSROOT event_root = GetClassRoot( WIDE("SACK/system/library/load_event") );
	CTEXTSTR name;
	for( name = GetFirstRegisteredName( event_root, &data );
		 name;
		  name = GetNextRegisteredName( &data ) )
	{
		f = GetRegisteredProcedureExx( data,(CTEXTSTR)NULL,void,name,(void));
		if( f )
		{
			f();
		}
	}
}
// look for all the libraries that are currently already loaded (so we know to just load them the normal way)
#define Seek(a,b) (((uintptr_t)a)+(b))
static void LoadExistingLibraries( void )
{
#ifdef WIN32
	DWORD n = 256;
	HMODULE *modules = NewArray( HMODULE, 256 );
	DWORD needed;
	if( !l.EnumProcessModules )
	{
		//lprintf( "Failed to load EnumProcessModules" );
		return;
	}
	l.EnumProcessModules( GetCurrentProcess(), modules, sizeof( HMODULE ) * 256, &needed );
	if( needed / sizeof( HMODULE ) == n )
		lprintf( WIDE("loaded module overflow") );
	needed /= sizeof( HMODULE );
	for( n = 0; n < needed; n++ )
	{
		POINTER real_memory = modules[n];
		PIMAGE_DOS_HEADER source_dos_header = (PIMAGE_DOS_HEADER)real_memory;
		PIMAGE_NT_HEADERS source_nt_header = (PIMAGE_NT_HEADERS)Seek( real_memory, source_dos_header->e_lfanew );
		PIMAGE_DATA_DIRECTORY dir = (PIMAGE_DATA_DIRECTORY)source_nt_header->OptionalHeader.DataDirectory;
		PIMAGE_EXPORT_DIRECTORY exp_dir = (PIMAGE_EXPORT_DIRECTORY)Seek( real_memory, dir[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress );
		const char *dll_name = (const char*) Seek( real_memory, exp_dir->Name );
		if( exp_dir->Name > source_nt_header->OptionalHeader.SizeOfImage )
		{
			dll_name = "Invalid_Name";
		}
#ifdef UNICODE
		{
			TEXTSTR _dll_name = DupCStr( dll_name );
#define dll_name _dll_name
#endif
			AddMappedLibrary( dll_name, modules[n] );
#ifdef UNICODE
			Deallocate( TEXTSTR, _dll_name );
#undef dll_name
		}
#endif
	}
#endif
#ifdef __MAC__
	lookup_dyld_images();
#else
#  ifdef __LINUX__
	{
		FILE *maps;
		char buf[256];
		maps = sack_fopenEx( 0, "/proc/self/maps", "rt", sack_get_mounted_filesystem( "native" ) );
		while( maps && sack_fgets( buf, 256, maps ) )
		{
			char *libpath = strchr( buf, '/' );
			char *split = strchr( buf, '-' );
			if( libpath && split )
			{
				char *dll_name = strrchr( libpath, '/' );
				size_t start, end;
				char perms[8];
				size_t offset;
				int scanned;
				offset = strlen( buf );
				if( offset < 2 )
					continue;
				buf[offset-1] = 0;
				scanned = sscanf( buf, "%zx-%zx %s %zx", &start, &end, perms, &offset );
				if( scanned == 4 && offset == 0 )
				{
					if( ( perms[2] == 'x' )
						&& ( ( end - start ) > 4 ) )
						if( ( ((unsigned char*)start)[0] == ELFMAG0 )
						   && ( ((unsigned char*)start)[1] == ELFMAG1 )
						   && ( ((unsigned char*)start)[2] == ELFMAG2 )
							&& ( ((unsigned char*)start)[3] == ELFMAG3 ) )
						{
							//lprintf( "Add library %s %p", dll_name + 1, start );
							AddMappedLibrary( libpath, (POINTER)start );
						}
				}
			}
		}
		sack_fclose( maps );
	}
#  endif
#endif
}
SYSTEM_PROC( LOGICAL, IsMappedLibrary)( CTEXTSTR libname )
{
	PLIBRARY library = l.libraries;
	if( !l.libraries )
	{
		LoadExistingLibraries();
		library = l.libraries;
	}
	while( library )
	{
		if( library->library && StrCaseCmp( library->name, libname ) == 0 )
			break;
		library = library->next;
	}
	if( library )
		return TRUE;
	return FALSE;
}
SYSTEM_PROC( void, AddMappedLibrary)( CTEXTSTR libname, POINTER image_memory )
{
	PLIBRARY library = l.libraries;
	static int loading;
	if( !l.libraries && !loading )
	{
		loading = 1;
		LoadExistingLibraries();
		library = l.libraries;
		loading = 0;
		if( !image_memory )
			return;
	}
	while( library )
	{
		if( StrCaseCmp( library->name, libname ) == 0 )
			break;
		library = library->next;
	}
	// don't really NEED anything else, in case we need to start before deadstart invokes.
	if( !library && image_memory )
	{
		size_t maxlen = StrLen( libname ) + 1;
		library = NewPlus( LIBRARY, sizeof(TEXTCHAR)*((maxlen<0xFFFFFF)?(uint32_t)maxlen:0) );
		library->alt_full_name = NULL;
		StrCpy( library->full_name, libname );
		library->name = (char*)pathrchr( library->full_name );
		if( library->name )
			library->name++;
		else
			library->name = library->full_name;
		library->functions = NULL;
		library->mapped = TRUE;
		library->library = (HLIBRARY)image_memory;
		InvokeLibraryLoad();
		library->nLibrary = ++l.nLibrary;
		LinkThing( l.libraries, library );
	}
}
void DeAttachThreadToLibraries( LOGICAL attach )
{
	PLIBRARY library = l.libraries;
	if( 0 )
	while( library )
	{
		if( library->mapped )
		{
#ifdef WIN32
			PIMAGE_DOS_HEADER source_dos_header = (PIMAGE_DOS_HEADER)library->library;
			PIMAGE_NT_HEADERS source_nt_header = (PIMAGE_NT_HEADERS)Seek( library->library, source_dos_header->e_lfanew );
			PIMAGE_DATA_DIRECTORY dir = (PIMAGE_DATA_DIRECTORY)source_nt_header->OptionalHeader.DataDirectory;
			void(WINAPI*entry_point)(void*, DWORD, void*) = (void(WINAPI*)(void*,DWORD,void*))Seek( library->library, source_nt_header->OptionalHeader.AddressOfEntryPoint );
			{
				// thread local storage fixup
				PIMAGE_TLS_DIRECTORY tls = (PIMAGE_TLS_DIRECTORY)Seek( library->library, dir[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress );
				DWORD n;
				if( dir[IMAGE_DIRECTORY_ENTRY_TLS].Size )
				{
					for( n = 0; n < dir[IMAGE_DIRECTORY_ENTRY_TLS].Size / sizeof( IMAGE_TLS_DIRECTORY ); n++ )
					{
						POINTER data;
						DWORD dwInit;
						size_t size_init = ( tls->EndAddressOfRawData - tls->StartAddressOfRawData );
						size_t size = size_init + tls->SizeOfZeroFill;
						/*
						printf( "something %d\n", dir[IMAGE_DIRECTORY_ENTRY_TLS].Size );
						printf( "%p %p %p(%d) %p\n"
									, tls->AddressOfCallBacks
									, tls->StartAddressOfRawData, tls->EndAddressOfRawData
									, ( tls->EndAddressOfRawData - tls->StartAddressOfRawData ) + tls->SizeOfZeroFill
									, tls->AddressOfIndex );
						*/
						dwInit = (*((DWORD*)tls->AddressOfIndex));
						if( attach )
						{
							data = NewArray( uint8_t, size );
#ifdef _MSC_VER
#  ifdef __64__
#  else
							{
								_asm mov ecx, fs:[2ch];
								_asm mov eax, dwInit;
								_asm mov edx, data;
								_asm mov dword ptr [ecx+eax*4], edx;
							}
#  endif
#endif
							//TlsSetValue( dwInit, data );
							memcpy( data, (POINTER)tls->StartAddressOfRawData, size_init );
							memset( ((uint8_t*)data) + size_init, 0, tls->SizeOfZeroFill );
						}
						else
						{
							data = TlsGetValue( dwInit );
							Deallocate( POINTER, data );
						}
					}
				}
			}
			entry_point( library->library, attach?DLL_THREAD_ATTACH:DLL_THREAD_DETACH, 0 );
#endif
		}
		library = library->next;
	}
}
SYSTEM_PROC( generic_function, LoadFunctionExx )( CTEXTSTR libname, CTEXTSTR funcname, LOGICAL bPrivate  DBG_PASS )
{
	PLIBRARY library;
	SystemInit();
	library = l.libraries;
	if( !l.libraries )
	{
		LoadExistingLibraries();
		library = l.libraries;
	}
	while( library )
	{
		if( StrCaseCmp( library->name, libname ) == 0 )
			break;
		library = library->next;
	}
	// don't really NEED anything else, in case we need to start before deadstart invokes.
	if( !library )
	{
		size_t fullnameLen;
		size_t maxlen = ( fullnameLen = StrLen( l.load_path ) + 1 + StrLen( libname ) + 1 ) + StrLen( l.library_path ) + 1 + StrLen(libname) + 1;
		library = NewPlus( LIBRARY, sizeof(TEXTCHAR)*((maxlen<0xFFFFFF)?(uint32_t)maxlen:0) );
		library->alt_full_name = library->full_name + fullnameLen;
		//lprintf( "New library %s", libname );
		if( !IsAbsolutePath( libname ) )
		{
			library->name = library->full_name
				+ tnprintf( library->full_name, maxlen, WIDE("%s/"), l.load_path );
			tnprintf( library->alt_full_name, maxlen, WIDE( "%s/%s" ), l.library_path, libname );
			tnprintf( library->name
				, fullnameLen - (library->name-library->full_name)
				, WIDE("%s"), libname );
			library->name = (char*)pathrchr( library->full_name );
			if( library->name )
				library->name++;
			else
				library->name = library->full_name;
		}
		else
		{
			StrCpy( library->full_name, libname );
			library->alt_full_name = library->full_name;
			library->name = (char*)pathrchr( library->full_name );
			library->loading = 0;
			if( library->name )
				library->name++;
			else
				library->name = library->full_name;
		}
		library->library = NULL;
		library->mapped = FALSE;
		library->functions = NULL;
		library->loading++;
		library->nLibrary = ++l.nLibrary;
		LinkThing( l.libraries, library );
#ifdef _WIN32
		// with deadstart suspended, the library can safely register
		// all of its preloads.  Then invoke will release suspend
		// so final initializers in application can run.
		if( l.ExternalLoadLibrary && !library->library )
		{
			PLIBRARY check;
#  ifdef UNICODE
			char *libname = CStrDup( library->name );
#  else
//#        define libname library->name
#  endif
			//lprintf( "trying external load...%s", library->name );
			l.ExternalLoadLibrary( libname );
#  ifdef UNICODE
			Deallocate( char*, libname );
#  else
#        undef libname
#  endif
			// during external load, it will end up adding a library that has
			// a valid handle, this entry is no longer good and we should use that one.
			// THe full name probably won't match.
			for( check = l.libraries; check; check = check->next )
			{
				// result will be in the local list of libraries (duplicating this one)
				// and will reference the same name(or a byte duplicate)
				if( check != library && !check->loading
					&& ( StrCaseCmp( check->full_name, library->full_name ) == 0
						|| StrCaseCmp( check->name, library->name ) == 0 ) )
				{
					UnlinkThing( library );
					Deallocate( PLIBRARY, library );
					library = check;
					// loaded....
					goto get_function_name;
				}
			}
		}
		library->loading--;
	}
		SuspendDeadstart();
		if( !library->library )
		{
#  ifdef DEBUG_LIBRARY_LOADING
			lprintf( "trying load...%s", library->full_name );
#  endif
			library->library = LoadLibrary( library->full_name );
			if( !library->library )
			{
				library->library = LoadLibrary( library->alt_full_name );
				if( !library->library )
				{
#  ifdef DEBUG_LIBRARY_LOADING
					lprintf( "trying load...%s", library->name );
#  endif
					library->library = LoadLibrary( library->name );
					if( !library->library )
					{
						if( !library->loading )
						{
							if( l.flags.bLog )
								_xlprintf( 2 DBG_RELAY )(WIDE( "Attempt to load %s[%s](%s) failed: %d." ), libname, library->full_name, funcname ? funcname : WIDE( "all" ), GetLastError());
							UnlinkThing( library );
							ReleaseEx( library DBG_SRC );
						}
						ResumeDeadstart();
						return NULL;
					}
				}
			}
		}
#else
		SuspendDeadstart();
#  ifndef __ANDROID__
		// ANDROID This will always fail from the application manager.
#    ifdef UNICODE
		{
			char *tmpname = CStrDup( library->name );
			library->library = dlopen( tmp, RTLD_LAZY|(bPrivate?RTLD_LOCAL: RTLD_GLOBAL) );
			Release( tmpname );
		}
#    else
		library->library = dlopen( library->name, RTLD_LAZY|(bPrivate?RTLD_LOCAL: RTLD_GLOBAL) );
#    endif
		if( !library->library )
		{
			if( l.flags.bLog )
				_xlprintf( 2 DBG_RELAY)( WIDE("Attempt to load %s%s(%s) failed: %s."), bPrivate?"(local)":"(global)", libname, funcname?funcname:"all", dlerror() );
#  endif
#  ifdef UNICODE
			{
				char *tmpname = CStrDup( library->full_name );
				library->library = dlopen( tmpname, RTLD_LAZY|(bPrivate?RTLD_LOCAL: RTLD_GLOBAL) );
				ReleaseEx( tmpname DBG_SRC );
			}
#  else
			library->library = dlopen( library->full_name, RTLD_LAZY|(bPrivate?RTLD_LOCAL:RTLD_GLOBAL) );
#  endif
			if( !library->library )
			{
				_xlprintf( 2 DBG_RELAY)( WIDE("Attempt to load  %s%s(%s) failed: %s."), bPrivate?WIDE("(local)"):WIDE("(global)"), library->full_name, funcname?funcname:WIDE("all"), dlerror() );
				UnlinkThing( library );
				ReleaseEx( library DBG_SRC );
				ResumeDeadstart();
				return NULL;
			}
#  ifndef __ANDROID__
		}
#  endif
}
#endif
#ifdef __cplusplus_cli
		{
			void (CPROC *f)( void );
			if( l.flags.bLog )
				lprintf( WIDE( "GetInvokePreloads" ) );
			f = (void(CPROC*)(void))GetProcAddress( library->library, "InvokePreloads" );
			if( f )
				f();
		}
#endif
		{
			//DebugBreak();
			ResumeDeadstart();
			// actually bInitialDone will not be done sometimes
			// and we need to force this here.
			InvokeDeadstart();
		}
		InvokeLibraryLoad();
	//}
#ifdef _WIN32
get_function_name:
#endif
	if( funcname )
	{
		PFUNCTION function = library->functions;
		while( function )
		{
			if( ((uintptr_t)function->name & 0xFFFF ) == (uintptr_t)function->name ) {
				if( function->name == funcname )
					break;
			} else
				if( StrCmp( function->name, funcname ) == 0 )
					break;
			function = function->next;
		}
		if( !function )
		{
			int len;
			if( library->mapped )
			{
#ifdef WIN32
				PIMAGE_DOS_HEADER source_dos_header = (PIMAGE_DOS_HEADER)library->library;
				PIMAGE_NT_HEADERS source_nt_header = (PIMAGE_NT_HEADERS)Seek( library->library, source_dos_header->e_lfanew );
				if( source_dos_header->e_magic != IMAGE_DOS_SIGNATURE )
					lprintf( WIDE("Basic signature check failed; not a library") );
				if( source_nt_header->Signature != IMAGE_NT_SIGNATURE )
					lprintf(WIDE("Basic NT signature check failed; not a library") );
				if( source_nt_header->FileHeader.SizeOfOptionalHeader )
					if( source_nt_header->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC )
						lprintf(WIDE("Optional header signature is incorrect...") );
				{
					PIMAGE_DATA_DIRECTORY dir;
					PIMAGE_EXPORT_DIRECTORY exp_dir;
					DWORD n;
					int ord;
					dir = (PIMAGE_DATA_DIRECTORY)source_nt_header->OptionalHeader.DataDirectory;
					exp_dir = (PIMAGE_EXPORT_DIRECTORY)Seek( library->library, dir[0].VirtualAddress );
					{
						void (**f)(void) = (void (**)(void))Seek( library->library, exp_dir->AddressOfFunctions );
						char **names = (char**)Seek( library->library, exp_dir->AddressOfNames );
						uint16_t *ords = (uint16_t*)Seek( library->library, exp_dir->AddressOfNameOrdinals );
						if( ( ord = ((uintptr_t)funcname & 0xFFFF ) ) == (uintptr_t)funcname )
						{
							return (generic_function)Seek( library->library, (uintptr_t)f[ord-exp_dir->Base] );
						}
						else
						{
							for( n = 0; n < exp_dir->NumberOfFunctions; n++ )
							{
								char *name = (char*)Seek( library->library, (uintptr_t)names[n] );
								int result;
#  ifdef UNICODE
								TEXTCHAR *_name = DupCStr( name );
#    define name _name
#  endif
								result = StrCmp( name, funcname );
#  ifdef UNICODE
								Deallocate( TEXTCHAR *,_name );
#    undef name _name
#  endif
								if( result == 0 )
								{
									if( ( ((uintptr_t)f[ords[n]] ) < ( dir[0].VirtualAddress + dir[0].Size ) )
										&& ( ((uintptr_t)f[ords[n]] ) > dir[0].VirtualAddress ) )
									{
										char *tmpname;
										char *name = (char*)Seek( library->library, (uintptr_t)f[ords[n]] );
										char *fname = name;
#  ifdef UNICODE
										TEXTCHAR *_tmp_fname;
										TEXTCHAR *_tmp_func;
#  endif
										int len;
										generic_function f;
										while( fname[0] && fname[0] != '.' )
											fname++;
										if( fname[0] )
											fname++;
										tmpname = NewArray( char, len = (int)( fname - name ) + 5 );
										snprintf( tmpname, len, "%*.*s.dll", (int)(fname-name)-1, (int)(fname-name)-1, name );
										//lprintf( "%s:%s = %s:%s", library->name, funcname, tmpname, fname );
#  ifdef UNICODE
										_tmp_fname = DupCStr(tmpname);
										_tmp_func = DupCStr(fname);
#    define tmpname _tmp_fname
#    define fname    _tmp_func
#  endif
										f = LoadFunction( tmpname, fname );
#  ifdef UNICODE
										Deallocate( TEXTCHAR *, _tmp_fname );
										Deallocate( TEXTCHAR *, _tmp_func );
#    undef tmpname
#    undef fname
#  endif
										Deallocate( char *, tmpname );
										return f;
									}
									//lprintf( "%s  %s is %d  %d = %p %p", library->name, name, n, ords[n], f[n], f[ords[n]] );
									return (generic_function)Seek( library->library, (uintptr_t)f[ords[n]] );
								}
							}
						}
					}
				}
#endif
				return NULL;
			}
			else
			{
				if( ( (uintptr_t)funcname & 0xFFFF ) == (uintptr_t)funcname )
				{
					function = NewPlus( FUNCTION, len=0 );
					function->name = funcname;
				}
				else
				{
					function = NewPlus( FUNCTION, (len=(sizeof(TEXTCHAR)*( (uint32_t)StrLen( funcname ) + 1 ) ) ) );
					function->name = function->_name;
					tnprintf( function->_name, len, WIDE( "%s" ), funcname );
				}
			}
			function->library = library;
			function->references = 0;
#ifdef _WIN32
#  ifdef __cplusplus_cli
			char *procname = CStrDup( function->name );
			if( l.flags.bLog )
				lprintf( WIDE( "Get:%s" ), procname );
			if( !(function->function = (generic_function)GetProcAddress( library->library, procname )) )
#  else
#    ifdef _UNICODE
			{
			char *tmp;
#    endif
			  if( l.flags.bLog )
				lprintf( WIDE( "Get:%s" ), (((uintptr_t)function->name&0xFFFF)==(uintptr_t)function->name)?function->name:"ordinal" );
			if( !(function->function = (generic_function)GetProcAddress( library->library
#    ifdef _UNICODE
																						  , tmp = DupTextToChar( function->name )
#    else
																						  , function->name
#    endif
																						  )) )
#  endif
			{
				TEXTCHAR tmpname[128];
#  ifdef UNICODE
				snwprintf( tmpname, sizeof( tmpname ), WIDE("_%s"), funcname );
#  else
				snprintf( tmpname, sizeof( tmpname ), WIDE("_%s"), funcname );
#  endif
#  ifdef __cplusplus_cli
				char *procname = CStrDup( tmpname );
				if( l.flags.bLog )
					lprintf( WIDE( "Get:%s" ), procname );
				function->function = (generic_function)GetProcAddress( library->library, procname );
				ReleaseEx( procname DBG_SRC );
#  else
				if( l.flags.bLog )
					lprintf( WIDE( "Get:%s" ), function->name );
				function->function = (generic_function)GetProcAddress( library->library
#    ifdef _UNICODE
																					  , WcharConvert( tmpname )
#    else
																					  , tmpname
#    endif
																					  );
#  endif
			}
#  ifdef __cplusplus_cli
			ReleaseEx( procname DBG_SRC );
#  else
#    ifdef _UNICODE
			Deallocate( char *, tmp );
			}
#    endif
#  endif
			if( !function->function )
			{
				if( l.flags.bLog )
					_xlprintf( 2 DBG_RELAY)( WIDE("Attempt to get function %s from %s failed. %d"), funcname, libname, GetLastError() );
				ReleaseEx( function DBG_SRC );
				return NULL;
			}
#else
#  ifdef UNICODE
			{
				char *tmpname = CStrDup( function->name );
				library->library = dlsym( library->library, tmpname );
				ReleaseEx( tmpname DBG_SRC );
			}
#  else
			function->function = (generic_function)dlsym( library->library, function->name );
#  endif
			 if( !(function->function) )
			{
				char tmpname[128];
				snprintf( tmpname, 128, "_%s", funcname );
				function->function = (generic_function)dlsym( library->library, tmpname );
			}
			if( !function->function )
			{
				_xlprintf( 2 DBG_RELAY)( WIDE("Attempt to get function %s from %s failed. %s"), funcname, libname, dlerror() );
				ReleaseEx( function DBG_SRC );
				return NULL;
			}
#endif
			if( !l.pFunctionTree )
				l.pFunctionTree = CreateBinaryTree();
			//lprintf( WIDE("Adding function %p"), function->function );
			AddBinaryNode( l.pFunctionTree, function, (uintptr_t)function->function );
			LinkThing( library->functions, function );
		}
		function->references++;
		return function->function;
	}
	else
	{
/*extend precisionfirst*/
 // success, but no function possible.
		return (generic_function)((uintptr_t)library->nLibrary);
	}
	return NULL;
}
SYSTEM_PROC( generic_function, LoadPrivateFunctionEx )( CTEXTSTR libname, CTEXTSTR funcname DBG_PASS )
{
	return LoadFunctionExx( libname, funcname, TRUE DBG_RELAY );
}
SYSTEM_PROC( void *, GetPrivateModuleHandle )( CTEXTSTR libname )
{
	PLIBRARY library = l.libraries;
	while( library )
	{
		if( StrCaseCmp( library->name, libname ) == 0 )
			return library->library;
		library = library->next;
	}
	return NULL;
}
SYSTEM_PROC( generic_function, LoadFunctionEx )( CTEXTSTR libname, CTEXTSTR funcname DBG_PASS )
{
	return LoadFunctionExx( libname, funcname, FALSE DBG_RELAY );
}
#undef LoadFunction
SYSTEM_PROC( generic_function, LoadFunction )( CTEXTSTR libname, CTEXTSTR funcname )
{
	return LoadFunctionEx( libname,funcname DBG_SRC);
}
//-------------------------------------------------------------------------
// pass the address of the function pointer - this
// will gracefully erase that reference also.
SYSTEM_PROC( int, UnloadFunctionEx )( generic_function *f DBG_PASS )
{
	if( !f  )
		return 0;
	_xlprintf( 1 DBG_RELAY )( WIDE("Unloading function %p"), *f );
	if( (uintptr_t)(*f) < 1000 )
	{
		// unload library only...
  // invalid result...
		if( !(*f) )
			return 0;
		{
			PLIBRARY library;
			uintptr_t nFind = (uintptr_t)(*f);
			for( library = l.libraries; library; library = NextLink( library ) )
			{
				if( nFind == library->nLibrary )
				{
#ifdef _WIN32
					// should make sure noone has loaded a specific function.
					FreeLibrary ( library->library );
					UnlinkThing( library );
					ReleaseEx( library DBG_SRC );
#else
#endif
				}
			}
		}
	}
	{
		PFUNCTION function = (PFUNCTION)FindInBinaryTree( l.pFunctionTree, (uintptr_t)(*f) );
		PLIBRARY library;
		if( function &&
			 !(--function->references) )
		{
			UnlinkThing( function );
			lprintf( WIDE( "Should remove the node from the tree here... but it crashes intermittantly. (tree list is corrupted)" ) );
			//RemoveLastFoundNode( l.pFunctionTree );
			library = function->library;
			if( !library->functions )
			{
#ifdef _WIN32
				FreeLibrary( library->library );
#else
				dlclose( library->library );
#endif
				UnlinkThing( library );
				ReleaseEx( library DBG_SRC );
			}
			ReleaseEx( function DBG_SRC );
			*f = NULL;
		}
		else
		{
			lprintf( WIDE("function was not found - or ref count = %") _32f WIDE(" (5566 means no function)"), function?function->references:5566 );
		}
	}
	return FALSE;
}
//-------------------------------------------------------------------------
#if !defined( __ANDROID__ )
SYSTEM_PROC( PTHREAD, SpawnProcess )( CTEXTSTR filename, va_list args )
{
	uintptr_t (CPROC *newmain)( PTHREAD pThread );
	newmain = (uintptr_t(CPROC*)(PTHREAD))LoadFunction( filename, WIDE("main") );
	if( newmain )
	{
		// hmm... suppose I should even thread through my own little header here
		// then when the thread exits I can get a positive acknowledgement?
		return ThreadTo( newmain, (uintptr_t)args );
	}
	return NULL;
}
#endif
//---------------------------------------------------------------------------
TEXTSTR GetArgsString( PCTEXTSTR pArgs )
{
	static TEXTCHAR args[256];
	int len = 0, n;
	args[0] = 0;
	// arg[0] should be the same as program name...
	for( n = 1; pArgs && pArgs[n]; n++ )
	{
		int space = (StrChr( pArgs[n], ' ' )!=NULL);
		len += tnprintf( args + len, sizeof( args ) - len * sizeof( TEXTCHAR ), WIDE("%s%s%s%s")
							, n>1?WIDE(" "):WIDE("")
							, space?WIDE("\""):WIDE("")
							, pArgs[n]
							, space?WIDE("\""):WIDE("")
							);
	}
	return args;
}
CTEXTSTR GetProgramName( void )
{
#ifdef __ANDROID__
	return program_name;
#else
	if( !local_systemlib || !l.filename )
	{
		SystemInit();
		if( !l.filename )
		{
			DebugBreak();
			return NULL;
		}
	}
	return l.filename;
#endif
}
CTEXTSTR GetProgramPath( void )
{
#ifdef __ANDROID__
	return program_path;
#else
	if( !local_systemlib || l.load_path )
	{
		SystemInit();
		if( !l.load_path )
		{
			DebugBreak();
			return NULL;
		}
	}
	return l.load_path;
#endif
}
CTEXTSTR GetLibraryPath( void )
{
#ifdef __ANDROID__
	return library_path;
#else
	if( !local_systemlib || l.library_path )
	{
		SystemInit();
		if( !l.library_path )
		{
			DebugBreak();
			return NULL;
		}
	}
	return l.library_path;
#endif
}
CTEXTSTR GetStartupPath( void )
{
#ifdef __ANDROID__
	return working_path;
#else
	if( !local_systemlib || l.work_path )
	{
		SystemInit();
		if( !l.work_path )
		{
			DebugBreak();
			return NULL;
		}
	}
	return l.work_path;
#endif
}
LOGICAL IsSystemShuttingDown( void )
{
#ifdef WIN32
	static HANDLE h = INVALID_HANDLE_VALUE;
	if( h == INVALID_HANDLE_VALUE )
		h = CreateEvent( NULL, TRUE, FALSE, WIDE( "Windows Is Shutting Down" ) );
	if( h != INVALID_HANDLE_VALUE )
		if( WaitForSingleObject( h, 0 ) == WAIT_OBJECT_0 )
			return TRUE;
#endif
	return FALSE;
}
void SetExternalLoadLibrary( LOGICAL (CPROC*f)(const char *) )
{
	if( !local_systemlib )
		SystemInit();
	l.ExternalLoadLibrary = f;
}
void SetExternalFindProgram( char * (CPROC*f)(const char *) )
{
	if( !local_systemlib )
		SystemInit();
	l.ExternalFindProgram = f;
}
void SetProgramName( CTEXTSTR filename )
{
	SystemInit();
	l.filename = filename;
}
#undef Seek
SACK_SYSTEM_NAMESPACE_END
#define NO_UNICODE_C
#define TASK_INFO_DEFINED
#ifndef __NO_IDLE__
#endif
#ifdef __LINUX__
#include <sys/poll.h>
extern char **environ;
#endif
//--------------------------------------------------------------------------
SACK_SYSTEM_NAMESPACE
typedef struct task_info_tag TASK_INFO;
//--------------------------------------------------------------------------
#ifdef WIN32
static int DumpErrorEx( DBG_VOIDPASS )
#define DumpError() DumpErrorEx( DBG_VOIDSRC )
{
	_lprintf(DBG_RELAY)( WIDE("Failed create process:%d"), GetLastError() );
	return 0;
}
#endif
//--------------------------------------------------------------------------
extern uintptr_t CPROC WaitForTaskEnd( PTHREAD pThread );
static uintptr_t CPROC HandleTaskOutput(PTHREAD thread )
{
	PTASK_INFO task = (PTASK_INFO)GetThreadParam( thread );
	{
		task->pOutputThread = thread;
		// read input from task, montiro close and dispatch TaskEnd Notification also.
		{
			PHANDLEINFO phi = &task->hStdOut;
			PTEXT pInput = SegCreate( 4096 );
			int done, lastloop;
			Hold( task );
			done = lastloop = FALSE;
			do
			{
				uint32_t dwRead;
				if( done )
					lastloop = TRUE;
				{
						if( task->flags.log_input )
							lprintf( WIDE( "Go to read task's stdout." ) );
#ifdef _WIN32
						if( !task->flags.process_ended &&
							 ReadFile( phi->handle
										, GetText( pInput ), (DWORD)(GetTextSize( pInput ) - 1)
  //read the  pipe
										, (LPDWORD)&dwRead, NULL ) )
						{
#else
							dwRead = read( phi->handle
											 , GetText( pInput )
											 , GetTextSize( pInput ) - 1 );
							if( !dwRead )
							{
#  ifdef _DEBUG
												//lprintf( WIDE( "Ending system thread because of broke pipe! %d" ), errno );
#  endif
#  ifdef WIN32
								continue;
#  else
												//lprintf( WIDE( "0 read = pipe failure." ) );
								break;
#  endif
							}
#endif
							if( task->flags.log_input )
								lprintf( WIDE( "got read on task's stdout: %d" ), dwRead );
							if( task->flags.bSentIoTerminator )
							{
								if( dwRead > 1 )
									dwRead--;
								else
								{
									if( task->flags.log_input )
										lprintf( WIDE( "Finished, no more data, task has ended; no need for once more around" ) );
									lastloop = 1;
 // we're done; task ended, and we got an io terminator on XP
									break;
								}
							}
							//lprintf( WIDE( "result %d" ), dwRead );
							GetText( pInput )[dwRead] = 0;
							pInput->data.size = dwRead;
							//LogBinary( GetText( pInput ), GetTextSize( pInput ) );
							if( task->OutputEvent )
							{
								task->OutputEvent( task->psvEnd, task, GetText( pInput ), GetTextSize( pInput ) );
							}
							pInput->data.size = 4096;
#ifdef _WIN32
						}
						else
						{
							DWORD dwError = GetLastError();
							int32_t dwAvail;
							if( ( dwError == ERROR_OPERATION_ABORTED ) && task->flags.process_ended )
							{
								if( PeekNamedPipe( phi->handle, NULL, 0, NULL, (LPDWORD)&dwAvail, NULL ) )
								{
									if( dwAvail > 0 )
									{
										lprintf( WIDE( "caught data" ) );
										// there is still data in the pipe, just that the process closed
										// and we got the sync even before getting the data.
									}
									else
										break;
								}
							}
						}
#endif
				}
				//allow a minor time for output to be gathered before sending
				// partial gathers...
				if( task->flags.process_ended )
				{
					// Ending system thread because of process exit!
 // do one pass to make sure we completed read
					  done = TRUE;
				}
			}
			while( !lastloop );
			//lprintf( "Exited read loop" );
#ifdef _DEBUG
			if( lastloop )
			{
				//DECLTEXT( msg, WIDE( "Ending system thread because of process exit!" ) );
				//EnqueLink( phi->pdp->&ps->Command->Output, &msg );
			}
			else
			{
				//DECLTEXT( msg, WIDE( "Guess we exited from broken pipe" ) );
				//EnqueLink( phi->pdp->&ps->Command->Output, &msg );
			}
#endif
			LineRelease( pInput );
#ifdef _WIN32
			CloseHandle( task->hReadIn );
			CloseHandle( task->hReadOut );
			CloseHandle( task->hWriteIn );
			CloseHandle( task->hWriteOut );
			//lprintf( WIDE( "Closing process handle %p" ), task->pi.hProcess );
			phi->hThread = 0;
#else
			//close( phi->handle );
			close( task->hStdIn.pair[1] );
			close( task->hStdOut.pair[0] );
			//close( task->hStdErr.pair[0] );
#define INVALID_HANDLE_VALUE -1
#endif
			if( phi->handle == task->hStdIn.handle )
				task->hStdIn.handle = INVALID_HANDLE_VALUE;
			phi->handle = INVALID_HANDLE_VALUE;
			task->pOutputThread = NULL;
			Release( task );
			//WakeAThread( phi->pdp->common.Owner );
			return 0xdead;
		}
	}
}
//--------------------------------------------------------------------------
static int FixHandles( PTASK_INFO task )
{
#ifdef WIN32
	if( task->pi.hProcess )
		CloseHandle( task->pi.hProcess );
	task->pi.hProcess = 0;
	if( task->pi.hProcess )
		CloseHandle( task->pi.hThread );
	task->pi.hThread = 0;
#endif
 // must return 0 so expression continues
	return 0;
}
//--------------------------------------------------------------------------
void ResumeProgram( PTASK_INFO task )
{
#ifdef WIN32
	//DWORD WINAPI ResumeThread(  _In_ HANDLE hThread);
	ResumeThread( task->pi.hThread );
#endif
}
uintptr_t GetProgramAddress( PTASK_INFO task ) {
#ifdef WIN32
	/*
	BOOL WINAPI GetThreadContext(
  _In_	 HANDLE    hThread,
  _Inout_ LPCONTEXT lpContext
  );
  */
	uintptr_t memstart;
	CONTEXT ctx;
#ifdef __64__
	WOW64_CONTEXT ctx64;
	ctx64.ContextFlags = CONTEXT_INTEGER;
	Wow64GetThreadContext( task->pi.hThread, &ctx64 );
	memstart = ctx64.Ebx;
	ctx.ContextFlags = CONTEXT_INTEGER;
	GetThreadContext( task->pi.hThread, &ctx );
	//memstart = ctx.Ebx;
	return memstart;
#else
	GetThreadContext( task->pi.hThread, &ctx );
	memstart = ctx.Ebx;
	return memstart;
#endif
#else
	lprintf( "non-windows system; cannot find program address... yet" );
	return 0;
#endif
}
#if 0
void LoadReadExe( PTASK_INFO task, uintptr_t base )
   //-------------------------------------------------------
// function to process a currently loaded program to get the
// data offset at the end of the executable.
{
#ifdef WIN32
#  define Seek(a,b) (((uintptr_t)a)+(b))
	//uintptr_t source_memory_length = block_len;
	//POINTER source_memory = block;
	{
// = (PIMAGE_DOS_HEADER)source_memory;
		IMAGE_DOS_HEADER source_dos_header;
// = (PIMAGE_NT_HEADERS)Seek( source_memory, source_dos_header->e_lfanew );
		PIMAGE_NT_HEADERS source_nt_header;
		SIZE_T nRead;
		ReadProcessMemory( task->pi.hProcess, (void*)base, (void*)&source_dos_header, sizeof( source_dos_header ), &nRead );
		LogBinary((uint8_t*) &source_dos_header, sizeof( source_dos_header ));
		if( source_dos_header.e_magic != IMAGE_DOS_SIGNATURE ) {
			LoG( "Basic signature check failed; not a library" );
			return ;
		}
/*
		if( source_nt_header->Signature != IMAGE_NT_SIGNATURE ) {
			LoG( "Basic NT signature check failed; not a library" );
			return NULL;
		}
		if( source_nt_header->FileHeader.SizeOfOptionalHeader )
		{
			if( source_nt_header->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC )
			{
				LoG( "Optional header signature is incorrect..." );
				return NULL;
			}
		}
		{
			int n;
			long FPISections = source_dos_header->e_lfanew
				+ sizeof( DWORD ) + sizeof( IMAGE_FILE_HEADER )
				+ source_nt_header->FileHeader.SizeOfOptionalHeader;
			PIMAGE_SECTION_HEADER source_section = (PIMAGE_SECTION_HEADER)Seek( source_memory, FPISections );
			uintptr_t dwSize = 0;
			uintptr_t newSize;
			source_section = (PIMAGE_SECTION_HEADER)Seek( source_memory, FPISections );
			for( n = 0; n < source_nt_header->FileHeader.NumberOfSections; n++ )
			{
				newSize = (source_section[n].PointerToRawData) + source_section[n].SizeOfRawData;
				if( newSize > dwSize )
					dwSize = newSize;
			}
			dwSize += (BLOCK_SIZE*2)-1; // pad 1 full block, plus all but 1 byte of a full block(round up)
			dwSize &= ~(BLOCK_SIZE-1); // mask off the low bits; floor result to block boundary
			return (POINTER)Seek( source_memory, dwSize );
			}
		*/
	}
#  undef Seek
#else
	// need to get elf size...
	return 0;
#endif
}
#endif
//--------------------------------------------------------------------------
#ifdef WIN32
extern HANDLE GetImpersonationToken( void );
#endif
// Run a program completely detached from the current process
// it runs independantly.  Program does not suspend until it completes.
// No way at all to know if the program works or fails.
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgramExx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
															  , int flags
															  , TaskOutput OutputHandler
															  , TaskEnd EndNotice
															  , uintptr_t psv
																DBG_PASS
															  )
{
	PTASK_INFO task;
	TEXTSTR expanded_path = ExpandPath( program );
	TEXTSTR expanded_working_path = path?ExpandPath( path ):ExpandPath( WIDE(".") );
	if( program && program[0] )
	{
#ifdef WIN32
		int launch_flags = ( ( flags & LPP_OPTION_NEW_CONSOLE ) ? CREATE_NEW_CONSOLE : 0 )
		                 | ( ( flags & LPP_OPTION_NEW_GROUP ) ? CREATE_NEW_PROCESS_GROUP : 0 )
		                 | ( ( flags & LPP_OPTION_SUSPEND ) ? CREATE_SUSPENDED : 0 )
			;
		PVARTEXT pvt = VarTextCreateEx( DBG_VOIDRELAY );
		PTEXT cmdline;
		TEXTSTR new_path;
		PTEXT final_cmdline;
		LOGICAL needs_quotes;
		int first = TRUE;
		//TEXTCHAR saved_path[256];
		task = (PTASK_INFO)AllocateEx( sizeof( TASK_INFO ) DBG_RELAY );
		MemSet( task, 0, sizeof( TASK_INFO ) );
		task->psvEnd = psv;
		task->EndNotice = EndNotice;
		if( l.ExternalFindProgram ) {
			new_path = l.ExternalFindProgram( expanded_path );
			if( new_path ) {
				Release( expanded_path );
				expanded_path = new_path;
			}
		}
#ifdef _DEBUG
		//xlprintf(LOG_NOISE)( WIDE("%s[%s]"), path, expanded_working_path );
#endif
		if( StrCmp( path, WIDE(".") ) == 0 )
		{
			path = NULL;
			Release( expanded_working_path );
			expanded_working_path = NULL;
		}
		if( expanded_path && StrChr( expanded_path, ' ' ) )
			needs_quotes = TRUE;
		else
			needs_quotes = FALSE;
		if( needs_quotes )
			vtprintf( pvt, WIDE( "\"" ) );
		/*
		if( !IsAbsolutePath( expanded_path ) && expanded_working_path )
		{
			//lprintf( "needs working path too" );
			vtprintf( pvt, WIDE("%s/"), expanded_working_path );
		}
		*/
		vtprintf( pvt, WIDE("%s"), expanded_path );
		if( needs_quotes )
			vtprintf( pvt, WIDE( "\"" ) );
		if( flags & LPP_OPTION_FIRST_ARG_IS_ARG )
			;
		else
		{
// arg[0] is passed with linux programs, and implied with windows.
			if( args && args[0] )
				args++;
		}
		while( args && args[0] )
		{
			if( args[0][0] == 0 )
				vtprintf( pvt, WIDE( " \"\"" ) );
			else if( StrChr( args[0], ' ' ) )
				vtprintf( pvt, WIDE(" \"%s\""), args[0] );
			else
				vtprintf( pvt, WIDE(" %s"), args[0] );
			first = FALSE;
			args++;
		}
		cmdline = VarTextGet( pvt );
		vtprintf( pvt, WIDE( "cmd.exe /c %s" ), GetText( cmdline ) );
		final_cmdline = VarTextGet( pvt );
		VarTextDestroy( &pvt );
		MemSet( &task->si, 0, sizeof( STARTUPINFO ) );
		task->si.cb = sizeof( STARTUPINFO );
#ifdef _DEBUG
		//xlprintf(LOG_NOISE)( WIDE( "quotes?%s path [%s] program [%s]  [cmd.exe (%s)]"), needs_quotes?WIDE( "yes"):WIDE( "no"), expanded_working_path, expanded_path, GetText( final_cmdline ) );
#endif
		/*
		if( path )
		{
			GetCurrentPath( saved_path, sizeof( saved_path ) );
			SetCurrentPath( path );
		}
		*/
		task->OutputEvent = OutputHandler;
		if( OutputHandler )
		{
			SECURITY_ATTRIBUTES sa;
			sa.bInheritHandle = TRUE;
			sa.lpSecurityDescriptor = NULL;
			sa.nLength = sizeof( sa );
			CreatePipe( &task->hReadOut, &task->hWriteOut, &sa, 0 );
			//CreatePipe( &hReadErr, &hWriteErr, &sa, 0 );
			CreatePipe( &task->hReadIn, &task->hWriteIn, &sa, 0 );
			task->si.hStdInput = task->hReadIn;
			task->si.hStdError = task->hWriteOut;
			task->si.hStdOutput = task->hWriteOut;
			task->si.dwFlags |= STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
			if( !( flags & LPP_OPTION_DO_NOT_HIDE ) )
				task->si.wShowWindow = SW_HIDE;
			else
				task->si.wShowWindow = SW_SHOW;
		}
		else
		{
			task->si.dwFlags |= STARTF_USESHOWWINDOW;
			if( !( flags & LPP_OPTION_DO_NOT_HIDE ) )
				task->si.wShowWindow = SW_HIDE;
			else
				task->si.wShowWindow = SW_SHOW;
		}
		{
			HINSTANCE hShellProcess = 0;
			int success = 0;
#ifdef WIN32
			if( flags & LPP_OPTION_IMPERSONATE_EXPLORER )
			{
				HANDLE hExplorer = GetImpersonationToken();
 //program
				if( ( CreateProcessAsUser( hExplorer, NULL
												 , GetText( cmdline )
												 , NULL, NULL, TRUE
												 , launch_flags | CREATE_NEW_PROCESS_GROUP
												 , NULL
												 , expanded_working_path
												 , &task->si
												 , &task->pi ) || FixHandles(task) || DumpError() ) ||
					( CreateProcessAsUser( hExplorer, program
												, GetText( cmdline )
												, NULL, NULL, TRUE
												, launch_flags | CREATE_NEW_PROCESS_GROUP
												, NULL
												, expanded_working_path
												, &task->si
												, &task->pi ) || FixHandles(task) || DumpError() ) ||
					( CreateProcessAsUser( hExplorer, program
 // GetText( cmdline )
												, NULL
												, NULL, NULL, TRUE
												, launch_flags | CREATE_NEW_PROCESS_GROUP
												, NULL
												, expanded_working_path
												, &task->si
												, &task->pi ) || FixHandles(task) || DumpError() ) ||
					( CreateProcessAsUser( hExplorer, WIDE( "cmd.exe" )
												, GetText( final_cmdline )
												, NULL, NULL, TRUE
												, launch_flags | CREATE_NEW_PROCESS_GROUP
												, NULL
												, expanded_working_path
												, &task->si
												, &task->pi ) || FixHandles(task) || DumpError() )
				  )
				{
					success = 1;
				}
				CloseHandle( hExplorer );
			}
			else
#endif
			{
				if( ( CreateProcess( program
										, GetText( cmdline )
										, NULL, NULL, TRUE
//CREATE_NEW_PROCESS_GROUP
										, launch_flags | ( OutputHandler?CREATE_NO_WINDOW:0 )
										, NULL
										, expanded_working_path
										, &task->si
										, &task->pi ) || FixHandles(task) || DumpError() ) ||
 //program
					( CreateProcess( NULL
										 , GetText( cmdline )
										 , NULL, NULL, TRUE
//CREATE_NEW_PROCESS_GROUP
										 , launch_flags | ( OutputHandler?CREATE_NO_WINDOW:0 )
										 , NULL
										 , expanded_working_path
										 , &task->si
										 , &task->pi ) || FixHandles(task) || DumpError() ) ||
					( CreateProcess( program
 // GetText( cmdline )
										, NULL
										, NULL, NULL, TRUE
//CREATE_NEW_PROCESS_GROUP
										, launch_flags | ( OutputHandler?CREATE_NO_WINDOW:0 )
										, NULL
										, expanded_working_path
										, &task->si
										, &task->pi ) || FixHandles(task) || DumpError() ) ||
					( TryShellExecute( task, expanded_working_path, program, cmdline ) ) ||
//WIDE( "cmd.exe" )
					( CreateProcess( NULL
										, GetText( final_cmdline )
										, NULL, NULL, TRUE
//CREATE_NEW_PROCESS_GROUP
										, launch_flags | ( OutputHandler?CREATE_NO_WINDOW:0 )
										, NULL
										, expanded_working_path
										, &task->si
										, &task->pi ) || FixHandles(task) || DumpError() ) ||
				   0
				  )
				{
					success = 1;
				}
			}
			if( success )
			{
				//CloseHandle( task->hReadIn );
				//CloseHandle( task->hWriteOut );
#ifdef _DEBUG
				//xlprintf(LOG_NOISE)( WIDE("Success running %s[%s] in %s (%p): %d"), program, GetText( cmdline ), expanded_working_path, task->pi.hProcess, GetLastError() );
#endif
				if( OutputHandler )
				{
					task->hStdIn.handle	 = task->hWriteIn;
					task->hStdIn.pLine	 = NULL;
					//task->hStdIn.pdp		 = pdp;
					task->hStdIn.hThread  = 0;
					task->hStdIn.bNextNew = TRUE;
					task->hStdOut.handle	  = task->hReadOut;
					task->hStdOut.pLine	  = NULL;
					//task->hStdOut.pdp		  = pdp;
					task->hStdOut.bNextNew = TRUE;
					task->hStdOut.hThread  = ThreadTo( HandleTaskOutput, (uintptr_t)task );
					ThreadTo( WaitForTaskEnd, (uintptr_t)task );
				}
				else
				{
					//task->hThread =
					ThreadTo( WaitForTaskEnd, (uintptr_t)task );
				}
			}
			else
			{
				xlprintf(LOG_NOISE)( WIDE("Failed to run %s[%s]: %d"), program, GetText( cmdline ), GetLastError() );
				CloseHandle( task->hWriteIn );
				CloseHandle( task->hReadIn );
				CloseHandle( task->hWriteOut );
				CloseHandle( task->hReadOut );
				CloseHandle( task->pi.hProcess );
				CloseHandle( task->pi.hThread );
				Release( task );
				task = NULL;
			}
		}
		LineRelease( cmdline );
		LineRelease( final_cmdline );
		Release( expanded_working_path );
		Release( expanded_path );
		/*
		if( path )
		SetCurrentPath( saved_path );
		*/
		return task;
#endif
#ifdef __LINUX__
		{
			pid_t newpid;
			TEXTCHAR saved_path[256];
			task = (PTASK_INFO)Allocate( sizeof( TASK_INFO ) );
			MemSet( task, 0, sizeof( TASK_INFO ) );
			task->psvEnd = psv;
			task->EndNotice = EndNotice;
			task->OutputEvent = OutputHandler;
			if( OutputHandler )
			{
				if( pipe(task->hStdIn.pair) < 0 ) {
					Release( expanded_working_path );
					Release( expanded_path );
					return NULL;
				}
				task->hStdIn.handle = task->hStdIn.pair[1];
				if( pipe(task->hStdOut.pair) < 0 ) {
					Release( expanded_working_path );
					Release( expanded_path );
					return NULL;
				}
				task->hStdOut.handle = task->hStdOut.pair[0];
			}
			// always have to thread to taskend so waitpid can clean zombies.
			ThreadTo( WaitForTaskEnd, (uintptr_t)task );
			if( path )
			{
				GetCurrentPath( saved_path, sizeof( saved_path ) );
				SetCurrentPath( path );
			}
			if( !( newpid = fork() ) )
			{
				char *_program = CStrDup( program );
				// in case exec fails, we need to
				// drop any registered exit procs...
				//close( task->hStdIn.pair[1] );
				//close( task->hStdOut.pair[0] );
				//close( task->hStdErr.pair[0] );
				if( OutputHandler ) {
					dup2( task->hStdIn.pair[0], 0 );
					dup2( task->hStdOut.pair[1], 1 );
					dup2( task->hStdOut.pair[1], 2 );
				}
				DispelDeadstart();
				//usleep( 100000 );
				execve( _program, (char *const*)args, environ );
				lprintf( WIDE( "Direct execute failed... trying along path..." ) );
				{
					char *tmp = strdup( getenv( "PATH" ) );
					char *tok;
					for( tok = strtok( tmp, ":" ); tok; tok = strtok( NULL, ":" ) )
					{
						char fullname[256];
						snprintf( fullname, sizeof( fullname ), "%s/%s", tok, _program );
						lprintf( WIDE( "program:[%s]" ), fullname );
						((char**)args)[0] = fullname;
						execve( fullname, (char*const*)args, environ );
					}
					Release( tmp );
				}
				lprintf( WIDE( "exec failed - and this is ALLL bad... %d" ), errno );
				if( OutputHandler ) {
					close( task->hStdIn.pair[0] );
					close( task->hStdOut.pair[1] );
				}
				//close( task->hWriteErr );
				close( 0 );
				close( 1 );
				close( 2 );
				//DebugBreak();
				// well as long as this runs before
				// the other all will be well...
				task = NULL;
				// shit - what can I do now?!
 // just in case exec fails... need to fault this.
				exit(0);
			}
			else
			{
				if( OutputHandler ) {
					close( task->hStdIn.pair[0] );
					close( task->hStdOut.pair[1] );
				}
			}
			if( OutputHandler )
				ThreadTo( HandleTaskOutput, (uintptr_t)task );
			task->pid = newpid;
			// how can I know if the command failed?
			// well I can't - but the user's callback will be invoked
			// when the above exits.
			if( path )
			{
				// if path is NULL we didn't change the path...
				SetCurrentPath( saved_path );
			}
			Release( expanded_working_path );
			Release( expanded_path );
			return task;
		}
#endif
	}
	Release( expanded_working_path );
	Release( expanded_path );
	return FALSE;
}
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgramEx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
															 , TaskOutput OutputHandler
															 , TaskEnd EndNotice
															 , uintptr_t psv
                                                DBG_PASS
															  )
{
	return LaunchPeerProgramExx( program, path, args, LPP_OPTION_DO_NOT_HIDE, OutputHandler, EndNotice, psv DBG_RELAY );
}
//------------- System() ---------- simplest form of launch process (with otuput handler, and pprintf support )
struct task_end_notice
{
	PTHREAD thread;
	LOGICAL ended;
	uintptr_t psv_output;
	TaskOutput output_handler;
};
static void CPROC SystemTaskEnd( uintptr_t psvUser, PTASK_INFO task )
{
	struct task_end_notice *end_data = (struct task_end_notice *)psvUser;
	end_data->ended = TRUE;
	WakeThread( end_data->thread );
}
static void CPROC SystemOutputHandler( uintptr_t psvUser, PTASK_INFO Task, CTEXTSTR buffer, size_t len )
{
	struct task_end_notice *end_data = (struct task_end_notice *)psvUser;
	end_data->output_handler( end_data->psv_output, Task, buffer, len );
}
ATEXIT( SystemAutoShutdownTasks )
{
	INDEX idx;
	PTASK_INFO task;
	if( local_systemlib )
		LIST_FORALL( (*local_systemlib).system_tasks, idx, PTASK_INFO, task )
		{
			TerminateProgram( task );
		}
}
SYSTEM_PROC( PTASK_INFO, SystemEx )( CTEXTSTR command_line
															  , TaskOutput OutputHandler
															  , uintptr_t psv
																DBG_PASS
											)
{
	TEXTCHAR *command_line_tmp = StrDup( command_line );
	struct task_end_notice end_notice;
	PTASK_INFO result;
	int argc;
	TEXTSTR *argv;
	end_notice.ended = FALSE;
	end_notice.thread = MakeThread();
	end_notice.psv_output = psv;
	end_notice.output_handler = OutputHandler;
	ParseIntoArgs( command_line_tmp, &argc, &argv );
	Release( command_line_tmp );
	result = LaunchPeerProgramExx( argv[0], NULL, (PCTEXTSTR)argv, 0, OutputHandler?SystemOutputHandler:NULL, SystemTaskEnd, (uintptr_t)&end_notice DBG_RELAY );
	if( result )
	{
		AddLink( &(*local_systemlib).system_tasks, result );
		// we'll get woken when it ends, might as well be infinite.
		while( !end_notice.ended )
		{
#ifndef __NO_IDLE__
			if( !Idle( ) )
				WakeableSleep( 10000 );
			else
				Relinquish();
#else
			WakeableSleep( 25 );
#endif
		}
		DeleteLink( &(*local_systemlib).system_tasks, result );
	}
	{
		POINTER tmp = (POINTER)argv;
		while( argv[0] )
		{
			Release( (POINTER)argv[0] );
			argv++;
		}
		Release( tmp );
	}
	return result;
}
//----------------------- Utility to send to launched task's stdin ----------------------------
int vpprintf( PTASK_INFO task, CTEXTSTR format, va_list args )
{
	PVARTEXT pvt = VarTextCreate();
	PTEXT output;
	vvtprintf( pvt, format, args );
	output = VarTextGet( pvt );
	if(
#ifdef _WIN32
		WaitForSingleObject( task->pi.hProcess, 0 )
#else
		task->pid != waitpid( task->pid, NULL, WNOHANG )
#endif
	  )
	{
#ifdef _WIN32
		DWORD dwWritten;
#endif
		//lprintf( "Allowing write to process pipe..." );
		{
			PTEXT seg = output;
			while( seg )
			{
#ifdef _WIN32
				//LogBinary( GetText( seg )
				//			, GetTextSize( seg ) );
					WriteFile( task->hStdIn.handle
							, GetText( seg )
							, (DWORD)GetTextSize( seg )
							, &dwWritten
							, NULL );
#else
				{
					struct pollfd pfd = { task->hStdIn.handle, POLLHUP|POLLERR, 0 };
					if( poll( &pfd, 1, 0 ) &&
						 pfd.revents & POLLERR )
					{
						Log( WIDE( "Pipe has no readers..." ) );
							break;
					}
					LogBinary( (uint8_t*)GetText( seg ), GetTextSize( seg ) );
					write( task->hStdIn.handle
						 , GetText( seg )
						 , GetTextSize( seg ) );
				}
#endif
				seg = NEXTLINE(seg);
			}
		}
		LineRelease( output );
	}
	else
	{
		lprintf( WIDE("Task has ended, write  aborted.") );
	}
	VarTextDestroy( &pvt );
	return 0;
}
int pprintf( PTASK_INFO task, CTEXTSTR format, ... )
{
	va_list args;
	va_start( args, format );
	return vpprintf( task, format, args );
}
SACK_SYSTEM_NAMESPACE_END
//-------------------------------------------------------------------------
#ifndef SYSTEM_SOURCE
#define SYSTEM_SOURCE
#endif
SACK_SYSTEM_NAMESPACE
SYSTEM_PROC( void, ParseIntoArgs )( TEXTCHAR *lpCmdLine, int *pArgc, TEXTCHAR ***pArgv )
{
	TEXTCHAR *args = lpCmdLine;
	TEXTCHAR  *p;
	TEXTCHAR **pp;
   //TEXTCHAR argc; // result variable, count is a temp counter...
 // result variable, pp is a temp pointer
   TEXTCHAR **argv;
	TEXTCHAR quote = 0;
   int escape = 0;
	int count = 0;
	int lastchar;
 // auto continue spaces...
	lastchar = ' ';
	//lprintf( WIDE("Got args: %s"), args );
	p = args;
	while( p && p[0] )
	{
		//lprintf( WIDE("check character %c %c"), lastchar, p[0] );
		if( escape ) {
			if( p[0] == '\"' || p[0] == '\'' ) {
				escape = 0;
            count++;
			}
			else {
				escape = 0;
            count += 2;
			}
		}
		else if( p[0] == '\\' ) {
			escape = 1;
         count++;
		}
		else if( quote )
		{
			if( p[0] == quote )
			{
				count++;
				quote = 0;
				lastchar = ' ';
			}
		}
		else
		{
			if( p[0] == '\"' || p[0] == '\'' )
				quote = p[0];
			else
			{
 // and there's a space
				if( lastchar != ' ' && p[0] == ' ' )
				{
					count++;
				}
				else if( lastchar == ' ' && p[0] != ' ' )
				{
				}
			}
			lastchar = p[0] ;
		}
		p++;
	}
	if( quote )
 // complete this argument
		count++;
	else if( p != args )
      count++;
	if( count )
	{
		TEXTCHAR *start;
 // auto continue spaces...
		lastchar = ' ';
      //lprintf( "Array is %d (+2?)", count );
		pp = argv = NewArray( TEXTCHAR*, count + 2 );
		//argc = count - 2;
		p = args;
		quote = 0;
		count = 0;
		//pp[count++] = StrDup( pTask->pTask ); // setup arg to equal program (needed for linux stuff)
		start = NULL;
		while( p[0] )
		{
			//lprintf( WIDE("check character %c %c"), lastchar, p[0] );
			if( escape ) {
				escape = 0;
			}
			else if( p[0] == '\\' ) {
				escape = 1;
			}
			else if( quote )
			{
				if( !escape ) {
					if( !start )
						start = p;
					if( p[0] == quote )
					{
						p[0] = 0;
						pp[count++] = StrDup( start );
						p[0] = quote;
						quote = 0;
						start = NULL;
						lastchar = ' ';
					}
				}
			}
			else
			{
				if( !escape ) {
					if( p[0] == '\"' || p[0] == '\'' )
						quote = p[0];
					else
					{
 // and there's a space
						if( lastchar != ' ' && p[0] == ' ' )
						{
							p[0] = 0;
							pp[count++] = StrDup( start );
							start = NULL;
							p[0] = ' ';
						}
						else if( lastchar == ' ' && p[0] != ' ' )
						{
							if( !start )
								start = p;
						}
					}
					lastchar = p[0] ;
				}
			}
			p++;
		}
		//lprintf( WIDE("Setting arg %d to %s"), count, start );
		if( start )
			pp[count++] = StrDup( start );
		pp[count] = NULL;
      if( pArgc )
			(*pArgc) = count;
      if( pArgv )
			(*pArgv) = argv;
	}
	else
	{
      if( pArgc )
			(*pArgc) = 0;
		if( pArgv )
		{
			(*pArgv) = NewArray( TEXTCHAR*, 1 );
			(*pArgv)[0] = NULL;
		}
	}
}
SACK_SYSTEM_NAMESPACE_END
#ifndef __LINUX__
#include <objbase.h>
#ifdef __cplusplus
namespace sack { namespace system{
#endif
void InitCo( void )
{
	CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
}
#ifdef __cplusplus
}
}
#endif
#endif
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   Adds functionality of timers that run dispatched from a single thread
 *   timer delay is trackable to provide self adjusting reliable frequency dispatch.
 *
 *   RemoveTimer( AddTimer( tick_frequency, timer_callback, user_data ) );
 *
 */
//#define ENABLE_CRITICALSEC_LOGGING
#define NO_UNICODE_C
// this is a cheat to get the critical section
// object... otherwise we'd have had circular
// linking reference between this and sharemem
// which would prefer to implement wakeablesleep
// for critical section waiting...
// must be included before memlib..
//#undef UNICODE
#define MEMORY_STRUCT_DEFINED
#define DEFINE_MEMORY_STRUCT
#define THREAD_STRUCTURE_DEFINED
 // Sleep()
 // SimpleRegisterAndCreateGlobal
// sorry if this causes problems...
// maybe promote this include into stdhdrs when this fails to compile
#ifdef __WATCOMC__
// _beginthread
#undef exit
#undef getenv
// process.h redefines exit
#include <process.h>
#endif
#ifndef __NO_OPTIONS__
#endif
#define DO_LOGGING
// display pause/resume support.
/* <link sack::image::render::PRENDERER, Render> provides a
   method to display images on a screen. It is the interface
   between memory images and the window desktop or frame buffer
   the user is viewing on a monitor.
   Under windows, this is implemented as an HWND and an HBITMAP
   used to allow the application to draw. Updates are done
   directly from the drawable surface to the HWND as appropriate
   for the type of service. This is implemented with Vidlib.dll.
   Under Linux, this is mounted against SDL. SDL, however, does
   not give multiple display surfaces, so a more direct method
   should be used someday, other than SDL does a good job of
   aliasing frame buffer and X display windows to a consistant
   interface. This is implemented wit DisplayLib (as yet outside
   of the documentation). Display lib can interface either
   directly, or be mounted as a service across from a shared
   memory message service, and host multiple applications on a
   single frame buffer surface.
   TODO
   Implement displays as direct X displays, and allow managment
   there under linux.
   Displaylib was a good project, and although suffers from
   code-rot, it is probably still mostly usable. Message
   services were easily transported across a network, but then
   location services started failing.
   Example
   <code lang="c++">
   // get a render display, just a default window of some size
   // extended features are available for more precision.
   Render render = OpenDisplay(0);
   </code>
   A few methods of using this surface are available. One, you
   may register for events, and be called as required.
   <code lang="c++">
   RedrawCallback MyDraw = DrawHandler;
   MouseCallback MyMouse;
   </code>
   <code>
   KeyProc MyKey;
   CloseCallback MyClose;
   </code>
   <code lang="c++">
   // called when the surface is initially shown, or when its surface changes.
   // otherwise, the image drawn by the application is static, and does
   // not get an update event.
   SetRedrawHandler( render, MyDraw, 0 );
   // This will get an event every time a mouse event happens.
   // If no Key handler is specified, key strokes will also be mouse events.
   SetMouseHandler( render, MyMouse, 0 );
   // If the window was closed, get an event.
   SetCloseHandler( render, MyClose, 0 );
   // specify a handler to get keyboard events...
   SetKeyboardHandler( render, MyKey, 0 );
   </code>
   Or, if you don't really care about any events...
   <code lang="c++">
   // load an image
   Image image = LoadImageFile( "sample.jpg" );
   // get the image target of render
   Image display = GetDisplayImage( render );
   // copy the loaded image to the display image
   BlotImage( display, image );
   // and update the display
   UpdateDisplay( render );
   </code>
   <code lang="c++">
   void CPROC DrawHandler( uintptr_t psvUserData, 31~PRENDERER render )
   {
       Image display = GetDisplayImage( render );
       // the display image may change, because of an external resize
       // update the image to display as desired...
       // when done, the draw handler should call UpdateDisplay or...
       UpdateDisplayPortion( render, 0, 0, 100, 100 );
   }
   </code>
   Oh! And most importantly! Have to call this to put the window
   on the screen.
   <code lang="c++">
   UpdateDisplay( render );
   </code>
   Or maybe can pretend it was hidden
   <code lang="c++">
   RestoreDisplay( render );
   </code>                                                                     */
// this shouldprobably be interlocked with
//  display.h or vidlib.h(video.h)
#ifndef RENDER_INTERFACE_INCLUDED
// multiple inclusion protection symbol.
#define RENDER_INTERFACE_INCLUDED
#ifdef __cplusplus
#ifdef _D3D_DRIVER
#define RENDER_NAMESPACE namespace sack { namespace image { namespace render { namespace d3d {
#define _RENDER_NAMESPACE namespace render { namespace d3d {
#define RENDER_NAMESPACE_END }}}}
#elif defined( _D3D10_DRIVER )
#define RENDER_NAMESPACE namespace sack { namespace image { namespace render { namespace d3d10 {
#define _RENDER_NAMESPACE namespace render { namespace d3d10 {
#define RENDER_NAMESPACE_END }}}}
#elif defined( _D3D11_DRIVER )
#define RENDER_NAMESPACE namespace sack { namespace image { namespace render { namespace d3d11 {
#define _RENDER_NAMESPACE namespace render { namespace d3d11 {
#define RENDER_NAMESPACE_END }}}}
#else
#define RENDER_NAMESPACE namespace sack { namespace image { namespace render {
/* <copy render.h>
   \ \             */
#define _RENDER_NAMESPACE namespace render {
#define RENDER_NAMESPACE_END }}}
#endif
#else
#define RENDER_NAMESPACE
#define _RENDER_NAMESPACE
#define RENDER_NAMESPACE_END
#endif
#ifndef KEYBOARD_DEFINITION
#define KEYBOARD_DEFINITION
#ifdef __cplusplus
#define _RENDER_KEYBOARD_NAMESPACE namespace keyboard {
#define _RENDER_KEYBOARD_NAMESPACE_END }
#else
#define _RENDER_KEYBOARD_NAMESPACE
#define _RENDER_KEYBOARD_NAMESPACE_END
#endif
RENDER_NAMESPACE
   _RENDER_KEYBOARD_NAMESPACE
			/* Keyboard state tracking structure... not very optimal...
			   \internal usage might be different.                      */
			enum KeyUpDownState {
KEYISUP   =2,
KEYISDOWN =1
			};
/* <combine sack::image::render::keyboard::keyboard_tag>
   \ \                                                   */
typedef struct keyboard_tag KEYBOARD;
/* <combine sack::image::render::keyboard::keyboard_tag>
   \ \                                                   */
typedef struct keyboard_tag *PKEYBOARD;
struct keyboard_tag
{
#define NUM_KEYS 256
   /* one byte index... more than sufficient
      if character in array is '1' key is down, '2' key is up. */
   char keyupdown[NUM_KEYS];
   /* Indicator that the key is a double-tap, not just a single.
      "!! is different that "!" "!                               */
   char keydouble[NUM_KEYS];
   /* time of the last key event */
   unsigned int  keytime[NUM_KEYS];
   /* I'm not sure, maybe it's the printable key char? */
		unsigned char key[NUM_KEYS];
#if 0
	// void (*Proc)(uintptr_t psv)[NUM_KEYS][8];
#endif
};
_RENDER_KEYBOARD_NAMESPACE_END
RENDER_NAMESPACE_END
#ifdef __cplusplus
#  ifdef _D3D_DRIVER
     using namespace sack::image::render::d3d::keyboard;
#  elif defined( _D3D10_DRIVER )
     using namespace sack::image::render::d3d10::keyboard;
#  elif defined( _D3D11_DRIVER )
     using namespace sack::image::render::d3d11::keyboard;
#  else
     using namespace sack::image::render::keyboard;
#  endif
#endif
//#include "vidlib.h"
	// some common things which are specific to this
   // library, and independant of implementation (so far)
#define KEY_MOD_SHIFT 1
#define KEY_MOD_CTRL  2
#define KEY_MOD_ALT   4
// call trigger on release also...
#define KEY_MOD_RELEASE  8
 // application wants both press and release events.
#define KEY_MOD_ALL_CHANGES  16
 // key match must be extended also... (extra arrow keys for instance.. what about SDL)
#define KEY_MOD_EXTENDED 32
#define KEY_PRESSED         0x80000000
#define IsKeyPressed( keycode ) ( (keycode) & 0x80000000 )
#define KEY_ALT_DOWN        0x40000000
#define KEY_CONTROL_DOWN    0x20000000
#define KEY_SHIFT_DOWN      0x10000000
#define KEY_MOD_DOWN (KEY_ALT_DOWN|KEY_CONTROL_DOWN)
#define KEY_ALPHA_LOCK_ON   0x08000000
#define KEY_NUM_LOCK_ON     0x04000000
#define KEY_MOD(key)        ( ( (key) & 0x70000000 ) >> 28 )
#define KEY_REAL_CODE(key)  ( ( (key) & 0x00FF0000 ) >> 16 )
#define KEY_CODE(key)       ( (key) & 0xFF )
#define IsKeyExtended(key)  ( ( (key) & 0x00000100 ) >> 8 )
#if defined( _WIN32 ) || defined( WIN32 ) || defined( __CYGWIN__ ) || defined( USE_WIN32_KEY_DEFINES )
// mirrored KEY_ definitions from allegro.H library....
//#include <windows.h>
#define BIT_7           0x80
#define KEY_TAB          9
#define KEY_CENTER       12
#define KEY_PAD5         12
#define KEY_ENTER        13
#define KEY_LSHIFT       16
#define KEY_SHIFT        16
#define KEY_LEFT_SHIFT   0x10
 // maybe?
#define KEY_RIGHT_SHIFT  0x10
#define KEY_SHIFT_LEFT KEY_LEFT_SHIFT
#define KEY_SHIFT_RIGHT KEY_RIGHT_SHIFT
#define KEY_CTRL         17
#define KEY_CONTROL      17
#define KEY_LEFT_CONTROL  17
#define KEY_RIGHT_CONTROL 17
 // can't get usually under windows?(keyhook!)
#define KEY_ALT          18
#define KEY_LEFT_ALT      18
#define KEY_RIGHT_ALT     18
#define KEY_CAPS_LOCK    20
#define KEY_ESC          27
#define KEY_ESCAPE       27
#define KEY_PGUP         33
#define KEY_PAGE_UP     KEY_PGUP
#define KEY_PGDN         34
#define KEY_PAGE_DOWN   KEY_PGDN
#define KEY_END          35
#define KEY_HOME         36
#define KEY_LEFT         37
#define KEY_UP           38
#define KEY_RIGHT        39
#define KEY_DOWN         40
#define KEY_GRAY_UP  38
#define KEY_GRAY_LEFT   37
#define KEY_GRAY_RIGHT  39
#define KEY_GRAY_DOWN    40
//#define KEY_GRAY_UP      BIT_7+0x48
#define KEY_GRAY_PGUP   BIT_7+0x49
#define KEY_GRAY_MINUS  BIT_7+0x4A
//#define KEY_GRAY_LEFT BIT_7+0x4B
//#define KEY_GRAY_RIGHT   BIT_7+0x4D
#define KEY_GRAY_PLUS   BIT_7+0x4E
#define KEY_GRAY_END    BIT_7+0x4F
#define KEY_PAD_PLUS   BIT_7+0x4E
//#define KEY_GRAY_DOWN BIT_7+0x50
#define KEY_GRAY_PGDN   BIT_7+0x51
#define KEY_GRAY_INS    BIT_7+0x52
#define KEY_GRAY_DEL    BIT_7+0x53
#define KEY_GRAY_DELETE    BIT_7+0x53
#define KEY_GREY_DELETE    BIT_7+0x53
#define KEY_INSERT       45
#define KEY_DEL          46
#define KEY_DELETE       KEY_DEL
#define KEY_PRINT_SCREEN1  VK_PRINT
#define KEY_PRINT_SCREEN2  VK_SNAPSHOT
 // windows keys keys
#define KEY_WINDOW_2     0x50
 // windows keys keys
#define KEY_WINDOW_1     0x5c
#define KEY_GRAY_STAR     0x6a
#define KEY_PLUS_PAD     0x6b
//#define KEY_GRAY_MINUS    0x6d
#define KEY_GRAY_SLASH    VK_OEM_5
//#define KEY_GRAY_PLUS     107
#define KEY_NUM_LOCK      VK_NUMLOCK
#define KEY_SCROLL_LOCK VK_SCROLL
#define KEY_SLASH        VK_OEM_2
#define KEY_BACKSPACE   '\b'
#define KEY_SPACE        ' '
#define KEY_COMMA      0xBC
 // should be some sort of VK_ definitions....
#define KEY_STOP       0xBE
#define KEY_PERIOD     KEY_STOP
#define KEY_A         'A'
#define KEY_B         'B'
#define KEY_C         'C'
#define KEY_D         'D'
#define KEY_E         'E'
#define KEY_F         'F'
#define KEY_G         'G'
#define KEY_H         'H'
#define KEY_I         'I'
#define KEY_J         'J'
#define KEY_K         'K'
#define KEY_L         'L'
#define KEY_F12  VK_F12
#define KEY_F11  VK_F11
#define KEY_F10  VK_F10
#define KEY_F9  VK_F9
#define KEY_F8  VK_F8
#define KEY_F7  VK_F7
#define KEY_F6  VK_F6
#define KEY_F5  VK_F5
#define KEY_F4  VK_F4
#define KEY_F3  VK_F3
#define KEY_F2  VK_F2
#define KEY_F1  VK_F1
#define KEY_M        77
#define KEY_N         78
#define KEY_O         79
#define KEY_P        80
#define KEY_Q         'Q'
#define KEY_R         'R'
#define KEY_S         'S'
#define KEY_T         'T'
#define KEY_U         'U'
#define KEY_V         'V'
#define KEY_W         'W'
#define KEY_X         'X'
#define KEY_Y         'Y'
#define KEY_Z         'Z'
#define KEY_1         '1'
#define KEY_2         '2'
#define KEY_3         '3'
#define KEY_4         '4'
#define KEY_5         '5'
#define KEY_6         '6'
#define KEY_7         '7'
#define KEY_8         '8'
#define KEY_9         '9'
#define KEY_0         '0'
#define KEY_MINUS    KEY_DASH
#ifndef VK_OEM_1
// native windows OEM definitions
#define VK_OEM_1   186
#define VK_OEM_2   191
#define VK_OEM_4   219
#define VK_OEM_5   220
#define VK_OEM_6   221
#define VK_OEM_7   222
#define VK_OEM_MINUS  189
#define VK_OEM_PLUS    187
#endif
#define KEY_SEMICOLON     VK_OEM_1
#define KEY_QUOTE         VK_OEM_7
#define KEY_LEFT_BRACKET  VK_OEM_4
#define KEY_RIGHT_BRACKET VK_OEM_6
#define KEY_BACKSLASH     VK_OEM_5
//'-'
#define KEY_DASH     VK_OEM_MINUS
#define KEY_EQUAL    VK_OEM_PLUS
#define KEY_EQUALS   KEY_EQUAL
#define KEY_ACCENT 192
#define KEY_GRAVE  KEY_ACCENT
#define KEY_APOSTROPHE  KEY_ACCENT
#define KEY_F1  VK_F1
#define KEY_F2  VK_F2
#define KEY_F3  VK_F3
#define KEY_F4  VK_F4
#define KEY_F5  VK_F5
#define KEY_F6  VK_F6
#define KEY_F7  VK_F7
#define KEY_F8  VK_F8
#define KEY_F9  VK_F9
#define KEY_F10  VK_F10
#define KEY_F1  VK_F1
#define VK_NUMPAD0        0x60
#define VK_NUMPAD1        0x61
#define VK_NUMPAD2        0x62
#define VK_NUMPAD3        0x63
#define VK_NUMPAD4        0x64
#define VK_NUMPAD5        0x65
#define VK_NUMPAD6        0x66
#define VK_NUMPAD7        0x67
#define VK_NUMPAD8        0x68
#define VK_NUMPAD9        0x69
#define VK_MULTIPLY       0x6A
#define VK_ADD            0x6B
#define VK_SEPARATOR      0x6C
#define VK_SUBTRACT       0x6D
#define VK_DECIMAL        0x6E
#define VK_DIVIDE         0x6F
#define KEY_PAD_MULT VK_MULTIPLY
#define KEY_PAD_DOT VK_DECIMAL
#define KEY_PAD_DIV VK_DIVIDE
#define KEY_PAD_0 VK_NUMPAD0
#define KEY_GREY_INSERT VK_NUMPAD0
#define KEY_PAD_1 VK_NUMPAD1
#define KEY_PAD_2 VK_NUMPAD2
#define KEY_PAD_3 VK_NUMPAD3
#define KEY_PAD_4 VK_NUMPAD4
#define KEY_PAD_5 VK_NUMPAD5
#define KEY_PAD_6 VK_NUMPAD6
#define KEY_PAD_7 VK_NUMPAD7
#define KEY_PAD_8 VK_NUMPAD8
#define KEY_PAD_9 VK_NUMPAD9
#define KEY_PAD_ENTER VK_RETURN
#define KEY_PAD_DELETE VK_SEPARATOR
#define KEY_PAD_MINUS VK_SUBTRACT
#endif
// if any key...
#if !defined( KEY_1 )
#if defined( __ANDROID__ )
#include <android/keycodes.h>
#define KEY_SHIFT        AKEYCODE_SHIFT_LEFT
#define KEY_LEFT_SHIFT   AKEYCODE_SHIFT_LEFT
 // maybe?
#define KEY_RIGHT_SHIFT  AKEYCODE_SHIFT_RIGHT
#ifndef AKEYCODE_CTRL_LEFT
#define AKEYCODE_CTRL_LEFT 113
#endif
#ifndef AKEYCODE_CTRL_RIGHT
#define AKEYCODE_CTRL_RIGHT 114
#endif
#define KEY_CTRL          AKEYCODE_CTRL_LEFT
#define KEY_CONTROL       AKEYCODE_CTRL_LEFT
#define KEY_LEFT_CONTROL  AKEYCODE_CTRL_LEFT
#define KEY_RIGHT_CONTROL AKEYCODE_CTRL_RIGHT
 // can't get usually under windows?(keyhook!)
#define KEY_ALT           AKEYCODE_ALT_LEFT
#define KEY_LEFT_ALT      AKEYCODE_ALT_LEFT
#define KEY_RIGHT_ALT     AKEYCODE_ALT_RIGHT
#ifndef AKEYCODE_CAPS_LOCK
#define AKEYCODE_CAPS_LOCK 115
#endif
#define KEY_CAPS_LOCK     AKEYCODE_CAPS_LOCK
#define KEY_NUM_LOCK      0
#ifndef AKEYCODE_SCROLL_LOCK
#define AKEYCODE_SCROLL_LOCK 116
#endif
 // unsure about this
#define KEY_SCROLL_LOCK   AKEYCODE_SCROLL_LOCK
#ifndef AKEYCODE_ESCAPE
#define AKEYCODE_ESCAPE 111
#endif
#define KEY_ESC           AKEYCODE_ESCAPE
#define KEY_ESCAPE        AKEYCODE_ESCAPE
#ifndef AKEYCODE_MOVE_HOME
#define AKEYCODE_MOVE_HOME 122
#endif
#ifndef AKEYCODE_MOVE_END
#define AKEYCODE_MOVE_END 123
#endif
#define KEY_HOME          AKEYCODE_MOVE_HOME
#define KEY_PAD_HOME      AKEYCODE_MOVE_HOME
#define KEY_PAD_7         0
#define KEY_GREY_HOME     0
#define KEY_UP            AKEYCODE_DPAD_UP
#define KEY_PAD_8         0
#define KEY_PAD_UP        0
#define KEY_GREY_UP       0
#define KEY_PGUP          0
#define KEY_PAD_9         0
#define KEY_PAD_PGUP      0
#define KEY_GREY_PGUP     0
#define KEY_LEFT          AKEYCODE_DPAD_LEFT
#define KEY_PAD_4         0
#define KEY_PAD_LEFT      0
#define KEY_GREY_LEFT     0
#define KEY_CENTER        AKEYCODE_DPAD_CENTER
#define KEY_PAD_5         0
#define KEY_PAD_CENTER    0
#define KEY_GREY_CENTER   0
#define KEY_RIGHT         AKEYCODE_DPAD_RIGHT
#define KEY_PAD_6         0
#define KEY_PAD_RIGHT     0
#define KEY_GREY_RIGHT    0
#define KEY_END           AKEYCODE_MOVE_END
#define KEY_PAD_1         0
#define KEY_PAD_END       0
#define KEY_GREY_END      0
#define KEY_DOWN          AKEYCODE_DPAD_DOWN
#define KEY_PAD_2         0
#define KEY_PAD_DOWN      0
#define KEY_GREY_DOWN     0
#define KEY_PGDN          0
#define KEY_PAD_3         0
#define KEY_PAD_PGDN      0
#define KEY_GREY_PGDN     0
#define KEY_INSERT        0
#define KEY_PAD_0         0
#define KEY_PAD_INSERT    0
#define KEY_GREY_INSERT   0
#define KEY_DELETE        0
#define KEY_PAD_DOT       0
#define KEY_PAD_DELETE    0
#define KEY_GREY_DELETE   0
#define KEY_PLUS          0
#define KEY_PAD_PLUS      0
#define KEY_GREY_PLUS     0
#define KEY_MINUS         0
#define KEY_PAD_MINUS     0
#define KEY_GREY_MINUS    0
#define KEY_MULT          0
#define KEY_PAD_MULT      0
#define KEY_GREY_MULT     0
#define KEY_DIV           0
#define KEY_PAD_DIV       0
#define KEY_GREY_DIV      0
#define KEY_ENTER         AKEYCODE_ENTER
#define KEY_PAD_ENTER     AKEYCODE_ENTER
#define KEY_NORMAL_ENTER  AKEYCODE_ENTER
 // windows keys keys
#define KEY_WINDOW_1      0
 // windows keys keys
#define KEY_WINDOW_2      0
#define KEY_TAB           AKEYCODE_TAB
#define KEY_SLASH         AKEYCODE_SLASH
#define KEY_BACKSPACE     AKEYCODE_DEL
#define KEY_SPACE         AKEYCODE_SPACE
#define KEY_COMMA         AKEYCODE_COMMA
 // should be some sort of VK_ definitions....
#define KEY_STOP          AKEYCODE_PERIOD
#define KEY_PERIOD        AKEYCODE_PERIOD
#define KEY_SEMICOLON     AKEYCODE_SEMICOLON
#define KEY_QUOTE         AKEYCODE_APOSTROPHE
#define KEY_LEFT_BRACKET  AKEYCODE_LEFT_BRACKET
#define KEY_RIGHT_BRACKET AKEYCODE_RIGHT_BRACKET
#define KEY_BACKSLASH     AKEYCODE_BACKSLASH
#define KEY_DASH          AKEYCODE_MINUS
#define KEY_EQUAL         AKEYCODE_EQUALS
#define KEY_ACCENT        AKEYCODE_GRAVE
#define KEY_1         AKEYCODE_1
#define KEY_2         AKEYCODE_2
#define KEY_3         AKEYCODE_3
#define KEY_4         AKEYCODE_4
#define KEY_5         AKEYCODE_5
#define KEY_6         AKEYCODE_6
#define KEY_7         AKEYCODE_7
#define KEY_8         AKEYCODE_8
#define KEY_9         AKEYCODE_9
#define KEY_0         AKEYCODE_0
#define KEY_F1        0
#define KEY_F2        0
#define KEY_F3        0
#define KEY_F4        0
#define KEY_F5        0
#define KEY_F6        0
#define KEY_F7        0
#define KEY_F8        0
#define KEY_F9        0
#define KEY_F10       0
#define KEY_F11       0
#define KEY_F12       0
#define KEY_A   AKEYCODE_A
#define KEY_B   AKEYCODE_B
#define KEY_C   AKEYCODE_C
#define KEY_D   AKEYCODE_D
#define KEY_E   AKEYCODE_E
#define KEY_F   AKEYCODE_F
#define KEY_G   AKEYCODE_G
#define KEY_H   AKEYCODE_H
#define KEY_I   AKEYCODE_I
#define KEY_J   AKEYCODE_J
#define KEY_K   AKEYCODE_K
#define KEY_L   AKEYCODE_L
#define KEY_M   AKEYCODE_M
#define KEY_N   AKEYCODE_N
#define KEY_O   AKEYCODE_O
#define KEY_P   AKEYCODE_P
#define KEY_Q   AKEYCODE_Q
#define KEY_R   AKEYCODE_R
#define KEY_S   AKEYCODE_S
#define KEY_T   AKEYCODE_T
#define KEY_U   AKEYCODE_U
#define KEY_V   AKEYCODE_V
#define KEY_W   AKEYCODE_W
#define KEY_X   AKEYCODE_X
#define KEY_Y   AKEYCODE_Y
#define KEY_Z   AKEYCODE_Z
#elif defined( __LINUX__ )
	  //#define USE_SDL_KEYSYM
// ug - KEYSYMS are too wide...
// so - we fall back to x scancode tables - and translate sym to these
// since the scancodes which come from X are not the same as from console Raw
// but - perhaps we should re-translate these to REAL scancodes... but in either
// case - these fall to under 256 characters, and can therefore be used...
#define USE_X_RAW_SCANCODES
#ifdef USE_X_RAW_SCANCODES
#define KEY_SHIFT        0xFF
#define KEY_LEFT_SHIFT   50
 // maybe?
#define KEY_RIGHT_SHIFT  62
#define KEY_CTRL          0xFE
#define KEY_CONTROL       0xFE
#define KEY_LEFT_CONTROL  37
#define KEY_RIGHT_CONTROL 109
 // can't get usually under windows?(keyhook!)
#define KEY_ALT           0xFD
#define KEY_LEFT_ALT      64
#define KEY_RIGHT_ALT     113
#define KEY_CAPS_LOCK     66
#define KEY_NUM_LOCK      77
 // unsure about this
#define KEY_SCROLL_LOCK   78
#define KEY_ESC           9
#define KEY_ESCAPE        9
#define KEY_HOME          0xFC
#define KEY_PAD_HOME      79
#define KEY_PAD_7         79
#define KEY_GREY_HOME     97
#define KEY_UP            0xFB
#define KEY_PAD_8         80
#define KEY_PAD_UP        80
#define KEY_GREY_UP       98
#define KEY_PGUP          0xFA
#define KEY_PAGE_UP       KEY_PGUP
#define KEY_PAD_9         81
#define KEY_PAD_PGUP      81
#define KEY_GREY_PGUP     99
#define KEY_LEFT          0xF9
#define KEY_PAD_4         83
#define KEY_PAD_LEFT      83
#define KEY_GREY_LEFT     100
#define KEY_CENTER        0xF8
#define KEY_PAD_5         84
#define KEY_PAD_CENTER    84
#define KEY_GREY_CENTER   0
#define KEY_RIGHT         0xF7
#define KEY_PAD_6         85
#define KEY_PAD_RIGHT     85
#define KEY_GREY_RIGHT    102
#define KEY_END           0xF6
#define KEY_PAD_1         87
#define KEY_PAD_END       87
#define KEY_GREY_END      103
#define KEY_DOWN          0xF5
#define KEY_PAD_2         88
#define KEY_PAD_DOWN      88
#define KEY_GREY_DOWN     104
#define KEY_PGDN          0xF4
#define KEY_PAGE_DOWN     KEY_PGDN
#define KEY_PAD_3         89
#define KEY_PAD_PGDN      89
#define KEY_GREY_PGDN     105
#define KEY_INSERT        0xF3
#define KEY_PAD_0         90
#define KEY_PAD_INSERT    90
#define KEY_GREY_INSERT   106
#define KEY_DELETE        0xF2
#define KEY_DEL           KEY_DELETE
#define KEY_PAD_DOT       91
#define KEY_PAD_DELETE    91
#define KEY_GREY_DELETE   107
#define KEY_PLUS          0xF1
#define KEY_PAD_PLUS      86
#define KEY_GREY_PLUS     0
#define KEY_MINUS         0xF0
#define KEY_PAD_MINUS     82
#define KEY_GREY_MINUS    0
#define KEY_MULT          0xEF
#define KEY_PAD_MULT      63
#define KEY_GREY_MULT     0
#define KEY_DIV           0xEE
#define KEY_PAD_DIV       112
#define KEY_GREY_DIV      0
#define KEY_ENTER         0xED
#define KEY_PAD_ENTER     108
#define KEY_NORMAL_ENTER  36
 // windows keys keys
#define KEY_WINDOW_1      115
 // windows keys keys
#define KEY_WINDOW_2      117
#define KEY_TAB           23
#define KEY_SLASH         61
#define KEY_BACKSPACE     22
#define KEY_SPACE         65
#define KEY_COMMA         59
 // should be some sort of VK_ definitions....
#define KEY_STOP          60
#define KEY_PERIOD        KEY_STOP
#define KEY_SEMICOLON     47
#define KEY_QUOTE         48
#define KEY_LEFT_BRACKET  34
#define KEY_RIGHT_BRACKET 35
#define KEY_BACKSLASH     51
#define KEY_DASH          20
#define KEY_EQUAL         21
#define KEY_EQUALS       KEY_EQUAL
#define KEY_ACCENT        49
#define KEY_APOSTROPHE    KEY_QUOTE
#define KEY_GRAVE        KEY_ACCENT
#define KEY_SHIFT_LEFT   KEY_LEFT_SHIFT
#define KEY_SHIFT_RIGHT  KEY_RIGHT_SHIFT
#define KEY_1         10
#define KEY_2         11
#define KEY_3         12
#define KEY_4         13
#define KEY_5         14
#define KEY_6         15
#define KEY_7         16
#define KEY_8         17
#define KEY_9         18
#define KEY_0         19
#define KEY_F1        67
#define KEY_F2        68
#define KEY_F3        69
#define KEY_F4        70
#define KEY_F5        71
#define KEY_F6        72
#define KEY_F7        73
#define KEY_F8        74
#define KEY_F9        75
#define KEY_F10       76
#define KEY_F11       95
#define KEY_F12       96
#define KEY_A         38
#define KEY_B         56
#define KEY_C         54
#define KEY_D         40
#define KEY_E         26
#define KEY_F         41
#define KEY_G         42
#define KEY_H         43
#define KEY_I         31
#define KEY_J         44
#define KEY_K         45
#define KEY_L         46
#define KEY_M         58
#define KEY_N         57
#define KEY_O         32
#define KEY_P         33
#define KEY_Q         24
#define KEY_R         27
#define KEY_S         39
#define KEY_T         28
#define KEY_U         30
#define KEY_V         55
#define KEY_W         25
#define KEY_X         53
#define KEY_Y         29
#define KEY_Z         52
#elif defined( USE_SDL_KEYSYM )
#include <SDL.h>
#define KEY_SHIFT        0xFF
#define KEY_LEFT_SHIFT   SDLK_LSHIFT
#define KEY_RIGHT_SHIFT  SDLK_RSHIFT
#define KEY_CTRL          0xFE
#define KEY_CONTROL       0xFE
#define KEY_LEFT_CONTROL  SDLK_LCTRL
#define KEY_RIGHT_CONTROL SDLK_RCTRL
 // can't get usually under windows?(keyhook!)
#define KEY_ALT           0xFD
#define KEY_LEFT_ALT      SDLK_LALT
#define KEY_RIGHT_ALT     SDLK_RALT
#define KEY_CAPS_LOCK     SDLK_CAPSLOCK
#define KEY_NUM_LOCK      SDLK_NUMLOCK
#define KEY_SCROLL_LOCK   SDLK_SCROLLOCK
#define KEY_ESC           SDLK_ESCAPE
#define KEY_ESCAPE        SDLK_ESCAPE
#define KEY_HOME          0xFC
#define KEY_PAD_HOME      SDLK_KP7
#define KEY_PAD_7         SDLK_KP7
#define KEY_GREY_HOME     SDLK_HOME
#define KEY_UP            0xFB
#define KEY_PAD_8         SDLK_KP8
#define KEY_PAD_UP        SDLK_KP8
#define KEY_GREY_UP       SDLK_UP
#define KEY_PGUP          0xFA
#define KEY_PAD_9         SDLK_KP9
#define KEY_PAD_PGUP      SDLK_KP9
#define KEY_GREY_PGUP     SDLK_PAGEUP
#define KEY_LEFT          0xF9
#define KEY_PAD_4         SDLK_KP4
#define KEY_PAD_LEFT      SDLK_KP4
#define KEY_GREY_LEFT     SDLK_LEFT
#define KEY_CENTER        0xF8
#define KEY_PAD_5         SDLK_KP5
#define KEY_PAD_CENTER    SDLK_KP5
#define KEY_GREY_CENTER   0
#define KEY_RIGHT         0xF7
#define KEY_PAD_6         SDLK_KP6
#define KEY_PAD_RIGHT     SDLK_KP6
#define KEY_GREY_RIGHT    SDLK_RIGHT
#define KEY_END           0xF6
#define KEY_PAD_1         SDLK_KP1
#define KEY_PAD_END       SDLK_KP1
#define KEY_GREY_END      SDLK_END
#define KEY_DOWN          0xF5
#define KEY_PAD_2         SDLK_KP2
#define KEY_PAD_DOWN      SDLK_KP2
#define KEY_GREY_DOWN     SDLK_DOWN
#define KEY_PGDN          0xF4
#define KEY_PAD_3         SDLK_KP3
#define KEY_PAD_PGDN      SDLK_KP3
#define KEY_GREY_PGDN     SDLK_PAGEDN
#define KEY_INSERT        0xF3
#define KEY_PAD_0         SDLK_KP0
#define KEY_PAD_INSERT    SDLK_KP0
#define KEY_GREY_INSERT   SDLK_INSERT
#define KEY_DELETE        0xF2
#define KEY_PAD_DOT       SDLK_KP_PERIOD
#define KEY_PAD_DELETE    SDLK_KP_PERIOD
#define KEY_GREY_DELETE   SDLK_DELETE
#define KEY_PLUS          0xF1
#define KEY_PAD_PLUS      SDLK_KP_PLUS
#define KEY_GREY_PLUS     0
#define KEY_MINUS         0xF0
#define KEY_PAD_MINUS     SDLK_KP_MINUS
#define KEY_GREY_MINUS    0
#define KEY_MULT          0xEF
#define KEY_PAD_MULT      SDLK_KP_MULTIPLY
#define KEY_GREY_MULT     0
#define KEY_DIV           0xEE
#define KEY_PAD_DIV       SDLK_KP_DIVIDE
#define KEY_GREY_DIV      0
#define KEY_ENTER         0xED
#define KEY_PAD_ENTER     SDLK_KP_ENTER
#define KEY_NORMAL_ENTER  SDLK_RETURN
 // windows keys keys
#define KEY_WINDOW_1      115
 // windows keys keys
#define KEY_WINDOW_2      117
#define KEY_TAB           SDLK_TAB
#define KEY_SLASH         SDLK_SLASH
#define KEY_BACKSPACE     SDLK_BACKSPACE
#define KEY_SPACE         SDLK_SPACE
#define KEY_COMMA         SDLK_COMMA
 // should be some sort of VK_ definitions....
#define KEY_STOP          SDLK_PERIOD
#define KEY_PERIOD        KEY_STOP
#define KEY_SEMICOLON     SDLK_SEMICOLON
#define KEY_QUOTE         SDLK_QUOTE
#define KEY_LEFT_BRACKET  SDLK_LEFTBRACKET
#define KEY_RIGHT_BRACKET SDLK_RIGHTBRACKET
#define KEY_BACKSLASH     SDLK_BACKSLASH
#define KEY_DASH          SDLK_MINUS
#define KEY_EQUAL         SDLK_EQUALS
 // grave
#define KEY_ACCENT        SDLK_BACKQUOTE
#define KEY_1         SDLK_1
#define KEY_2         SDLK_2
#define KEY_3         SDLK_3
#define KEY_4         SDLK_4
#define KEY_5         SDLK_5
#define KEY_6         SDLK_6
#define KEY_7         SDLK_7
#define KEY_8         SDLK_8
#define KEY_9         SDLK_9
#define KEY_0         SDLK_0
#define KEY_F1        SDLK_F1
#define KEY_F2        SDLK_F2
#define KEY_F3        SDLK_F3
#define KEY_F4        SDLK_F4
#define KEY_F5        SDLK_F5
#define KEY_F6        SDLK_F6
#define KEY_F7        SDLK_F7
#define KEY_F8        SDLK_F8
#define KEY_F9        SDLK_F9
#define KEY_F10       SDLK_F10
#define KEY_F11       SDLK_F11
#define KEY_F12       SDLK_F12
#define KEY_A         SDLK_A
#define KEY_B         SDLK_B
#define KEY_C         SDLK_C
#define KEY_D         SDLK_D
#define KEY_E         SDLK_E
#define KEY_F         SDLK_F
#define KEY_G         SDLK_G
#define KEY_H         SDLK_H
#define KEY_I         SDLK_I
#define KEY_J         SDLK_J
#define KEY_K         SDLK_K
#define KEY_L         SDLK_L
#define KEY_M         SDLK_M
#define KEY_N         SDLK_N
#define KEY_O         SDLK_O
#define KEY_P         SDLK_P
#define KEY_Q         SDLK_Q
#define KEY_R         SDLK_R
#define KEY_S         SDLK_S
#define KEY_T         SDLK_T
#define KEY_U         SDLK_U
#define KEY_V         SDLK_V
#define KEY_W         SDLK_W
#define KEY_X         SDLK_X
#define KEY_Y         SDLK_Y
#define KEY_Z         SDLK_Z
#elif defined( USE_RAW_SCANCODE )
#error RAW_SCANCODES have not been defined yet.
#define KEY_SHIFT        0xFF
#define KEY_LEFT_SHIFT   50
 // maybe?
#define KEY_RIGHT_SHIFT  62
#define KEY_CTRL          0xFE
#define KEY_CONTROL       0xFE
#define KEY_LEFT_CONTROL  37
#define KEY_RIGHT_CONTROL 109
 // can't get usually under windows?(keyhook!)
#define KEY_ALT           0xFD
#define KEY_LEFT_ALT      64
#define KEY_RIGHT_ALT     113
#define KEY_CAPS_LOCK     66
#define KEY_NUM_LOCK      77
 // unsure about this
#define KEY_SCROLL_LOCK   78
#define KEY_ESC           9
#define KEY_ESCAPE        9
#define KEY_HOME          0xFC
#define KEY_PAD_HOME      79
#define KEY_PAD_7         79
#define KEY_GREY_HOME     97
#define KEY_UP            0xFB
#define KEY_PAD_8         80
#define KEY_PAD_UP        80
#define KEY_GREY_UP       98
#define KEY_PGUP          0xFA
#define KEY_PAD_9         81
#define KEY_PAD_PGUP      81
#define KEY_GREY_PGUP     99
#define KEY_LEFT          0xF9
#define KEY_PAD_4         83
#define KEY_PAD_LEFT      83
#define KEY_GREY_LEFT     100
#define KEY_CENTER        0xF8
#define KEY_PAD_5         84
#define KEY_PAD_CENTER    84
#define KEY_GREY_CENTER   0
#define KEY_RIGHT         0xF7
#define KEY_PAD_6         85
#define KEY_PAD_RIGHT     85
#define KEY_GREY_RIGHT    102
#define KEY_END           0xF6
#define KEY_PAD_1         87
#define KEY_PAD_END       87
#define KEY_GREY_END      103
#define KEY_DOWN          0xF5
#define KEY_PAD_2         88
#define KEY_PAD_DOWN      88
#define KEY_GREY_DOWN     104
#define KEY_PGDN          0xF4
#define KEY_PAD_3         89
#define KEY_PAD_PGDN      89
#define KEY_GREY_PGDN     105
#define KEY_INSERT        0xF3
#define KEY_PAD_0         90
#define KEY_PAD_INSERT    90
#define KEY_GREY_INSERT   106
#define KEY_DELETE        0xF2
#define KEY_PAD_DOT       91
#define KEY_PAD_DELETE    91
#define KEY_GREY_DELETE   107
#define KEY_PLUS          0xF1
#define KEY_PAD_PLUS      86
#define KEY_GREY_PLUS     0
#define KEY_MINUS         0xF0
#define KEY_PAD_MINUS     82
#define KEY_GREY_MINUS    0
#define KEY_MULT          0xEF
#define KEY_PAD_MULT      63
#define KEY_GREY_MULT     0
#define KEY_DIV           0xEE
#define KEY_PAD_DIV       112
#define KEY_GREY_DIV      0
#define KEY_ENTER         0xED
#define KEY_PAD_ENTER     108
#define KEY_NORMAL_ENTER  36
 // windows keys keys
#define KEY_WINDOW_1      115
 // windows keys keys
#define KEY_WINDOW_2      117
#define KEY_TAB           23
#define KEY_SLASH         61
#define KEY_BACKSPACE     22
#define KEY_SPACE         65
#define KEY_COMMA         59
 // should be some sort of VK_ definitions....
#define KEY_STOP          60
#define KEY_PERIOD        KEY_STOP
#define KEY_SEMICOLON     47
#define KEY_QUOTE         48
#define KEY_LEFT_BRACKET  34
#define KEY_RIGHT_BRACKET 35
#define KEY_BACKSLASH     51
#define KEY_DASH          20
#define KEY_EQUAL         21
#define KEY_ACCENT        49
#define KEY_1         10
#define KEY_2         11
#define KEY_3         12
#define KEY_4         13
#define KEY_5         14
#define KEY_6         15
#define KEY_7         16
#define KEY_8         17
#define KEY_9         18
#define KEY_0         19
#define KEY_F1        67
#define KEY_F2        68
#define KEY_F3        69
#define KEY_F4        70
#define KEY_F5        71
#define KEY_F6        72
#define KEY_F7        73
#define KEY_F8        74
#define KEY_F9        75
#define KEY_F10       76
#define KEY_F11       95
#define KEY_F12       96
#define KEY_A         38
#define KEY_B         56
#define KEY_C         54
#define KEY_D         40
#define KEY_E         26
#define KEY_F         41
#define KEY_G         42
#define KEY_H         43
#define KEY_I         31
#define KEY_J         44
#define KEY_K         45
#define KEY_L         46
#define KEY_M         58
#define KEY_N         57
#define KEY_O         32
#define KEY_P         33
#define KEY_Q         24
#define KEY_R         27
#define KEY_S         39
#define KEY_T         28
#define KEY_U         30
#define KEY_V         55
#define KEY_W         25
#define KEY_X         53
#define KEY_Y         29
#define KEY_Z         52
#endif
#endif
#endif
#elif defined( DEFINE_HARDWARE_SCANCODES )
#ifndef KBD_HPP
#define KBD_HPP
#define KBD_INT            9
#define KBD_EXTENDED_CODE     0xE0
#define LOW_ASCII(asc)     (asc&0x7F)
#define NUM_KEYS        256
#ifdef WIN32
//#define KEY_ESC       27
//#define KEY_LEFT      37
//#define KEY_CENTER    KB_CENTER
//#define KEY_RIGHT     39
//#define KEY_DOWN      40
//#define KEY_GRAY_UP   38
//#define KEY_GRAY_LEFT 37
//#define KEY_GRAY_RIGHT   39
//#define KEY_GRAY_DOWN    40
//#define KEY_LEFT_SHIFT   16
//#define KEY_RIGHT_SHIFT  16
//#define KEY_GRAY_PGUP 33
//#define KEY_GRAY_PGDN 34
//#define KEY_GRAY_INS  45
//#define KEY_GRAY_DEL  46
//#define KEY_P         80
//#define KEY_M         77
#else
#define KEY_ESC       0x01
#define KEY_1         0x02
#define KEY_2         0x03
#define KEY_3         0x04
#define KEY_4         0x05
#define KEY_5         0x06
#define KEY_6         0x07
#define KEY_7         0x08
#define KEY_8         0x09
#define KEY_9         0x0A
#define KEY_0         0x0B
#define KEY_MINUS     0x0C
#define KEY_PLUS         0x0D
#define  KEY_BKSP        0x0E
#define KEY_TAB       0x0F
#define KEY_Q         0x10
#define KEY_W         0x11
#define KEY_E         0x12
#define KEY_R         0x13
#define KEY_T         0x14
#define KEY_Y         0x15
#define KEY_U         0x16
#define KEY_I         0x17
#define  KEY_O        0x18
#define KEY_P         0x19
#define KEY_BRACK_OPEN   0x1A
#define KEY_BRACK_CLOSE  0x1B
#define KEY_ENTER     0x1C
#define KEY_LEFT_CTRL 0x1D
#define KEY_A         0x1E
#define KEY_S         0x1F
#define KEY_D         0x20
#define KEY_F         0x21
#define KEY_X         0x2D
#define KEY_C         0x2E
#define KEY_V         0x2F
#define KEY_B         0x30
#define KEY_N         0x31
#define KEY_M         0x32
#define KEY_GRAY_SLASH   0x35
#define KEY_RIGHT_SHIFT  0x36
#define KEY_GRAY_STAR 0x37
#define KEY_LEFT_ALT     0x38
#define KEY_SPACE     0x39
#define KEY_CAPS         0x3A
#define KEY_F1        0x3B
#define KEY_F2        0x3C
#define KEY_F3        0x3D
#define KEY_F4        0x3E
#define KEY_F5        0x3F
#define KEY_F6        0x40
#define KEY_F7        0x41
#define KEY_F8        0x42
#define KEY_F9        0x43
#define KEY_F10       0x44
#define KEY_UP        0x48
#define KEY_LEFT      0x4B
#define KEY_CENTER    0x4C
#define KEY_RIGHT     0x4D
#define KEY_DOWN      0x50
#define KEY_DEL       0x53
#define KEY_F11       0x57
#define KEY_F12       0x58
#define KEY_RIGHT_CTRL   BIT_7+0x1D
#define KEY_RIGHT_ALT BIT_7+0x38
#define KEY_GRAY_UP      BIT_7+0x48
#define KEY_GRAY_PGUP BIT_7+0x49
#define KEY_GRAY_MINUS   BIT_7+0x4A
#define KEY_GRAY_LEFT BIT_7+0x4B
#define KEY_GRAY_RIGHT   BIT_7+0x4D
#define KEY_GRAY_PLUS BIT_7+0x4E
#define KEY_GRAY_END     BIT_7+0x4F
#define KEY_GRAY_DOWN BIT_7+0x50
#define KEY_GRAY_PGDN BIT_7+0x51
#define KEY_GRAY_INS     BIT_7+0x52
#define KEY_GRAY_DEL     BIT_7+0x53
#endif
#endif
#endif
// $Log: keybrd.h,v $
// Revision 1.16  2004/08/11 11:41:06  d3x0r
// Begin seperation of key and render
//
// Revision 1.15  2004/06/01 21:53:43  d3x0r
// Fix PUBLIC dfeinitions from Windoze-centric to system nonspecified
//
// Revision 1.14  2004/04/27 04:58:16  d3x0r
// Forgot to macro a function..
//
// Revision 1.13  2004/04/27 03:06:16  d3x0r
// Define F1-F10
//
// Revision 1.12  2004/03/05 23:33:21  d3x0r
// Missing keydefs - may be wrong.
//
// Revision 1.11  2003/03/25 08:38:11  panther
// Add logging
//
#ifndef __NO_INTERFACES__
   // for interface, can omit if no interfaces
#endif
#ifndef __NO_MSGSVR__
  // for interface across the message service
#ifndef MESSAGE_SERVICE_PROTOCOL
#define MESSAGE_SERVICE_PROTOCOL
#ifdef __cplusplus
using namespace sack;
#endif
#ifdef __cplusplus
#define _MSG_NAMESPACE  namespace msg {
#define _PROTOCOL_NAMESPACE namespace protocol {
#define MSGPROTOCOL_NAMESPACE namespace sack { _MSG_NAMESPACE _PROTOCOL_NAMESPACE
#define MSGPROTOCOL_NAMESPACE_END }} }
#else
#define _MSG_NAMESPACE
#define _PROTOCOL_NAMESPACE
#define MSGPROTOCOL_NAMESPACE
#define MSGPROTOCOL_NAMESPACE_END
#endif
SACK_NAMESPACE
	/* This namespace contains an implmentation of inter process
	   communications using a set of message queues which result
	   from 'msgget' 'msgsnd' and 'msgrcv'. This are services
	   available under a linux kernel. Reimplemented a version to
	   service for windows. This is really a client/service
	   registration and message routing system, it is not the
	   message queue itself. See <link sack::containers::message, message>
	   for the queue implementation (again, under linux, does not
	   use this custom queue).
	   See Also
	   RegisterService
	   LoadService                                                         */
	_MSG_NAMESPACE
/* Defines structures and methods for receiving and sending
	   messages. Also defines some utility macros for referencing
		message ID from a user interface structure.                */
	_PROTOCOL_NAMESPACE
#define MSGQ_ID_BASE WIDE("Srvr")
// this is a fun thing, in order to use it,
// undefine MyInterface, and define your own to your
// library's interface structure name (the tag of the structure)
#define MSG_ID(method)  BASE_MESSAGE_ID,( ( offsetof( struct MyInterface, _##method ) / sizeof( void(*)(void) ) ) +  MSG_EventUser )
#define MSG_OFFSET(method)  ( ( offsetof( struct MyInterface, _##method ) / sizeof( void(*)(void) ) ) + MSG_EventUser )
#define INTERFACE_METHOD(type,name) type (CPROC*_##name)
// this is the techincal type of SYSV IPC MSGQueues
#define MSGIDTYPE long
#ifdef __64__
#  ifdef __LINUX__
#    define _MsgID_f  _64fs
#  else
#    define _MsgID_f  _32fs
#  endif
#else
#  define _MsgID_f  _32fs
#endif
// this will determine the length of parameter list
// based on the first and last parameters.
#define ParamLength( first, last ) ( ((uintptr_t)((&(last))+1)) - ((uintptr_t)(&(first))) )
#ifdef _MSC_VER
#pragma pack (push, 1)
#endif
typedef PREFIX_PACKED struct buffer_len_tag {
	CPOINTER buffer;
	size_t len;
} PACKED BUFFER_LENGTH_PAIR;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
// Dispach Pending - particularly display mouse event messages
//                   needed to be accumulated before being dispatched
//                   this event is generated when no more messages
//                   have been received.
#define MSG_EventDispatchPending   0
#define MSG_DispatchPending   MSG_EventDispatchPending
// these are event message definitions.
// server events come through their function table, clients
// register an event handler... these are low numbered since
// they are guaranteed from the client/server respectively.
// Mate ended - for the client, this means that the server
//              has become defunct.  For the server, this
//              means that a client is no longer present.
//              also issued when a client volentarily leaves
//              which in effect is the same as being discovered gone.
//    param[0] = Process ID of client disconnecting
//  result_length = INVALID_INDEX - NO RESULT DATA, PLEASE!
#define MSG_MateEnded         MSG_ServiceUnload
#define MSG_ServiceUnload     0
//#define MSG_ServiceClose    MSG_ServiceUnload
//#define MSG_ServiceUnload        MSG_MateEnded
// finally - needed to define a way for the service
// to actually know when a client connects... so that
// it may validate commands as being froma good source.
// also, a multiple service server may want this to know which
// service is being loaded.
//     params + 0 = text string of the service to load
//  on return result[1] is the number of messages this routine
//  expects.
//     result[0] is the number of events this service may generate
#define MSG_MateStarted      1
#define MSG_ServiceLoad      MSG_MateStarted
// Service is about to be unloaded - here's a final chance to
// cleanup before being yanked from existance.
// Last reference to the service is now gone, going to do the unload.
#define MSG_UndefinedMessage2      2
// no defined mesasage fo this
#define MSG_UndefinedMessage3       3
// Other messages may be filled in here...
// skip a couple messages so we don't have to recompile everything
// very soon...
#define MSG_EventUser       MSG_UserServiceMessages
#define MSG_UserServiceMessages 16
// skip a couple messages so we don't have to recompile everything
// very soon...
#define MSG_EventInternal       MSG_InternalServiceMessages
#define MSG_InternalServiceMessages 4
enum server_event_messages {
	// these messages are sent to client's event channel
	// within the space of core service requests (0-256?)
	// it's on top of client event user - cause the library
	// may also receive client_disconnect/connect messages
   //
	MSG_SERVICE_DATA = MSG_EventInternal
 // end of list - zero or more MSG_SERVICE_DATA mesasges will preceed this.
      , MSG_SERVICE_NOMORE
	, MSG_SERVICE_MAX_ID
};
enum server_failure_messages {
	CLIENT_UNKNOWN
									  , MESSAGE_UNKNOWN
 // sending server(sourced) messages to server
									  , MESSAGE_INVALID
 // could not find a service for the message.
									  , SERVICE_UNKNOWN
									  , UNABLE_TO_LOAD
};
enum service_messages {
 // no message ID 0 ever.
	INVALID_MESSAGE  = 0
 // server responce to clients - failure
							 , SERVER_FAILURE   = 0x80000000
							 // failure may result for the above reasons.
 // server responce to clients - success
							 , SERVER_SUCCESS   = 0x40000000
 // server needs more time to complete...
							 , SERVER_NEED_TIME = 0x20000000
 // server had no method to process the message
							 , SERVER_UNHANDLED = 0x10000000
 // client requests a service (load by name)
							 , CLIENT_LOAD_SERVICE = 1
 // client no longer needs a service (unload msgbase)
							 , CLIENT_UNLOAD_SERVICE
       // new client wants to connect
							 , CLIENT_CONNECT
    // client disconnects (no responce)
							 , CLIENT_DISCONNECT
             // server/client message to other requesting status
							 , RU_ALIVE
             // server/client message to other responding status
							 , IM_ALIVE
 // client register service (name, serivces, callback table.)
							 , CLIENT_REGISTER_SERVICE
 // client requests a list of services (optional param partial filter?)
                      , CLIENT_LIST_SERVICES
   // Service needs more time, and passes back a millisecond delay-reset
                      , IM_TARDY
};
#define LOWEST_BASE_MESSAGE 0x100
typedef struct ServiceRoute_tag SERVICE_ROUTE;
typedef struct ServiceRoute_tag *PSERVICE_ROUTE;
typedef struct ServiceEndPoint_tag SERVICE_ENDPOINT, *PSERVICE_ENDPOINT;
// this is part of the message structure
//
// this structure is avaialble at ((PSERVICE_ROUTE)(((uint32_t*)params)-1)[-1])
// (to explain that, the first uint32_t back is the MsgID... to get JUST the route tag
//  have to go back one Dword then back a service_route struct...
#ifdef _MSC_VER
#pragma pack (push, 1)
#endif
PREFIX_PACKED struct ServiceEndPoint_tag
{
   // remote process ID
	MSGIDTYPE process_id;
   // service (either served or connected as client) remote id
	MSGIDTYPE service_id;
}PACKED;
PREFIX_PACKED struct ServiceRoute_tag
{
   SERVICE_ENDPOINT dest;
	//MSGIDTYPE process_id;   // remote process ID
   //MSGIDTYPE service_id;   // service (either served or connected as client) remote id
   SERVICE_ENDPOINT source;
   //uint32_t source_process_id; // need this defined here anyway; so this can be used in receivers
	//uint32_t source_service_id;  // the service this is connected to, or is a connection for local ID
}PACKED;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
#define GetServiceRoute(data)   ((PSERVICE_ROUTE)(((uint32_t*)data)-1)-1)
// server functions will return TRUE if no failure
// server functions will return FALSE on failure
// FAILURE or SUCCESS will be returned to the client,
//   along with any result data set.
// native mode (unspecified... one would assume
// stack passing, but the world is bizarre and these are
// probably passed by registers.
typedef int (CPROC *server_message_handler)( PSERVICE_ROUTE SourceRouteID, uint32_t MsgID
														 , uint32_t *params, size_t param_length
														 , uint32_t *result, size_t *result_length );
typedef int (CPROC *server_message_handler_ex)( uintptr_t psv
															 , PSERVICE_ROUTE SourceRouteID, uint32_t MsgID
															 , uint32_t *params, size_t param_length
															 , uint32_t *result, size_t *result_length );
// params[-1] == Source Process ID
// params[-2] == Source Route ID
typedef int (CPROC *server_function)( PSERVICE_ROUTE route, uint32_t *params, size_t param_length
										 , uint32_t *result, size_t *result_length );
typedef struct server_function_entry_tag{
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
	CTEXTSTR name;
#endif
	server_function function;
} SERVER_FUNCTION;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
#define ServerFunctionEntry(name) { _WIDE(#name), name }
#else
#define ServerFunctionEntry(name) { name }
#endif
typedef SERVER_FUNCTION *server_function_table;
// MsgID will be < MSG_EventUser if it's a system message...
// MsgID will be service msgBase + Remote ID...
//    so the remote needs to specify a unique base... so ...
//    entries must still be used...
typedef int (CPROC*EventHandlerFunction)( MSGIDTYPE MsgID, uint32_t*params, size_t paramlen);
typedef int (CPROC*EventHandlerFunctionEx)( PSERVICE_ROUTE SourceID, MSGIDTYPE MsgID, uint32_t*params, size_t paramlen);
typedef int (CPROC*EventHandlerFunctionExx)( uintptr_t psv, PSERVICE_ROUTE SourceID, MSGIDTYPE MsgID
														 , uint32_t*params, size_t paramlen);
// result of EventHandlerFunction shall be one fo the following values...
//   EVENT_HANDLED
// 0 - no futher action required
//   EVENT_WAIT_DISPATCH
// 1 - when no further events are available, please send event_dispatched.
//     this Event was handled by an internal queuing for later processing.
enum EventResult {
	EVENT_HANDLED = 0,
	EVENT_WAIT_DISPATCH = 1
};
//------------------- Begin Server Message Structs ----------------
#ifdef _MSC_VER
#pragma pack (push, 1)
#endif
typedef struct MsgSvr_RegisterRequest_msg MsgSvr_RegisterRequest;
PREFIX_PACKED struct MsgSvr_RegisterRequest_msg
{
	MSGIDTYPE RouteID;
  // service_id...
   MSGIDTYPE ClientID;
}PACKED;
typedef struct MsgSrv_ReplyServiceLoad_msg MsgSrv_ReplyServiceLoad;
PREFIX_PACKED struct MsgSrv_ReplyServiceLoad_msg
{
	MSGIDTYPE ServiceID;
 // if this is a local service, it's dispatched this way?
	THREAD_ID thread;
}PACKED;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
MSGPROTOCOL_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::msg::protocol;
#endif
#endif
#endif
#ifndef SECOND_RENDER_LEVEL
#define SECOND_RENDER_LEVEL
#define PASTE(sym,name) name
#else
#define PASTE2(sym,name) sym##name
#define PASTE(sym,name) PASTE2(sym,name)
#endif
#        ifdef RENDER_LIBRARY_SOURCE
#           define RENDER_PROC(type,name) EXPORT_METHOD type CPROC PASTE(SECOND_RENDER_LEVEL,name)
#        else
#           define RENDER_PROC(type,name) IMPORT_METHOD type CPROC PASTE(SECOND_RENDER_LEVEL,name)
#        endif
SACK_NAMESPACE
/* <copy render.h>
   \ \             */
BASE_IMAGE_NAMESPACE
/* PRENDERER is the primary object this namespace deals with.
   See Also
   <link render.h>                                            */
_RENDER_NAMESPACE
/* Application layer abstract structure to handle displays. This
 is the type returned by OpenDisplay.                          */
typedef struct HVIDEO_tag *PRENDERER;
typedef struct key_function  KEY_FUNCTION;
typedef struct key_function *PKEY_FUNCTION;
// disable this functionality, it was never fully implemented, and is a lot to document.
#if ACTIVE_MESSAGE_IMPLEMENTED
// Message IDs 0-99 are reserved for
// very core level messages.
// Message IDs 100-999 are for general purpose window input/output
// Message ID 1000+ Usable by applications to transport messages via
//                  the image's default message loop.
enum active_msg_id {
    // Message ID 0 - contains a active image to respond to
   ACTIVE_MSG_PING
    // Message ID 0 - contains a active image to respond to
   , ACTIVE_MSG_PONG
   , ACTIVE_MSG_MOUSE = 100
   , ACTIVE_MSG_GAIN_FOCUS
   , ACTIVE_MSG_LOSE_FOCUS
   , ACTIVE_MSG_DRAG
   , ACTIVE_MSG_KEY
   , ACTIVE_MSG_DRAW
   , ACTIVE_MSG_CREATE
   , ACTIVE_MSG_DESTROY
   , ACTIVE_MSG_USER = 1000
};
typedef struct {
   enum active_msg_id ID;
 // the size of the cargo potion of the message. (mostly data.raw)
   uint32_t  size;
   union {
  //--------------------
      struct {
         PRENDERER respondto;
      } ping;
  //--------------------
      struct {
         int x, y, b;
      } mouse;
  //--------------------
      struct {
         PRENDERER lose;
      } gain_focus;
  //--------------------
      struct {
         PRENDERER gain;
      } lose_focus;
  //--------------------
      struct {
         uint8_t no_informaiton;
      } draw;
  //--------------------
      struct {
         uint8_t no_informaiton;
      } close;
  //--------------------
      struct {
         uint8_t no_informaiton;
      } create;
  //--------------------
      struct {
         uint8_t no_informaiton;
      } destroy;
  //--------------------
      struct {
         uint32_t key;
      } key;
  //--------------------
      uint8_t raw[1];
   } data;
} ACTIVEMESSAGE, *PACTIVEMESSAGE;
#endif
// Event Message ID's CANNOT be 0
// Message Event ID (base+0) is when the
// server teriminates, and ALL client resources
// are lost.
// Message Event ID (base+1) is when the
// final message has been received, and any
// pending events collected should be dispatched.
#ifndef __NO_MSGSVR__
enum {
   /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_CloseMethod = MSG_EventUser,
  /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_RedrawMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_MouseMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_LoseFocusMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_KeyMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_GeneralMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_RedrawFractureMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_ThreadEventPost
};
#endif
#ifdef __WATCOMC__
#if ( __WATCOMC__ < 1291 )
#define NO_TOUCH
#endif
#endif
#ifndef WIN32
#define NO_TOUCH
#endif
#if defined( __LINUX__ )
#define NO_TOUCH
#endif
#if defined( __ANDROID__ )
// definately IS touch
#undef NO_TOUCH
#define MINGW_SUX
#endif
// static void OnBeginShutdown( "Unique Name" )( void ) { /* run shutdown code */ }
#define OnBeginShutdown(name)	 __DefineRegistryMethod(WIDE("SACK"),BeginShutdown,WIDE("System"),WIDE("Begin Shutdown"),name WIDE("_begin_shutdown"),void,(void),__LINE__)
/* function signature for the close callback  which can be specified to handle events to close the display.  see SetCloseHandler. */
typedef void (CPROC*CloseCallback)( uintptr_t psvUser );
/* function signature to define hide/restore callback, it just gets the user data of the callback... */
typedef void (CPROC*HideAndRestoreCallback)( uintptr_t psvUser );
/* function signature for the redraw callback  which can be specified to handle events to redraw the display.  see SetRedrawHandler. */
typedef void (CPROC*RedrawCallback)( uintptr_t psvUser, PRENDERER self );
/* function signature for the mouse callback  which can be specified to handle events from mouse motion on the display.  see SetMouseHandler.
  would be 'wise' to retun 0 if ignored, 1 if observed (perhaps not used), but NOT ignored.*/
typedef uintptr_t  (CPROC*MouseCallback)( uintptr_t psvUser, int32_t x, int32_t y, uint32_t b );
typedef struct input_point
{
   //
	RCOORD x, y;
	struct {
  // set on first down, clear on subsequent events
		BIT_FIELD new_event : 1;
 // set on first up, clear on first down,
		BIT_FIELD end_event : 1;
	} flags;
} *PINPUT_POINT;
#ifndef NO_TOUCH
#if defined( MINGW_SUX )
/*
 * Touch input mask values (TOUCHINPUT.dwMask)
 */
  // the dwTime field contains a system generated value
#define TOUCHINPUTMASKF_TIMEFROMSYSTEM  0x0001
  // the dwExtraInfo field is valid
#define TOUCHINPUTMASKF_EXTRAINFO       0x0002
  // the cxContact and cyContact fields are valid
#define TOUCHINPUTMASKF_CONTACTAREA     0x0004
#ifndef __ANDROID__
typedef HANDLE HTOUCHINPUT;
#endif
#define WM_TOUCH 0x0240
#define TWF_FINETOUCH 0x00000001
#define TWF_WANTPALM 0x00000002
#endif
 // added to flags as touches are used.  Controls may use some of the touches but not all.
#define TOUCHEVENTF_USED 0x8000
/* function signature for the touch callback  which can be specified to handle events from touching the display.  see SetMouseHandler.
  would be 'wise' to retun 0 if ignored, 1 if observed (perhaps not used), but NOT ignored.  Return 1 if some of the touches are used.
  This will trigger a check to see if there are unused touches to continue sending... oh but on renderer there's only one callback, more
  important as a note of the control touch event handerer.
  */
typedef int  (CPROC*TouchCallback)( uintptr_t psvUser, PINPUT_POINT pTouches, int nTouches );
#endif
/* function signature for the close callback  which can be specified to handle events to redraw the display.  see SetLoseFocusHandler. */
typedef void (CPROC*LoseFocusCallback)( uintptr_t dwUser, PRENDERER pGain );
// without a keyproc, you will still get key notification in the mousecallback
// if KeyProc returns 0 or is NULL, then bound keys are checked... otherwise
// priority is given to controls with focus that handle keys.
typedef int (CPROC*KeyProc)( uintptr_t dwUser, uint32_t keycode );
// without any other proc, you will get a general callback message.
#if ACTIVE_MESSAGE_IMPLEMENTED
typedef void (CPROC*GeneralCallback)( uintptr_t psvUser
                                     , PRENDERER image
												, PACTIVEMESSAGE msg );
#endif
typedef void (CPROC*RenderReadCallback)(uintptr_t psvUser, PRENDERER pRenderer, TEXTSTR buffer, INDEX len );
// called before redraw callback to update the background on the scene...
typedef void (CPROC*_3DUpdateCallback)( uintptr_t psvUser );
//----------------------------------------------------------
//   Mouse Button definitions
//----------------------------------------------------------
// the prefix of these may either be interpreted as MAKE - as in
// a make/break state of a switch.  Or may be interpreted as
// MouseKey.... such as KB_ once upon a time stood for KeyBoard,
// and not Keebler as some may have suspected.
enum ButtonFlags {
#ifndef MK_LBUTTON
 // left mouse button  MouseKey_ ?
	MK_LBUTTON = 0x01,
#endif
#ifndef MK_MBUTTON
  // right mouse button MouseKey_ ?
	MK_RBUTTON = 0x02,
#endif
#ifndef MK_RBUTTON
  // middle mouse button MouseKey_ ?
	MK_MBUTTON = 0x10,
#endif
#ifndef MK_CONTROL
  // the control key on the keyboard
  MK_CONTROL = 0x08,
#endif
#ifndef MK_ALT
   // the alt key on the keyboard
  MK_ALT = 0x20,
#endif
#ifndef MK_SHIFT
   // the shift key on the keyboard
  MK_SHIFT = 0x40,
#endif
  // scroll wheel click down
  MK_SCROLL_DOWN  = 0x100,
  // scroll wheel click up
  MK_SCROLL_UP    = 0x200,
  // scroll wheel click left
  MK_SCROLL_LEFT  = 0x400,
  // scroll wheel click right
  MK_SCROLL_RIGHT = 0x800,
#ifndef MK_NO_BUTTON
// used to indicate that there is
// no known button information available.  The mouse
// event which triggered this was beyond the realm of
// this mouse handler, but it is entitled to know that
// it now knows nothing.
  MK_NO_BUTTON = 0xFFFFFFFF,
#endif
// this bit will NEVER NEVER NEVER be set
// for ANY reason whatsoever. ( okay except when it's in MK_NO_BUTTON )
  MK_INVALIDBUTTON = 0x80000000,
// One or more other buttons were pressed.  These
// buttons are available by querying the keyboard state.
 // any other button (keyboard)
  MK_OBUTTON = 0x80,
 // any other button (keyboard) went up
  MK_OBUTTON_UP = 0x1000
};
// mask to test to see if some button (physical mouse, not logical)
// is currently pressed...
#define MK_SOMEBUTTON       (MK_LBUTTON|MK_RBUTTON|MK_MBUTTON)
// test to see if any button is clicked */
#define MAKE_SOMEBUTTONS(b)     ((b)&(MK_SOMEBUTTON))
// test to see if a specific button is clicked
#define BUTTON_STILL_DOWN(b,button)     ((b)&(button))
// test a button variable to see if no buttons are currently pressed
// NOBUTTON, NOBUTTONS may be confusing, consider renaming these....
#define MAKE_NOBUTTONS(b)     ( !((b) & MK_SOMEBUTTON ) )
// break of some button
#define BREAK_NEWBUTTON(b,_b) ((((b)^(_b))&(_b))&MK_SOMEBUTTON)
// break a specific button (the last up of the button)
#define BREAK_A_BUTTON(b,_b,button) ((((b)^(_b))&(_b))&(button))
// make of some button (the first down of a button)
#define MAKE_NEWBUTTON(b,_b) ((((b)^(_b))&(b))&MK_SOMEBUTTON)
// make a specific button (the first down of the button)
#define MAKE_A_BUTTON(b,_b,button) ((((b)^(_b))&(b))&(button))
// test current b vs prior _b to see if the  last button pressed is
// now not pressed...
#define BREAK_LASTBUTTON(b,_b)  ( BREAK_NEWBUTTON(b,_b) && MAKE_NOBUTTONS(b) )
// test current b vs prior _b to see if there is now some button pressed
// when previously there were no buttons pressed...
#define MAKE_FIRSTBUTTON(b,_b) ( MAKE_NEWBUTTON(b,_b) && MAKE_NOBUTTONS(_b) )
// these button states may reflect the current
// control, alt, shift key states.  There may be further
// definitions (meta?) And as of the writing of this comment
// these states may not be counted on, if you care about these
// please do validate that the code gives them to you all the way
// from the initial mouse message through all layers to the final
// application handler.
//----------------------------------------------------------
enum DisplayAttributes {
   /* when used by the Display Lib manager, this describes how to manage the subsurface */
  PANEL_ATTRIBUTE_ALPHA    = 0x10000,
   /* when used by the Display Lib manager, this describes how to manage the subsurface */
  PANEL_ATTRIBUTE_HOLEY    = 0x20000,
// when used by the Display Lib manager, this describes how to manage the subsurface
// focus on this window excludes any of it's parent/sibling panels
// from being able to focus.
  PANEL_ATTRIBUTE_EXCLUSIVE = 0x40000,
// when used by the Display Lib manager, this describes how to manage the subsurface
// child attribute affects the child is contained within this parent
  PANEL_ATTRIBUTE_INTERNAL  = 0x88000,
    // open the window as layered - allowing full transparency.
  DISPLAY_ATTRIBUTE_LAYERED = 0x0100,
    // window will not be in alt-tab list
  DISPLAY_ATTRIBUTE_CHILD = 0x0200,
    // set to WS_EX_TRANSPARENT - all mouse is passed, regardless of alpha/shape
  DISPLAY_ATTRIBUTE_NO_MOUSE = 0x0400,
    // when created, the display does not attempt to set itself into focus, otherwise we try to focus self.
  DISPLAY_ATTRIBUTE_NO_AUTO_FOCUS = 0x0800,
  // when created, set topmost as soon as possible
  DISPLAY_ATTRIBUTE_TOPMOST = 0x1000,
};
 // does not HAVE to be called but may
    RENDER_PROC( int , InitDisplay) (void);
	 // this generates a mouse event though the mouse system directly
    // there is no queuing, and the mouse is completed before returning.
    RENDER_PROC( void, GenerateMouseRaw)( int32_t x, int32_t y, uint32_t b );
	 /* Create mouse events to self?
	    Parameters
	    x :  x of the mouse
	    y :  y of the mouse
	    b :  buttons of the mouse    */
	 RENDER_PROC( void, GenerateMouseDeltaRaw )( int32_t x, int32_t y, uint32_t b );
    /* Sets the title of the application window. Once upon a time,
       applications only were able to make a SINGLE window. Internally,
       all windows are mounted against a hidden application window,
       and this appilcation window gets the title.
       Parameters
       title :  Title for the application                               */
    RENDER_PROC( void , SetApplicationTitle) (const TEXTCHAR *title );
    /* Sets the title of the window (shows up in windows when
       alt-tabbing). Also shows up on the task tray icon (if there
       is one)
       Parameters
       render :  display to set the title of
       title :   new text for the title.                           */
    RENDER_PROC( void , SetRendererTitle) ( PRENDERER render, const TEXTCHAR *title );
    /* Sets the icon to show for the application's window.
       Parameters
       Icon :  this really has to be an HICON I think... it's for
               setting the icon on Windows' windows.              */
    RENDER_PROC( void , SetApplicationIcon)  (Image Icon);
    /* Gets the size of the default desktop screen.
       Parameters
       width :   pointer to a 32 value for the display's width.
       height :  pointer to a 32 value for the display's height.
       Example
       <code lang="c++">
       uint32_t w, h;
       GetDisplaySize( &amp;w, &amp;h );
       </code>
       See Also
       <link sack::image::render::GetDisplaySizeEx@int@int32_t *@int32_t *@uint32_t *@uint32_t *, GetDisplaySizeEx> */
    RENDER_PROC( void , GetDisplaySize)      ( uint32_t *width, uint32_t *height );
	 /* \ \
	    Parameters
	    nDisplay :  display to get the coordinates of. 0 is the
	                default display from GetDesktopWindow(). 1\-n are
	                displays for multiple display systems, 1,2,3,4
	                etc..
	    x :         left screen coordinate of this display
	    y :         top screen coordinate of this display
	    width :     how wide this display is
	    height :    how tall this display is
	    Example
	    <code lang="c#">
	    int32_t x, y;
	    uint32_t w, h;
	    GetDisplaySizeEx( 1, &amp;x, &amp;y, &amp;w, &amp;h );
	    </code>                                                       */
	 RENDER_PROC (void, GetDisplaySizeEx) ( int nDisplay
													  , int32_t *x, int32_t *y
													  , uint32_t *width, uint32_t *height);
    /* Sets the first displayed physical window to a certain size. This
       should actually adjust the screen size. Like GetDisplaySize
       \returns the size of the actual display, this should set the
       size of the actual display.
       Parameters
       width :   new width of the screen
       height :  new height of the screen.                              */
    RENDER_PROC( void , SetDisplaySize)      ( uint32_t width, uint32_t height );
#ifdef WIN32
    /* Enable logging when updates happen to the real display.
       Parameters
       bEnable :  TRUE to enable, FALSE to disable.            */
    RENDER_PROC (void, EnableLoggingOutput)( LOGICAL bEnable );
	 /* A method to promote any arbitrary HWND to a PRENDERER. This
	    can be used to put SACK display surfaces in .NET
	    applications.
	    Parameters
	    hWnd :  HWND to make into a renderer.
	    Returns
	    PRENDERER new renderer that uses HWND to update to.         */
	 RENDER_PROC (PRENDERER, MakeDisplayFrom) (HWND hWnd);
#endif
    /* This opens a display for output. It is opened hidden, so the
       application might draw to its surface before it is shown.
       This is not the most capable creation routine, but it is the
       most commonly aliased.
       Parameters
       attributes :  one or more <link sack::image::render::DisplayAttributes, DisplayAttributes>
                     or'ed togeteher.
       width :       width of the display
       height :      height of the display
       x :           x position of left the display
       y :           y position of the top of the display                                         */
    RENDER_PROC( PRENDERER, OpenDisplaySizedAt)     ( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y );
    /* This opens a display for output. It is opened hidden, so the
       application might draw to its surface before it is shown.
       This is not the most capable creation routine, but it is the
       most commonly aliased.
       Parameters
       attributes :  one or more <link sack::image::render::DisplayAttributes, DisplayAttributes>
                     or'ed togeteher.
       width :       width of the display
       height :      height of the display
       x :           x position of left the display
       y :           y position of the top of the display
       above :       display to put this one above.                                               */
    RENDER_PROC( PRENDERER, OpenDisplayAboveSizedAt)( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y, PRENDERER above );
    /* This opens a display for output. It is opened hidden, so the
       application might draw to its surface before it is shown.
       This is not the most capable creation routine, but it is the
       most commonly aliased.
       Parameters
       attributes :  one or more <link sack::image::render::DisplayAttributes, DisplayAttributes>
                     or'ed togeteher.
       width :       width of the display
       height :      height of the display
       x :           x position of left the display
       y :           y position of the top of the display
       above :       display to put this one above.
       below :       display to put this one under. (for building
                     behind a cover window)                                                       */
    RENDER_PROC( PRENDERER, OpenDisplayAboveUnderSizedAt)( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y, PRENDERER above, PRENDERER under );
	 /* Sets the alpha level of the overall display window.
	    Parameters
	    hVideo :  display to set the overall fade level on
	    level :   the level of fade from 0 (transparent) to 255
	              (opaque)
	    Example
	    <code lang="c++">
	    PRENDERER render = OpenDisplay( 0 );
	    int i;
	    UpdateDisplay( render );
	    </code>
	    <code>
	    // the window will slowly fade out
	    for( i = 255; i \> 0; i-- )
	    </code>
	    <code lang="c++">
	        SetDisplayFade( render, i );
	    CloseDisplay( render );  // Hiding the display works too, if it is to be reused.
	    </code>                                                                          */
	 RENDER_PROC( void, SetDisplayFade )( PRENDERER hVideo, int level );
    /* closes a display, releasing all resources assigned to it.
       Parameters
       hDisplay :  Render display to close.                      */
    RENDER_PROC( void         , CloseDisplay) ( PRENDERER );
    /* Updates just a portion of a display window. Minimizing the
       size required for screen output greatly increases efficiency.
       Also on vista+, this will update just a portion of a
       transparent display.
       Parameters
       hVideo :  the display to update
       x :       the left coordinate of the region to update
       y :       the top coordinate of the region to update
       width :   the width of the region to update
       height :  the height of the region to update
       DBG_PASS information is used to track who is doing updates
       when update logging is enabled.                               */
    RENDER_PROC( void , UpdateDisplayPortionEx) ( PRENDERER, int32_t x, int32_t y, uint32_t width, uint32_t height DBG_PASS );
/* <combine sack::image::render::UpdateDisplayPortionEx@PRENDERER@int32_t@int32_t@uint32_t@uint32_t height>
   \ \                                                                                      */
#define UpdateDisplayPortion(r,x,y,w,h) UpdateDisplayPortionEx(r,x,y,w,h DBG_SRC )
	 /* Updates the entire surface of a display.
	    Parameters
	    display :  display to update
	    DBG_PASS information is passed for logging writing to
	    physical display.
	                                                          */
	 RENDER_PROC( void , UpdateDisplayEx)        ( PRENDERER DBG_PASS );
#define UpdateDisplay(r) UpdateDisplayEx(r DBG_SRC)
/* Gets the current location and size of a display.
       Parameters
       hVideo :  display to get the position of
       x :       pointer to a signed 32 bit value to get the left
                 edge of the display.
       y :       pointer to a signed 32 bit value to get the top edge
                 of the display.
       width :   pointer to a unsigned 32 bit value to get the width.
       height :  pointer to a unsigned 32 bit value to get the
                 height.                                              */
    RENDER_PROC( void, GetDisplayPosition)   ( PRENDERER, int32_t *x, int32_t *y, uint32_t *width, uint32_t *height );
    /* Moves a display to an absolute position.
       Parameters
       render :  the display to move
       x :       new X coordinate for the left of the display
       y :       new Y coordinate for the top of the display  */
    RENDER_PROC( void , MoveDisplay)          ( PRENDERER, int32_t x, int32_t y );
    /* Moves a display relative to its current position.
       Parameters
       render :  the display to move
       delx :    a signed amount to add to its X coordiante
       dely :    a signed amount ot add to its Y coordinate. ( bigger
                 values go down the screen )                          */
    RENDER_PROC( void , MoveDisplayRel)       ( PRENDERER, int32_t delx, int32_t dely );
    /* Sets the display's current size. If it is different than
       before, will invoke render's redraw callback.
       Parameters
       display :  the display to set the size of
       w :        new width of the display
       h :        new height of the display                     */
    RENDER_PROC( void , SizeDisplay)          ( PRENDERER, uint32_t w, uint32_t h );
    /* Sets the display's current size relative to what it currently
       is. If it is different than before, will invoke render's
       redraw callback.
       Parameters
       display :  the display to set the size of
       w :        signed value to add to current width
       h :        signed value to add to current height              */
    RENDER_PROC( void , SizeDisplayRel)       ( PRENDERER, int32_t delw, int32_t delh );
   /* Change the position and size of a display.
      Parameters
      hVideo :  display to move and size
      x :       new left coordinate of the display
      y :       new top coordinate of the display
      w :       new width of the display
      h :       new height of the display          */
   RENDER_PROC( void, MoveSizeDisplay )( PRENDERER hVideo
                                        , int32_t x, int32_t y
                                        , int32_t w, int32_t h );
   /* Moves and changes the display size relative to its current
      size. All parameters are relative to current.
      Parameters
      hVideo :  display to move and change the size of
      delx :    amount to modify the left coordinate by
      dely :    amount to modify the top coordinate by
      delw :    amount to change the width by
      delh :    amount to change the height by                   */
   RENDER_PROC( void, MoveSizeDisplayRel )( PRENDERER hVideo
                                        , int32_t delx, int32_t dely
                                        , int32_t delw, int32_t delh );
		/* Put the display above another display. This makes sure that
		   the displays are stacked at least in this order.
		   Parameters
		   this_display :  the display to put above another
		   that_display :  the display that will be on the bottom.     */
		RENDER_PROC( void , PutDisplayAbove)      ( PRENDERER this_display, PRENDERER that_display );
      /* put this in container
	   Parameters
	   hVideo :      Display to put into another display surface
	   hContainer :  The new parent window of the hVideo.
	   Example
	   <code lang="c#">
	   Render render = OpenDisplay( 0 );
	   Render parent = OpenDisplay( 0 );
	   PutDisplayIn( render, parent );
	   </code>                                                   */
	 RENDER_PROC (void, PutDisplayIn) (PRENDERER hVideo, PRENDERER hContainer);
    /* Gets the Image from the Render.
       Parameters
       renderer :  the display window to get the surface of.
       Returns
       Image that is the surface of the window to draw to.   */
    RENDER_PROC( Image , GetDisplayImage)     ( PRENDERER );
    /* Sets the close handler callback. Called when a window is
       closed externally.
       Parameters
       hVideo :     display to set the close handler for
       callback :   close method to call when the display is called
       user_data :  user data passed to close method when invoked.  */
    RENDER_PROC( void , SetCloseHandler)      ( PRENDERER, CloseCallback, uintptr_t );
    /* Specifies the mouse event handler for a display.
       Parameters
       hVideo :     display to set the mouse handler for
       callback :   the routine to call when a mouse event happens.
       user_data :  this value is passed to the callback routine when
                    it is called.                                     */
    RENDER_PROC( void , SetMouseHandler)      ( PRENDERER, MouseCallback, uintptr_t );
    /* Specifies the hide event handler for a display.
       Parameters
       hVideo :     display to set the hide handler for
       callback :   the routine to call when a hide event happens.
       user_data :  this value is passed to the callback routine when
                    it is called.                                     */
    RENDER_PROC( void , SetHideHandler)      ( PRENDERER, HideAndRestoreCallback, uintptr_t );
    /* Specifies the restore event handler for a display.
       Parameters
       hVideo :     display to set the restore handler for
       callback :   the routine to call when a restore event happens.
       user_data :  this value is passed to the callback routine when
                    it is called.                                     */
    RENDER_PROC( void , SetRestoreHandler)      ( PRENDERER, HideAndRestoreCallback, uintptr_t );
#ifndef NO_TOUCH
    /* Specifies the touch event handler for a display.
       Parameters
       hVideo :     display to set the touch handler for
       callback :   the routine to call when a touch event happens.
       user_data :  this value is passed to the callback routine when
                    it is called.                                     */
	   RENDER_PROC( void , SetTouchHandler)      ( PRENDERER, TouchCallback, uintptr_t );
#endif
	 /* Sets the function to call when a redraw event is required.
	    Parameters
	    hVideo :     display to set the handler for
	    callback :   function to call when a redraw is required (or
	                 requested).
	    user_data :  this value is passed to the redraw callback.
	    Example
	    See <link render.h>
	    See Also
	    <link sack::image::render::Redraw@PRENDERER, Redraw>        */
	 RENDER_PROC( void , SetRedrawHandler)     ( PRENDERER, RedrawCallback, uintptr_t );
	 // call this to call the callback registered. as appropriate.  Said callback
    // should never be directly called by application.
    RENDER_PROC( void, Redraw )( PRENDERER hVideo );
    /* Sets the keyboard handler callback for a display
       Parameters
       hVideo :     display to receive key events for.
       callback :   callback invoked when a key event happens.
       user_data :  user data passed to the callback when invoked.
       Remarks
       the keyboard handler may make use of the scan code itself for
       PKEYDEFINE structures. There are also a variety of methods
       for checking the 32 bit key value. The value passed to the
       keyboard handler contains most all of the information about
       the state of the keyboard and specific key.                   */
    RENDER_PROC( void , SetKeyboardHandler)   ( PRENDERER, KeyProc, uintptr_t );
    /* Sets a callback handler called when focus is gained or lost
       by the display.
       Parameters
       hVideo :     display to set the event on
       callback :   the user callback to call when focus is lost or
                    gained.
       user_data :  user data passed to the callback when invoked.
       Note
       When the LoseFocusCallback is called, the renderer is the one
       that is getting the focus. This may be you, may be NULL
       (everyone losing focus) or may be another PRENDERER in your
       application.                                                  */
    RENDER_PROC( void , SetLoseFocusHandler)  ( PRENDERER, LoseFocusCallback, uintptr_t );
    /* Undefined */
    RENDER_PROC( void, SetRenderReadCallback )( PRENDERER pRenderer, RenderReadCallback callback, uintptr_t psv );
#if ACTIVE_MESSAGE_IMPLEMENTED
    RENDER_PROC( void , SetDefaultHandler)    ( PRENDERER, GeneralCallback, uintptr_t );
#endif
    /* Receives the current global mouse state, and position in
       screen coordinates.
       Parameters
       x :  pointer to a signed 32 bit value for the mouse X position.
       y :  pointer to a signed 32 bit value for the mouse Y position.
       b :  current state of mouse buttons. See <link sack::image::render::ButtonFlags, ButtonFlags>. */
    RENDER_PROC( void , GetMouseState )        ( int32_t *x, int32_t *y, uint32_t *b );
    /* Gets the current mouse position in screen coordinates.
       Parameters
       x :  pointer to a signed 32 bit value for the mouse position
       y :  pointer to a signed 32 bit value for the mouse position
       Example
       <code lang="c++">
       int32_t x, y;
       GetMousePosition( &amp;x, &amp;y );
       </code>                                                      */
    RENDER_PROC( void , GetMousePosition)     ( int32_t *x, int32_t *y );
    /* Sets the mouse pointer at the specified display coordinates.
       Parameters
       hDisplay :  display to use to where to position the mouse. Will
                   fault if NULL is passed.
       x :         x relative to the display to set the mouse
       y :         y relative to the display to set the mouse          */
    RENDER_PROC( void , SetMousePosition)     ( PRENDERER, int32_t x, int32_t y );
    /* Test a display to see if it is focused.
       Parameters
       hVideo :  display to check to see if it has focus. (keyboard
                 \input)
       Returns
       TRUE if focused, else FALSE.                                 */
    RENDER_PROC( LOGICAL , HasFocus)          ( PRENDERER );
#if ACTIVE_MESSAGE_IMPLEMENTED
    RENDER_PROC( int, SendActiveMessage)     ( PRENDERER dest, PACTIVEMESSAGE msg );
    RENDER_PROC( PACTIVEMESSAGE , CreateActiveMessage) ( int ID, int size, ... );
#endif
    /* Translates a key's scancode into text. Handles things like
       capslock, shift...
       Parameters
       key :  KEY_ to translate
       Returns
       char that the key represents. (should implement a method to
       get back the UNICODE character).                            */
    RENDER_PROC( const TEXTCHAR *, GetKeyText)             ( int key );
    /* Simple check to see if a key is in a pressed state.
       Parameters
       display :  display to check the key state in
       key :      KEY_ symbol to check.                    */
    RENDER_PROC( uint32_t, IsKeyDown )              ( PRENDERER display, int key );
    /* \ \
       Parameters
       display :  display to test the key status in
       key :      KEY_ symbol to check if the key is pressed
       Returns
       TRUE if the key is down, else FALSE.                  */
    RENDER_PROC( uint32_t, KeyDown )                ( PRENDERER display, int key );
    /* Sometimes displays can be closed by external forces (the
       close button on most windows). This tests to see if a display
       is still valid, or if it has been closed externally.
       Returns
       TRUE if display is still okay. FALSE if the display is no
       longer able to be used.
       Parameters
       display :  the display to check the validity of.              */
    RENDER_PROC( LOGICAL, DisplayIsValid )     ( PRENDERER display );
    /* Assigns all mouse input to a window. This allows the window
       to process messages which are outside of itself normally.
       Parameters
       display :  which window wants to own the mouse
       own :      1 to own, 0 to release ownership.                */
    RENDER_PROC( void, OwnMouseEx )            ( PRENDERER display, uint32_t bOwn DBG_PASS );
    /* Proprietary routine for reading touch screen serial devices
       directly and performing self calibration. Should rely on
       system driver and it's calibration instead.                 */
    RENDER_PROC( int, BeginCalibration )       ( uint32_t points );
    /* Used when display is accessed via a remote message pipe, this
       allows all render operations to be flushed and processed.
       Parameters
       display :  display to flush                                   */
    RENDER_PROC( void, SyncRender )            ( PRENDERER display );
/* Makes a display topmost. There isn't a way to un-topmost a
   window.
   Parameters
   hVideo :  display to make topmost
   Note
   Windows maintains at least two distinct stacks of windows. Normal
   windows in the normal window stack, and a set of windows that
   are above all other windows (except other windows that are
   also topmost).                                                    */
RENDER_PROC( void, MakeTopmost )( PRENDERER hVideo );
/* This makes the display topmost, but more so, any window that
   gets put over it it will attempt put itself over it.
   Parameters
   hVideo :  display to make top top most.                      */
RENDER_PROC (void, MakeAbsoluteTopmost) (PRENDERER hVideo);
/* Tests a display to see if it is set as topmost.
   Parameters
   hVideo :  display to inquire if it's topmost.
   Returns
   TRUE if display is topmost, else FALSE.         */
RENDER_PROC( int, IsTopmost )( PRENDERER hVideo );
/* Hides a display. That is, the content no longer shows on the
   users display.
   Parameters
   hVideo :  the handle of the Render to hide.
   See Also
   <link sack::image::render::RestoreDisplay@PRENDERER, RestoreDisplay> */
RENDER_PROC( void, HideDisplay )( PRENDERER hVideo );
/* Puts a display back on the screen. This is used in
   conjunction with HideDisplay().
   Parameters
   hVideo :  display to restore                       */
RENDER_PROC( void, RestoreDisplay )( PRENDERER hVideo );
	RENDER_PROC( void, RestoreDisplayEx )( PRENDERER hVideo DBG_PASS );
#define RestoreDisplay(n) RestoreDisplayEx( n DBG_SRC )
/* A check to see if HideDisplay has been applied to the
   display.
   Returns
   TRUE if the display is hidden, otherwise FALSE.
   Parameters
   video :  the display to check if hidden               */
RENDER_PROC( LOGICAL, IsDisplayHidden )( PRENDERER video );
// set focus to display, no events are generated if display already
// has the focus.
RENDER_PROC( void, ForceDisplayFocus )( PRENDERER display );
// display set as topmost within it's group (normal/bottommost/topmost)
RENDER_PROC( void, ForceDisplayFront )( PRENDERER display );
// display is force back one layer... or forced to bottom?
// alt-n pushed the display to the back... alt-tab is different...
RENDER_PROC( void, ForceDisplayBack )( PRENDERER display );
/* Not implemented on windows native, is for getting back
   display information over message service abstraction.
   if a readcallback is enabled, then this will be no-wait, and
   one will expect to receive the read data in the callback.
   Otherwise this will return any data which is present already,
   also non wait. Returns length read, INVALID_INDEX if no data
   read.
   If there IS a read callback, return will be 1 if there was no
   previous read queued, and 0 if there was already a read
   pending there may be one and only one read queued (for now)
   In either case if the read could not be queued, it will be
   0..
   If READLINE is true - then the result of the read will be a
   completed line. if there is no line present, and no callback
   defined, this will return INVALID_INDEX characters... 0
   characters is a n only (in line mode) 0 will be returned for
   no characters in non line mode...
   it will not have the end of line terminator (as generated by
   a non-bound enter key) I keep thinking there must be some
   kinda block mode read one can do, but no, uhh no, there's no
   way to get the user to put in X characters exactly....?
   Parameters
   pRenderer :  display to read from
   buffer :     buffer to read into
   maxlen :     maximum length of buffer to read
   bReadLine :  ???                                              */
RENDER_PROC( uint32_t, ReadDisplayEx )( PRENDERER pRenderer, TEXTSTR buffer, uint32_t maxlen, LOGICAL bReadLine );
/* Unused. Incomplete. */
#define ReadDisplay(r,b,len)      ReadDisplayEx(r,b,len,FALSE)
/* Unused. Incomplete. */
#define ReadDisplayLine(r,b,len)  ReadDisplayEx(r,b,len,TRUE)
/* Issues an update to a layered (transparent) window. This does
   the update directly, and does not have to be done within the
   redraw event.
   Parameters
   hVideo :    display to update a part of
   bContent :  TRUE is only the passed rectangle should update
   x :         left coordinate of the region to update to
               physical display
   y :         top coordinate of the region to update to physical
               display
   w :         width of the region to update to physical display
   h :         height of the region to update to physical display */
RENDER_PROC( void, IssueUpdateLayeredEx )( PRENDERER hVideo, LOGICAL bContent, int32_t x, int32_t y, uint32_t w, uint32_t h DBG_PASS );
#ifndef KEY_STRUCTURE_DEFINED
typedef LOGICAL (CPROC*KeyTriggerHandler)(uintptr_t,uint32_t keycode);
typedef struct KeyDefine *PKEYDEFINE;
#endif
/* Can create an external key binder to store key event
   bindings. One of these is available per display.
   Example
   <code lang="c++">
   void Alt_A_Pressed(uintptr_t user_data,uint32_t keycode)
   {
       // do something when alt-a is pressed.
   }
   {
      PKEYDEFINE my_key_events = CreateKeyBinder();
      BindKeyToEventEx( my_key_events, KEY_A, KEY_MOD_ALT, Alt_A_Pressed, 0 );
   }
   // then later, in a KeyProc handler...
   HandleKeyEvents( my_key_events, keycode );
   </code>                                                                     */
RENDER_PROC( PKEYDEFINE, CreateKeyBinder )( void );
/* Destroyes a PKEYDEFINE previously created with
   CreateKeyBinder.
   Parameters
   pKeyDef :  key binder to destroy.              */
RENDER_PROC( void, DestroyKeyBinder )( PKEYDEFINE pKeyDef );
/* Evaluates a key against the key defines to trigger possible
   events.
   Parameters
   KeyDefs :  PKEYDEFINE keystate which has keys bound to it.
   keycode :  the keycode passed to a KeyProc handler.         */
RENDER_PROC( int, HandleKeyEvents )( PKEYDEFINE KeyDefs, uint32_t keycode );
/* Assigns a callback routine to a key event.
   Parameters
   KeyDefs :   pointer to key table to set event in
   scancode :  scancode of the key \- this is a KEY_ code from
               keybrd.h
   modifier :  specific modifiers pressed for this event (control,
               alt, shift)
   trigger :   the trigger function to invoke when the key is
               pressed
   psv :       a uintptr_t user data passed to the trigger function
               when invoked.                                       */
RENDER_PROC( int, BindEventToKeyEx )( PKEYDEFINE KeyDefs, uint32_t scancode, uint32_t modifier, KeyTriggerHandler trigger, uintptr_t psv );
/* Binds a key to a display.
   Parameters
   pRenderer :  display to set the event in (each display has a
                PKEYDEFINE internally. If this is NULL, then the
                event is bound to global events, an applies for
                any display window that gets a key input.
   scancode :   key scancode (a KEY_ identifier from keybrd.h)
   modifier :   key state modifier to apply to match the trigger
                on (control, alt, shift)
   trigger :    callback to invoke when the key combination is
                pressed
   psv :        user data to pass to the trigger when invoked.   */
RENDER_PROC( int, BindEventToKey )( PRENDERER pRenderer, uint32_t scancode, uint32_t modifier, KeyTriggerHandler trigger, uintptr_t psv );
/* Remove a previous binding to a key.
   Parameters
   pRenderer :  renderer to remove the key bind from
   scancode :   key scancode to stop checking
   modifier :   key modifier to stop checking        */
RENDER_PROC( int, UnbindKey )( PRENDERER pRenderer, uint32_t scancode, uint32_t modifier );
/* A way to test to see if the current input device is a touch
   display. This can affect how mouse clicks are handles for
   things like buttons.
   Parameters
   None.
   Returns
   0.                                                          */
RENDER_PROC( int, IsTouchDisplay )( void );
// static void OnInputTouch( "Touch Handler" )(
#define OnSurfaceInput(name)	 __DefineRegistryMethod(WIDE("sack/render"),SurfaceInput,WIDE("surface input"),WIDE("SurfaceInput"),name,void,( int nInputs, PINPUT_POINT pInputs ),__LINE__)
#ifndef PSPRITE_METHOD
/* Unused. Incomplete. */
#define PSPRITE_METHOD PSPRITE_METHOD
RENDER_NAMESPACE_END
IMAGE_NAMESPACE
   /* define sprite draw method structure */
	typedef struct sprite_method_tag *PSPRITE_METHOD;
IMAGE_NAMESPACE_END
RENDER_NAMESPACE
#endif
/* Adds a sprite rendering method to the display. Just before
   updating to the display, the display is saved, and sprite
   update callbacks are issued. then the resulting display is
   \output. Sprite data only exists on the output image just
   before it is put on the physical display.
   Parameters
   render :    the display to attach a sprite render method to
   callback :  callback to draw sprites
   psv :       user data passed to callback when it is called
   Returns
   Pointer to a SpriteMethod that can be used in SavePortion...
   uhmm
   Note
   Has fallen into disrepair, and may need work before sprites
   work this way.                                               */
RENDER_PROC( PSPRITE_METHOD, EnableSpriteMethod )(PRENDERER render, void(CPROC*RenderSprites)(uintptr_t psv, PRENDERER renderer, int32_t x, int32_t y, uint32_t w, uint32_t h ), uintptr_t psv );
/* signature for callback method to pass to
   WinShell_AcceptDroppedFiles.             */
typedef LOGICAL (CPROC*dropped_file_acceptor)(uintptr_t psv, CTEXTSTR filename, int32_t x, int32_t y );
/* Adds a callback to call when a file is dropped. Each callback
   can return 0 that it did not accept the file, or 1 that it
   did. once the file is accepted by a handler, it is not passed
   to any other handlers.
   Parameters
   renderer :  display to handle dropped files for
   f :         callback to acceptor
   psvUser :   user data passed to acceptor when it is invoked   */
RENDER_PROC( void, WinShell_AcceptDroppedFiles )( PRENDERER renderer, dropped_file_acceptor f, uintptr_t psvUser );
/* Enables a timer on the mouse to hide the cursor after a
   second that the mouse is not being moved.
   Parameters
   hVideo :   display to hide the mouse automatically for
   bEnable :  enable automatic hiding. After a few seconds, the
              mouse goes away until it moves(not click).        */
RENDER_PROC (void, DisableMouseOnIdle) (PRENDERER hVideo, LOGICAL bEnable );
/* Sets whether the display wants to get any mouse events at
   all.
   Parameters
   hVideo :    display to set the property for
   bNoMouse :  if 1, disables any mouse events. if 0, enables mouse
               events to the display.                               */
RENDER_PROC( void, SetDisplayNoMouse )( PRENDERER hVideo, int bNoMouse );
#ifdef WIN32
	/* \returns the native handle used to output to. this can be an
	   SDL_Screen or HWND depending on platform.
	   Parameters
	   video :  display to get the native handle for
	   Returns
	   the system handle of the display object being used to output. */
	RENDER_PROC( HWND, GetNativeHandle )( PRENDERER video );
#endif
/* <combine sack::image::render::OwnMouseEx@PRENDERER@uint32_t bOwn>
   \ \                                                          */
#define OwnMouse(d,o) OwnMouseEx( d, o DBG_SRC )
/* <combine sack::image::render::OpenDisplaySizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t>
   \ \                                                                     */
#define OpenDisplay(a)            OpenDisplaySizedAt(a,-1,-1,-1,-1)
/* <combine sack::image::render::OpenDisplaySizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t>
   \ \                                                                     */
#define OpenDisplaySized(a,w,h)   OpenDisplaySizedAt(a,w,h,-1,-1)
/* <combine sack::image::render::OpenDisplayAboveSizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t@PRENDERER>
   \ \                                                                                    */
#define OpenDisplayAbove(p,a)            OpenDisplayAboveSizedAt(p,-1,-1,-1,-1,a)
/* <combine sack::image::render::OpenDisplayAboveSizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t@PRENDERER>
   \ \                                                                                    */
#define OpenDisplayAboveSized(p,a,w,h)   OpenDisplayAboveSizedAt(p,w,h,-1,-1,a)
/* <combine sack::image::render::OpenDisplayAboveUnderSizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t@PRENDERER@PRENDERER>
   \ \                                                                                                   */
#define OpenDisplayUnderSizedAt(p,a,w,h,x,y) OpenDisplayAboveUnderSizedAt(a,w,h,x,y,NULL,p)
/* Lock the renderer for this thread to use. */
RENDER_PROC( void, LockRenderer )( PRENDERER render );
/* Unlock the renderer for other threads to use. */
RENDER_PROC( void, UnlockRenderer )( PRENDERER render );
/* Function to check if the draw mode of the renderer requires
   an ALL update (opengl/direct3d) every frame the whole display
   must be drawn.                                                */
RENDER_PROC( LOGICAL, RequiresDrawAll )( void );
RENDER_PROC( void, MarkDisplayUpdated )( PRENDERER );
#ifndef __NO_INTERFACES__
/* Interface defines the functions that are exported from the
   render library. This interface may be retrieved with
   LoadInterface( "\<appropriate name" ).                     */
_INTERFACE_NAMESPACE
/* Macro to define exports for render.h */
#define RENDER_PROC_PTR(type,name) type  (CPROC*_##name)
/* <combine sack::image::render::render_interface_tag>
	\ \                                                 */
typedef struct render_interface_tag RENDER_INTERFACE;
/* <combine sack::image::render::render_interface_tag>
	\ \                                                 */
typedef struct render_interface_tag *PRENDER_INTERFACE;
/* This is a function table interface to the video library. Allows
   application to not be linked to the video portion directly,
   allowing dynamic replacement.                                   */
struct render_interface_tag
{
      /* <combine sack::image::render::InitDisplay>
         \ \                                        */
       RENDER_PROC_PTR( int , InitDisplay) (void);
       /* <combine sack::image::render::SetApplicationTitle@TEXTCHAR *>
          \ \                                                           */
			 RENDER_PROC_PTR( void , SetApplicationTitle) (const TEXTCHAR *title );
          /* <combine sack::image::render::SetApplicationIcon@Image>
                                                    \ \                                                     */
       RENDER_PROC_PTR( void , SetApplicationIcon)  (Image Icon);
    /* <combine sack::image::render::GetDisplaySize@uint32_t *@uint32_t *>
       \ \                                                       */
    RENDER_PROC_PTR( void , GetDisplaySize)      ( uint32_t *width, uint32_t *height );
    /* <combine sack::image::render::SetDisplaySize@uint32_t@uint32_t>
       \ \                                                   */
    RENDER_PROC_PTR( void , SetDisplaySize)      ( uint32_t width, uint32_t height );
    /* <combine sack::image::render::OpenDisplaySizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t>
       \ \                                                                     */
    RENDER_PROC_PTR( PRENDERER , OpenDisplaySizedAt)     ( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y );
    /* <combine sack::image::render::OpenDisplayAboveSizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t@PRENDERER>
       \ \                                                                                    */
    RENDER_PROC_PTR( PRENDERER , OpenDisplayAboveSizedAt)( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y, PRENDERER above );
    /* <combine sack::image::render::CloseDisplay@PRENDERER>
       \ \                                                   */
    RENDER_PROC_PTR( void        , CloseDisplay) ( PRENDERER );
    /* <combine sack::image::render::UpdateDisplayPortionEx@PRENDERER@int32_t@int32_t@uint32_t@uint32_t height>
       \ \                                                                                      */
    RENDER_PROC_PTR( void, UpdateDisplayPortionEx) ( PRENDERER, int32_t x, int32_t y, uint32_t width, uint32_t height DBG_PASS );
    /* <combine sack::image::render::UpdateDisplayEx@PRENDERER>
       \ \                                                      */
    RENDER_PROC_PTR( void, UpdateDisplayEx)        ( PRENDERER DBG_PASS);
    /* <combine sack::image::render::GetDisplayPosition@PRENDERER@int32_t *@int32_t *@uint32_t *@uint32_t *>
       \ \                                                                                   */
    RENDER_PROC_PTR( void, GetDisplayPosition)   ( PRENDERER, int32_t *x, int32_t *y, uint32_t *width, uint32_t *height );
    /* <combine sack::image::render::MoveDisplay@PRENDERER@int32_t@int32_t>
       \ \                                                            */
    RENDER_PROC_PTR( void, MoveDisplay)          ( PRENDERER, int32_t x, int32_t y );
    /* <combine sack::image::render::MoveDisplayRel@PRENDERER@int32_t@int32_t>
       \ \                                                               */
    RENDER_PROC_PTR( void, MoveDisplayRel)       ( PRENDERER, int32_t delx, int32_t dely );
    /* <combine sack::image::render::SizeDisplay@PRENDERER@uint32_t@uint32_t>
       \ \                                                          */
    RENDER_PROC_PTR( void, SizeDisplay)          ( PRENDERER, uint32_t w, uint32_t h );
    /* <combine sack::image::render::SizeDisplayRel@PRENDERER@int32_t@int32_t>
       \ \                                                               */
    RENDER_PROC_PTR( void, SizeDisplayRel)       ( PRENDERER, int32_t delw, int32_t delh );
    /* <combine sack::image::render::MoveSizeDisplayRel@PRENDERER@int32_t@int32_t@int32_t@int32_t>
       \ \                                                                             */
    RENDER_PROC_PTR( void, MoveSizeDisplayRel )  ( PRENDERER hVideo
                                                 , int32_t delx, int32_t dely
                                                 , int32_t delw, int32_t delh );
    RENDER_PROC_PTR( void, PutDisplayAbove)      ( PRENDERER, PRENDERER );
 /* <combine sack::image::render::PutDisplayAbove@PRENDERER@PRENDERER>
                                                              \ \                                                                */
    /* <combine sack::image::render::GetDisplayImage@PRENDERER>
       \ \                                                      */
    RENDER_PROC_PTR( Image, GetDisplayImage)     ( PRENDERER );
    /* <combine sack::image::render::SetCloseHandler@PRENDERER@CloseCallback@uintptr_t>
       \ \                                                                             */
    RENDER_PROC_PTR( void, SetCloseHandler)      ( PRENDERER, CloseCallback, uintptr_t );
    /* <combine sack::image::render::SetMouseHandler@PRENDERER@MouseCallback@uintptr_t>
       \ \                                                                             */
    RENDER_PROC_PTR( void, SetMouseHandler)      ( PRENDERER, MouseCallback, uintptr_t );
    /* <combine sack::image::render::SetRedrawHandler@PRENDERER@RedrawCallback@uintptr_t>
       \ \                                                                               */
    RENDER_PROC_PTR( void, SetRedrawHandler)     ( PRENDERER, RedrawCallback, uintptr_t );
    /* <combine sack::image::render::SetKeyboardHandler@PRENDERER@KeyProc@uintptr_t>
       \ \                                                                          */
    RENDER_PROC_PTR( void, SetKeyboardHandler)   ( PRENDERER, KeyProc, uintptr_t );
    /* <combine sack::image::render::SetLoseFocusHandler@PRENDERER@LoseFocusCallback@uintptr_t>
       \ \                                                                                     */
    RENDER_PROC_PTR( void, SetLoseFocusHandler)  ( PRENDERER, LoseFocusCallback, uintptr_t );
    /* <combine sack::image::render::SetDefaultHandler@PRENDERER@GeneralCallback@uintptr_t>
       \ \                                                                                 */
#if ACTIVE_MESSAGE_IMPLEMENTED
			 RENDER_PROC_PTR( void, SetDefaultHandler)    ( PRENDERER, GeneralCallback, uintptr_t );
#else
       POINTER junk1;
#endif
    /* <combine sack::image::render::GetMousePosition@int32_t *@int32_t *>
		 \ \                                                           */
    RENDER_PROC_PTR( void, GetMousePosition)     ( int32_t *x, int32_t *y );
    /* <combine sack::image::render::SetMousePosition@PRENDERER@int32_t@int32_t>
       \ \                                                                 */
    RENDER_PROC_PTR( void, SetMousePosition)     ( PRENDERER, int32_t x, int32_t y );
    /* <combine sack::image::render::HasFocus@PRENDERER>
       \ \                                               */
    RENDER_PROC_PTR( LOGICAL, HasFocus)          ( PRENDERER );
    /* <combine sack::image::render::GetKeyText@int>
       \ \                                           */
    RENDER_PROC_PTR( const TEXTCHAR *, GetKeyText)           ( int key );
    /* <combine sack::image::render::IsKeyDown@PRENDERER@int>
       \ \                                                    */
    RENDER_PROC_PTR( uint32_t, IsKeyDown )        ( PRENDERER display, int key );
    /* <combine sack::image::render::KeyDown@PRENDERER@int>
       \ \                                                  */
    RENDER_PROC_PTR( uint32_t, KeyDown )         ( PRENDERER display, int key );
    /* <combine sack::image::render::DisplayIsValid@PRENDERER>
       \ \                                                     */
    RENDER_PROC_PTR( LOGICAL, DisplayIsValid )  ( PRENDERER display );
    /* <combine sack::image::render::OwnMouseEx@PRENDERER@uint32_t bOwn>
       \ \                                                          */
    RENDER_PROC_PTR( void, OwnMouseEx )            ( PRENDERER display, uint32_t Own DBG_PASS);
    /* <combine sack::image::render::BeginCalibration@uint32_t>
       \ \                                                 */
    RENDER_PROC_PTR( int, BeginCalibration )       ( uint32_t points );
    /* <combine sack::image::render::SyncRender@PRENDERER>
       \ \                                                 */
    RENDER_PROC_PTR( void, SyncRender )            ( PRENDERER pDisplay );
    /* DEPRICATED; left in structure for compatibility.  Removed define and export definition. */
	 /* <combine sack::image::render::MoveSizeDisplay@PRENDERER@int32_t@int32_t@int32_t@int32_t>
	    \ \                                                                          */
	 RENDER_PROC_PTR( void, MoveSizeDisplay )( PRENDERER hVideo
                                        , int32_t x, int32_t y
                                        , int32_t w, int32_t h );
   /* <combine sack::image::render::MakeTopmost@PRENDERER>
      \ \                                                  */
   RENDER_PROC_PTR( void, MakeTopmost )    ( PRENDERER hVideo );
   /* <combine sack::image::render::HideDisplay@PRENDERER>
      \ \                                                  */
   RENDER_PROC_PTR( void, HideDisplay )      ( PRENDERER hVideo );
   /* <combine sack::image::render::RestoreDisplay@PRENDERER>
      \ \                                                     */
   RENDER_PROC_PTR( void, RestoreDisplay )   ( PRENDERER hVideo );
	/* <combine sack::image::render::ForceDisplayFocus@PRENDERER>
	   \ \                                                        */
	RENDER_PROC_PTR( void, ForceDisplayFocus )( PRENDERER display );
	/* <combine sack::image::render::ForceDisplayFront@PRENDERER>
	   \ \                                                        */
	RENDER_PROC_PTR( void, ForceDisplayFront )( PRENDERER display );
	/* <combine sack::image::render::ForceDisplayBack@PRENDERER>
	   \ \                                                       */
	RENDER_PROC_PTR( void, ForceDisplayBack )( PRENDERER display );
	/* <combine sack::image::render::BindEventToKey@PRENDERER@uint32_t@uint32_t@KeyTriggerHandler@uintptr_t>
	   \ \                                                                                        */
	RENDER_PROC_PTR( int, BindEventToKey )( PRENDERER pRenderer, uint32_t scancode, uint32_t modifier, KeyTriggerHandler trigger, uintptr_t psv );
	/* <combine sack::image::render::UnbindKey@PRENDERER@uint32_t@uint32_t>
	   \ \                                                        */
	RENDER_PROC_PTR( int, UnbindKey )( PRENDERER pRenderer, uint32_t scancode, uint32_t modifier );
	/* <combine sack::image::render::IsTopmost@PRENDERER>
	   \ \                                                */
	RENDER_PROC_PTR( int, IsTopmost )( PRENDERER hVideo );
	/* Used as a point to sync between applications and the message
	   display server; Makes sure that all draw commands which do
	   not have a response are done.
	   Waits until all commands are processed; which is wait until
	   this command is processed.                                   */
	RENDER_PROC_PTR( void, OkaySyncRender )            ( void );
   /* <combine sack::image::render::IsTouchDisplay>
      \ \                                           */
   RENDER_PROC_PTR( int, IsTouchDisplay )( void );
	/* <combine sack::image::render::GetMouseState@int32_t *@int32_t *@uint32_t *>
	   \ \                                                              */
	RENDER_PROC_PTR( void , GetMouseState )        ( int32_t *x, int32_t *y, uint32_t *b );
	/* <combine sack::image::render::EnableSpriteMethod@PRENDERER@void__cdecl*RenderSpritesPTRSZVAL psv\, PRENDERER renderer\, int32_t x\, int32_t y\, uint32_t w\, uint32_t h@uintptr_t>
	   \ \                                                                                                                                                               */
	RENDER_PROC_PTR ( PSPRITE_METHOD, EnableSpriteMethod )(PRENDERER render, void(CPROC*RenderSprites)(uintptr_t psv, PRENDERER renderer, int32_t x, int32_t y, uint32_t w, uint32_t h ), uintptr_t psv );
	/* <combine sack::image::render::WinShell_AcceptDroppedFiles@PRENDERER@dropped_file_acceptor@uintptr_t>
	   \ \                                                                                                 */
	RENDER_PROC_PTR( void, WinShell_AcceptDroppedFiles )( PRENDERER renderer, dropped_file_acceptor f, uintptr_t psvUser );
	/* <combine sack::image::render::PutDisplayIn@PRENDERER@PRENDERER>
	   \ \                                                             */
	RENDER_PROC_PTR(void, PutDisplayIn) (PRENDERER hVideo, PRENDERER hContainer);
#ifdef WIN32
	/* <combine sack::image::render::MakeDisplayFrom@HWND>
	   \ \                                                 */
			RENDER_PROC_PTR (PRENDERER, MakeDisplayFrom) (HWND hWnd) ;
#else
      POINTER junk4;
#endif
	/* <combine sack::image::render::SetRendererTitle@PRENDERER@TEXTCHAR *>
	   \ \                                                                  */
	RENDER_PROC_PTR( void , SetRendererTitle) ( PRENDERER render, const TEXTCHAR *title );
	/* <combine sack::image::render::DisableMouseOnIdle@PRENDERER@LOGICAL>
	   \ \                                                                 */
	RENDER_PROC_PTR (void, DisableMouseOnIdle) (PRENDERER hVideo, LOGICAL bEnable );
	/* <combine sack::image::render::OpenDisplayAboveUnderSizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t@PRENDERER@PRENDERER>
	   \ \                                                                                                   */
	RENDER_PROC_PTR( PRENDERER, OpenDisplayAboveUnderSizedAt)( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y, PRENDERER above, PRENDERER under );
	/* <combine sack::image::render::SetDisplayNoMouse@PRENDERER@int>
	   \ \                                                            */
	RENDER_PROC_PTR( void, SetDisplayNoMouse )( PRENDERER hVideo, int bNoMouse );
	/* <combine sack::image::render::Redraw@PRENDERER>
	   \ \                                             */
	RENDER_PROC_PTR( void, Redraw )( PRENDERER hVideo );
	/* <combine sack::image::render::MakeAbsoluteTopmost@PRENDERER>
	   \ \                                                          */
	RENDER_PROC_PTR(void, MakeAbsoluteTopmost) (PRENDERER hVideo);
	/* <combine sack::image::render::SetDisplayFade@PRENDERER@int>
	   \ \                                                         */
	RENDER_PROC_PTR( void, SetDisplayFade )( PRENDERER hVideo, int level );
	/* <combine sack::image::render::IsDisplayHidden@PRENDERER>
	   \ \                                                      */
	RENDER_PROC_PTR( LOGICAL, IsDisplayHidden )( PRENDERER video );
#ifdef WIN32
	/* <combine sack::image::render::GetNativeHandle@PRENDERER>
	   \ \                                                      */
	RENDER_PROC_PTR( HWND, GetNativeHandle )( PRENDERER video );
#endif
		 /* <combine sack::image::render::GetDisplaySizeEx@int@int32_t *@int32_t *@uint32_t *@uint32_t *>
		    \ \                                                                           */
		 RENDER_PROC_PTR (void, GetDisplaySizeEx) ( int nDisplay
														  , int32_t *x, int32_t *y
														  , uint32_t *width, uint32_t *height);
	/* Locks a video display. Applications shouldn't be locking
	   this, but if for some reason they require it; use this
	   function.                                                */
	RENDER_PROC_PTR( void, LockRenderer )( PRENDERER render );
	/* Release renderer lock critical section. Applications
	   shouldn't be locking this surface.                   */
	RENDER_PROC_PTR( void, UnlockRenderer )( PRENDERER render );
	/* Provides a way for applications to cause the window to flush
	   to the display (if it's a transparent window)                */
	RENDER_PROC_PTR( void, IssueUpdateLayeredEx )( PRENDERER hVideo, LOGICAL bContent, int32_t x, int32_t y, uint32_t w, uint32_t h DBG_PASS );
	/* Check to see if the render mode is always redraw; changes how
	   smudge works in PSI. If always redrawn, then the redraw isn't
	   done during the smudge, and instead is delayed until a draw
	   is triggered at which time all controls are drawn.
	   Returns
	   TRUE if full screen needs to be drawn during a draw,
	   otherwise partial updates may be done.                        */
	RENDER_PROC_PTR( LOGICAL, RequiresDrawAll )( void );
#ifndef NO_TOUCH
		/* <combine sack::image::render::SetTouchHandler@PRENDERER@fte inc asdfl;kj
		 fteTouchCallback@uintptr_t>
       \ \                                                                             */
			RENDER_PROC_PTR( void, SetTouchHandler)      ( PRENDERER, TouchCallback, uintptr_t );
#endif
    RENDER_PROC_PTR( void, MarkDisplayUpdated )( PRENDERER );
    /* <combine sack::image::render::SetHideHandler@PRENDERER@HideAndRestoreCallback@uintptr_t>
       \ \                                                                             */
    RENDER_PROC_PTR( void, SetHideHandler)      ( PRENDERER, HideAndRestoreCallback, uintptr_t );
    /* <combine sack::image::render::SetRestoreHandler@PRENDERER@HideAndRestoreCallback@uintptr_t>
       \ \                                                                             */
    RENDER_PROC_PTR( void, SetRestoreHandler)      ( PRENDERER, HideAndRestoreCallback, uintptr_t );
		 RENDER_PROC_PTR( void, RestoreDisplayEx )   ( PRENDERER hVideo DBG_PASS );
		 /* added for android extensions; call to enable showing the keyboard in the correct thread
        ; may have applications for windows tablets
		  */
       RENDER_PROC_PTR( void, SACK_Vidlib_ShowInputDevice )( void );
		 /* added for android extensions; call to enable hiding the keyboard in the correct thread
		  ; may have applications for windows tablets */
       RENDER_PROC_PTR( void, SACK_Vidlib_HideInputDevice )( void );
	/* Check to see if the render mode is allows updates from any thread.
	   If supported can simplify updates (requiring less scheduling queues).
	   If it is not supported (such as an X display where only a single thread
	   can write to the server, otherwise the socket state gets confused) then
	   Redraw() should be used to dispatch appriorately.  PSI Implements this
	   internally, so smudge() on a control will behave appriopriately.
	   If RequiresDrawAll() this is irrelavent.
	   Returns
	   TRUE if any thread is allowed to generate UpdateDisplayPortion().
	   otherwise must call Redraw() on the surface to get a event in the
	   correct thread.*/
			 RENDER_PROC_PTR( LOGICAL, AllowsAnyThreadToUpdate )( void );
		/* This method takes the renderer and either A) resizes it to the display
		 and issues a redraw; or it sets the screen to the size of the renderer
		 and scales the image direct to the display.  Pass NULL or another window
		 to clear the current fullscreen app.
		 Second paramter is the display to show full on; 0 is 'default'...
		 1, 2, 3, etc... will be absolute number... if not supported will be same a 0 */
		RENDER_PROC_PTR( void, SetDisplayFullScreen )( PRENDERER renderer, int nDisplay );
		/* like full screen, some applications may want to
       enable owning the screen... (media player) */
      RENDER_PROC_PTR( void, SuspendSystemSleep )( int bool_suspend_enable );
	RENDER_PROC_PTR( LOGICAL, RenderIsInstanced )( void );
	RENDER_PROC_PTR( LOGICAL, VidlibRenderAllowsCopy )( void );
	RENDER_PROC_PTR( void, SetDisplayCursor )( CTEXTSTR nCursor );
	RENDER_PROC_PTR( LOGICAL, IsDisplayRedrawForced )( PRENDERER renderer );
 // only valid during a headless display event....
	RENDER_PROC_PTR( void, ReplyCloseDisplay )( void );
};
#ifdef DEFINE_DEFAULT_RENDER_INTERFACE
#define USE_RENDER_INTERFACE GetDisplayInterface()
#endif
#ifdef FORCE_NO_INTERFACE
#undef USE_RENDER_INTERFACE
#endif
#ifdef FORCE_NO_RENDER_INTERFACE
#undef USE_RENDER_INTERFACE
#endif
#if !defined(FORCE_NO_RENDER_INTERFACE)
/* RENDER_PROC( PRENDER_INTERFACE, GetDisplayInterface )( void );
   Gets the interface the proper way - by name.
   Returns
   Pointer to the render interface.                            */
#  define GetDisplayInterface() (PRENDER_INTERFACE)GetInterface( WIDE("render") )
/* RENDER_PROC( void, DropDisplayInterface )( PRENDER_INTERFACE interface );
   release the interface (could be cleanup, most are donothing....
   parameters
   interface   - Pointer to the render interface.                            */
#  define DropDisplayInterface(x) DropInterface( WIDE("render"), x )
#endif
#ifdef USE_RENDER_INTERFACE
typedef int check_this_variable;
// these methods are provided for backwards compatibility
// these should not be used - but rather use the interface defined below
// (the ones not prefixed by ActImage_ - except for ActImage_Init, which
// may(should) be called before any other function.
#define REND_PROC_ALIAS(name) ((USE_RENDER_INTERFACE)->_##name)
#define REND_PROC_ALIAS_VOID(name) if(USE_RENDER_INTERFACE)(USE_RENDER_INTERFACE)->_##name
#define SetApplicationTitle       REND_PROC_ALIAS(SetApplicationTitle)
#define SetRendererTitle       REND_PROC_ALIAS(SetRendererTitle)
#define SetApplicationIcon        REND_PROC_ALIAS(SetApplicationIcon)
#define GetDisplaySize            REND_PROC_ALIAS(GetDisplaySize)
#define GetDisplaySizeEx            REND_PROC_ALIAS(GetDisplaySizeEx)
#define MarkDisplayUpdated            REND_PROC_ALIAS(MarkDisplayUpdated)
#define SetDisplaySize            REND_PROC_ALIAS(SetDisplaySize)
#define GetDisplayPosition        REND_PROC_ALIAS(GetDisplayPosition)
#define IssueUpdateLayeredEx      REND_PROC_ALIAS(IssueUpdateLayeredEx)
#define MakeDisplayFrom        REND_PROC_ALIAS(MakeDisplayFrom)
#define OpenDisplaySizedAt        REND_PROC_ALIAS(OpenDisplaySizedAt)
#define OpenDisplayAboveSizedAt   REND_PROC_ALIAS(OpenDisplayAboveSizedAt)
#define OpenDisplayAboveUnderSizedAt   REND_PROC_ALIAS(OpenDisplayAboveUnderSizedAt)
#define CloseDisplay              REND_PROC_ALIAS(CloseDisplay)
#define UpdateDisplayPortionEx    REND_PROC_ALIAS(UpdateDisplayPortionEx)
#define UpdateDisplayEx             REND_PROC_ALIAS(UpdateDisplayEx)
#define SetMousePosition          REND_PROC_ALIAS(SetMousePosition)
#define GetMousePosition          REND_PROC_ALIAS(GetMousePosition)
#define GetMouseState          REND_PROC_ALIAS(GetMouseState)
#define EnableSpriteMethod          REND_PROC_ALIAS(EnableSpriteMethod)
#define WinShell_AcceptDroppedFiles REND_PROC_ALIAS(WinShell_AcceptDroppedFiles)
#define MoveDisplay               REND_PROC_ALIAS(MoveDisplay)
#define MoveDisplayRel            REND_PROC_ALIAS(MoveDisplayRel)
#define SizeDisplay               REND_PROC_ALIAS(SizeDisplay)
#define Redraw               REND_PROC_ALIAS(Redraw)
#define RequiresDrawAll()        (USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_RequiresDrawAll()):0
#define SizeDisplayRel            REND_PROC_ALIAS(SizeDisplayRel)
#define MoveSizeDisplay        REND_PROC_ALIAS(MoveSizeDisplay)
#define MoveSizeDisplayRel        REND_PROC_ALIAS(MoveSizeDisplayRel)
#define PutDisplayAbove           REND_PROC_ALIAS(PutDisplayAbove)
#define PutDisplayIn           REND_PROC_ALIAS(PutDisplayIn)
#define GetDisplayImage           REND_PROC_ALIAS(GetDisplayImage)
#define LockRenderer              REND_PROC_ALIAS(LockRenderer)
#define UnlockRenderer              REND_PROC_ALIAS(UnlockRenderer)
#define SetCloseHandler           REND_PROC_ALIAS(SetCloseHandler)
#define SetMouseHandler           REND_PROC_ALIAS(SetMouseHandler)
#define SetHideHandler           REND_PROC_ALIAS(SetHideHandler)
#define SetRestoreHandler           REND_PROC_ALIAS(SetRestoreHandler)
#define AllowsAnyThreadToUpdate()          ((USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_AllowsAnyThreadToUpdate)?(USE_RENDER_INTERFACE)->_AllowsAnyThreadToUpdate():1:1)
#define VidlibRenderAllowsCopy()        ((USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_VidlibRenderAllowsCopy)?(USE_RENDER_INTERFACE)->_VidlibRenderAllowsCopy():1:1)
#ifndef __LINUX__
#define SetTouchHandler           REND_PROC_ALIAS(SetTouchHandler)
#endif
#define SetRedrawHandler          REND_PROC_ALIAS(SetRedrawHandler)
#define SetKeyboardHandler        REND_PROC_ALIAS(SetKeyboardHandler)
#define SetLoseFocusHandler       REND_PROC_ALIAS(SetLoseFocusHandler)
#define SetDefaultHandler         REND_PROC_ALIAS(SetDefaultHandler)
#define GetKeyText                REND_PROC_ALIAS(GetKeyText)
#define HasFocus                  REND_PROC_ALIAS(HasFocus)
#define SACK_Vidlib_ShowInputDevice REND_PROC_ALIAS( SACK_Vidlib_ShowInputDevice )
#define SACK_Vidlib_HideInputDevice REND_PROC_ALIAS( SACK_Vidlib_HideInputDevice )
#define CreateMessage             REND_PROC_ALIAS(CreateMessage)
#define SendActiveMessage         REND_PROC_ALIAS(SendActiveMessage)
#define IsKeyDown                 REND_PROC_ALIAS(IsKeyDown)
#define KeyDown                   REND_PROC_ALIAS(KeyDown)
#define DisplayIsValid            REND_PROC_ALIAS(DisplayIsValid)
#define OwnMouseEx                REND_PROC_ALIAS(OwnMouseEx)
#define BeginCalibration          REND_PROC_ALIAS(BeginCalibration)
#define SyncRender                REND_PROC_ALIAS(SyncRender)
#define OkaySyncRender                REND_PROC_ALIAS(OkaySyncRender)
#define HideDisplay               REND_PROC_ALIAS(HideDisplay)
#define IsDisplayHidden               REND_PROC_ALIAS(IsDisplayHidden)
/* <combine sack::image::render::GetNativeHandle@PRENDERER>
   \ \                                                      */
#define GetNativeHandle             REND_PROC_ALIAS(GetNativeHandle)
//#define RestoreDisplay             REND_PROC_ALIAS(RestoreDisplay)
#define RestoreDisplayEx             REND_PROC_ALIAS(RestoreDisplayEx)
#define MakeTopmost               REND_PROC_ALIAS_VOID(MakeTopmost)
#define MakeAbsoluteTopmost               REND_PROC_ALIAS_VOID(MakeAbsoluteTopmost)
#define IsTopmost               REND_PROC_ALIAS(IsTopmost)
#define SetDisplayFade               REND_PROC_ALIAS(SetDisplayFade)
#define ForceDisplayFocus         REND_PROC_ALIAS(ForceDisplayFocus)
#define ForceDisplayFront       REND_PROC_ALIAS(ForceDisplayFront)
#define ForceDisplayBack          REND_PROC_ALIAS(ForceDisplayBack)
#define BindEventToKey          REND_PROC_ALIAS(BindEventToKey)
#define UnbindKey               REND_PROC_ALIAS(UnbindKey)
#define IsTouchDisplay          REND_PROC_ALIAS(IsTouchDisplay)
#define DisableMouseOnIdle      REND_PROC_ALIAS(DisableMouseOnIdle )
#define SetDisplayNoMouse      REND_PROC_ALIAS(SetDisplayNoMouse )
#define SetTouchHandler        REND_PROC_ALIAS(SetTouchHandler)
#define ReplyCloseDisplay      if(USE_RENDER_INTERFACE) if((USE_RENDER_INTERFACE)->_ReplyCloseDisplay) (USE_RENDER_INTERFACE)->_ReplyCloseDisplay
#define SetDisplayFullScreen    REND_PROC_ALIAS_VOID( SetDisplayFullScreen )
#define SuspendSystemSleep      REND_PROC_ALIAS_VOID( SuspendSystemSleep )
#define RenderIsInstanced()       ((USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_RenderIsInstanced)?(USE_RENDER_INTERFACE)->_RenderIsInstanced():0:0)
#define SetDisplayCursor(n)           {if((USE_RENDER_INTERFACE)&&(USE_RENDER_INTERFACE)->_SetDisplayCursor)REND_PROC_ALIAS(SetDisplayCursor)(n);}
#define IsDisplayRedrawForced(r)    ((USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_IsDisplayRedrawForced)?(USE_RENDER_INTERFACE)->_IsDisplayRedrawForced(r):0:0)
#endif
	_INTERFACE_NAMESPACE_END
#ifdef __cplusplus
#ifdef _D3D_DRIVER
	using namespace sack::image::render::d3d::Interface;
#elif defined( _D3D10_DRIVER )
	using namespace sack::image::render::d3d10::Interface;
#elif defined( _D3D11_DRIVER )
	using namespace sack::image::render::d3d11::Interface;
#else
	using namespace sack::image::render::Interface;
#endif
#endif
#endif
#ifndef __NO_MSGSVR__
#ifdef DEFINE_RENDER_PROTOCOL
  // offsetof
// need to define BASE_RENDER_MESSAGE_ID before including this.
//#define MSG_ID(method)  ( ( offsetof( struct render_interface_tag, _##method ) / sizeof( void(*)(void) ) ) + BASE_RENDER_MESSAGE_ID + MSG_EventUser )
#define MSG_DisplayClientClose        MSG_ID(DisplayClientClose)
#define MSG_SetApplicationTitle       MSG_ID(SetApplicationTitle)
#define MSG_SetRendererTitle       MSG_ID(SetRendererTitle)
#define MSG_SetApplicationIcon        MSG_ID(SetApplicationTitle)
#define MSG_GetDisplaySize            MSG_ID(GetDisplaySize)
#define MSG_SetDisplaySize            MSG_ID(SetDisplaySize)
#define MSG_GetDisplayPosition        MSG_ID(GetDisplayPosition)
#define MSG_OpenDisplaySizedAt        MSG_ID(OpenDisplaySizedAt)
#define MSG_OpenDisplayAboveSizedAt   MSG_ID(OpenDisplayAboveSizedAt)
#define MSG_CloseDisplay              MSG_ID(CloseDisplay)
#define MSG_UpdateDisplayPortionEx    MSG_ID(UpdateDisplayPortionEx)
#define MSG_UpdateDisplay             MSG_ID(UpdateDisplayEx)
#define MSG_SetMousePosition          MSG_ID(SetMousePosition)
#define MSG_GetMousePosition          MSG_ID(GetMousePosition)
#define MSG_GetMouseState             MSG_ID(GetMouseState )
#define MSG_Redraw               MSG_ID(Redraw)
#define MSG_EnableSpriteMethod             MSG_ID(EnableSpriteMethod )
#define MSG_WinShell_AcceptDroppedFiles    MSG_ID(WinShell_AcceptDroppedFiles )
#define MSG_MoveDisplay               MSG_ID(MoveDisplay)
#define MSG_MoveDisplayRel            MSG_ID(MoveDisplayRel)
#define MSG_SizeDisplay               MSG_ID(SizeDisplay)
#define MSG_SizeDisplayRel            MSG_ID(SizeDisplayRel)
#define MSG_MoveSizeDisplay           MSG_ID(MoveSizeDisplay)
#define MSG_MoveSizeDisplayRel        MSG_ID(MoveSizeDisplayRel)
#define MSG_PutDisplayAbove           MSG_ID(PutDisplayAbove)
#define MSG_GetDisplayImage           MSG_ID(GetDisplayImage)
#define MSG_SetCloseHandler           MSG_ID(SetCloseHandler)
#define MSG_SetMouseHandler           MSG_ID(SetMouseHandler)
#define MSG_SetRedrawHandler          MSG_ID(SetRedrawHandler)
#define MSG_SetKeyboardHandler        MSG_ID(SetKeyboardHandler)
#define MSG_SetLoseFocusHandler       MSG_ID(SetLoseFocusHandler)
#define MSG_SetDefaultHandler         MSG_ID(SetDefaultHandler)
// -- all other handlers - client side only
#define MSG_HasFocus                  MSG_ID(HasFocus)
#define MSG_SendActiveMessage         MSG_ID(SendActiveMessage)
#define MSG_GetKeyText                MSG_ID(GetKeyText)
#define MSG_IsKeyDown                 MSG_ID(IsKeyDown)
#define MSG_KeyDown                   MSG_ID(KeyDown)
#define MSG_DisplayIsValid            MSG_ID(DisplayIsValid)
#define MSG_OwnMouseEx                 MSG_ID(OwnMouseEx)
#define MSG_BeginCalibration           MSG_ID(BeginCalibration)
#define MSG_SyncRender                 MSG_ID(SyncRender)
#define MSG_OkaySyncRender                 MSG_ID(OkaySyncRender)
#define MSG_HideDisplay               MSG_ID(HideDisplay)
#define MSG_IsDisplayHidden               MSG_ID(IsDisplayHidden)
#define MSG_RestoreDisplay             MSG_ID(RestoreDisplay)
#define MSG_MakeTopmost               MSG_ID(MakeTopmost)
#define MSG_BindEventToKey          MSG_ID(BindEventToKey)
#define MSG_UnbindKey               MSG_ID(UnbindKey)
#define MSG_IsTouchDisplay          MSG_ID(IsTouchDisplay )
#define MSG_GetNativeHandle             MSG_ID(GetNativeHandle)
#endif
#endif
// static void OnDisplayChangedSize( WIDE("") )( PRENDERER, int nDisplay, uint32_t x, uint32_t y, uint32_t width, uint32_t height )
	// OnDisplayPause is called on systems that allow the application to suspend its display.
	// Sleep mode may also trigger such an event, allows application to save state
   // a media player, for instance, may recover unplayed buffers to prepare for resume
#define OnDisplaySizeChange(name)	 __DefineRegistryMethod(WIDE("sack/render"),OnDisplaySizeChange,WIDE("display"),name,WIDE("on_display_size_change"),void,( uintptr_t psv_redraw, int nDisplay, int32_t x, int32_t y, uint32_t width, uint32_t height ),__LINE__)
// static void OnDisplayPause( WIDE("") )( void )
	// OnDisplayPause is called on systems that allow the application to suspend its display.
	// Sleep mode may also trigger such an event, allows application to save state
   // a media player, for instance, may recover unplayed buffers to prepare for resume
#define OnDisplayPause(name)	 __DefineRegistryMethod(WIDE("sack/render/android"),OnDisplayPause,WIDE("display"),name,WIDE("on_display_pause"),void,(void),__LINE__)
// static void OnDisplayResume( WIDE("") )( void )
	// OnDisplayResume is called on systems that allow the application to suspend its display.
	// Wake from sleep mode may also trigger such an event, allows application to restore saved state
   // a media player, for instance, may continue playing ( it might be good to wait just a little longer than 'now')
#define OnDisplayResume(name)	 __DefineRegistryMethod(WIDE("sack/render/android"),OnDisplayResume,WIDE("display"),name,WIDE("on_display_resume"),void,(void),__LINE__)
	struct display_app;
	struct display_app_local;
	// static void OnDisplayConnect( WIDE("") )( struct display_app*app, struct display_app_local ***pppLocal )
	//  app is a unique handle to the display instance.  Can be used as a key to locate resources for the display
	//  pppLocal is ... ugly.
	//  ThreadLocal struct instance_local *_thread_local;
	//  static void OnDisplayConnect( WIDE("") )( struct display_app*app, struct display_app_local ***pppLocal )
	//  {
	//	    _thread_local = New( struct instance_local );
	//      MemSet( option_thread, 0, sizeof( option_thread ) );
	//      (*local) = (struct display_app_local**)&option_thread;
	//       //... init local here
	//  }
	//
#define OnDisplayConnect(name)	 __DefineRegistryMethod(WIDE("/sack/render/remote display"),OnDisplayConnect,WIDE("connect"),name,WIDE("new_display_connect"),void,(struct display_app*app, struct display_app_local ***),__LINE__)
	// unimplemented.
#define OnDisplayConnected(name)	 __DefineRegistryMethod(WIDE("/sack/render/remote display"),OnDisplayConnect,WIDE("connect"),name,WIDE("new_display_connected"),void,(struct display_app*app),__LINE__)
RENDER_NAMESPACE_END
#ifdef __cplusplus
#ifdef _D3D_DRIVER
	using namespace sack::image::render::d3d;
#elif defined( _D3D10_DRIVER )
	using namespace sack::image::render::d3d10;
#elif defined( _D3D11_DRIVER )
	using namespace sack::image::render::d3d11;
#else
	using namespace sack::image::render;
#endif
#endif
#endif
// : $
// $Log: render.h,v $
// Revision 1.48  2005/05/25 16:50:09  d3x0r
// Synch with working repository.
//
// Revision 1.10  2003/03/25 08:38:11  panther
// Add logging
//
#ifndef _SHARED_MEMORY_LIBRARY
#if !defined( MEMORY_STRUCT_DEFINED ) || defined( DEFINE_MEMORY_STRUCT )
//#define ENABLE_NATIVE_MALLOC_PROTECTOR
#ifdef _DEBUG
#  define USE_DEBUG_LOGGING 1
#else
#  define USE_DEBUG_LOGGING 0
#endif
#define MEMORY_STRUCT_DEFINED
#ifdef _DEBUG
//  Define this symbol in SHAREMEM.H!
// if you define it here it will not work as expected...
//// defined in sharemem.h #define DEBUG_CRITICAL_SECTIONS
//// defined in sharemem.h #define LOG_DEBUG_CRITICAL_SECTIONS
#endif
#define _SHARED_MEMORY_LIBRARY
#ifdef __cplusplus
namespace sack {
	namespace timers {
#endif
// bit set on dwLocks when someone hit it and it was locked
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
#define SECTION_LOGGED_WAIT 0x80000000
#define AND_NOT_SECTION_LOGGED_WAIT(n) ((n)&(~SECTION_LOGGED_WAIT))
#define AND_SECTION_LOGGED_WAIT(n) ((n)&(SECTION_LOGGED_WAIT))
#else
#define SECTION_LOGGED_WAIT 0
#define AND_NOT_SECTION_LOGGED_WAIT(n) (n)
#define AND_SECTION_LOGGED_WAIT(n) (0)
#endif
// If you change this structure please change the public
// reference of this structure, and please, do hand-count
// the bytes to set there... so not include this file
// to get the size.  The size there should be the worst
// case - debug or release mode.
#ifdef NO_PRIVATE_DEF
struct critical_section_tag {
 // this is set when entering or leaving (updating)...
	volatile uint32_t dwUpdating;
	volatile uint32_t dwLocks;
 // windows upper 16 is process ID, lower is thread ID
	THREAD_ID dwThreadID;
 // ID of thread waiting for this..
	THREAD_ID dwThreadWaiting;
	//PDATAQUEUE pPriorWaiters;
#ifdef DEBUG_CRITICAL_SECTIONS
	uint32_t bCollisions ;
	CTEXTSTR pFile;
	uint32_t  nLine;
#endif
};
typedef struct critical_section_tag CRITICALSECTION;
#endif
#ifdef __cplusplus
	};
};
#endif
#ifdef __cplusplus
namespace sack {
	namespace memory {
		using namespace sack::timers;
#endif
// pFile, nLine has been removed from this
// the references for this info are now
// stored at the end of the block
		// after the 0x12345678 tag.
#  ifdef _MSC_VER
#    pragma pack (push, 1)
#  endif
// custom allocer, use heap_chunk_tag
PREFIX_PACKED struct malloc_chunk_tag
{
   // if 0 - block is free
	uint16_t dwOwners;
      // extra bytes 4/12 typical, sometimes pad untill next. (alignment extra bytes)
	uint16_t dwPad;
#ifdef __64__
	uint32_t pad;
#endif
  // limited to allocating 4 billion bytes...
	uintptr_t dwSize;
#ifdef ENABLE_NATIVE_MALLOC_PROTECTOR
	uint32_t LeadProtect[2];
#endif
 // this is additional to subtract to get back to start (aligned allocate)
	uint16_t alignment;
 // this is additional to subtract to get back to start (aligned allocate)
	uint16_t to_chunk_start;
 // uint8_t is the smallest valid datatype could be _0
	uint8_t byData[1];
} PACKED;
PREFIX_PACKED struct heap_chunk_tag
{
            // if 0 - block is free
	uint16_t dwOwners;
   // extra bytes 4/12 typical, sometimes pad untill next.
	uint16_t dwPad;
	// which is < ( CHUNK_SIZE + nMinAllocate )
	// real size is then dwSize - dwPad.
	// this is actually where the end of block tag(s) should begin!
  // limited to allocating 4 billion bytes...
	uintptr_t dwSize;
         // save some math backwards...
	struct heap_chunk_tag *pPrior;
  // pointer to master allocation struct (pMEM)
	struct memory_block_tag * pRoot;
	DeclareLink( struct heap_chunk_tag );
 // this is additional to subtract to get back to start (aligned allocate)
	uint16_t alignment;
 // this is additional to subtract to get back to start (aligned allocate)
	uint16_t to_chunk_start;
 // uint8_t is the smallest valid datatype could be _0
	uint8_t byData[1];
} PACKED;
// a chunk of memory in a heap space, heaps are also tracked, so extents
// of that space are known, therefore one can identify a heap chunk
// from a non-heap (malloc?) chunk.
typedef PREFIX_PACKED struct heap_chunk_tag HEAP_CHUNK, *PHEAP_CHUNK;
// CHUNK and HEAP_CHUNK are the same.  They were not the same when using an
// ifdef to separate custom allocation from malloc allocation.  HeapAllocate
// could still be passed a heap before, and would be able to allocate from it.
typedef PREFIX_PACKED struct heap_chunk_tag CHUNK, *PCHUNK;
typedef PREFIX_PACKED struct malloc_chunk_tag MALLOC_CHUNK, *PMALLOC_CHUNK;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
// chunks allocated have no debug information.
#define HEAP_FLAG_NO_DEBUG 0x0001
struct memory_block_tag
{
	uintptr_t dwSize;
 // unique value 0xbab1f1ea (baby flea);
	uint32_t dwHeapID;
	// lock between multiple processes/threads
	CRITICALSECTION cs;
	uint32_t dwFlags;
	PHEAP_CHUNK pFirstFree;
	HEAP_CHUNK pRoot[1];
};
typedef struct memory_block_tag MEM;
#ifdef __cplusplus
	};
};
#endif
#endif
#endif
#ifdef __cplusplus
namespace sack {
	namespace timers {
		using namespace sack::containers;
		using namespace sack::memory;
		using namespace sack::logging;
#endif
//#define LOG_CREATE_EVENT_OBJECT
//#define LOG_THREAD
//#define LOG_SLEEPS
// - define this to log when timers were delayed in scheduling...
//198#define LOG_LATENCY_LIGHT
//#define LOG_LATENCY
//#define LOG_INSERTS
//#define LOG_DISPATCH
//#define DEBUG_PIPE_USAGE
typedef struct thread_event THREAD_EVENT;
typedef struct thread_event *PTHREAD_EVENT;
struct timer_tag
{
// putting next as first thing in structure
   // allows me to reference also prior
	struct timer_tag *next;
	union {
		struct timer_tag **me;
		struct timer_tag *prior;
	};
	struct {
		BIT_FIELD bRescheduled : 1;
	} flags;
	uint32_t frequency;
	int32_t delta;
	uint32_t ID;
	void (CPROC*callback)(uintptr_t user);
	uintptr_t userdata;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
	CTEXTSTR pFile;
	int nLine;
#endif
};
typedef struct timer_tag TIMER, *PTIMER;
#define MAXTIMERSPERSET 32
DeclareSet( TIMER );
struct threads_tag
{
	// these first two items MUST
	// be declared publically, and MUST be visible
	// to the thread created.
	uintptr_t param;
	uintptr_t (CPROC*proc)( struct threads_tag * );
	uintptr_t (CPROC*simple_proc)( POINTER );
 // might be not a real thread.
	TEXTSTR thread_event_name;
	THREAD_ID thread_ident;
	PTHREAD_EVENT thread_event;
#ifdef _WIN32
	//HANDLE hEvent;
	HANDLE hThread;
#else
#ifdef USE_PIPE_SEMS
 // file handles that are the pipe's ends. 0=read 1=write
	int pipe_ends[2];
#endif
 // use this as a status of pipes if USE_PIPE_SEMS is used...; otherwise it's a ipcsem
	int semaphore;
	pthread_t hThread;
#endif
	struct {
		//BIT_FIELD bLock : 1;
		//BIT_FIELD bSleeping : 1;
		//BIT_FIELD bWakeWhileRunning : 1;
		BIT_FIELD bRemovedWhileRunning : 1;
		BIT_FIELD bLocal : 1;
		BIT_FIELD bReady : 1;
		BIT_FIELD bStarted : 1;
	} flags;
	//struct threads_tag *next, **me;
	CTEXTSTR pFile;
	uint32_t nLine;
};
typedef struct threads_tag THREAD;
#define MAXTHREADSPERSET 16
DeclareSet( THREAD );
struct thread_event
{
	TEXTSTR name;
#ifdef _WIN32
	HANDLE hEvent;
#endif
};
static struct {
	uint32_t timerID;
	PTIMERSET timer_pool;
	PTIMER timers;
 // this timer is scheduled to be added...
	PTIMER add_timer;
	PTIMER current_timer;
	struct {
		BIT_FIELD away_in_timer : 1;
		BIT_FIELD insert_while_away : 1;
		BIT_FIELD set_timer_signal : 1;
		BIT_FIELD bExited : 1;
#ifdef ENABLE_CRITICALSEC_LOGGING
		BIT_FIELD bLogCriticalSections : 1;
#endif
		BIT_FIELD bLogSleeps : 1;
		BIT_FIELD bLogTimerDispatch : 1;
		BIT_FIELD bLogThreadCreate : 1;
		BIT_FIELD bHaltTimers : 1;
	} flags;
 // this timer is scheduled to be removed...
	uint32_t del_timer;
 // should somehow end up equating to sleep overhead...
	uint32_t tick_bias;
 // last known time that a timer could have fired...
	uint32_t last_tick;
 // the current moment up to which we fire all timers.
	uint32_t this_tick;
	PTHREAD pTimerThread;
	PTHREADSET threadset;
	PTHREAD threads;
	uint32_t lock_timers;
	CRITICALSECTION cs_timer_change;
	//uint32_t pending_timer_change;
	uint32_t remove_timer;
	uint32_t CurrentTimerID;
	int32_t last_sleep;
#define globalTimerData (*global_timer_structure)
	uintptr_t lock_thread_create;
	// should be a short list... 10 maybe 15...
	PLIST thread_events;
	CRITICALSECTION csGrab;
#if defined( WIN32 )
	DWORD my_thread_info_tls;
#elif defined( __LINUX__ )
	pthread_key_t my_thread_info_tls;
#endif
// = { 1000 };
} *global_timer_structure;
#if HAS_TLS
struct my_thread_info {
	PTHREAD pThread;
	THREAD_ID nThread;
};
#define MyThreadInfo (*_MyThreadInfo)
#endif
#ifdef _WIN32
#else
//#include <sys/ipc.h>
	 // hmm wonder why this has to be defined....
	 // semtimedop is a wonderful wonderful thing...
	 // but yet /usr/include/sys/sem.h only defines it if
// __USE_GNU is defined....
#ifndef __USE_GNU
#define __USE_GNU
#endif
#ifdef __ANDROID__
#include <linux/sem.h>
#else
#include <sys/sem.h>
#endif
#endif
void  RemoveTimerEx( uint32_t ID DBG_PASS );
static struct my_thread_info* GetThreadTLS( void )
{
	struct my_thread_info* _MyThreadInfo;
#if defined( WIN32 )
	if( !global_timer_structure )
		SimpleRegisterAndCreateGlobal( global_timer_structure );
	if( !( _MyThreadInfo = (struct my_thread_info*)TlsGetValue( global_timer_structure->my_thread_info_tls ) ) )
	{
		int old = SetAllocateLogging( FALSE );
		TlsSetValue( global_timer_structure->my_thread_info_tls, _MyThreadInfo = New( struct my_thread_info ) );
		SetAllocateLogging( old );
		_MyThreadInfo->nThread = 0;
		_MyThreadInfo->pThread = 0;
	}
#elif defined( __LINUX__ )
	if( !( _MyThreadInfo = (struct my_thread_info*)pthread_getspecific( global_timer_structure->my_thread_info_tls ) ) )
	{
		pthread_setspecific( global_timer_structure->my_thread_info_tls, _MyThreadInfo = New( struct my_thread_info ) );
		_MyThreadInfo->nThread = 0;
		_MyThreadInfo->pThread = 0;
	}
#endif
	return _MyThreadInfo;
}
// this priorirty is also relative to a secondary init for procreg/names.c
// if you change this, need to change when that is scheduled also
PRIORITY_PRELOAD( LowLevelInit, CONFIG_SCRIPT_PRELOAD_PRIORITY-1 )
{
	// there is a small chance the local is already initialized.
	if( !global_timer_structure )
		SimpleRegisterAndCreateGlobal( global_timer_structure );
	if( !globalTimerData.timerID )
	{
#if defined( WIN32 )
		globalTimerData.my_thread_info_tls = TlsAlloc();
#elif defined( __LINUX__ )
		pthread_key_create( &globalTimerData.my_thread_info_tls, NULL );
#endif
		InitializeCriticalSec( &globalTimerData.csGrab );
		// this may have initialized early?
		globalTimerData.timerID = 1000;
		//lprintf( "thread global will be %p %p", global_timer_structure, &global_timer_structure );
	}
}
PRELOAD( ConfigureTimers )
{
#ifndef __NO_OPTIONS__
#  ifdef ENABLE_CRITICALSEC_LOGGING
	globalTimerData.flags.bLogCriticalSections = SACK_GetProfileInt( GetProgramName(), WIDE( "SACK/Memory Library/Log critical sections" ), 0 );
#  endif
	globalTimerData.flags.bLogThreadCreate = SACK_GetProfileInt( GetProgramName(), WIDE( "SACK/Timers/Log Thread Create" ), 0 );
	globalTimerData.flags.bLogSleeps = SACK_GetProfileInt( GetProgramName(), WIDE( "SACK/Timers/Log Sleeps" ), 0 );
	globalTimerData.flags.bLogTimerDispatch = SACK_GetProfileInt( GetProgramName(), WIDE( "SACK/Timers/Log Timer Dispatch" ), 0 );
#endif
}
//--------------------------------------------------------------------------
#ifdef __LINUX__
#ifdef __LINUX__
uint32_t  GetTickCount( void )
{
	struct timeval time;
	gettimeofday( &time, 0 );
	return (time.tv_sec * 1000) + (time.tv_usec / 1000);
}
uint32_t  timeGetTime( void )
{
	struct timeval time;
	gettimeofday( &time, 0 );
	return (time.tv_sec * 1000) + (time.tv_usec / 1000);
}
void  Sleep( uint32_t ms )
{
	(usleep((ms)*1000));
}
#endif
uintptr_t closesem( POINTER p, uintptr_t psv )
{
	PTHREAD thread = (PTHREAD)p;
#ifdef USE_PIPE_SEMS
	//lprintf( "CLOSE PIPES %s %"_64fx, thread->thread_event_name, thread->thread_ident );
	close( thread->pipe_ends[0] );
	close( thread->pipe_ends[1] );
	thread->pipe_ends[0] = -1;
	thread->pipe_ends[1] = -1;
	thread->semaphore = -1;
#else
	if( semctl( thread->semaphore, 0, IPC_RMID ) == -1 )
	{
		lprintf( WIDE( "Error: %08x %s" ), thread->semaphore, strerror( errno ) );
	}
	thread->semaphore = -1;
#endif
	return 0;
}
static uintptr_t threadrunning( POINTER p, uintptr_t psv )
{
	PTHREAD thread = (PTHREAD)p;
	if( thread->hThread && thread->flags.bStarted )
		return 1;
	return 0;
}
// sharemem exit priority +1 (exit after everything else, except emmory; globals at memory+1)
PRIORITY_ATEXIT( CloseAllWakeups, ATEXIT_PRIORITY_THREAD_SEMS )
{
	//pid_t mypid = getppid();
	// not sure if mypid is needed...
	while( ForAllInSet( THREAD, globalTimerData.threadset, threadrunning, 0 ) )
		Relinquish();
	lprintf( WIDE("Destroy thread semaphores...") );
	ForAllInSet( THREAD, globalTimerData.threadset, closesem, (uintptr_t)0 );
	DeleteSet( (GENERICSET**)&globalTimerData.threadset );
	globalTimerData.pTimerThread = NULL;
	//globalTimerData.threads = NULL;
	globalTimerData.timers = NULL;
}
#endif
// sharemem exit priority +1 (exit after everything else, except emmory)
PRIORITY_ATEXIT( StopTimers, ATEXIT_PRIORITY_TIMERS )
{
	int tries = 0;
	//pid_t mypid = getppid();
	// not sure if mypid is needed...
	if( global_timer_structure ) {
		globalTimerData.flags.bExited = 1;
		if( globalTimerData.pTimerThread )
			WakeThread( globalTimerData.pTimerThread );
		while( globalTimerData.pTimerThread )
		{
			tries++;
			if( tries > 10 )
				return;
			WakeThread( globalTimerData.pTimerThread );
			Relinquish();
		}
	}
}
//--------------------------------------------------------------------------
static void InitWakeup( PTHREAD thread, CTEXTSTR event_name )
{
	if( !event_name )
		event_name = WIDE("ThreadSignal");
	thread->thread_event_name = StrDup( event_name );
#ifdef _WIN32
	if( !thread->thread_event )
	{
		PTHREAD_EVENT thread_event;
		TEXTCHAR name[64];
		tnprintf( name, 64, WIDE("%s:%08lX:%08lX"), event_name, (uint32_t)(thread->thread_ident >> 32)
		        , (uint32_t)(thread->thread_ident & 0xFFFFFFFF) );
		name[sizeof(name)/sizeof(name[0])-1] = 0;
#ifdef LOG_CREATE_EVENT_OBJECT
		lprintf( WIDE("Thread Event created is: %s everyone should use this..."), name );
#endif
		thread_event = New( THREAD_EVENT );
		thread_event->name = StrDup( name );
		thread_event->hEvent = CreateEvent( NULL, TRUE, FALSE, name );
		AddLink( &globalTimerData.thread_events, thread_event );
		thread->thread_event = thread_event;
	}
#else
#ifdef USE_PIPE_SEMS
	// store status of pipe() in semaphore... it's not really a semaphore..
#  ifdef DEBUG_PIPE_USAGE
	lprintf( "Init wakeup %p %s", thread, event_name );
#  endif
	if( ( thread->semaphore = pipe( thread->pipe_ends ) )  == -1 )
	{
		lprintf( WIDE("Failed to get pipe! %d:%s"), errno, strerror( errno ) );
	}
	else
	{
		char buf;
		int success = 0;
		do
		{
			int stat;
			int n;
			fd_set set;
			struct timeval timeout;
			FD_ZERO(&set);
			FD_SET( thread->pipe_ends[0], &set);
			timeout.tv_sec = 0;
			timeout.tv_usec = 100;
#  ifdef DEBUG_PIPE_USAGE
			lprintf(" Begin select-flush on thread %p", thread );
#  endif
			stat = select(thread->pipe_ends[0] + 1, &set, NULL, NULL, &timeout);
			if(stat == -1)
			{
				lprintf( WIDE("select error %d %d"), errno, thread->pipe_ends[0]);
			}
			else if(stat == 0)
			{
				success = 1;
#  ifdef DEBUG_PIPE_USAGE
				lprintf("timeout");
#  endif
			}
			else
			{
#  ifdef DEBUG_PIPE_USAGE
				lprintf(" immediate return?" );
#  endif
				stat = read( thread->pipe_ends[0], &buf, 1 );
#  ifdef DEBUG_PIPE_USAGE
				lprintf( "Stat is now %d", stat );
#  endif
			}
		}
		while( !success );
	}
#else
	thread->semaphore = semget( IPC_PRIVATE
	                          , 1, IPC_CREAT | 0600 );
	if( thread->semaphore == -1 )
	{
		// basically this can't really happen....
		if( errno ==  EEXIST )
		{
			thread->semaphore = semget( IPC_PRIVATE
			                          , 1, 0 );
			if( thread->semaphore == -1 )
				lprintf( WIDE("FAILED TO CREATE SEMAPHORE! : %d"), errno );
		}
		if( errno == ENOSPC )
		{
			lprintf( WIDE("Hmm Need to cleanup some semaphore objects!!!") );
		}
		else
			lprintf( WIDE("Failed to get semaphore! %d"), errno );
	}
	if( thread->semaphore != -1 )
	{
		//union semun ctl;
		//ctl.val = 0;
		//lprintf( WIDE("Setting thread semaphore to 0 (locked).") );
		if( semctl( thread->semaphore, 0, SETVAL, 0 ) < 0 )
		{
			lprintf( WIDE("Errro setting semaphre value: %d"), errno );
		}
		//lprintf( WIDE("after semctl = %d %08lx"), semctl( thread->semaphore, 0, GETVAL ), thread->semaphore );
	}
#endif
#endif
}
//--------------------------------------------------------------------------
uintptr_t CPROC check_thread_name( POINTER p, uintptr_t psv )
{
	PTHREAD thread = (PTHREAD)p;
	if( StrCaseCmp( thread->thread_event_name, (CTEXTSTR)psv ) == 0 )
		return (uintptr_t)p;
	return 0;
}
static PTHREAD FindWakeup( CTEXTSTR name )
{
	PTHREAD check;
	if( global_timer_structure )
	{
		// don't need locks if init didn't finish, there's now way to have threads in loader lock.
		while( LockedExchangePtrSzVal( &globalTimerData.lock_thread_create, 1 ) )
			Relinquish();
	}
	else
	{
		if( IsRootDeadstartStarted() )
			SimpleRegisterAndCreateGlobal( global_timer_structure );
	}
	check = (PTHREAD)ForAllInSet( THREAD, globalTimerData.threadset, check_thread_name, (uintptr_t)name );
	if( !check )
	{
#ifdef _DEBUG
		//lprintf( DBG_FILELINEFMT "Failed to find the thread - so let's add it" );
#endif
		check = GetFromSet( THREAD, &globalTimerData.threadset );
		MemSet( check, 0, sizeof( THREAD ) );
		check->thread_ident = GetMyThreadID();
		InitWakeup( check, name );
		check->flags.bReady = 1;
	}
	globalTimerData.lock_thread_create = 0;
	return check;
}
//--------------------------------------------------------------------------
struct name_and_id_params
{
	CTEXTSTR name;
	THREAD_ID thread;
};
uintptr_t CPROC check_thread_name_and_id( POINTER p, uintptr_t psv )
{
	struct name_and_id_params *params = (struct name_and_id_params*)psv;
	PTHREAD thread = (PTHREAD)p;
	if( thread->thread_ident == params->thread
		&& StrCaseCmp( thread->thread_event_name, params->name ) == 0 )
		return (uintptr_t)p;
	return 0;
}
static PTHREAD FindThreadWakeup( CTEXTSTR name, THREAD_ID thread )
{
	PTHREAD check;
	struct name_and_id_params params;
	params.name = name;
	params.thread = thread;
	if( global_timer_structure )
	{
		// don't need locks if init didn't finish, there's now way to have threads in loader lock.
		while( LockedExchangePtrSzVal( &globalTimerData.lock_thread_create, 1 ) )
			Relinquish();
	}
	else
	{
		if( IsRootDeadstartStarted() )
			SimpleRegisterAndCreateGlobal( global_timer_structure );
	}
	check = (PTHREAD)ForAllInSet( THREAD, globalTimerData.threadset, check_thread_name_and_id, (uintptr_t)&params );
	if( !check )
	{
#ifdef _DEBUG
		//lprintf( DBG_FILELINEFMT "Failed to find the thread - so let's add it" );
#endif
		check = GetFromSet( THREAD, &globalTimerData.threadset );
		MemSet( check, 0, sizeof( THREAD ) );
		check->thread_ident = thread;
		InitWakeup( check, name );
		check->flags.bReady = 1;
	}
	globalTimerData.lock_thread_create = 0;
	return check;
}
//--------------------------------------------------------------------------
uintptr_t CPROC check_thread( POINTER p, uintptr_t psv )
{
	PTHREAD thread = (PTHREAD)p;
	THREAD_ID ID = *((THREAD_ID*)psv);
	//lprintf( "Check thread %016llx %016llx %s", thread->thread_ident, ID, thread->thread_event_name );
	if( ( thread->thread_ident == ID )
		&& ( StrCmp( thread->thread_event_name, WIDE("ThreadSignal") ) == 0 ) )
		return (uintptr_t)p;
	return 0;
}
static PTHREAD FindThread( THREAD_ID thread )
{
	PTHREAD check;
	if( global_timer_structure )
	{
		// don't need locks if init didn't finish, there's now way to have threads in loader lock.
		while( LockedExchangePtrSzVal( &globalTimerData.lock_thread_create, 1 ) )
			Relinquish();
	}
	else
	{
		if( IsRootDeadstartStarted() )
			SimpleRegisterAndCreateGlobal( global_timer_structure );
	}
	check = (PTHREAD)ForAllInSet( THREAD, globalTimerData.threadset, check_thread, (uintptr_t)&thread );
	if( !check )
	{
#ifdef _DEBUG
		//lprintf( DBG_FILELINEFMT "Failed to find the thread - so let's add it" );
#endif
		check = GetFromSet( THREAD, &globalTimerData.threadset );
		MemSet( check, 0, sizeof( THREAD ) );
		check->thread_ident = thread;
		InitWakeup( check, NULL );
		check->flags.bReady = 1;
	}
	globalTimerData.lock_thread_create = 0;
	return check;
}
//--------------------------------------------------------------------------
void  WakeThreadEx( PTHREAD thread DBG_PASS )
{
 // can't wake nothing
	if( !thread )
	{
		//_lprintf(DBG_RELAY)( WIDE("Failed to find thread to wake...") );
		return;
	}
	//_xlprintf( 0 DBG_RELAY )( WIDE("Waking a thread: %p"), thread );
	//while( thread->flags.bLock )
	//{
	//	Log( WIDE("Waiting for thread to go to sleep") );
	//	Relinquish();
	//}
	//if( thread->flags.bLocal && !thread->flags.bSleeping )
	//{
	//	//Log( WIDE("Waking thread which is already awake") );
	//  thread->flags.bWakeWhileRunning = 1;
	//  Relinquish(); // wake implies that we want the other thing to run.
	//  lprintf( DBG_FILELINEFMT "Thread is not sleeping... woke it before it slept" );
	//  return;
	//}
#ifdef _WIN32
	//	lprintf( WIDE("setting event.") );
	{
		PTHREAD_EVENT thread_event;
		INDEX idx;
		TEXTCHAR name[64];
		if( !(thread_event = thread->thread_event ) )
		{
			tnprintf( name, sizeof(name), WIDE("%s:%08lX:%08lX")
			        , thread->thread_event_name, (uint32_t)(thread->thread_ident >> 32)
			        , (uint32_t)(thread->thread_ident & 0xFFFFFFFF));
			name[sizeof(name)/sizeof(name[0])-1] = 0;
			LIST_FORALL( globalTimerData.thread_events, idx, PTHREAD_EVENT, thread_event )
			{
				if( StrCmp( thread_event->name, name ) == 0 )
					break;
			}
#ifdef LOG_CREATE_EVENT_OBJECT
			lprintf( WIDE("Event opened is: %s"), name );
#endif
		}
#ifdef LOG_CREATE_EVENT_OBJECT
		else
		{
			lprintf( WIDE("Event opened is thread.") );
		}
#endif
		if( !thread_event )
		{
			thread_event = New( THREAD_EVENT );
			thread_event->name = StrDup( name );
 /*EVENT_MODIFY_STATE */
			thread_event->hEvent = OpenEvent( EVENT_ALL_ACCESS, FALSE, name );
			AddLink( &globalTimerData.thread_events, thread_event );
			thread->thread_event = thread_event;
		}
		if( thread_event->hEvent )
		{
			//lprintf( WIDE("event opened successfully... %d"), WaitForSingleObject( hEvent, 0 ) );
#ifndef NO_LOGGING
			if( globalTimerData.flags.bLogSleeps )
				_xlprintf(1 DBG_RELAY )( WIDE("About to wake on %d Thread event created...%016llx")
				                       , thread->thread_event->hEvent
				                       , thread->thread_ident );
#endif
			if( !SetEvent( thread_event->hEvent ) )
				lprintf( WIDE("Set event FAILED..%d"), GetLastError() );
 // may or may not execute other thread before this...
			Relinquish();
		}
		else
		{
			lprintf( WIDE("Failed to open that event! %d"), GetLastError() );
			// thread to wake is not ready to be
			// woken, does not exist, or some other
			// BAD problem.
		}
	}
#else
#ifdef USE_PIPE_SEMS
	if( thread->semaphore != -1 )
	{
#  ifdef DEBUG_PIPE_USAGE
		_lprintf(DBG_RELAY)( "(wakethread)wil write pipe... %p", thread );
#  endif
		write( thread->pipe_ends[1], "G", 1 );
		//lprintf( "did write pipe..." );
		Relinquish();
	}
#else
	if( thread->semaphore != -1 )
	{
		int stat;
		int val;
		struct sembuf semdo;
		semdo.sem_num = 0;
		semdo.sem_op = 1;
		semdo.sem_flg = 0;
		//_xlprintf( 1 DBG_RELAY )( WIDE("Resetting event on %08x %016"_64fx"x"), thread->semaphore, thread->thread_ident );
		//lprintf( WIDE("Before semval = %d %08lx"), semctl( thread->semaphore, 0, GETVAL ), thread->semaphore );
		stat = semop( thread->semaphore, &semdo, 1 );
		if( stat == -1 )
		{
			if( errno != ERANGE )
				lprintf( WIDE("semop error (wake) : %d"), errno );
		}
		//lprintf( WIDE("After semval = %d %08lx"), val = semctl( thread->semaphore, 0, GETVAL ), thread->semaphore );
		if( !val )
		{
			//DebugBreak();
			//lprintf( WIDE("Did we fail the semop?!") );
		}
 // may or may not execute other thread before this...
		Relinquish();
	}
#endif
#  if 0
 // thread creation might not be complete yet...
	if( thread->thread )
	{
		pthread_kill( thread->thread, SIGUSR1 );
	}
#  endif
#endif
}
void  WakeNamedThreadSleeperEx( CTEXTSTR name, THREAD_ID thread DBG_PASS )
{
	PTHREAD sleeper = FindThreadWakeup( name, thread );
	if( sleeper )
		WakeThreadEx( sleeper DBG_RELAY );
}
void  WakeNamedSleeperEx( CTEXTSTR name DBG_PASS )
{
	PTHREAD sleeper = FindWakeup( name );
	if( sleeper )
		WakeThreadEx( sleeper DBG_RELAY );
}
//#undef WakeThread
//void  WakeThread( PTHREAD thread )
//{
//	WakeThreadEx( thread DBG_SRC );
//}
//--------------------------------------------------------------------------
void  WakeThreadIDEx( THREAD_ID thread DBG_PASS )
{
	PTHREAD pThread = FindThread( thread );
	WakeThreadEx( pThread DBG_RELAY );
}
//--------------------------------------------------------------------------
#undef WakeThreadID
void  WakeThreadID( THREAD_ID thread )
{
	WakeThreadIDEx( thread DBG_SRC );
}
//--------------------------------------------------------------------------
#ifdef _NO_SEMTIMEDOP_
#ifndef _WIN32
static void CPROC TimerWake( uintptr_t psv )
{
	WakeThreadEx( (PTHREAD)psv DBG_SRC );
}
#endif
#endif
//--------------------------------------------------------------------------
static void  InternalWakeableNamedSleepEx( CTEXTSTR name, uint32_t n, LOGICAL threaded DBG_PASS )
{
	PTHREAD pThread;
	if( name && threaded )
		pThread = FindThreadWakeup( name, GetMyThreadID() );
	else if( name )
		pThread = FindWakeup( name );
	else
	{
#ifdef HAS_TLS
		struct my_thread_info* _MyThreadInfo = GetThreadTLS();
		pThread = MyThreadInfo.pThread;
		//lprintf( "thread will be %p %p", pThread, &MyThreadInfo );
		//lprintf( "pthread is %p", pThread );
		if( !pThread )
		{
			//lprintf( WIDE("had to init thread...") );
			MakeThread();
			pThread = MyThreadInfo.pThread;
		}
#  ifdef DEBUG_PIPE_USAGE
		lprintf( "Sleeping on threadsignal... %p", pThread );
#  endif
#else
		pThread = FindThread( GetMyThreadID() );
#endif
	}
	if( pThread )
	{
#ifdef _WIN32
#ifndef NO_LOGGING
		if( globalTimerData.flags.bLogSleeps )
			_xlprintf(1 DBG_RELAY )( WIDE("About to sleep on %d Thread event created...%s:%016llx")
			                         , pThread->thread_event->hEvent
			                         , pThread->thread_event_name
			                         , pThread->thread_ident );
#endif
		if( WaitForSingleObject( pThread->thread_event->hEvent
		                       , n==SLEEP_FOREVER?INFINITE:(n) ) != WAIT_TIMEOUT )
		{
#ifdef LOG_LATENCY
			_lprintf(DBG_RELAY)( WIDE("Woke up- reset event") );
#endif
			ResetEvent( pThread->thread_event->hEvent );
			//if( n == SLEEP_FOREVER )
			//   DebugBreak();
		}
#ifdef LOG_LATENCY
		else
			_lprintf(DBG_RELAY)( WIDE("Timed out from %d"), n );
#endif
#else
		{
#ifndef USE_PIPE_SEMS
#ifdef _NO_SEMTIMEDOP_
			int nTimer = 0;
			if( n != SLEEP_FOREVER )
			{
				//lprintf( WIDE("Wakeable sleep in %ld (oneshot, no frequency)"), n );
				nTimer = AddTimerExx( n, 0, TimerWake, (uintptr_t)pThread DBG_RELAY );
			}
#endif
#endif
			if( pThread->semaphore == -1 )
			{
				//lprintf( WIDE("Invalid semaphore...fixing?") );
				InitWakeup( pThread, name );
			}
			if( pThread->semaphore != -1 )
			{
#ifdef USE_PIPE_SEMS
#else
				struct sembuf semdo[2];
				semdo[0].sem_num = 0;
				semdo[0].sem_op = -1;
				semdo[0].sem_flg = 0;
#endif
				while(1)
				{
					int stat;
					//lprintf( WIDE("Lock on semop on semdo... %08x %016"_64fx"x"), pThread->semaphore, pThread->thread_ident );
					//lprintf( WIDE("Before semval = %d %08lx"), semctl( pThread->semaphore, 0, GETVAL ), pThread->semaphore );
					if( n != SLEEP_FOREVER )
					{
#ifdef USE_PIPE_SEMS
						char buf;
						{
							fd_set set;
							struct timeval timeout;
							FD_ZERO(&set);
							FD_SET( pThread->pipe_ends[0], &set);
							timeout.tv_sec = n / 1000;
							timeout.tv_usec = ( n % 1000 ) * 1000;
#  ifdef DEBUG_PIPE_USAGE
							lprintf(" Begin select-read on thread %p %d ", pThread, n );
							//_lprintf(DBG_RELAY)( "Select  %p %d  %d  %d", pThread, pThread->pipe_ends[0], pThread->pipe_ends[1],n );
#  endif
							stat = select(pThread->pipe_ends[0] + 1, &set, NULL, NULL, &timeout);
							if(stat == -1)
							{
								lprintf(WIDE("select error %d %d"), errno, pThread->pipe_ends[0]);
							}
							else if(stat == 0)
							{
#  ifdef DEBUG_PIPE_USAGE
								lprintf("timeout");
#  endif
							}
							else
							{
#  ifdef DEBUG_PIPE_USAGE
								lprintf(" immediate return?" );
#  endif
								stat = read( pThread->pipe_ends[0], &buf, 1 );
								// 1 = success
								// -1 will be an error (errno handled later)
								// 0 would be end of file...
#  ifdef DEBUG_PIPE_USAGE
								lprintf( "Stat is now %d", stat );
#endif
							}
						}
#  ifdef DEBUG_PIPE_USAGE
						lprintf( "end read" );
#  endif
#else
# ifdef _NO_SEMTIMEDOP_
						stat = semop( pThread->semaphore, semdo, 1 );
# else
						struct timespec timeout;
						timeout.tv_nsec = ( n % 1000 ) * 1000000L;
						timeout.tv_sec = n / 1000;
						stat = semtimedop( pThread->semaphore, semdo, 1, &timeout );
# endif
#endif
					}
					else
					{
#ifdef USE_PIPE_SEMS
						char buf;
#  ifdef DEBUG_PIPE_USAGE
						_lprintf(DBG_RELAY)(" Begin read on thread %p", pThread );
#  endif
						stat = read( pThread->pipe_ends[0], &buf, 1 );
#  ifdef DEBUG_PIPE_USAGE
						lprintf( "end read" );
#  endif
#else
						stat = semop( pThread->semaphore, semdo, 1 );
#endif
					}
					//lprintf( WIDE("After semval = %d %08lx"), semctl( pThread->semaphore, 0, GETVAL ), pThread->semaphore );
					//lprintf( WIDE("Lock passed.") );
					if( stat < 0 )
					{
						if( errno == EINTR )
						{
							//lprintf( WIDE("EINTR") );
							break;
							//continue;
						}
						if( errno == EAGAIN )
						{
							//lprintf( WIDE("EAGAIN?") );
							// timeout elapsed on semtimedop - or IPC_NOWAIT was specified
							// but since it's not, it must be the timeout condition.
							break;
						}
						if( errno == EIDRM )
						{
							lprintf( WIDE("Semaphore has been removed on us!?") );
							pThread->semaphore = -1;
							break;
						}
						if( errno == EINVAL )
						{
							lprintf( WIDE("Semaphore is no longer valid on this thread object... %d")
							       , pThread->semaphore );
							// this probably means that it has gone away..
							pThread->semaphore = -1;
							break;
						}
						lprintf( WIDE("stat from sempop on thread semaphore %p = %d (%d)")
						       , pThread
						       , stat
						       , stat<0?errno:0 );
						break;
					}
					else
					{
						// reset semaphore to nothing.... might
						// have been woken up MANY times.
							//lprintf( WIDE("Resetting our lock count from %d to 0....")
						//		 , semctl( pThread->semaphore, 0, GETVAL ));
#ifdef USE_PIPE_SEMS
						// flush? empty the pipe?
#else
						semctl( pThread->semaphore, 0, SETVAL, 0 );
#endif
						break;
					}
				}
			}
			else
			{
				lprintf( WIDE("Still an invalid semaphore? Dang.") );
				fprintf( stderr, WIDE("Out of semaphores.") );
				BAG_Exit(0);
			}
		}
#endif
		//pThread->flags.bSleeping = 0;
	}
	else
	{
		lprintf( WIDE("You, as a thread, do not exist, sorry.") );
	}
}
#ifdef USE_PIPE_SEMS
int GetThreadSleeper( PTHREAD thread )
{
	return thread->pipe_ends[0];
}
#endif
void  WakeableNamedThreadSleepEx( CTEXTSTR name, uint32_t n DBG_PASS )
{
	InternalWakeableNamedSleepEx( name, n, TRUE DBG_RELAY );
}
void  WakeableNamedSleepEx( CTEXTSTR name, uint32_t n DBG_PASS )
{
	InternalWakeableNamedSleepEx( name, n, FALSE DBG_RELAY );
}
void  WakeableSleepEx( uint32_t n DBG_PASS )
{
	InternalWakeableNamedSleepEx( NULL, n, FALSE DBG_RELAY );
}
#undef WakeableSleep
void  WakeableSleep( uint32_t n )
#define WakeableSleep(n) WakeableSleepEx(n DBG_SRC)
{
	WakeableSleepEx(n DBG_SRC);
}
//--------------------------------------------------------------------------
#ifdef __LINUX__
static void ContinueSignal( int sig )
{
	lprintf( WIDE("Sigusr1") );
}
// network is at GLOBAL_INIT_PRIORITY
PRIORITY_PRELOAD( IgnoreSignalContinue, GLOBAL_INIT_PRELOAD_PRIORITY-1 )
{
	//lprintf( "register handler for sigusr1" );
#if defined __ANDROID_OLD_PLATFORM_SUPPORT__
	bsd_signal( SIGUSR1, ContinueSignal );
#else
	signal( SIGUSR1, ContinueSignal );
#endif
}
static void AlarmSignal( int sig )
{
	//lprintf( "Received alarm" );
	WakeThread( globalTimerData.pTimerThread );
}
static void TimerWakeableSleep( uint32_t n )
{
	if( globalTimerData.pTimerThread )
	{
#ifndef USE_PIPE_SEMS
		if( !globalTimerData.flags.set_timer_signal )
		{
#  if defined __ANDROID_OLD_PLATFORM_SUPPORT__
			bsd_signal( SIGALRM, AlarmSignal );
#  else
			signal( SIGALRM, AlarmSignal );
#  endif
			globalTimerData.flags.set_timer_signal = 1;
		}
		if( n != SLEEP_FOREVER )
		{
			struct itimerval val;
			//lprintf( WIDE("Wakeable sleep in %") _32f WIDE(""), n );
			val.it_value.tv_sec = n / 1000;
			val.it_value.tv_usec = (n % 1000) * 1000;
			val.it_interval.tv_sec = 0;
			val.it_interval.tv_usec = 0;
			//lprintf( "setitimer %d %d", val.it_value.tv_sec, val.it_value.tv_usec );
			setitimer( ITIMER_REAL, &val, NULL );
		}
#endif
		if( globalTimerData.pTimerThread && globalTimerData.pTimerThread->semaphore != -1 )
		{
#ifdef USE_PIPE_SEMS
			InternalWakeableNamedSleepEx( NULL, n, FALSE DBG_SRC );
#else
			struct sembuf semdo;
			semdo.sem_num = 0;
			semdo.sem_op = -1;
			semdo.sem_flg = 0;
			//lprintf( WIDE("Before semval = %d %08lx")
			//		 , semctl( globalTimerData.pTimerThread->semaphore, 0, GETVAL )
			//		 , globalTimerData.pTimerThread->semaphore );
			while( semop( globalTimerData.pTimerThread->semaphore, &semdo, 1 ) < 0 )
			{
				if( !globalTimerData.pTimerThread )
					return;
				if( errno == EIDRM )
				{
 // closed.
					globalTimerData.pTimerThread->semaphore = -1;
					return;
				}
				//lprintf( WIDE("Before semval = %d"), semctl( globalTimerData.pTimerThread->semaphore, 0, GETVAL ) );
				if( errno == EINTR )
				{
					//lprintf( WIDE("Before semval = %d"), semctl( globalTimerData.pTimerThread->semaphore, 0, GETVAL ) );
					continue;
				}
				else
				{
					lprintf( WIDE("Semop failed: %d %08x"), errno, globalTimerData.pTimerThread->semaphore );
					break;
				}
			}
#endif
			//lprintf( WIDE("After semval = %d %08lx")
			//	      , semctl( globalTimerData.pTimerThread->semaphore, 0, GETVAL )
			//       , globalTimerData.pTimerThread->semaphore );
		}
	}
}
#endif
//--------------------------------------------------------------------------
uintptr_t CPROC ThreadProc( PTHREAD pThread );
// results if the timer
int  IsThisThreadEx( PTHREAD pThreadTest DBG_PASS )
{
	PTHREAD pThread;
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
	pThread
#ifdef HAS_TLS
		= MyThreadInfo.pThread;
#else
		= FindThread( GetMyThreadID() );
#endif
//   lprintf( WIDE("Found thread; %p is it %p?"), pThread, pThreadTest );
	if( pThread == pThreadTest )
		return TRUE;
	//lprintf( WIDE("Found thread; %p is not  %p?"), pThread, pThreadTest );
	return FALSE;
}
static int NotTimerThread( void )
{
	PTHREAD pThread;
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
	pThread
#ifdef HAS_TLS
		= MyThreadInfo.pThread;
#else
		= FindThread( GetMyThreadID() );
#endif
	if( pThread && ( pThread->proc == ThreadProc ) )
		return FALSE;
	return TRUE;
}
//--------------------------------------------------------------------------
void  UnmakeThread( void )
{
	PTHREAD pThread;
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
	while( LockedExchangePtrSzVal( &globalTimerData.lock_thread_create, (uintptr_t)_MyThreadInfo->nThread ) )
		Relinquish();
	pThread
#ifdef HAS_TLS
		= MyThreadInfo.pThread;
#else
		= FindThread( GetMyThreadID() );
#endif
	if( pThread )
	{
		// unlink from globalTimerData.threads list.
		//if( ( (*pThread->me)=pThread->next ) )
		//	pThread->next->me = pThread->me;
		{
			int tmp = SetAllocateLogging( FALSE );
#ifdef _WIN32
			//lprintf( WIDE("Unmaking thread event! on thread %016"_64fx"x"), pThread->thread_ident );
			CloseHandle( pThread->thread_event->hEvent );
			{
				struct my_thread_info* _MyThreadInfo = GetThreadTLS();
				Deallocate( struct my_thread_info*, _MyThreadInfo );
				TlsSetValue( global_timer_structure->my_thread_info_tls, NULL );
			}
#else
			closesem( (POINTER)pThread, 0 );
#endif
			Deallocate( TEXTSTR, pThread->thread_event_name );
#ifdef _WIN32
			Deallocate( TEXTSTR, pThread->thread_event->name );
			if( global_timer_structure )
				DeleteLink( &globalTimerData.thread_events, pThread->thread_event );
			Deallocate( PTHREAD_EVENT, pThread->thread_event );
#endif
			if( global_timer_structure )
 /*Release( pThread )*/
				DeleteFromSet( THREAD, globalTimerData.threadset, pThread );
			SetAllocateLogging( tmp );
		}
	}
	globalTimerData.lock_thread_create = 0;
}
//--------------------------------------------------------------------------
#ifdef __WATCOMC__
static void *ThreadWrapper( PTHREAD pThread )
#else
static uintptr_t CPROC ThreadWrapper( PTHREAD pThread )
#endif
{
	uintptr_t result = 0;
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
#ifdef __LINUX__
	//lprintf( "register handler for sigusr1 (for thread)" );
#  if defined __ANDROID_OLD_PLATFORM_SUPPORT__
	bsd_signal( SIGUSR1, ContinueSignal );
#  else
	signal( SIGUSR1, ContinueSignal );
#  endif
#endif
#ifdef _WIN32
	while( !pThread->hThread )
		Relinquish();
#endif
	pThread->flags.bStarted = 1;
	//DeAttachThreadToLibraries( TRUE );
	while( !pThread->flags.bReady )
		Relinquish();
#ifdef HAS_TLS
#  ifdef LOG_THREAD
	lprintf( "thread will be %p %p", MyThreadInfo.pThread, &MyThreadInfo );
	lprintf( "thread will be %p %p", pThread, &MyThreadInfo.pThread );
#  endif
	MyThreadInfo.pThread = pThread;
	MyThreadInfo.nThread =
#endif
		pThread->thread_ident = _GetMyThreadID();
	//DebugBreak();
	InitWakeup( pThread, NULL );
#ifdef LOG_THREAD
	Log1( WIDE("Set thread ident: %016"_64fx""), pThread->thread_ident );
#endif
	if( pThread->proc )
		result = pThread->proc( pThread );
	//lprintf( WIDE("%s(%d):Thread is exiting... "), pThread->pFile, pThread->nLine );
	//DeAttachThreadToLibraries( FALSE );
	UnmakeThread();
#ifdef __LINUX__
	pThread->hThread = 0;
#else
	pThread->hThread = NULL;
#endif
	//lprintf( WIDE("%s(%d):Thread is exiting... "), pThread->pFile, pThread->nLine );
#ifdef __WATCOMC__
	return (void*)result;
#else
	return result;
#endif
}
//--------------------------------------------------------------------------
#ifdef __WATCOMC__
static void *SimpleThreadWrapper( PTHREAD pThread )
#else
static uintptr_t CPROC SimpleThreadWrapper( PTHREAD pThread )
#endif
{
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
	uintptr_t result = 0;
#ifdef _WIN32
	while( !pThread->hThread )
	{
		Log( WIDE("wait for main thread to process...") );
		Relinquish();
	}
#endif
	pThread->flags.bStarted = 1;
	while( !pThread->flags.bReady )
		Relinquish();
#ifdef HAS_TLS
	MyThreadInfo.pThread = pThread;
	MyThreadInfo.nThread =
#endif
		pThread->thread_ident = GetMyThreadID();
	InitWakeup( pThread, NULL );
#ifdef LOG_THREAD
	Log1( WIDE("Set thread ident: %016") _64fx, pThread->thread_ident );
#endif
	if( pThread->proc )
		result = pThread->simple_proc( (POINTER)GetThreadParam( pThread ) );
	//lprintf( WIDE("%s(%d):Thread is exiting... "), pThread->pFile, pThread->nLine );
	UnmakeThread();
	//lprintf( WIDE("%s(%d):Thread is exiting... "), pThread->pFile, pThread->nLine );
#ifdef __WATCOMC__
	return (void*)result;
#else
	return result;
#endif
}
//--------------------------------------------------------------------------
PTHREAD  MakeThread( void )
{
#ifdef HAS_TLS
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
	if( MyThreadInfo.pThread )
		return MyThreadInfo.pThread;
	MyThreadInfo.nThread = _GetMyThreadID();
#endif
	{
		PTHREAD pThread;
		THREAD_ID thread_ident = _GetMyThreadID();
#ifndef HAS_TLS
		if( !(pThread = FindThread( thread_ident ) ) )
#endif
		{
			uintptr_t oldval;
			LOGICAL dontUnlock = FALSE;
			while( ( oldval = LockedExchangePtrSzVal( &globalTimerData.lock_thread_create, (uintptr_t)thread_ident ) ) && oldval != thread_ident )
			{
				if( oldval != thread_ident )
					globalTimerData.lock_thread_create = oldval;
				Relinquish();
			}
			if( oldval == thread_ident )
				dontUnlock = TRUE;
 /*Allocate( sizeof( THREAD ) )*/
			pThread = GetFromSet( THREAD, &globalTimerData.threadset );;
			//lprintf( WIDE("Get Thread %p"), pThread );
			MemSet( pThread, 0, sizeof( THREAD ) );
			pThread->flags.bLocal = TRUE;
			pThread->proc = NULL;
			pThread->param = 0;
			pThread->thread_ident = thread_ident;
			pThread->flags.bReady = 1;
			//if( ( pThread->next = globalTimerData.threads ) )
			//	globalTimerData.threads->me = &pThread->next;
			//pThread->me = &globalTimerData.threads;
			//globalTimerData.threads = pThread;
			InitWakeup( pThread, NULL );
			if( !dontUnlock )
				globalTimerData.lock_thread_create = 0;
#ifdef LOG_THREAD
			Log3( WIDE("Created thread address: %p %" PRIxFAST64 " at %p")
			    , pThread->proc, pThread->thread_ident, pThread );
#endif
		}
#ifdef HAS_TLS
		MyThreadInfo.pThread = pThread;
#endif
		return pThread;
	}
}
THREAD_ID GetThreadID( PTHREAD thread )
{
	if( thread )
		return thread->thread_ident;
	return 0;
}
THREAD_ID GetThisThreadID( void )
{
#if HAS_TLS
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
	if( !MyThreadInfo.nThread )
	{
		MyThreadInfo.nThread = _GetMyThreadID();
	}
	return MyThreadInfo.nThread;
#else
	return MakeThread()->thread_ident;
#endif
}
uintptr_t GetThreadParam( PTHREAD thread )
{
	if( thread )
		return thread->param;
	return 0;
}
//--------------------------------------------------------------------------
PTHREAD  ThreadToEx( uintptr_t (CPROC*proc)(PTHREAD), uintptr_t param DBG_PASS )
{
	int success;
	PTHREAD pThread;
	while( LockedExchangePtrSzVal( &globalTimerData.lock_thread_create, 1 ) )
		Relinquish();
	do
	{
		pThread = GetFromSet( THREAD, &globalTimerData.threadset );
		if( !pThread )
			xlprintf(LOG_ALWAYS)( WIDE( "Thread to pThread allocation failed!" ) );
	} while( !pThread );
	/*AllocateEx( sizeof( THREAD ) DBG_RELAY );*/
	if( globalTimerData.flags.bLogThreadCreate )
		_lprintf(DBG_RELAY)( WIDE("Create New thread %p"), pThread );
	MemSet( pThread, 0, sizeof( THREAD ) );
	pThread->flags.bLocal = TRUE;
	pThread->proc = proc;
	pThread->param = param;
	pThread->thread_ident = 0;
#if DBG_AVAILABLE
	pThread->pFile = pFile;
	pThread->nLine = nLine;
#endif
	globalTimerData.lock_thread_create = 0;
#ifdef LOG_THREAD
	Log( WIDE("Begin Create Thread") );
#endif
#ifdef _WIN32
#if defined( __WATCOMC__ ) || defined( __WATCOM_CPLUSPLUS__ )
	pThread->hThread = (HANDLE)_beginthread( (void(*)(void*))ThreadWrapper, 8192, pThread );
#else
	{
		DWORD dwJunk;
		pThread->hThread = CreateThread( NULL, 1024
		                               , (LPTHREAD_START_ROUTINE)(ThreadWrapper)
		                               , pThread
		                               , 0
		                               , &dwJunk );
	}
#endif
	success = (int)(pThread->hThread!=NULL);
#else
	//lprintf( "Create thread..." );
	success = !pthread_create( &pThread->hThread, NULL, (void*(*)(void*))ThreadWrapper, pThread );
#endif
	if( success )
	{
#ifndef _WIN32
		pthread_detach( pThread->hThread );
		// I don't get the return code from threads...
		// thread wrapper self destructs its handles...
		// should add an event callback on thread end.
#endif
		// link into list... it's a valid thread
		// the system claims that it can start one.
		//if( ( ( pThread->next = globalTimerData.threads ) ) )
		//   globalTimerData.threads->me = &pThread->next;
		//pThread->me = &globalTimerData.threads;
		//globalTimerData.threads = pThread;
		pThread->flags.bReady = 1;
		{
			uint32_t now = GetTickCount();
			while( !pThread->thread_event && ( now + 250 ) > GetTickCount()  )
				Relinquish();
		}
#ifdef LOG_THREAD
		Log3( WIDE("Created thread address: %p %016"_64fx" at %p")
		    , pThread->proc, pThread->thread_ident, pThread );
#endif
	}
	else
	{
		// unlink from globalTimerData.threads list.
		while( LockedExchangePtrSzVal( &globalTimerData.lock_thread_create, 1 ) )
			Relinquish();
 /*Release( pThread )*/
		DeleteFromSet( THREAD, globalTimerData.threadset, pThread );
		globalTimerData.lock_thread_create = 0;
		pThread = NULL;
	}
	return pThread;
}
//--------------------------------------------------------------------------
PTHREAD  ThreadToSimpleEx( uintptr_t (CPROC*proc)(POINTER), POINTER param DBG_PASS )
{
	int success;
	PTHREAD pThread;
	while( LockedExchangePtrSzVal( &globalTimerData.lock_thread_create, 1 ) )
		Relinquish();
	pThread = GetFromSet( THREAD, &globalTimerData.threadset );
	/*AllocateEx( sizeof( THREAD ) DBG_RELAY );*/
#ifdef LOG_THREAD
	Log( WIDE("Creating a new thread... ") );
	lprintf( WIDE("New thread %p"), pThread );
#endif
	MemSet( pThread, 0, sizeof( THREAD ) );
	pThread->flags.bLocal = TRUE;
	pThread->simple_proc = proc;
	pThread->param = (uintptr_t)param;
	pThread->thread_ident = 0;
#if DBG_AVAILABLE
	pThread->pFile = pFile;
	pThread->nLine = nLine;
#endif
	globalTimerData.lock_thread_create = 0;
#ifdef LOG_THREAD
	Log( WIDE("Begin Create Thread") );
#endif
#ifdef _WIN32
#if defined( __WATCOMC__ ) || defined( __WATCOM_CPLUSPLUS__ )
	pThread->hThread = (HANDLE)_beginthread( (void(*)(void*))SimpleThreadWrapper, 8192, pThread );
#else
	{
		DWORD dwJunk;
		pThread->hThread = CreateThread( NULL, 1024
		                               , (LPTHREAD_START_ROUTINE)(SimpleThreadWrapper)
		                               , pThread
		                               , 0
		                               , &dwJunk );
	}
#endif
	success = (int)(pThread->hThread!=NULL);
#else
	//lprintf( "Create thread" );
	success = !pthread_create( &pThread->hThread, NULL, (void*(*)(void*))SimpleThreadWrapper, pThread );
#endif
	if( success )
	{
		// link into list... it's a valid thread
		// the system claims that it can start one.
		//if( ( ( pThread->next = globalTimerData.threads ) ) )
		//   globalTimerData.threads->me = &pThread->next;
		//pThread->me = &globalTimerData.threads;
		//globalTimerData.threads = pThread;
		pThread->flags.bReady = 1;
		while( !pThread->thread_ident )
			Relinquish();
#ifdef LOG_THREAD
		lprintf( WIDE("Created thread address: %p %016"_64fx" at %p")
		       , pThread->proc, pThread->thread_ident, pThread );
#endif
	}
	else
	{
		// unlink from globalTimerData.threads list.
		while( LockedExchangePtrSzVal( &globalTimerData.lock_thread_create, 1 ) )
			Relinquish();
 /*Release( pThread )*/
		DeleteFromSet( THREAD, globalTimerData.threadset, pThread );
		globalTimerData.lock_thread_create = 0;
		pThread = NULL;
	}
	return pThread;
}
//--------------------------------------------------------------------------
void  EndThread( PTHREAD thread )
{
	if( thread )
	{
#ifdef __LINUX__
#  ifndef __ANDROID__
		pthread_cancel( thread->hThread );
#  endif
#else
		TerminateThread( thread->hThread, 0xD1E );
#ifdef LOG_THREAD
		lprintf( WIDE("Killing thread...") );
#endif
		CloseHandle( thread->thread_event->hEvent );
#endif
	}
}
#if _WIN32
HANDLE GetThreadHandle( PTHREAD thread )
{
	if( thread )
		return thread->hThread;
	return INVALID_HANDLE_VALUE;
}
#endif
#ifdef __LINUX__
pthread_t GetThreadHandle( PTHREAD thread )
{
	if( thread )
		return thread->hThread;
	return (pthread_t)NULL;
}
#endif
//--------------------------------------------------------------------------
static void DoInsertTimer( PTIMER timer )
{
	PTIMER check;
#ifdef ENABLE_CRITICALSEC_LOGGING
	BIT_FIELD bLock = globalTimerData.flags.bLogCriticalSections;
	SetCriticalLogging( 0 );
	globalTimerData.flags.bLogCriticalSections = 0;
#endif
	EnterCriticalSec( &globalTimerData.csGrab );
#ifdef ENABLE_CRITICALSEC_LOGGING
	globalTimerData.flags.bLogCriticalSections = bLock;
	SetCriticalLogging( bLock );
#endif
	if( !(check = globalTimerData.timers) )
	{
#ifdef LOG_INSERTS
		Log( WIDE("First(only known) timer!") );
#endif
		// subtract already existing time... (ONLY if first timer)
		//timer->delta -= ( globalTimerData.this_tick - globalTimerData.last_tick );
		(*(timer->me = &globalTimerData.timers))=timer;
#ifdef LOG_INSERTS
		Log( WIDE("Done with addition") );
#endif
#ifdef ENABLE_CRITICALSEC_LOGGING
		SetCriticalLogging( 0 );
		globalTimerData.flags.bLogCriticalSections = 0;
#endif
		LeaveCriticalSec( &globalTimerData.csGrab );
#ifdef ENABLE_CRITICALSEC_LOGGING
		globalTimerData.flags.bLogCriticalSections = bLock;
		SetCriticalLogging( bLock );
#endif
		return;
	}
	while( check )
	{
		// was previously <= which would schedule equal timers at the
		// head of the queue constantly.
#ifdef LOG_INSERTS
		lprintf( WIDE("Timer to store %d freq: %d delta: %d check delta: %d"), timer->ID, timer->frequency, timer->delta, check->delta );
#endif
		if( timer->delta < check->delta )
		{
			check->delta -= timer->delta;
#ifdef LOG_INSERTS
			Log3( WIDE("Storing before timer: %d delta %d next %d"), check->ID, timer->delta, check->delta );
#endif
			timer->next = check;
			(*(timer->me = check->me))=timer;
			check->me = &timer->next;
			break;
		}
		else
		{
			timer->delta -= check->delta;
		}
		if( !check->next )
		{
#ifdef LOG_INSERTS
			Log1( WIDE("Storing after last timer. Delta %d"), timer->delta );
#endif
			(*(timer->me = &check->next))=timer;
			break;
		}
		check = check->next;
	}
#ifdef LOG_INSERTS
	Log( WIDE("Done with addition") );
#endif
	if( !check )
		Log( WIDE("Fatal! Didn't add the timer!") );
#ifdef ENABLE_CRITICALSEC_LOGGING
	SetCriticalLogging( 0 );
	globalTimerData.flags.bLogCriticalSections = 0;
#endif
	LeaveCriticalSec( &globalTimerData.csGrab );
#ifdef ENABLE_CRITICALSEC_LOGGING
	globalTimerData.flags.bLogCriticalSections = bLock;
	SetCriticalLogging( bLock );
#endif
}
//--------------------------------------------------------------------------
static uintptr_t CPROC find_timer( POINTER p, uintptr_t psvID )
{
	uint32_t timerID = (uint32_t)psvID;
	PTIMER timer = (PTIMER)p;
	//lprintf( "Find to remove test %d==%d", timer->ID, timerID );
	if( timer->ID == timerID )
		return (uintptr_t)p;
	return 0;
}
static void  DoRemoveTimer( uint32_t timerID DBG_PASS )
{
	EnterCriticalSec( &globalTimerData.csGrab );
	{
		PTIMER timer = globalTimerData.timers;
		uintptr_t psvTimerResult = ForAllInSet( TIMER, &globalTimerData.timer_pool, find_timer, (uintptr_t)timerID );
		if( psvTimerResult )
			timer = (PTIMER)psvTimerResult;
		else
		{
			while( timer )
			{
				if( timer->ID == timerID )
					break;
				timer = timer->next;
			}
		}
		if( timer )
		{
			PTIMER tmp;
			if( ( tmp = ( (*timer->me) = timer->next ) ) )
			{
				// if I had a next - his refernece of thing that points at him is mine.
				tmp->delta += timer->delta;
				tmp->me = timer->me;
			}
			DeleteFromSet( TIMER, globalTimerData.timer_pool, timer );
		}
		else
			_lprintf(DBG_RELAY)( WIDE("Failed to find timer to grab") );
	}
	LeaveCriticalSec( &globalTimerData.csGrab );
}
//--------------------------------------------------------------------------
static void InsertTimer( PTIMER timer DBG_PASS )
{
	if( NotTimerThread() )
	{
		if( globalTimerData.flags.away_in_timer )
 // if it's away - should be safe to add a new timer
		{
			globalTimerData.flags.insert_while_away = 1;
			// set that we're adding a timer while away
			if( globalTimerData.flags.away_in_timer )
			{
				// if the thread is still away - we can add the timer...
#ifdef LOG_SLEEPS
				lprintf( "Timer is away, just add this new timer back in.." );
#endif
				DoInsertTimer( timer );
				globalTimerData.flags.insert_while_away = 0;
				return;
			}
			// otherwise he came back before we set our addin
			// therefore it should be safe to schedule.
			globalTimerData.flags.insert_while_away = 0;
		}
#ifdef LOG_INSERTS
		Log( WIDE("Inserting timer...to wait for change allow") );
#endif
		// lockout multiple additions...
		EnterCriticalSec( &globalTimerData.cs_timer_change );
#ifdef LOG_INSERTS
		Log( WIDE("Inserting timer...to wait for free add") );
#endif
		// don't add a timer while there's one being added...
		while( globalTimerData.add_timer )
		{
			WakeThread(globalTimerData.pTimerThread);
			//Relinquish();
		}
#ifdef LOG_INSERTS
		Log( WIDE("Inserting timer...setup dataa") );
#endif
		globalTimerData.add_timer = timer;
		LeaveCriticalSec( &globalTimerData.cs_timer_change );
		// it might be sleeping....
#ifdef LOG_INSERTS
		Log( WIDE("Inserting timer...wake and done") );
#endif
#ifdef LOG_SLEEPS
		lprintf( "Wake timer thread." );
#endif
		// wake this thread because it's current scheduled delta (ex 1000ms)
		// may put it's sleep beyond the frequency of this timer (ex 10ms)
		WakeThreadEx(globalTimerData.pTimerThread DBG_RELAY);
	}
	else
	{
		EnterCriticalSec( &globalTimerData.csGrab );
		// have to assume that we're away in callback
		// in order to get here... there's no other way
		// for this routine to be called and BE the timer thread.
		// therefore - safe to add it.
		DoInsertTimer( timer );
#ifdef LOG_SLEEPS
		lprintf( "Insert timer not dispatched." );
#endif
		if( globalTimerData.timers == timer )
		{
#ifdef LOG_SLEEPS
			lprintf( "Wake timer thread." );
#endif
			WakeThread(globalTimerData.pTimerThread);
		}
		LeaveCriticalSec( &globalTimerData.csGrab );
	}
}
//--------------------------------------------------------------------------
static PTIMER GrabTimer( PTIMER timer )
{
	// if a timer has been grabbed, it won't be grabbed...
	// but if a timer is being grabbed, it might get grabbed twice.
	if( timer && timer->me )
	{
		// the thing that points at me points at my next....
#ifdef LOG_INSERTS
		Log1( WIDE("Grab Timer: %d"), timer->ID );
#endif
		if( ( (*timer->me) = timer->next ) )
		{
			// if I had a next - his refernece of thing that points at him is mine.
			timer->next->me = timer->me;
		}
		timer->next = NULL;
		timer->me = NULL;
		return timer;
	}
	return NULL;
}
//--------------------------------------------------------------------------
static int CPROC ProcessTimers( uintptr_t psvForce )
{
	if( global_timer_structure )
	{
	PTIMER timer;
#ifdef ENABLE_CRITICALSEC_LOGGING
	BIT_FIELD bLock = globalTimerData.flags.bLogCriticalSections;
#endif
	uint32_t newtick;
	if( globalTimerData.flags.bExited )
		return -1;
	if( !psvForce && !IsThisThread( globalTimerData.pTimerThread ) )
	{
		//Log( WIDE("Unknown thread attempting to process timers...") );
		return -1;
	}
#ifndef _WIN32
	//nice( -3 ); // allow ourselves a bit more priority...
#endif
	{
		// there are timers - and there's one which wants to be added...
		// if there's no timers - just sleep here...
		while( ( !globalTimerData.add_timer && !globalTimerData.timers ) || globalTimerData.flags.bHaltTimers )
		{
			if( !psvForce )
				return 1;
#ifdef LOG_SLEEPS
			lprintf( WIDE("Timer thread sleeping forever...") );
#endif
#ifdef __LINUX__
			if( globalTimerData.pTimerThread )
				TimerWakeableSleep( SLEEP_FOREVER );
#else
			WakeableSleep( SLEEP_FOREVER );
#endif
			// had no timers - but NOW either we woke up by default...
			// OR - we go kicked awake - so mark the beginning of known time.
#ifdef LOG_LATENCY
			Log( WIDE("Re-synch first tick...") );
#endif
//GetTickCount();
			globalTimerData.last_tick = timeGetTime();
		}
		// add and delete new/old timers here...
		// should be the next event after sleeping (low var-sleep top const-sleep)
		if( globalTimerData.add_timer )
		{
#ifdef LOG_INSERTS
			Log( WIDE("Adding timer really...") );
#endif
			DoInsertTimer( globalTimerData.add_timer );
			globalTimerData.add_timer = NULL;
		}
		if( globalTimerData.del_timer )
		{
#ifdef LOG_INSERTS
			Log( WIDE("Scheduled remove timer...") );
#endif
			DoRemoveTimer( globalTimerData.del_timer DBG_SRC );
			globalTimerData.del_timer = 0;
		}
		// get the time now....
//GetTickCount();
		newtick = globalTimerData.this_tick = timeGetTime();
#ifdef LOG_LATENCY
		Log3( WIDE("total - Tick: %u Last: %u  delta: %u"), globalTimerData.this_tick, globalTimerData.last_tick, globalTimerData.this_tick-globalTimerData.last_tick );
#endif
		//if( globalTimerData.timers )
		//	 delay_skew = globalTimerData.this_tick-globalTimerData.last_tick - globalTimerData.timers->delta;
		// delay_skew = 0; // already chaotic...
		//if( timers )
		//	Log1( WIDE("timer delta: %ud"), timers->delta );
#ifdef ENABLE_CRITICALSEC_LOGGING
		SetCriticalLogging( 0 );
		globalTimerData.flags.bLogCriticalSections = 0;
#endif
		while( ( EnterCriticalSec( &globalTimerData.csGrab ), timer = globalTimerData.timers ) &&
				( (int32_t)( newtick - globalTimerData.last_tick ) >= timer->delta ) )
		{
#ifdef ENABLE_CRITICALSEC_LOGGING
			globalTimerData.flags.bLogCriticalSections = bLock;
			SetCriticalLogging( bLock );
#endif
#ifdef LOG_LATENCY
#ifdef _DEBUG
			_xlprintf( 1, timer->pFile, timer->nLine )( WIDE("Tick: %u Last: %u  delta: %u Timerdelta: %u")
																	, globalTimerData.this_tick, globalTimerData.last_tick, globalTimerData.this_tick-globalTimerData.last_tick, timer->delta );
#else
			lprintf( WIDE("Tick: %u Last: %u  delta: %u Timerdelta: %u")
			       , globalTimerData.this_tick, globalTimerData.last_tick, globalTimerData.this_tick-globalTimerData.last_tick, timer->delta );
#endif
#endif
			// also enters csGrab... should be ok.
			GrabTimer( timer );
#ifdef ENABLE_CRITICALSEC_LOGGING
			SetCriticalLogging( 0 );
			globalTimerData.flags.bLogCriticalSections = 0;
#endif
			LeaveCriticalSec( &globalTimerData.csGrab );
#ifdef ENABLE_CRITICALSEC_LOGGING
			globalTimerData.flags.bLogCriticalSections = bLock;
			SetCriticalLogging( bLock );
#endif
			globalTimerData.last_tick += timer->delta;
			if( timer->callback )
			{
#ifdef _WIN32
#if PARANOID
				if( IsBadCodePtr( (FARPROC)timer->callback ) )
				{
					Log1( WIDE("Timer %d proc has been unloaded! kiling timer"), timer->ID );
					timer->frequency = 0;
				}
				else
#endif
#endif
				{
					//#ifdef LOG_DISPATCH
					static int level;
					if( globalTimerData.flags.bLogTimerDispatch )
					{
						level++;
#ifdef _DEBUG
						lprintf( WIDE("%d Dispatching timer %")_32fs WIDE(" freq %")_32fs WIDE(" %s(%d)"), level, timer->ID, timer->frequency
						       , timer->pFile, timer->nLine );
#else
						lprintf( WIDE("%d Dispatching timer %") _32fs WIDE(" freq %") _32fs, level, timer->ID, timer->frequency );
#endif
					}
					//#endif
					globalTimerData.current_timer = timer;
					timer->flags.bRescheduled = 0;
					globalTimerData.flags.away_in_timer = 1;
					globalTimerData.CurrentTimerID = timer->ID;
					timer->callback( timer->userdata );
					if( globalTimerData.flags.bLogTimerDispatch )
					{
						level--;
						lprintf( WIDE("timer done. (%d)"), level );
					}
					globalTimerData.flags.away_in_timer = 0;
					while( globalTimerData.flags.insert_while_away )
					{
						// request for insert while away... allow it to
						// get scheduled...
						Relinquish();
					}
					globalTimerData.current_timer = NULL;
				}
				// allow timers to be added while away in this
				// timer's callback... so wait for it to finish.
				// but do - clear away status so that ANOTHER
				// timer will be held waiting...
			}
			// reset timer to frequency here
			// if a VERY long time has elapsed, next timer occurs its
			//  frequency after now.  Otherwise we may NEVER get out
			//  of processing this timer.
			// this point should be optioned whether the timer is
			// a guaranteed tick, or whether it's sloppy.
			if( timer->frequency || timer->flags.bRescheduled )
			{
				if( timer->flags.bRescheduled )
				{
					timer->flags.bRescheduled = 0;
					// delta will have been set for next run...
					// therefore do not schedule it ourselves.
				}
				else
				{
					if( ( newtick - globalTimerData.last_tick ) > timer->frequency )
					{
#ifdef LOG_LATENCY_LIGHT
						lprintf( WIDE("Timer used more time than its frequency.  Scheduling at 1 ms.") );
#endif
						timer->delta = ( newtick - globalTimerData.last_tick ) + 1;
					}
					else
					{
#ifdef LOG_LATENCY_LIGHT
						// timer alwyas goes +1 frequency from its base tick.
						lprintf( WIDE("Scheduling timer at 1 frequency.") );
#endif
						timer->delta = timer->frequency;
					}
				}
				DoInsertTimer( timer );
			}
			else
			{
#ifdef LOG_INSERTS
				lprintf( WIDE("Removing one shot timer. %d"), timer->ID );
#endif
				// was a one shot timer.
				DeleteFromSet( TIMER, globalTimerData.timer_pool, timer );
				timer = NULL;
			}
		}
#ifdef ENABLE_CRITICALSEC_LOGGING
		SetCriticalLogging( 0 );
		globalTimerData.flags.bLogCriticalSections = 0;
#endif
		LeaveCriticalSec( &globalTimerData.csGrab );
#ifdef ENABLE_CRITICALSEC_LOGGING
		globalTimerData.flags.bLogCriticalSections = bLock;
		SetCriticalLogging( bLock );
#endif
		if( timer )
		{
#ifdef LOG_LATENCY
			lprintf( WIDE("Pending timer in: %d Sleeping %d (%d) [%d]")
			       , timer->delta
			       , timer->delta - (newtick-globalTimerData.last_tick)
			       , timer->delta - (globalTimerData.this_tick-globalTimerData.last_tick)
			       , newtick - globalTimerData.this_tick
			       );
#endif
			globalTimerData.last_sleep = ( timer->delta - ( globalTimerData.this_tick - globalTimerData.last_tick ) );
			if( globalTimerData.last_sleep < 0 )
			{
				lprintf( WIDE( "next pending sleep is %d" ), globalTimerData.last_sleep );
				globalTimerData.last_sleep = 1;
			}
#ifdef LOG_LATENCY
			Log1( WIDE("Sleeping %d"), globalTimerData.last_sleep );
#endif
			if( !psvForce )
				return 1;
			if( globalTimerData.last_sleep )
			{
#ifdef __LINUX__
				TimerWakeableSleep( globalTimerData.last_sleep );
#else
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
				WakeableSleepEx( globalTimerData.last_sleep, timer->pFile, timer->nLine );
#else
				WakeableSleepEx( globalTimerData.last_sleep );
#endif
#endif
			}
			if( !global_timer_structure || globalTimerData.flags.bExited )
				return -1;
		}
		// else no timers - go back up to the top - where we sleep.
	}
	//Log( WIDE("Timer thread is exiting...") );
	return 1;
	}
	return -1;
}
//--------------------------------------------------------------------------
uintptr_t CPROC ThreadProc( PTHREAD pThread )
{
	InitializeCriticalSec( &globalTimerData.cs_timer_change );
	globalTimerData.pTimerThread = pThread;
#ifndef __NO_IDLE__
	AddIdleProc( ProcessTimers, (uintptr_t)0 );
#endif
#ifndef _WIN32
 // allow ourselves a bit more priority...
	nice( -3 );
#endif
	//Log( WIDE("Permanently lock timers - indicates that thread is running...") );
	globalTimerData.lock_timers = 1;
	//Log( WIDE("Get first tick") );
//GetTickCount();
	globalTimerData.last_tick = timeGetTime();
	while( ProcessTimers( 1 ) > 0 );
	//Log( WIDE("Timer thread is exiting...") );
	globalTimerData.pTimerThread = NULL;
	return 0;
}
//--------------------------------------------------------------------------
#if 0
// this would really be a good thing to impelment someday.
static void *WatchdogProc( void *unused )
{
	// this checks the running status of the main thread(s)
// if there is a paused thread, then a new thread is created.
// yeah see dekware( syscore/nexus.c WakeAThread() )
	return 0;
}
#endif
//--------------------------------------------------------------------------
uint32_t  AddTimerExx( uint32_t start, uint32_t frequency, TimerCallbackProc callback, uintptr_t user DBG_PASS )
{
	PTIMER timer = GetFromSet( TIMER, &globalTimerData.timer_pool );
	//timer = AllocateEx( sizeof( TIMER ) DBG_RELAY );
	MemSet( timer, 0, sizeof( TIMER ) );
	if( start && !frequency )
	{
		//"Creating one shot timer %d long", start );
	}
 // first time for timer to fire... may be 0
	timer->delta     = (int32_t)start;
	timer->frequency = frequency;
	timer->callback  = callback;
	timer->ID        = globalTimerData.timerID++;
	timer->userdata  = user;
#ifdef _DEBUG
	timer->pFile = pFile;
	timer->nLine = nLine;
#endif
	if( !globalTimerData.pTimerThread )
	{
		//Log( WIDE("Starting \"a\" timer thread!!!!" ) );
		if( !( ThreadTo( ThreadProc, 0 ) ) )
		{
			//Log1( WIDE("Failed to start timer ThreadProc... %d"), GetLastError() );
			return 0;
		}
		while( !globalTimerData.lock_timers )
			Relinquish();
		//Log1( WIDE("Thread started successfully? %d"), GetLastError() );
		// make sure that the thread is running, and had setup its
		// locks, and tick reference
	}
	//_xlprintf(1 DBG_RELAY)( WIDE("Inserting newly created timer.") );
	InsertTimer( timer DBG_RELAY );
	// don't need to sighup here, cause we MUST have permission
	// from the idle thread to add the timer, which means we issue it
	// a sighup to make it wake up and allow us to post.
#ifdef LOG_INSERTS
	_lprintf( DBG_RELAY )( "Resulting timer ID: %d", timer->ID );
#endif
	return timer->ID;
}
#undef AddTimerEx
uint32_t  AddTimerEx( uint32_t start, uint32_t frequency, void (CPROC*callback)(uintptr_t user), uintptr_t user )
{
	return AddTimerExx( start, frequency, callback, user DBG_SRC );
}
//--------------------------------------------------------------------------
void  RemoveTimerEx( uint32_t ID DBG_PASS )
{
	// Lockout multiple changes at a time...
 // IS timer thread..
	if( !NotTimerThread() &&
 // and not in THIS timer...
		( ID != globalTimerData.CurrentTimerID ) )
	{
		// is timer thread itself... safe to remove the timer....
		DoRemoveTimer( ID DBG_SRC );
		return;
	}
	EnterCriticalSec( &globalTimerData.cs_timer_change );
	// only allow one delete at a time...
	while( globalTimerData.del_timer )
	{
#ifdef LOG_INSERTS
		lprintf( "pending timer delete, wait." );
#endif
 // IS timer thread...
		if( !NotTimerThread() )
		{
#ifdef LOG_INSERTS
			lprintf( "is not the timer." );
#endif
			if( globalTimerData.del_timer != globalTimerData.CurrentTimerID )
			{
#ifdef LOG_INSERTS
				lprintf( "schedule timer is not the current timer..." );
#endif
				DoRemoveTimer( globalTimerData.del_timer DBG_SRC );
				globalTimerData.del_timer = 0;
			}
			if( ID != globalTimerData.CurrentTimerID )
			{
#ifdef LOG_INSERTS
				lprintf( "removing timer is not the current timer" );
#endif
				DoRemoveTimer( ID DBG_SRC );
				return;
			}
		}
		else
			Relinquish();
	}
	// now how to set del_timer to a valid timer?!
#ifdef LOG_INSERTS
	_lprintf(DBG_RELAY)( "Set del_timer to schedule delete." );
#endif
	globalTimerData.del_timer = ID;
	LeaveCriticalSec( &globalTimerData.cs_timer_change );
	if( NotTimerThread() )
	{
#ifdef LOG_INSERTS
		lprintf( "wake thread, scheduled delete" );
#endif
		//Log( WIDE("waking timer thread to indicate deletion...") );
		WakeThread( globalTimerData.pTimerThread );
	}
}
#undef RemoveTimer
void  RemoveTimer( uint32_t ID )
{
	RemoveTimerEx( ID DBG_SRC );
}
//--------------------------------------------------------------------------
static void InternalRescheduleTimerEx( PTIMER timer, uint32_t delay )
{
	if( timer )
	{
		PTIMER bGrabbed = GrabTimer( timer );
		timer->flags.bRescheduled = 1;
  // should never pass a negative value here, but delta can be negative.
		timer->delta = (int32_t)delay;
#ifdef LOG_SLEEPS
		lprintf( "Reschedule at %d  %p", timer->delta, bGrabbed );
#endif
		if( bGrabbed )
		{
			//lprintf( WIDE("Rescheduling timer...") );
			DoInsertTimer( timer );
			if( timer == globalTimerData.timers )
			{
#ifdef LOG_SLEEPS
				lprintf( "We cheated to insert - so create a wake." );
#endif
				WakeThread( globalTimerData.pTimerThread );
			}
		}
	}
}
//--------------------------------------------------------------------------
// should lock this...
void  RescheduleTimerEx( uint32_t ID, uint32_t delay )
{
	PTIMER timer;
	EnterCriticalSec( &globalTimerData.csGrab );
	if( !ID )
	{
		timer =globalTimerData.current_timer;
	}
	else
	{
		timer = globalTimerData.timers;
		while( timer && timer->ID != ID )
			timer = timer->next;
		if( !timer )
		{
			// this timer is not part of the list if it's
			// dispatched and we get here (timer itself rescheduling itself)
			if( globalTimerData.current_timer && globalTimerData.current_timer->ID == ID )
				timer = globalTimerData.current_timer;
		}
	}
	InternalRescheduleTimerEx( timer, delay );
	LeaveCriticalSec( &globalTimerData.csGrab );
}
//--------------------------------------------------------------------------
void  RescheduleTimer( uint32_t ID )
{
	PTIMER timer = globalTimerData.timers;
	EnterCriticalSec( &globalTimerData.csGrab );
	while( timer && timer->ID != ID )
		timer = timer->next;
	if( !timer )
	{
		if( globalTimerData.current_timer && globalTimerData.current_timer->ID == ID )
			timer = globalTimerData.current_timer;
	}
	if( timer )
	{
		InternalRescheduleTimerEx( timer, timer->frequency );
	}
	LeaveCriticalSec( &globalTimerData.csGrab );
}
//--------------------------------------------------------------------------
static void OnDisplayPause( WIDE("@Internal Timers") _WIDE(TARGETNAME) )( void )
{
	globalTimerData.flags.bHaltTimers = 1;
}
//--------------------------------------------------------------------------
static void OnDisplayResume( WIDE("@Internal Timers") _WIDE(TARGETNAME))( void )
{
	globalTimerData.flags.bHaltTimers = 0;
	if( globalTimerData.pTimerThread )
		WakeThread( globalTimerData.pTimerThread );
}
//--------------------------------------------------------------------------
void  ChangeTimerEx( uint32_t ID, uint32_t initial, uint32_t frequency )
{
	PTIMER timer = globalTimerData.timers;
	EnterCriticalSec( &globalTimerData.csGrab );
	while( timer && timer->ID != ID )
		timer = timer->next;
	if( timer )
	{
		timer->frequency = frequency;
		InternalRescheduleTimerEx( timer, initial );
	}
	LeaveCriticalSec( &globalTimerData.csGrab );
}
//--------------------------------------------------------------------------
#ifndef USE_NATIVE_CRITICAL_SECTION
#ifdef _MSC_VER
#  pragma optimize( "st", off )
#endif
LOGICAL  EnterCriticalSecEx( PCRITICALSECTION pcs DBG_PASS )
{
	int d;
	THREAD_ID prior = 0;
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
#ifdef _DEBUG
	if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
		_lprintf( DBG_RELAY )( WIDE("Enter critical section %p (owner) %")_64fx, pcs, pcs->dwThreadID );
#endif
#endif
	do
	{
		d=EnterCriticalSecNoWaitEx( pcs, &prior DBG_RELAY );
		if( d < 0 )
			Relinquish();
		else if( d == 0 )
		{
			if( pcs->dwThreadID )
			{
#ifdef ENABLE_CRITICALSEC_LOGGING
#  ifdef _DEBUG
				if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
					lprintf( WIDE("Failed to enter section... sleeping (forever)...") );
#  endif
#endif
				WakeableNamedThreadSleepEx( WIDE("sack.critsec"), SLEEP_FOREVER DBG_RELAY );
#ifdef ENABLE_CRITICALSEC_LOGGING
#  ifdef _DEBUG
				if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
					lprintf( WIDE("Allowed to retry section entry, woken up...") );
#  endif
#endif
			}
#ifdef ENABLE_CRITICALSEC_LOGGING
#  ifdef _DEBUG
			else
			{
				if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
					lprintf( WIDE("Lock Released while we logged?") );
			}
#  endif
#endif
		}
		else {
			if( prior ) {
#ifdef ENABLE_CRITICALSEC_LOGGING
#  ifdef _DEBUG
				if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
					lprintf( WIDE("Entered section, restore prior waiting thread. %") _64fx  WIDE(" %" ) _64fx, prior, pcs->dwThreadWaiting );
#  endif
#endif
			}
		}
		// after waking up, this will re-aquire a lock, and
		// set the prior waiting ID into the criticalsection
		// this will then wake that process when this lock is left.
	}
	while( (d <= 0) );
	return TRUE;
}
#endif
//-------------------------------------------------------------------------
#ifndef USE_NATIVE_CRITICAL_SECTION
#ifdef _MSC_VER
#  pragma optimize( "st", off )
#endif
LOGICAL  LeaveCriticalSecEx( PCRITICALSECTION pcs DBG_PASS )
{
	THREAD_ID dwCurProc;
#ifdef _DEBUG
	uint32_t curtick;
#endif
	while( 1 ) {
#ifdef _DEBUG
		curtick = timeGetTime();
#endif
#ifdef ENABLE_CRITICALSEC_LOGGING
		if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
			_xlprintf( LOG_NOISE DBG_RELAY )( WIDE( "Begin leave critical section %p %" ) _64fx, pcs, pcs->dwThreadWaiting );
#endif
		while( LockedExchange( &pcs->dwUpdating, 1 )
#ifdef _DEBUG
			//GetTickCount() )
			&& ( ( curtick + 2000 ) > timeGetTime() )
#endif
			) {
#ifdef ENABLE_CRITICALSEC_LOGGING
			if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
				_lprintf( DBG_RELAY )( WIDE( "On leave - section is updating, wait..." ) );
#endif
			Relinquish();
}
		dwCurProc = GetMyThreadID();
#ifdef _DEBUG
		//GetTickCount() )
		if( ( curtick + 2000 ) <= timeGetTime() ) {
			lprintf( WIDE( "Timeout during critical section wait for lock.  No lock should take more than 1 task cycle" ) );
			DebugBreak();
			continue;
		}
#endif
		break;
	}
	if( !( pcs->dwLocks & ~SECTION_LOGGED_WAIT ) )
	{
#ifdef ENABLE_CRITICALSEC_LOGGING
		if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
			_lprintf( DBG_RELAY )( WIDE("Leaving a blank critical section") );
#endif
		DebugBreak();
		pcs->dwUpdating = 0;
		return FALSE;
	}
	if( pcs->dwThreadID == dwCurProc )
	{
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
		pcs->pFile[pcs->nPrior] = pFile;
		pcs->nLine[pcs->nPrior] = nLine;
#  else
		pcs->pFile[pcs->nPrior] = __FILE__;
		pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
		pcs->nLineCS[pcs->nPrior] = __LINE__;
		pcs->isLock[pcs->nPrior] = 0;
		pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
		pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
		pcs->dwLocks--;
#ifdef ENABLE_CRITICALSEC_LOGGING
		if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
			lprintf( WIDE("Remaining locks... %08") _32fx, pcs->dwLocks );
#endif
		if( !( pcs->dwLocks & ~(SECTION_LOGGED_WAIT) ) )
		{
			pcs->dwLocks = 0;
			pcs->dwThreadID = 0;
			// wake the prior (if there is one sleeping)
			if( pcs->dwThreadWaiting )
			{
				pcs->dwUpdating = 0;
#ifdef ENABLE_CRITICALSEC_LOGGING
				if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
					_lprintf( DBG_RELAY )( WIDE("%8")_64fx WIDE(" Waking a thread which is waiting..."), pcs->dwThreadWaiting );
#endif
				// don't clear waiting... so the proper thread can
				// allow itself to claim section...
				WakeNamedThreadSleeperEx( WIDE("sack.critsec"), pcs->dwThreadWaiting DBG_RELAY );
				//WakeThreadIDEx( wake DBG_RELAY);
			}
			else
				pcs->dwUpdating = 0;
			return TRUE;
		}
	}
	else {
#ifdef ENABLE_CRITICALSEC_LOGGING
		if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
		{
			_lprintf( DBG_RELAY )(WIDE( "Sorry - you can't leave a section owned by %016" )_64fx WIDE( " locks:%08" )_32fx
#  ifdef DEBUG_CRITICAL_SECTIONS
				WIDE( "%s(%d)..." )
#  endif
				, pcs->dwThreadID
				, pcs->dwLocks
#  ifdef DEBUG_CRITICAL_SECTIONS
				, (pcs->pFile[(pcs->nPrior + 15) % MAX_SECTION_LOG_QUEUE]) ? (pcs->pFile[(pcs->nPrior + 15) % MAX_SECTION_LOG_QUEUE]) : WIDE( "Unknown" ), pcs->nLine[(pcs->nPrior + 15) % MAX_SECTION_LOG_QUEUE]
#  endif
				);
		}
#endif
		DebugBreak();
	}
	pcs->dwUpdating = 0;
	return FALSE;
}
#endif
//--------------------------------------------------------------------------
void DeleteCriticalSec( PCRITICALSECTION pcs )
{
	// ya I don't have anything to do here...
	return;
}
#ifdef _WIN32
HANDLE  GetWakeEvent( void )
{
#if HAS_TLS
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
	if( !MyThreadInfo.pThread )
		MakeThread();
	return MyThreadInfo.pThread->thread_event->hEvent;
#else
	return MakeThread()->thread_event->hEvent;
#endif
}
#endif
#ifdef __cplusplus
//	namespace timers {
};
//namespace sack {
};
#endif
//--------------------------------------------------------------------------
// $Log: timers.c,v $
// Revision 1.140  2005/06/22 23:13:51  jim
// Differentiate the normal logging of 'entered, left section' but leave in notable exception case logging when enabling critical section debugging.
//
// Revision 1.108  2005/01/23 11:28:24  panther
// Thread ID modification broke timer...
//
// 400 lines of logging removed... version 1.109?
#ifdef __cplusplus
namespace sack {
	namespace timers {
		using namespace sack::memory;
#endif
      typedef struct idle_proc_tag IDLEPROC;
      typedef struct idle_proc_tag *PIDLEPROC;
struct idle_proc_tag
{
	struct {
		BIT_FIELD bDispatched : 1;
		BIT_FIELD bRemove : 1;
	} flags;
	// return -1 if not the correct thread
	// to handle this callback
	// return 0 if no messages were processed
	// return 1 if messages were processed
	int (CPROC*function)(uintptr_t);
	uintptr_t data;
	THREAD_ID thread;
	//PDATAQUEUE threads;
 // same function references go here - for multiple thread entries...
	PIDLEPROC similar;
	DeclareLink( struct idle_proc_tag );
};
struct idle_global_tag {
	CRITICALSECTION idle_cs;
	LOGICAL cs_inited;
	PIDLEPROC registered_idle_procs;
};
#ifndef __STATIC_GLOBALS__
// registered_idle_procs;
static struct idle_global_tag *idle_global;
PRIORITY_PRELOAD( InitGlobalIdle, OSALOT_PRELOAD_PRIORITY )
{
	SimpleRegisterAndCreateGlobal( idle_global );
	if( !(*idle_global).cs_inited )
	{
		InitializeCriticalSec( &(*idle_global).idle_cs );
		(*idle_global).cs_inited = 1;
	}
}
#else
// registered_idle_procs;
static struct idle_global_tag _idle_global;
// registered_idle_procs;
static struct idle_global_tag *idle_global = &_idle_global;
#endif
#ifdef procs
#  undef procs
#endif
#define procs ((*idle_global).registered_idle_procs)
IDLE_PROC( void, AddIdleProc )( int (CPROC*Proc)( uintptr_t psv ), uintptr_t psvUser )
{
	PIDLEPROC proc = NULL;
#ifndef __STATIC_GLOBALS__
	if( !idle_global )
		SimpleRegisterAndCreateGlobal( idle_global );
#endif
	if( !(*idle_global).cs_inited )
	{
		InitializeCriticalSec( &(*idle_global).idle_cs );
		(*idle_global).cs_inited = TRUE;
	}
	EnterCriticalSec( &(*idle_global).idle_cs );
	for( proc = procs; proc; proc = proc->next )
	{
		if( Proc == proc->function )
		{
			PIDLEPROC newproc = (PIDLEPROC)Allocate( sizeof( IDLEPROC ) );
			MemSet( newproc, 0, sizeof( IDLEPROC ) );
			newproc->function = Proc;
			newproc->data = psvUser;
			LinkLast( proc->similar, PIDLEPROC, newproc );
			break;
		}
	}
	// if the function is not already registered as an idle proc, register it.
	if( !proc )
	{
		proc = (PIDLEPROC)Allocate( sizeof( IDLEPROC ) );
		MemSet( proc, 0, sizeof( IDLEPROC ) );
		proc->function = Proc;
		proc->data = psvUser;
		LinkThing( procs, proc );
	}
	LeaveCriticalSec( &(*idle_global).idle_cs );
}
IDLE_PROC( int, RemoveIdleProc )( int (CPROC*Proc)(uintptr_t psv ) )
{
	PIDLEPROC check_proc;
#ifndef __STATIC_GLOBALS__
	if( !idle_global )
		SimpleRegisterAndCreateGlobal( idle_global );
#endif
	if( !(*idle_global).cs_inited )
	{
		InitializeCriticalSec( &(*idle_global).idle_cs );
		(*idle_global).cs_inited = TRUE;
	}
	EnterCriticalSec( &(*idle_global).idle_cs );
	for( check_proc = procs; check_proc; check_proc = check_proc->next )
	{
		if( Proc == check_proc->function )
		{
			if( !check_proc->flags.bDispatched )
			{
				UnlinkThing( check_proc );
				if( check_proc->similar )
					LinkThing( check_proc->similar, procs );
				Release( check_proc );
			}
			else
			{
				check_proc->flags.bRemove = 1;
			}
			break;
		}
	}
	LeaveCriticalSec( &(*idle_global).idle_cs );
	return 0;
}
IDLE_PROC( int, IdleEx )( DBG_VOIDPASS )
{
	THREAD_ID me = GetMyThreadID();
	int success = 0;
	PIDLEPROC proc;
#ifndef __STATIC_GLOBALS__
	if( idle_global )
#endif
	for( proc = procs; proc;  )
	{
		PIDLEPROC check;
		for( check = proc; check; check = check->similar )
		{
			check->flags.bDispatched = 1;
			//lprintf( "attempt proc %p in %Lx  procthread=%Lx", check, GetThreadID( MakeThread() ), check->thread );
			//if( !check->thread || ( check->thread == me ) )
			// sometimes... a function belongs to multiple threads...
			if( check->function( check->data ) != -1 )
			{
				check->thread = me;
				success = 1;
			}
			check->flags.bDispatched = 0;
			if( check->flags.bRemove )
			{
				UnlinkThing( check );
				if( check->similar && check == proc )
					LinkThing( check->similar, procs );
				Release( proc );
				proc = procs;
				break;
			}
			else
			{
				//if( check->thread == me )
				{
					proc = proc->next;
					break;
				}
			}
		}
		if( check == NULL )
			proc = proc->next;
	}
	//_lprintf( DBG_AVAILABLE, WIDE("Is Going idle.") DBG_RELAY );
	Relinquish();
	//_lprintf( DBG_AVAILABLE, WIDE("Is back from idle.") DBG_RELAY );
	return success;
}
#undef Idle
IDLE_PROC( int, Idle )( void )
{
   return IdleEx( DBG_VOIDSRC );
}
IDLE_PROC( int, IdleForEx )( uint32_t dwMilliseconds DBG_PASS )
{
	uint32_t dwStart = timeGetTime();
	while( ( dwStart + dwMilliseconds ) > timeGetTime() )
	{
		if( !IdleEx( DBG_VOIDRELAY ) )
		{
			// sleeping... cause ew didn't do any idle procs...
			WakeableSleep( dwMilliseconds );
		}
	}
	return 0;
}
#undef IdleFor
IDLE_PROC( int, IdleFor )( uint32_t dwMilliseconds )
{
   return IdleForEx( dwMilliseconds DBG_SRC );
}
#undef procs
#ifdef __cplusplus
 //namespace sack {
};
 //	namespace idle {
};
#endif
#define NO_UNICODE_C
#define PROCREG_SOURCE
#ifdef __ANDROID__
#  ifdef DEBUG_FIRST_UNICODE_OPERATION
#  endif
#endif
//#define DEBUG_GLOBAL_REGISTRATION
#define REGISTRY_STRUCTURE_DEFINED
//#define PROCREG_SOURCE
// include this first so we can have the namespace...
#undef REGISTRY_STRUCTURE_DEFINED
#ifndef REGISTRY_STRUCTURE_DEFINED
#define REGISTRY_STRUCTURE_DEFINED
#ifdef __LINUX__
// pid_t for service process registrations...
#endif
PROCREG_NAMESPACE
//typedef struct tree_def_tag *PCLASSROOT;
//typedef void (CPROC *PROCEDURE)(void);
enum proc_types {
	ARG_FLOAT
					, ARG_DOUBLE
					, ARG_CHAR
					, ARG_SHORT
					, ARG_LONG
					, ARG_LONGLONG
					, ARG_UCHAR
					, ARG_USHORT
					, ARG_ULONG
					, ARG_ULONGLONG
					, ARG_PTRFLOAT
					, ARG_PTRDOUBLE
					, ARG_PTRCHAR
					, ARG_PTRSHORT
					, ARG_PTRLONG
					, ARG_PTRLONGLONG
					, ARG_PTRUCHAR
					, ARG_PTRUSHORT
					, ARG_PTRULONG
					, ARG_PTRULONGLONG
               , ARG_PTRSTRING
};
#if 0
typedef struct proc_param_tag {
	enum proc_types type;
   int count;
//1>c:\work\sack\src\procreglib\registry.h(42) : warning C4200: nonstandard extension used : zero-sized array in struct/union
//1>        Cannot generate copy-ctor or copy-assignment operator when UDT contains a zero-sized array`
   char name[];
} PROC_PARAM;
#endif
typedef struct proc_def_tag
{
	//CTEXTSTR ret;
	// name is a NUL seperated list of fields
	// library:procname:return type:args
	// this is truly the full name of a procedure...
	// arguments have any spaces or odd characters stripped
	CTEXTSTR name;
	//CTEXTSTR args;
	CTEXTSTR library;
	CTEXTSTR procname;
 // proc is just a cache of library:name
	PROCEDURE proc;
} PROCDEF, *PPROCDEF;
#ifdef __cplusplus_cli
typedef struct stdproc_def_tag
{
	//CTEXTSTR ret;
	// name is a NUL seperated list of fields
	// library:procname:return type:args
	// this is truly the full name of a procedure...
	// arguments have any spaces or odd characters stripped
	CTEXTSTR name;
	//CTEXTSTR args;
	CTEXTSTR library;
	CTEXTSTR procname;
 // proc is just a cache of library:name
	STDPROCEDURE proc;
} STDPROCDEF, *PSTDPROCDEF;
#endif
#define MAGIC_TREE_NUMBER 0x20040525
#define IS_TREE_MAGIC(tree)  (*((uint32_t*)(&(tree))) == (uint32_t)MAGIC_TREE_NUMBER )
#define MAGIC_LIST_NUMBER 0x20040911
#define IS_LIST_MAGIC(tree)  (*((uint32_t*)(&(tree))) == (uint32_t)MAGIC_LIST_NUMBER )
typedef struct tree_def_tag
{
////////
// this and "/blah/blah/blah" look the same
// to an application.  Therefore a name is as good
// as text... internally a pointer to this structure
// when CTEXTSTR and PTREEDEF are received through a
// CTEXTSTR parameter, the distinction can be made by
// examinging the first 4 characters... however!
// the string passed must be at least 4 bytes of
   // real memory.
  // magic number 0x20040525
	uint32_t Magic;
	union {
 // any option can have a tree of suboptions?
		PTREEROOT Tree;
			// a list of things may serve as lightweight alternative
		PLIST List;
	};
   POINTER cursor;
   struct proc_name_tag *self;
} TREEDEF, *PTREEDEF;
typedef struct tree_def_tag const * PCTREEDEF;
#define MAXTREEDEFSPERSET 256
DeclareSet( TREEDEF );
typedef struct data_class_def_tag
{
   uintptr_t size;
   OpenCloseNotification Open;
   OpenCloseNotification Close;
   INDEX unique;
   TREEDEF instances;
} DATADEF, *PDATADEF;
typedef struct name_def_tag
{
	// a member can have a string and a number
   // associated with it.
   CTEXTSTR sValue;
   uintptr_t iValue;
} NAMEDEF, *PNAMEDEF;
#ifdef __LINUX__
typedef  struct service_tag {
	pid_t pid;
	uint32_t Msg;
	// paramters...
} SERVICE, *PSERVICE;
#endif
typedef struct proc_name_tag
{
	struct {
 // really only important when saving the tree
		BIT_FIELD bAlias: 1;
		// each and every node may reference a tree
		// if it does, then the tree will be non-NULL
 // else it's a proc leef...
		BIT_FIELD bTree : 1;
 // name value points at a name
		BIT_FIELD bValue : 1;
 // and value is a uintptr_t integer...
		BIT_FIELD bIntVal : 1;
 // and value is a uintptr_t integer...
		BIT_FIELD bStringVal : 1;
 // name points at a function
		BIT_FIELD bProc : 1;
  // this might be fun to register names across msgsvr's
		BIT_FIELD bService : 1;
 // data member defines data..
		BIT_FIELD bData : 1;
 // is a (__stdcall *) instead of a (CPROC *)
		BIT_FIELD bStdProc : 1;
	} flags;
	CTEXTSTR name;
	TREEDEF   tree;
	struct {
		NAMEDEF    name;
		PROCDEF    proc;
#ifdef __cplusplus_cli
		STDPROCDEF stdproc;
#endif
		DATADEF    data;
#ifdef __LINUX__
		SERVICE    service;
#endif
	}data;
	PTREEDEF parent;
} NAME, *PNAME;
#define MAXNAMESPERSET 256
DeclareSet( NAME );
#define NAMESPACE_SIZE (4096 - sizeof( uint32_t ) - 2 * sizeof( POINTER ))
typedef struct namespace_tag
{
	uint32_t nextname;
	TEXTCHAR buffer[NAMESPACE_SIZE];
	DeclareLink( struct namespace_tag );
} NAMESPACE, *PNAMESPACE;
PROCREG_NAMESPACE_END
#endif
PROCREG_NAMESPACE
// using lower level syslog bypasses some allocation requirements...
//#define lprintf( f, ... ) { TEXTCHAR buf[256]; tnprintf( buf, 256, f,##__VA_ARGS__ ); SystemLogFL( buf DBG_SRC ); }
	static struct procreg_local_private_tag {
		// don't use critical sections while registering.
		struct {
			BIT_FIELD enable_critical_sections : 1;
		} flags;
	} procreg_local_private_data;
struct tmp_namebuf
{
	TEXTCHAR *buffer;
	size_t length;
};
struct procreg_local_tag {
	struct {
		BIT_FIELD bInterfacesLoaded : 1;
		BIT_FIELD bIndexNameTable : 1;
		// if neither of the next two are set, then the statement can be processed; both are cleared at endif
 // set if 'if' condition is false - SUPPORT 32 levels of if (more than 2 and you're crazy with this)
		BIT_FIELD bFindEndif : 5;
 // set if 'if' condition is false - SUPPORT 32 levels of if (more than 2 and you're crazy with this)
		BIT_FIELD bFindElse : 1;
		//BIT_FIELD bIfSuccess : 1; // set if 'if' condition is true
		BIT_FIELD bTraceInterfaceLoading : 1;
		BIT_FIELD bDisableMemoryLogging : 1;
 // having read the configuration file
		BIT_FIELD bReadConfiguration : 1;
		BIT_FIELD bHeldDeadstart : 1;
	} flags;
	PTREEDEF Names;
	PTREEROOT NameIndex;
	PTREEDEFSET TreeNodes;
	PNAMESET NameSet;
	PNAMESPACE NameSpace;
	PLIST TransationSpaces;
 // open group ID
	int translations;
	TEXTCHAR *config_filename;
	FILE *file;
	CRITICALSECTION csName;
	uint32_t simple_lock;
	PLINKQUEUE tmp_names;
	int reference_count;
	PLIST global_spaces;
	//gcroot<System::IO::FileStream^> fs;
};
#ifdef l
#   undef l
#endif
#define l (*procreg_local_data)
static struct procreg_local_tag *procreg_local_data;
static CTEXTSTR SaveName( CTEXTSTR name );
PTREEDEF GetClassTreeEx( PCTREEDEF root
										, PCTREEDEF name_class
										, PTREEDEF alias, LOGICAL bCreate );
#define GetClassTree( root, name_class ) GetClassTreeEx( root, name_class, NULL, TRUE )
//---------------------------------------------------------------------------
static int CPROC SavedNameCmpEx(CTEXTSTR dst, CTEXTSTR src, size_t srclen)
{
	// NUL does not nessecarily terminate strings
	// instead slave off the length...
	 TEXTCHAR f,last;
 // one for length, one for nul
	size_t l1 = srclen;
 // one for length, one for nul
	size_t l2 = dst[-1] - 2;
	// case insensitive loop..
	//lprintf( WIDE("Compare %s(%d) vs %s[%p](%d)"), src, l1, dst, dst, l2 );
	// interesting... first sort by length
	// and then by content?
	//if( l1 != l2 )
	 //  return l2-l1;
	do {
		if( (*src) == '\\' || (*src)=='/' )
		{
 // no more length .. should have gotten a matched length on dst...
			l1 = 0;
			break;
		}
		if ( ((f = (TEXTCHAR)(*(dst++))) >= 'A') && (f <= 'Z') )
			f -= ('A' - 'a');
		if ( ((last = (TEXTCHAR)(*(src++))) >= 'A') && (last <= 'Z') )
			last -= ('A' - 'a');
		--l2;
		--l1;
	} while ( l2 && l1 && (f == last) );
	//lprintf( WIDE("Results to compare...%d,%d  %c,%c"), l1, l2, f, last );
	// if up to the end of some portion of the strings matched...
	if( !f && !last )
	{
		return 0;
	}
	if( !l2 && !l1 )
	{
		return f-last;
	}
	if( f == last )
	{
		if( l2 && !l1 )
			return 1;
		if( l1 && !l2 )
			return -1;
	}
	return(f - last);
}
//---------------------------------------------------------------------------
static int CPROC SavedNameCmp(CTEXTSTR dst, CTEXTSTR src)
{
	//lprintf( WIDE("Compare names... (tree) %s,%s"), dst, src );
	if( !src && !dst )
		return 0;
	if( !src ) {
		DebugBreak();
		return 1;
	}
	if( !dst && src )
		return -1;
	return SavedNameCmpEx( dst, src, src[-1]-2 );
}
//---------------------------------------------------------------------------
static TEXTSTR StripName( TEXTSTR buf, CTEXTSTR name )
{
	TEXTSTR savebuf = buf;
	int escape = 0;
	if( !name )
	{
		buf[0] = 0;
		return buf;
	}
	while( name[0] )
	{
		if( name[0] == '\\' )
		{
			escape = 1;
		}
		else
		{
			// drop spaces...
			if( escape || ( name[0] > ' ' && name[0] < 127 ) )
			{
				*(buf++) = name[0];
			}
			escape = 0;
		}
		name++;
	}
	buf[0] = 0;
	return savebuf;
}
//---------------------------------------------------------------------------
static TEXTSTR GetFullName( CTEXTSTR name )
{
	int len;
	int out;
	int totlen = name[-1];
	TEXTSTR result;
	//for( len = 0; name[len] != 0 || name[len+1] != 0; len++ );
	result = NewArray( TEXTCHAR, totlen + 1);
	out = 0;
	for( len = 0; len < totlen; len++ )
		if( name[len] )
			result[out++] = name[len];
	result[out] = 0;
	return result;
}
//---------------------------------------------------------------------------
static CTEXTSTR DressName( TEXTSTR buf, CTEXTSTR name )
{
	TEXTSTR savebuf = buf;
	savebuf[0] = 2;
	buf++;
	if( !name )
	{
		savebuf[0] = 0;
		return buf;
	}
	while( name[0] )
	{
		if( name[0] == '/' || name[0] == '\\' )
			break;
		if( name[0] < ' ' || name[0] >= 127 )
		{
			savebuf[0]++;
			(*buf++) = '\\';
			savebuf[0]++;
			(*buf++) = name[0];
		}
		else
		{
			savebuf[0]++;
			(*buf++) = name[0];
		}
		name++;
	}
	buf[0] = 0;
	return savebuf + 1;
}
//---------------------------------------------------------------------------
static CTEXTSTR DoSaveNameEx( CTEXTSTR stripped, size_t len DBG_PASS )
#define DoSaveName(a,b) DoSaveNameEx(a,b DBG_SRC )
{
	PNAMESPACE space = l.NameSpace;
	TEXTCHAR *p;
	// cannot save 0 length strings.
	if( !stripped || !stripped[0] || !len )
	{
		//lprintf( WIDE("zero length string passed") );
		return NULL;
	}
	// otherwise it will be single threaded?
	if( procreg_local_private_data.flags.enable_critical_sections )
	{
#if USE_CUSTOM_ALLOCER
		EnterCriticalSec( &l.csName );
#else
		while( LockedExchange( &l.simple_lock, 1 ) )
			Relinquish();
#endif
	}
	if( l.flags.bIndexNameTable )
	{
		POINTER p;
		p = (POINTER)FindInBinaryTree( l.NameIndex, (uintptr_t)stripped );
		if( p )
		{
			// otherwise it will be single threaded?
			if( procreg_local_private_data.flags.enable_critical_sections )
			{
#if USE_CUSTOM_ALLOCER
				LeaveCriticalSec( &l.csName );
#else
				l.simple_lock = 0;
#endif
			}
			return ((CTEXTSTR)p);
		}
	}
	else
	{
		for( space = l.NameSpace; space; space = space->next )
		{
			p = space->buffer;
			while( p[0] && len )
			{
				//lprintf( WIDE("Compare %s(%d) vs %s(%d)"), p+1, p[0], stripped,len );
				if( SavedNameCmpEx( p+1, stripped, len ) == 0 )
				{
					// otherwise it will be single threaded?
					if( procreg_local_private_data.flags.enable_critical_sections )
					{
						l.simple_lock = 0;
						//LeaveCriticalSec( &l.csName );
					}
					return (CTEXTSTR)p+1;
				}
				p +=
#if defined( __ARM__ ) || defined( UNDER_CE )
					(
#endif
					 p[0]
#if defined( __ARM__ ) || defined( UNDER_CE )
					 +3 ) & 0xFC;
#endif
				;
			}
		}
	}
	for( space = l.NameSpace; space; space = space->next )
	{
		//lprintf( "Finding next name space free %p %p %p", l.NameSpace, space, space->next );
		if( ( space->nextname + len ) < ( NAMESPACE_SIZE - 3 ) )
		{
			p = NULL;
			break;
		}
	}
	if( !space || !p )
	{
		size_t alloclen;
		if( !space )
		{
			space = (PNAMESPACE)Allocate( sizeof( NAMESPACE ) );
			space->nextname = 0;
			//lprintf( "Adding new namespace %p", space );
			LinkThing( l.NameSpace, space );
		}
		MemCpy( p = space->buffer + space->nextname + 1, stripped,(uint32_t)(sizeof( TEXTCHAR)*(len + 1)) );
 // make sure we get a null terminator...
		p[len] = 0;
		// +2 1 for byte of len, 1 for nul at end.
		alloclen = (len + 2);
		space->buffer[space->nextname] = (TEXTCHAR)(alloclen);
		space->nextname += (uint32_t)alloclen;
		space->buffer[space->nextname] = 0;
#if defined( __ARM__ ) || defined( UNDER_CE )
		space->nextname = ( space->nextname + 3 ) & 0xFFFFC;
		// +3&0xFC rounds to next full dword segment
		// arm requires this name be aligned on a dword boundry
		// because later code references this as a DWORD value.
#endif
		if( l.flags.bIndexNameTable )
		{
			AddBinaryNode( l.NameIndex, p, (uintptr_t)p );
			BalanceBinaryTree( l.NameIndex );
		}
	}
	// otherwise it will be single threaded?
	if( procreg_local_private_data.flags.enable_critical_sections )
	{
#if USE_CUSTOM_ALLOCER
		LeaveCriticalSec( &l.csName );
#else
		l.simple_lock = 0;
#endif
	}
	return (CTEXTSTR)p;
}
//---------------------------------------------------------------------------
static CTEXTSTR SaveName( CTEXTSTR name )
{
	if( name )
	{
		size_t len = StrLen( name );
		struct tmp_namebuf *tmp_namebuf = (struct tmp_namebuf*)DequeLink( &l.tmp_names );
		TEXTSTR stripped;
		size_t n;
		if( !tmp_namebuf )
		{
			tmp_namebuf = New( struct tmp_namebuf );
			tmp_namebuf->length = len + 2;
			tmp_namebuf->buffer = NewArray( TEXTCHAR, len + 2 );
		}
		else
		{
			if( tmp_namebuf->length < ( len + 2 ) )
			{
				Release( tmp_namebuf->buffer );
				tmp_namebuf->length = len + 2;
				tmp_namebuf->buffer = NewArray( TEXTCHAR, len + 2 );
			}
		}
		stripped = tmp_namebuf->buffer;
		stripped[0] = (TEXTCHAR)(len + 2);
		for( n = 0; n < len; n++ )
			if( name[n] == '\\' || name[n] == '/' )
			{
				len = n;
				break;
			}
 // allow +1 length for null after string; otherwise strncpy dropps the nul early
		StrCpyEx( stripped + 1, name, len + 1 );
		stripped[0] = (TEXTCHAR)(len + 2);
		{
			CTEXTSTR result = DoSaveName( stripped + 1, len );
			EnqueLink( &l.tmp_names, tmp_namebuf );
			return result;
		}
	}
	return NULL;
}
//---------------------------------------------------------------------------
CTEXTSTR SaveNameConcatN( CTEXTSTR name1, ... )
#define SaveNameConcat(n1,n2) SaveNameConcatN( (n1),(n2),NULL )
{
	// space concat since that's eaten by strip...
	TEXTCHAR _stripbuffer[256];
	TEXTCHAR *stripbuffer = (_stripbuffer+1);
	size_t len = 0;
	CTEXTSTR namex;
	va_list args;
	va_start( args, name1 );
	for( namex = name1;
			 namex;
			 namex = va_arg( args, CTEXTSTR ) )
	{
		size_t newlen;
		// concat order for libraries is
		// args, return type, library, library_procname
		// this is appeneded to the key value FUNCTION
		//lprintf( WIDE("Concatting %s"), namex );
		newlen = StrLen( StripName( stripbuffer + len, namex ) );
		//if( newlen )
		newlen++;
		len += newlen;
	}
	_stripbuffer[0] = (TEXTCHAR)(len + 2);
	// and add another - final part of string is \0\0
	//stripbuffer[len] = 0;
	//len++;
	return DoSaveName( stripbuffer, len );
}
//---------------------------------------------------------------------------
CTEXTSTR SaveText( CTEXTSTR text )
#define SaveNameConcat(n1,n2) SaveNameConcatN( (n1),(n2),NULL )
{
	size_t len = StrLen( text );
	TEXTSTR stripped = NewArray( TEXTCHAR, len + 2 );
	CTEXTSTR result;
	StrCpyEx( stripped + 1, text, len + 1 );
	stripped[0] = (TEXTCHAR)(len + 2);
	result = DoSaveName( stripped + 1, len);
	Release( stripped );
	return result;
}
//---------------------------------------------------------------------------
static void CPROC KillName( CPOINTER user, uintptr_t key )
{
	PNAME name = (PNAME)user;
	if( name->tree.Tree )
	{
	}
	else if( name->flags.bValue )
	{
	}
	else if( name->flags.bProc )
	{
	}
	else if( name->flags.bData )
	{
	}
	//DeleteFromSet( NAME, l.TreeNodes, user );
}
//---------------------------------------------------------------------------
// p would be the global space, but it's also already set in it's correct spot
static void CPROC InitGlobalSpace( POINTER p, uintptr_t size )
{
	InitializeCriticalSec( &(*(struct procreg_local_tag*)p).csName );
	(*(struct procreg_local_tag*)p).Names = (PTREEDEF)GetFromSet( TREEDEF, &(*(struct procreg_local_tag*)p).TreeNodes );
	(*(struct procreg_local_tag*)p).Names->Magic = MAGIC_TREE_NUMBER;
	(*(struct procreg_local_tag*)p).Names->Tree = CreateBinaryTreeExx( BT_OPT_NODUPLICATES, (int(CPROC *)(uintptr_t,uintptr_t))SavedNameCmp, KillName );
	// enable name indexing.
	// if we have 500 names, 9 searches is much less than 250 avg
	(*(struct procreg_local_tag*)p).flags.bIndexNameTable = 1;
	(*(struct procreg_local_tag*)p).NameIndex = CreateBinaryTreeExx( BT_OPT_NODUPLICATES, (int(CPROC *)(uintptr_t,uintptr_t))SavedNameCmp, KillName );
	(*(struct procreg_local_tag*)p).reference_count++;
}
static void Init( void )
{
	// don't call this function, preserves the process line cache, just check the flag and simple skip any call.
	// use SAFE_INIT();
#define SAFE_INIT() if( !procreg_local_data ) SimpleRegisterAndCreateGlobalWithInit( procreg_local_data, InitGlobalSpace );
	SAFE_INIT();
}
static void ReadConfiguration( void );
//PRIORITY_UNLOAD( InitProcreg, NAMESPACE_PRELOAD_PRIORITY )
//{
	// release other members too, kindly
	//Deallocate( struct procreg_local_tag*, procreg_local_data );
	//procreg_local_data = NULL;
//}
PRIORITY_PRELOAD( InitProcReg2, SYSLOG_PRELOAD_PRIORITY )
{
	// this has to be done after timer's init is done, which is SYSLOG_PRELOAD_PRIORITY-1
	procreg_local_private_data.flags.enable_critical_sections = 1;
}
PRIORITY_PRELOAD( InitProcreg, NAMESPACE_PRELOAD_PRIORITY )
{
	Init();
#ifndef __NO_INTERFACE_SUPPORT__
#ifndef __NO_DEFAULT_INTERFACES__
	if( !l.flags.bReadConfiguration )
	{
		l.flags.bReadConfiguration = 1;
		ReadConfiguration();
	}
#endif
#endif
#ifndef __NO_OPTIONS__
	l.flags.bDisableMemoryLogging = SACK_GetProfileIntEx( GetProgramName(), WIDE("SACK/Process Registry/Disable Memory Logging"), 1, TRUE );
#else
	l.flags.bDisableMemoryLogging = 1;
#endif
}
//---------------------------------------------------------------------------
int GetClassPath( TEXTSTR out, size_t len, PCLASSROOT root )
{
	int ofs = 0;
	PLINKSTACK pls = CreateLinkStack();
	PTREEDEF current;
	PNAME name;
	for( current = (PTREEDEF)root; current->self && current; current = current->self->parent )
	{
		PushLink( &pls, current->self );
	}
	while( ( name = (PNAME)PopLink( &pls ) ) )
	{
		//pcr->
		ofs += tnprintf( out + ofs, len - ofs, WIDE("/%s"), name->name );
	}
	DeleteLinkStack( &pls );
	return ofs;
}
//---------------------------------------------------------------------------
static PTREEDEF AddClassTree( PCTREEDEF class_root, TEXTCHAR *name, PTREEROOT root, int bAlias )
{
	if( root && class_root )
	{
 //Allocate( sizeof( NAME ) );
		PNAME classname = GetFromSet( NAME, &l.NameSet );
		//MemSet( classname, 0, sizeof( NAME ) );
		classname->flags.bAlias = bAlias;
		classname->name = SaveName( name );
		classname->tree.Magic = MAGIC_TREE_NUMBER;
		classname->tree.Tree = root;
		classname->tree.self = classname;
		classname->flags.bTree = TRUE;
		classname->parent = (PTREEDEF)class_root;
		//lprintf( WIDE("Adding class tree thing %p  %s"), class_root->Tree, classname->name );
		if( !AddBinaryNode( class_root->Tree, classname, (uintptr_t)classname->name ) )
		{
			//Log( WIDE("For some reason could not add new class tree to tree!") );
			DeleteFromSet( NAME, l.NameSet, classname );
			return NULL;
		}
		return &classname->tree;
	}
	return NULL;
}
//---------------------------------------------------------------------------
static CTEXTSTR  my_pathchr ( CTEXTSTR path )
{
	CTEXTSTR end1, end2;
	end1 = StrChr( path, (int)'\\' );
	end2 = StrChr( path, (int)'/' );
	if( end1 && end2 )
	{
		if( end1 < end2 )
			return end1;
		return end2;
	}
	else if( end1 )
		return end1;
	else if( end2 )
		return end2;
	return NULL;
}
//---------------------------------------------------------------------------
// if name_class is NULL then root is returned.
// if name_class is not NULL then if name_class references
// PTREEDEF structure, then name_class is returned.
// if root is NULL then it is set to l.nmaes... if this library has
// never been initialized it will return NULL.
// if name_class does not previously exist, then it is created.
// There is no protection for someone to constantly create large trees just
// by asking for them.
PTREEDEF GetClassTreeEx( PCTREEDEF root, PCTREEDEF _name_class, PTREEDEF alias, LOGICAL bCreate )
{
	PCTREEDEF class_root;
	if( !root )
	{
		Init();
		root = (PCTREEDEF)l.Names;
// fix root...
	}
	class_root = root;
	if(
#if defined( __ARM__ ) || defined( UNDER_CE )
		// if its odd, it comes from the name space
		// (savename)
		(((uintptr_t)class_root)&0x3) ||
#endif
		(class_root->Magic != MAGIC_TREE_NUMBER) )
	{
		// if root name is passed as a NAME, then resolve it
		// assuming the root of all names as the root...
		class_root = GetClassTreeEx( l.Names, class_root, NULL, bCreate );
	}
	if( _name_class )
	{
		if(
#if defined( __ARM__ ) || defined( UNDER_CE )
	  // if its odd, it comes from the name space
		// (savename)
			 !(((uintptr_t)_name_class)&0x3) &&
#endif
			(_name_class->Magic == MAGIC_TREE_NUMBER) )
		{
			return (PTREEDEF)_name_class;
		}
		else
		{
			size_t buflen = 0;
			//TEXTCHAR *original;
			TEXTCHAR *end, *start;
			CTEXTSTR name_class = (CTEXTSTR)_name_class;
			size_t len = StrLen( name_class ) + 1;
			PNAME new_root;
			int retry = 0;
			if( len > buflen )
			{
				buflen = len + 32;
			}
			start = (TEXTCHAR*)name_class;
			do
			{
				end = (TEXTCHAR*)my_pathchr( start );
				do
				{
					if( end == start )
					{
						start = start+1;
						end = (TEXTCHAR*)my_pathchr( start );
						continue;
					}
					if( !end || ((my_pathchr(end+1) - end) != 1) )
						break;
					end++;
				}
				while( 1 );
				do
				{
					{
						// dress name terminates on a '/'
						TEXTCHAR buf[256];
						//lprintf( "Finding a..." );
						new_root = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, start ) );
						//lprintf( WIDE("Found %p %s(%d)=%s"), new_root, buf+1, buf[0], start );
					}
					if( !new_root )
					{
						if( !bCreate )
							return NULL;
						if( alias && !end )
						{
							// added name in this place name terminates on a '/'
							//lprintf( WIDE("name not found, adding...!end && alias") );
							class_root = AddClassTree( class_root
															 , start
															 , alias->Tree
															 , TRUE );
							((PTREEDEF)class_root)->self = alias->self;
						}
						else
						{
							PTREEDEF new_root;
							PTREEROOT tree;
							// added name in this place name terminates on a '/'
							// interesting note - while searching for
							// a member, branches are created.... should consider
							// perhaps offering an option to read for class root without creating
							// however it gives one an idea of what methods might be avaialable...
							//lprintf( WIDE("name not found, adding.. [%s] %s"), start, class_root->self?class_root->self->name:"." );
							new_root = AddClassTree( class_root
															 , start
															 , tree = CreateBinaryTreeExx( BT_OPT_NODUPLICATES
																						 , (int(CPROC *)(uintptr_t,uintptr_t))SavedNameCmp
																						 , KillName )
															 , FALSE
															 );
							if( !new_root )
							{
								// if this happens it was probably added while adding...
								DebugBreak();
								DestroyBinaryTree( tree );
								if( retry < 2 )
								{
									retry++;
									continue;
								}
#ifndef NO_LOGGING
								SystemLog( WIDE("Failed to register...") );
								lprintf( WIDE("name not found, adding.. [%s] %s"), start, class_root->self?class_root->self->name:WIDE(".") );
#endif
								return NULL;
							}
							class_root = new_root;
						}
					}
					else
					{
						if( !end && alias && !new_root->flags.bAlias )
						{
							static int error_count;
							error_count++;
							// this orphans the prior tree; but probably results from requests for values that aren't present
							// and later are filled by an alias.
							if( error_count > 20 )
								lprintf( WIDE( " Name %s exists, but we want it to be an alias, and it is not...(a LOT of this is bad) " ), new_root->name );
							if( new_root->tree.Magic != MAGIC_TREE_NUMBER )
								lprintf( WIDE( "Hell it's not even a tree!" ) );
							new_root->flags.bAlias = 1;
							new_root->tree.Tree = alias->Tree;
							new_root->tree.self = alias->self;
						}
						class_root = &new_root->tree;
					}
					break;
				} while( 1 );
				if( end )
					start = end + 1;
				else
					break;
			}
			while( class_root && start[0] );
		}
	}
	return (PTREEDEF)class_root;
}
//---------------------------------------------------------------------------
PROCREG_PROC( PCLASSROOT, CheckClassRoot )( CTEXTSTR name_class )
{
	return (PCLASSROOT)GetClassTreeEx( NULL, (PTREEDEF)name_class, NULL, FALSE );
}
//---------------------------------------------------------------------------
PROCREG_PROC( PCLASSROOT, GetClassRootEx )( PCLASSROOT root, CTEXTSTR name_class )
{
	return (PCLASSROOT)GetClassTreeEx( (PTREEDEF)root, (PTREEDEF)name_class, NULL, TRUE );
}
PROCREG_PROC( PCLASSROOT, GetClassRoot )( CTEXTSTR name_class )
{
	return (PCLASSROOT)GetClassTreeEx( l.Names, (PTREEDEF)name_class, NULL, TRUE );
}
#ifdef __cplusplus
PROCREG_PROC( PCLASSROOT, GetClassRootEx )( PCLASSROOT root, PCLASSROOT name_class )
{
	return GetClassTreeEx( root, (PTREEDEF)name_class, NULL, TRUE );
}
PROCREG_PROC( PCLASSROOT, GetClassRoot )( PCLASSROOT name_class )
{
	return GetClassTreeEx( l.Names, (PTREEDEF)name_class, NULL, TRUE );
}
#endif
//---------------------------------------------------------------------------
int AddNode( PTREEDEF class_root, POINTER data, uintptr_t key )
{
	if( class_root )
	{
		TEXTCHAR buf[256];
		PNAME oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, (CTEXTSTR)key ) );
		if( oldname )
		{
			//lprintf( WIDE("Name already in the tree... %s"), (CTEXTSTR)key );
			return FALSE;
		}
		else
		{
			//lprintf( WIDE("addnode? a data ndoe - create data structure") );
			if( !AddBinaryNode( class_root->Tree, data, key ) )
			{
				Log( WIDE("For some reason could not add new name to tree!") );
				return FALSE;
			}
		}
		return TRUE;
	}
	Log( WIDE("Nowhere to add the node...") );
	return FALSE;
}
//---------------------------------------------------------------------------
static int CPROC MyStrCmp( uintptr_t s1, uintptr_t s2 )
{
	//lprintf( WIDE("Compare (%s) vs (%s)"), s1, s2 );
	return StrCaseCmp( (TEXTCHAR*)s1, (TEXTCHAR*)s2 );
}
//---------------------------------------------------------------------------
#undef RegisterFunctionExx
PROCREG_PROC( LOGICAL, RegisterFunctionExx )( PCLASSROOT root
													 , PCLASSROOT name_class
													 , CTEXTSTR public_name
													 , CTEXTSTR returntype
													 , PROCEDURE proc
													 , CTEXTSTR args
													 , CTEXTSTR library
													 , CTEXTSTR real_name
													  DBG_PASS
													)
{
	if( root || name_class )
	{
//Allocate( sizeof( NAME ) );
		PNAME newname = GetFromSet( NAME, &l.NameSet );
		TEXTCHAR strippedargs[256];
		CTEXTSTR func_name = real_name?real_name:public_name;
		CTEXTSTR root_func_name = func_name;
		PTREEDEF class_root = (PTREEDEF)GetClassTree( (PCTREEDEF)root, (PCTREEDEF)name_class );
		int tmp;
		MemSet( newname, 0, sizeof( NAME ) );
		newname->flags.bProc = 1;
		// this is kinda messed up...
		newname->name = SaveName( public_name );
		newname->data.proc.library = SaveName( library );
		newname->data.proc.procname = SaveName( real_name );
		//newname->data.proc.ret = SaveName( returntype );
		for( tmp = 0; func_name[tmp]; tmp++ )
			if( func_name[tmp] == '/' ||
				func_name[tmp] == '\\' )
			{
				func_name = func_name + tmp + 1;
				tmp = -1;
			}
		if( func_name != root_func_name )
		{
			size_t len;
			TEXTSTR new_root_func_name = NewArray( TEXTCHAR, len = ( func_name - root_func_name ) );
			StrCpyEx( new_root_func_name, root_func_name, len );
			new_root_func_name[len-1] = 0;
			//lprintf( "trimmed name would be %s  /   %s", new_root_func_name, func_name );
			class_root = GetClassTree( (PCTREEDEF)class_root, (PCTREEDEF)new_root_func_name );
			Release( new_root_func_name );
		}
		//newname->data.proc.args = SaveName( StripName( strippedargs, args ) );
		newname->data.proc.name = SaveNameConcatN( StripName( strippedargs, args )
															  , returntype
															  , library?library:WIDE("_")
															  , func_name
															  , NULL
															  );
		newname->data.proc.proc = proc;
		if( class_root )
		{
			PNAME oldname;
			oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)newname->name);
			if( oldname )
			{
				if( !oldname->data.proc.proc )
				{
					// old branch location might have existed, but no value assigned...
					//lprintf( WIDE( "overloading prior %p with %p and %p with %p" )
					//		 , oldname->data.proc.proc, proc
					//		 , oldname->data.proc.name, newname->data.proc.name
					//		 );
					oldname->flags.bProc = 1;
					oldname->data.proc.proc = proc;
					oldname->data.proc.name = newname->data.proc.name;
					oldname->data.proc.library = newname->data.proc.library;
					oldname->data.proc.procname = newname->data.proc.procname;
					newname->data.proc.name = NULL;
				}
				else if( oldname->data.proc.proc == proc )
					Log( WIDE("And fortunatly it's the same address... all is well...") );
				else
				{
					TEXTSTR s1, s2;
#ifndef NO_LOGGING
					CTEXTSTR file = GetRegisteredValue( (CTEXTSTR)&oldname->tree, WIDE( "Source File" ) );
					int line = (int)(uintptr_t)GetRegisteredValueEx( (CTEXTSTR)&oldname->tree, WIDE( "Source Line" ), TRUE );
					_xlprintf( 2 DBG_RELAY)( WIDE("proc %s/%s regisry by %s of %s(%s) conflicts with %s(%d):%s(%s)...")
												  , (CTEXTSTR)name_class?(CTEXTSTR)name_class:WIDE("@")
												  , public_name?public_name:WIDE("@")
												  , newname->name
												  , s1 = GetFullName( newname->data.proc.name )
													//,library
												  , newname->data.proc.procname
												  , file
												  , line
												  , s2 = GetFullName( oldname->data.proc.name )
												  //,library
												  , oldname->data.proc.procname );
					Release( s1 );
					Release( s2 );
					// perhaps it's same in a different library...
					Log( WIDE("All is not well - found same function name in tree with different address. (ignoring second) ") );
#endif
				}
				DeleteFromSet( NAME, l.NameSet, newname );
				return TRUE;
			}
			else
			{
				if( !AddBinaryNode( class_root->Tree, (PCLASSROOT)newname, (uintptr_t)newname->name ) )
				{
					Log( WIDE("For some reason could not add new name to tree!") );
					DeleteFromSet( NAME, l.NameSet, newname );
					return FALSE;
				}
			}
			{
				//PTREEDEF root = GetClassRoot( newname );
				newname->parent = class_root;
				newname->tree.Magic = MAGIC_TREE_NUMBER;
 // dups okay BT_OPT_NODUPLICATES
				newname->tree.Tree = CreateBinaryTreeExx( 0
																	 , (int(CPROC *)(uintptr_t,uintptr_t))MyStrCmp
																	 , KillName );
#ifdef _DEBUG
				{
					CTEXTSTR name = pathrchr( pFile );
					// chop the trailing filename, removing path of filename.
					if( name )
						name++;
					else
						name = pFile;
					RegisterValue( (CTEXTSTR)&newname->tree, WIDE( "Source File" ), name );
					RegisterIntValue( (CTEXTSTR)&newname->tree, WIDE( "Source Line" ), nLine );
				}
#endif
			}
		}
		else
		{
			lprintf( WIDE("I'm relasing this name!?") );
			DeleteFromSet( NAME, l.NameSet, newname );
		}
		return 1;
	}
	return FALSE;
}
#ifdef __cplusplus
PROCREG_PROC( LOGICAL, RegisterFunctionExx )( CTEXTSTR root
													 , CTEXTSTR name_class
													 , CTEXTSTR public_name
													 , CTEXTSTR returntype
													 , PROCEDURE proc
													 , CTEXTSTR args
													 , CTEXTSTR library
													 , CTEXTSTR real_name
													  DBG_PASS
														  )
{
	return RegisterFunctionExx( (PCLASSROOT)root, (PCLASSROOT)name_class, public_name, returntype
	                          , proc, args, library, real_name DBG_RELAY );
}
#endif
//---------------------------------------------------------------------------
#if 0
int ReleaseRegisteredFunctionEx( PCLASSROOT root, CTEXTSTR name_class
							 , CTEXTSTR public_name
							 )
{
	PTREEDEF class_root = GetClassTree( root, (PCLASSROOT)name_class );
	TEXTCHAR buf[256];
	PNAME node = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, public_name ) );
	if( node )
	{
		if( node->flags.bProc )
		{
			UnloadFunction( &node->data.proc.proc );
			//node->data.proc.proc = NULL;
			node->flags.bProc = 0;
			return 1;
		}
	}
	return 0;
}
#endif
//---------------------------------------------------------------------------
PROCREG_PROC( int, RegisterProcedureExx )( PCLASSROOT root
														, CTEXTSTR name_class
														, CTEXTSTR public_name
														, CTEXTSTR returntype
														, CTEXTSTR library
														, CTEXTSTR name
														, CTEXTSTR args
														 DBG_PASS
														)
{
	//PROCEDURE proc = (PROCEDURE)LoadFunction( library, name );
	//if( proc )
	{
		return RegisterFunctionExx( root, (PCLASSROOT)name_class
		                          , public_name
		                          , returntype
		                          , NULL
		                          , args
		                          , library
		                          , name
		                          DBG_RELAY );
	}
   //return 0;
}
#undef RegisterProcedureEx
PROCREG_PROC( int, RegisterProcedureEx )( CTEXTSTR name_class
                                        , CTEXTSTR public_name
                                        , CTEXTSTR returntype
                                        , CTEXTSTR library
                                        , CTEXTSTR name
                                        , CTEXTSTR args
                                         DBG_PASS
                                        )
{
   return RegisterProcedureExx( NULL, name_class, public_name, returntype, library, name, args DBG_RELAY );
}
// used in dekware.
PROCREG_PROC( PROCEDURE, ReadRegisteredProcedureEx )( PCLASSROOT root
                                                    , CTEXTSTR returntype
                                                    , CTEXTSTR parms
                                                    )
{
	PTREEDEF class_root = GetClassTree( (PCTREEDEF)root, NULL );
	PNAME oldname = (PNAME)GetCurrentNodeEx( class_root->Tree, &class_root->cursor );
	if( oldname )
	{
		PROCEDURE proc = oldname->data.proc.proc;
		if( !proc && ( oldname->data.proc.library && oldname->data.proc.procname ) )
		{
			proc = (PROCEDURE)LoadFunction( oldname->data.proc.library
													, oldname->data.proc.procname );
			//lprintf( WIDE("Found a procedure %s=%p  (%p)"), name, oldname, proc );
			// should compare whether the types match...
			if( !proc )
			{
				Log( WIDE("Failed to load function when requested from tree...") );
			}
			oldname->data.proc.proc = proc;
		}
		return oldname->data.proc.proc;
	}
	return NULL;
}
//---------------------------------------------------------------------------
// can use the return type and args to validate the correct
// type of routine is called...
// name is not the function name, but rather the public/common name...
// this name may optionally include a # remark detailing more information
// about the name... the comparison of this name is done up to the #
// and data after a # is checked only if both values have a sub-comment.
// library name is not checked.
// this routine may find more than 1 routine which matches the given
// criteria.  return type and args may be NULL indicating a care-less
// approach.
void DumpRegisteredNamesWork( PTREEDEF tree, int level );
#undef GetRegisteredProcedureExx
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( PCLASSROOT root, PCLASSROOT name_class, CTEXTSTR returntype, CTEXTSTR name, CTEXTSTR args )
#define GetRegisteredProcedureExx GetRegisteredProcedureExxx
{
	PTREEDEF class_root = GetClassTreeEx( (PCTREEDEF)root, (PCTREEDEF)name_class, NULL, FALSE );
	if( class_root )
	{
		PNAME oldname;
		//TEXTCHAR buf[256];
		//lprintf( WIDE("Found class %s=%p for %s"), name_class, class_root, name );
		//DumpRegisteredNamesWork( class_root, 5 );
		oldname = (PNAME)LocateInBinaryTree( class_root->Tree, (uintptr_t)name, NULL );
		//oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, name ) );
		if( oldname )
		{
#if 0
			PROCEDURE proc = oldname->data.proc.proc;
			if( !proc && ( oldname->data.proc.library && oldname->data.proc.procname ) )
			{
				proc = (PROCEDURE)LoadFunction( oldname->data.proc.library
														, oldname->data.proc.procname );
				//lprintf( WIDE("Found a procedure %s=%p  (%p)"), name, oldname, proc );
				// should compare whether the types match...
				if( !proc )
				{
					Log( WIDE("Failed to load function when requested from tree...") );
				}
				oldname->data.proc.proc = proc;
			}
#endif
			return oldname->data.proc.proc;
		}
		//else
      //   lprintf( WIDE("Failed to find %s in the tree"), buf );
	}
	//lprintf( WIDE("Failed to find the class root...") );
	return NULL;
}
#ifdef __cplusplus
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( CTEXTSTR root, CTEXTSTR name_class, CTEXTSTR returntype, CTEXTSTR name, CTEXTSTR args )
{
   return GetRegisteredProcedureExxx( (PCLASSROOT)root, (PCLASSROOT)name_class, returntype, name, args );
}
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR returntype, CTEXTSTR name, CTEXTSTR args )
{
   return GetRegisteredProcedureExxx( (PCLASSROOT)root, (PCLASSROOT)name_class, returntype, name, args );
}
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( CTEXTSTR root, PCLASSROOT name_class, CTEXTSTR returntype, CTEXTSTR name, CTEXTSTR args )
{
   return GetRegisteredProcedureExxx( (PCLASSROOT)root, name_class, returntype, name, args );
}
#endif
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureEx )( PCLASSROOT name_class, CTEXTSTR returntype, CTEXTSTR name, CTEXTSTR args )
{
	Init();
   return GetRegisteredProcedureExx( (PCLASSROOT)l.Names, name_class, returntype, name, args );
}
#ifdef __cplusplus
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureEx )( CTEXTSTR name_class, CTEXTSTR returntype, CTEXTSTR name, CTEXTSTR args )
{
	Init();
   return GetRegisteredProcedureExx( l.Names, name_class, returntype, name, args );
}
#endif
//---------------------------------------------------------------------------
void DumpRegisteredNamesWork( PTREEDEF tree, int level )
{
	PNAME name;
	PVARTEXT pvt;
	PTEXT pText;
   POINTER data;
	int bLogging = 0;
#if 0
	if( level == 0 )
	{
		Init();
		lprintf( "Names %p  %p", l.Names, l.NameSpace );
	}
#endif
   if( l.flags.bDisableMemoryLogging )
		bLogging = SetAllocateLogging( FALSE );
   // at least save the create/destroy uselessness...
	if( !tree->Tree )
	{
		if( l.flags.bDisableMemoryLogging )
			SetAllocateLogging( bLogging );
		return;
	}
	pvt = VarTextCreateExx( 512, 1024 );
#if 0
	DumpTree( tree->Tree, NULL );
	lprintf( "Tree is %p %p", tree, tree->Tree );
#endif
	for( name = (PNAME)GetLeastNodeEx( tree->Tree, &data );
		  name;
		  name = (PNAME)GetGreaterNodeEx( tree->Tree, &data ) )
	{
		int n;
		for( n = 0; n < level; n++ )
			vtprintf( pvt, WIDE("   ") );
		vtprintf( pvt, WIDE("%s"), name->name );
		if( name->flags.bValue )
		{
			vtprintf( pvt, WIDE(" = ") );
			if( name->flags.bIntVal )
				vtprintf( pvt, WIDE("[%ld]"), name->data.name.iValue );
			if( name->flags.bStringVal )
				vtprintf( pvt, WIDE("\"%s\""), name->data.name.sValue );
			if( name->flags.bProc )
            vtprintf( pvt, WIDE("*%p"), name->data.proc.proc );
		}
		else if( name->flags.bProc )
		{
			CTEXTSTR p = name->data.proc.name;
			if( p )
			{
				size_t len = p[-1] - 2;
				vtprintf( pvt, WIDE(" = ") );
				while( len )
				{
					size_t tmp;
					vtprintf( pvt, WIDE("%s "), p );
					tmp = StrLen( p ) + 1;
					len-= tmp;
					p += tmp;
				}
				vtprintf( pvt, WIDE("*%p"), name->data.proc.proc );
			}
		}
		pText = VarTextGet( pvt );
		xlprintf(LOG_INFO)( WIDE("%s"), GetText( pText ) );
		LineRelease( pText );
		DumpRegisteredNamesWork( &name->tree, level + 1 );
	}
	VarTextDestroy( &pvt );
	if( l.flags.bDisableMemoryLogging )
		SetAllocateLogging( bLogging );
}
//---------------------------------------------------------------------------
struct browse_index
{
	PTREEDEF current_limbs;
	PTREEDEF current_branch;
};
PROCREG_PROC( int, NameHasBranches )( PCLASSROOT *data )
{
	PTREEDEF class_root;
	PNAME name;
	class_root = (PTREEDEF)*data;
	name = (PNAME)GetCurrentNodeEx( class_root->Tree, &class_root->cursor );
 // may also have a value, but it was created as a path node in the tree
	return name->flags.bTree;
}
int NewNameIsAlias( PCLASSROOT *data )
{
	struct browse_index *class_root = (struct browse_index*)(*data);
	PNAME name;
	name = (PNAME)GetCurrentNodeEx( class_root->current_branch->Tree, &class_root->current_branch->cursor );
 // may also have a value, but it was created as a path node in the tree
	return name->flags.bAlias;
}
int NameIsAlias( PCLASSROOT *data )
{
	PTREEDEF class_root;
	PNAME name;
	class_root = (PTREEDEF)*data;
	name = (PNAME)GetCurrentNodeEx( class_root->Tree, &class_root->cursor );
 // may also have a value, but it was created as a path node in the tree
	return name->flags.bAlias;
}
PROCREG_PROC( PCLASSROOT, GetCurrentRegisteredTree )( PCLASSROOT *data )
{
	PTREEDEF class_root;
	PNAME name;
	class_root = (PTREEDEF)*data;
	name = (PNAME)GetCurrentNodeEx( class_root->Tree, &class_root->cursor );
	if( name )
		return (PCLASSROOT)&name->tree;
	return NULL;
}
//---------------------------------------------------------------------------
PROCREG_PROC( CTEXTSTR, GetFirstRegisteredNameEx )( PCLASSROOT root, CTEXTSTR classname, PCLASSROOT *data )
{
	PTREEDEF class_root;
	PNAME name;
	*data =
		(PCLASSROOT)(class_root = (PTREEDEF)GetClassTree( (PCTREEDEF)root, (PCTREEDEF)classname ));
	if( class_root )
	{
		name = (PNAME)GetLeastNodeEx( class_root->Tree, &class_root->cursor );
		if( name )
		{
			//lprintf( WIDE("Resulting first name: %s"), name->name );
			return name->name;
		}
	}
	return NULL;
}
PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( CTEXTSTR classname, PCLASSROOT *data )
{
	return GetFirstRegisteredNameEx( NULL, classname, data );
}
#ifdef __cplusplus
PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( PCLASSROOT classname, PCLASSROOT *data )
{
	return GetFirstRegisteredNameEx( NULL, (CTEXTSTR)classname, data );
}
#endif
//---------------------------------------------------------------------------
PROCREG_PROC( CTEXTSTR, GetNextRegisteredName )( PCLASSROOT *data )
{
	PTREEDEF class_root;
	PNAME name;
	class_root = (PTREEDEF)*data;
	if( class_root )
	{
		name = (PNAME)GetGreaterNodeEx( class_root->Tree, &class_root->cursor );
		if( name )
		{
			//lprintf( WIDE("Resulting next name: %s"), name->name );
			return name->name;
		}
	}
	return NULL;
}
//---------------------------------------------------------------------------
PROCREG_PROC( void, DumpRegisteredNames )( void )
{
	if( l.Names )
		DumpRegisteredNamesWork( l.Names, 0 );
}
//---------------------------------------------------------------------------
PROCREG_PROC( void, DumpRegisteredNamesFrom )( PCLASSROOT root )
{
	DumpRegisteredNamesWork( GetClassTreeEx( l.Names, (PCTREEDEF)root, NULL, TRUE ), 0 );
}
//---------------------------------------------------------------------------
PROCREG_PROC( void, InvokeProcedure )( void )
{
}
//---------------------------------------------------------------------------
PROCREG_PROC( int, RegisterValueExx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal, CTEXTSTR value )
{
	PTREEDEF class_root = GetClassTree( (PCTREEDEF)root, (PCTREEDEF)name_class );
	if( class_root )
	{
		TEXTCHAR buf[256];
		PNAME oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, name ) );
		//lprintf( "... existed? %p", oldname );
		if( oldname )
		{
 // it is now a value, okay?
			oldname->flags.bValue = 1;
			if( bIntVal )
			{
				oldname->flags.bIntVal = 1;
				oldname->data.name.iValue = (uintptr_t)value;
			}
			else
			{
				oldname->flags.bStringVal = 1;
				oldname->data.name.sValue = SaveName( value );
			}
		}
		else
		{
 //Allocate( sizeof( NAME ) );
			PNAME newname = GetFromSet( NAME, &l.NameSet );
			//MemSet( newname, 0, sizeof( NAME ) );
			if( name )
				newname->name = SaveName( name );
			newname->flags.bValue = 1;
			newname->parent = class_root;
			if( bIntVal )
			{
				newname->flags.bIntVal = 1;
				newname->data.name.iValue = (uintptr_t)value;
			}
			else
			{
				newname->flags.bStringVal = 1;
 //StrDup( value );
				newname->data.name.sValue = SaveName( value );
			}
			//lprintf( "... adding %s (%s)", name, newname->name );
			if( !AddBinaryNode( class_root->Tree, newname, (uintptr_t)newname->name ) )
			{
				lprintf( WIDE("Failed to add name to tree...%s"), name );
			}
		}
		return TRUE;
	}
	return FALSE;
}
PROCREG_PROC( int, RegisterValueEx )( CTEXTSTR name_class, CTEXTSTR name, int bIntVal, CTEXTSTR value )
{
	Init();
	return RegisterValueExx( (PCLASSROOT)l.Names, name_class, name, bIntVal, value );
}
//---------------------------------------------------------------------------
PROCREG_PROC( int, RegisterValue )( CTEXTSTR name_class, CTEXTSTR name, CTEXTSTR value )
{
	return RegisterValueEx( name_class, name, FALSE, value );
}
//---------------------------------------------------------------------------
PROCREG_PROC( int, RegisterIntValueEx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, uintptr_t value )
{
	return RegisterValueExx( root, name_class, name, TRUE, (CTEXTSTR)value );
}
PROCREG_PROC( int, RegisterIntValue )( CTEXTSTR name_class, CTEXTSTR name, uintptr_t value )
{
	return RegisterValueEx( name_class, name, TRUE, (CTEXTSTR)value );
}
//---------------------------------------------------------------------------
int GetRegisteredStaticValue( PCLASSROOT root, CTEXTSTR name_class
									 , CTEXTSTR name
									 , CTEXTSTR *result
									 , int bIntVal )
{
	PTREEDEF class_root = GetClassTree( (PCTREEDEF)root, (PCTREEDEF)name_class );
	TEXTCHAR buf[256];
	PNAME oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, name ));
	if( oldname )
	{
		if( bIntVal )
		{
			*((int*)result) = (int)oldname->data.name.iValue;
			return TRUE;
		}
		else if( oldname->flags.bStringVal )
		{
			(*result) = oldname->data.name.sValue;
			return TRUE;
		}
	}
	return FALSE;
}
//---------------------------------------------------------------------------
PROCREG_PROC( CTEXTSTR, GetRegisteredValueExx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal )
{
	PTREEDEF class_root;
	TEXTCHAR buf[256];
	PNAME oldname;
	class_root = GetClassTree( (PCTREEDEF)root, (PCTREEDEF)name_class );
	oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, name ));
	if( oldname )
	{
		if( bIntVal )
			return (CTEXTSTR)oldname->data.name.iValue;
		else if( oldname->flags.bStringVal )
			return oldname->data.name.sValue;
	}
	return NULL;
}
#ifdef __cplusplus
PROCREG_PROC( CTEXTSTR, GetRegisteredValueExx )( CTEXTSTR root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal )
{
	return GetRegisteredValueExx( (PCLASSROOT)root, name_class, name, bIntVal );
}
#endif
PROCREG_PROC( CTEXTSTR, GetRegisteredValueEx )( CTEXTSTR name_class, CTEXTSTR name, int bIntVal )
{
	Init();
	return GetRegisteredValueExx( (PCLASSROOT)l.Names, name_class, name, bIntVal );
}
//---------------------------------------------------------------------------
PROCREG_PROC( CTEXTSTR, GetRegisteredValue )( CTEXTSTR name_class, CTEXTSTR name )
{
	return GetRegisteredValueEx( name_class, name, FALSE );
}
//---------------------------------------------------------------------------
PROCREG_PROC( int, GetRegisteredIntValue )( CTEXTSTR name_class, CTEXTSTR name )
{
/*
 * this has a warning - typecast to value of differnet size.
 * this is OK.  the value originates as an 'int' and is typecast to a
 * CTEXTSTR which this then down converts back to 'int'
 */
	return (int)(uintptr_t)GetRegisteredValueEx( (CTEXTSTR)name_class, name, TRUE );
}
PROCREG_PROC( int, GetRegisteredIntValueEx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name )
{
/*
 * this has a warning - typecast to value of differnet size.
 * this is OK.  the value originates as an 'int' and is typecast to a
 * CTEXTSTR which this then down converts back to 'int'
 */
	return (int)(uintptr_t)GetRegisteredValueExx( root, name_class, name, TRUE );
}
#ifdef __cplusplus
PROCREG_PROC( int, GetRegisteredIntValue )( PCLASSROOT name_class, CTEXTSTR name )
{
/*
 * this has a warning - typecast to value of differnet size.
 * this is OK.  the value originates as an 'int' and is typecast to a
 * CTEXTSTR which this then down converts back to 'int'
 */
	return (int)(uintptr_t)GetRegisteredValueEx( (CTEXTSTR)name_class, name, TRUE );
}
#endif
//---------------------------------------------------------------------------
PROCREG_PROC( PCLASSROOT, RegisterClassAliasEx )( PCLASSROOT root, CTEXTSTR original, CTEXTSTR alias )
{
	PTREEDEF class_root = GetClassTreeEx( (PCTREEDEF)root, (PCTREEDEF)original, NULL, TRUE );
	return (PCLASSROOT)GetClassTreeEx( (PCTREEDEF)root, (PCTREEDEF)alias, class_root, TRUE );
}
//---------------------------------------------------------------------------
PROCREG_PROC( PCLASSROOT, RegisterClassAlias )( CTEXTSTR original, CTEXTSTR alias )
{
	Init();
	return (PCLASSROOT)RegisterClassAliasEx( (PCLASSROOT)l.Names, original, alias );
}
//---------------------------------------------------------------------------
PROCREG_PROC( uintptr_t, RegisterDataTypeEx )( PCLASSROOT root
												 , CTEXTSTR classname
												 , CTEXTSTR name
												 , uintptr_t size
												 , void (CPROC *Open)(POINTER,uintptr_t)
												 , void (CPROC *Close)(POINTER,uintptr_t) )
{
	PTREEDEF class_root = GetClassTreeEx( (PCTREEDEF)root, (PCTREEDEF)classname, NULL, TRUE );
	if( class_root )
	{
 //(PNAME)Allocate( sizeof( NAME ) );
		PNAME pName = GetFromSet( NAME, &l.NameSet );
		//MemSet( pName, 0, sizeof( NAME ) );
		pName->flags.bData = 1;
		pName->name = SaveName( name );
		pName->data.data.Open = Open;
		pName->data.data.Close = Close;
		pName->data.data.size = size;
		pName->data.data.instances.Magic = MAGIC_TREE_NUMBER;
 // dups okay BT_OPT_NODUPLICATES
		pName->data.data.instances.Tree = CreateBinaryTreeExx( 0
														, (int(CPROC *)(uintptr_t,uintptr_t))MyStrCmp
														, KillName );
		pName->parent = class_root;
		if( !AddNode( class_root, pName, (uintptr_t)pName->name ) )
		{
			DeleteFromSet( NAME, l.NameSet, pName );
 // NULL
			return 0;
		}
		return (uintptr_t)pName;
	}
 // NULL
	return 0;
}
PROCREG_PROC( uintptr_t, RegisterDataType )( CTEXTSTR classname
												 , CTEXTSTR name
												 , uintptr_t size
												 , void (CPROC *Open)(POINTER,uintptr_t)
												 , void (CPROC *Close)(POINTER,uintptr_t) )
{
	Init();
	return RegisterDataTypeEx( (PCLASSROOT)l.Names, classname, name, size, Open, Close );
}
//---------------------------------------------------------------------------
PROCREG_PROC( uintptr_t, MakeRegisteredDataTypeEx)( PCLASSROOT root
																 , CTEXTSTR classname
																 , CTEXTSTR name
																 , CTEXTSTR instancename
																 , POINTER data
																 , uintptr_t datasize
																 )
{
	PTREEDEF class_root = GetClassTree( (PCTREEDEF)root, (PCTREEDEF)classname );
	if( class_root )
	{
		TEXTCHAR buf[256];
		PNAME pName = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, name ));
		if( !pName )
			pName = (PNAME)RegisterDataTypeEx( root, classname, name, datasize, NULL, NULL );
		if( pName && pName->flags.bData )
		{
			PDATADEF pDataDef = &pName->data.data;
			if( pDataDef )
			{
				if( !instancename )
				{
					TEXTCHAR buf[256];
					tnprintf( buf, sizeof(buf), WIDE("%s_%d"), name, (int)pDataDef->unique++ );
					instancename = SaveName( buf );
				}
				else
					instancename = SaveName( instancename );
				{
					// look up prior instance...
					if( !FindInBinaryTree( pDataDef->instances.Tree, (uintptr_t)instancename ) )
					{
						AddBinaryNode( pDataDef->instances.Tree
										 , data
										 , (uintptr_t)instancename );
					}
					else
					{
						lprintf( WIDE("Suck. We just created one externally, and want to use that data, but it already exists.") );
						DumpRegisteredNames();
						DebugBreak();
						// increment instances referenced so that close does not
						// destroy - fortunatly this is persistant data, and therefore
						// doesn't get destroyed yet.
					}
					return (uintptr_t)data;
				}
			}
		}
		else
		{
			lprintf( WIDE("No such struct defined: %s"), name );
		}
	}
	return 0;
}
//---------------------------------------------------------------------------
PROCREG_PROC( uintptr_t, CreateRegisteredDataTypeEx)( PCLASSROOT root
																	, CTEXTSTR classname
																	, CTEXTSTR name
																	, CTEXTSTR instancename )
{
	PTREEDEF class_root = GetClassTree( (PCTREEDEF)root, (PCTREEDEF)classname );
	if( class_root )
	{
		TEXTCHAR buf[256];
		PNAME pName = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, name ));
		if( pName && pName->flags.bData )
		{
			PDATADEF pDataDef = &pName->data.data;
			if( pDataDef )
			{
				if( !instancename )
				{
					TEXTCHAR buf[256];
					tnprintf( buf, sizeof(buf), WIDE("%s_%d"), name, (int)pDataDef->unique++ );
					instancename = SaveName( buf );
				}
				else
					instancename = SaveName( instancename );
				{
					POINTER p;
					// look up prior instance...
					if( !( p = (POINTER)FindInBinaryTree( pDataDef->instances.Tree, (uintptr_t)instancename ) ) )
					{
#ifdef DEBUG_GLOBAL_REGISTRATION
						lprintf( WIDE( "Allocating new struct data :%" )_32f, pDataDef->size );
#endif
						p = Allocate( pDataDef->size + sizeof( PLIST ) );
						((PLIST*)p)[0] = NULL;
						p = (POINTER)( ((uintptr_t)p) + sizeof( PLIST ) );
						MemSet( p, 0, pDataDef->size );
						if( pDataDef->Open )
							pDataDef->Open( p, pDataDef->size );
						AddBinaryNode( pDataDef->instances.Tree
										 , p
										 , (uintptr_t)instancename );
					}
					else
					{
						// registered one, returned, needs to be offset for hold purposes.
						POINTER tmp_p = (POINTER)( (uintptr_t)p - sizeof( PLIST ) );
						Hold( tmp_p );
#ifdef DEBUG_GLOBAL_REGISTRATION
						lprintf( WIDE("Resulting with previuosly created instance.") );
						// increment instances referenced so that close does not
						// destroy - fortunatly this is persistant data, and therefore
						// doesn't get destroyed yet.
#endif
					}
					return (uintptr_t)p;
				}
			}
		}
#ifdef DEBUG_GLOBAL_REGISTRATION
		else
		{
			lprintf( WIDE("No such struct defined:[%s]%s"), classname, name );
		}
#endif
	}
	return 0;
}
//---------------------------------------------------------------------------
PROCREG_PROC( uintptr_t, CreateRegisteredDataType)( CTEXTSTR classname
																 , CTEXTSTR name
																 , CTEXTSTR instancename )
{
	Init();
	return CreateRegisteredDataTypeEx( (PCLASSROOT)l.Names, classname, name, instancename );
}
//---------------------------------------------------------------------------
typedef POINTER (CPROC *LOADPROC)( void );
typedef void	 (CPROC *UNLOADPROC)( POINTER );
//-----------------------------------------------------------------------
LOGICAL RegisterInterface( CTEXTSTR servicename, POINTER(CPROC*load)(void), void(CPROC*unload)(POINTER))
{
	//PARAM( args, TEXTCHAR*, servicename );
	//PARAM( args, TEXTCHAR*, library );
	//PARAM( args, TEXTCHAR*, load_proc_name );
	//PARAM( args, TEXTCHAR*, unload_proc_name );
	PCLASSROOT pcr = GetClassRoot( WIDE("system/interfaces") );
	if( GetRegisteredProcedureExx( pcr, (PCLASSROOT)servicename, WIDE("POINTER"), WIDE("load"), WIDE("void") ) )
	{
		lprintf( WIDE("Service: %s has multiple definitions, will use last first.")
				 , servicename );
		return FALSE;
	}
	//lprintf( WIDE("Registering library l:%p ul:%p"), load, unload );
	{
		RegisterFunctionExx( pcr
								  , (PCLASSROOT)servicename
								  , WIDE("load")
								  , WIDE("POINTER")
								  , (PROCEDURE)load
								  , WIDE("(void)"), NULL, NULL DBG_SRC );
		RegisterFunctionExx( pcr
								  , (PCLASSROOT)servicename
								  , WIDE("unload")
								  , WIDE("void")
								  , (PROCEDURE)unload
								  , WIDE("(POINTER)"), NULL, NULL DBG_SRC );
	}
	return TRUE;
}
//-----------------------------------------------------------------------
#ifndef __NO_INTERFACE_SUPPORT__
static uintptr_t CPROC HandleLibrary( uintptr_t psv, arg_list args )
{
	PARAM( args, TEXTCHAR*, servicename );
	PARAM( args, TEXTCHAR*, library );
	PARAM( args, TEXTCHAR*, load_proc_name );
	PARAM( args, TEXTCHAR*, unload_proc_name );
	PCLASSROOT pcr = GetClassRoot( WIDE("system/interfaces") );
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
	if( GetRegisteredProcedureExx( pcr, (PCLASSROOT)servicename, WIDE("POINTER"), WIDE("load"), WIDE("void") ) )
	{
		lprintf( WIDE("Service: %s has multiple definitions, will use last first.")
				 , servicename );
		return psv;
	}
	//lprintf( WIDE("Registering library %s function %s"), library, load_proc_name );
	{
		RegisterProcedureExx( pcr
		                    , servicename
		                    , WIDE("load")
		                    , WIDE("POINTER")
		                    , library
		                    , load_proc_name
		                    , WIDE("void") DBG_SRC );
		RegisterProcedureExx( pcr
		                    , servicename
		                    , WIDE("unload")
		                    , WIDE("void")
		                    , library
		                    , unload_proc_name, WIDE("POINTER") DBG_SRC );
	}
	return psv;
}
//-----------------------------------------------------------------------
static uintptr_t CPROC HandleAlias( uintptr_t psv, arg_list args )
{
	PARAM( args, TEXTCHAR*, servicename );
	PARAM( args, TEXTCHAR*, originalname );
	TEXTCHAR fullservicename[256];
	TEXTCHAR fulloriginalname[256];
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
	if( l.flags.bTraceInterfaceLoading )
		lprintf( WIDE( "alias %s=%s" ), servicename, originalname );
	tnprintf( fullservicename, sizeof( fullservicename), WIDE("system/interfaces/%s"), servicename );
	tnprintf( fulloriginalname, sizeof( fulloriginalname), WIDE("system/interfaces/%s"), originalname );
	RegisterClassAlias( fulloriginalname, fullservicename );
	return psv;
}
//-----------------------------------------------------------------------
static uintptr_t CPROC HandleModule( uintptr_t psv, arg_list args )
{
	PARAM( args, TEXTCHAR*, module );
	LOGICAL tempPath = FALSE;
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
	if( module[0] == '~' || module[0] == '@' || module[0] == '^' || module[0] == '*' ) {
		module = ExpandPath( module );
		tempPath = TRUE;
	}
	if( l.flags.bTraceInterfaceLoading )
		lprintf( WIDE( "load module %s" ), module );
	if( !l.flags.bHeldDeadstart )
	{
		l.flags.bHeldDeadstart = 1;
		SuspendDeadstart();
	}
	LoadFunction( module, NULL );
	if( tempPath )
		Deallocate( TEXTCHAR*, module );
	return psv;
}
//-----------------------------------------------------------------------
static uintptr_t CPROC HandlePrivateModule( uintptr_t psv, arg_list args )
{
	PARAM( args, TEXTCHAR*, module );
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
	if( l.flags.bTraceInterfaceLoading )
		lprintf( WIDE( "load private module %s" ), module );
	if( !l.flags.bHeldDeadstart )
	{
		l.flags.bHeldDeadstart = 1;
		SuspendDeadstart();
	}
	LoadPrivateFunction( module, NULL );
	return psv;
}
//-----------------------------------------------------------------------
static TEXTSTR SubstituteNameVars( CTEXTSTR name )
{
	PVARTEXT pvt = VarTextCreate();
	const TEXTCHAR *start = name;
	const TEXTCHAR *this_var = name;
	const TEXTCHAR *end;
	while( ( this_var = StrChr( start, '%' ) ) )
	{
		// allow specifying %% for a single %.
		// emit the stuff from start to the variable
		if( start < this_var )
			vtprintf( pvt, WIDE("%*.*s"), this_var-start, this_var-start, start );
		if( this_var[1] == '%' )
		{
			VarTextAddCharacter( pvt, '%' );
			start = this_var + 2;
			continue;
		}
		end = StrChr( this_var + 1, '%' );
		if( end )
		{
			TEXTCHAR *tmpvar = NewArray( TEXTCHAR, end - this_var );
			CTEXTSTR envvar;
			tnprintf( tmpvar, end-this_var, WIDE("%*.*s"), (int)(end-this_var-1), (int)(end-this_var-1), this_var + 1 );
			envvar = OSALOT_GetEnvironmentVariable( tmpvar );
			if( envvar )
				vtprintf( pvt, WIDE("%s"), OSALOT_GetEnvironmentVariable( tmpvar ) );
			else
				lprintf( WIDE("failed to find environment variable '%s'"), tmpvar );
			Release( tmpvar );
			start = end + 1;
		}
		else
			lprintf( WIDE("Bad framing on environment variable %%var%% syntax got [%s]"), start );
	}
	if( start[0] )
		vtprintf( pvt, WIDE("%s"), start );
	{
		TEXTSTR result = StrDup( GetText( VarTextPeek( pvt ) ) );
		VarTextDestroy( &pvt );
		return result;
	}
}
//-----------------------------------------------------------------------
static uintptr_t CPROC HandleModulePath( uintptr_t psv, arg_list args )
{
	PARAM( args, TEXTSTR, filepath );
	filepath = ExpandPath( filepath );
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
# ifdef __LINUX__
	OSALOT_AppendEnvironmentVariable( WIDE("LD_LIBRARY_PATH"), filepath );
# else
#  ifndef UNDER_CE
	OSALOT_AppendEnvironmentVariable( WIDE("PATH"), filepath );
#  endif
# endif
	Release( filepath );
	return psv;
}
PROCREG_PROC( void, SetInterfaceConfigFile )( TEXTCHAR *filename )
{
	if( l.config_filename )
		Release( l.config_filename );
	l.config_filename = StrDup( filename );
}
static uintptr_t CPROC SetDefaultDirectory( uintptr_t psv, arg_list args )
{
#ifndef __NO_OPTIONS__
	PARAM( args, CTEXTSTR, path );
	SetCurrentPath( path );
#endif
	return psv;
}
static uintptr_t CPROC SetOptionDefault( uintptr_t psv, arg_list args )
{
#ifndef __NO_OPTIONS__
	PARAM( args, TEXTSTR, key );
	PARAM( args, CTEXTSTR, value );
	TEXTCHAR buf[256];
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
	if( key[0] != '/' && key[0] != '\\' )
	{
		if( l.flags.bTraceInterfaceLoading )
			lprintf( WIDE( "Default Option %s / [%s] = [%s}" ), GetProgramName(), key, value );
		key = SubstituteNameVars( key );
		SACK_GetProfileStringEx( GetProgramName(), key, value, buf, sizeof( buf ), TRUE );
		Release( key );
	}
	else
	{
		TEXTSTR optpath = (TEXTSTR)pathchr( key + 1 );
		TEXTSTR optname = (TEXTSTR)pathrchr( key );
		optname[0] = 0;
		optname++;
		optpath[0] = 0;
		optpath++;
		optname = SubstituteNameVars( optname );
		optpath = SubstituteNameVars( optpath );
		if( l.flags.bTraceInterfaceLoading )
			lprintf( WIDE( "Default Option [%s]/[%s]/[%s] = [%s}" ), key, optpath, optname, value );
		SACK_GetPrivateProfileStringEx( optpath, optname, value, buf, sizeof( buf ), key, TRUE );
		Release( optname );
		Release( optpath );
	}
#endif
	return psv;
}
static uintptr_t CPROC SetOptionSet( uintptr_t psv, arg_list args )
{
#ifndef __NO_OPTIONS__
	PARAM( args, TEXTSTR, key );
	PARAM( args, CTEXTSTR, value );
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
	if( key[0] != '/' && key[0] != '\\' )
	{
		if( l.flags.bTraceInterfaceLoading )
			lprintf( WIDE( "Set Option %s / [%s] = [%s}" ), GetProgramName(), key, value );
		key = SubstituteNameVars( key );
		SACK_WriteProfileStringEx( GetProgramName(), key, value, key, TRUE );
		Release( key );
	}
	else
	{
		TEXTSTR optpath = (TEXTSTR)pathchr( key + 1 );
		TEXTSTR optname = (TEXTSTR)pathrchr( key );
		optname[0] = 0;
		optname++;
		optpath[0] = 0;
		optpath++;
		optname = SubstituteNameVars( optname );
		optpath = SubstituteNameVars( optpath );
		if( l.flags.bTraceInterfaceLoading )
			lprintf( WIDE( "Set Option [%s]/[%s]/[%s] = [%s}" ), key, optpath, optname, value );
		SACK_WritePrivateProfileStringEx( optpath, optname, value, key, TRUE );
		Release( optname );
		Release( optpath );
	}
#endif
	return psv;
}
static uintptr_t CPROC TestOption( uintptr_t psv, arg_list args )
{
#ifndef __NO_OPTIONS__
	PARAM( args, CTEXTSTR, key );
	PARAM( args, CTEXTSTR, value );
	TEXTCHAR buf[256];
	SACK_GetProfileStringEx( GetProgramName(), key, WIDE( "" ), buf, sizeof( buf ), TRUE );
	if( l.flags.bTraceInterfaceLoading )
		lprintf( WIDE( " is [%s] == [%s]  buf = [%s]" ), key, value, buf );
	if( buf[0] == 0 )
	{
		l.flags.bFindEndif++;
		l.flags.bFindElse = 1;
	}
	else if( StrCaseCmp( buf, value ) != 0 )
	{
		l.flags.bFindEndif++;
		l.flags.bFindElse = 1;
	}
	if( l.flags.bTraceInterfaceLoading )
		lprintf( WIDE( "seek(findendif, findelse) = %d %d" ), l.flags.bFindEndif, l.flags.bFindElse );
#endif
	return psv;
}
static uintptr_t CPROC EndTestOption( uintptr_t psv, arg_list args )
{
	if( l.flags.bTraceInterfaceLoading )
		lprintf( WIDE( "found endif..." ) );
	if(l.flags.bFindEndif)
	{
		l.flags.bFindEndif--;
		l.flags.bFindElse = 0;
	}
	return psv;
}
static uintptr_t CPROC ElseTestOption( uintptr_t psv, arg_list args )
{
	if( l.flags.bTraceInterfaceLoading )
		lprintf( WIDE( "found else..." ) );
	if(l.flags.bFindElse)
	{
		l.flags.bFindElse = 0;
		l.flags.bFindEndif = 0;
	}
	else
		l.flags.bFindEndif++;
	return psv;
}
static uintptr_t CPROC SetTrace( uintptr_t psv, arg_list args )
{
	PARAM( args, LOGICAL, yesno );
	l.flags.bTraceInterfaceLoading = yesno;
	return psv;
}
static uintptr_t CPROC IncludeAdditional( uintptr_t psv, arg_list args )
{
	PARAM( args, CTEXTSTR, path );
	TEXTSTR old_configname = l.config_filename;
	l.config_filename = ExpandPath( path );
	if( l.flags.bTraceInterfaceLoading )
		lprintf( WIDE( "include:%s from %s" ), l.config_filename, old_configname );
	if( !l.flags.bHeldDeadstart )
	{
		l.flags.bHeldDeadstart = 1;
		SuspendDeadstart();
	}
	ReadConfiguration();
	if( l.flags.bHeldDeadstart )
	{
		ResumeDeadstart();
		l.flags.bHeldDeadstart = 0;
	}
	Release( l.config_filename );
	l.config_filename = old_configname;
	return psv;
}
static uintptr_t CPROC SetProducerName( uintptr_t psv, arg_list args )
{
	PARAM( args, CTEXTSTR, name );
	sack_set_common_data_producer( name );
	return psv;
}
static uintptr_t CPROC SetApplicationName( uintptr_t psv, arg_list args )
{
	PARAM( args, CTEXTSTR, name );
	sack_set_common_data_application( name );
	return psv;
}
#endif
//-----------------------------------------------------------------------
#ifndef __NO_INTERFACE_SUPPORT__
void ReadConfiguration( void )
{
	if( !l.flags.bInterfacesLoaded )
	{
		PCONFIG_HANDLER pch;
		pch = CreateConfigurationHandler();
		AddConfigurationMethod( pch, WIDE( "Producer=%m" ), SetProducerName );
		AddConfigurationMethod( pch, WIDE( "Application=%m" ), SetApplicationName );
		AddConfigurationMethod( pch, WIDE( "enable trace=%b" ), SetTrace );
		AddConfigurationMethod( pch, WIDE( "option default %m=%m" ), SetOptionDefault );
		AddConfigurationMethod( pch, WIDE( "option set %m=%m" ), SetOptionSet );
		AddConfigurationMethod( pch, WIDE( "default option %m=%m" ), SetOptionDefault );
		AddConfigurationMethod( pch, WIDE( "set option %m=%m" ), SetOptionSet );
		AddConfigurationMethod( pch, WIDE( "start directory \"%m\"" ), SetDefaultDirectory );
		AddConfigurationMethod( pch, WIDE( "include \"%m\"" ), IncludeAdditional );
		AddConfigurationMethod( pch, WIDE( "if %m==%m" ), TestOption );
		AddConfigurationMethod( pch, WIDE( "endif" ), EndTestOption );
		AddConfigurationMethod( pch, WIDE( "else" ), ElseTestOption );
		AddConfigurationMethod( pch, WIDE("service=%w library=%w load=%w unload=%w"), HandleLibrary );
		AddConfigurationMethod( pch, WIDE("alias service %w %w"), HandleAlias );
		AddConfigurationMethod( pch, WIDE("module %w"), HandleModule );
		AddConfigurationMethod( pch, WIDE("pmodule %w"), HandlePrivateModule );
		AddConfigurationMethod( pch, WIDE("modulepath %m"), HandleModulePath );
		{
			CTEXTSTR filepath
#ifdef __ANDROID__
				= WIDE(".");
#else
				= GetProgramPath();
#endif
			TEXTSTR loadname;
			size_t len;
			int success = FALSE;
			if( !filepath )
				filepath = WIDE("@");
			if( l.config_filename )
			{
				success = ProcessConfigurationFile( pch, l.config_filename, 0 );
				if( !success )
					lprintf( WIDE("Failed to open custom interface configuration file:%s"), l.config_filename );
				return;
			}
			if( !success )
			{
				CTEXTSTR dot;
				loadname = NewArray( TEXTCHAR, (uint32_t)(len = StrLen( GetProgramName() ) + StrLen( WIDE("interface.conf") ) + 3) );
				tnprintf( loadname, len, WIDE("%s.%s"), GetProgramName(), WIDE("interface.conf") );
				success = ProcessConfigurationFile( pch, loadname, 0 );
				if( !success )
					dot = GetProgramName();
				while( !success )
				{
					dot = StrChr( dot + 1, '.' );
					if( dot )
					{
						tnprintf( loadname, len, WIDE("%s.%s"), dot+1, WIDE("interface.conf") );
						success = ProcessConfigurationFile( pch, loadname, 0 );
					}
					else
						break;
				}
			}
			if( !success )
			{
				success = ProcessConfigurationFile( pch, WIDE( "interface.conf" ), 0 );
			}
			if( !success )
			{
				CTEXTSTR dot;
				loadname = NewArray( TEXTCHAR, (uint32_t)(len = StrLen( filepath ) + StrLen( GetProgramName() ) + StrLen( WIDE("interface.conf") ) + 3) );
				tnprintf( loadname, len, WIDE("%s/%s.%s"), filepath, GetProgramName(), WIDE("interface.conf") );
				success = ProcessConfigurationFile( pch, loadname, 0 );
				if( !success )
					dot = GetProgramName();
				while( !success )
				{
					dot = StrChr( dot + 1, '.' );
					if( dot )
					{
						tnprintf( loadname, len, WIDE("%s/%s.%s"), filepath, dot+1, WIDE("interface.conf") );
						success = ProcessConfigurationFile( pch, loadname, 0 );
					}
					else
						break;
				}
			}
			if( !success )
			{
				tnprintf( loadname, len, WIDE("%s/%s"), filepath, WIDE("interface.conf") );
				success = ProcessConfigurationFile( pch, loadname, 0 );
			}
			if( !success )
			{
				//lprintf( WIDE("Failed to open interface configuration file:%s - assuming it will never exist, and aborting trying this again")
				//		 , l.config_filename?l.config_filename:WIDE("interface.conf") );
			}
			if( loadname )
				Release( loadname );
		}
		DestroyConfigurationHandler( pch );
		//at this point... we should probably NOT
		// dump this information, a vast amount of information may occur.
		// consider impelmenting enumerators and allowing browsing
		//DumpRegisteredNames();
		// if we failed, probably noone will notice, and nooone will
		// get the clue that we need to have an interface.conf
		// for this to preload extra libraries that the program may be
		// requesting.
		l.flags.bInterfacesLoaded = 1;
	}
	//else
	//	lprintf( WIDE( "already loaded." ) );
	if( l.flags.bHeldDeadstart )
	{
		l.flags.bHeldDeadstart = 0;
		ResumeDeadstart();
	}
}
#endif
//-----------------------------------------------------------------------
POINTER GetInterfaceExx( CTEXTSTR pServiceName, LOGICAL ReadConfig DBG_PASS )
{
	TEXTCHAR interface_name[256];
	POINTER (CPROC *load)( void );
	static int reading_configuration;
	// this might be the first clean chance to run deadstarts
	// for ill behaved platforms that have forgotten to do this.
	if( !IsRootDeadstartStarted() )
	{
		InvokeDeadstart();
	}
#ifndef __NO_INTERFACE_SUPPORT__
	if( ReadConfig && !reading_configuration )
	{
		reading_configuration = 1;
		SuspendDeadstart();
		ReadConfiguration();
		ResumeDeadstart();
		reading_configuration = 0;
	}
#endif
	//lprintf( "Load interface [%s]", pServiceName );
	if( pServiceName )
	{
		tnprintf( interface_name, sizeof( interface_name ), WIDE("system/interfaces/%s"), pServiceName );
		load = GetRegisteredProcedure( (PCLASSROOT)interface_name, POINTER, load, (void) );
		//lprintf( WIDE("GetInterface for %s is %p"), pServiceName, load );
		if( load )
		{
			POINTER p = load();
			//lprintf( WIDE("And the laod proc resulted %p"), p );
 //load();
			return p;
		}
#ifdef _DEBUG
		else
		{
			if( l.flags.bInterfacesLoaded )
			{
				if( !GetRegisteredValueExx( (PCLASSROOT)interface_name, NULL, WIDE( "Logged" ), 1 ) )
				{
					_lprintf(DBG_RELAY)( WIDE("Did not find load procedure for:[%s] (dumping names from /system/interface/* so you can see what might be available)"), interface_name );
					DumpRegisteredNamesFrom(GetClassRoot(WIDE( "system/interfaces" )));
					RegisterValueExx( (PCLASSROOT)interface_name, NULL, WIDE( "Logged" ), 1, (CTEXTSTR)1 );
				}
			}
		}
#endif
	}
	return NULL;
}
#undef GetInterfaceEx
POINTER GetInterfaceEx( CTEXTSTR pServiceName, LOGICAL ReadConfig )
{
	return GetInterfaceExx( pServiceName, ReadConfig DBG_SRC );
}
POINTER GetInterfaceDbg( CTEXTSTR pServiceName DBG_PASS )
{
	POINTER result = GetInterfaceExx( pServiceName, FALSE DBG_RELAY );
	if( !result )
	{
		// don't force the issue too much
		if( l.flags.bReadConfiguration )
			result = GetInterfaceExx( pServiceName, TRUE DBG_RELAY );
	}
	return result;
}
#if 0
#undef GetInterface
PUBLIC( POINTER, GetInterface )( CTEXTSTR pServiceName )
{
	return GetInterfaceDbg( pServiceName DBG_SRC );
}
#endif
//-----------------------------------------------------------------------
PROCREG_PROC( void, DropInterface )( CTEXTSTR pServiceName, POINTER interface_drop )
{
	TEXTCHAR interfacename[256];
	void (CPROC *unload)( POINTER );
	tnprintf( interfacename, sizeof(interfacename), WIDE("system/interfaces/%s"), pServiceName );
	unload = GetRegisteredProcedure( (PCLASSROOT)interfacename, void, unload, (POINTER) );
	if( unload )
		unload( interface_drop );
}
//-----------------------------------------------------------------------
PRIORITY_ATEXIT( CloseGlobalRegions, ATEXIT_PRIORITY_SHAREMEM + 1 )
{
	PLIST *global_reference;
	INDEX idx;
	return;
	l.reference_count--;
	if( !l.reference_count )
		LIST_FORALL( l.global_spaces, idx, PLIST*, global_reference )
		{
			INDEX idx2;
			POINTER *ppGlobal;
			SetAllocateLogging( 0 );
			// hold the global reference once more, and then just release
			Hold( global_reference );
			LIST_FORALL( global_reference[0], idx2, POINTER *, ppGlobal )
			{
				// increment count here for number of Releases to do.
				(*ppGlobal) = NULL;
				Release( global_reference );
			}
			DeleteList( global_reference );
			// Release all times; number of holds should match number above...
			// safety check it?
			Release( global_reference );
		}
}
void RegisterAndCreateGlobalWithInit( POINTER *ppGlobal, uintptr_t global_size, CTEXTSTR name, void (CPROC*Open)(POINTER,uintptr_t) )
{
	POINTER *ppGlobalMain;
	POINTER p;
	if( ppGlobal == (POINTER*)&procreg_local_data )
	{
		uintptr_t size = global_size + sizeof( PLIST );
		uint32_t created;
		TEXTCHAR spacename[32];
		if( procreg_local_data != NULL )
		{
			// if local already has something, just return.
			return;
		}
#ifdef DEBUG_GLOBAL_REGISTRATION
		lprintf( WIDE("Opening space...") );
#endif
#ifdef UNICODE
#define _S WIDE("ls")
#else
#define _S WIDE("s")
#endif
#ifdef WIN32
		tnprintf( spacename, sizeof( spacename ), WIDE("%s:%08lX"), name, GetCurrentProcessId() );
#else
		tnprintf( spacename, sizeof( spacename ), WIDE("%")_S WIDE(":%08X"), name, getpid() );
#  ifdef DEBUG_FIRST_UNICODE_OPERATION
		{
			wchar_t buf[32];
			strcpy( (char*)buf, "abcdefghijklmn" );
			swprintf( buf, 32, L"%s", L"some_name" );
			{
				char tmpmsg[256];
				int chars;
				int ofs= 0;
				ofs = snprintf( tmpmsg, 256, "in the beginning(w):" );
				for( chars = 0; chars < 32; chars++ )
					ofs += snprintf( tmpmsg + ofs, 256 - ofs, "%02x ", ((char*)buf)[chars] );
				__android_log_print( ANDROID_LOG_INFO, "org.d3x0r.sack.xxxx", tmpmsg );
				ofs = snprintf( tmpmsg, 256, "in the beginning(w):" );
				for( chars = 0; chars < 32; chars++ )
					ofs += snprintf( tmpmsg + ofs, 256 - ofs, "%c", (buf)[chars] );
				__android_log_print( ANDROID_LOG_INFO, "org.d3x0r.sack.xxxx", tmpmsg );
								ofs = snprintf( tmpmsg, 256, "in the beginning(w):" );
				for( chars = 0; chars < 32; chars++ )
					ofs += snprintf( tmpmsg + ofs, 256 - ofs, "%c", (name)[chars] );
				__android_log_print( ANDROID_LOG_INFO, "org.d3x0r.sack.xxxx", tmpmsg );
				ofs = snprintf( tmpmsg, 256, "in the beginning(w):" );
				for( chars = 0; chars < 32; chars++ )
					ofs += snprintf( tmpmsg + ofs, 256 - ofs, "%c", (spacename)[chars] );
				__android_log_print( ANDROID_LOG_INFO, "org.d3x0r.sack.xxxx", tmpmsg );
			}
		}
#  endif
#endif
		// hmm application only shared space?
		// how do I get that to happen?
		(*ppGlobal) = OpenSpaceExx( spacename, NULL, 0, &size, &created );
		(*ppGlobal) = (POINTER*)( (uintptr_t)(*ppGlobal) + sizeof( PLIST ) );
		// I myself must have a global space, which is kept sepearte from named spaces
		// but then... blah
		if( created )
		{
#ifdef DEBUG_GLOBAL_REGISTRATION
			lprintf( WIDE("(specific procreg global)clearing memory:%s(%p)"), spacename, (*ppGlobal ) );
#endif
			MemSet( (*ppGlobal), 0, global_size );
			{
				// pp global is a double pointer type, I want the pointer before
				PLIST *global_references = (PLIST*)( (uintptr_t)(*ppGlobal) - sizeof( POINTER ) );
				global_references[0] = NULL;
				AddLink( global_references, ppGlobal );
			}
			if( Open )
				Open( (*ppGlobal), global_size );
			p = (POINTER)MakeRegisteredDataTypeEx( NULL, WIDE("system/global data"), name, name, (*ppGlobal), global_size );
		}
		else
		{
#ifdef DEBUG_GLOBAL_REGISTRATION
			lprintf( WIDE("(specific procreg global)using memory untouched:%s(%p)"), spacename, (*ppGlobal ) );
#endif
			{
				// pp global is a double pointer type, I want the pointer before
				PLIST *global_references = (PLIST*)( (uintptr_t)(*ppGlobal) - sizeof( POINTER ) );
				AddLink( global_references, ppGlobal );
			}
		}
		// result is the same as the pointer input...
		return;
	}
	if( ppGlobal && !(*ppGlobal) )
	{
		Init();
		// RTLD_DEFAULT
		ppGlobalMain = &p;
		p = (POINTER)CreateRegisteredDataTypeEx( (PCLASSROOT)l.Names, WIDE("system/global data"), name, name );
		if( !p )
		{
			RegisterDataType( WIDE("system/global data"), name, global_size
								 , Open
								 , NULL );
			p = (POINTER)CreateRegisteredDataTypeEx( (PCLASSROOT)l.Names, WIDE("system/global data"), name, name );
			if( !p )
				ppGlobalMain = NULL;
#ifdef DEBUG_GLOBAL_REGISTRATION
			lprintf( WIDE("Registered and created by registered type. %p"), p );
#endif
			{
				// only need each space once in this list; when it's created.
				POINTER tmp_p = (POINTER)( (uintptr_t)p - sizeof( PLIST ) );
				AddLink( &l.global_spaces, tmp_p );
			}
		}
		else
		{
#ifdef DEBUG_GLOBAL_REGISTRATION
			lprintf( WIDE("Found our shared region by asking politely for it! *********************") );
#endif
		}
		if( !ppGlobalMain )
		{
			lprintf( WIDE("None found in main... no way to mark for a peer...") );
			exit(0);
		}
		if( ppGlobalMain && *ppGlobalMain )
		{
#ifdef DEBUG_GLOBAL_REGISTRATION
			lprintf( WIDE("Resulting with a global space to use... %p"), (*ppGlobalMain) );
#endif
			(*ppGlobal) = (*ppGlobalMain);
			{
				// pp global is a double pointer type, I want the pointer before
				PLIST *global_references = (PLIST*)( (uintptr_t)(*ppGlobal) - sizeof( PLIST ) );
				AddLink( global_references, ppGlobal );
			}
		}
		else
		{
			lprintf( WIDE("Failure to get global_procreg_data block.") );
			exit(0);
		}
	}
	else
	{
		// thing is already apparently initizliaed.. don't do this.
		ppGlobalMain = NULL;
	}
}
void RegisterAndCreateGlobal( POINTER *ppGlobal, uintptr_t global_size, CTEXTSTR name )
{
	RegisterAndCreateGlobalWithInit( ppGlobal, global_size, name, NULL );
}
#ifdef __cplusplus_cli
using namespace System;
public ref class ProcReg
{
	static ProcReg()
	{
		InvokeDeadstart();
	}
	int Register( System::String^ name_class, String^ proc, STDPROCEDURE Delegate )
	{
		if( name_class )
		{
//Allocate( sizeof( NAME ) );
			PNAME newname = GetFromSet( NAME, &l.NameSet );
			TEXTCHAR strippedargs[256];
			pin_ptr<const WCHAR> tmp2 = PtrToStringChars(name_class);
			CTEXTSTR __name_class = DupWideToText( tmp2 );
			pin_ptr<const WCHAR> tmp = PtrToStringChars(proc);
			CTEXTSTR real_name = DupWideToText( tmp );
			PTREEDEF class_root = (PTREEDEF)GetClassTree( NULL, (PTREEDEF)__name_class );
			MemSet( newname, 0, sizeof( NAME ) );
			newname->flags.bStdProc = 1;
			// this is kinda messed up...
			newname->name = SaveName( real_name );
			//newname->data.stdproc.library = SaveName( library );
			newname->data.stdproc.procname = SaveName( real_name );
			//newname->data.proc.ret = SaveName( returntype );
			//newname->data.proc.args = SaveName( StripName( strippedargs, args ) );
			newname->data.proc.name = SaveNameConcatN( StripName( strippedargs, WIDE( "(*)" ) )
 //returntype
																  , WIDE("")
 // library
																  , WIDE("")
																  , real_name
																  , NULL
																  );
			newname->data.stdproc.proc = Delegate;
			if( class_root )
			{
				PNAME oldname;
				oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)newname->name);
				if( oldname )
				{
					if( oldname->data.stdproc.proc == Delegate )
						Log( WIDE("And fortunatly it's the same address... all is well...") );
					else
					{
						xlprintf( 2 )( WIDE("proc %s/%s regisry by %s of %s(%s) conflicts with %s(%s)...")
													  , (CTEXTSTR)__name_class?(CTEXTSTR)__name_class:WIDE("@")
													  , real_name
													  , newname->name
													  , newname->data.proc.name
														//,library
													  , newname->data.proc.procname
													  , oldname->data.proc.name
													  //,library
													  , oldname->data.proc.procname );
						// perhaps it's same in a different library...
						Log( WIDE("All is not well - found same function name in tree with different address. (ignoring second) ") );
						//DebugBreak();
						//DumpRegisteredNames();
					}
					return TRUE;
				}
				else
				{
					newname->parent = class_root;
					if( !AddBinaryNode( class_root->Tree, newname, (uintptr_t)newname->name ) )
					{
						Log( WIDE("For some reason could not add new name to tree!") );
						DeleteFromSet( NAME, l.NameSet, newname );
					}
				}
			}
			else
			{
				lprintf( WIDE("I'm relasing this name!?") );
				DeleteFromSet( NAME, l.NameSet, newname );
			}
			return 1;
		}
	}
};
#endif
PROCREG_NAMESPACE_END
#undef l
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   created to provide standard memory allocation features.
 *   Release( Allocate(size) )
 *   Hold( pointer ); // must release a second time.
 *   if DEBUG, memory bounds checking enabled and enableable.
 *   if RELEASE standard memory includes no excessive operations
 *
 *  standardized to never use int. (was a clean port, however,
 *  inaccurate, knowing the conversions on calculations of pointers
 *  are handled by cast to int! )
 *
 * see also - include/sharemem.h
 *
 */
//   DEBUG_SYMBOLS
// had some problems with OpenSpace opening a shared region under win98
// Apparently if a create happens with a size of 0, the name of the region
// becomes unusable, until a reboot happens.
//#define DEBUG_OPEN_SPACE
// this variable controls whether allocate/release is logged.
#ifndef NO_FILEOP_ALIAS
#  define NO_FILEOP_ALIAS
#endif
#define NO_UNICODE_C
//#define USE_SIMPLE_LOCK_ON_OPEN
#ifdef __LINUX__
#include <sys/mman.h>
#endif
#ifdef _MSC_VER
#ifndef UNDER_CE
#endif
#endif
#define DEFINE_MEMORY_STRUCT
/* A header for doing .NET /CLR compatiblity changes. Things
   like fopen needing to be _fopen_s and junk.               */
#ifndef FILE_DOT_NET_COMPAT
/* Header multiple inclusion protection symbol. */
#define FILE_DOT_NET_COMPAT
#ifdef __cplusplus_cli
#define Fopen( result, name, opts ) { char *tmp1 = CStrDup( name ); char *tmp2 = CStrDup( opts ); result = fopen( tmp1, tmp2 ); Deallocate( char *, tmp1 ); Deallocate( char *, tmp2 ); }
#if asdfasdlfkajsdflkj
#define fputs( msg, file ) { char *tmp = CStrDup( msg ); fputs( tmp, file ); Release( tmp ); }
#define unlink( name ) { char *tmp = CStrDup( name ); unlink( tmp ); Release( tmp ); }
#define rename( name1, name2 ) { char *tmp1 = CStrDup( name1 ); char *tmp2 = CStrDup( name2 ); rename( tmp1, tmp2 ); Release( tmp1 ); Release( tmp2 ); }
#define fprintf Fprintf
#endif
//int Fprintf( FILE *file, CTEXTSTR fmt, ... );
/*
using namespace Win32;
#define CreateEvent(a,b,c,d) Win32::Kernel::CreateEvent((SECURITY_ATTRIBUTES)a,b,c,d)
#define OpenEvent(a,b,c)     Win32::Kernel::OpenEvent(a,b,c)
#define Sleep(a)             Win32::Kernel::Sleep(a)
#define GetTickCount()       Win32::Kernel::GetTickCount()
#define GetCurrentProcessId() Win32::Kernel::GetCurrentProcessId()
#define GetCurrentThreadId()  Win32::Kernel::GetCurrentThreadId()
#define GetLastError()  Win32::Kernel::GetLastError()
#define SetEvent(a) Win32::Kernel::SetEvent(a)
#define ResetEvent(a) Win32::Kernel::ResetEvent(a)
#define CloseHandle(a) Win32::Kernel::CloseHandle(a)
#define WaitForSingleObject(a,b) Win32::Kernel::WaitForSingleObject(a,b)
#define PeekMessage(a,b,c,d,e)  Win32::User::PeekMessage(a,b,c,d,e)
#define DispatchMessage(a)   Win32::User::DispatchMessage(a)
#define GetModuleFileName(a,b) Win32::Kernel::GetModuleFileName(a,b)
*/
#if 0
typedef struct MyFile MYFILE;
MYFILE *Fopen( CTEXTSTR filename, CTEXTSTR mode );
int Fread( POINTER data, int count, int size, MYFILE *file );
int Fwrite( POINTER data, int count, int size, MYFILE *file );
int Fclose( MYFILE *file );
int Fseek( MYFILE *file, int64_t pos, int whence );
uint64_t Ftell( MYFILE *file );
MYFILE *Fdopen( int fd, CTEXTSTR mode );
int Ferror( MYFILE *file );
int Fflush( MYFILE *file );
int Rewind( MYFILE *file );
int Fputc( int c, MYFILE *file );
int Fgets( TEXTSTR buf, int buflen, MYFILE *file );
int Fputs( CTEXTSTR but, MYFILE *file );
int Unlink( CTEXTSTR filename );
int Rename( CTEXTSTR from, CTEXTSTR to );
#define rename Rename
#define unlink Unlink
#define FILE MYFILE
#define fopen Fopen
#define fseek Fseek
#define fclose Fclose
#define fprintf Fprintf
#define ftell Ftell
#define fread Fread
#define fwrite Fwrite
//#define fdopen Fdopen
#define ferror Ferror
#define fflush Fflush
#define rewind Rewind
#define fputc Fputc
#define fgets Fgets
#define fputs Fputs
#endif
#else
/* A macro which can be translated into microsoft so-called safe
   methods.                                                      */
#define Fopen( result, name, opts ) result = sack_fopen( 0, name, opts )
//#define MYFILE  FILE
//#define Fopen   fopen
//#define Fread   fread
//#define Fwrite  fread
//#define Fclose  fclose
//#define Fprintf fprintf
//#define Fseek   fseek
//#define Ftell   ftell
#endif
#endif
// end with a newline please.
#ifndef _SHARED_MEMORY_LIBRARY
#if !defined( MEMORY_STRUCT_DEFINED ) || defined( DEFINE_MEMORY_STRUCT )
//#define ENABLE_NATIVE_MALLOC_PROTECTOR
#ifdef _DEBUG
#  define USE_DEBUG_LOGGING 1
#else
#  define USE_DEBUG_LOGGING 0
#endif
#define MEMORY_STRUCT_DEFINED
#ifdef _DEBUG
//  Define this symbol in SHAREMEM.H!
// if you define it here it will not work as expected...
//// defined in sharemem.h #define DEBUG_CRITICAL_SECTIONS
//// defined in sharemem.h #define LOG_DEBUG_CRITICAL_SECTIONS
#endif
#define _SHARED_MEMORY_LIBRARY
#ifdef __cplusplus
namespace sack {
	namespace timers {
#endif
// bit set on dwLocks when someone hit it and it was locked
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
#define SECTION_LOGGED_WAIT 0x80000000
#define AND_NOT_SECTION_LOGGED_WAIT(n) ((n)&(~SECTION_LOGGED_WAIT))
#define AND_SECTION_LOGGED_WAIT(n) ((n)&(SECTION_LOGGED_WAIT))
#else
#define SECTION_LOGGED_WAIT 0
#define AND_NOT_SECTION_LOGGED_WAIT(n) (n)
#define AND_SECTION_LOGGED_WAIT(n) (0)
#endif
// If you change this structure please change the public
// reference of this structure, and please, do hand-count
// the bytes to set there... so not include this file
// to get the size.  The size there should be the worst
// case - debug or release mode.
#ifdef NO_PRIVATE_DEF
struct critical_section_tag {
 // this is set when entering or leaving (updating)...
	volatile uint32_t dwUpdating;
	volatile uint32_t dwLocks;
 // windows upper 16 is process ID, lower is thread ID
	THREAD_ID dwThreadID;
 // ID of thread waiting for this..
	THREAD_ID dwThreadWaiting;
	//PDATAQUEUE pPriorWaiters;
#ifdef DEBUG_CRITICAL_SECTIONS
	uint32_t bCollisions ;
	CTEXTSTR pFile;
	uint32_t  nLine;
#endif
};
typedef struct critical_section_tag CRITICALSECTION;
#endif
#ifdef __cplusplus
	};
};
#endif
#ifdef __cplusplus
namespace sack {
	namespace memory {
		using namespace sack::timers;
#endif
// pFile, nLine has been removed from this
// the references for this info are now
// stored at the end of the block
		// after the 0x12345678 tag.
#  ifdef _MSC_VER
#    pragma pack (push, 1)
#  endif
// custom allocer, use heap_chunk_tag
PREFIX_PACKED struct malloc_chunk_tag
{
   // if 0 - block is free
	uint16_t dwOwners;
      // extra bytes 4/12 typical, sometimes pad untill next. (alignment extra bytes)
	uint16_t dwPad;
#ifdef __64__
	uint32_t pad;
#endif
  // limited to allocating 4 billion bytes...
	uintptr_t dwSize;
#ifdef ENABLE_NATIVE_MALLOC_PROTECTOR
	uint32_t LeadProtect[2];
#endif
 // this is additional to subtract to get back to start (aligned allocate)
	uint16_t alignment;
 // this is additional to subtract to get back to start (aligned allocate)
	uint16_t to_chunk_start;
 // uint8_t is the smallest valid datatype could be _0
	uint8_t byData[1];
} PACKED;
PREFIX_PACKED struct heap_chunk_tag
{
            // if 0 - block is free
	uint16_t dwOwners;
   // extra bytes 4/12 typical, sometimes pad untill next.
	uint16_t dwPad;
	// which is < ( CHUNK_SIZE + nMinAllocate )
	// real size is then dwSize - dwPad.
	// this is actually where the end of block tag(s) should begin!
  // limited to allocating 4 billion bytes...
	uintptr_t dwSize;
         // save some math backwards...
	struct heap_chunk_tag *pPrior;
  // pointer to master allocation struct (pMEM)
	struct memory_block_tag * pRoot;
	DeclareLink( struct heap_chunk_tag );
 // this is additional to subtract to get back to start (aligned allocate)
	uint16_t alignment;
 // this is additional to subtract to get back to start (aligned allocate)
	uint16_t to_chunk_start;
 // uint8_t is the smallest valid datatype could be _0
	uint8_t byData[1];
} PACKED;
// a chunk of memory in a heap space, heaps are also tracked, so extents
// of that space are known, therefore one can identify a heap chunk
// from a non-heap (malloc?) chunk.
typedef PREFIX_PACKED struct heap_chunk_tag HEAP_CHUNK, *PHEAP_CHUNK;
// CHUNK and HEAP_CHUNK are the same.  They were not the same when using an
// ifdef to separate custom allocation from malloc allocation.  HeapAllocate
// could still be passed a heap before, and would be able to allocate from it.
typedef PREFIX_PACKED struct heap_chunk_tag CHUNK, *PCHUNK;
typedef PREFIX_PACKED struct malloc_chunk_tag MALLOC_CHUNK, *PMALLOC_CHUNK;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
// chunks allocated have no debug information.
#define HEAP_FLAG_NO_DEBUG 0x0001
struct memory_block_tag
{
	uintptr_t dwSize;
 // unique value 0xbab1f1ea (baby flea);
	uint32_t dwHeapID;
	// lock between multiple processes/threads
	CRITICALSECTION cs;
	uint32_t dwFlags;
	PHEAP_CHUNK pFirstFree;
	HEAP_CHUNK pRoot[1];
};
typedef struct memory_block_tag MEM;
#ifdef __cplusplus
	};
};
#endif
#endif
#endif
#if defined __ANDROID__
#include <linux/ashmem.h>
#endif
#ifdef _MSC_VER
//>= 900
#include <crtdbg.h>
#include <new.h>
#endif
#ifdef __cplusplus
namespace sack {
	namespace memory {
#endif
#ifdef __64__
#define CLEAR_MEMORY_TAG 0xDEADBEEFDEADBEEFULL
#define FREE_MEMORY_TAG 0xFACEBEADFACEBEADULL
#define LEAD_PROTECT_TAG 0xbabecafebabecafeULL
#define LEAD_PROTECT_BLOCK_TAIL 0xbeefcafebeefcafeULL
#else
#define CLEAR_MEMORY_TAG 0xDEADBEEFUL
#define FREE_MEMORY_TAG 0xFACEBEADUL
#define LEAD_PROTECT_TAG 0xbabecafeUL
#define LEAD_PROTECT_BLOCK_TAIL 0xbeefcafeUL
#endif
#ifdef g
#  undef g
#endif
#ifdef __64__
#  define makeULong(n) (~(n##ULL))
#else
#  define makeULong(n) (~(n##UL))
#endif
static uintptr_t masks[33] = { makeULong(0), makeULong(0), makeULong(1), 0, makeULong(3), 0, 0, 0, makeULong(7), 0, 0, 0, 0, 0, 0, 0, makeULong(15), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, makeULong(31) };
#define BASE_MEMORY (POINTER)0x80000000
// golly allocating a WHOLE DOS computer to ourselves? how RUDE
#define SYSTEM_CAPACITY  g.dwSystemCapacity
#define MALLOC_CHUNK_SIZE(pData) ( (pData)?( ( ( (uint16_t*)(pData))[-1] ) + offsetof( MALLOC_CHUNK, byData ) ):0 )
//#define CHUNK_SIZE(pData) ( ( (pData)?( (uint16_t*)(pData))[-1]:0 ) +offsetof( CHUNK, byData ) ) )
#define CHUNK_SIZE ( offsetof( CHUNK, byData ) )
#define MEM_SIZE  ( offsetof( MEM, pRoot ) )
// using lower level syslog bypasses some allocation requirements...
//#undef lprintf
//#undef _lprintf
#ifndef NO_LOGGING
#  ifdef _DEBUG
#    define ll_lprintf( f, ... ) { TEXTCHAR buf[256]; tnprintf( buf, 256, f,##__VA_ARGS__ ); SystemLogFL( buf FILELINE_SRC ); }
#    define _lprintf2( f, ... ) { TEXTCHAR buf[256]; tnprintf( buf, 256, FILELINE_FILELINEFMT f,_pFile,_nLine,##__VA_ARGS__ ); SystemLogFL( buf FILELINE_SRC ); } }
#    define ll__lprintf( a ) {const TEXTCHAR *_pFile = pFile; int _nLine = nLine; _lprintf2
#  else
#    define ll_lprintf( f, ... ) { TEXTCHAR buf[256]; tnprintf( buf, 256, f,##__VA_ARGS__ ); SystemLog( buf ); }
#    define _lprintf2( f, ... ) { TEXTCHAR buf[256]; tnprintf( buf, 256, f,##__VA_ARGS__ ); SystemLog( buf ); } }
#    define ll__lprintf( a ) { _lprintf2
#  endif
#else
#  define lprintf( f,... )
#endif
// last entry in space tracking array will ALWAYS be
// another space tracking array (if used)
// (32 bytes)
typedef struct space_tracking_structure {
	PMEM pMem;
#ifdef _WIN32
	HANDLE  hFile;
	HANDLE  hMem;
#else
	struct {
		uint32_t bTemporary : 1;
	} flags;
	int hFile;
#endif
	uintptr_t dwSmallSize;
	DeclareLink( struct space_tracking_structure );
} SPACE, *PSPACE;
typedef struct space_pool_structure {
	DeclareLink( struct space_pool_structure );
	SPACE spaces[(4096 - sizeof( struct space_pool_structure * )
		- sizeof( struct space_pool_structure ** ))
		/ sizeof( SPACE )];
} SPACEPOOL, *PSPACEPOOL;
#define MAX_PER_BLOCK (4096 - sizeof( struct space_pool_structure *)	 - sizeof( struct space_pool_structure **) )	  / sizeof( SPACE )
#ifdef _WIN32
//(0x10000 * 0x1000) //256 megs?
#define FILE_GRAN g.si.dwAllocationGranularity
#else
#define FILE_GRAN g.pagesize
#endif
struct global_memory_tag {
 // basic OS block grabbed for allocation
	size_t dwSystemCapacity;
//#ifdef _DEBUG
// may define one or the other of these but NOT both
	int bDisableDebug;
	int bDisableAutoCheck;
	int bLogCritical;
	//#endif
	size_t nMinAllocateSize;
	int pagesize;
	int bLogAllocate;
	int bLogAllocateWithHold;
  // this option couldn't work; different block tracking methods are incompatible
	LOGICAL bCustomAllocer;
	LOGICAL bInit;
	LOGICAL allowLogging;
	PSPACEPOOL pSpacePool;
#ifdef _WIN32
	SYSTEM_INFO si;
#endif
 // don't add our tracking to ourselves...
	int InAdding;
 // set if anybody starts to DIG.
	uint32_t bMemInstanced;
	LOGICAL deadstart_finished;
	PMEM pMemInstance;
};
#ifdef __STATIC__
static struct global_memory_tag global_memory_data = { 0x10000 * 0x08, 0, 0
													, 0
													, 0
													, 0
													, 0
													, 0
																	  , USE_CUSTOM_ALLOCER
																	  , 0
																	  , 0
																	  , NULL
#ifdef _WIN32
																	  , { 0 }
#endif
																	  , 0
																	  , 0
																	  , FALSE
                                                     , NULL
};
#  define g (global_memory_data)
#else
#  ifdef _DEBUG
struct global_memory_tag global_memory_data = { 0x10000 * 0x08, 0, 0
#    ifdef DEBUG_CRITICAL_SECTIONS
															, 1
#    else
															, 0
#    endif
															, 0
															, 0
															, 0
															, 0
															 , USE_CUSTOM_ALLOCER
																	  , 0
																	  , 0
																	  , NULL
#ifdef _WIN32
																	  , { 0 }
#endif
																	  , 0
																	  , 0
																	  , FALSE
                                                     , NULL
};
// this one has memory logging enabled by default...
//struct global_memory_tag global_memory_data = { 0x10000 * 0x08, 0, 1, 0, 0, 0, 1 };
#  else
/* disable debug*/
struct global_memory_tag global_memory_data = { 0x10000 * 0x08, 1, 1
 /* log crit */
 /* min alloc size */
															, 0, 0, 0
															, 0
															, 0
  // custom allocer
															, USE_CUSTOM_ALLOCER
																	  , 0
																	  , 0
																	  , NULL
#ifdef _WIN32
																	  , { 0 }
#endif
																	  , 0
																	  , 0
																	  , FALSE
                                                     , NULL
};
// this one has memory logging enabled by default...
//struct global_memory_tag global_memory_data = { 0x10000 * 0x08, 0, 1, 0, 0, 0, 1 };
#  endif
#define g global_memory_data
#endif
#ifndef NO_LOGGING
#  define ODSEx(s,pFile,nLine) SystemLogFL( s DBG_RELAY )
//#define ODSEx(s,pFile,nLine) SystemLog( s )
#  define ODS(s)  SystemLog(s)
#else
#  define ODSEx(s,file,line)
#  define ODS(s)
#endif
#define MAGIC_SIZE sizeof( void* )
#ifdef __64__
#define BLOCK_TAG(pc)  (*(uint64_t*)((pc)->byData + (pc)->dwSize - (pc)->dwPad ))
// so when we look at memory this stamp is 0123456789ABCDEF
#define TAG_FORMAT_MODIFIER "ll"
#define BLOCK_TAG_ID 0xefcdab8967452301LL
#else
#define BLOCK_TAG(pc)  (*(uint32_t*)((pc)->byData + (pc)->dwSize - (pc)->dwPad ))
// so when we look at memory this stamp is 12345678
#define TAG_FORMAT_MODIFIER ""
#define BLOCK_TAG_ID 0x78563412L
#endif
// file/line info are at the very end of the physical block...
// block_tag is at the start of the padding...
#define BLOCK_FILE(pc) (*(CTEXTSTR*)((pc)->byData + (pc)->dwSize - MAGIC_SIZE*2))
#define BLOCK_LINE(pc) (*(int*)((pc)->byData + (pc)->dwSize - MAGIC_SIZE))
#ifndef _WIN32
#endif
PRIORITY_PRELOAD( Deadstart_finished_enough, GLOBAL_INIT_PRELOAD_PRIORITY + 1 )
{
	g.deadstart_finished = 1;
	//g.bLogAllocate = 1;
}
PRIORITY_PRELOAD( InitGlobal, DEFAULT_PRELOAD_PRIORITY )
{
#ifndef __NO_OPTIONS__
	g.bLogCritical = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Memory Library/Log critical sections" ), g.bLogCritical, TRUE );
	g.bLogAllocate = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Memory Library/Enable Logging" ), g.bLogAllocate, TRUE );
	if( g.bLogAllocate )
		ll_lprintf( WIDE( "Memory allocate logging enabled." ) );
	g.bLogAllocateWithHold = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Memory Library/Enable Logging Holds" ), g.bLogAllocateWithHold, TRUE );
	//USE_CUSTOM_ALLOCER = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Memory Library/Custom Allocator" ), USE_CUSTOM_ALLOCER, TRUE );
	g.bDisableDebug = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Memory Library/Disable Debug" ), !USE_DEBUG_LOGGING, TRUE );
#else
	//g.bLogAllocate = 1;
#endif
	g.nMinAllocateSize = 32;
	g.allowLogging = 1;
}
#if __GNUC__
#  ifndef __ATOMIC_RELAXED
#    define __ATOMIC_RELAXED 0
#  endif
//#    define DoXchg  XCHG
#  ifndef __GNUC_VERSION
#    define __GNUC_VERSION ( __GNUC__ * 10000 ) + ( __GNUC_MINOR__ * 100 )
#  endif
#  if  ( __GNUC_VERSION >= 40800 ) || defined(__MAC__)
#    define XCHG(p,val)  __atomic_exchange_n(p,val,__ATOMIC_RELAXED)
///  for some reason __GNUC_VERSION doesn't exist from android ?
#  elif defined __ARM__ || defined __ANDROID__
#    define XCHG(p,val)  __atomic_exchange_n(p,val,__ATOMIC_RELAXED)
#  else
inline uint32_t DoXchg( volatile uint32_t* p, uint32_t val ) { __asm__( WIDE( "lock xchg (%2),%0" ) :WIDE( "=a" )(val) : WIDE( "0" )(val), WIDE( "c" )(p) ); return val; }
inline uint64_t DoXchg64( volatile int64_t* p, uint64_t val ) { __asm__( WIDE( "lock xchg (%2),%0" ) :WIDE( "=a" )(val) : WIDE( "0" )(val), WIDE( "c" )(p) ); return val; }
#    define XCHG( p,val) ( ( sizeof( val ) > sizeof( uint32_t ) )?DoXchg64( (volatile int64_t*)p, (uint64_t)val ):DoXchg( (volatile uint32_t*)p, (uint32_t)val ) )
#  endif
//#  endif
#else
#  define XCHG(p,val)  LockedExchange( p, val )
#endif
//-------------------------------------------------------------------------
#if !defined( HAS_ASSEMBLY ) || defined( __CYGWIN__ )
uint32_t  LockedExchange( volatile uint32_t* p, uint32_t val )
{
	// Windows only available - for linux platforms please consult
	// the assembly version should be consulted
#if ( defined( _WIN32 ) || defined( WIN32 ) ) && !defined( __ANDROID__ )
#  if !defined(_MSC_VER)
	return InterlockedExchange( (volatile LONG *)p, val );
#  else
	//return _InterlockedExchange_HLEAcquire( (volatile long*)p, val );
	return _InterlockedExchange( (volatile long*)p, val );
	// windows wants this as a LONG not ULONG
	//return InterlockedExchange( (volatile LONG *)p, val );
#  endif
#else
 //&& !( defined __ARM__ || defined __ANDROID__ )
#  if ( defined( __LINUX__ ) )
	return XCHG( p, val );
	//   return __atomic_exchange_n(p,val,__ATOMIC_RELAXED);
#  else
	{
			// swp is the instruction....
			uint32_t prior = *p;
		*p = val;
		return prior;
	}
#  endif
#endif
}
uint32_t LockedIncrement( uint32_t* p ) {
#ifdef _WIN32
	return InterlockedIncrement( (volatile LONG *)p );
#endif
#ifdef __LINUX__
	return __atomic_add_fetch( p, 1, __ATOMIC_RELAXED );
#endif
}
uint32_t LockedDecrement( uint32_t* p ) {
#ifdef _WIN32
	return InterlockedDecrement( (volatile LONG *)p );
#endif
#ifdef __LINUX__
	return __atomic_sub_fetch( p, 1, __ATOMIC_RELAXED );
#endif
}
uint64_t  LockedExchange64( volatile uint64_t* p, uint64_t val )
{
	// Windows only available - for linux platforms please consult
	// the assembly version should be consulted
#if defined WIN32 && !defined __ANDROID__
#ifdef _MSC_VER
#ifdef __64__
	uint64_t prior = (uint64_t)InterlockedExchange64( (volatile __int64 *)p, (int64_t)val );
#else
	// because the value is a LONG (signed) it has to be made unsigned of the same lenght (ULONG) then extended (uint64_t).
	// otherwise the sign extension was a bug.
	uint64_t prior = (uint64_t)(ULONG)InterlockedExchange( (DWORD*)p, (DWORD)val ) | ((uint64_t)InterlockedExchange( ((DWORD*)p) + 1, (DWORD)(val >> 32) ) << 32);
#endif
#else
	uint64_t prior = InterlockedExchange( (volatile LONG*)p, (int32_t)val ) | InterlockedExchange( ((volatile LONG*)p) + 1, (uint32_t)(val >> 32) );
#endif
	return prior;
#else
#  if defined __GNUC__
#     if !defined( __ANDROID__ ) || ( ANDROID_NDK_TARGET_PLATFORM > 16 )
//__atomic_exchange_n(p,val,__ATOMIC_RELAXED);
	return XCHG( p, val );
#else
	{
		// swp is the instruction....
		// going to have to set IRQ, PIRQ on arm...
		uint64_t prior = *p;
		*p = val;
		return prior;
	}
#endif
#  else
	{
		// swp is the instruction....
		// going to have to set IRQ, PIRQ on arm...
		uint64_t prior = *p;
		*p = val;
		return prior;
	}
#  endif
#endif
}
#endif
//-------------------------------------------------------------------------
#ifdef DEBUG_CRITICAL_SECTIONS
#if 0
static void DumpSection( PCRITICALSECTION pcs )
{
	ll_lprintf( WIDE( "Critical Section....." ) );
	ll_lprintf( WIDE( "------------------------------" ) );
	ll_lprintf( WIDE( "Update: %08x" ), pcs->dwUpdating );
	ll_lprintf( WIDE( "Current Process: %16"_64fx"" ), pcs->dwThreadID );
	ll_lprintf( WIDE( "Next Process:    %16"_64fx"" ), pcs->dwThreadWaiting );
	ll_lprintf( WIDE( "Last update: %s(%d)" ), pcs->pFile ? pcs->pFile : "unknown", pcs->nLine );
}
#endif
#endif
#ifdef __cplusplus
 // namespace memory {
};
 // begin timer namespace
	namespace timers {
#endif
#ifndef USE_NATIVE_CRITICAL_SECTION
		uint32_t  CriticalSecOwners( PCRITICALSECTION pcs )
		{
			return pcs->dwLocks;
		}
#endif
#ifndef USE_NATIVE_CRITICAL_SECTION
//#  ifdef _MSC_VER
//#    pragma optimize( "st", off )
//#  endif
		int32_t  EnterCriticalSecNoWaitEx( PCRITICALSECTION pcs, THREAD_ID *prior DBG_PASS )
		{
			THREAD_ID dwCurProc;
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
#  ifndef NO_LOGGING
			if( g.bLogCritical > 0 && g.bLogCritical < 2 )
				ll__lprintf( DBG_RELAY )(WIDE( "Attempt enter critical Section %") _64fx WIDE( " %" ) _64fx WIDE( " %") _64fx WIDE(" %08" ) _32fx
					, pcs->dwThreadID
					, pcs->dwThreadWaiting
					, (prior?(*prior):-1)
					, pcs->dwLocks);
#  endif
#endif
			// need to aquire lock on section...
			// otherwise our old mechanism allowed an enter in another thread
			// to falsely identify the section as its own while the real owner
			// tried to exit...
			if( XCHG( &pcs->dwUpdating, 1 ) )
				return -1;
#ifdef USE_CUSTOM_ALLOCER
			dwCurProc = _GetMyThreadID();
#else
			dwCurProc = GetMyThreadID();
#endif
			if( !AND_NOT_SECTION_LOGGED_WAIT(pcs->dwLocks) )
			{
				// section is unowned...
				if( pcs->dwThreadWaiting )
				{
					// someone was waiting for it...
					if( pcs->dwThreadWaiting != dwCurProc )
					{
						if( prior ) {
							if( !(*prior) ) {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
								ll__lprintf( DBG_RELAY )(WIDE( "waiter is not myself... this is more recent than him... claim now. %" ) _64fx WIDE( " %" ) _64fx WIDE( " %" ) _64fx, pcs->dwThreadWaiting, prior ? (*prior) : -1LL, pcs->dwThreadID);
#endif
								// this would stack me on top anyway so just allow the waitier to keep waiting....
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
								pcs->pFile[pcs->nPrior] = pFile;
								pcs->nLine[pcs->nPrior] = nLine;
#  else
								pcs->pFile[pcs->nPrior] = __FILE__;
								pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
								pcs->nLineCS[pcs->nPrior] = __LINE__;
								pcs->isLock[pcs->nPrior] = 1;
								pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
								pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
							}
							else {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
								ll__lprintf( DBG_RELAY )(WIDE( "waiter is not myself... AND am in stack of waiter. %" ) _64fx WIDE( " %" ) _64fx WIDE( " %" ) _64fx, pcs->dwThreadWaiting, prior ? (*prior) : -1LL, pcs->dwThreadID);
#endif
								// prior is set, so someone has set their prior to me....
								pcs->dwUpdating = 0;
								return 0;
							}
						}
						else {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
							ll__lprintf( DBG_RELAY )(WIDE( "Waiter which is quick-wait does not sleep; claiming section... %" ) _64fx WIDE( " %" ) _64fx WIDE( " %" ) _64fx, pcs->dwThreadWaiting, prior ? (*prior) : -1LL, pcs->dwThreadID);
#endif
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
							pcs->pFile[pcs->nPrior] = pFile;
							pcs->nLine[pcs->nPrior] = nLine;
#  else
							pcs->pFile[pcs->nPrior] = __FILE__;
							pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
							pcs->nLineCS[pcs->nPrior] = __LINE__;
							pcs->isLock[pcs->nPrior] = 1;
							pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
							pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
						}
					}
 //  waiting is me
					else {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
						ll_lprintf( WIDE( "@@@ Woke up after waiting, set prior waiter as next waiter... %" ) _64fx, prior ? (*prior) : -1LL );
#endif
						if( prior && (*prior) ) {
							if( (*prior) == 1 ) {
								pcs->dwThreadWaiting = 0;
							}
							else
								pcs->dwThreadWaiting = (*prior);
							(*prior) = 0;
						}
						else
							pcs->dwThreadWaiting = 0;
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
						pcs->pFile[pcs->nPrior] = pFile;
						pcs->nLine[pcs->nPrior] = nLine;
#  else
						pcs->pFile[pcs->nPrior] = __FILE__;
						pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
						pcs->nLineCS[pcs->nPrior] = __LINE__;
						pcs->isLock[pcs->nPrior] = 1;
						pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
						pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
					}
				}
				else {
					if( prior && *prior ) {
						// shouldn't happen, if there's no waiter set, then there shouldn't be a prior.
						DebugBreak();
					}
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
					ll_lprintf( WIDE( "Claimed critical section." ) );
#endif
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
					pcs->pFile[pcs->nPrior] = pFile;
					pcs->nLine[pcs->nPrior] = nLine;
#  else
					pcs->pFile[pcs->nPrior] = __FILE__;
					pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
					pcs->nLineCS[pcs->nPrior] = __LINE__;
					pcs->isLock[pcs->nPrior] = 1;
					pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
					pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
				}
 // claim the section and return success
				pcs->dwThreadID = dwCurProc;
				pcs->dwLocks = 1;
				pcs->dwUpdating = 0;
				return 1;
			}
			else if( dwCurProc == pcs->dwThreadID )
			{
				// otherwise 1) I won the thread already... (threadID == me )
				pcs->dwLocks++;
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifndef NO_LOGGING
#    ifdef LOG_DEBUG_CRITICAL_SECTIONS
				if( g.bLogCritical > 0 && g.bLogCritical < 2 )
					ll_lprintf( WIDE( "Locks are %08" )_32fx, pcs->dwLocks );
#    endif
				if( (pcs->dwLocks & 0xFFFFF) > 1 )
				{
#    ifdef LOG_DEBUG_CRITICAL_SECTIONS
					if( g.bLogCritical > 0 && g.bLogCritical < 2 )
						_xlprintf( 1 DBG_RELAY )(WIDE( "!!!!  %p  Multiple Double entry! %" )_32fx, pcs, pcs->dwLocks);
#    endif
				}
#  endif
#  ifdef _DEBUG
				pcs->pFile[pcs->nPrior] = pFile;
				pcs->nLine[pcs->nPrior] = nLine;
#  else
				pcs->pFile[pcs->nPrior] = __FILE__;
				pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
				pcs->nLineCS[pcs->nPrior] = __LINE__;
				pcs->isLock[pcs->nPrior] = 1;
				pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
				pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
				pcs->dwUpdating = 0;
				return 1;
			}
			//if( !(AND_SECTION_LOGGED_WAIT(pcs->dwLocks)) )
			{
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
				pcs->dwLocks |= SECTION_LOGGED_WAIT;
				if( g.bLogCritical )
					ll_lprintf( WIDE( "Waiting on critical section owned by %s(%d) %08lx %." ) _64fx, (pcs->pFile) ? (pcs->pFile) : WIDE( "Unknown" ), pcs->nLine, pcs->dwLocks, pcs->dwThreadID );
#endif
			}
			// if the prior is wanted to be saved...
			if( prior )
			{
				if( *prior )
				{
					if( pcs->dwThreadWaiting != dwCurProc )
					{
						if( !pcs->dwThreadWaiting ) {
							ll_lprintf( WIDE( "@@@ Someone stole the critical section that we were wiating on before we reentered. fail. %" )_64fx WIDE( " %" ) _64fx WIDE( " %" ) _64fx, pcs->dwThreadWaiting, dwCurProc, *prior );
							DebugBreak();
							// go back to sleep again.
							pcs->dwThreadWaiting = dwCurProc;
						}
						else {
							if( (*prior) == pcs->dwThreadWaiting ) {
								ll_lprintf( WIDE( "prior is thread wiaiting (normal?!) %" )_64fx WIDE( " %" ) _64fx, pcs->dwThreadWaiting, *prior );
								DebugBreak();
								(*prior) = 0;
							}
							else {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
								ll_lprintf( WIDE( "Someone stole the critical section that we were wiating on before we reentered. fail. %" )_64fx WIDE( " %" ) _64fx WIDE( " %" ) _64fx, pcs->dwThreadWaiting, dwCurProc, *prior );
#endif
							}
						}
						// assume that someone else kept our waiting ID...
						// cause we're not the one waiting, and we have someone elses ID..
						// we are awake out of order..
						pcs->dwUpdating = 0;
						return 0;
					}
					else {
						// waiting is the current threadproc; but someone claimed the section ahead of this.
					}
				}
				else if( pcs->dwThreadWaiting != dwCurProc )
				{
					if( pcs->dwThreadWaiting ) {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
						if( g.bLogCritical )
							ll_lprintf( WIDE( "@@@ Setting prior to % " ) _64fx WIDE( " and prior was %" ) _64fx, pcs->dwThreadWaiting, (*prior) );
#endif
						*prior = pcs->dwThreadWaiting;
					}
					else {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
						if( g.bLogCritical )
							ll_lprintf( WIDE( "@@@ Setting prior to % " ) _64fx WIDE( " and prior was %" ) _64fx, pcs->dwThreadWaiting, (*prior) );
#endif
						*prior = 1;
					}
					pcs->dwThreadWaiting = dwCurProc;
				}
			}
			else
			{
				// else no prior... so don't set the dwthreadwaiting...
			}
			pcs->dwUpdating = 0;
			return 0;
		}
#endif
		//-------------------------------------------------------------------------
#ifndef USE_NATIVE_CRITICAL_SECTION
//#  ifdef _MSC_VER
//#    pragma optimize( "st", off )
//#  endif
		static LOGICAL LeaveCriticalSecNoWakeEx( PCRITICALSECTION pcs DBG_PASS )
#define LeaveCriticalSecNoWake(pcs) LeaveCriticalSecNoWakeEx( pcs DBG_SRC )
		{
			THREAD_ID dwCurProc;
			while( XCHG( &pcs->dwUpdating, 1 ) )
				Relinquish();
#ifdef USE_CUSTOM_ALLOCER
			dwCurProc = _GetMyThreadID();
#else
			dwCurProc = GetMyThreadID();
#endif
#  ifdef LOG_DEBUG_CRITICAL_SECTIONS
#    ifndef NO_LOGGING
			if( g.bLogCritical > 0 && g.bLogCritical < 2 )
				ll__lprintf( DBG_RELAY )(WIDE( "Locked %p for leaving..." ), pcs);
#    endif
#  endif
			if( !AND_NOT_SECTION_LOGGED_WAIT(pcs->dwLocks) )
			{
				if( g.bLogCritical > 0 && g.bLogCritical < 2 )
					ll_lprintf( DBG_FILELINEFMT WIDE( "Leaving a blank critical section" ) DBG_RELAY );
				DebugBreak();
				//while( 1 );
				pcs->dwUpdating = 0;
				return FALSE;
			}
#ifdef DEBUG_CRITICAL_SECTIONS
			//if( g.bLogCritical > 1 )
			// ll_lprintf( DBG_FILELINEFMT WIDE( "Leaving %"_64fx"x %"_64fx"x %p" ) DBG_RELAY ,pcs->dwThreadID, dwCurProc, pcs );
#endif
			if( pcs->dwThreadID == dwCurProc )
			{
				pcs->dwLocks--;
				if( AND_SECTION_LOGGED_WAIT(pcs->dwLocks) )
				{
					if( !AND_NOT_SECTION_LOGGED_WAIT(pcs->dwLocks) )
					{
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
						pcs->pFile[pcs->nPrior] = pFile;
						pcs->nLine[pcs->nPrior] = nLine;
#  else
						pcs->pFile[pcs->nPrior] = __FILE__;
						pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
						pcs->nLineCS[pcs->nPrior] = __LINE__;
						pcs->isLock[pcs->nPrior] = 0;
						pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
						pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
						pcs->dwLocks = 0;
#endif
						pcs->dwThreadID = 0;
						pcs->dwUpdating = 0;
 // allow whoever was waiting to go now...
						Relinquish();
						return TRUE;
					}
				}
				else
				{
					if( !pcs->dwLocks ) {
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
						pcs->pFile[pcs->nPrior] = pFile;
						pcs->nLine[pcs->nPrior] = nLine;
#  else
						pcs->pFile[pcs->nPrior] = __FILE__;
						pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
						pcs->nLineCS[pcs->nPrior] = __LINE__;
						pcs->isLock[pcs->nPrior] = 1;
						pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
						pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
						pcs->dwThreadID = 0;
					}
				}
				// don't wake the prior (if there is one sleeping)
				// pcs->dwThreadID = 0;
			}
			else
			{
#ifdef DEBUG_CRITICAL_SECTIONS
				{
					_xlprintf( 0 DBG_RELAY )(WIDE( "Sorry - you can't leave a section owned by %") _64fx WIDE(" %08lx %s(%d)..." )
						, pcs->dwThreadID
						, pcs->dwLocks
						, (pcs->pFile[(pcs->nPrior + 15) % MAX_SECTION_LOG_QUEUE]) ? (pcs->pFile[(pcs->nPrior + 15) % MAX_SECTION_LOG_QUEUE]) : WIDE( "Unknown" ), pcs->nLine[(pcs->nPrior + 15) % MAX_SECTION_LOG_QUEUE]);
					DebugBreak();
				}
#else
				lprintf( WIDE( "Sorry - you can't leave a section you don't own..." ) );
				DebugBreak();
#endif
				pcs->dwUpdating = 0;
				return FALSE;
			}
			// allow other locking threads immediate access to section
			// but I know when that happens - since the waiting process
			// will flag - SECTION_LOGGED_WAIT
			pcs->dwUpdating = 0;
			return TRUE;
		}
#else
#define LeaveCriticalSecNoWake(pcs) LeaveCriticalSection(pcs)
#endif
//-------------------------------------------------------------------------
#ifndef USE_NATIVE_CRITICAL_SECTION
		void  InitializeCriticalSec( PCRITICALSECTION pcs )
		{
			memset( pcs, 0, sizeof( CRITICALSECTION ) );
			return;
		}
#endif
#ifdef __cplusplus
 // namespace timers {
	};
 // resume memory namespace
	namespace memory {
#endif
//-------------------------------------------------------------------------
#ifdef _DEBUG
 // last values from getmemstats...
static uint32_t dwBlocks;
static uint32_t dwFreeBlocks;
static uint32_t dwAllocated;
static uint32_t dwFree;
#endif
//------------------------------------------------------------------------------------------------------
static void DoCloseSpace( PSPACE ps, int bFinal );
//------------------------------------------------------------------------------------------------------
LOGICAL OpenRootMemory()
{
	uintptr_t size = sizeof( SPACEPOOL );
	uint32_t created;
	TEXTCHAR spacename[32];
	if( g.pSpacePool != NULL )
	{
		// if local already has something, just return.
		return FALSE;
	}
#ifdef DEBUG_GLOBAL_REGISTRATION
	ll_lprintf( WIDE( "Opening space..." ) );
#endif
#ifdef WIN32
	tnprintf( spacename, sizeof( spacename ), WIDE( "memory:%" ) _32fx, GetCurrentProcessId() );
#else
	tnprintf( spacename, sizeof( spacename ), WIDE( "memory:%08X" ), getpid() );
#  ifdef DEBUG_FIRST_UNICODE_OPERATION
	{
		wchar_t buf[32];
		strcpy( (char*)buf, "abcdefghijklmn" );
		swprintf( buf, 32, L"%s", L"some_name" );
		{
			char tmpmsg[256];
			int chars;
			int ofs = 0;
			ofs = snprintf( tmpmsg, 256, "in the beginning(w):" );
			for( chars = 0; chars < 32; chars++ )
				ofs += snprintf( tmpmsg + ofs, 256 - ofs, "%02x ", ((char*)buf)[chars] );
			__android_log_print( ANDROID_LOG_INFO, "org.d3x0r.sack.xxxx", tmpmsg );
			ofs = snprintf( tmpmsg, 256, "in the beginning(w):" );
			for( chars = 0; chars < 32; chars++ )
				ofs += snprintf( tmpmsg + ofs, 256 - ofs, "%c", (buf)[chars] );
			__android_log_print( ANDROID_LOG_INFO, "org.d3x0r.sack.xxxx", tmpmsg );
			ofs = snprintf( tmpmsg, 256, "in the beginning(w):" );
			for( chars = 0; chars < 32; chars++ )
				ofs += snprintf( tmpmsg + ofs, 256 - ofs, "%c", (name)[chars] );
			__android_log_print( ANDROID_LOG_INFO, "org.d3x0r.sack.xxxx", tmpmsg );
			ofs = snprintf( tmpmsg, 256, "in the beginning(w):" );
			for( chars = 0; chars < 32; chars++ )
				ofs += snprintf( tmpmsg + ofs, 256 - ofs, "%c", (spacename)[chars] );
			__android_log_print( ANDROID_LOG_INFO, "org.d3x0r.sack.xxxx", tmpmsg );
		}
	}
#  endif
#endif
	// hmm application only shared space?
	// how do I get that to happen?
	 g.pSpacePool = (PSPACEPOOL)OpenSpaceExx( spacename, NULL, 0, &size, &created );
	// I myself must have a global space, which is kept sepearte from named spaces
	// but then... blah
	return created;
}
// hmm this runs
PRIORITY_ATEXIT(ReleaseAllMemory,ATEXIT_PRIORITY_SHAREMEM)
{
#ifdef __SKIP_RELEASE_OPEN_SPACES__
	// actually, under linux, it releases /tmp/.shared files.
	//ll_lprintf( WIDE( "No super significant reason to release all memory blocks?" ) );
	//ll_lprintf( WIDE( "Short circuit on memory shutdown." ) );
	return;
#else
	// need to try and close /tmp/.shared region files...  so we only close
	// temporary spaces
	PSPACEPOOL psp;
	PSPACE ps;
	while( ( psp = g.pSpacePool ) )
	{
		int i;
		// I didn't allocate at the root; someone else is responsible.
		if( psp->me != &g.pSpacePool )
			break;
		for( i = 0; i < (((int)(MAX_PER_BLOCK))-1); i++ )
		{
			ps = psp->spaces + i;
			if( ps->pMem )
			{
				/*
				* if we do this, then logging will attempt to possibly use memory which was allocated from this?
#ifdef _DEBUG
				if( !g.bDisableDebug )
				{
					ll_lprintf( WIDE("Space: %p mem: %p-%p"), ps, ps->pMem, (uint8_t*)ps->pMem + ps->dwSmallSize );
					ll_lprintf( WIDE("Closing tracked space...") );
				}
#endif
*/
#ifndef _WIN32
				if( ps->flags.bTemporary )
#endif
					DoCloseSpace( ps, TRUE );
			}
		}
		if( !(*psp->me) )
			break;
		if( ( (*psp->me) = psp->next ) )
			psp->next->me = psp->me;
#ifdef _WIN32
		UnmapViewOfFile( ps->pMem );
		CloseHandle( ps->hMem );
		CloseHandle( ps->hFile );
#else
		//ll_lprintf( WIDE("unmaping space tracking structure...") );
		munmap( ps, MAX_PER_BLOCK * sizeof( SPACE ) );
		//close( (int)ps->pMem );
		//if( ps->hFile >= 0 )
		//	close( ps->hFile );
#endif
	}
#endif
	g.bInit = FALSE;
}
//------------------------------------------------------------------------------------------------------
void InitSharedMemory( void )
{
	if( !g.bInit )
	{
	// this would be really slick to do
	// especially in the case where files have been used
	// to back storage...
	// so please do make releaseallmemory smarter and dlea
	// only with closing those regions which have a file
		// backing, espcecially those that are temporary chickens.
		//atexit( ReleaseAllMemory );
#ifdef _WIN32
		GetSystemInfo( &g.si );
#else
		g.pagesize = sysconf(_SC_PAGESIZE);
#endif
#ifdef VERBOSE_LOGGING
		if( !g.bDisableDebug )
			Log2( WIDE("CHUNK: %d  MEM:%d"), CHUNK_SIZE(0), MEM_SIZE );
#endif
  // onload was definatly a zero.
		g.bInit = TRUE;
		{
			if( OpenRootMemory() )
			{
				MemSet( g.pSpacePool, 0, sizeof( SPACEPOOL ) );
				g.pSpacePool->me = &g.pSpacePool;
#ifdef VERBOSE_LOGGING
				if( !g.bDisableDebug )
					Log1( WIDE("Allocated Space pool %lu"), dwSize );
#endif
			}
		}
	}
	else
	{
#ifdef VERBOSE_LOGGING
		if( !g.bDisableDebug )
			ODS( WIDE("already initialized?") );
#endif
	}
}
//------------------------------------------------------------------------------------------------------
// private
static PSPACE AddSpace( PSPACE pAddAfter
#if defined( WIN32 ) || defined( __CYGWIN__ )
							, HANDLE hFile
							, HANDLE hMem
#else
							, int hFile
							, int hMem
#endif
							, POINTER pMem, uintptr_t dwSize, int bLink )
{
	PSPACEPOOL psp;
	PSPACEPOOL _psp = NULL;
	PSPACE ps;
	int i;
	if( !g.pSpacePool || g.InAdding )
	{
#ifdef VERBOSE_LOGGING
		if( !g.bDisableDebug )
			Log2( WIDE("No space pool(%p) or InAdding(%d)"), g.pSpacePool, g.InAdding );
#endif
		return NULL;
	}
	g.InAdding = 1;
	//_ps = NULL;
	psp = g.pSpacePool;
Retry:
	do {
		ps = psp->spaces;
		for( i = 0; i < (((int)(MAX_PER_BLOCK))-1); i++ )
		{
			if( !ps[i].pMem )
			{
				ps += i;
				break;
			}
		}
		if( i == (MAX_PER_BLOCK-1) )
		{
			_psp = psp;
			psp = psp->next;
		}
		else
			break;
	} while( psp );
	if( !psp )
	{
		//DebugBreak(); // examine conditions for allocating new space block...
		dwSize = sizeof( SPACEPOOL );
		if( _psp )
		{
			psp = _psp->next = (PSPACEPOOL)OpenSpace( NULL, NULL, &dwSize );
			MemSet( psp, 0, dwSize );
			psp->me = &_psp->next;
		}
		goto Retry;
	}
	//Log7( WIDE("Managing space (s)%p (pm)%p (hf)%08") _32fx WIDE(" (hm)%08") _32fx WIDE(" (sz)%") _32f WIDE(" %08") _32fx WIDE("-%08") _32fx WIDE("")
	//				, ps, pMem, (uint32_t)hFile, (uint32_t)hMem, dwSize
	//				, (uint32_t)pMem, ((uint32_t)pMem + dwSize)
	//				);
	ps->pMem = (PMEM)pMem;
	// okay yes I made this line ugly.
	ps->hFile =
#ifdef _WIN32
					(HANDLE)
#endif
								hFile;
#ifdef _WIN32
	ps->hMem = hMem;
#endif
	ps->dwSmallSize = dwSize;
	/*
	if( bLink )
	{
		while( AddAfter && AddAfter->next )
			AddAfter = AddAfter->next;
		//Log2( WIDE("Linked into space...%p after %p "), ps, AddAfter );
		if( AddAfter )
		{
			ps->me = &AddAfter->next;
			AddAfter->next = ps;
		}
		  ps->next = NULL;
	}
	*/
	g.InAdding = 0;
	return ps;
}
//------------------------------------------------------------------------------------------------------
PSPACE FindSpace( POINTER pMem )
{
	PSPACEPOOL psp;
	INDEX idx;
	for( psp = g.pSpacePool;psp; psp = psp->next)
		for( idx = 0; idx < MAX_PER_BLOCK; idx++ )
			if( psp->spaces[idx].pMem == pMem )
				return psp->spaces + idx;
	return NULL;
}
//------------------------------------------------------------------------------------------------------
static void DoCloseSpace( PSPACE ps, int bFinal )
{
	if( ps )
	{
		//Log( WIDE("Closing a space...") );
#ifdef _WIN32
		UnmapViewOfFile( ps->pMem );
		CloseHandle( ps->hMem );
		CloseHandle( ps->hFile );
#else
		munmap( ps->pMem, ps->dwSmallSize );
		if( ps->flags.bTemporary && (ps->hFile >= 0) )
		{
			if( bFinal )
			{
				char file[256];
				char fdname[64];
				snprintf( fdname, sizeof(fdname), "/proc/self/fd/%d", (int)ps->hFile );
				file[readlink( fdname, file, sizeof( file ) )] = 0;
				remove( file );
			}
			close( (int)ps->hFile );
		}
#endif
		MemSet( ps, 0, sizeof( SPACE ) );
	}
}
//------------------------------------------------------------------------------------------------------
 void  CloseSpaceEx ( POINTER pMem, int bFinal )
{
	DoCloseSpace( FindSpace( pMem ), bFinal );
}
//------------------------------------------------------------------------------------------------------
 void  CloseSpace ( POINTER pMem )
{
	DoCloseSpace( FindSpace( pMem ), TRUE );
}
//------------------------------------------------------------------------------------------------------
 uintptr_t  GetSpaceSize ( POINTER pMem )
{
	PSPACE ps;
	ps = FindSpace( pMem );
	if( ps )
		return ps->dwSmallSize;
	return 0;
}
#if defined( __LINUX__ ) && !defined( __CYGWIN__ )
uintptr_t GetFileSize( int fd )
{
	uintptr_t len = lseek( fd, 0, SEEK_END );
	lseek( fd, 0, SEEK_SET );
	return len;
}
#endif
//------------------------------------------------------------------------------------------------------
 POINTER  OpenSpaceExx ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t address, uintptr_t *dwSize, uint32_t* bCreated )
{
	POINTER pMem = NULL;
#ifdef USE_SIMPLE_LOCK_ON_OPEN
	static uint32_t bOpening;
#endif
#ifndef USE_SIMPLE_LOCK_ON_OPEN
	static CRITICALSECTION cs;
	static int first = 1;
#endif
	int readonly = FALSE;
	if( !g.bInit )
	{
		//ODS( WIDE("Doing Init") );
		InitSharedMemory();
	}
#ifndef USE_SIMPLE_LOCK_ON_OPEN
	if( g.deadstart_finished )
	{
		if( first )
		{
			InitializeCriticalSection( &cs );
			first = 0;
		}
		while( !EnterCriticalSecNoWait( &cs, NULL ) )
			Relinquish();
	}
#else
	while( XCHG( &bOpening, 1 ) )
		Relinquish();
#endif
	{
#ifdef __LINUX__
		char *filename = NULL;
		int fd = -1;
		int bTemp = FALSE;
		int exists = FALSE;
		if( !pWhat && !pWhere)
		{
			pMem = mmap( 0, *dwSize
						 , PROT_READ|PROT_WRITE
						 , MAP_SHARED|MAP_ANONYMOUS
						 ,
#ifdef __QNX__
  // QNX Note; NOFD = -1
							NOFD
 // other systems were quite happy to have a 0 here for the handle.
#else
							0
#endif
						  , 0 );
			if( pMem == (POINTER)-1 )
			{
				ll_lprintf( WIDE("Something bad about this region sized %") _PTRSZVALfs WIDE("(%d)"), *dwSize, errno );
				DebugBreak();
			}
			//ll_lprintf( WIDE("Clearing anonymous mmap %p %") _size_f WIDE(""), pMem, *dwSize );
			MemSet( pMem, 0, *dwSize );
		}
 // name doesn't matter, same file cannot be called another name
		else if( pWhere )
		{
			filename = (char*)pWhere;
		 }
		else if( pWhat )
		{
			int len;
         char tmpbuf[256];
#ifdef __ANDROID__
			//if( !IsPath( "./tmp" ) )
			//	if( !MakePath( "./tmp" ) )
			//		ll_lprintf( "Failed to create a temporary space" );
			filename = tmpbuf;
			snprintf( tmpbuf, 256, "./tmp.shared.%s", pWhat );
#else
			filename = tmpbuf;
			snprintf( tmpbuf, 256, WIDE("/tmp/.shared.%s"), pWhat );
#endif
			bTemp = TRUE;
		}
		//ll_lprintf( "Open Space: %s", filename?filename:"anonymous" );
		if( !pMem && filename )
		{
#ifdef __ANDROID__
			//fd = ashmem_create_region( filename , size );
			if( pWhat )
			{
				fd = open(filename, O_RDWR);
				if (fd < 0 )
				{
					int ret;
					if( !(*dwSize ) )
					{
						ll_lprintf( WIDE("Region didn't exist... and no size... return") );
						return NULL;
					}
#   ifdef DEBUG_SHARED_REGION_CREATE
					ll_lprintf( WIDE("Shared region didn't already exist...: %s"), filename );
#   endif
					fd = open("/dev/ashmem", O_RDWR);
					if( fd < 0 )
					{
						ll_lprintf( WIDE("Failed to open core device...") );
						return NULL;
					}
					if( bCreated )
						(*bCreated) = 1;
 // skip 11 for the "/dev/ashmem/"
					ret = ioctl(fd, ASHMEM_SET_NAME, filename + 12 );
					if (ret < 0)
					{
						ll_lprintf( WIDE("Failed to set the name of ashmem region: %s"), filename + 12 );
						//							goto error;
					}
					ret = ioctl(fd, ASHMEM_SET_SIZE, (*dwSize) );
					if (ret < 0)
					{
						ll_lprintf( WIDE("Failed to set IOCTL size to %d"), (*dwSize) );
						//goto error;
					}
					/*
					 {
						// unpin; pages will be pined to start (I think)
						struct ashmem_pin pin = {
							.offset = 0,
							.len    = (*dwSize)
						};
						ret = ioctl(fd, ASHMEM_UNPIN, &pin);
					}
					*/
				}
				else
				{
					if( bCreated )
						(*bCreated) = 1;
				}
			}
			else
#endif
			{
				mode_t prior;
				if( bCreated )
					(*bCreated) = 1;
				prior = umask( 0 );
				fd = open( filename, O_RDWR|O_CREAT|O_EXCL, 0600 );
				umask(prior);
			}
			if( fd == -1 )
			{
				//ll_lprintf( "open is %d %s %d", errno, filename, prior );
				// if we didn't create the file...
				// then it can't be marked as temporary...
				bTemp = FALSE;
				if( GetLastError() == EEXIST )
				{
					exists = TRUE;
					fd = open( filename, O_RDWR );
					bTemp = FALSE;
					if( bCreated )
						(*bCreated) = 0;
				}
				if( fd == -1 )
				{
					readonly = TRUE;
					fd = open( filename, O_RDONLY );
				}
				if( fd == -1 )
				{
					Log2( WIDE("Sorry - failed to open: %d %s")
						, errno
						, filename );
#ifndef USE_SIMPLE_LOCK_ON_OPEN
					if( g.deadstart_finished )
					{
						LeaveCriticalSecNoWake( &cs );
					}
#else
					bOpening = FALSE;
#endif
					//if(filename)Release( filename );
					return NULL;
				}
			}
			if( exists )
			{
				if( GetFileSize( fd ) < (uintptr_t)*dwSize )
				{
					// expands the file...
					ftruncate( fd, *dwSize );
					//*dwSize = ( ( *dwSize + ( FILE_GRAN - 1 ) ) / FILE_GRAN ) * FILE_GRAN;
				}
				else
				{
					// expands the size requested to that of the file...
					(*dwSize) = GetFileSize( fd );
				}
			}
			else
			{
				if( !*dwSize )
				{
					// can't create a 0 sized file this way.
 // not zero.
					(*dwSize) = 1;
					close( fd );
					unlink( filename );
#ifndef USE_SIMPLE_LOCK_ON_OPEN
					if( g.deadstart_finished )
					{
						LeaveCriticalSecNoWake( &cs );
					}
#else
					bOpening = FALSE;
#endif
					//if(filename)Release( filename );
					return NULL;
				}
				//*dwSize = ( ( *dwSize + ( FILE_GRAN - 1 ) ) / FILE_GRAN ) * FILE_GRAN;
				ftruncate( fd, *dwSize );
			}
			pMem = mmap( 0, *dwSize
			          , PROT_READ|(readonly?(0):PROT_WRITE)
			          , MAP_SHARED|((fd<0)?MAP_ANONYMOUS:0)
			          , fd, 0 );
			if( !exists && pMem )
			{
				MemSet( pMem, 0, *dwSize );
			}
		}
		if( pMem )
		{
			PSPACE ps = AddSpace( NULL, fd, 0, pMem, *dwSize, TRUE );
			if( ps )
				ps->flags.bTemporary = bTemp;
		}
#ifndef USE_SIMPLE_LOCK_ON_OPEN
		if( g.deadstart_finished )
		{
			LeaveCriticalSecNoWake( &cs );
		}
#else
		bOpening = FALSE;
#endif
		//if(filename)Release( filename );
		return pMem;
#elif defined( _WIN32 )
#ifndef UNDER_CE
		LOGICAL didCreate = FALSE;
		HANDLE hFile;
		HANDLE hMem = NULL;
		*dwSize = ( ( (*dwSize) + ( FILE_GRAN - 1 ) ) / FILE_GRAN ) * FILE_GRAN;
		if( !pWhat && !pWhere )
		{
			//ll_lprintf( "ALLOCATE %"_64fx"d", (*dwSize)>>32, 0 );
			hMem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL
											, PAGE_READWRITE
											|SEC_COMMIT
#if __64__
 // dwSize is sometimes 64 bit... this should be harmless
											, (*dwSize)>>32
											, (*dwSize) & (0xFFFFFFFF)
#else
											, 0
											, (*dwSize)
#endif
 // which should be NULL... but is consistant
											, pWhat );
			if( !hMem )
			{
				//ll_lprintf( "Failed to allocate pagefile memory?! %p %d", *dwSize, GetLastError() );
				{
					POINTER p = malloc( *dwSize );
					//ll_lprintf(" but we could allocate it %p", p  );
#ifndef USE_SIMPLE_LOCK_ON_OPEN
					if( g.deadstart_finished )
					{
						LeaveCriticalSecNoWake( &cs );
					}
#else
					bOpening = 0;
#endif
					return p;
				}
			}
			else
			{
			// created and this size is right...
				if( bCreated )
					(*bCreated) = TRUE;
			}
		}
		else if( pWhat )
		{
			hMem = OpenFileMapping( FILE_MAP_READ|FILE_MAP_WRITE
										, FALSE
										, pWhat );
			if( hMem )
			{
				if( bCreated )
					(*bCreated) = FALSE;
			}
			else
			{
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( WIDE("Failed to open region named %s %d"), pWhat, GetLastError() );
#endif
  // don't continue... we're expecting open-existing behavior
				if( (*dwSize) == 0 )
				{
#ifndef USE_SIMPLE_LOCK_ON_OPEN
					if( g.deadstart_finished )
					{
						LeaveCriticalSecNoWake( &cs );
					}
#else
					bOpening = 0;
#endif
					return FALSE;
				}
			}
		}
		hFile = INVALID_HANDLE_VALUE;
		// I would have hmem here if the file was validly opened....
		if( !hMem )
		{
			hFile = CreateFile( pWhere, GENERIC_READ|GENERIC_WRITE
									,FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE
 // default security
									,NULL
									,(dwSize&&(*dwSize)) ? OPEN_ALWAYS : OPEN_EXISTING
 //|FILE_ATTRIBUTE_TEMPORARY
									,FILE_ATTRIBUTE_NORMAL
									//| FILE_FLAG_WRITE_THROUGH
									//| FILE_FLAG_NO_BUFFERING
									// must access on sector bournds
									// must read complete sectors
									//| FILE_FLAG_DELETE_ON_CLOSE
									, NULL );
#ifdef DEBUG_OPEN_SPACE
			ll_lprintf( WIDE("Create file %s result %d"), pWhere, hFile );
			ll_lprintf( WIDE("File result is %ld (error %ld)"), hFile, GetLastError() );
#endif
			if( hFile == INVALID_HANDLE_VALUE )
			{
				readonly = 1;
				if( ( dwSize && (!(*dwSize )) ) && ( GetLastError() == ERROR_PATH_NOT_FOUND || GetLastError() == ERROR_FILE_NOT_FOUND ) )
				{
#ifdef DEBUG_OPEN_SPACE
					ll_lprintf( WIDE("File did not exist, and we're not creating the file (0 size passed)") );
#endif
#ifndef USE_SIMPLE_LOCK_ON_OPEN
					if( g.deadstart_finished )
					{
						LeaveCriticalSecNoWake( &cs );
					}
#else
					bOpening = 0;
#endif
					return NULL;
				}
				hFile = CreateFile( pWhere, GENERIC_READ
										,FILE_SHARE_READ|FILE_SHARE_DELETE
 // default security
										,NULL
										,OPEN_ALWAYS
 //|FILE_ATTRIBUTE_TEMPORARY
										,FILE_ATTRIBUTE_NORMAL
										//| FILE_FLAG_WRITE_THROUGH
										//| FILE_FLAG_NO_BUFFERING
										// must access on sector bournds
										// must read complete sectors
										//| FILE_FLAG_DELETE_ON_CLOSE
										, NULL );
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( WIDE("Create file %s result %d"), pWhere, hFile );
#endif
				if( hFile != INVALID_HANDLE_VALUE ) {
 // lie...
					SetLastError( ERROR_ALREADY_EXISTS );
				}
			}
			else {
 // lie...
				SetLastError( ERROR_ALREADY_EXISTS );
			}
			if( hFile == INVALID_HANDLE_VALUE )
			{
				// might still be able to open it by shared name; even if the file share is disabled
				readonly = 0;
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( WIDE("file is still invalid(alreadyexist?)... new size is %d %d on %p"), (*dwSize), FILE_GRAN, hFile );
#endif
 // is INVALID_HANDLE_VALUE, but is consistant
				hMem = CreateFileMapping( hFile
												, NULL
												, (readonly?PAGE_READONLY:PAGE_READWRITE)
												/*|SEC_COMMIT|SEC_NOCACHE*/
#ifdef __64__
												, (uint32_t)((*dwSize)>>32)
#else
												, 0
#endif
												, (uint32_t)(*dwSize)
												, pWhat );
				if( hMem )
				{
					if( bCreated )
						(*bCreated) = 1;
					goto isokay;
				}
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( WIDE("Sorry - Nothing good can happen with a filename like that...%s %d"), pWhat, GetLastError());
#endif
					 //bOpening = FALSE;
#ifndef USE_SIMPLE_LOCK_ON_OPEN
				if( g.deadstart_finished )
				{
					LeaveCriticalSecNoWake( &cs );
				}
#else
				bOpening = 0;
#endif
				return NULL;
			}
			if( GetLastError() == ERROR_ALREADY_EXISTS )
			{
				LARGE_INTEGER lSize;
				GetFileSizeEx( hFile, &lSize );
			// mark status for memory... dunno why?
				// in theory this is a memory image of valid memory already...
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( WIDE("Getting existing size of region...") );
#endif
				if( SUS_LT( lSize.QuadPart, LONGLONG, (*dwSize), uintptr_t ) )
				{
#ifdef DEBUG_OPEN_SPACE
					ll_lprintf( WIDE("Expanding file to size requested.") );
#endif
					didCreate = 1;
					SetFilePointer( hFile, (LONG)*dwSize, NULL, FILE_BEGIN );
					SetEndOfFile( hFile );
				}
				else
				{
#ifdef DEBUG_OPEN_SPACE
					ll_lprintf( WIDE("Setting size to size of file (which was larger..") );
#endif
					(*dwSize) = (uintptr_t)(lSize.QuadPart);
				}
			}
			else
			{
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( WIDE("New file, setting size to requested %d"), *dwSize );
#endif
				SetFilePointer( hFile, (LONG)*dwSize, NULL, FILE_BEGIN );
				SetEndOfFile( hFile );
				didCreate = 1;
			}
			if( bCreated )
				(*bCreated) = didCreate;
			//(*dwSize) = GetFileSize( hFile, NULL );
#ifdef DEBUG_OPEN_SPACE
			ll_lprintf( WIDE("%s Readonly? %d  hFile %d"), pWhat, readonly, hFile );
#endif
			hMem = CreateFileMapping( hFile
											, NULL
											, (readonly?PAGE_READONLY:PAGE_READWRITE)
											/*|SEC_COMMIT|SEC_NOCACHE*/
											, 0, 0
											, pWhat );
			if( pWhat && !hMem )
			{
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( WIDE("Create of mapping failed on object specified? %d %p"), GetLastError(), hFile );
#endif
				(*dwSize) = 1;
				CloseHandle( hFile );
				//bOpening = FALSE;
#ifndef USE_SIMPLE_LOCK_ON_OPEN
				if( g.deadstart_finished )
				{
					LeaveCriticalSecNoWake( &cs );
				}
#else
				bOpening = 0;
#endif
				return NULL;
			}
		}
	isokay:
      /*
		if( !hMem )
		{
			pMem = VirtualAlloc( address, (*dwSize), 0 ,PAGE_READWRITE );
			if( !VirtualLock( pMem, (*dwSize ) ) )
            DebugBreak();
		}
		else
      */
		{
			pMem = MapViewOfFileEx( hMem
										, FILE_MAP_READ| ((readonly)?(0):(FILE_MAP_WRITE))
  // offset high, low
										, 0, 0
	 // size of file to map
										, 0
 // don't specify load location... irrelavent...
										, (POINTER)address );
		}
	if( !pMem )
	{
#ifdef DEBUG_OPEN_SPACE
		Log1( WIDE("Create view of file for memory access failed at %p"), (POINTER)address );
#endif
		CloseHandle( hMem );
		if( hFile != INVALID_HANDLE_VALUE )
			CloseHandle( hFile );
#ifndef USE_SIMPLE_LOCK_ON_OPEN
		if( g.deadstart_finished )
		{
			LeaveCriticalSecNoWake( &cs );
		}
#else
		bOpening = 0;
#endif
		return NULL;
	}
	else
	{
		if( bCreated && !(*bCreated) && ((*dwSize) == 0) )
		{
			MEMORY_BASIC_INFORMATION meminfo;
			VirtualQuery( pMem, &meminfo, sizeof( meminfo ) );
			(*dwSize) = meminfo.RegionSize;
#ifdef DEBUG_OPEN_SPACE
			ll_lprintf( WIDE("Fixup memory size to %ld %s:%s(reported by system on view opened)")
					, *dwSize, pWhat?pWhat:"ANON", pWhere?pWhere:"ANON" );
#endif
		}
	}
	// store information about this
	// external to the space - do NOT
	// modify content of memory opened!
	AddSpace( NULL, hFile, hMem, pMem, *dwSize, TRUE );
#ifndef USE_SIMPLE_LOCK_ON_OPEN
	if( g.deadstart_finished )
	{
		LeaveCriticalSecNoWake( &cs );
	}
#else
      bOpening = 0;
#endif
	return pMem;
#else
	if( bCreated )
		(*bCreated) = 1;
	return malloc( *dwSize );
#endif
#endif
	}
}
//------------------------------------------------------------------------------------------------------
#undef OpenSpaceEx
 POINTER  OpenSpaceEx ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t address, uintptr_t *dwSize )
{
	uint32_t bCreated;
	return OpenSpaceExx( pWhat, pWhere, address, dwSize, &bCreated );
}
//------------------------------------------------------------------------------------------------------
#undef OpenSpace
 POINTER  OpenSpace ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t *dwSize )
{
	return OpenSpaceEx( pWhat, pWhere, 0, dwSize );
}
//------------------------------------------------------------------------------------------------------
 int  InitHeap( PMEM pMem, uintptr_t dwSize )
{
	//pMem->dwSize = *dwSize - MEM_SIZE;
	// size of the PMEM block is all inclusive (from pMem(0) to pMem(dwSize))
	// do NOT need to substract the size of the tracking header
	// otherwise we would be working from &pMem->pRoot + dwSize
	if( pMem->dwSize )
	{
		if( pMem->dwHeapID != 0xbab1f1ea )
		{
			ll_lprintf( WIDE("Memory has content, and is NOT a heap!") );
			return FALSE;
		}
		ll_lprintf( WIDE("Memory was already initialized as a heap?") );
		return FALSE;
	}
	if( !FindSpace( pMem ) )
	{
		//ll_lprintf( WIDE("space for heap has not been tracked yet....") );
		// a heap must be in the valid space pool.
		// it may not have come from a file, and will not have
		// a file or memory handle.
		AddSpace( NULL, 0, 0, pMem, dwSize, TRUE );
	}
	// the size passed is the full size of the memory, so we need to remove sizeof(MEM)
	// so there is room to track heap info at the start of the heap.
	dwSize -= sizeof( MEM );
	pMem->dwSize = dwSize;
	pMem->dwHeapID = 0xbab1f1ea;
	pMem->pFirstFree = NULL;
	pMem->dwFlags = 0;
	LinkThing( pMem->pFirstFree, pMem->pRoot );
	InitializeCriticalSec( &pMem->cs );
	pMem->pRoot[0].dwSize = dwSize - MEM_SIZE - CHUNK_SIZE;
	pMem->pRoot[0].dwPad = MAGIC_SIZE;
	pMem->pRoot[0].dwOwners = 0;
	pMem->pRoot[0].pRoot  = pMem;
	pMem->pRoot[0].pPrior = NULL;
#ifdef _DEBUG
	if( !g.bDisableDebug )
	{
#ifdef VERBOSE_LOGGING
		ll_lprintf( WIDE("Initializing %p %d")
				, pMem->pRoot[0].byData
				, pMem->pRoot[0].dwSize );
#endif
		MemSet( pMem->pRoot[0].byData, 0x1BADCAFE, pMem->pRoot[0].dwSize );
		BLOCK_TAG( pMem->pRoot ) = BLOCK_TAG_ID;
	}
	{
		pMem->pRoot[0].dwPad += 2*MAGIC_SIZE;
		BLOCK_FILE( pMem->pRoot ) = _WIDE(__FILE__);
		BLOCK_LINE( pMem->pRoot ) = __LINE__;
	}
#endif
	return TRUE;
}
//------------------------------------------------------------------------------------------------------
PMEM DigSpace( TEXTSTR pWhat, TEXTSTR pWhere, uintptr_t *dwSize )
{
	PMEM pMem = (PMEM)OpenSpace( pWhat, pWhere, dwSize );
	if( !pMem )
	{
		// did reference BASE_MEMORY...
		ll_lprintf( WIDE("Create view of file for memory access failed at %p %p"), pWhat, pWhere );
		CloseSpace( (POINTER)pMem );
		return NULL;
	}
#ifdef VERBOSE_LOGGING
	Log( WIDE("Go to init the heap...") );
#endif
	pMem->dwSize = 0;
#if USE_CUSTOM_ALLOCER
	InitHeap( pMem, *dwSize );
#endif
	return pMem;
}
//------------------------------------------------------------------------------------------------------
int ExpandSpace( PMEM pHeap, uintptr_t dwAmount )
{
	PSPACE pspace = FindSpace( (POINTER)pHeap ), pnewspace;
	PMEM pExtend;
	//ll_lprintf( WIDE("Expanding by %d %d"), dwAmount );
	pExtend = DigSpace( NULL, NULL, &dwAmount );
	if( !pExtend )
	{
		ll_lprintf( WIDE("Failed to expand space by %") _PTRSZVALfs, dwAmount );
		return FALSE;
	}
	pnewspace = FindSpace( pExtend );
	if( pnewspace )
	{
		while( pspace && pspace->next )
			pspace = pspace->next;
		if( ( pspace->next = pnewspace ) )
		{
			pnewspace->me = &pspace->next;
		}
	}
	return TRUE;
}
//------------------------------------------------------------------------------------------------------
static PMEM InitMemory( void ) {
	uintptr_t MinSize = SYSTEM_CAPACITY;
	// generic internal memory, unnamed, unshared, unsaved
	g.pMemInstance = DigSpace( NULL, NULL, &MinSize );
	if( !g.pMemInstance )
	{
		g.bMemInstanced = FALSE;
		ODS( WIDE( "Failed to allocate memory - assuming fatailty at Allocation service level." ) );
		return NULL;
	}
	return g.pMemInstance;
}
//------------------------------------------------------------------------------------------------------
static PMEM GrabMemEx( PMEM pMem DBG_PASS )
#define GrabMem(m) GrabMemEx( m DBG_SRC )
{
	if( !pMem )
	{
		// use default heap...
		if( !XCHG( &g.bMemInstanced, TRUE ) )
			pMem = InitMemory();
		else
			return 0;
	}
	//ll_lprintf( WIDE("grabbing memory %p"), pMem );
	{
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
		int log = g.bLogCritical;
		g.bLogCritical = 0;
#endif
#ifdef USE_NATIVE_CRITICAL_SECTION
		while( !TryEnterCriticalSection( &pMem->cs ) )
		{
			Relinquish();
		}
#else
		while( EnterCriticalSecNoWaitEx( &pMem->cs, NULL DBG_RELAY ) <= 0 )
		{
			Relinquish();
		}
#endif
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
		g.bLogCritical = log;
#endif
	}
	return pMem;
}
//------------------------------------------------------------------------------------------------------
static void DropMemEx( PMEM pMem DBG_PASS )
#define DropMem(m) DropMemEx( m DBG_SRC)
{
	if( !pMem )
		return;
	//ll_lprintf( WIDE("dropping memory %p"), pMem );
	{
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
		int log = g.bLogCritical;
		g.bLogCritical = 0;
#endif
#ifdef USE_NATIVE_CRITICAL_SECTION
		LeaveCriticalSection( &pMem->cs );
#else
		LeaveCriticalSecNoWakeEx( &pMem->cs DBG_RELAY );
#endif
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
		g.bLogCritical = log;
#endif
	}
}
//------------------------------------------------------------------------------------------------------
POINTER HeapAllocateAlignedEx( PMEM pHeap, uintptr_t dwSize, uint16_t alignment DBG_PASS )
{
   // if a heap is passed, it's a private heap, and allocation is as normal...
	uint32_t dwAlignPad = 0;
	if( alignment ) {
		dwSize += (alignment - 1);
		dwAlignPad = (alignment - 1);
	}
	if( !pHeap && !USE_CUSTOM_ALLOCER )
	{
		PMALLOC_CHUNK pc;
#ifdef ENABLE_NATIVE_MALLOC_PROTECTOR
		pc = (PMALLOC_CHUNK)malloc( sizeof( MALLOC_CHUNK ) - 1 + alignment + dwSize + sizeof( pc->LeadProtect ) );
		if( !pc )
			DebugBreak();
		MemSet( pc->LeadProtect, LEAD_PROTECT_TAG, sizeof( pc->LeadProtect ) );
		MemSet( pc->byData + dwSize, LEAD_PROTECT_BLOCK_TAIL, sizeof( pc->LeadProtect ) );
#else
		pc = (PMALLOC_CHUNK)malloc( sizeof( MALLOC_CHUNK ) - 1 + dwSize );
#endif
		pc->dwOwners = 1;
		pc->dwSize = dwSize;
		pc->dwPad = dwAlignPad;
#ifndef NO_LOGGING
#  ifdef _DEBUG
		if( g.bLogAllocate )
		{
			ll__lprintf(DBG_RELAY)( WIDE( "alloc %p(%p) %" ) _PTRSZVALfs, pc, pc->byData, dwSize );
		}
#  endif
#endif
		if( alignment && ( (uintptr_t)pc->byData & ~masks[alignment] ) ) {
			uintptr_t retval = ((((uintptr_t)pc->byData) + (alignment - 1)) & masks[alignment]);
			//pc->dwPad = (uint16_t)( dwAlignPad - sizeof(uintptr_t) );
			// to_chunk_start is the last thing in chunk, so it's pre-allocated space
 /*pc->alignemnt = */
			((uint16_t*)(retval - sizeof(uint32_t)))[0] =alignment;
 /*pc->to_chunk_start = */
			((uint16_t*)(retval - sizeof(uint32_t)))[1] =(uint16_t)(((((uintptr_t)pc->byData) + (alignment - 1)) & masks[alignment]) - (uintptr_t)pc->byData);
			return (POINTER)retval;
		}
		else {
			pc->alignment = 0;
			pc->to_chunk_start = 0;
			return pc->byData;
		}
	}
	else
	{
		PHEAP_CHUNK pc;
		PMEM pMem, pCurMem = NULL;
		PSPACE pMemSpace;
		uint32_t dwPad = 0;
		uint32_t dwMin = 0;
		//ll__lprintf(DBG_RELAY)( WIDE( "..." ) );
#ifdef _DEBUG
		if( !g.bDisableAutoCheck )
			GetHeapMemStatsEx(pHeap, &dwFree,&dwAllocated,&dwBlocks,&dwFreeBlocks DBG_RELAY);
#endif
 // no size is NO space!
		if( !dwSize )
		{
			return NULL;
		}
		// if memstats is used - memory could have been initialized there...
		// so wait til now to grab g.pMemInstance.
		if( !pHeap )
			pHeap = g.pMemInstance;
		pMem = GrabMem( pHeap );
#ifdef __64__
 // fix size to allocate at least _32s which
		dwSize += 7;
		dwSize &= 0xFFFFFFFFFFFFFFF8;
#else
 // fix size to allocate at least _32s which
		dwSize += 3;
		dwSize &= 0xFFFFFFFC;
#endif
#ifdef _DEBUG
		if( pMem && !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
		{
			dwPad += MAGIC_SIZE * 2;
 // pFile, nLine per block...
			dwSize += MAGIC_SIZE * 2;
									  //ll_lprintf( WIDE("Adding 8 bytes to block size...") );
		}
		if( !g.bDisableDebug )
		{
			dwPad += MAGIC_SIZE;
  // add a uint32_t at end to mark, and check for application overflow...
			dwSize += MAGIC_SIZE;
		}
		dwMin = dwPad;
#endif
		// re-search for memory should step long back...
	search_for_free_memory:
		for( pc = NULL, pMemSpace = FindSpace( pMem ); !pc && pMemSpace; pMemSpace = pMemSpace->next )
		{
			// grab the new memory (might be old, is ok)
			GrabMem( (PMEM)pMemSpace->pMem );
			// then drop old memory, don't need that anymore.
 // first time through, there is no current.
			if( pCurMem )
				DropMem( pCurMem );
			// then mark that this block is our current block.
			pCurMem = (PMEM)pMemSpace->pMem;
			//ll_lprintf( WIDE("region %p is now owned."), pCurMem );
			for( pc = pCurMem->pFirstFree; pc; pc = pc->next )
			{
 // if free block size is big enough...
				if( pc->dwSize >= dwSize )
				{
					// split block
 // must allocate it all.
					if( ( pc->dwSize - dwSize ) <= ( dwMin + CHUNK_SIZE + g.nMinAllocateSize ) )
					{
						pc->dwPad = (uint16_t)(dwPad + ( pc->dwSize - dwSize ));
						UnlinkThing( pc );
						pc->dwOwners = 1;
 // successful allocation....
						break;
					}
					else
					{
  // cleared, NEW, uninitialized block...
						PHEAP_CHUNK pNew;
						PHEAP_CHUNK next;
						next = (PHEAP_CHUNK)( pc->byData + pc->dwSize );
						pNew = (PHEAP_CHUNK)(pc->byData + dwSize);
						pNew->dwPad = 0;
						pNew->dwSize = ((pc->dwSize - CHUNK_SIZE) - dwSize);
#ifdef _DEBUG
						if( pNew->dwSize > 0x80000000 )
							DebugBreak();
						if( pMem && !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
						{
							pNew->dwPad += MAGIC_SIZE * 2;
						}
						if( !g.bDisableDebug )
						{
							pNew->dwPad += MAGIC_SIZE;
							BLOCK_TAG( pNew ) = BLOCK_TAG_ID;
						}
						if( pMem && !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
						{
							BLOCK_FILE( pNew ) = pFile;
							BLOCK_LINE( pNew ) = nLine;
						}
#endif
						pc->dwPad = (uint16_t)dwPad;
 // set old size?  this can wait until we have the block.
						pc->dwSize = dwSize;
						if( pc->dwSize & 0x80000000 )
							DebugBreak();
  // not beyond end of memory...
						if( (uintptr_t)next - (uintptr_t)pCurMem < (uintptr_t)pCurMem->dwSize )
							next->pPrior = pNew;
						pNew->dwOwners = 0;
						pNew->pRoot = pc->pRoot;
						pNew->pPrior = pc;
						// copy link...
						if( ( pNew->next = pc->next ) )
							pNew->next->me = &pNew->next;
						*( pNew->me = pc->me ) = pNew;
  // set owned block.
						pc->dwOwners = 1;
 // successful allocation....
						break;
					}
				}
			}
		}
		if( !pc )
		{
			if( dwSize < SYSTEM_CAPACITY )
			{
				if( ExpandSpace( pMem, SYSTEM_CAPACITY ) )
					goto search_for_free_memory;
			}
			else
			{
				// after 1 allocation, need a free chunk at end...
				// and let's just have a couple more to spaere.
				if( ExpandSpace( pMem, dwSize + (CHUNK_SIZE*4) + MEM_SIZE + 8 * MAGIC_SIZE ) )
				{
#ifndef NO_LOGGING
					//ll__lprintf(DBG_RELAY)( WIDE("Creating a new expanded space... %")_size_fs, dwSize + (CHUNK_SIZE*4) + MEM_SIZE + 8 * MAGIC_SIZE );
#endif
					goto search_for_free_memory;
				}
			}
			DropMem( pCurMem );
			pCurMem = NULL;
#ifdef _DEBUG
			if( !g.bDisableDebug )
				ODS( WIDE("Remaining space in memory block is insufficient.  Please EXPAND block."));
#endif
			DropMem( pMem );
			return NULL;
		}
 //|| !defined( __NO_WIN32API__ )
#if defined( _DEBUG )
		if( !g.bDisableDebug )
		{
			// set end of block tag(s).
			// without disabling memory entirely, blocks are
			// still tagged and trashed in debug mode.
			MemSet( pc->byData, CLEAR_MEMORY_TAG, pc->dwSize );
			BLOCK_TAG(pc) = BLOCK_TAG_ID;
		}
		if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
		{
			if( pc->dwPad < 16 )
				DebugBreak();
			BLOCK_FILE(pc) = pFile;
			BLOCK_LINE(pc) = nLine;
		}
#endif
		DropMem( pCurMem );
		DropMem( pMem );
		//#if DBG_AVAILABLE
#ifndef NO_LOGGING
#  ifdef _DEBUG
		if( g.bLogAllocate && g.allowLogging )
		{
			_xlprintf( 2 DBG_RELAY )(WIDE( "Allocate : %p(%p) - %" ) _PTRSZVALfs WIDE( " bytes" ), pc->byData, pc, pc->dwSize);
		}
#  endif
#endif
		//#endif
		if( alignment && ((uintptr_t)pc->byData & ~masks[alignment]) ) {
			uintptr_t retval = ((((uintptr_t)pc->byData) + (alignment - 1)) & masks[alignment]);
 /*pc->alignemnt =*/
			((uint16_t*)(retval - sizeof( uint32_t )))[0] = alignment;
 /*pc->to_chunk_start =*/
			((uint16_t*)(retval - sizeof( uint32_t )))[1] = (uint16_t)(((((uintptr_t)pc->byData) + (alignment - 1)) & masks[alignment]) - (uintptr_t)pc->byData);
			return (POINTER)retval;
		}
		else {
			pc->alignment = 0;
			pc->to_chunk_start = 0;
			return pc->byData;
		}
	}
	return NULL;
}
//------------------------------------------------------------------------------------------------------
POINTER HeapAllocateEx( PMEM pHeap, uintptr_t dwSize DBG_PASS ) {
	return HeapAllocateAlignedEx( pHeap, dwSize, 0 DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
#undef AllocateEx
POINTER  AllocateEx ( uintptr_t dwSize DBG_PASS )
{
	return HeapAllocateAlignedEx( g.pMemInstance, dwSize, 0 DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
POINTER  HeapReallocateAlignedEx ( PMEM pHeap, POINTER source, uintptr_t size, uint16_t alignment DBG_PASS )
{
	POINTER dest;
	uintptr_t minSize;
	dest = HeapAllocateAlignedEx( pHeap, size, alignment DBG_RELAY );
	if( source )
	{
		minSize = SizeOfMemBlock( source );
		if( size < minSize )
			minSize = size;
		MemCpy( dest, source, minSize );
		if( minSize < size )
			MemSet( ((uint8_t*)dest) + minSize, 0, size - minSize );
		ReleaseEx( source DBG_RELAY );
	}
	else
		MemSet( dest, 0, size );
	return dest;
}
//------------------------------------------------------------------------------------------------------
POINTER  HeapReallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS )
{
	return HeapReallocateAlignedEx( pHeap, source, size, 0 DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
POINTER  HeapPreallocateAlignedEx ( PMEM pHeap, POINTER source, uintptr_t size, uint16_t alignment DBG_PASS )
{
	POINTER dest;
	uintptr_t minSize;
	dest = HeapAllocateAlignedEx( pHeap, size, alignment DBG_RELAY );
	if( source )
	{
		minSize = SizeOfMemBlock( source );
		if( size < minSize )
			minSize = size;
		MemCpy( (uint8_t*)dest + (size-minSize), source, minSize );
		if( minSize < size )
			MemSet( dest, 0, size - minSize );
		ReleaseEx( source DBG_RELAY );
	}
	else
		MemSet( dest, 0, size );
	return dest;
}
POINTER  HeapPreallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS ){
	return HeapPreallocateAlignedEx( pHeap, source, size, AlignOfMemBlock(source) DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
 POINTER  HeapMoveEx( PMEM pNewHeap, POINTER source DBG_PASS )
{
	return HeapReallocateAlignedEx( pNewHeap, source, SizeOfMemBlock( source ), AlignOfMemBlock( source ) DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
 POINTER  ReallocateEx( POINTER source, uintptr_t size DBG_PASS )
{
	return HeapReallocateAlignedEx( g.pMemInstance, source, size, AlignOfMemBlock( source ) DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
 POINTER  PreallocateEx( POINTER source, uintptr_t size DBG_PASS )
{
	return HeapPreallocateAlignedEx( g.pMemInstance, source, size, AlignOfMemBlock( source ) DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
static void Bubble( PMEM pMem )
{
	// handle sorting free memory to be least signficant first...
	PCHUNK temp, next;
	PCHUNK *prior;
	prior = &pMem->pFirstFree;
	temp = *prior;
	if( !temp )
		return;
	next = temp->next;
	while( temp && next )
	{
		if( (uintptr_t)next < (uintptr_t)temp )
		{
			UnlinkThing( temp );
			UnlinkThing( next );
			LinkThing( *prior, next );
			LinkThing( next->next, temp );
			prior = &next->next;
			temp = *prior;
			next = temp->next;
		}
		else
		{
			prior = &temp->next;
			temp = *prior;
#ifdef _DEBUG
			if( temp->next == temp )
			{
				ll_lprintf( WIDE("OOps this block is way bad... how'd that happen? %s(%d)"), BLOCK_FILE( temp ), BLOCK_LINE( temp ) );
				DebugBreak();
			}
#endif
			next = temp->next;
		}
	}
}
//------------------------------------------------------------------------------------------------------
 uintptr_t  SizeOfMemBlock ( CPOINTER pData )
{
	if( pData )
	{
		if( USE_CUSTOM_ALLOCER )
		{
			PCHUNK pc = (PCHUNK)(((uintptr_t)pData) - (((uint16_t*)pData)[-1] + offsetof( CHUNK, byData )));
			return pc->dwSize - pc->dwPad;
		}
		else
		{
			PMALLOC_CHUNK pc = (PMALLOC_CHUNK)(((uintptr_t)pData) - MALLOC_CHUNK_SIZE(pData));
			return pc->dwSize - pc->dwPad;
		}
	}
	return 0;
}
//------------------------------------------------------------------------------------------------------
uint16_t  AlignOfMemBlock( CPOINTER pData )
{
	if( pData )
	{
		return (((uint16_t*)pData)[-2]);
	}
	return 0;
 }
//------------------------------------------------------------------------------------------------------
 POINTER  MemDupEx ( CPOINTER thing DBG_PASS )
{
	uintptr_t size = SizeOfMemBlock( thing );
	POINTER result;
	result = HeapAllocateAlignedEx( g.pMemInstance, size, AlignOfMemBlock( thing ) DBG_RELAY );
	MemCpy( result, thing, size );
	return result;
}
#undef MemDup
 POINTER  MemDup (CPOINTER thing )
{
	return MemDupEx( thing DBG_SRC );
}
//------------------------------------------------------------------------------------------------------
POINTER ReleaseEx ( POINTER pData DBG_PASS )
{
	if( pData )
	{
		// how to figure if it's a CHUNK or a HEAP_CHUNK?
		if( !( ((uintptr_t)pData) & 0x3FF ) )
		{
			// system allocated blocks ( OpenSpace ) will be tracked as spaces...
			// and they will be aligned on large memory blocks (4096 probably)
			PSPACE ps = FindSpace( pData );
			if( ps )
			{
				DoCloseSpace( ps, TRUE );
				return NULL;
			}
		}
		if( !USE_CUSTOM_ALLOCER )
		{
			//PMEM pMem = (PMEM)(pData - offsetof( MEM, pRoot ));
			PMALLOC_CHUNK pc = (PMALLOC_CHUNK)(((uintptr_t)pData) - MALLOC_CHUNK_SIZE(pData) );
			pc->dwOwners--;
			if( !pc->dwOwners )
			{
				extern int  MemChk ( POINTER p, uintptr_t val, size_t sz );
#ifndef NO_LOGGING
#  ifdef _DEBUG
				if( g.bLogAllocate )
				{
					ll__lprintf(DBG_RELAY)( WIDE( "Release %p(%p)" ), pc, pc->byData );
				}
#  endif
#endif
#ifdef ENABLE_NATIVE_MALLOC_PROTECTOR
				if( !MemChk( pc->LeadProtect, LEAD_PROTECT_TAG, sizeof( pc->LeadProtect ) ) ||
					!MemChk( pc->byData + pc->dwSize, LEAD_PROTECT_BLOCK_TAIL, sizeof( pc->LeadProtect ) ) )
				{
					ll_lprintf( WIDE( "overflow block (%p) %p" ), pData, pc );
					DebugBreak();
				}
#endif
				free( pc );
				return NULL;
			}
			else
			{
#ifndef NO_LOGGING
				if( g.bLogAllocate && g.bLogAllocateWithHold )
				{
					ll__lprintf(DBG_RELAY)( WIDE( "Release(holding) %p(%p)" ), pc, pc->byData );
				}
#endif
			}
			return pData;
		}
		else
		{
			PCHUNK pc = (PCHUNK)(((uintptr_t)pData) - ( ( (uint16_t*)pData)[-1] +
													offsetof( CHUNK, byData ) ) );
			PMEM pMem, pCurMem;
			PSPACE pMemSpace;
			// Allow a simple release() to close a shared memory file mapping
			// this is a slight performance hit for all deallocations
#ifdef _DEBUG
			if( !g.bDisableAutoCheck )
				GetHeapMemStatsEx(pc->pRoot, &dwFree,&dwAllocated,&dwBlocks,&dwFreeBlocks DBG_RELAY);
#endif
#ifndef NO_LOGGING
#  ifdef _DEBUG
			if( g.bLogAllocate )
			{
				if( !g.bDisableDebug )
					_xlprintf( 2 DBG_RELAY )(WIDE( "Release  : %p(%p) - %" ) _PTRSZVALfs WIDE( " bytes %s(%d)" ), pc->byData, pc, pc->dwSize, BLOCK_FILE( pc ), BLOCK_LINE( pc ));
				else
					_xlprintf( 2 DBG_RELAY )(WIDE( "Release  : %p(%p) - %" ) _PTRSZVALfs WIDE( " bytes" ), pc->byData, pc, pc->dwSize);
			}
#  endif
#endif
			pMem = GrabMem( pc->pRoot );
			if( !pMem )
			{
#ifndef NO_LOGGING
				ll__lprintf( DBG_RELAY )( WIDE("ERROR: Chunk to free does not reference a heap!") );
#endif
				DebugDumpHeapMemEx( pc->pRoot, 1 );
				DebugBreak();
			}
			pMemSpace = FindSpace( pMem );
			while( pMemSpace && ( ( pCurMem = (PMEM)pMemSpace->pMem ),
										(	( (uintptr_t)pData < (uintptr_t)pCurMem )
										||  ( (uintptr_t)pData > ( (uintptr_t)pCurMem + pCurMem->dwSize ) ) )
									 )
				 )
			{
				Log( WIDE("ERROR: This block should have immediatly referenced it's correct heap!") );
				pMemSpace = pMemSpace->next;
			}
			if( !pMemSpace )
			{
#ifndef NO_LOGGING
#  ifdef _DEBUG
				ll__lprintf( DBG_RELAY )( WIDE("This Block is NOT within the managed heap! : %p" ), pData );
#  endif
#endif
				ll_lprintf( WIDE("this may not be an error.  This could be an old block from not using customallocer...") );
				DebugDumpHeapMemEx( pc->pRoot, 1 );
				DebugBreak();
				DropMem( pMem );
				return NULL;
			}
			pCurMem = (PMEM)pMemSpace->pMem;
			if( pData && pc )
			{
				if( !pc->dwOwners )
				{
#ifndef NO_LOGGING
#  ifdef _DEBUG
					if( !g.bDisableDebug &&
						!(pCurMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
						_xlprintf( 2
									, BLOCK_FILE(pc)
									, BLOCK_LINE(pc)
									)( WIDE("Block is already Free! %p ")
									, pc );
					else
#  endif
						// CRITICAL ERROR!
						_xlprintf( 2 DBG_RELAY)( WIDE("Block is already Free! %p "), pc );
#endif
					DropMem( pMem );
					return pData;
				}
#ifdef _DEBUG
				if( !g.bDisableDebug )
					if( BLOCK_TAG( pc ) != BLOCK_TAG_ID )
					{
						ll_lprintf( WIDE("Application overflowed memory:%p"), pc->byData );
						DebugDumpHeapMemEx( pc->pRoot, 1 );
						DebugBreak();
					}
#endif
				pc->dwOwners--;
				if( pc->dwOwners )
				{
#ifdef _DEBUG
					if( !(pCurMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
					{
						// store where it was released from
						BLOCK_FILE(pc) = pFile;
						BLOCK_LINE(pc) = nLine;
					}
#endif
					DropMem( pMem );
					return pData;
				}
				else
				{
					LOGICAL bCollapsed = FALSE;
					PCHUNK next, nextNext, pPrior;
					uintptr_t nNext;
					// fill memory with a known value...
					// this will allow me to check usage after release....
#ifdef _DEBUG
					if( !(pCurMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
					{
						// store where it was released from
						BLOCK_FILE(pc) = pFile;
						BLOCK_LINE(pc) = nLine;
					}
					if( !g.bDisableDebug )
					{
						BLOCK_TAG(pc)=BLOCK_TAG_ID;
						MemSet( pc->byData, FREE_MEMORY_TAG, pc->dwSize - pc->dwPad );
					}
#endif
					next = (PCHUNK)(pc->byData + pc->dwSize);
					if( (nNext = (uintptr_t)next - (uintptr_t)pCurMem) >= pCurMem->dwSize )
					{
						// if next is NOT within valid memory...
						next = NULL;
					}
 // is not root chunk...
					if( ( pPrior = pc->pPrior ) )
					{
 // prior physical is free
						if( !pPrior->dwOwners )
						{
 // add this header plus size
							pPrior->dwSize += CHUNK_SIZE + pc->dwSize;
#ifdef _DEBUG
							//if( bLogAllocate )
							{
								//ll_lprintf( WIDE("Collapsing freed block with prior block...%p %p"), pc, pPrior );
							}
							if( !g.bDisableDebug )
							{
								pPrior->dwPad = MAGIC_SIZE;
								if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
								{
									pPrior->dwPad += 2 * MAGIC_SIZE;
									BLOCK_FILE( pPrior ) = pFile;
									BLOCK_LINE( pPrior ) = nLine;
								}
								BLOCK_TAG( pPrior ) = BLOCK_TAG_ID;
								MemSet( pPrior->byData, FREE_MEMORY_TAG, pPrior->dwSize - pPrior->dwPad );
							}
							else
#endif
							{
 // *** NEEDFILELINE ***
								pPrior->dwPad = 0;
#ifdef _DEBUG
								if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
								{
									pPrior->dwPad += 2 * MAGIC_SIZE;
									BLOCK_FILE( pPrior ) = pFile;
									BLOCK_LINE( pPrior ) = nLine;
								}
#endif
							}
							if( pPrior->dwSize & 0x80000000 )
								DebugBreak();
 // use prior block as base ....
							pc = pPrior;
							if( next )
								next->pPrior = pPrior;
							bCollapsed = TRUE;
						}
					}
					// begin checking NEXT physical memory block for conglomerating
					if( next )
					{
						if( !next->dwOwners )
						{
							pc->dwSize += CHUNK_SIZE + next->dwSize;
							if( bCollapsed )
							{
								// pc is already in free list...
								UnlinkThing( next );
							}
							else
							{
								// otherwise need to use next's link spot
								// for this pc...
								if( (pc->next = next->next) )
									pc->next->me = &pc->next;
								*( pc->me = next->me ) = pc;
								bCollapsed = TRUE;
							}
#ifdef _DEBUG
							//if( bLogAllocate )
								//ll_lprintf( WIDE("Collapsing freed block with next block...%p %p"), pc, next );
							if( !g.bDisableDebug )
							{
								pc->dwPad = MAGIC_SIZE;
								if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
								{
									pc->dwPad += 2 * MAGIC_SIZE;
									BLOCK_FILE( pc ) = pFile;
									BLOCK_LINE( pc ) = nLine;
								}
								BLOCK_TAG( pc ) = BLOCK_TAG_ID;
								MemSet( pc->byData, FREE_MEMORY_TAG, pc->dwSize - pc->dwPad );
							}
							else
#endif
							{
 // *** NEEDFILELINE ***
								pc->dwPad = 0;
#ifdef _DEBUG
								if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
								{
									pc->dwPad += 2 * MAGIC_SIZE;
									BLOCK_FILE( pc ) = pFile;
									BLOCK_LINE( pc ) = nLine;
								}
#endif
							}
							if( pc->dwSize & 0x80000000 )
								DebugBreak();
							nextNext = (PCHUNK)(pc->byData + pc->dwSize );
							if( (((uintptr_t)nextNext) - ((uintptr_t)pCurMem)) < (uintptr_t)pCurMem->dwSize )
							{
								nextNext->pPrior = pc;
							}
						}
					}
 // no block near this one was free...
					if( !bCollapsed )
					{
						LinkThing( pc->pRoot->pFirstFree, pc );
					}
				}
			}
			Bubble( pMem );
			DropMem( pMem );
#ifdef _DEBUG
			if( !g.bDisableAutoCheck )
				GetHeapMemStatsEx(pMem, &dwFree,&dwAllocated,&dwBlocks,&dwFreeBlocks DBG_RELAY);
#endif
		}
	}
	return NULL;
}
		//------------------------------------------------------------------------------------------------------
 POINTER  HoldEx ( POINTER pData DBG_PASS )
{
	if( pData )
	{
		if( !USE_CUSTOM_ALLOCER )
		{
			PMALLOC_CHUNK pc = (PMALLOC_CHUNK)((uintptr_t)pData - MALLOC_CHUNK_SIZE(pData));
			//ll__lprintf( DBG_RELAY )( "holding block %p", pc );
#ifndef NO_LOGGING
			if( g.bLogAllocate && g.bLogAllocateWithHold )
				_xlprintf( 2 DBG_RELAY)( WIDE("Hold	 : %p - %") _PTRSZVALfs WIDE(" bytes"),pc, pc->dwSize );
#endif
			pc->dwOwners++;
		}
		else
		{
			PCHUNK pc = (PCHUNK)((char*)pData - CHUNK_SIZE);
			PMEM pMem = GrabMem( pc->pRoot );
#ifndef NO_LOGGING
			if( g.bLogAllocate )
			{
				_xlprintf( 2 DBG_RELAY)( WIDE("Hold	 : %p - %") _PTRSZVALfs WIDE(" bytes"),pc, pc->dwSize );
			}
#endif
			if( !pc->dwOwners )
			{
				ll_lprintf( WIDE("Held block has already been released!  too late to hold it!") );
				DebugBreak();
				DropMem( pMem );
				return pData;
			}
			pc->dwOwners++;
			DropMem(pMem );
#ifdef _DEBUG
			if( !g.bDisableAutoCheck )
				GetHeapMemStatsEx(pc->pRoot, &dwFree,&dwAllocated,&dwBlocks,&dwFreeBlocks DBG_RELAY);
#endif
		}
	}
	return pData;
}
//------------------------------------------------------------------------------------------------------
 POINTER  GetFirstUsedBlock ( PMEM pHeap )
{
	return pHeap->pRoot[0].byData;
}
//------------------------------------------------------------------------------------------------------
void  DebugDumpHeapMemEx ( PMEM pHeap, LOGICAL bVerbose )
{
	if( USE_CUSTOM_ALLOCER )
	{
		PCHUNK pc, _pc;
		uintptr_t nTotalFree = 0;
		uintptr_t nChunks = 0;
		uintptr_t nTotalUsed = 0;
		PSPACE pMemSpace;
		PMEM pMem = GrabMem( pHeap ), pCurMem;
		pc = pMem->pRoot;
		ll_lprintf(WIDE(" ------ Memory Dump ------- ") );
		{
			xlprintf(LOG_ALWAYS)( WIDE("FirstFree : %p"),
										pMem->pFirstFree );
		}
		for( pc = NULL, pMemSpace = FindSpace( pMem ); pMemSpace; pMemSpace = pMemSpace->next )
		{
			pCurMem = (PMEM)pMemSpace->pMem;
 // current pChunk(pc)
			pc = pCurMem->pRoot;
 // while PC not off end of memory
			while( (((uintptr_t)pc) - ((uintptr_t)pCurMem)) < (uintptr_t)pCurMem->dwSize )
			{
#ifndef __LINUX__
 // allow debug log to work... (OutputDebugString() Win32, also network streams may require)
				Relinquish();
#endif
				nChunks++;
				if( !pc->dwOwners )
				{
					nTotalFree += pc->dwSize;
#ifndef NO_LOGGING
					if( bVerbose )
					{
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
						CTEXTSTR pFile =  !IsBadReadPtr( BLOCK_FILE(pc), 1 )
							?BLOCK_FILE(pc)
							:WIDE("Unknown");
						uint32_t nLine = BLOCK_LINE(pc);
#endif
						_xlprintf(LOG_ALWAYS DBG_RELAY)( WIDE("Free at %p size: %") _PTRSZVALfs WIDE("(%") _PTRSZVALfx WIDE(") Prior:%p NF:%p"),
																 pc, pc->dwSize, pc->dwSize,
																 pc->pPrior,
																 pc->next );
					}
#endif
				}
				else
				{
					nTotalUsed += pc->dwSize;
#ifndef NO_LOGGING
					if( bVerbose )
					{
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
						CTEXTSTR pFile =  !IsBadReadPtr( BLOCK_FILE(pc), 1 )
							?BLOCK_FILE(pc)
							:WIDE("Unknown");
						uint32_t nLine = BLOCK_LINE(pc);
#endif
						_xlprintf(LOG_ALWAYS DBG_RELAY)( WIDE("Used at %p size: %") _PTRSZVALfs WIDE("(%") _PTRSZVALfx WIDE(") Prior:%p"),
																 pc, pc->dwSize, pc->dwSize,
																 pc->pPrior );
					}
#endif
				}
				_pc = pc;
				pc = (PCHUNK)(pc->byData + pc->dwSize );
				if( pc == _pc )
				{
					ll_lprintf( WIDE("Next block is the current block...") );
 // broken memory chain
					DebugBreak();
					break;
				}
			}
		}
		xlprintf(LOG_ALWAYS)( WIDE("Total Free: %")_PTRSZVALfs WIDE("  TotalUsed: %")_PTRSZVALfs WIDE("  TotalChunks: %")_PTRSZVALfs WIDE(" TotalMemory:%") _PTRSZVALfs,
									nTotalFree, nTotalUsed, nChunks,
									(nTotalFree + nTotalUsed + nChunks * CHUNK_SIZE) );
		DropMem( pMem );
	}
	else
		xlprintf(LOG_ALWAYS)( WIDE( "Cannot log chunks allocated that are not using custom allocer." ) );
}
	//------------------------------------------------------------------------------------------------------
 void  DebugDumpMemEx ( LOGICAL bVerbose )
{
	DebugDumpHeapMemEx( g.pMemInstance, bVerbose );
}
//------------------------------------------------------------------------------------------------------
 void  DebugDumpHeapMemFile ( PMEM pHeap, CTEXTSTR pFilename )
{
	FILE *file;
	if( !USE_CUSTOM_ALLOCER )
		return;
	Fopen( file, pFilename, WIDE("wt") );
	if( file )
	{
		PCHUNK pc, _pc;
		PMEM pMem, pCurMem;
		PSPACE pMemSpace;
		size_t nTotalFree = 0;
		size_t nChunks = 0;
		size_t nTotalUsed = 0;
		char byDebug[256];
		pMem = GrabMem( pHeap );
		fprintf( file, " ------ Memory Dump ------- \n" );
		{
			char  byDebug[256];
			snprintf( byDebug, sizeof( byDebug ), "FirstFree : %p",
						pMem->pFirstFree );
			byDebug[255] = 0;
			fprintf( file, "%s\n", byDebug );
		}
		for( pc = NULL, pMemSpace = FindSpace( pMem ); pMemSpace; pMemSpace = pMemSpace->next )
		{
			pCurMem = (PMEM)pMemSpace->pMem;
 // current pChunk(pc)
			pc = pCurMem->pRoot;
 // while PC not off end of memory
			while( (((uintptr_t)pc) - ((uintptr_t)pCurMem)) < (uintptr_t)pCurMem->dwSize )
			{
				//Relinquish(); // allow debug log to work...
				nChunks++;
				if( !pc->dwOwners )
				{
					nTotalFree += pc->dwSize;
					snprintf( byDebug, sizeof(byDebug), "Free at %p size: %" cPTRSZVALfs "(%" cPTRSZVALfx ") Prior:%p NF:%p",
						pc, pc->dwSize, pc->dwSize,
						pc->pPrior,
						pc->next );
					byDebug[255] = 0;
				}
				else
				{
					nTotalUsed += pc->dwSize;
					snprintf( byDebug, sizeof(byDebug), "Used at %p size: %" cPTRSZVALfs "(%" cPTRSZVALfx ") Prior:%p",
						pc, pc->dwSize, pc->dwSize,
						pc->pPrior );
					byDebug[255] = 0;
				}
#ifdef _DEBUG
				if( !g.bDisableDebug && !(pCurMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
				{
					CTEXTSTR pFile =  !IsBadReadPtr( BLOCK_FILE(pc), 1 )
							?BLOCK_FILE(pc)
							:WIDE("Unknown");
					fprintf( file, "%s(%d):%s\n", pFile, BLOCK_LINE(pc), byDebug );
				}
				else
#endif
					fprintf( file, "%s\n", byDebug );
				_pc = pc;
				pc = (PCHUNK)(pc->byData + pc->dwSize );
				if( pc == _pc )
				{
 // broken memory chain
					DebugBreak();
					break;
				}
			}
		}
		fprintf( file, "--------------- FREE MEMORY LIST --------------------\n" );
		for( pc = NULL, pMemSpace = FindSpace( pMem ); pMemSpace; pMemSpace = pMemSpace->next )
		{
			pCurMem = (PMEM)pMemSpace->pMem;
 // current pChunk(pc)
			pc = pCurMem->pFirstFree;
 // while PC not off end of memory
			while( pc )
			{
				snprintf( byDebug, sizeof(byDebug), "Free at %p size: %" c_size_fs "(%" c_size_fx ") ",
							pc, pc->dwSize, pc->dwSize );
				byDebug[255] = 0;
	#ifdef _DEBUG
 /*!g.bDisableDebug && */
				if( !(pCurMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
				{
					const char * pFile =  !IsBadReadPtr( BLOCK_FILE(pc), 1 )
							?CStrDup(BLOCK_FILE(pc))
							:"Unknown";
					fprintf( file, "%s(%d):%s\n", pFile, BLOCK_LINE(pc), byDebug );
				}
				else
	#endif
					fprintf( file, "%s\n", byDebug );
				pc = pc->next;
			}
		}
		snprintf( byDebug, sizeof(byDebug), "Total Free: %" c_size_f "  TotalUsed: %" c_size_f "  TotalChunks: %" c_size_f " TotalMemory:%" c_size_f
					, nTotalFree, nTotalUsed, nChunks
					, (nTotalFree + nTotalUsed + nChunks * CHUNK_SIZE) );
		byDebug[255] = 0;
		fprintf( file, "%s\n", byDebug );
		//Relinquish();
		DropMem( pMem );
		 fclose( file );
	}
}
//------------------------------------------------------------------------------------------------------
 void  DebugDumpMemFile ( CTEXTSTR pFilename )
{
	DebugDumpHeapMemFile( g.pMemInstance, pFilename );
}
//------------------------------------------------------------------------------------------------------
 // returns true/false, updates pointer
 LOGICAL  Defragment ( POINTER *ppMemory )
{
	// this is broken... needs
	// to fixup BLOCK_TAG, BLOCK_FILE, etc...
#if 1
	return FALSE;
#else
	// pass an array of allocated memory... for all memory blocks in list,
	// check to see if they can be reallocated lower, and or just moved to
	// a memory space lower than they are now.
	PCHUNK pc, pPrior;
	PMEM pMem;
	if( !ppMemory || !*ppMemory)
		return FALSE;
	pc = (PCHUNK)(((uintptr_t)(*ppMemory)) - (((uint16_t*)pData)[-1] + offsetof( CHUNK, byData )));
	pMem = GrabMem( pc->pRoot );
		// check if prior block is free... if so - then...
		// move this data down, and reallocate the freeness at the end
		// this reallocation may move the free next to another free, which
		// should be collapsed into this one...
	pPrior = pc->pPrior;
 // not HELD by others... no way to update their pointers
	if( ( pc->dwOwners == 1 ) &&
		pPrior &&
		!pPrior->dwOwners )
	{
		CHUNK Free = *pPrior;
		CHUNK Allocated, *pNew;
 // save this chunk...
		Allocated = *pc;
		MemCpy( pPrior->byData, pc->byData, Allocated.dwSize );
		pNew = (PCHUNK)(pPrior->byData + Allocated.dwSize);
		pNew->dwSize = Free.dwSize;
		pNew->dwOwners = 0;
 // now pAllocated...
		pNew->pPrior = pPrior;
		pNew->pRoot = Free.pRoot;
		if( ( pNew->next = Free.next ) )
			pNew->next->me = &pNew->next;
		if( ( pNew->me = Free.me ) )
			(*pNew->me) = pNew;
#ifdef _DEBUG
		if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
		{
			BLOCK_FILE(pNew) = BLOCK_FILE(&Free);
			BLOCK_LINE(pNew) = BLOCK_LINE(&Free);
		}
#endif
		pPrior->dwSize = Allocated.dwSize;
		pPrior->dwOwners = 1;
		pPrior->next = NULL;
		pPrior->me = NULL;
		// update NEXT NEXT real block...
		{
			PCHUNK next;
			next = (PCHUNK)( pNew->byData + pNew->dwSize );
			if( (((uintptr_t)next) - ((uintptr_t)pMem)) < (uintptr_t)pMem->dwSize )
			{
 // if next is free.....
				if( !next->dwOwners )
				{
					// consolidate...
					if( (pNew->next = next->next) )
						pNew->next->me = &pNew->next;
					*( pNew->me = next->me ) = pNew;
					pNew->dwSize += next->dwSize + CHUNK_SIZE;
					next = (PCHUNK)( pNew->byData + pNew->dwSize );
					if( (uint32_t)(((char *)next) - ((char *)pMem)) < pMem->dwSize )
					{
						next->pPrior = pNew;
					}
				}
				else
					next->pPrior = pNew;
			}
		}
		*ppMemory = pPrior->byData;
		DropMem( pMem );
		GetHeapMemStats( g.pMemInstance, NULL, NULL, NULL, NULL );
		return TRUE;
	}
	DropMem( pMem );
	return FALSE;
#endif
}
//------------------------------------------------------------------------------------------------------
 void  GetHeapMemStatsEx ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks DBG_PASS )
{
	int nChunks = 0, nFreeChunks = 0, nSpaces = 0;
	uintptr_t nFree = 0, nUsed = 0;
	PCHUNK pc, _pc;
	PMEM pMem;
	PSPACE pMemSpace;
	if( !USE_CUSTOM_ALLOCER )
      return;
	if( !pHeap )
		pHeap = g.pMemInstance;
	pMem = GrabMem( pHeap );
	pMemSpace = FindSpace( pMem );
	while( pMemSpace )
	{
		PMEM pMemCheck = ((PMEM)pMemSpace->pMem);
		pc = pMemCheck->pRoot;
		GrabMem( pMemCheck );
 // while PC not off end of memory
		while( (((uintptr_t)pc) - ((uintptr_t)pMemCheck)) < (uintptr_t)pMemCheck->dwSize )
		{
			nChunks++;
			if( !pc->dwOwners )
			{
				nFree += pc->dwSize;
				nFreeChunks++;
			}
			else
			{
				nUsed += pc->dwSize;
#ifdef _DEBUG
				if( !g.bDisableDebug )
				{
					if( pc->dwSize > pMemCheck->dwSize )
					{
						ll_lprintf( WIDE("Memory block %p has a corrupt size."), pc->byData );
						DebugBreak();
					}
					else
					{
						int minPad = MAGIC_SIZE;
						if( pMem && !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
							minPad += MAGIC_SIZE * 2;
						if( pc->dwPad >= minPad && BLOCK_TAG(pc) != BLOCK_TAG_ID )
						{
#ifndef NO_LOGGING
							ll_lprintf( WIDE("memory block: %p %08") TAG_FORMAT_MODIFIER WIDE("x insted of %08")TAG_FORMAT_MODIFIER WIDE("x"), pc->byData, BLOCK_TAG(pc), BLOCK_TAG_ID );
							if( !(pMemCheck->dwFlags & HEAP_FLAG_NO_DEBUG ) )
							{
								CTEXTSTR file = BLOCK_FILE(pc);
#  ifdef _WIN32
								if( IsBadReadPtr( file, 4 ) )
									file = WIDE("(corrupt)");
#  endif
								_xlprintf( 2, file, BLOCK_LINE(pc) )( WIDE("Application overflowed allocated memory.") );
							}
							else
								ODS( WIDE("Application overflowed allocated memory.") );
#endif
							DebugDumpHeapMemEx( pHeap, 1 );
							DebugBreak();
						}
					}
				}
#endif
			}
			_pc = pc;
			pc = (PCHUNK)(pc->byData + pc->dwSize );
			if( (((uintptr_t)pc) - ((uintptr_t)pMemCheck)) < (uintptr_t)pMemCheck->dwSize  )
			{
				if( pc == _pc )
				{
					Log( WIDE("Current block is the same as the last block we checked!") );
					DebugDumpHeapMemEx( pHeap, 1 );
 // broken memory chain
					DebugBreak();
					break;
				}
				if( pc->pPrior != _pc )
				{
					ll_lprintf( WIDE("Block's prior is not the last block we checked! prior %p sz: %") _PTRSZVALfs WIDE(" current: %p currentprior: %p")
						, _pc
						, _pc->dwSize
						, pc
						, pc->pPrior );
					DebugDumpHeapMemEx( pHeap, 1 );
					DebugBreak();
					break;
				}
			}
		}
		_pc = NULL;
		pc = pMemCheck->pFirstFree;
		while( pc )
		{
			if( pc->dwOwners )
  // owned block is in free memory chain ! ?
			{
				ll_lprintf( WIDE("Owned block %p is in free memory chain!"), pc );
				DebugBreak();
				break;
			}
			_pc = pc;
			pc = pc->next;
		}
		nSpaces++;
		pMemSpace = pMemSpace->next;
		DropMem( pMemCheck );
	}
	DropMem( pMem );
	if( pFree )
		*pFree = (uint32_t)nFree;
	if( pUsed )
		*pUsed = (uint32_t)nUsed;
	if( pChunks )
		*pChunks = nChunks;
	if( pFreeChunks )
		*pFreeChunks = nFreeChunks;
}
//------------------------------------------------------------------------------------------------------
 void  GetMemStats ( uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks )
{
	GetHeapMemStats( g.pMemInstance, pFree, pUsed, pChunks, pFreeChunks );
}
//------------------------------------------------------------------------------------------------------
 int  SetAllocateLogging ( LOGICAL bTrueFalse )
{
	LOGICAL prior = g.bLogAllocate;
	g.bLogAllocate = bTrueFalse;
	return prior;
}
//------------------------------------------------------------------------------------------------------
 int  SetCriticalLogging ( LOGICAL bTrueFalse )
{
#ifdef _DEBUG
	int prior = g.bLogCritical;
	g.bLogCritical = bTrueFalse;
	return prior;
#else
	return 0;
#endif
}
//------------------------------------------------------------------------------------------------------
 int  SetAllocateDebug ( LOGICAL bDisable )
{
#ifdef _DEBUG
	int save = g.bDisableDebug;
	g.bDisableDebug = !bDisable;
	g.bDisableAutoCheck = !bDisable;
	return save;
#else
	return 1;
#endif
}
 int  SetManualAllocateCheck ( LOGICAL bDisable )
{
#ifdef _DEBUG
	int save = g.bDisableAutoCheck;
	g.bDisableAutoCheck = bDisable;
	return save;
#else
	return 1;
#endif
}
//------------------------------------------------------------------------------------------------------
 void  SetMinAllocate ( size_t nSize )
{
	g.nMinAllocateSize = nSize;
}
//------------------------------------------------------------------------------------------------------
 void  SetHeapUnit ( size_t dwSize )
{
	g.dwSystemCapacity = dwSize;
}
//------------------------------------------------------------------------------------------------------
#undef GetHeapMemStats
 void  GetHeapMemStats ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks )
{
	GetHeapMemStatsEx( pHeap, pFree, pUsed, pChunks, pFreeChunks DBG_SRC );
}
#if 0
#  ifdef _MSC_VER
//>= 900
_CRT_ALLOC_HOOK prior_hook;
int allocHook(int allocType, void *userData, size_t size, int
blockType, long requestNumber, const unsigned char *filename, int
lineNumber)
{
	static int logging;
	if( logging )
		return TRUE;
	logging = 1;
	switch( allocType )
	{
	case _HOOK_ALLOC:
		ll_lprintf( WIDE( "CRT Alloc: %d bytes %s(%d)" )
			, size
			, filename, lineNumber
			);
		break;
	case _HOOK_REALLOC:
		ll_lprintf( WIDE( "CRT Realloc: %d bytes %s(%d)" )
			, size
			, filename, lineNumber
			);
		break;
	case _HOOK_FREE:
		ll_lprintf( WIDE( "CRT Free: %p[%"_PTRSZVALfs"](%d) %s(%d)" )
			, userData
			, (uintptr_t)userData
			, size
			, filename, lineNumber
			);
		break;
	default:
		DebugBreak();
	}
	logging = 0;
	if( prior_hook )
		return prior_hook( allocType, userData, size, blockType, requestNumber, filename, lineNumber );
	return TRUE;
}
//int handle_program_memory_depletion( size_t )
//{
   // Your code
//}
PRELOAD( ShareMemToVSAllocHook )
{
	//_CRT_ALLOC_HOOK allocHook;
	//allocHook = 0 ;
	/* this is about useless... the free doesn't report the correct address
	* the allocate doesn't report the block
	* the free doesn't reprot the size
	* there is no way to relate what is freed with what is allocated
	*/
	//prior_hook = _CrtSetAllocHook(	allocHook );
	//_set_new_handler( pn );
}
#  endif
#endif
#ifdef __cplusplus
//namespace sack {
};
//	namespace memory {
};
#endif
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   created to provide standard memory allocation features.
 *   Release( Allocate(size) )
 *   Hold( pointer ); // must release a second time.
 *   if DEBUG, memory bounds checking enabled and enableable.
 *   if RELEASE standard memory includes no excessive operations
 *
 *  standardized to never use int. (was a clean port, however,
 *  inaccurate, knowing the conversions on calculations of pointers
 *  are handled by cast to int! )
 *
 * see also - include/sharemem.h
 *
 */
SACK_MEMORY_NAMESPACE
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#if defined( __GNUC__ )
#  pragma GCC push_options
#  pragma GCC optimize ("O0")
#endif
void  MemSet ( POINTER p, uintptr_t n, size_t sz )
{
#if defined( _MSC_VER ) && !defined( __NO_WIN32API__ ) && !defined( UNDER_CE )
#  if defined( _WIN64 )
	//__asm cld;
	__stosq( (uint64_t*)p, n, sz/8 );
	if( sz & 4 )
		(*(uint32_t*)( ((uintptr_t)p) + sz - (sz&7) ) ) = (uint32_t)n;
	if( sz & 2 )
		(*(uint16_t*)( ((uintptr_t)p) + sz - (sz&3) ) ) = (uint16_t)n;
	if( sz & 1 )
		(*(uint8_t*)( ((uintptr_t)p) + sz - (sz&1) ) ) = (uint8_t)n;
#  else
#    ifdef __64__
	__stosq( (uint64_t*)p, n, sz / 4 );
	if( sz & 4 )
		(*(uint32_t*)( ((uintptr_t)p) + sz - (sz&7) ) ) = (uint32_t)n;
	if( sz & 2 )
		(*(uint16_t*)( ((uintptr_t)p) + sz - (sz&3) ) ) = (uint16_t)n;
	if( sz & 1 )
		(*(uint8_t*)( ((uintptr_t)p) + sz - (sz&1) ) ) = (uint8_t)n;
#    else
	__stosd( (DWORD*)p, n, sz / 4 );
	if( sz & 2 )
		(*(uint16_t*)( ((uintptr_t)p) + sz - (sz&3) ) ) = (uint16_t)n;
	if( sz & 1 )
		(*(uint8_t*)( ((uintptr_t)p) + sz - (sz&1) ) ) = (uint8_t)n;
#    endif
#  endif
#elif defined( __GNUC__ )
	{
      uintptr_t tmp = (uintptr_t)p;
#  ifdef __64__
		{
			int m; int len = sz/8;
			for( m = 0; m < len; m++ ) {
				((uint64_t*)tmp)[0] = n;
				tmp += 8;
			}
		}
		if( sz & 4 )
			(*(uint32_t*)( ((uintptr_t)p) + sz - (sz&7) ) ) = (uint32_t)n;
		if( sz & 2 )
			(*(uint16_t*)( ((uintptr_t)p) + sz - (sz&3) ) ) = (uint16_t)n;
		if( sz & 1 )
			(*(uint8_t*)( ((uintptr_t)p) + sz - 1 ) ) = (uint8_t)n;
#  else
		{
			int m; int len = sz/4;
			for( m = 0; m < len; m++ ) {
				((uint32_t*)tmp)[0] = n;
				tmp += 4;
			}
		}
		if( sz & 2 )
			(*(uint16_t*)( ((uintptr_t)p) + sz - (sz&3) ) ) = (uint16_t)n;
		if( sz & 1 )
			(*(uint8_t*)( ((uintptr_t)p) + sz - 1 ) ) = (uint8_t)n;
#  endif
	}
#else
   memset( p, n, sz );
#endif
}
#if defined( __GNUC__ )
#  pragma GCC pop_options
#endif
int  MemChk ( POINTER p, uintptr_t val, size_t sz )
{
#if defined( _MSC_VER ) && !defined( __NO_WIN32API__ ) && !defined( UNDER_CE )
	size_t n;
	uintptr_t *data = (uintptr_t*)p;
	for( n = 0; n < sz/sizeof(uintptr_t); n++, data++ )
		if( data[0] != val )
			return 0;
   return 1;
#else
	//   memset( p, n, sz );
   return 1;
#endif
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 void  MemCpy ( POINTER pTo, CPOINTER pFrom, size_t sz )
{
#if defined( _MSC_VER ) && !defined( __NO_WIN32API__ )&& !defined( UNDER_CE )
#  ifdef _WIN64
	__movsq( (uint64_t*)pTo, (uint64_t*)pFrom, sz/8 );
	if( sz & 4 )
		(*(uint32_t*)( ((uintptr_t)pTo) + sz - (sz&7) ) ) = (*(uint32_t*)( ((uintptr_t)pFrom) + sz - (sz&7) ) );
#  else
	__movsd( (DWORD*)pTo, (DWORD*)pFrom, sz/4 );
#  endif
	if( sz & 2 )
		(*(uint16_t*)( ((uintptr_t)pTo) + sz - (sz&3) ) ) = (*(uint16_t*)( ((uintptr_t)pFrom) + sz - (sz&3) ) );
	if( sz & 1 )
		(*(uint8_t*)( ((uintptr_t)pTo) + sz - (sz&1) ) ) = (*(uint8_t*)( ((uintptr_t)pFrom) + sz - (sz&1) ) );
#else
	memcpy( pTo, pFrom, sz );
#endif
}
int  MemCmp ( CPOINTER pOne, CPOINTER pTwo, size_t sz )
{
   // zero byte comparison, always same.
	if( !sz )
      return 0;
	if( !pOne && !pTwo )
		return 0;
	if( !pOne )
 // NULL < "anything"
		return -1;
	if( !pTwo )
  // "anything" > NULL
		return 1;
	return memcmp( pOne, pTwo, sz );
}
TEXTSTR StrCpyEx( TEXTSTR s1, CTEXTSTR s2, size_t n )
{
	size_t x;
	if( !s1 ) return s1;
	if( !s2 ) { if( s1 ) { s1[0] = 0; return s1; } }
	for( x = 0; x < n && (s1[x]=s2[x]); x++ );
	if( n )
		s1[n-1] = 0;
	return s1;
}
#undef StrCpy
TEXTSTR StrCpy( TEXTSTR s1, CTEXTSTR s2 )
{
	int x;
	for( x = 0; (s1[x]=s2[x]); x++ );
	return s1;
}
CTEXTSTR StrChr( CTEXTSTR s1, TEXTCHAR c )
{
	CTEXTSTR p1 = s1;
	if( !p1 ) return NULL;
	while( p1[0] && p1[0] != c ) p1++;
	if( p1[0] )
		return p1;
	return NULL;
}
CTEXTSTR StrRChr( CTEXTSTR s1, TEXTCHAR c )
{
	CTEXTSTR  p1 = s1;
	if( !p1 ) return NULL;
	while( p1[0] ) p1++;
	while( p1 != s1 && p1[0] != c ) p1--;
	if( p1[0] == c )
		return p1;
	return NULL;
}
#ifdef __cplusplus
TEXTSTR StrChr( TEXTSTR s1, TEXTCHAR c )
{
	TEXTSTR p1 = s1;
	if( !p1 ) return NULL;
	while( p1[0] && p1[0] != c ) p1++;
	if( p1[0] )
		return p1;
	return NULL;
}
TEXTSTR StrRChr( TEXTSTR s1, TEXTCHAR c )
{
	TEXTSTR  p1 = s1;
	if( !p1 ) return NULL;
	while( p1[0] ) p1++;
	while( p1 != s1 && p1[0] != c ) p1--;
	if( p1[0] == c )
		return p1;
	return NULL;
}
#endif
CTEXTSTR StrCaseStr( CTEXTSTR s1, CTEXTSTR s2 )
{
	int match = 0;
	CTEXTSTR p1, p2, began_at;
	if( !s1 )
		return NULL;
	if( !s2 )
		return s1;
	began_at = NULL;
	p1 = s1;
	p2 = s2;
	while( p1[0] && p2[0] )
	{
		if( p1[0] == p2[0] ||
         (p1[0] == '/' && p2[0] == '\\' ) ||
         (p1[0] == '\\' && p2[0] == '/' ) ||
			(((p1[0] >='a' && p1[0] <='z' )?p1[0]-('a'-'A'):p1[0])
			 == ((p2[0] >='a' && p2[0] <='z' )?p2[0]-('a'-'A'):p2[0]) ))
		{
			if( !match )
			{
				match++;
				began_at = p1;
			}
			//p2++;
		}
		else
		{
			if( began_at )
			{
  // start at the beginning again..
				p1 = began_at;
 // reset searching string.
				p2 = s2;
            began_at = NULL;
			}
			match = 0;
		}
		p1++;
      if( match )
			p2++;
	}
	if( !p2[0] )
		return began_at;
	return NULL;
}
CTEXTSTR StrStr( CTEXTSTR s1, CTEXTSTR s2 )
{
	int match = 0;
	CTEXTSTR p1, p2, began_at;
	if( !s1 )
		return NULL;
	if( !s2 )
		return s1;
	began_at = NULL;
	p1 = s1;
	p2 = s2;
	while( p1[0] && p2[0] )
	{
		if( p1[0] == p2[0] )
		{
			if( !match )
			{
				match++;
				began_at = p1;
			}
			//p2++;
		}
		else
		{
			if( began_at )
			{
  // start at the beginning again..
				p1 = began_at;
 // reset searching string.
				p2 = s2;
            began_at = NULL;
			}
			match = 0;
		}
		p1++;
      if( match )
			p2++;
	}
	if( !p2[0] )
		return began_at;
	return NULL;
}
#ifdef __cplusplus
TEXTSTR StrStr( TEXTSTR s1, CTEXTSTR s2 )
{
	int match = 0;
	TEXTSTR p1, began_at;
	CTEXTSTR p2;
	if( !s1 )
		return NULL;
	if( !s2 )
		return s1;
 // set began_at here too..
	began_at = p1 = s1;
	p2 = s2;
	while( p1[0] && p2[0] )
	{
		if( p1[0] == p2[0] )
		{
			if( !match )
			{
				match++;
				began_at = p1;
			}
		}
		else
		{
			if( began_at )
			{
  // start at the beginning again..
				p1 = began_at;
 // reset searching string.
				p2 = s2;
            began_at = NULL;
			}
			match = 0;
		}
		p1++;
      if( match )
			p2++;
	}
	if( !p2[0] )
		return began_at;
	return NULL;
}
#endif
//------------------------------------------------------------------------------------------------------
// result in 0(equal), 1 above, or -1 below
// *r contains the position of difference
 int  CmpMem8 ( void *s1, void *s2, unsigned long n, unsigned long *r )
{
	int t1, t2;
	uint32_t pos;
	{
		pos = 0;
		while( pos < n )
		{
			t1 = *(unsigned char*)s1;
			t2 = *(unsigned char*)s2;
			if( ( t1 ) == ( t2 ) ) {
				(pos)++;
				s1 = (void*)(((uintptr_t)s1) + 1);
				s2 = (void*)(((uintptr_t)s2) + 1);
			} else if( t1 > t2 ) {
				if( r )
					*r = pos;
				return 1;
			} else {
				if( r )
					*r = pos;
				return -1;
			}
		}
	}
	if( r )
		*r = pos;
	return 0;
}
//------------------------------------------------------------------------------------------------------
 TEXTSTR  StrDupEx ( CTEXTSTR original DBG_PASS )
{
	if( original )
	{
		uintptr_t len = (uintptr_t)StrLen( original ) + 1;
		TEXTCHAR *result;
		result = (TEXTCHAR*)AllocateEx( sizeof(TEXTCHAR)*len  DBG_RELAY );
		MemCpy( result, original, sizeof(TEXTCHAR)*len );
		return result;
	}
	return NULL;
}
size_t StrLen( CTEXTSTR s )
{
	size_t l;
	if( !s )
		return 0;
	for( l = 0; s[0];l++, s++);
	return l;
}
size_t CStrLen( char const* s )
{
	size_t l;
	if( !s )
		return 0;
	for( l = 0; s[0];l++,s++);
	return l;
}
#ifdef _UNICODE
char *  CStrDupEx ( CTEXTSTR original DBG_PASS )
{
	return WcharConvertEx( original DBG_RELAY );
}
TEXTSTR  DupCStrEx ( const char * original DBG_PASS )
{
	if( original )
		return CharWConvertEx( original DBG_RELAY );
	return NULL;
}
TEXTSTR  DupCStrLenEx( const char * original, size_t chars DBG_PASS )
{
	if( original )
		return CharWConvertExx( original, chars DBG_RELAY );
	return NULL;
}
#else
char *  CStrDupEx ( CTEXTSTR original DBG_PASS )
{
	INDEX len;
	char *result;
	if( !original )
		return NULL;
	for( len = 0; original[len]; len++ );
	result = (char*)AllocateEx( (len+1) * sizeof( result[0] ) DBG_RELAY );
	len = 0;
	while( ( result[len] = original[len] ) != 0 ) len++;
	return result;
}
TEXTSTR  DupCStrLenEx( const char * original, size_t chars DBG_PASS )
{
	size_t len = 0;
	TEXTSTR result, _result;
	if( !original )
		return NULL;
// (TEXTSTR)AllocateEx( (len + 1) * sizeof( result[0] )  DBG_RELAY );
	_result = result = NewArray( TEXTCHAR, chars + 1 );
	len = 0;
	while( len < chars ) ((*result++) = (*original++)), len++;
	result[0] = 0;
	return _result;
}
TEXTSTR  DupCStrEx( const char * original DBG_PASS )
{
	size_t len = 0;
	const char *_original;
	if( !original )
		return NULL;
	_original = original;
	while( (*original++) ) len++;
	return DupCStrLenEx( _original, len DBG_RELAY );
}
#endif
wchar_t *   DupTextToWideEx( CTEXTSTR original DBG_PASS )
{
#ifdef _UNICODE
   return StrDupEx( original DBG_RELAY );
#else
   return CharWConvertEx( original DBG_RELAY );
#endif
}
char *     DupTextToCharEx( CTEXTSTR original DBG_PASS )
{
#ifdef _UNICODE
   return WcharConvertEx( original DBG_RELAY );
#else
   return StrDupEx( original DBG_RELAY );
#endif
}
TEXTSTR     DupWideToTextEx( const wchar_t * original DBG_PASS )
{
#ifdef _UNICODE
   return StrDupEx( original DBG_RELAY );
#else
   return WcharConvertEx( original DBG_RELAY );
#endif
}
TEXTSTR     DupCharToTextEx( const char * original DBG_PASS )
{
#ifdef _UNICODE
   return CharWConvertEx( original DBG_RELAY );
#else
   return StrDupEx( original DBG_RELAY );
#endif
}
 int  StrCmp ( CTEXTSTR s1, CTEXTSTR s2 )
{
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
      return 0;
	for( ;s1[0] && s2[0] && ( s1[0] == s2[0] ); s1++, s2++ );
	return s1[0] - s2[0];
}
 int  StrCaseCmp ( CTEXTSTR s1, CTEXTSTR s2 )
{
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
		return 0;
	for( ;s1[0] && s2[0] && (((s1[0] >='a' && s1[0] <='z' )?s1[0]-('a'-'A'):s1[0])
									 == ((s2[0] >='a' && s2[0] <='z' )?s2[0]-('a'-'A'):s2[0]) );
		  s1++, s2++ );
	return tolower(s1[0]) - tolower(s2[0]);
}
 int  StrCmpEx ( CTEXTSTR s1, CTEXTSTR s2, INDEX maxlen )
{
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
      return 0;
	for( ;s1[0] && s2[0] && ( s1[0] == s2[0] ) && maxlen; s1++, s2++, maxlen-- );
	if( maxlen )
		return s1[0] - s2[0];
	return 0;
}
 int  StrCaseCmpEx ( CTEXTSTR s1, CTEXTSTR s2, size_t maxlen )
{
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
		return 0;
	for( ;s1[0] && s2[0] && (((s1[0] >='a' && s1[0] <='z' )?s1[0]-('a'-'A'):s1[0])
									 == ((s2[0] >='a' && s2[0] <='z' )?s2[0]-('a'-'A'):s2[0]) ) && maxlen;
		  s1++, s2++, maxlen-- );
	if( maxlen )
		return tolower(s1[0]) - tolower(s2[0]);
	return 0;
}
 int  StriCmp ( CTEXTSTR pOne, CTEXTSTR pTwo )
{
   return -1;
}
SACK_MEMORY_NAMESPACE_END
#define FILESYSTEM_LIBRARY_SOURCE
#define NO_UNICODE_C
#define WINFILE_COMMON_SOURCE
#define FIX_RELEASE_COM_COLLISION
#ifndef _DEBUG
#  define __FILESYS_NO_FILE_LOGGING__
#endif
#if defined( _WIN32 ) && !defined( __TURBOC__ )
#  ifndef UNDER_CE
  // findfirst,findnext, fileinfo
#  endif
#  ifdef UNDER_CE
#    define finddata_t WIN32_FIND_DATA
#    define findfirst FindFirstFile
#    define findnext  FindNextFile
#    define findclose FindClose
#  else
#    ifdef UNICODE
#      define finddata_t _wfinddata_t
#      define findfirst _wfindfirst
#      define findnext  _wfindnext
#      define findclose _findclose
#    else
#      define finddata_t _finddata_t
#      define findfirst _findfirst
#      define findnext  _findnext
#      define findclose _findclose
#    endif
#  endif
#else
 // opendir etc..
#  include <dirent.h>
#  ifndef MAX_PATH_NAME
#    define MAX_PATH_NAME PATH_MAX
#  endif
#endif
//#undef DeleteList
#ifdef WIN32
#endif
#ifndef UNDER_CE
//#include <fcntl.h>
//#include <io.h>
#endif
FILESYS_NAMESPACE
enum textModes {
	TM_BINARY = 0,
	TM_UNKNOWN,
	TM_UTF8,
	TM_UTF16BE,
	TM_UTF16LE,
	TM_UTF32BE,
	TM_UTF32LE,
	TM_UTF7,
	TM_UTF1,
	TM_UTF_EBCDIC,
	TM_UTF_SCSU,
	TM_UTF_BOCU,
	TM_UTF_GB_18030
};
struct file{
	TEXTSTR name;
	TEXTSTR fullname;
	int fullname_size;
 // HANDLE 's
	PLIST handles;
 // FILE *'s
	PLIST files;
	INDEX group;
	enum textModes textmode;
  // text file modes; skip existing BOM for seek purposes.
	size_t file_start_offset;
	struct file_system_mounted_interface *mount;
};
struct file_interface_tracker
{
	CTEXTSTR name;
	struct file_system_interface *fsi;
};
struct Group {
	TEXTSTR name;
	TEXTSTR base_path;
};
struct file_system_mounted_interface
{
	DeclareLink( struct file_system_mounted_interface );
	const char *name;
	int priority;
	uintptr_t psvInstance;
	struct file_system_interface *fsi;
	LOGICAL writeable;
};
#ifndef WINFILE_COMMON_SOURCE
extern
#endif
 struct winfile_local_tag {
	CRITICALSECTION cs_files;
	PLIST files;
	PLIST groups;
	PLIST handles;
	PLIST file_system_interface;
	struct file_system_interface *default_file_system_interface;
	struct file_system_mounted_interface *mounted_file_systems;
	struct file_system_mounted_interface *last_find_mount;
	struct file_system_mounted_interface *default_mount;
	LOGICAL have_default;
	struct {
		BIT_FIELD bLogOpenClose : 1;
		BIT_FIELD bInitialized : 1;
		BIT_FIELD bDeallocateClosedFiles : 1;
	} flags;
	TEXTSTR data_file_root;
	TEXTSTR producer;
	TEXTSTR application;
} *winfile_local;
//#define l (*winfile_local)
static void UpdateLocalDataPath( void )
{
#ifdef _WIN32
	TEXTCHAR path[MAX_PATH];
	TEXTCHAR *realpath;
	size_t len;
#ifndef SHGFP_TYPE_CURRENT
#define SHGFP_TYPE_CURRENT 0
#endif
	SHGetFolderPath( NULL, CSIDL_COMMON_APPDATA, NULL, SHGFP_TYPE_CURRENT, path );
	realpath = NewArray( TEXTCHAR, len = StrLen( path )
							  + StrLen( (*winfile_local).producer?(*winfile_local).producer:WIDE("") )
 // worse case +3
							  + StrLen( (*winfile_local).application?(*winfile_local).application:WIDE("") ) + 3 );
	tnprintf( realpath, len, WIDE("%s%s%s%s%s"), path
			  , (*winfile_local).producer?WIDE("/"):WIDE(""), (*winfile_local).producer?(*winfile_local).producer:WIDE("")
			  , (*winfile_local).application?WIDE("/"):WIDE(""), (*winfile_local).application?(*winfile_local).application:WIDE("")
			  );
	if( (*winfile_local).data_file_root )
		Deallocate( TEXTSTR, (*winfile_local).data_file_root );
	(*winfile_local).data_file_root = realpath;
	MakePath( (*winfile_local).data_file_root );
#else
	(*winfile_local).data_file_root = StrDup( WIDE(".") );
#endif
}
void sack_set_common_data_producer( CTEXTSTR name )
{
	(*winfile_local).producer = StrDup( name );
	UpdateLocalDataPath();
}
void sack_set_common_data_application( CTEXTSTR name )
{
	(*winfile_local).application = StrDup( name );
	UpdateLocalDataPath();
}
static void LocalInit( void )
{
	if( !winfile_local )
	{
		SimpleRegisterAndCreateGlobal( winfile_local );
		if( !(*winfile_local).flags.bInitialized )
		{
			InitializeCriticalSec( &(*winfile_local).cs_files );
			(*winfile_local).flags.bInitialized = 1;
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
			(*winfile_local).flags.bLogOpenClose = 0;
#endif
			{
#ifdef _WIN32
				sack_set_common_data_producer( WIDE( "Freedom Collective" ) );
				sack_set_common_data_application( GetProgramName() );
#else
				(*winfile_local).data_file_root = StrDup( WIDE( "~" ) );
#endif
			}
		}
	}
}
static void InitGroups( void )
{
	struct Group *group;
	TEXTCHAR tmp[256];
	// known handle '0' is 'default' which is CurrentWorkingDirectory at load.
	group = New( struct Group );
	group->base_path = StrDup( GetCurrentPath( tmp, sizeof( tmp ) ) );
	group->name = StrDup( WIDE( "Default" ) );
	AddLink( &(*winfile_local).groups, group );
	// known handle '1' is the program's load path.
	group = New( struct Group );
#ifdef __ANDROID__
	// assets and other files are in the data directory
	group->base_path = StrDup( GetStartupPath() );
#else
	group->base_path = StrDup( GetProgramPath() );
#endif
	group->name = StrDup( WIDE( "Program Path" ) );
	AddLink( &(*winfile_local).groups, group );
	// known handle '1' is the program's start path.
	group = New( struct Group );
	group->base_path = StrDup( GetStartupPath() );
	group->name = StrDup( WIDE( "Startup Path" ) );
	AddLink( &(*winfile_local).groups, group );
	(*winfile_local).have_default = TRUE;
}
static struct Group *GetGroupFilePath( CTEXTSTR group )
{
	struct Group *filegroup;
	INDEX idx;
	if( !(*winfile_local).groups )
	{
		InitGroups();
	}
	LIST_FORALL( (*winfile_local).groups, idx, struct Group *, filegroup )
	{
		if( StrCaseCmp( filegroup->name, group ) == 0 )
		{
		break;
		}
	}
	return filegroup;
}
INDEX  GetFileGroup ( CTEXTSTR groupname, CTEXTSTR default_path )
{
	struct Group *filegroup = GetGroupFilePath( groupname );
	if( !filegroup && default_path )
	{
		{
			TEXTCHAR tmp_ent[256];
			TEXTCHAR tmp[256];
			tnprintf( tmp_ent, sizeof( tmp_ent ), WIDE( "file group/%s" ), groupname );
			//lprintf( WIDE( "option to save is %s" ), tmp );
#ifdef __NO_OPTIONS__
			tmp[0] = 0;
#else
			if( (*winfile_local).have_default )
				SACK_GetProfileString( GetProgramName(), tmp_ent, default_path?default_path:WIDE( "" ), tmp, sizeof( tmp ) );
#endif
			if( tmp[0] )
				default_path = tmp;
			else if( default_path )
			{
#ifndef __NO_OPTIONS__
				SACK_WriteProfileString( GetProgramName(), tmp_ent, default_path );
#endif
			}
		}
		filegroup = New( struct Group );
		filegroup->name = StrDup( groupname );
		if( default_path )
			filegroup->base_path = StrDup( default_path );
		else
			filegroup->base_path = StrDup( WIDE( "." ) );
		AddLink( &(*winfile_local).groups, filegroup );
	}
	return FindLink( &(*winfile_local).groups, filegroup );
}
TEXTSTR GetFileGroupText ( INDEX group, TEXTSTR path, int path_chars )
{
	struct Group* filegroup = (struct Group *)GetLink( &(*winfile_local).groups, group );
	if( !filegroup )
	{
		path[0] = 0;
		return 0;
	}
	StrCpyEx( path, filegroup->base_path, path_chars );
	return path;
}
TEXTSTR ExpandPathVariable( CTEXTSTR path )
{
	TEXTSTR subst_path = NULL;
	TEXTSTR end = NULL;
	TEXTSTR tmp_path = StrDup( path );
	TEXTSTR tmp = NULL;
	TEXTSTR newest_path = NULL;
	size_t  len;
	size_t  this_length;
	INDEX   group;
	struct  Group* filegroup;
	if( path )
	{
		while( ( subst_path = (TEXTSTR)StrChr( tmp_path, '%' ) ) )
		{
			end = (TEXTSTR)StrChr( ++subst_path, '%' );
			//lprintf( WIDE( "Found magic subst in string" ) );
			if( end )
			{
				this_length = StrLen( tmp_path );
				tmp = NewArray( TEXTCHAR, len = ( end - subst_path ) + 1 );
				tnprintf( tmp, len * sizeof( TEXTCHAR ), WIDE( "%*.*s" ), (int)(end-subst_path), (int)(end-subst_path), subst_path );
				group = GetFileGroup( tmp, NULL );
				if( group != INVALID_INDEX ) {
					filegroup = (struct Group *)GetLink( &(*winfile_local).groups, group );
  // must deallocate tmp
					Deallocate( TEXTCHAR*, tmp );
					newest_path = NewArray( TEXTCHAR, len = (subst_path - tmp_path) + StrLen( filegroup->base_path ) + (this_length - (end - tmp_path)) + 1 );
					//=======================================================================
					// Get rid of the ending '%' AND any '/' or '\' that might come after it
					//=======================================================================
					tnprintf( newest_path, len, WIDE( "%*.*s%s/%s" ), (int)((subst_path - tmp_path) - 1), (int)((subst_path - tmp_path) - 1), tmp_path, filegroup->base_path,
						((end + 1)[0] == '/' || (end + 1)[0] == '\\') ? (end + 2) : (end + 1) );
					Deallocate( TEXTCHAR*, tmp_path );
					tmp_path = ExpandPathVariable( newest_path );
					Deallocate( TEXTCHAR*, newest_path );
				}
				else {
					CTEXTSTR external_var = OSALOT_GetEnvironmentVariable( tmp );
					if( external_var ) {
  // must deallocate tmp
						Deallocate( TEXTCHAR*, tmp );
						newest_path = NewArray( TEXTCHAR, len = (subst_path - tmp_path) + StrLen( external_var ) + (this_length - (end - tmp_path)) + 1 );
						//=======================================================================
						// Get rid of the ending '%' AND any '/' or '\' that might come after it
						//=======================================================================
						tnprintf( newest_path, len, WIDE( "%*.*s%s/%s" ), (int)((subst_path - tmp_path) - 1), (int)((subst_path - tmp_path) - 1), tmp_path, external_var,
							((end + 1)[0] == '/' || (end + 1)[0] == '\\') ? (end + 2) : (end + 1) );
						tmp_path = ExpandPathVariable( newest_path );
						Deallocate( TEXTCHAR*, newest_path );
					}
					else
						tmp_path = tmp;
				}
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
				if( (*winfile_local).flags.bLogOpenClose )
					lprintf( WIDE( "transform subst [%s]" ), tmp_path );
#endif
			}
		}
	}
	return tmp_path;
}
TEXTSTR ExpandPathEx( CTEXTSTR path, struct file_system_interface *fsi )
{
	TEXTSTR tmp_path = NULL;
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "input path is [%s]" ), path );
#endif
	if( path )
	{
		if( !fsi && !IsAbsolutePath( path ) )
		{
			if( ( path[0] == '.' ) && ( ( path[1] == 0 ) || ( path[1] == '/' ) || ( path[1] == '\\' ) ) )
			{
				TEXTCHAR here[256];
				size_t len;
				GetCurrentPath( here, sizeof( here ) );
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, WIDE( "%s%s%s" )
						 , here
						 , path[1]?WIDE("/"):WIDE("")
						 , path[1]?(path + 2):WIDE("") );
			}
			else if( ( path[0] == '@' ) && ( ( path[1] == '/' ) || ( path[1] == '\\' ) ) )
			{
				CTEXTSTR here;
				size_t len;
				here = GetLibraryPath();
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, WIDE( "%s/%s" ), here, path + 2 );
			}
			else if( ( path[0] == '#' ) && ( ( path[1] == '/' ) || ( path[1] == '\\' ) ) )
			{
				CTEXTSTR here;
				size_t len;
				here = GetProgramPath();
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, WIDE( "%s/%s" ), here, path + 2 );
			}
			else if( ( path[0] == '~' ) && ( ( path[1] == '/' ) || ( path[1] == '\\' ) ) )
			{
				CTEXTSTR here;
				size_t len;
				here = OSALOT_GetEnvironmentVariable(WIDE("HOME"));
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, WIDE( "%s/%s" ), here, path + 2 );
			}
			else if( ( path[0] == '*' ) && ( ( path[1] == '/' ) || ( path[1] == '\\' ) ) )
			{
				CTEXTSTR here;
				size_t len;
				here = (*winfile_local).data_file_root;
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, WIDE( "%s/%s" ), here, path + 2 );
			}
			else if( path[0] == '^' && ( ( path[1] == '/' ) || ( path[1] == '\\' ) ) )
			{
				CTEXTSTR here;
				size_t len;
				here = GetStartupPath();
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, WIDE( "%s/%s" ), here, path + 2 );
			}
			else if( path[0] == '%' )
			{
				tmp_path = ExpandPathVariable( path );
			}
			else
			{
				tmp_path = StrDup( path );
			}
#if __ANDROID__
			{
				int len_base;
				TEXTCHAR here[256];
				size_t len;
				size_t ofs;
				GetCurrentPath( here, sizeof( here ) );
				if( StrStr( tmp_path, here ) )
					len = StrLen( here );
				else
					len = 0;
		/*
				if( (*winfile_local).flags.bLogOpenClose )
					lprintf( "Fix dots in [%s]", tmp_path );
				for( ofs = len+1; tmp_path[ofs]; ofs++ )
				{
					if( tmp_path[ofs] == '/' )
						tmp_path[ofs] = '.';
					if( tmp_path[ofs] == '\\' )
						tmp_path[ofs] = '.';
				}
				if( (*winfile_local).flags.bLogOpenClose )
				lprintf( "Fixed result [%s]", tmp_path );
			*/
			}
#endif
		}
		else if( StrChr( path, '%' ) != NULL )
		{
			tmp_path = ExpandPathVariable( path );
		}
		else
		{
			tmp_path = StrDup( path );
		}
	}
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "output path is [%s]" ), tmp_path );
#endif
	return tmp_path;
}
TEXTSTR ExpandPath( CTEXTSTR path )
{
	return ExpandPathEx( path, NULL );
}
INDEX  SetGroupFilePath ( CTEXTSTR group, CTEXTSTR path )
{
	struct Group *filegroup = GetGroupFilePath( group );
	if( !filegroup )
	{
		TEXTCHAR tmp[256];
		filegroup = New( struct Group );
		filegroup->name = StrDup( group );
		filegroup->base_path = StrDup( path );
		tnprintf( tmp, sizeof( tmp ), WIDE( "file group/%s" ), group );
#ifndef __NO_OPTIONS__
		if( (*winfile_local).have_default )
		{
			TEXTCHAR tmp2[256];
			SACK_GetProfileString( GetProgramName(), tmp, WIDE( "" ), tmp2, sizeof( tmp2 ) );
		if( StrCaseCmp( path, tmp2 ) )
				SACK_WriteProfileString( GetProgramName(), tmp, path );
		}
#endif
		AddLink( &(*winfile_local).groups, filegroup );
		(*winfile_local).have_default = TRUE;
	}
	else
	{
		Deallocate( TEXTCHAR*, filegroup->base_path );
		filegroup->base_path = StrDup( path );
	}
	return FindLink( &(*winfile_local).groups, filegroup );
}
void SetDefaultFilePath( CTEXTSTR path )
{
	TEXTSTR tmp_path = NULL;
	struct Group *filegroup;
	LocalInit();
	filegroup = (struct Group *)GetLink( &(*winfile_local).groups, 0 );
	tmp_path = ExpandPath( path );
	if( (*winfile_local).groups && filegroup )
	{
		Deallocate( TEXTSTR, filegroup->base_path );
		filegroup->base_path = StrDup( tmp_path?tmp_path:path );
	}
	else
	{
		SetGroupFilePath( WIDE( "Default" ), tmp_path?tmp_path:path );
	}
	if( tmp_path )
		Deallocate( TEXTCHAR*, tmp_path );
}
static TEXTSTR PrependBasePathEx( INDEX groupid, struct Group *group, CTEXTSTR filename, LOGICAL expand_path )
{
	TEXTSTR real_filename = filename?ExpandPath( filename ):NULL;
	TEXTSTR fullname;
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE("Prepend to {%s} %p %") _size_f, real_filename, group, groupid );
#endif
	if( (*winfile_local).groups )
	{
		//SetDefaultFilePath( GetProgramPath() );
		if( !group )
		{
			if( groupid < 4096 )
				group = (struct Group *)GetLink( &(*winfile_local).groups, groupid );
		}
	}
	if( !group || ( filename && ( IsAbsolutePath( real_filename ) ) ) )
	{
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf( WIDE("already an absolute path.  [%s]"), real_filename );
#endif
		return real_filename;
	}
	{
		TEXTSTR tmp_path;
		size_t len;
		if( expand_path )
			tmp_path = ExpandPath( group->base_path );
		else
			tmp_path = group->base_path;
		fullname = NewArray( TEXTCHAR, len = StrLen( filename ) + StrLen(tmp_path) + 2 );
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf(WIDE("prepend %s[%s] with %s"), group->base_path, tmp_path, filename );
#endif
		tnprintf( fullname, len, WIDE("%s/%s"), tmp_path, real_filename );
#if __ANDROID__
		{
			int len_base;
			static TEXTCHAR here[256];
			static size_t len;
			size_t ofs;
			if( !here[0] )
			{
				GetCurrentPath( here, sizeof( here ) );
			}
			if( StrStr( tmp_path, here ) )
				len = StrLen( here );
			else
				len = 0;
		/*
			if( (*winfile_local).flags.bLogOpenClose )
				lprintf( WIDE("Fix dots in [%s]"), fullname );
			for( ofs = len+1; fullname[ofs]; ofs++ )
			{
				if( fullname[ofs] == '/' )
					fullname[ofs] = '.';
				if( fullname[ofs] == '\\' )
					fullname[ofs] = '.';
			}
		*/
		}
#endif
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf( WIDE("result %s"), fullname );
#endif
		if( expand_path )
			Deallocate( TEXTCHAR*, tmp_path );
		Deallocate( TEXTCHAR*, real_filename );
	}
	return fullname;
}
static TEXTSTR PrependBasePath( INDEX groupid, struct Group *group, CTEXTSTR filename )
{
   return PrependBasePathEx(groupid,group,filename,TRUE );
}
TEXTSTR sack_prepend_path( INDEX group, CTEXTSTR filename )
{
	struct Group *filegroup = (struct Group *)GetLink( &(*winfile_local).groups, group );
	TEXTSTR result = PrependBasePath( group, filegroup, filename );
	return result;
}
#ifdef __LINUX__
#define HANDLE int
#define INVALID_HANDLE_VALUE -1
#endif
static void DetectUnicodeBOM( FILE *file ) {
   //00 00 FE FF     UTF-32, big-endian
   //FF FE 00 00     UTF-32, little-endian
   //FE FF           UTF-16, big-endian
   //FF FE           UTF-16, little-endian
   //EF BB BF        UTF-8
//Encoding	Representation (hexadecimal)	Representation (decimal)	Bytes as CP1252 characters
//UTF-8[t 1]		EF BB BF		239 187 191	ï»¿
//UTF-16 (BE)		FE FF			254 255	þÿ      þÿ
//UTF-16 (LE)		FF FE			255 254	ÿþ      ÿþ
//UTF-32 (BE)		00 00 FE FF		0 0 254 255	??þÿ (? refers to the ASCII null character)
//UTF-32 (LE)		FF FE 00 00[t 2]	255 254 0 0	ÿþ?? (? refers to the ASCII null character)
//UTF-7[t 1]		2B 2F 76 38             43 47 118 56	+/v9
//			2B 2F 76 39		43 47 118 43	+/v+
//			2B 2F 76 2B             43 47 118 47	+/v/
//			2B 2F 76 2F[t 3]	43 47 118 57	+/v8
//			2B 2F 76 38 2D[t 4]	43 47 118 56 45	+/v8-
//
//UTF-1[t 1]		F7 64 4C	247 100 76	÷dL
//UTF-EBCDIC[t 1]	DD 73 66 73	221 115 102 115	Ýsfs
//SCSU[t 1]		0E FE FF[t 5]	14 254 255	?þÿ (? represents the ASCII "shift out" character)
//BOCU-1[t 1]		FB EE 28	251 238 40	ûî(
//GB-18030[t 1]		84 31 95 33	132 49 149 51	„1•3
	struct file* _file = (struct file*)file;
	// file was opened with 't' flag, test what sort of 't' the file might be.
	// can result in conversion based on UNICODE (utf-16) compilation flag is set or not (UTF8).
	if( _file->textmode == TM_UNKNOWN ) {
		uint8_t bytes[5];
		enum textModes textmode = _file->textmode;
		size_t bytelength;
		_file->textmode = TM_BINARY;
		bytelength = sack_fread( bytes, 1, 5, file );
		sack_fseek( file, 0, SEEK_SET );
		if( bytelength < 5 ) {
			size_t n;
			for( n = bytelength; n < 5; n++ )
				bytes[n] = 0;
		}
		if( bytes[0] == 0xEF ) {
			// UTF8 test
			if( bytes[1] == 0xBB && bytes[2] == 0xBF ) {
				_file->textmode = TM_UTF8;
				sack_fseek( file, 3, SEEK_SET );
			} else {
				_file->textmode = TM_UTF8;
			}
		} else if( bytes[0] == 0xFF ) {
			// UTF32/16 LE test
			if( bytes[1] == 0xFE ) {
				if( bytes[2] == 0 && bytes[3] == 0 ) {
					_file->textmode = TM_UTF32LE;
				}
			}
		} else if( bytes[0] == 0xFE ) {
			// UTF16ZBE test
			if( bytes[1] == 0xFF ) {
				_file->textmode = TM_UTF16BE;
			} else {
				_file->textmode = TM_UTF8;
			}
		} else if( bytes[0] == 0 && bytes[1] == 0 ) {
			// UTF32BE test...
			if( bytes[2] == 0xFE && bytes[3] == 0xFF ) {
				_file->textmode = TM_UTF32BE;
			} else
				_file->textmode = TM_UTF8;
		} else {
		}
	}
}
static void DecodeFopenOpts( struct file *file, CTEXTSTR opts ) {
	CTEXTSTR op = opts;
	for( ; op[0]; op++ ) {
		if( op[0] == 'w' || op[0] == 'a' || op[0] == 'r' || op[0] == '+' )
			continue;
		if( op[0] == ' ' ) continue;
		if( op[0] == 't' ) {
         file->textmode = TM_UNKNOWN;
		} else if( op[0] == 'b' ) {
 // also the default.
         file->textmode = TM_BINARY;
		} else if( op[0] == ',' ) {
         const char *restore = op;
			op++;
			while( op[0] == ' ' ) op++;
			if( op[0] == 'c' ) op++; else { op = restore; continue; }
			if( op[0] == 'c' ) op++; else { op = restore; continue; }
			if( op[0] == 's' ) op++; else { op = restore; continue; }
			while( op[0] == ' ' ) op++;
			if( op[0] == '=' ) op++; else { op = restore; continue; }
			while( op[0] == ' ' ) op++;
			if( StrCaseCmpEx( op, "unicode", 7 ) == 0 ) {
				file->textmode = TM_UTF16LE;
 // minus 1, becuase for loop will increment.
            op += 6;
			}
			else if( StrCaseCmpEx( op, "utf-16le", 8 ) == 0 ) {
				file->textmode = TM_UTF16LE;
 // minus 1, becuase for loop will increment.
            op += 7;
			}
			else if( ( StrCaseCmpEx( op, "utf-8", 5 ) == 0 ) ) {
				file->textmode = TM_UTF8;
 // minus 1, becuase for loop will increment.
            op += 4;
			}
			else if( ( StrCaseCmpEx( op, "utf-16be", 8 ) == 0 ) ) {
				file->textmode = TM_UTF16BE;
 // minus 1, becuase for loop will increment.
            op += 7;
			}
			else if( ( StrCaseCmpEx( op, "utf-32le", 8 ) == 0 ) ) {
				file->textmode = TM_UTF32LE;
 // minus 1, becuase for loop will increment.
            op += 7;
			}
			else if( ( StrCaseCmpEx( op, "utf-32be", 8 ) == 0 ) ) {
				file->textmode = TM_UTF32BE;
 // minus 1, becuase for loop will increment.
            op += 7;
			}
		}
	}
}
HANDLE sack_open( INDEX group, CTEXTSTR filename, int opts, ... )
{
	HANDLE handle;
	struct file *file;
	INDEX idx;
	EnterCriticalSec( &(*winfile_local).cs_files );
	LIST_FORALL( (*winfile_local).files, idx, struct file *, file )
	{
		if( StrCmp( file->name, filename ) == 0 )
		{
			break;
		}
	}
	LeaveCriticalSec( &(*winfile_local).cs_files );
	if( !file )
	{
		struct Group *filegroup = (struct Group *)GetLink( &(*winfile_local).groups, group );
		file = New( struct file );
		file->name = StrDup( filename );
		file->fullname = PrependBasePath( group, filegroup, filename );
		file->handles = NULL;
		file->files = NULL;
		file->group = group;
		EnterCriticalSec( &(*winfile_local).cs_files );
		AddLink( &(*winfile_local).files,file );
		LeaveCriticalSec( &(*winfile_local).cs_files );
	}
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "Open File: [%s]" ), file->fullname );
#endif
#ifdef __LINUX__
#  undef open
	{
#  ifdef UNICODE
		char *tmpfile = CStrDup( file->fullname );
		handle = open( tmpfile, opts );
		Deallocate( char *, tmpfile );
#  else
		handle = open( file->fullname, opts );
#  endif
	}
#  if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "open %s %d %d" ), file->fullname, handle, opts );
#  endif
#else
	switch( opts & 3 )
	{
	case 0:
	handle = CreateFile( file->fullname
							, GENERIC_READ
							, FILE_SHARE_READ
							, NULL
							, ((opts&O_CREAT)?CREATE_ALWAYS:OPEN_EXISTING)
							, FILE_ATTRIBUTE_NORMAL
							, NULL );
	break;
	case 1:
	handle = CreateFile( file->fullname
							, GENERIC_WRITE
							, FILE_SHARE_READ|FILE_SHARE_WRITE
							, NULL
							, ((opts&O_CREAT)?CREATE_ALWAYS:OPEN_EXISTING)
							, FILE_ATTRIBUTE_NORMAL
							, NULL );
		break;
	case 2:
	case 3:
	handle = CreateFile( file->fullname
							,(GENERIC_READ|GENERIC_WRITE)
							, FILE_SHARE_READ|FILE_SHARE_WRITE
							, NULL
							, ((opts&O_CREAT)?CREATE_ALWAYS:OPEN_EXISTING)
							, FILE_ATTRIBUTE_NORMAL
							, NULL );
	break;
	}
#  if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "open %s %p %08x" ), file->fullname, (POINTER)handle, opts );
#  endif
#endif
	if( handle == INVALID_HANDLE_VALUE )
	{
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf( WIDE( "Failed to open file [%s]=[%s]" ), file->name, file->fullname );
#endif
		return INVALID_HANDLE_VALUE;
	}
	if( handle != INVALID_HANDLE_VALUE )
	{
		HANDLE *holder = New( HANDLE );
		holder[0] = handle;
		AddLink( &file->handles, holder );
	}
	return handle;
}
#ifdef WIN32
HANDLE sack_openfile( INDEX group,CTEXTSTR filename, OFSTRUCT *of, int flags )
{
#ifdef _UNICODE
	char *tmpname = WcharConvert( filename );
#undef OpenFile
	HANDLE result = (HANDLE)OpenFile(tmpname,of,flags);
	Deallocate( char*, tmpname );
	return result;
#else
#undef OpenFile
	return (HANDLE)(uintptr_t)OpenFile(filename,of,flags);
#endif
}
#endif
struct file *FindFileByHandle( HANDLE file_file )
{
	struct file *file;
	INDEX idx;
	EnterCriticalSec( &(*winfile_local).cs_files );
	LIST_FORALL( (*winfile_local).files, idx, struct file *, file )
	{
		INDEX idx2;
		HANDLE* check;
		LIST_FORALL( file->handles, idx2, HANDLE*, check )
		{
			if( check[0] == file_file )
				break;
		}
		if( check )
			break;
	}
	LeaveCriticalSec( &(*winfile_local).cs_files );
	return file;
}
//----------------------------------------------------------------------------
LOGICAL sack_iset_eof ( INDEX file_handle )
{
	HANDLE *holder = (HANDLE*)GetLink( &(*winfile_local).handles, file_handle );
	HANDLE handle = holder?holder[0]:INVALID_HANDLE_VALUE;
#ifdef _WIN32
	return SetEndOfFile( handle );
#else
	return ftruncate( handle, lseek( handle, 0, SEEK_CUR ) );
#endif
}
//----------------------------------------------------------------------------
struct file *FindFileByFILE( FILE *file_file )
{
	struct file *file;
	INDEX idx;
	LocalInit();
	EnterCriticalSec( &(*winfile_local).cs_files );
	LIST_FORALL( (*winfile_local).files, idx, struct file *, file )
	{
		INDEX idx2;
		FILE *check;
		LIST_FORALL( file->files, idx2, FILE *, check )
		{
			if( check == file_file )
				break;
		}
		if( check )
			break;
	}
	LeaveCriticalSec( &(*winfile_local).cs_files );
	return file;
}
LOGICAL sack_set_eof ( HANDLE file_handle )
{
	struct file *file;
	file = FindFileByFILE( (FILE*)(uintptr_t)file_handle );
	if( file )
	{
		if( file->mount )
		{
			file->mount->fsi->truncate( (void*)(uintptr_t)file_handle );
			//lprintf( WIDE("result is %d"), file->mount->fsi->size( (void*)file_handle ) );
		}
		else
		{
#ifdef _WIN32
			;
#else
			truncate( file->fullname, sack_ftell( (FILE*)(uintptr_t)file_handle ) );
#endif
		}
		return TRUE;
	}
	else
	{
		HANDLE *holder = (HANDLE*)GetLink( &(*winfile_local).handles, (INDEX)file_handle );
		HANDLE handle = holder?holder[0]:INVALID_HANDLE_VALUE;
#ifdef _WIN32
		return SetEndOfFile( handle );
#else
		return ftruncate( handle, lseek( handle, 0, SEEK_CUR ) );
#endif
	}
}
//----------------------------------------------------------------------------
int sack_ftruncate( FILE *file_file )
{
	struct file *file;
	file = FindFileByFILE( file_file );
	if( file )
	{
		if( file->mount && file->mount->fsi )
		{
			file->mount->fsi->truncate( (void*)file_file );
			//lprintf( WIDE("result is %d"), file->mount->fsi->size( (void*)file_file ) );
		}
		else
		{
#ifdef _WIN32
			_chsize( _fileno( file_file ), ftell( file_file ) );
#else
			truncate( file->fullname, sack_ftell( (FILE*)file_file ) );
#endif
		}
		return TRUE;
	}
	return FALSE;
}
//----------------------------------------------------------------------------
long sack_tell( INDEX file_handle )
{
	HANDLE *holder = (HANDLE*)GetLink( &(*winfile_local).handles, file_handle );
	HANDLE handle = holder?holder[0]:INVALID_HANDLE_VALUE;
#ifdef WIN32
 // must have GENERIC_READ and/or GENERIC_WRITE
	uint32_t length = SetFilePointer( handle
	// do not move pointer
								, 0
  // hFile is not large enough to need this pointer
								, NULL
  // provides offset from current position
								, FILE_CURRENT);
	return length;
#else
	return lseek( handle, 0, SEEK_SET );
#endif
}
//----------------------------------------------------------------------------
HANDLE sack_creat( INDEX group, CTEXTSTR file, int opts, ... )
{
	return sack_open( group, file, opts | O_CREAT );
}
//----------------------------------------------------------------------------
int sack_lseek( HANDLE file_handle, int pos, int whence )
{
#ifdef _WIN32
	return SetFilePointer(file_handle,pos,NULL,whence);
#else
	return lseek( file_handle, pos, whence );
#endif
}
//----------------------------------------------------------------------------
int sack_read( HANDLE file_handle, POINTER buffer, int size )
{
#ifdef _WIN32
	DWORD dwLastReadResult;
	//lprintf( WIDE( "..." ) );
	return (ReadFile( (HANDLE)file_handle, buffer, size, &dwLastReadResult, NULL )?dwLastReadResult:-1 );
#else
	return read( file_handle, buffer, size );
#endif
}
//----------------------------------------------------------------------------
int sack_write( HANDLE file_handle, CPOINTER buffer, int size )
{
#ifdef _WIN32
	DWORD dwLastWrittenResult;
	return (WriteFile( (HANDLE)file_handle, (POINTER)buffer, size, &dwLastWrittenResult, NULL )?dwLastWrittenResult:-1 );
#else
	return write( file_handle, buffer, size );
#endif
}
//----------------------------------------------------------------------------
INDEX sack_icreat( INDEX group, CTEXTSTR file, int opts, ... )
{
	return sack_iopen( group, file, opts | O_CREAT );
}
//----------------------------------------------------------------------------
int sack_close( HANDLE file_handle )
{
	struct file *file = FindFileByHandle( (HANDLE)file_handle );
	if( file )
	{
		SetLink( &file->handles, (INDEX)file_handle, NULL );
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf( WIDE("Close %s"), file->fullname );
#endif
		/*
		Deallocate( TEXTCHAR*, file->name );
		Deallocate( TEXTCHAR*, file->fullname );
		Deallocate( TEXTCHAR*, file );
		DeleteLink( &(*winfile_local).files, file );
		*/
	}
	if( file_handle != INVALID_HANDLE_VALUE )
#ifdef _WIN32
		return CloseHandle((HANDLE)file_handle);
#else
		return close( file_handle );
#endif
	return 0;
}
//----------------------------------------------------------------------------
INDEX sack_iopen( INDEX group, CTEXTSTR filename, int opts, ... )
{
	HANDLE h;
	INDEX result;
	h = sack_open( group, filename, opts );
	if( h == INVALID_HANDLE_VALUE )
	{
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf( WIDE( "Failed to open %s" ), filename );
#endif
		return INVALID_INDEX;
	}
	EnterCriticalSec( &(*winfile_local).cs_files );
	{
		HANDLE *holder = New( HANDLE );
		holder[0] = h;
		AddLink( &(*winfile_local).handles, holder );
		result = FindLink( &(*winfile_local).handles, holder );
	}
	LeaveCriticalSec( &(*winfile_local).cs_files );
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "return iopen of [%s]=%p(%")_size_f WIDE(")?" ), filename, (void*)(uintptr_t)h, (size_t)result );
#endif
	return result;
}
//----------------------------------------------------------------------------
int sack_iclose( INDEX file_handle )
{
	int result;
	EnterCriticalSec( &(*winfile_local).cs_files );
	{
		HANDLE *holder = (HANDLE*)GetLink( &(*winfile_local).handles, file_handle );
		HANDLE handle = holder?holder[0]:INVALID_HANDLE_VALUE;
		SetLink( &(*winfile_local).handles, file_handle, 0 );
		Deallocate( HANDLE*, holder );
		result = sack_close( handle );
	}
	LeaveCriticalSec( &(*winfile_local).cs_files );
	return result;
}
//----------------------------------------------------------------------------
int sack_ilseek( INDEX file_handle, size_t pos, int whence )
{
	int result;
	EnterCriticalSec( &(*winfile_local).cs_files );
	{
		 HANDLE *holder = (HANDLE*)GetLink( &(*winfile_local).handles, file_handle );
		 HANDLE handle = holder?holder[0]:INVALID_HANDLE_VALUE;
#ifdef _WIN32
		result = SetFilePointer(handle,(LONG)pos,NULL,whence);
#else
		result = lseek( handle, pos, whence );
#endif
	}
	LeaveCriticalSec( &(*winfile_local).cs_files );
	return result;
}
//----------------------------------------------------------------------------
int sack_iread( INDEX file_handle, POINTER buffer, int size )
{
	EnterCriticalSec( &(*winfile_local).cs_files );
	{
		 HANDLE *holder = (HANDLE*)GetLink( &(*winfile_local).handles, file_handle );
		 HANDLE handle = holder?holder[0]:INVALID_HANDLE_VALUE;
#ifdef _WIN32
		DWORD dwLastReadResult;
		//lprintf( WIDE( "... %p %p" ), file_handle, h );
		LeaveCriticalSec( &(*winfile_local).cs_files );
		return (ReadFile( handle, (POINTER)buffer, size, &dwLastReadResult, NULL )?dwLastReadResult:-1 );
#else
		return read( handle, buffer, size );
#endif
	}
}
//----------------------------------------------------------------------------
int sack_iwrite( INDEX file_handle, CPOINTER buffer, int size )
{
	EnterCriticalSec( &(*winfile_local).cs_files );
	{
		 HANDLE *holder = (HANDLE*)GetLink( &(*winfile_local).handles, file_handle );
		 HANDLE handle = holder?holder[0]:INVALID_HANDLE_VALUE;
#ifdef _WIN32
		DWORD dwLastWrittenResult;
		LeaveCriticalSec( &(*winfile_local).cs_files );
		return (WriteFile( handle, (POINTER)buffer, size, &dwLastWrittenResult, NULL )?dwLastWrittenResult:-1 );
#else
		return write( handle, buffer, size );
#endif
	}
}
//----------------------------------------------------------------------------
int sack_unlinkEx( INDEX group, CTEXTSTR filename, struct file_system_mounted_interface *mount )
{
	while( mount )
	{
		int okay = 1;
		if( mount->fsi )
		{
#ifdef UNICODE
			char *_filename = CStrDup( filename );
#  define filename _filename
#endif
			if( mount->fsi->exists( mount->psvInstance, filename ) )
			{
				mount->fsi->_unlink( mount->psvInstance, filename );
				okay = 0;
			}
#ifdef UNICODE
			Deallocate( char *, _filename );
#  undef filename
#endif
		}
		else
		{
			TEXTSTR tmp = PrependBasePath( group, NULL, filename );
#ifdef WIN32
			okay = DeleteFile(tmp);
#else
#  ifdef UNICODE
			char *_filename = CStrDup( filename );
#    define filename _filename
#  endif
			okay = unlink( filename );
#  ifdef UNICODE
			Deallocate( char *, _filename );
#    undef filename
#  endif
#endif
			Deallocate( TEXTCHAR*, tmp );
		}
		if( !okay )
			return !okay;
		mount = mount->next;
	}
	return 0;
}
//----------------------------------------------------------------------------
int sack_unlink( INDEX group, CTEXTSTR filename )
{
	return sack_unlinkEx( group, filename, (*winfile_local).mounted_file_systems );
}
//----------------------------------------------------------------------------
int sack_rmdir( INDEX group, CTEXTSTR filename )
{
#ifdef __LINUX__
	int okay;
	TEXTSTR tmp = PrependBasePath( group, NULL, filename );
#ifdef UNICODE
	char *tmpname = CStrDup( tmp );
	okay = rmdir( tmpname );
	Deallocate( char*, tmpname );
#else
	okay = rmdir( filename );
#endif
	Deallocate( TEXTCHAR*, tmp );
 // unlink returns TRUE is 0, else error...
	return !okay;
#else
	int okay;
	TEXTSTR tmp = PrependBasePath( group, NULL, filename );
	okay = RemoveDirectory(tmp);
	Deallocate( TEXTCHAR*, tmp );
 // unlink returns TRUE is 0, else error...
	return !okay;
#endif
}
#undef open
#undef fopen
//----------------------------------------------------------------------------
FILE * sack_fopenEx( INDEX group, CTEXTSTR filename, CTEXTSTR opts, struct file_system_mounted_interface *mount )
{
	FILE *handle = NULL;
	struct file *file;
	INDEX idx;
	LOGICAL memalloc = FALSE;
	LOGICAL single_mount = (mount != NULL );
	LocalInit();
	EnterCriticalSec( &(*winfile_local).cs_files );
	if( !mount )
		mount = (*winfile_local).mounted_file_systems;
	if( !StrChr( opts, 'r' ) && !StrChr( opts, '+' ) )
		while( mount )
  // skip roms...
		{
			//lprintf( "check mount %p %d", mount, mount->writeable );
			if( mount->writeable )
				break;
			mount = mount->next;
		}
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE("open %s %p(%s) %s (%d)"), filename, mount, mount->name, opts, mount?mount->writeable:1 );
#endif
	LIST_FORALL( (*winfile_local).files, idx, struct file *, file )
	{
		if( ( file->group == group )
			&& ( StrCmp( file->name, filename ) == 0 )
			&& ( file->mount == mount ) )
		{
			break;
		}
	}
	LeaveCriticalSec( &(*winfile_local).cs_files );
	if( !file )
	{
		TEXTSTR tmpname = NULL;
		struct Group *filegroup = (struct Group *)GetLink( &(*winfile_local).groups, group );
		file = New( struct file );
		memalloc = TRUE;
		DecodeFopenOpts( file, opts );
		if( StrChr( filename, '%' ) )
		{
			tmpname = ExpandPathVariable( filename );
			filename = tmpname;
		}
		if( (filename[0] == '@') || (filename[0] == '*') || (filename[0] == '~') )
		{
			tmpname = ExpandPathEx( filename, NULL );
			filename = tmpname;
		}
		file->handles = NULL;
		file->files = NULL;
		file->name = StrDup( filename );
		file->mount = mount;
		if( ( !file->mount || !file->mount->fsi ) && !IsAbsolutePath( filename ) )
		{
			tmpname = ExpandPath( filename );
			file->fullname = PrependBasePath( group, filegroup, tmpname );
			Deallocate( TEXTCHAR*, tmpname );
		}
		else
		{
			if( mount && group == 0 )
			{
				file->fullname = StrDup( file->name );
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
				if( (*winfile_local).flags.bLogOpenClose )
					lprintf( WIDE("full is %s"), file->fullname );
#endif
			}
			else
			{
				file->fullname = PrependBasePathEx( group, filegroup, file->name, !mount );
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
				if( (*winfile_local).flags.bLogOpenClose )
					lprintf( WIDE("full is %s %d"), file->fullname, (int)group );
#endif
			}
			//file->fullname = file->name;
		}
		file->group = group;
		if( (file->fullname[0] == '@') || (file->fullname[0] == '*') || (file->fullname[0] == '~') )
		{
			TEXTSTR tmpname = ExpandPathEx( file->fullname, NULL );
			Deallocate( TEXTSTR, file->fullname );
			file->fullname = tmpname;
		}
		if( StrChr( file->fullname, '%' ) )
		{
			if( memalloc )
			{
				DeleteLink( &(*winfile_local).files, file );
				Deallocate( TEXTCHAR*, file->name );
				Deallocate( TEXTCHAR*, file->fullname );
				Deallocate( struct file *, file );
			}
			//DebugBreak();
			return NULL;
		}
		EnterCriticalSec( &(*winfile_local).cs_files );
		AddLink( &(*winfile_local).files,file );
		LeaveCriticalSec( &(*winfile_local).cs_files );
	}
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "Open File: [%s]" ), file->fullname );
#endif
	if( mount && mount->fsi )
	{
		if( StrChr( opts, 'r' ) && !StrChr( opts, '+' ) )
		{
			struct file_system_mounted_interface *test_mount = mount;
			while( !handle && test_mount )
			{
				if( test_mount->fsi )
				{
#if UNICODE
					char *_fullname = CStrDup( file->fullname );
#else
#  define _fullname file->fullname
#endif
					file->mount = test_mount;
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
					if( (*winfile_local).flags.bLogOpenClose )
						lprintf( WIDE("Call mount %s to check if file exists %s"), test_mount->name, file->fullname );
#endif
					if( test_mount->fsi->exists( test_mount->psvInstance, _fullname ) )
					{
						handle = (FILE*)test_mount->fsi->open( test_mount->psvInstance, _fullname, opts );
					}
					else if( single_mount )
					{
#if UNICODE
						Deallocate( char *, _fullname );
#else
#  undef _fullname
#endif
						return NULL;
					}
#if UNICODE
					Deallocate( char *, _fullname );
#endif
				}
				else
					goto default_fopen;
				test_mount = test_mount->next;
			}
		}
		else
		{
			struct file_system_mounted_interface *test_mount = mount;
			//lprintf( "full is %s", file->fullname );
			while( !handle && test_mount )
			{
				file->mount = test_mount;
				if( test_mount->fsi && test_mount->writeable )
				{
#ifdef UNICODE
					char* _fullname = CStrDup( file->fullname );
#else
#  define _fullname file->fullname
#endif
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
					if( (*winfile_local).flags.bLogOpenClose )
						lprintf( WIDE("Call mount %s to open file %s"), test_mount->name, file->fullname );
#endif
					handle = (FILE*)test_mount->fsi->open( test_mount->psvInstance, _fullname, opts );
#ifdef UNICODE
					Deallocate( char*, _fullname );
#else
#  undef _fullname
#endif
				}
				else
					goto default_fopen;
				test_mount = test_mount->next;
			}
		}
	}
	if( !handle )
	{
default_fopen:
		//file->mount = NULL;
#ifdef __LINUX__
#  ifdef UNICODE
		char *tmpname = CStrDup( file->fullname );
		char *tmpopts = CStrDup( opts );
		handle = fopen( tmpname, tmpopts );
		Deallocate( char*, tmpname );
		Deallocate( char*, tmpopts );
#  else
		handle = fopen( file->fullname, opts );
#  endif
#else
#  ifdef _STRSAFE_H_INCLUDED_
#    ifdef UNICODE
		char *tmpname = CStrDup( file->fullname );
		char *tmpopts = CStrDup( opts );
		fopen_s( &handle, tmpname, tmpopts );
		Deallocate( char*, tmpname );
		Deallocate( char*, tmpopts );
#    else
		{
			wchar_t *tmp = CharWConvert( file->fullname );
			wchar_t *wopts = CharWConvert( opts );
			handle = _wfopen( tmp, wopts );
			//_wfopen_s( &handle, tmp, wopts );
			Deallocate( wchar_t *, tmp );
			Deallocate( wchar_t *, wopts );
		}
#    endif
#  else
		handle = fopen( file->fullname, opts );
#  endif
#endif
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf( WIDE("native opened %s"), file->fullname );
#endif
	}
	if( !handle )
	{
		DeleteLink( &(*winfile_local).files, file );
		Deallocate( TEXTCHAR*, file->name );
		Deallocate( TEXTCHAR*, file->fullname );
		Deallocate( struct file*, file );
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf( WIDE( "Failed to open file [%s]=[%s]" ), file->name, file->fullname );
#endif
		return NULL;
	}
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "sack_open %s (%s)" ), file->fullname, opts );
#endif
	AddLink( &file->files, handle );
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "Added FILE* %p and list is %p" ), handle, file->files );
#endif
	return handle;
}
//----------------------------------------------------------------------------
FILE*  sack_fopen ( INDEX group, CTEXTSTR filename, CTEXTSTR opts )
{
	return sack_fopenEx( group, filename, opts, NULL );
}
//----------------------------------------------------------------------------
FILE*  sack_fsopenEx( INDEX group
					 , CTEXTSTR filename
					 , CTEXTSTR opts
					 , int share_mode
					 , struct file_system_mounted_interface *mount )
{
	FILE *handle = NULL;
	struct file *file;
	INDEX idx;
	LOGICAL single_mount = ( mount != NULL );
	LocalInit();
	EnterCriticalSec( &(*winfile_local).cs_files );
	if( !mount )
		mount = (*winfile_local).mounted_file_systems;
	if( !StrChr( opts, 'r' ) && !StrChr( opts, '+' ) )
		while( mount )
  // skip roms...
		{
			//lprintf( "check mount %p %d", mount, mount->writeable );
			if( mount->writeable )
				break;
			mount = mount->next;
		}
	LIST_FORALL( (*winfile_local).files, idx, struct file *, file )
	{
		if( ( file->group == group )
			&& ( StrCmp( file->name, filename ) == 0 )
			&& ( file->mount == mount ) )
		{
			break;
		}
	}
	LeaveCriticalSec( &(*winfile_local).cs_files );
	if( !file )
	{
		struct Group *filegroup = (struct Group *)GetLink( &(*winfile_local).groups, group );
		file = New( struct file );
      DecodeFopenOpts( file, opts );
		file->handles = NULL;
		file->files = NULL;
		file->name = StrDup( filename );
		file->group = group;
		file->mount = mount;
		if( !mount || !mount->fsi )
			file->fullname = PrependBasePath( group, filegroup, filename );
		else
			file->fullname = StrDup( filename );
		EnterCriticalSec( &(*winfile_local).cs_files );
		AddLink( &(*winfile_local).files,file );
		LeaveCriticalSec( &(*winfile_local).cs_files );
	}
	if( mount && mount->fsi )
	{
		if( StrChr( opts, 'r' ) && !StrChr( opts, '+' ) )
		{
			struct file_system_mounted_interface *test_mount = mount;
			while( !handle && test_mount && test_mount->fsi )
			{
#ifdef UNICODE
				char *_fullname = CStrDup( file->fullname );
#else
#  define _fullname file->fullname
#endif
				file->mount = test_mount;
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
				if( (*winfile_local).flags.bLogOpenClose )
					lprintf( WIDE("Call mount %s to check if file exists %s"), test_mount->name, file->fullname );
#endif
				if( test_mount->fsi->exists( test_mount->psvInstance, _fullname ) )
				{
					handle = (FILE*)test_mount->fsi->open( test_mount->psvInstance, _fullname, opts );
				}
#ifdef UNICODE
				Deallocate( char *, _fullname );
#else
#  undef _fullname
#endif
				if( !handle && single_mount )
				{
					return NULL;
				}
				test_mount = test_mount->next;
			}
		}
		else
		{
			struct file_system_mounted_interface *test_mount = mount;
			//lprintf( "full is %s", file->fullname );
			while( !handle && test_mount )
			{
				file->mount = test_mount;
				if( test_mount->fsi && test_mount->writeable )
				{
#ifdef UNICODE
					char* _fullname = CStrDup( file->fullname );
#else
#  define _fullname file->fullname
#endif
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
					if( (*winfile_local).flags.bLogOpenClose )
						lprintf( WIDE("Call mount %s to open file %s"), test_mount->name, file->fullname );
#endif
					handle = (FILE*)test_mount->fsi->open( test_mount->psvInstance, _fullname, opts );
#ifdef UNICODE
					Deallocate( char*, _fullname );
#else
#  undef _fullname
#endif
				}
				else
					goto default_fopen;
				test_mount = test_mount->next;
			}
		}
			//file->fsi = mount?mount->fsi:NULL;
	}
	if( !handle )
	{
default_fopen:
#ifdef __LINUX__
#  ifdef UNICODE
		char *tmpname = CStrDup( file->fullname );
		char *tmpopts = CStrDup( opts );
		handle = fopen( tmpname, tmpopts );
		Deallocate( char*, tmpname );
		Deallocate( char*, tmpopts );
#  else
		handle = fopen( file->fullname, opts );
#  endif
#else
		{
			wchar_t *tmp = CharWConvert( file->fullname );
			wchar_t *wopts = CharWConvert( opts );
			handle = _wfsopen( tmp, wopts, share_mode );
			Deallocate( wchar_t *, tmp );
			Deallocate( wchar_t *, wopts );
		}
#endif
	}
	if( !handle )
	{
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf( WIDE( "Failed to open file [%s]=[%s]" ), file->name, file->fullname );
#endif
		return NULL;
	}
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "sack_open %s (%s)" ), file->fullname, opts );
#endif
	EnterCriticalSec( &(*winfile_local).cs_files );
	AddLink( &file->files, handle );
	LeaveCriticalSec( &(*winfile_local).cs_files );
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "Added FILE* %p and list is %p" ), handle, file->files );
#endif
	return handle;
}
//----------------------------------------------------------------------------
FILE*  sack_fsopen( INDEX group, CTEXTSTR filename, CTEXTSTR opts, int share_mode )
{
/*(*winfile_local).mounted_file_systems*/
	return sack_fsopenEx( group, filename, opts, share_mode, NULL );
}
//----------------------------------------------------------------------------
static size_t sack_fsizeEx ( FILE *file_file, struct file_system_mounted_interface *mount )
{
	if( mount && mount->fsi )
		return mount->fsi->size( file_file );
	{
		size_t here = ftell( file_file );
		size_t length;
		fseek( file_file, 0, SEEK_END );
		length = ftell( file_file );
		fseek( file_file, (long)here, SEEK_SET );
		return length;
	}
}
size_t sack_fsize ( FILE *file_file ) {
	struct file *file;
	file = FindFileByFILE( file_file );
	return sack_fsizeEx( file_file, file?file->mount:NULL );
}
static size_t sack_ftellEx ( FILE *file_file, struct file_system_mounted_interface *mount )
{
	if( mount && mount->fsi )
		return mount->fsi->tell( file_file );
	return ftell( file_file );
}
size_t sack_ftell ( FILE *file_file ) {
	struct file *file;
	file = FindFileByFILE( file_file );
	if( file && file->mount && file->mount->fsi )
		return sack_ftellEx(  file_file, file->mount );
	return sack_ftellEx( file_file, NULL );
}
size_t  sack_fseekEx ( FILE *file_file, size_t pos, int whence, struct file_system_mounted_interface *mount )
{
	if( mount && mount->fsi )
	{
		return mount->fsi->seek( file_file, pos, whence );
	}
	if( fseek( file_file, (long)pos, whence ) )
		return -1;
	//struct file *file = FindFileByFILE( file_file );
	return ftell( file_file );
}
size_t  sack_fseek ( FILE *file_file, size_t pos, int whence ){
	struct file *file;
	file = FindFileByFILE( file_file );
	if( file && file->mount && file->mount->fsi )
		return sack_fseekEx( file_file, pos, whence, file->mount );
	return sack_fseekEx( file_file, pos, whence, NULL );
}
static int  sack_fflushEx ( FILE *file_file, struct file_system_mounted_interface *mount )
{
	if( mount && mount->fsi )
	{
		return mount->fsi->flush( file_file );
		//DeleteLink( &file->files, file_file );
		//file->fsi->close( file_file );
		//file_file = (FILE*)file->fsi->open( file->fullname );
		//AddLink( &file->files, file_file );
		//return 0;
	}
	return fflush( file_file );
}
int  sack_fflush ( FILE *file_file )
{
	struct file *file;
	file = FindFileByFILE( file_file );
	if( file && file->mount && file->mount->fsi )
	{
		return sack_fflushEx( file_file, file->mount );
	}
	return fflush( file_file );
}
//----------------------------------------------------------------------------
int  sack_fclose ( FILE *file_file )
{
	struct file *file;
	EnterCriticalSec( &(*winfile_local).cs_files );
	file = FindFileByFILE( file_file );
	if( file )
	{
		int status;
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf( WIDE("Closing %s"), file->fullname );
#endif
		if( file->mount && file->mount->fsi )
			status = file->mount->fsi->_close( file_file );
		else
			status = fclose( file_file );
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf( WIDE( "deleted FILE* %p and list is %p" ), file_file, file->files );
#endif
		DeleteLink( &file->files, file_file );
		if( !GetLinkCount( file->files ) ) {
			DeleteLink( &(*winfile_local).files, file );
			LeaveCriticalSec( &(*winfile_local).cs_files );
			DeleteListEx( &file->files DBG_SRC );
			Deallocate( TEXTCHAR*, file->name );
			Deallocate( TEXTCHAR*, file->fullname );
			Deallocate( struct file*, file );
		}
		else
			LeaveCriticalSec( &(*winfile_local).cs_files );
		return status;
	}
	LeaveCriticalSec( &(*winfile_local).cs_files );
	return fclose( file_file );
}
//----------------------------------------------------------------------------
static void transcodeOutputText( struct file *file, POINTER buffer, size_t size, POINTER *outbuf, size_t *outsize ) {
}
//----------------------------------------------------------------------------
static void transcodeInputText( struct file *file, POINTER buffer, size_t size, POINTER *outbuf, size_t *outsize ) {
}
//----------------------------------------------------------------------------
size_t  sack_fread ( POINTER buffer, size_t size, int count,FILE *file_file )
{
	struct file *file;
	file = FindFileByFILE( file_file );
	if( file->mount && file->mount->fsi )
		return file->mount->fsi->_read( file_file, (char*)buffer, size * count );
	return fread( buffer, size, count, file_file );
}
//----------------------------------------------------------------------------
size_t  sack_fwrite ( CPOINTER buffer, size_t size, int count,FILE *file_file )
{
	struct file *file;
	file = FindFileByFILE( file_file );
	if( file && file->mount && file->mount->fsi )
	{
		size_t result;
		if( file->mount->fsi->copy_write_buffer && file->mount->fsi->copy_write_buffer() )
		{
			POINTER dupbuf = malloc( size*count + 3 );
			memcpy( dupbuf, buffer, size*count );
			result = file->mount->fsi->_write( file_file, (const char*)dupbuf, size * count );
			free( dupbuf );
		}
		else
			result = file->mount->fsi->_write( file_file, (const char*)buffer, size * count );
		return result;
	}
	return fwrite( (POINTER)buffer, size, count, file_file );
}
//----------------------------------------------------------------------------
TEXTSTR sack_fgets ( TEXTSTR buffer, size_t size,FILE *file_file )
{
#ifdef _UNICODE
	//char *tmpbuf = NewArray( char, size+1);
	//TEXTSTR tmp_wbuf;
	fgets( (char*)buffer, size, file_file );
	//tmp_wbuf = CharWConvert( tmpbuf );
	//StrCpyEx( buffer, tmp_wbuf, size );
	return buffer;
#else
	struct file *file;
	file = FindFileByFILE( file_file );
	if( file && file->mount && file->mount->fsi )
	{
		size_t n;
		char *output = buffer;
		size = size-1;
		buffer[size] = 0;
		for( n = 0; n < size; n++ )
		{
			if( file->mount->fsi->_read( file_file, output, 1 ) )
			{
				if( output[0] == '\n' )
				{
					output[1] = 0;
					break;
				}
				output++;
			}
			else
			{
				output[0] = 0;
				break;
			}
		}
		if( n )
			return buffer;
		return NULL;
	}
	return fgets( buffer, (int)size, file_file );
#endif
}
//----------------------------------------------------------------------------
LOGICAL sack_existsEx ( const char *filename, struct file_system_mounted_interface *fsi )
{
	FILE *tmp;
	if( fsi && fsi->fsi && fsi->fsi->exists )
	{
		int result = fsi->fsi->exists( fsi->psvInstance, filename );
		return result;
	}
	else if( ( tmp = fopen( filename, "rb" ) ) )
	{
		fclose( tmp );
		return TRUE;
	}
	return FALSE;
}
//----------------------------------------------------------------------------
LOGICAL sack_exists( const char * filename )
{
	struct file_system_mounted_interface *mount = (*winfile_local).mounted_file_systems;
	while( mount )
	{
		if( sack_existsEx( filename, mount ) )
		{
			(*winfile_local).last_find_mount = mount;
			return TRUE;
		}
		mount = mount->next;
	}
	return FALSE;
}
//----------------------------------------------------------------------------
LOGICAL sack_isPathEx ( const char *filename, struct file_system_mounted_interface *fsi )
{
	FILE *tmp;
	if( fsi && fsi->fsi && fsi->fsi->exists )
	{
		int result = fsi->fsi->is_directory( fsi->psvInstance, filename );
		return result;
	}
	else if( ( tmp = fopen( filename, "rb" ) ) )
	{
		fclose( tmp );
		return TRUE;
	}
	return FALSE;
}
//----------------------------------------------------------------------------
LOGICAL sack_isPath( const char * filename )
{
	struct file_system_mounted_interface *mount = (*winfile_local).mounted_file_systems;
	while( mount )
	{
		if( sack_isPathEx( filename, mount ) )
		{
			(*winfile_local).last_find_mount = mount;
			return TRUE;
		}
		mount = mount->next;
	}
	return FALSE;
}
//----------------------------------------------------------------------------
int  sack_renameEx ( CTEXTSTR file_source, CTEXTSTR new_name, struct file_system_mounted_interface *mount )
{
	int status;
	if( mount && mount->fsi )
	{
		return mount->fsi->rename( mount->psvInstance, file_source, new_name );
	}
	else
	{
		TEXTSTR tmp_src = ExpandPath( file_source );
		TEXTSTR tmp_dst = ExpandPath( new_name );
#ifdef WIN32
		status = MoveFile( tmp_src, tmp_dst );
#else
#  ifdef UNICODE
		{
			char *tmpnames = CStrDup( tmp_src );
			char *tmpnamed = CStrDup( tmp_dst );
			status = rename( tmpnames, tmpnamed );
			Deallocate( char*, tmpnames );
			Deallocate( char*, tmpnamed );
		}
#  else
		status = rename( tmp_src, tmp_dst );
#  endif
#endif
		Deallocate( TEXTSTR, tmp_src );
		Deallocate( TEXTSTR, tmp_dst );
	}
	return status;
}
//----------------------------------------------------------------------------
int  sack_rename( CTEXTSTR file_source, CTEXTSTR new_name )
{
	return sack_renameEx( file_source, new_name, (*winfile_local).default_mount );
}
//----------------------------------------------------------------------------
size_t GetSizeofFile( TEXTCHAR *name, uint32_t* unused )
{
	size_t size;
#ifdef __LINUX__
#  ifdef UNICODE
	char *tmpname = CStrDup( name );
		  // open MYFILE.TXT
	int hFile = open( tmpname,
			 // open for reading
						  O_RDONLY );
	Deallocate( char*, tmpname );
#  else
		  // open MYFILE.TXT
	int hFile = open( name,
			 // open for reading
						  O_RDONLY );
#  endif
	if( hFile >= 0 )
	{
		size = lseek( hFile, 0, SEEK_END );
		close( hFile );
		return size;
	}
	else
		return 0;
#else
	HANDLE hFile = CreateFile( name, 0, 0, NULL, OPEN_EXISTING, 0, NULL );
	if( hFile != INVALID_HANDLE_VALUE )
	{
		size = GetFileSize( hFile, (DWORD*)unused );
		if( sizeof( size ) > 4  && unused )
			size |= (uint64_t)(*unused) << 32;
		CloseHandle( hFile );
		return size;
	}
	else
		return (size_t)-1;
#endif
}
//-------------------------------------------------------------------------
uint32_t GetFileTimeAndSize( CTEXTSTR name
							, LPFILETIME lpCreationTime
							,  LPFILETIME lpLastAccessTime
							,  LPFILETIME lpLastWriteTime
							, int *IsDirectory
							)
{
	uint32_t size;
#ifdef __LINUX__
#  ifdef UNICODE
	char *tmpname = CStrDup( name );
		  // open MYFILE.TXT
	int hFile = open( tmpname,
			 // open for reading
						  O_RDONLY );
	Deallocate( char*, tmpname );
#  else
		  // open MYFILE.TXT
	int hFile = open( name,
			 // open for reading
						  O_RDONLY );
#  endif
	if( hFile >= 0 )
	{
		size = lseek( hFile, 0, SEEK_END );
		close( hFile );
		return size;
	}
	else
		return (uint32_t)-1;
#else
	HANDLE hFile = CreateFile( name, 0, 0, NULL, OPEN_EXISTING, 0, NULL );
	uint32_t extra_size;
	if( hFile != INVALID_HANDLE_VALUE )
	{
		size = GetFileSize( hFile, (DWORD*)&extra_size );
		GetFileTime( hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime );
		if( IsDirectory )
		{
			uint32_t dwAttr = GetFileAttributes( name );
			if( dwAttr & FILE_ATTRIBUTE_DIRECTORY )
				(*IsDirectory) = 1;
			else
				(*IsDirectory) = 0;
		}
		CloseHandle( hFile );
		return size;
	}
	else
		return (uint32_t)-1;
#endif
}
struct file_system_interface *sack_get_filesystem_interface( CTEXTSTR name )
{
	struct file_interface_tracker *fit;
	INDEX idx;
	LIST_FORALL( (*winfile_local).file_system_interface, idx, struct file_interface_tracker *, fit )
	{
		if( StrCaseCmp( fit->name, name ) == 0 )
			return fit->fsi;
	}
	return NULL;
}
void sack_set_default_filesystem_interface( struct file_system_interface *fsi )
{
	(*winfile_local).default_file_system_interface = fsi;
}
void sack_register_filesystem_interface( CTEXTSTR name, struct file_system_interface *fsi )
{
	struct file_interface_tracker *fit = New( struct file_interface_tracker );
	fit->name = StrDup( name );
	fit->fsi = fsi;
	LocalInit();
	AddLink( &(*winfile_local).file_system_interface, fit );
}
static void * CPROC sack_filesys_open( uintptr_t psv, const char *filename, const char *opts );
static int CPROC sack_filesys_close( void*file ) { return fclose(  (FILE*)file ); }
static size_t CPROC sack_filesys_read( void*file, char*buf, size_t len ) { return fread( buf, 1, len, (FILE*)file ); }
static size_t CPROC sack_filesys_write( void*file, const char*buf, size_t len ) { return fwrite( buf, 1, len, (FILE*)file ); }
static size_t CPROC sack_filesys_seek( void*file, size_t pos, int whence ) { return fseek( (FILE*)file, (long)pos, whence ), ftell( (FILE*)file ); }
static int CPROC sack_filesys_unlink( uintptr_t psv, const char*filename ) {
	int okay = 0;
#ifdef UNICODE
	TEXTCHAR *_filename = DupCStr( filename );
#  define filename _filename
#endif
#ifdef WIN32
	okay = DeleteFileA( filename );
#else
	okay = unlink( filename );
#endif
#ifdef UNICODE
	Deallocate( char *, _filename );
#  undef filename
#endif
	return okay;
}
static size_t CPROC sack_filesys_size( void*file ) {
	size_t here = ftell( (FILE*)file );
	size_t length;
	fseek( (FILE*)file, 0, SEEK_END );
	length = ftell( (FILE*)file );
	fseek( (FILE*)file, (long)here, SEEK_SET );
	return length;
}
static size_t CPROC sack_filesys_tell( void*file ) { return ftell( (FILE*)file ); }
static void CPROC sack_filesys_truncate( void*file ) {
#if _WIN32
	_chsize
#else
		ftruncate
#endif
		( fileno( (FILE*)file), ftell((FILE*)file) ); }
static int CPROC sack_filesys_flush( void*file ) { return fflush( (FILE*)file ); }
static int CPROC sack_filesys_exists( uintptr_t psv, const char*file );
static LOGICAL CPROC sack_filesys_rename( uintptr_t psvInstance, const char *original_name, const char *new_name );
static LOGICAL CPROC sack_filesys_copy_write_buffer( void ) { return FALSE; }
struct find_cursor_data {
	char *root;
	char *filemask;
	char *mask;
#ifdef WIN32
	intptr_t findHandle;
	struct _finddata_t fileinfo;
#else
	DIR* handle;
	struct dirent *de;
#endif
};
static	struct find_cursor * CPROC sack_filesys_find_create_cursor ( uintptr_t psvInstance, const char *root, const char *filemask ){
	struct find_cursor_data *cursor = New( struct find_cursor_data );
	char maskbuf[512];
	MemSet( cursor, 0, sizeof( *cursor ) );
	//snprintf( maskbuf, 512, "%s/%s", root ? root : ".", filemask?filemask:"*" );
	snprintf( maskbuf, 512, "%s/%s", root ? root : ".", "*" );
	cursor->mask = StrDup( filemask );
	cursor->root = StrDup( root?root:"." );
// StrDup( filemask ? filemask : "*" );
	cursor->filemask = ExpandPath( maskbuf );
#ifdef WIN32
   // windows mode is delayed until findfirst
#else
	cursor->handle = opendir( root );
#endif
	return (struct find_cursor *)cursor;
}
static	int CPROC sack_filesys_find_first( struct find_cursor *_cursor ){
	struct find_cursor_data *cursor = (struct find_cursor_data *)_cursor;
#ifdef WIN32
	cursor->findHandle = findfirst( cursor->filemask, &cursor->fileinfo );
	if( cursor->findHandle == -1 )
	{
		int err = errno;
		lprintf( "error:%d", err );
	}
	return ( cursor->findHandle != -1 );
#else
	if( cursor->handle ) {
		do {
			cursor->de = readdir( cursor->handle );
		} while( cursor->de && !CompareMask( cursor->mask, cursor->de->d_name, 0 ) );
		return ( cursor->de != NULL );
	}
	return 0;
#endif
}
static	int CPROC sack_filesys_find_close( struct find_cursor *_cursor ){
	struct find_cursor_data *cursor = (struct find_cursor_data *)_cursor;
#ifdef WIN32
	findclose( cursor->findHandle );
#else
	if( cursor->handle )
		closedir( cursor->handle );
#endif
	Deallocate( char *, cursor->root );
	Deallocate( char *, cursor->mask );
	Deallocate( char *, cursor->filemask );
	Deallocate( struct find_cursor_data *, cursor );
	return 0;
}
static	int CPROC sack_filesys_find_next( struct find_cursor *_cursor ){
   int r;
   struct find_cursor_data *cursor = (struct find_cursor_data *)_cursor;
#ifdef WIN32
   r = !findnext( cursor->findHandle, &cursor->fileinfo );
#else
	do {
		cursor->de = readdir( cursor->handle );
	} while( cursor->de && !CompareMask( cursor->mask, cursor->de->d_name, 0 ) );
   r = (cursor->de != NULL );
#endif
   return r;
}
static	char * CPROC sack_filesys_find_get_name( struct find_cursor *_cursor ){
   struct find_cursor_data *cursor = (struct find_cursor_data *)_cursor;
#ifdef WIN32
#   ifdef UNDER_CE
	return cursor->fileinfo.cFileName;
#   else
	return cursor->fileinfo.name;
#   endif
#else
   return cursor->de->d_name;
#endif
}
static	size_t CPROC sack_filesys_find_get_size( struct find_cursor *_cursor ) {
	struct find_cursor_data *cursor = (struct find_cursor_data *)_cursor;
#ifdef WIN32
	if( cursor )
		return cursor->fileinfo.size;
	return 0;
#else
	if( cursor ) {
		struct stat s;
		char filename[280];
		snprintf( filename, 280, "%s/%s", cursor->root, cursor->de->d_name );
		if( stat( filename, &s ) ) {
			lprintf( "getsize stat error:%d", errno );
			return -2;
		}
		if( s.st_mode & S_IFREG )
			return s.st_size;
		return -1;
	}
#endif
	return 0;
}
static	LOGICAL CPROC sack_filesys_find_is_directory( struct find_cursor *_cursor ){
	struct find_cursor_data *cursor = (struct find_cursor_data *)_cursor;
#ifdef WIN32
#  ifdef UNDER_CE
	return ( cursor->fileinfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
#  else
	return (cursor->fileinfo.attrib & _A_SUBDIR );
#  endif
#else
	char buffer[MAX_PATH_NAME];
	snprintf( buffer, MAX_PATH_NAME, WIDE("%s%s%s"), cursor->root, cursor->root[0]?"/":"", cursor->de->d_name );
	return IsPath( buffer );
#endif
}
static	LOGICAL CPROC sack_filesys_is_directory( uintptr_t psvInstance, const char *buffer ){
	return IsPath( buffer );
}
static struct file_system_interface native_fsi = {
	sack_filesys_open
		, sack_filesys_close
		, sack_filesys_read
		, sack_filesys_write
		, sack_filesys_seek
		, sack_filesys_truncate
		, sack_filesys_unlink
		, sack_filesys_size
		, sack_filesys_tell
		, sack_filesys_flush
		, sack_filesys_exists
		, sack_filesys_copy_write_buffer
  //( uintptr_t psvInstance, const char *root, const char *filemask );
		, sack_filesys_find_create_cursor
		, sack_filesys_find_first
		, sack_filesys_find_close
		, sack_filesys_find_next
		, sack_filesys_find_get_name
		, sack_filesys_find_get_size
																 , sack_filesys_find_is_directory
																 , sack_filesys_is_directory
 // rename
                                                 , sack_filesys_rename
} ;
PRIORITY_PRELOAD( InitWinFileSysEarly, OSALOT_PRELOAD_PRIORITY - 1 )
{
	LocalInit();
	if( !sack_get_filesystem_interface( WIDE("native") ) )
		sack_register_filesystem_interface( WIDE("native" ), &native_fsi );
	if( !(*winfile_local).default_mount )
		(*winfile_local).default_mount = sack_mount_filesystem( "native", &native_fsi, 1000, (uintptr_t)NULL, TRUE );
}
#if !defined( __NO_OPTIONS__ )
PRELOAD( InitWinFileSys )
{
#  if !defined( __FILESYS_NO_FILE_LOGGING__ )
	(*winfile_local).flags.bLogOpenClose = SACK_GetProfileIntEx( WIDE( "SACK/filesys" ), WIDE( "Log open and close" ), (*winfile_local).flags.bLogOpenClose, TRUE );
#  endif
}
#endif
static void * CPROC sack_filesys_open( uintptr_t psv, const char *filename, const char *opts ) {
	void *result;
#ifdef UNICODE
	TEXTCHAR *_filename = DupCStr( filename );
#  define filename _filename
#endif
	result = fopen( filename, opts );
#ifdef UNICODE
	Deallocate( TEXTCHAR *, _filename );
#  undef filename
#endif
	return result;
}
static int CPROC sack_filesys_exists( uintptr_t psv, const char *filename ) {
	int result;
#ifdef UNICODE
	TEXTSTR _filename = DupCStr( filename );
#define filename _filename
#endif
//(*winfile_local).default_mount );
	result = sack_existsEx( filename, NULL );
#ifdef UNICODE
	Deallocate( TEXTSTR, _filename );
#undef filename
#endif
	return result;
}
struct file_system_mounted_interface *sack_get_default_mount( void ) { return (*winfile_local).default_mount; }
struct file_system_mounted_interface *sack_get_mounted_filesystem( const char *name )
{
	struct file_system_mounted_interface *root = (*winfile_local).mounted_file_systems;
	while( root )
	{
		if( root->name ) if( stricmp( root->name, name ) == 0 ) break;
		root = NextThing( root );
	}
	return root;
}
void sack_unmount_filesystem( struct file_system_mounted_interface *mount )
{
	UnlinkThing( mount );
}
LOGICAL CPROC sack_filesys_rename( uintptr_t psvInstance, const char *original_name, const char *new_name ){
	return sack_renameEx( original_name, new_name, NULL );
}
struct file_system_mounted_interface *sack_mount_filesystem( const char *name, struct file_system_interface *fsi, int priority, uintptr_t psvInstance, LOGICAL writable )
{
	struct file_system_mounted_interface *root = (*winfile_local).mounted_file_systems;
	struct file_system_mounted_interface *mount = New( struct file_system_mounted_interface );
	mount->name = name?strdup( name ):NULL;
	mount->priority = priority;
	mount->psvInstance = psvInstance;
	mount->writeable = writable;
	mount->fsi = fsi;
	//lprintf( "Create mount called %s ", name );
	if( !root || ( root->priority >= priority ) )
	{
		if( !root || root == (*winfile_local).mounted_file_systems )
		{
			LinkThing( (*winfile_local).mounted_file_systems, mount );
		}
		else
		{
			LinkThingBefore( root, mount );
		}
	}
	else while( root )
	{
		if( root->priority >= priority )
		{
			LinkThingBefore( root, mount );
			break;
		}
		if( !NextThing( root ) )
		{
			LinkThingAfter( root, mount );
			break;
		}
		root = NextThing( root );
	}
	return mount;
}
int sack_vfprintf( FILE *file_handle, const char *format, va_list args )
{
	struct file *file;
	file = FindFileByFILE( file_handle );
	if( file->mount && file->mount->fsi )
	{
		PVARTEXT pvt;
		PTEXT output;
		int r;
#ifdef UNICODE
		TEXTCHAR *_format = DupCStr( format );
#define format _format
#endif
		pvt = VarTextCreate();
		vvtprintf( pvt, format, args );
		output = VarTextPeek( pvt );
#ifdef UNICODE
		Deallocate( TEXTCHAR*, _format );
#  undef format
#endif
		r = (int)file->mount->fsi->_write( file_handle, (char*)GetText( output ), GetTextSize( output ) * sizeof( TEXTCHAR ) );
		VarTextDestroy( &pvt );
		return r;
	}
	else
		return vfprintf( file_handle, format, args );
}
int sack_fprintf( FILE *file, const char *format, ... )
{
	va_list args;
	va_start( args, format );
	return sack_vfprintf( file, format, args );
}
int sack_fputs( const char *format,FILE *file )
{
	if( format )
	{
		size_t len = strlen( format );
		return (int)( sack_fwrite( format, 1, (int)len, file ) & 0x7FFFFFFF );
	}
	return 0;
}
FILESYS_NAMESPACE_END
#define NO_UNICODE_C
#ifdef _MSC_VER
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif
#endif
#if defined( _WIN32 ) && !defined( __TURBOC__ )
 // windows lean_and_mean
#ifndef UNDER_CE
  // findfirst,findnext, fileinfo
#endif
#else
 // opendir etc..
#endif
FILESYS_NAMESPACE
#ifndef MAX_PATH_NAME
#  define MAX_PATH_NAME 512
#endif
// DEBUG_COMPARE 1 == full debug
// DEBUG_COMPARE 2 == quieter debug
#ifdef _DEBUG
#define DEBUG_COMPARE 5
#else
#define DEBUG_COMPARE 999
#endif
//--------------------------------------------------------------------------
 int  CompareMask ( CTEXTSTR mask, CTEXTSTR name, int keepcase )
{
	int m = 0, n = 0;
	int anymatch;
	int wasanymatch, wasmaskmatch;
	int matchone;
	TEXTCHAR namech, maskch;
	if( !mask )
		return 1;
	if( !name )
		return 0;
try_mask:
	anymatch = 0;
	wasanymatch = 0;
	wasmaskmatch = 0;
	matchone = 0;
#if ( DEBUG_COMPARE < 3 )
	lprintf( WIDE("Check %s vs %s"), mask + m, name );
#endif
	do
	{
		if( mask[m] == '\t' || mask[m] == '|' )
		{
			lprintf( WIDE("Found mask seperator - skipping to next mask :%s"), mask + m + 1 );
			n = 0;
			m++;
			continue;
		}
		while( mask[m] == '*' )
		{
			anymatch = 1;
			m++;
		}
		while( mask[m] == '?' )
		{
#if ( DEBUG_COMPARE < 2 )
         //Log( WIDE("Match any one character") );
#endif
			matchone++;
			m++;
		}
		if( !keepcase && name[n]>= 'a' && name[n] <= 'z' )
			namech = name[n] - ('a' - 'A');
		else if( name[n] == '/' )
			namech = '\\';
		else
			namech = name[n];
		if( !keepcase && mask[m]>= 'a' && mask[m] <= 'z' )
			maskch = mask[m] - ('a' - 'A');
		else if( mask[m] == '/' )
			maskch = '\\';
		else
			maskch = mask[m];
		if( matchone )
		{
			matchone--;
			n++;
		}
		else if(
#if ( DEBUG_COMPARE < 2 )
				  lprintf( WIDE("Check %c == %c?"), maskch, namech ),
#endif
				  maskch == namech )
		{
#if ( DEBUG_COMPARE < 2 )
			lprintf( WIDE(" yes.") );
#endif
			 if( anymatch )
			 {
				 wasanymatch = n+1;
				 wasmaskmatch = m+1;
				 anymatch = 0;
			}
			 n++;
			 m++;
		}
		else if(
#if ( DEBUG_COMPARE < 2 )
				  lprintf( WIDE(" no. Any match?") ),
#endif
				  anymatch )
		{
#if ( DEBUG_COMPARE < 2 )
			lprintf( WIDE(" yes"));
#endif
			n++;
		}
		else if(
#if ( DEBUG_COMPARE < 2 )
				  lprintf( WIDE(" No. wasanymatch?") ),
#endif
				  wasanymatch )
		{
#if ( DEBUG_COMPARE < 2 )
			lprintf( WIDE(" yes. reset to anymatch.") );
#endif
			n = wasanymatch - 1;
			m = wasmaskmatch - 1;
			anymatch = 1;
			n++;
		}
		else
		{
#if ( DEBUG_COMPARE < 2 )
			lprintf( WIDE(" No. match failed.") );
#endif
			break;
		}
	}while( name[n] );
	// 0 or more match a *
	// so auto match remaining *
	while( mask[m] && mask[m] == '*' )
		m++;
#if ( DEBUG_COMPARE < 3 )
	lprintf( WIDE("Skipping to next mask") );
#endif
	if( mask[m] &&
		 ( mask[m] != '\t' &&
			mask[m] != '|' ) )
	{
		int mask_m = m;
		while( mask[m] )
		{
			if( mask[m] == '\t' || mask[m] == '|' )
			{
				n = 0;
				m++;
				break;
			}
			m++;
		}
		if( mask[m] )
			goto try_mask;
		m = mask_m;
	}
	//lprintf( WIDE("Result: %d %c %d"), matchone, mask[m], name[n] );
	// match ???? will not match abc
	// a??? abc not match
	if( !matchone && (!mask[m] || mask[m] == '\t' || mask[m] == '|' ) && !name[n] )
		return 1;
	return  0;
}
//--------------------------------------------------------------------------
//---------------------------------------------------------------------------
typedef struct result_buffer
{
	TEXTSTR buffer;
	int len;
	int result_len;
} RESULT_BUFFER, *PRESULT_BUFFER;
static void CPROC MatchFile( uintptr_t psvUser, CTEXTSTR name, int flags )
{
	PRESULT_BUFFER buffer = (PRESULT_BUFFER)psvUser;
	buffer->result_len = tnprintf( buffer->buffer, buffer->len*sizeof(TEXTCHAR), WIDE("%s"), name );
}
int  GetMatchingFileName ( CTEXTSTR filemask, int flags, TEXTSTR pResult, int nResult )
{
	void *info = NULL;
	RESULT_BUFFER result_buf;
	result_buf.buffer = pResult;
	result_buf.len = nResult;
	result_buf.result_len = 0;
	// may need a while loop here...
	// but I'm just going to result the first matching anyhow.
	while( ScanFiles( NULL, filemask, &info, MatchFile, flags, (uintptr_t)&result_buf ) );
	return result_buf.result_len;
}
//---------------------------------------------------------------------------
#if defined( _WIN32 ) && !defined( __TURBOC__ )
#ifdef UNDER_CE
#define finddata_t WIN32_FIND_DATA
#define findfirst FindFirstFile
#define findnext  FindNextFile
#define findclose FindClose
#else
#  ifdef UNICODE
#define finddata_t _wfinddata_t
#define findfirst _wfindfirst
#define findnext  _wfindnext
#define findclose _findclose
#  else
#define finddata_t _finddata_t
#define findfirst _findfirst
#define findnext  _findnext
#define findclose _findclose
#  endif
#endif
#else
#endif
typedef struct myfinddata {
#ifdef WIN32
#  ifdef _MSC_VER
#define HANDLECAST intptr_t
	intptr_t
#  else
#define HANDLECAST int
	int
#  endif
#else
#  define HANDLECAST DIR*
	DIR*
#endif
		handle;
#  ifdef WIN32
#    ifdef UNDER_CE
	WIN32_FIND_DATA fd;
#    else
#      ifdef UNICODE
	struct _wfinddata_t fd;
#    else
	 struct finddata_t fd;
#    endif
#  endif
#endif
	struct find_cursor *cursor;
	INDEX scanning_interface_index;
	LOGICAL new_mount;
	LOGICAL single_mount;
	struct file_system_mounted_interface *scanning_mount;
	TEXTCHAR buffer[MAX_PATH_NAME];
	TEXTCHAR file_buffer[MAX_PATH_NAME];
	TEXTCHAR basename[MAX_PATH_NAME];
	TEXTCHAR findmask[MAX_PATH_NAME];
	struct myfinddata *current;
	struct myfinddata *prior;
	struct myfinddata **root_info;
} MFD, *PMFD;
#define findhandle(pInfo) ( ((PMFD)(*pInfo))->handle)
#define finddata(pInfo) ( &((PMFD)(*pInfo))->fd)
#define findbuffer(pInfo) ( ((PMFD)(*pInfo))->buffer)
#define findbasename(pInfo) ( ((PMFD)(*pInfo))->basename)
#define findmask(pInfo)     ( ((PMFD)(*pInfo))->findmask)
#define findinfo(pInfo)     (((PMFD)(*pInfo)))
#define findcursor(pInfo)     ( ((PMFD)(*pInfo))->cursor)
 int  ScanFilesEx ( CTEXTSTR base
           , CTEXTSTR mask
           , void **pInfo
           , void CPROC Process( uintptr_t psvUser, CTEXTSTR name, int flags )
           , int flags
           , uintptr_t psvUser
		   , LOGICAL begin_sub_path
		   , struct file_system_mounted_interface *mount
		   )
{
	PMFD pDataCurrent = (PMFD)(pInfo);
	PMFD pData = (PMFD)(*pInfo);
	TEXTSTR tmp_base = NULL;
	int sendflags;
	int processed = 0;
#ifndef WIN32
	struct dirent *de;
#endif
	if( begin_sub_path )
	{
		pInfo = (void**)&(pDataCurrent->current);
	}
	else
		pDataCurrent = NULL;
	//lprintf( "Search in %s for %s   %d %d", base?base:"(NULL)", mask?mask:"(*)", (*pInfo)?((PMFD)*pInfo)->scanning_mount:0, (*pInfo)?((PMFD)*pInfo)->single_mount:0 );
	if( !*pInfo || begin_sub_path || ((PMFD)*pInfo)->new_mount )
	{
		TEXTCHAR findmask[256];
		pData = (PMFD)(*pInfo);
		if( !pData )
		{
			*pInfo = Allocate( sizeof( MFD ) );
			pData = (PMFD)(*pInfo);
			if( !( pData->scanning_mount = mount ) )
			{
				if( !winfile_local )
					SimpleRegisterAndCreateGlobal( winfile_local );
				//lprintf( "... %p", winfile_local );
				pData->single_mount = FALSE;
				pData->scanning_mount = (*winfile_local).mounted_file_systems;
			}
			else
				pData->single_mount = TRUE;
			if( !pData->scanning_mount )
			{
				Deallocate( PMFD, pData );
				if( tmp_base )
					Release( tmp_base );
				return 0;
			}
			if( pData->scanning_mount->fsi )
			{
				char *tmp1, *tmp2;
				//lprintf( "create cursor" );
				tmp_base = ExpandPathEx( base, pData->scanning_mount->fsi );
				pData->cursor = pData->scanning_mount->fsi->find_create_cursor( pData->scanning_mount->psvInstance, tmp2 = CStrDup( tmp_base ), tmp1 = CStrDup( mask ) );
				Deallocate( char*, tmp1 );
				Deallocate( char*, tmp2 );
			}
			else
			{
				//lprintf( "no cursor" );
				pData->cursor = NULL;
			}
		}
		else
		{
			if( pData->new_mount )
			{
				if( pData->scanning_mount->fsi )
				{
					//lprintf( "create cursor (new mount)" );
					tmp_base = ExpandPathEx( base, pData->scanning_mount->fsi );
					pData->cursor = pData->scanning_mount->fsi->find_create_cursor( pData->scanning_mount->psvInstance, CStrDup( tmp_base ), CStrDup( mask ) );
				}
				else
					pData->cursor = NULL;
			}
		}
		pData->new_mount = FALSE;
		pData->current = NULL;
		pData->prior = pDataCurrent;
		if( pDataCurrent )
		{
			pData->root_info = pDataCurrent->root_info;
			pInfo = (void**)pData->root_info;
		}
		else
		{
			pData->root_info = (struct myfinddata**)pInfo;
		}
		(*pData->root_info) = pData;
		if( base )
		{
			TEXTSTR tmp;
			StrCpyEx( findbasename(pInfo), tmp = ExpandPathEx( base, pData->scanning_mount?pData->scanning_mount->fsi:NULL ), MAX_PATH_NAME );
			Release( tmp );
			StrCpyEx( findmask(pInfo), mask, MAX_PATH_NAME );
		}
		else
		{
			CTEXTSTR p = pathrchr( mask );
			if( p )
			{
				StrCpyEx( findbasename(pInfo), mask, p - mask + 1 );
				StrCpyEx( findmask(pInfo), p + 1, MAX_PATH_NAME );
				//mask = p + 1;
			}
			else
			{
				StrCpyEx( findbasename(pInfo), WIDE(""), 2 );
				StrCpyEx( findmask(pInfo), mask, MAX_PATH_NAME );
			}
		}
		if( findbasename(pInfo)[0] )
			tnprintf( findmask, sizeof(findmask), WIDE("%s/*"), findbasename(pInfo) );
		else {
			tnprintf( findmask, sizeof( findmask ), WIDE( "*" ) );
		}
		if( pData->scanning_mount?pData->scanning_mount->fsi:NULL )
			if( pData->scanning_mount->fsi->find_first( findcursor(pInfo) ) )
				findhandle(pInfo) = 0;
			else
				findhandle(pInfo) = (HANDLECAST)-1;
		else
		{
#ifdef WIN32
			findhandle(pInfo) = findfirst( findmask, finddata(pInfo) );
#else
			lprintf( "opendir [%s]", findbasename(pInfo) );
			if( !findbasename(pInfo)[0] ) {
				TEXTSTR tmp;
				tmp = ExpandPathEx( ".", pData->scanning_mount?pData->scanning_mount->fsi:NULL );
				findhandle( pInfo ) = opendir( tmp );
				Deallocate( TEXTSTR, tmp );
			} else
				findhandle( pInfo ) = opendir( findbasename(pInfo) );
			if( !findhandle(pInfo ) )
				findhandle(pInfo) = (HANDLECAST)-1;
			else
				de = readdir( (DIR*)findhandle( pInfo ) );
#endif
		}
		if( findhandle(pInfo) == (HANDLECAST)-1 )
		{
			PMFD prior = pData->prior;
			//lprintf( "first use of cursor or first open of directoy failed..." );
			if( pData->scanning_mount && pData->scanning_mount->fsi )
				pData->scanning_mount->fsi->find_close( (struct find_cursor*)findcursor(pInfo) );
			else
			{
#ifdef WIN32
				findclose( findhandle(pInfo) );
#else
				// but it failed... so ... don't close
				//closedir( findhandle( pInfo ) );
#endif
			}
			pData->scanning_mount = NextThing( pData->scanning_mount );
			if( !pData->scanning_mount || pData->single_mount )
			{
				(*pData->root_info) = pData->prior;
				if( !begin_sub_path ) {
					Release( pData ); pInfo[0] = NULL;
				}
				//lprintf( WIDE( "%p %d" ), prior, processed );
				if( tmp_base )
					Release( tmp_base );
				return prior?processed:0;
			}
			pData->new_mount = TRUE;
				if( tmp_base )
					Release( tmp_base );
			return 1;
		}
	}
	else
	{
		int r;
getnext:
		//lprintf( "returning customer..." );
		if( pData->scanning_mount?pData->scanning_mount->fsi:NULL )
			r = !pData->scanning_mount->fsi->find_next( findcursor( pInfo ) );
		else
		{
#ifdef _WIN32
			r = findnext( findhandle(pInfo), finddata( pInfo ) );
#else
			de = readdir( (DIR*)findhandle( pInfo ) );
			//lprintf( "using %p got %p", findhandle( pInfo ), de );
			r = (de == NULL);
#endif
		}
		if( r )
		{
			PMFD prior = pData->prior;
			//lprintf( "nothing left to find..." );
			if( pData->scanning_mount->fsi )
				pData->scanning_mount->fsi->find_close( findcursor(pInfo) );
			else
			{
#ifdef WIN32
				findclose( findhandle(pInfo) );
#else
				closedir( (DIR*)findhandle(pInfo));
#endif
			}
			pData->scanning_mount = NextThing( pData->scanning_mount );
			//lprintf( "Step mount... %p %d", pData->scanning_mount, pData->single_mount );
			if( !pData->scanning_mount || pData->single_mount )
			{
				//lprintf( "done with mounts?" );
				(*pData->root_info) = pData->prior;
				Release( pData );
				if( prior )
					prior->current = NULL;
				if( !processed && !begin_sub_path )
				{
					//pInfo = (void**)&(prior->prior->current);
					pData = prior;
					if( pData )
						goto getnext;
				}
				if( tmp_base )
					Release( tmp_base );
				return (*pInfo)?processed:0;
			}
			pData->new_mount = TRUE;
			if( tmp_base )
				Release( tmp_base );
			return 1;
		}
	}
	if( pData->scanning_mount?pData->scanning_mount->fsi:NULL )
	{
		char * path = pData->scanning_mount->fsi->find_get_name( findcursor(pInfo) );
		//lprintf( "... %s", path );
		if( !strcmp( ".", path ) ||
		    !strcmp( "..", path ) )
		goto getnext;
	}
	else
	{
#ifdef WIN32
		//lprintf( "... %s", finddata(pInfo)->name );
#  ifdef UNDER_CE
		if( !StrCmp( WIDE("."), finddata(pInfo)->cFileName ) ||
		    !StrCmp( WIDE(".."), finddata(pInfo)->cFileName ) )
#  else
		if( !StrCmp( WIDE("."), finddata(pInfo)->name ) ||
		    !StrCmp( WIDE(".."), finddata(pInfo)->name ) )
#  endif
#else
		if( !StrCmp( WIDE("."), de->d_name ) ||
		    !StrCmp( WIDE(".."), de->d_name ) )
#endif
			goto getnext;
	}
 // if nameonly - have to rebuild the correct name.
	if( !(flags & SFF_NAMEONLY) )
	{
		if( pData->scanning_mount?pData->scanning_mount->fsi:NULL )
		{
			tnprintf( pData->file_buffer, MAX_PATH_NAME, WIDE("%s"), pData->scanning_mount->fsi->find_get_name( findcursor(pInfo) ) );
			if( findbasename( pInfo )[0] )
				tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s/%s"), findbasename(pInfo), pData->file_buffer );
			else
				tnprintf( pData->buffer, MAX_PATH_NAME, WIDE( "%s" ), pData->file_buffer );
		}
		else
		{
#ifdef WIN32
#  ifdef UNDER_CE
			tnprintf( pData->file_buffer, MAX_PATH_NAME, WIDE( "%s" ), finddata( pInfo )->cFileName );
			tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s/%s"), findbasename(pInfo), finddata(pInfo)->cFileName );
#  else
			tnprintf( pData->file_buffer, MAX_PATH_NAME, WIDE("%s"), finddata(pInfo)->name );
			tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s%s%s"), findbasename(pInfo), findbasename( pInfo )[0]?"/":"", pData->file_buffer );
#  endif
#else
			tnprintf( pData->file_buffer, MAX_PATH_NAME, WIDE("%s"), de->d_name );
			tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s%s%s"), findbasename(pInfo), findbasename( pInfo )[0]?"/":"", de->d_name );
#endif
		}
	}
	else
	{
		if( flags & SFF_SUBCURSE )
		{
			if( pData->scanning_mount?pData->scanning_mount->fsi:NULL )
			{
				tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s%s%s")
					  , pData->prior?pData->prior->buffer:WIDE( "" )
					  , pData->prior?WIDE( "/" ):WIDE( "" )
					, pData->scanning_mount->fsi->find_get_name( findcursor(pInfo) )
					);
			}
			else
			{
#ifdef WIN32
#  ifdef UNDER_CE
				tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s%s%s")
						  , pData->prior?pData->prior->buffer:WIDE( "" )
						  , pData->prior?WIDE( "/" ):WIDE( "" )
						  , finddata(pInfo)->cFileName );
#  else
				tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s%s%s")
						  , pData->prior?pData->prior->buffer:WIDE( "" )
						  , pData->prior?WIDE( "/" ):WIDE( "" )
						  , finddata(pInfo)->name );
#  endif
#else
				tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s%s%s")
					  , pData->prior?pData->prior->buffer:WIDE( "" )
					  , pData->prior?WIDE( "/" ):WIDE( "" )
					  , de->d_name );
					  lprintf( "resulting is %s", pData->buffer );
#endif
			}
		}
		else
		{
			if( pData->scanning_mount?pData->scanning_mount->fsi:NULL )
			{
				tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s"), pData->scanning_mount->fsi->find_get_name( findcursor(pInfo) ) );
			}
			else
			{
#ifdef WIN32
#  ifdef UNDER_CE
				tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s"), finddata(pInfo)->cFileName );
#  else
#    ifdef UNICODE
				snwprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s"), finddata(pInfo)->name );
#    else
				tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s"), finddata(pInfo)->name );
#    endif
#  endif
#else
				tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s"), de->d_name );
#endif
			}
		}
	}
 // force nul termination...
	pData->buffer[MAX_PATH_NAME-1] = 0;
#ifdef UNICODE
	{
		char *pDataBuffer = CStrDup( pData->buffer );
#else
#  define pDataBuffer pData->buffer
#endif
	//lprintf( "Check if %s is a directory...", pData->buffer );
	if( ((flags & (SFF_DIRECTORIES | SFF_SUBCURSE))
		&& (pData->scanning_mount && pData->scanning_mount->fsi
			&& (pData->scanning_mount->fsi->is_directory
				&& pData->scanning_mount->fsi->is_directory( pData->scanning_mount->psvInstance, pDataBuffer ))))
		|| (!(pData->scanning_mount ? pData->scanning_mount->fsi : NULL)
#ifdef WIN32
#  ifdef UNDER_CE
			&& (finddata( pInfo )->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
#  else
			&& (finddata( pInfo )->attrib & _A_SUBDIR)
#  endif
#else
			&& IsPath( pData->buffer )
#endif
			) )
	{
#ifdef UNICODE
		Deallocate( char *, pDataBuffer );
#else
#  undef pDataBuffer
#endif
		//lprintf( "... it is?" );
		if( flags & SFF_DIRECTORIES )
		{
			if( Process != NULL )
			{
				//lprintf( "Send %s", pData->buffer );
				Process( psvUser, pData->buffer, SFF_DIRECTORY );
				processed = 1;
			}
			//return 1;
		}
		if( flags & SFF_SUBCURSE )
		{
			//int ofs = 0;
			TEXTCHAR tmpbuf[MAX_PATH_NAME];
			if( flags & SFF_NAMEONLY )
			{
				// even in name only - need to have this full buffer for subcurse.
				if( pData->scanning_mount && pData->scanning_mount->fsi )
				{
					/*ofs = */
tnprintf( tmpbuf, sizeof( tmpbuf ), WIDE( "%s/%s" ), findbasename( pInfo ), pData->scanning_mount->fsi->find_get_name( findcursor( pInfo ) ) );
				}
				else
				{
#ifdef WIN32
#  ifdef UNDER_CE
					/*ofs = */
tnprintf( tmpbuf, sizeof( tmpbuf ), WIDE( "%s/%s" ), findbasename( pInfo ), finddata( pInfo )->cFileName );
#  else
#    ifdef UNICODE
					/*ofs = */
snwprintf( tmpbuf, sizeof( tmpbuf ), WIDE( "%s/%s" ), findbasename( pInfo ), finddata( pInfo )->name );
#    else
					/*ofs = */
tnprintf( tmpbuf, sizeof( tmpbuf ), WIDE( "%s/%s" ), findbasename( pInfo ), finddata( pInfo )->name );
#    endif
#  endif
#else
					/*ofs = */
tnprintf( tmpbuf, sizeof( tmpbuf ), WIDE( "%s/%s" ), findbasename( pInfo ), de->d_name );
#endif
				}
				//lprintf( "process sub... %s %s", tmpbuf, findmask(pInfo)  );
				processed |= ScanFilesEx( tmpbuf, findmask( pInfo ), (POINTER*)pData, Process, flags, psvUser, TRUE, pData->scanning_mount );
			}
			else
			{
				//lprintf( "process sub..." );
				processed |= ScanFilesEx( pData->buffer, findmask( pInfo ), (POINTER*)pData, Process, flags, psvUser, TRUE, pData->scanning_mount );
			}
		}
		if( !processed )
			goto getnext;
		if( tmp_base )
			Release( tmp_base );
		return (*pInfo) ? 1 : 0;
	}
#ifdef UNICODE
	Deallocate( char *, pDataBuffer );
	}
#else
#  undef pDataBuffer
#endif
	if( ( sendflags = SFF_DIRECTORY, ( ( flags & SFF_DIRECTORIES )
#ifdef WIN32
#  ifdef UNDER_CE
												 && ( finddata(pInfo)->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
#  else
												 && ( finddata(pInfo)->attrib & _A_SUBDIR )
#  endif
#else
												 && ( IsPath( pData->buffer ) )
#endif
												) ) || ( sendflags = 0, CompareMask( findmask( pInfo )
#ifdef WIN32
#  ifdef UNDER_CE
																							  , finddata(pInfo)->cFileName
#  else
																							  , pData->file_buffer
#  endif
#else
																							  , de->d_name
#endif
																								// yes this is silly - but it's correct...
																							  , (flags & SFF_IGNORECASE)?0:0 ) ) )
	{
		//lprintf( "Send %s", pData->buffer );
		if( Process != NULL )
			Process( psvUser, pData->buffer, sendflags );
		if( tmp_base )
			Release( tmp_base );
		return (*pInfo)?1:0;
	}
	if( tmp_base )
		Release( tmp_base );
	return (*pInfo)?1:0;
}
 int  ScanFiles ( CTEXTSTR base
                , CTEXTSTR mask
                , void **pInfo
                , void CPROC Process( uintptr_t psvUser, CTEXTSTR name, int flags )
                , int flags
                , uintptr_t psvUser )
 {
	 return ScanFilesEx( base, mask, pInfo, Process, flags, psvUser, FALSE, NULL );
 }
//---------------------------------------------------------------------------
 void  ScanDrives ( void (CPROC*Process)(uintptr_t user, CTEXTSTR letter, int flags)
									, uintptr_t user )
{
#ifdef WIN32
#  ifdef UNDER_CE
	Process( user, WIDE(""), SFF_DRIVE );
#  else
	uint32_t drives;
	int i;
	drives = GetLogicalDrives();
	for( i = 0; i < 26; i++ )
	{
		TEXTCHAR name[2];
		name[1] = 0;
		if( drives & ( 1 << i ) )
		{
			name[0] = 'A' + i;
			if( Process )
				Process( user, name, SFF_DRIVE );
		}
	}
#  endif
#endif
}
FILESYS_NAMESPACE_END
#ifdef __LINUX__
#endif
//-----------------------------------------------------------------------
FILESYS_NAMESPACE
extern TEXTSTR ExpandPath( CTEXTSTR path );
 CTEXTSTR  pathrchr ( CTEXTSTR path )
{
	CTEXTSTR end1, end2;
	end1 = StrRChr( path, '\\' );
	end2 = StrRChr( path, '/' );
	if( end1 > end2 )
		return end1;
	return end2;
}
#ifdef __cplusplus
 TEXTSTR  pathrchr ( TEXTSTR path )
{
	TEXTSTR end1, end2;
	end1 = StrRChr( path, '\\' );
	end2 = StrRChr( path, '/' );
	if( end1 > end2 )
		return end1;
	return end2;
}
#endif
//-----------------------------------------------------------------------
 CTEXTSTR  pathchr ( CTEXTSTR path )
{
	CTEXTSTR end1, end2;
	end1 = StrChr( path, (int)'\\' );
	end2 = StrChr( path, (int)'/' );
	if( end1 && end2 )
	{
		if( end1 < end2 )
			return end1;
		return end2;
	}
	else if( end1 )
		return end1;
	else if( end2 )
		return end2;
	return NULL;
}
//-----------------------------------------------------------------------
TEXTSTR GetCurrentPath( TEXTSTR path, int len )
{
	if( !path )
		return 0;
#ifndef UNDER_CE
#  ifdef _WIN32
	GetCurrentDirectory( len, path );
#  else
#	  ifdef UNICODE
	{
		char _path[256];
		//TEXTCHAR *tmppath;
		//getcwd( _path, 256 );
		//tmppath = DupCStr( _path );
		//StrCpyEx( path, tmppath, len );
		path[0] = '.';
		path[1] = 0;
	}
#	  else
	getcwd( path, len );
#	  endif
#  endif
#endif
	return path;
}
#ifndef _WIN32
static void convert( uint64_t* outtime, time_t *time )
{
	*outtime = *time;
}
#endif
//-----------------------------------------------------------------------
uint64_t GetTimeAsFileTime ( void )
{
#if defined( __LINUX__ )
	struct timeval tmp;
	struct timezone tz;
	FILETIME result;
	gettimeofday( &tmp, &tz );
	result = ( tmp.tv_usec * 10LL ) + ( tmp.tv_sec * 1000LL * 1000LL * 10LL );
	return result;
#else
	SYSTEMTIME st;
	FILETIME result;
	GetLocalTime( &st );
	SystemTimeToFileTime( &st, &result );
	return *(uint64_t*)&result;
#endif
}
 // last modification time.
 uint64_t  GetFileWriteTime( CTEXTSTR name )
{
	TEXTSTR tmppath = ExpandPath( name );
#ifdef _WIN32
	HANDLE hFile = CreateFile( tmppath
 // device access?
								  , 0
								  , FILE_SHARE_READ|FILE_SHARE_WRITE
								  , NULL
								  , OPEN_EXISTING
								  , 0
								  , NULL );
	if( hFile != INVALID_HANDLE_VALUE )
	{
		FILETIME filetime;
		//uint64_t realtime;
		GetFileTime( hFile, NULL, NULL, &filetime );
		CloseHandle( hFile );
		//realtime = *(uint64_t*)&filetime;
		//realtime *= 100; // nano seconds?
		return *(uint64_t*)&filetime;
	}
	return 0;
#else
	struct stat statbuf;
	 uint64_t realtime;
#ifdef UNICODE
	{
		char *tmpname = CStrDup( tmppath );
		stat( tmpname, &statbuf );
		Release( tmpname );
	}
#else
	stat( tmppath, &statbuf );
#endif
	convert( &realtime, (time_t*)&statbuf.st_mtime );
	return realtime;
#endif
	return 0;
}
//-----------------------------------------------------------------------
 // last modification time.
 LOGICAL  SetFileWriteTime( CTEXTSTR name, uint64_t filetime )
{
#ifdef _WIN32
	HANDLE hFile = CreateFile( name
 // device access?
								  , GENERIC_WRITE
								  , FILE_SHARE_READ|FILE_SHARE_WRITE
								  , NULL
								  , OPEN_EXISTING
								  , 0
								  , NULL );
	if( hFile != INVALID_HANDLE_VALUE )
	{
		//uint64_t realtime;
		SetFileTime( hFile, NULL, NULL, (CONST FILETIME*)&filetime );
		CloseHandle( hFile );
		//realtime = *(uint64_t*)&filetime;
	   //realtime *= 100; // nano seconds?
	  return TRUE;
	}
	return FALSE;
#else
	struct stat statbuf;
	uint64_t realtime;
#ifdef UNICODE
	 {
		 int status;
	   char *tmpname = CStrDup( name );
		 stat( tmpname, &statbuf );
		 Release( tmpname );
	 }
#else
	 stat( name, &statbuf );
#endif
	convert( &realtime, (time_t*)&statbuf.st_mtime );
	return realtime;
#endif
	return 0;
}
#ifdef WIN32
uint64_t ConvertFileTimeToInt( const FILETIME *filetime )
{
	ULARGE_INTEGER tmp;
	tmp.u.LowPart = filetime->dwLowDateTime;
	tmp.u.HighPart = filetime->dwHighDateTime;
	return tmp.QuadPart;
}
void ConvertFileIntToFileTime( uint64_t int_filetime, FILETIME *filetime )
{
	ULARGE_INTEGER tmp;
	tmp.QuadPart = int_filetime;
	filetime->dwLowDateTime  = tmp.u.LowPart;
	filetime->dwHighDateTime = tmp.u.HighPart;
}
#endif
LOGICAL  SetFileTimes( CTEXTSTR name
  // last modification time.
							, uint64_t time_create
 // last modification time.
							, uint64_t time_modify
  // last modification time.
							, uint64_t time_access
							)
{
#ifdef _WIN32
	LOGICAL result = TRUE;
	HANDLE hFile = CreateFile( name
 //GENERIC_WRITE|FILE_WRITE_ATTRIBUTES //GENERIC_ALL // device access?
									 , GENERIC_ALL
									 , FILE_SHARE_READ|FILE_SHARE_WRITE
									 , NULL
									 , OPEN_EXISTING
									 , FILE_FLAG_BACKUP_SEMANTICS
									 , NULL );
	if( hFile != INVALID_HANDLE_VALUE )
	{
		FILETIME filetime_create;
		FILETIME filetime_modify;
		FILETIME filetime_access;
		ULARGE_INTEGER tmp;
		//uint64_t realtime;
		tmp.QuadPart = time_create;
		filetime_create.dwLowDateTime = tmp.u.LowPart;
		filetime_create.dwHighDateTime = tmp.u.HighPart;
		tmp.QuadPart = time_access;
		filetime_access.dwLowDateTime = tmp.u.LowPart;
		filetime_access.dwHighDateTime = tmp.u.HighPart;
		tmp.QuadPart = time_modify;
		filetime_modify.dwLowDateTime = tmp.u.LowPart;
		filetime_modify.dwHighDateTime = tmp.u.HighPart;
#if 0
		{
			TEXTCHAR buf[3][64];
			SYSTEMTIME st;
			FileTimeToSystemTime( &time_create, &st );
			snprintf( buf[0], 64, "%02d/%02d/%04d %02d:%02d:%02d.%03d", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds );
			FileTimeToSystemTime( &time_access, &st );
			snprintf( buf[1], 64,"%02d/%02d/%04d %02d:%02d:%02d.%03d", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds );
			FileTimeToSystemTime( &time_modify, &st );
			snprintf( buf[2], 64, "%02d/%02d/%04d %02d:%02d:%02d.%03d", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds );
			lprintf( "File times on [%s] are to be : %s %s %s", name, buf[0], buf[1], buf[2] );
		}
#endif
		if( !SetFileTime( hFile, (CONST FILETIME*)&filetime_create, (CONST FILETIME*)&filetime_access, (CONST FILETIME*)&filetime_modify ) )
		{
			result = FALSE;
			lprintf( WIDE("Failed to set times:(%s)%d"), name, GetLastError() );
		}
		CloseHandle( hFile );
		//realtime = *(uint64_t*)&filetime;
		//realtime *= 100; // nano seconds?
		return result;
	}
	else
	{
		lprintf( WIDE("Failed to open to set time on %s:%d"), name, GetLastError() );
	}
	return FALSE;
#else
	struct stat statbuf;
	 uint64_t realtime;
#ifdef UNICODE
	 {
	   char *tmpname = CStrDup( name );
		 stat( tmpname, &statbuf );
	   Release( tmpname );
	 }
#else
	 stat( name, &statbuf );
#endif
	convert( &realtime, (time_t*)&statbuf.st_mtime );
	return realtime;
#endif
	return 0;
}
//-----------------------------------------------------------------------
LOGICAL  IsPath ( CTEXTSTR path )
{
	if( !path )
		return 0;
#ifdef _WIN32
	{
		DWORD dwResult;
		dwResult = GetFileAttributes( path );
		if( dwResult == 0xFFFFFFFF )
			return 0;
		if( dwResult & FILE_ATTRIBUTE_DIRECTORY )
			return 1;
		return 0;
	}
#else
	 {
		 struct stat statbuf;
#ifdef UNICODE
		 {
			 int status;
			 char *tmppath = CStrDup( path );
			 status = stat( tmppath, &statbuf );
			 Release( tmppath );
			 if( status < 0 )
				 return 0;
		 }
#else
		 if( stat( path, &statbuf ) < 0 )
			 return 0;
#endif
		 return S_ISDIR( statbuf.st_mode );
	 }
#endif
}
//-----------------------------------------------------------------------
int  MakePath ( CTEXTSTR path )
{
	int status;
	if( !path )
		return 0;
#ifdef _WIN32
	status = CreateDirectory( path, NULL );
	if( !status )
	{
		uint32_t err = GetLastError();
		TEXTSTR tmppath = StrDup( path );
		TEXTSTR last = (TEXTSTR)pathrchr( tmppath );
		if( last )
		{
			last[0] = 0;
			if( MakePath( tmppath ) )
				status = CreateDirectory( path, NULL );
		}
		Release( tmppath );
	}
	return status;
#else
#  ifdef UNICODE
	{
		int status;
		char *tmppath = CStrDup( path );
 // make directory with full umask permissions
		status = mkdir( tmppath, -1 );
		Release( tmppath );
		return !status;
	}
#  else
 // make directory with full umask permissions
	if( ( status = mkdir( path, -1 ) ) < 0 )
	{
		TEXTSTR tmppath = StrDup( path );
		TEXTSTR last = (TEXTSTR)pathrchr( tmppath );
		if( last )
		{
			last[0] = 0;
			if( MakePath( tmppath ) ) {
				status = mkdir( path, -1 );
				if( status < 0 )
					if( EEXIST == errno )
						status = 0;
			}
		}
		Release( tmppath );
	}
	if( status < 0 )
		if( EEXIST == errno )
			status = 0;
	return !status;
#  endif
#endif
}
//-----------------------------------------------------------------------
int  SetCurrentPath ( CTEXTSTR path )
{
	int status = 1;
	TEXTSTR tmp_path;
	if( !path )
		return 0;
	tmp_path = ExpandPath( path );
#ifndef UNDER_CE
#  ifdef _WIN32
	status = SetCurrentDirectory( tmp_path );
#  else
#	ifdef UNICODE
	{
		char *tmppath = CStrDup( path );
 // make directory with full umask permissions
		status = chdir( tmppath );
		Release( tmppath );
	}
#	else
	 status = !chdir( tmp_path );
#	endif
#  endif
	Release( tmp_path );
	if( status )
	{
		TEXTCHAR tmp[256];
		path = GetCurrentPath( tmp, sizeof( tmp ) );
		SetDefaultFilePath( path );
	}
	else
	{
		TEXTCHAR tmp[256];
		lprintf( WIDE( "Failed to change to [%s](%d) from %s" ), path, GetLastError(), GetCurrentPath( tmp, sizeof( tmp ) ) );
	}
#endif
	return status;
}
LOGICAL IsAbsolutePath( CTEXTSTR path )
{
	if(path)
	{
#ifdef WIN32
		if( ( path[0] && path[1] && path[2] ) &&
			  ( ( ( ( path[0] >= 'a' && path[0] <= 'z' )
				  || ( path[0] >= 'A' && path[0] <= 'Z' ) )
				  && ( path[1] == ':' )
				  && ( path[2] == '/' || path[2] == '\\' ) )
				|| ( path[0] == '/' && path[1] == '/' )
				|| ( path[0] == '\\' && path[1] == '\\' )
			  || ( path[0] == '/' || path[0] == '\\' ) )
		  )
			return TRUE;
#else
		if( path[0] == '/' || path[0] == '\\' )
			return TRUE;
#endif
	}
	return FALSE;
}
LOGICAL SetFileLength( CTEXTSTR path, size_t length )
{
#ifdef __LINUX__
	// files are by default binary in linux
#  ifndef O_BINARY
#	define O_BINARY 0
#  endif
#endif
	INDEX file;
	file = sack_iopen( 0, path, O_RDWR|O_BINARY );
	if( file == INVALID_INDEX )
		return FALSE;
	sack_ilseek( file, length, SEEK_SET );
	sack_iset_eof( file );
	sack_iclose( file );
	return TRUE;
}
FILESYS_NAMESPACE_END
//-----------------------------------------------------------------------
/*
 *  Crafted by James Buckeyne
 *
 *	(c) Freedom Collective 2000-2006++
 *
 *	code to drive standard containers, lists, stacks, queues
 *	auto expanding, auto tracking, threadsafe containers...
 *
 *  standardized to never use int.
 *
 * see also - include/typelib.h
 *
 */
 // offsetof
 // Sleep
#define MY_OFFSETOF( ppstruc, member ) ((uintptr_t)&((*ppstruc)->member)) - ((uintptr_t)(*ppstruc))
#ifndef USE_CUSTOM_ALLOCER
#define USE_SACK_CUSTOM_MEMORY_ALLOCATION
// this has to be a compile option (option from cmake)
#ifdef USE_SACK_CUSTOM_MEMORY_ALLOCATION
#define USE_CUSTOM_ALLOCER 1
#else
#define USE_CUSTOM_ALLOCER 0
#endif
#endif
#ifdef __cplusplus
namespace sack {
	namespace containers {
#endif
//--------------------------------------------------------------------------
#ifdef __cplusplus
		namespace list {
#endif
static struct list_local_data
{
	volatile uint32_t lock;
} s_list_local, *_list_local;
#define list_local  ((_list_local)?(*_list_local):(s_list_local))
#define list_local_lock ((_list_local)?(&_list_local->lock):(&s_list_local.lock))
#ifdef UNDER_CE
#define LockedExchange InterlockedExchange
#endif
PLIST  CreateListEx ( DBG_VOIDPASS )
{
	PLIST pl;
	INDEX size;
	pl = (PLIST)AllocateEx( ( size = (INDEX)offsetof( LIST, pNode[0] ) ) DBG_RELAY );
	MemSet( pl, 0, size );
	return pl;
}
//--------------------------------------------------------------------------
PLIST  DeleteListEx ( PLIST *pList DBG_PASS )
{
	PLIST ppList;
	while( LockedExchange( list_local_lock, 1 ) )
		Relinquish();
	if( pList &&
		( ppList = (PLIST)LockedExchangePtrSzVal( (uintptr_t*)pList, 0 ) )
	  )
	{
		ReleaseEx( ppList DBG_RELAY );
	}
	list_local_lock[0] = 0;
	return NULL;
}
//--------------------------------------------------------------------------
static PLIST ExpandListEx( PLIST *pList, INDEX amount DBG_PASS )
{
	PLIST old_list = (*pList);
	PLIST pl;
	uintptr_t size;
	uintptr_t old_size;
	if( !pList )
		return NULL;
	if( *pList )
	{
		old_size = ((uintptr_t)&((*pList)->pNode[(*pList)->Cnt])) - ((uintptr_t)(*pList));
		size = ((uintptr_t)&((*pList)->pNode[(*pList)->Cnt+amount])) - ((uintptr_t)(*pList));
		//old_size = offsetof( LIST, pNode[(*pList)->Cnt]));
		pl = (PLIST)AllocateEx( size DBG_RELAY );
	}
	else
	{
		old_size = 0;
		pl = (PLIST)AllocateEx( size = MY_OFFSETOF( pList, pNode[amount] ) DBG_RELAY );
		pl->Cnt = 0;
	}
	if( old_list )
	{
		// copy old list to new list
		MemCpy( pl, *pList, old_size );
		if( amount == 1 )
			pl->pNode[pl->Cnt++] = NULL;
		else
		{
			// clear the new additions to the list
			MemSet( pl->pNode + pl->Cnt, 0, size - old_size );
			pl->Cnt += amount;
		}
		// set the new list before releasing the old one.
		(*pList) = pl;
		// remove the old list...
		ReleaseEx( old_list DBG_RELAY );
	}
	else
	{
 // clear whole structure on creation...
		MemSet( pl, 0, size );
  // one more ( always a free )
		pl->Cnt = amount;
		// brand new list.
		*pList = pl;
	}
	return pl;
}
//--------------------------------------------------------------------------
 PLIST  AddLinkEx ( PLIST *pList, POINTER p DBG_PASS )
{
	INDEX i;
	if( !pList )
		return NULL;
	if( !(*pList ) )
	{
	retry1:
		ExpandListEx( pList, 8 DBG_RELAY );
	}
	else
	{
		while( LockedExchange( list_local_lock, 1 ) )
			Relinquish();
		// cannot trust that the list will exist all the time
		// we may start calling this function and have the
		// list re-allocated.
		if( !(*pList) )
		{
			list_local_lock[0] = 0;
			return NULL;
		}
	}
	for( i = 0; i < (*pList)->Cnt; i++ )
	{
		if( !(*pList)->pNode[i] )
		{
			(*pList)->pNode[i] = p;
			break;
		}
	}
	if( i == (*pList)->Cnt )
  // pList->Cnt changes - don't test in WHILE
		goto retry1;
	list_local_lock[0] = 0;
 // might be a NEW list...
	return *pList;
}
//--------------------------------------------------------------------------
 PLIST  SetLinkEx ( PLIST *pList, INDEX idx, POINTER p DBG_PASS )
{
	INDEX sz;
	if( !pList )
		return NULL;
	if( *pList )
	{
		while( LockedExchange( list_local_lock, 1 ) )
			Relinquish();
		if( !(*pList ) )
		{
			list_local_lock[0] = 0;
			return NULL;
		}
	}
	if( idx == INVALID_INDEX )
	{
		list_local_lock[0] = 0;
 // not set...
		return *pList;
	}
	sz = 0;
	while( !(*pList) || ( sz = (*pList)->Cnt ) <= idx )
		ExpandListEx( pList, (idx - sz) + 1 DBG_RELAY );
	(*pList)->pNode[idx] = p;
	list_local_lock[0] = 0;
 // might be a NEW list...
	return *pList;
}
//--------------------------------------------------------------------------
 POINTER  GetLink ( PLIST *pList, INDEX idx )
{
	// must lock the list so that it's not expanded out from under us...
	POINTER p;
	if( !pList || !(*pList) )
		return NULL;
	if( idx == INVALID_INDEX )
 // not set...
		return pList;
	while( LockedExchange( list_local_lock, 1 ) )
		Relinquish();
	if( !(*pList ) )
	{
		list_local_lock[0] = 0;
		return NULL;
	}
	if( (*pList)->Cnt <= idx )
	{
		list_local_lock[0] = 0;
		return NULL;
	}
	p = (*pList)->pNode[idx];
	list_local_lock[0] = 0;
	return p;
}
//--------------------------------------------------------------------------
 POINTER*  GetLinkAddress ( PLIST *pList, INDEX idx )
{
	// must lock the list so that it's not expanded out from under us...
	POINTER *p;
	if( !pList || !(*pList) )
		return NULL;
	if( idx == INVALID_INDEX )
 // not set...
		return NULL;
	if( (*pList)->Cnt <= idx )
	{
		return NULL;
	}
	p = (*pList)->pNode + idx;
	return p;
}
//--------------------------------------------------------------------------
 uintptr_t  ForAllLinks ( PLIST *pList, ForProc func, uintptr_t user )
{
	INDEX i;
	uintptr_t result = 0;
	while( LockedExchange( list_local_lock, 1 ) )
		Relinquish();
	 if( pList && *pList )
	{
		for( i=0; i < ((*pList)->Cnt); i++ )
		{
			if( (*pList)->pNode[i] )
			{
				result = func( user, i, (*pList)->pNode + i );
				if( result )
					break;
			}
		}
	}
	list_local_lock[0] = 0;
	return result;
}
 //--------------------------------------------------------------------------
 INDEX GetLinkCount( PLIST pList ) {
	 INDEX i;
	 POINTER p;
	 INDEX count = 0;
	 LIST_FORALL( pList, i, POINTER, p ) {
		 count++;
	 }
	 return count;
 }
 //--------------------------------------------------------------------------
static uintptr_t CPROC IsLink( uintptr_t value, INDEX i, POINTER *link )
{
	if( value == (uintptr_t)(*link) )
 // 0 might be value so add one to make it non zero
		return i+1;
	return 0;
}
//--------------------------------------------------------------------------
 INDEX  FindLink ( PLIST *pList, POINTER value )
{
	if( !pList || !(*pList ) )
		return INVALID_INDEX;
	return ForAllLinks( pList, IsLink, (uintptr_t)value ) - 1;
}
//--------------------------------------------------------------------------
static uintptr_t CPROC KillLink( uintptr_t value, INDEX i, POINTER *link )
{
	if( value == (uintptr_t)(*link) )
	{
		(*link) = NULL;
 // stop searching
		return 1;
	}
	return 0;
}
 LOGICAL  DeleteLink ( PLIST *pList, CPOINTER value )
{
	if( ForAllLinks( pList, KillLink, (uintptr_t)value ) )
		return TRUE;
	return FALSE;
}
//--------------------------------------------------------------------------
static uintptr_t CPROC RemoveItem( uintptr_t value, INDEX i, POINTER *link )
{
	*link = NULL;
	return 0;
}
 void			EmptyList		( PLIST *pList )
{
	ForAllLinks( pList, RemoveItem, 0 );
}
#ifdef __cplusplus
//		namespace list {
		};
namespace data_list {
#endif
static struct data_list_local_data
{
	uint32_t lock;
} s_data_list_local, *_data_list_local;
#define data_list_local  ((_data_list_local)?(*_data_list_local):(s_data_list_local))
#define data_list_local_lock  ((_data_list_local)?(&_data_list_local->lock):(&s_data_list_local.lock))
//--------------------------------------------------------------------------
PDATALIST ExpandDataListEx( PDATALIST *ppdl, INDEX entries DBG_PASS )
{
	PDATALIST pdl = (*ppdl);
	PDATALIST pNewList;
	if( !ppdl || !*ppdl )
 // can't expand - was not created (no data size)
		return NULL;
	if( (*ppdl) )
		entries += (*ppdl)->Avail;
	pNewList = (PDATALIST)AllocateEx( sizeof( DATALIST ) + ( (*ppdl)->Size * entries ) - 1 DBG_RELAY );
	MemCpy( pNewList->data, (*ppdl)->data, (*ppdl)->Avail * (*ppdl)->Size );
	pNewList->Cnt = (*ppdl)->Cnt;
	pNewList->Avail = entries;
	pNewList->Size = (*ppdl)->Size;
	// set the new list int he pointer
	*ppdl = pNewList;
	ReleaseEx( pdl DBG_RELAY );
	return pNewList;
}
//--------------------------------------------------------------------------
 PDATALIST  CreateDataListEx ( uintptr_t nSize DBG_PASS )
{
	PDATALIST pdl = (PDATALIST)AllocateEx( sizeof( DATALIST ) + ( nSize * 8 ) - 1 DBG_RELAY );
	pdl->Cnt = 0;
	pdl->Avail = 8;
	pdl->Size = nSize;
	return pdl;
}
//--------------------------------------------------------------------------
 void  DeleteDataListEx ( PDATALIST *ppdl DBG_PASS )
{
	if( ppdl )
	{
		if( *ppdl )
		{
			ReleaseEx( *ppdl DBG_RELAY );
			*ppdl = NULL;
		}
	}
}
//--------------------------------------------------------------------------
POINTER SetDataItemEx( PDATALIST *ppdl, INDEX idx, POINTER data DBG_PASS )
{
	POINTER p = NULL;
	if( !ppdl || !(*ppdl) || idx > 0x100000 )
		return NULL;
	if( idx >= (*ppdl)->Avail )
	{
		ExpandDataListEx( ppdl, (idx-(*ppdl)->Avail)+32 DBG_RELAY );
	}
	p = (*ppdl)->data + ( (*ppdl)->Size * idx );
	MemCpy( p, data, (*ppdl)->Size );
	if( idx >= (*ppdl)->Cnt )
		(*ppdl)->Cnt = idx+1;
	return p;
}
//--------------------------------------------------------------------------
POINTER AddDataItemEx( PDATALIST *ppdl, POINTER data DBG_PASS )
{
	if( ppdl && *ppdl )
		return SetDataItemEx( ppdl, (*ppdl)->Cnt+1, data DBG_RELAY );
	if( ppdl )
		return SetDataItemEx( ppdl, 0, data DBG_RELAY );
	return NULL;
}
void EmptyDataList( PDATALIST *ppdl )
{
	if( ppdl && (*ppdl) )
		(*ppdl)->Cnt = 0;
}
//--------------------------------------------------------------------------
void DeleteDataItem( PDATALIST *ppdl, INDEX idx )
{
	if( ppdl && *ppdl )
	{
		if( idx < ( (*ppdl)->Cnt - 1 ) )
			MemCpy( (*ppdl)->data + ((*ppdl)->Size * idx )
					, (*ppdl)->data + ((*ppdl)->Size * (idx + 1) )
					, (*ppdl)->Size );
		(*ppdl)->Cnt--;
	}
}
//--------------------------------------------------------------------------
POINTER GetDataItem( PDATALIST *ppdl, INDEX idx )
{
	POINTER p = NULL;
	if( ppdl && *ppdl && ( idx < (*ppdl)->Cnt ) )
		p = (*ppdl)->data + ( (*ppdl)->Size * idx );
	return p;
}
//--------------------------------------------------------------------------
#ifdef __cplusplus
//		namespace data_list {
		};
namespace link_stack {
#endif
 PLINKSTACK		CreateLinkStackLimitedEx		  ( int max_entries  DBG_PASS )
{
	PLINKSTACK pls;
	pls = (PLINKSTACK)AllocateEx( sizeof( LINKSTACK ) DBG_RELAY );
	pls->Top = 0;
	pls->Cnt = 0;
	pls->Max = max_entries;
	return pls;
}
//--------------------------------------------------------------------------
 PLINKSTACK  CreateLinkStackEx ( DBG_VOIDPASS )
{
	return CreateLinkStackLimitedEx( 0 DBG_RELAY );
}
//--------------------------------------------------------------------------
 void  DeleteLinkStackEx ( PLINKSTACK *pls DBG_PASS )
{
	if( pls && *pls )
	{
		ReleaseEx( *pls DBG_RELAY );
		*pls = 0;
	}
}
//--------------------------------------------------------------------------
POINTER  PeekLinkEx ( PLINKSTACK *pls, INDEX n )
{
	// should lock - but it's fast enough?
	POINTER p = NULL;
	if( pls && (*pls) && n >= (*pls)->Top )
		return NULL;
	if( pls && *pls && ((*pls)->Top-n) )
		p = (*pls)->pNode[(*pls)->Top-(n+1)];
	else
		return NULL;
	return p;
}
//--------------------------------------------------------------------------
POINTER  PeekLink ( PLINKSTACK *pls )
{
	return PeekLinkEx( pls, 0 );
}
//--------------------------------------------------------------------------
POINTER  PopLink ( PLINKSTACK *pls )
{
	if( pls && *pls && (*pls)->Top )
		return (*pls)->pNode[--(*pls)->Top];
	return NULL;
}
//--------------------------------------------------------------------------
static PLINKSTACK ExpandStackEx( PLINKSTACK *stack, INDEX entries DBG_PASS )
{
	PLINKSTACK pNewStack;
	if( *stack )
		entries += (*stack)->Cnt;
	pNewStack = (PLINKSTACK)AllocateEx( my_offsetof( stack, pNode[entries] ) DBG_RELAY );
	if( *stack )
	{
		PLINKSTACK pls = (*stack);
		MemCpy( pNewStack->pNode, (*stack)->pNode, (*stack)->Cnt * sizeof(POINTER) );
		pNewStack->Top = (*stack)->Top;
		pNewStack->Max = (*stack)->Max;
		*stack = pNewStack;
		ReleaseEx( pls DBG_RELAY );
	}
	else
	{
		pNewStack->Top = 0;
		pNewStack->Max = 0;
		*stack = pNewStack;
	}
	pNewStack->Cnt = entries;
	return pNewStack;
}
//--------------------------------------------------------------------------
 PLINKSTACK  PushLinkEx ( PLINKSTACK *pls, POINTER p DBG_PASS )
{
	if( !pls )
		return NULL;
	// should lock this thing :)
	if( !*pls ||
		 (*pls)->Top == (*pls)->Cnt )
	{
		ExpandStackEx( pls, ((*pls)?((*pls)->Max):0)+8 DBG_RELAY );
	}
	if( (*pls)->Max )
		if( ((*pls)->Top) >= (*pls)->Max )
		{
			MemCpy( (*pls)->pNode, (*pls)->pNode + 1, (*pls)->Top - 1 );
			(*pls)->Top--;
		}
	(*pls)->pNode[(*pls)->Top] = p;
	(*pls)->Top++;
	return (*pls);
}
#ifdef __cplusplus
//namespace link_stack
}
#endif
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
#ifdef __cplusplus
		namespace data_stack {
#endif
 POINTER  PopData ( PDATASTACK *pds )
{
	POINTER p = NULL;
	if( (pds) && (*pds) && (*pds)->Top )
	{
		 (*pds)->Top--;
		p = (*pds)->data + ( (*pds)->Size * ((*pds)->Top) );
	}
	return p;
}
//--------------------------------------------------------------------------
static PDATASTACK ExpandDataStackEx( PDATASTACK *ppds, INDEX entries DBG_PASS )
{
	PDATASTACK pNewStack;
	PDATASTACK pds = (*ppds);
	if( !pds )
		return NULL;
	entries += pds->Cnt;
	pNewStack = (PDATASTACK)AllocateEx( sizeof( DATASTACK ) + ( (*ppds)->Size * entries ) - 1 DBG_RELAY );
	MemCpy( pNewStack->data, (*ppds)->data, (*ppds)->Cnt * (*ppds)->Size );
	pNewStack->Cnt = entries;
	pNewStack->Size = (*ppds)->Size;
	pNewStack->Top = (*ppds)->Top;
	(*ppds) = pNewStack;
	ReleaseEx( pds DBG_RELAY );
	return pNewStack;
}
//--------------------------------------------------------------------------
 PDATASTACK  PushDataEx ( PDATASTACK *pds, POINTER pdata DBG_PASS )
{
	if( pds && *pds )
	{
		if( (*pds)->Top == (*pds)->Cnt )
		{
			ExpandDataStackEx( pds, 1 DBG_RELAY );
		}
		if( (*pds)->Max )
			if( ((*pds)->Top) >= (*pds)->Max )
			{
				MemCpy( (*pds)->data, (*pds)->data + (*pds)->Size, ( (*pds)->Top - 1 ) * (*pds)->Size );
				(*pds)->Top--;
			}
		MemCpy( (*pds)->data + ((*pds)->Top * (*pds)->Size ), pdata, (*pds)->Size );
		(*pds)->Top++;
		return (*pds);
	}
	if( pds )
		return *pds;
	return NULL;
}
//--------------------------------------------------------------------------
 POINTER  PeekDataEx ( PDATASTACK *pds, INDEX nBack )
{
	POINTER p = NULL;
	nBack++;
	if( !(*pds) )
		return NULL;
	if( ( (int)((*pds)->Top) - (int)nBack ) >= 0 )
		p = (*pds)->data + ( (*pds)->Size * ((*pds)->Top - nBack) );
	return p;
}
//--------------------------------------------------------------------------
 POINTER  PeekData ( PDATASTACK *pds )
{
	POINTER p = NULL;
	if( pds && *pds && (*pds)->Top )
		p = (*pds)->data + ( (*pds)->Size * ((*pds)->Top-1) );
	return p;
}
//--------------------------------------------------------------------------
void  EmptyDataStack( PDATASTACK *pds )
{
	if( pds && *pds )
		(*pds)->Top = 0;
}
//--------------------------------------------------------------------------
 PDATASTACK  CreateDataStackEx ( size_t size DBG_PASS )
{
	return CreateDataStackLimitedEx( size, 0 DBG_RELAY );
}
//--------------------------------------------------------------------------
 PDATASTACK  CreateDataStackLimitedEx ( size_t size, INDEX max_items DBG_PASS )
{
	PDATASTACK pds;
	pds = (PDATASTACK)AllocateEx( sizeof( DATASTACK ) + ( 10 * size ) DBG_RELAY );
	pds->Cnt = 10;
	pds->Top = 0;
	pds->Size = size;
	pds->Max = max_items;
	return pds;
}
//--------------------------------------------------------------------------
void DeleteDataStackEx( PDATASTACK *pds DBG_PASS )
{
	ReleaseEx( *pds DBG_RELAY );
	*pds = NULL;
}
#ifdef __cplusplus
//		namespace data_stack {
}
#endif
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
#ifdef __cplusplus
		namespace queue {
#endif
static struct link_queue_local_data
{
	volatile uint32_t lock;
//#if !USE_CUSTOM_ALLOCER
	volatile PTHREAD thread;
//#endif
} s_link_queue_local, *_link_queue_local;
#define link_queue_local  ((_link_queue_local)?(*_link_queue_local):(s_link_queue_local))
#define link_queue_local_thread  ((_link_queue_local)?(*_link_queue_local).thread:(s_link_queue_local.thread))
#define link_queue_local_lock  ((_link_queue_local)?(&_link_queue_local->lock):(&s_link_queue_local.lock))
PLINKQUEUE CreateLinkQueueEx( DBG_VOIDPASS )
{
	PLINKQUEUE plq = 0;
	plq = (PLINKQUEUE)AllocateEx( MY_OFFSETOF( &plq, pNode[8] ) DBG_RELAY );
#if USE_CUSTOM_ALLOCER
	plq->Lock     = 0;
#endif
	plq->Top      = 0;
	plq->Bottom   = 0;
	plq->Cnt      = 8;
	plq->pNode[0] = NULL;
 // shrug
	plq->pNode[1] = NULL;
	return plq;
}
//--------------------------------------------------------------------------
void DeleteLinkQueueEx( PLINKQUEUE *pplq DBG_PASS )
{
	if( !pplq )
		return;
#if USE_CUSTOM_ALLOCER
retry_lock:
#endif
	while( LockedExchange( link_queue_local_lock, __LINE__ ) )
	{
		Relinquish();
	}
#if USE_CUSTOM_ALLOCER
	if( _link_queue_local )
		_link_queue_local->thread = MakeThread();
	if( !(*pplq) )
	{
		link_queue_local_lock[0] = 0;
		return;
	}
	if( (*pplq)->Lock )
	{
		link_queue_local_lock[0] = 0;
		Relinquish();
		goto retry_lock;
	}
	(*pplq)->Lock = 1;
#endif
	link_queue_local_lock[0] = 0;
	if( pplq )
	{
		if( *pplq )
			ReleaseEx( *pplq DBG_RELAY );
		*pplq = NULL;
	}
#if USE_CUSTOM_ALLOCER
	if( _link_queue_local )
		_link_queue_local->thread = NULL;
#endif
	//link_queue_local_lock[0] = 0;
}
//--------------------------------------------------------------------------
static PLINKQUEUE ExpandLinkQueueEx( PLINKQUEUE *pplq, INDEX entries DBG_PASS )
{
	PLINKQUEUE plqNew = NULL;
#if USE_CUSTOM_ALLOCER
	while( LockedExchange( link_queue_local_lock, __LINE__ ) )
	{
		Relinquish();
	}
	if( _link_queue_local )
		_link_queue_local->thread = MakeThread();
#endif
	if( pplq )
	{
		PLINKQUEUE plq = *pplq;
		INDEX size;
		int prior_logging;
		size = MY_OFFSETOF( pplq, pNode[plq->Cnt + entries] );
		prior_logging = SetAllocateLogging( FALSE );
		plqNew = (PLINKQUEUE)AllocateEx( size DBG_RELAY );
		plqNew->Cnt = plq->Cnt + entries;
		plqNew->Bottom = 0;
		if( plq->Bottom > plq->Top )
		{
			INDEX bottom_half;
			plqNew->Top = (bottom_half = plq->Cnt - plq->Bottom ) + plq->Top;
			MemCpy( plqNew->pNode, plq->pNode + plq->Bottom, sizeof(POINTER)*bottom_half );
			MemCpy( plqNew->pNode + bottom_half, plq->pNode, sizeof(POINTER)*plq->Top );
		}
		else
		{
			plqNew->Top = plq->Top - plq->Bottom;
			MemCpy( plqNew->pNode, plq->pNode + plq->Bottom, sizeof(POINTER)*plqNew->Top );
		}
		//need to make sure plq is always valid; can be trying to get a lock
		(*pplq) = plqNew;
		Release( plq );
		SetAllocateLogging( prior_logging );
	}
#if USE_CUSTOM_ALLOCER
	if( _link_queue_local )
		_link_queue_local->thread = NULL;
	link_queue_local_lock[0] = 0;
#endif
	return plqNew;
}
//--------------------------------------------------------------------------
 PLINKQUEUE  EnqueLinkEx ( PLINKQUEUE *pplq, POINTER link DBG_PASS )
{
	INDEX tmp;
	PLINKQUEUE plq;
#if USE_CUSTOM_ALLOCER
	int keep_lock = 0;
#endif
	if( !pplq )
		return NULL;
	if( !(*pplq) )
		*pplq = CreateLinkQueueEx( DBG_VOIDRELAY );
#if USE_CUSTOM_ALLOCER
retry_lock:
#endif
	while( LockedExchange( link_queue_local_lock, __LINE__ ) )
	{
#if USE_CUSTOM_ALLOCER
		if( link_queue_local_thread == MakeThread() )
		{
			keep_lock = 1;
			break;
		}
#endif
		Relinquish();
	}
#if USE_CUSTOM_ALLOCER
	if( _link_queue_local )
		_link_queue_local->thread = MakeThread();
	if( !(*pplq) )
	{
		if( !keep_lock )
			link_queue_local_lock[0] = 0;
		return (*pplq);
	}
	if( (*pplq)->Lock )
	{
		if( !keep_lock )
			link_queue_local_lock[0] = 0;
		Relinquish();
		goto retry_lock;
	}
	(*pplq)->Lock = 1;
	if( !keep_lock )
	{
		if( _link_queue_local )
			_link_queue_local->thread = NULL;
		link_queue_local_lock[0] = 0;
	}
#else
	if( !(*pplq) )
	{
		//it could have been deallocated
		link_queue_local_lock[0] = 0;
		return (*pplq);
	}
#endif
	plq = *pplq;
	//else
	//	s_link_queue_local.thread = MakeThread();
	if( link )
	{
		tmp = plq->Top + 1;
		if( tmp >= plq->Cnt )
			tmp -= plq->Cnt;
 // collided with self...
		if( tmp == plq->Bottom )
		{
			plq = ExpandLinkQueueEx( pplq, 16 DBG_RELAY );
 // should be room at the end of phsyical array....
			tmp = plq->Top + 1;
		}
		plq->pNode[plq->Top] = link;
		plq->Top = tmp;
	}
	*pplq = plq;
#if USE_CUSTOM_ALLOCER
	plq->Lock = 0;
#endif
	link_queue_local_lock[0] = 0;
	return plq;
}
//--------------------------------------------------------------------------
void EnqueLinkNLEx( PLINKQUEUE *pplq, POINTER link DBG_PASS )
 {
	INDEX tmp, t, c;
	PLINKQUEUE plq;
	if( !pplq )
		return;
	if( !( *pplq ) )
		*pplq = CreateLinkQueueEx( DBG_VOIDRELAY );
	plq = *pplq;
	if( link )
	{
		tmp = (t=plq->Top) + 1;
		if( tmp >= ( c = plq->Cnt ) )
			tmp -= c;
 // collided with self...
		if( tmp == ( plq->Bottom ) )
		{
			plq = ExpandLinkQueueEx( pplq, 16 DBG_RELAY );
 // should be room at the end of phsyical array....
			tmp = (t=plq->Top) + 1;
		}
		plq->pNode[t] = link;
		plq->Top = tmp;
	}
	*pplq = plq;
 }
 //--------------------------------------------------------------------------
 PLINKQUEUE  PrequeLinkEx ( PLINKQUEUE *pplq, POINTER link DBG_PASS )
{
	INDEX tmp;
	PLINKQUEUE plq;
	if( !pplq )
		return NULL;
	if( !(*pplq) )
		*pplq = CreateLinkQueueEx( DBG_VOIDRELAY );
#if USE_CUSTOM_ALLOCER
retry_lock:
#endif
	while( LockedExchange( link_queue_local_lock, __LINE__ ) )
		Relinquish();
#if USE_CUSTOM_ALLOCER
	if( !(*pplq) )
	{
		link_queue_local_lock[0] = 0;
		return NULL;
	}
	if( (*pplq)->Lock )
	{
		link_queue_local_lock[0] = 0;
		Relinquish();
		goto retry_lock;
	}
	(*pplq)->Lock = 1;
	link_queue_local_lock[0] = 0;
#else
	if( !(*pplq) )
	{
		//it could have been deallocated
		link_queue_local_lock[0] = 0;
		return (*pplq);
	}
#endif
	plq = *pplq;
	if( link )
	{
		tmp = plq->Bottom - 1;
		if( tmp & 0x80000000 )
			tmp += plq->Cnt;
 // collided with self...
		if( tmp == plq->Top )
		{
			plq = ExpandLinkQueueEx( pplq, 16 DBG_RELAY );
 // should be room at the end of phsyical array....
			tmp = plq->Cnt - 1;
		}
		plq->pNode[tmp] = link;
		plq->Bottom = tmp;
	}
#if USE_CUSTOM_ALLOCER
	plq->Lock = 0;
#endif
	link_queue_local_lock[0] = 0;
	return plq;
}
//--------------------------------------------------------------------------
 LOGICAL  IsQueueEmpty ( PLINKQUEUE *pplq  )
{
	if( !pplq || !(*pplq) ||
		(*pplq)->Bottom == (*pplq)->Top )
		return TRUE;
	return FALSE;
}
//--------------------------------------------------------------------------
 INDEX  GetQueueLength ( PLINKQUEUE plq )
{
	INDEX used = 0;
	if( plq )
	{
		used = plq->Top - plq->Bottom;
		if( plq->Top < plq->Bottom )
			used += plq->Cnt;
	}
	return used;
}
//--------------------------------------------------------------------------
POINTER  PeekQueueEx	 ( PLINKQUEUE plq, int idx )
{
	size_t top;
	if( !plq )
		return NULL;
	if( idx < 0 )
	{
		idx++;
		for( top = plq->Top?(plq->Top - 1):(plq->Cnt-1)
			 ; idx && top != plq->Bottom
			  ; )
		{
			idx++;
			if( !top ) top = plq->Cnt - 1;
			else top--;
		}
		if( idx == 0 )
		{
			if( plq->Top == plq->Bottom )
				return NULL;
			return plq->pNode[top];
		}
	}
	else
	{
		for( top = plq->Bottom
			 ; idx != -1 && top != plq->Top
			  ; )
		{
			if( idx ) {
				top++;
				if( top >= plq->Cnt )
					top-=plq->Cnt;
				idx--;
			}else { idx = -1; break; }
		}
		if( idx == -1 )
			return plq->pNode[top];
	}
	return NULL;
}
POINTER  PeekQueue ( PLINKQUEUE plq )
{
	return PeekQueueEx( plq, 0 );
}
//--------------------------------------------------------------------------
POINTER  DequeLink ( PLINKQUEUE *pplq )
{
	POINTER p;
	INDEX tmp;
	if( pplq && *pplq )
	{
#if USE_CUSTOM_ALLOCER
		int keep_lock = 0;
#endif
		uint32_t priorline;
#if USE_CUSTOM_ALLOCER
retry_lock:
#endif
		while( ( priorline = LockedExchange( link_queue_local_lock, __LINE__ ) ) )
		{
#if USE_CUSTOM_ALLOCER
			if( link_queue_local_thread == MakeThread() )
			{
				keep_lock = 1;
				break;
			}
#endif
			Relinquish();
		}
#if USE_CUSTOM_ALLOCER
		if( !pplq )
		{
			if( !keep_lock )
				link_queue_local_lock[0] = 0;
			return NULL;
		}
		if( (*pplq)->Lock )
		{
			if( !keep_lock )
				link_queue_local_lock[0] = 0;
			Relinquish();
			goto retry_lock;
		}
		(*pplq)->Lock = 1;
		if( !keep_lock )
			link_queue_local_lock[0] = 0;
#else
		if( !(*pplq) )
		{
			//it could have been deallocated
			link_queue_local_lock[0] = 0;
			return (*pplq);
		}
#endif
	}
	else
		return NULL;
	p = NULL;
	if( (*pplq)->Bottom != (*pplq)->Top )
	{
		tmp = (*pplq)->Bottom + 1;
		if( tmp >= (*pplq)->Cnt )
			tmp -= (*pplq)->Cnt;
		p = (*pplq)->pNode[(*pplq)->Bottom];
		(*pplq)->Bottom = tmp;
	}
#if USE_CUSTOM_ALLOCER
	(*pplq)->Lock = 0;
#endif
	link_queue_local_lock[0] = 0;
	return p;
}
POINTER  DequeLinkNL( PLINKQUEUE *pplq )
{
	INDEX b, t, c, tmp;
	POINTER p;
	if( !pplq || !*pplq )
		return NULL;
	p = NULL;
	if( (b=( *pplq )->Bottom) != (t=( *pplq )->Top) )
	{
		tmp = b + 1;
		if( tmp >= ( c = ( *pplq )->Cnt ) )
			tmp -= c;
		p = ( *pplq )->pNode[b];
		( *pplq )->Bottom = tmp;
	}
	return p;
}
#ifdef __cplusplus
//		namespace queue {
}
#endif
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
#ifdef __cplusplus
		namespace data_queue {
#endif
static struct data_queue_local_data
{
	volatile uint32_t lock;
} s_data_queue_local, *_data_queue_local;
#define data_queue_local  ((_data_queue_local)?(*_data_queue_local):(s_data_queue_local))
#define data_queue_local_lock ((_data_queue_local)?(&_data_queue_local->lock):(&s_data_queue_local.lock))
PDATAQUEUE CreateDataQueueEx( INDEX size DBG_PASS )
{
	PDATAQUEUE pdq;
	pdq = (PDATAQUEUE)AllocateEx( ( ( sizeof( DATAQUEUE ) + (2*size) ) - 1 ) DBG_RELAY );
	pdq->Top      = 0;
	pdq->Bottom	  = 0;
	pdq->ExpandBy = 16;
	pdq->Size     = size;
	pdq->Cnt      = 2;
	return pdq;
}
//--------------------------------------------------------------------------
void DeleteDataQueueEx( PDATAQUEUE *ppdq DBG_PASS )
{
	if( ppdq )
	{
		if( *ppdq )
			ReleaseEx( *ppdq DBG_RELAY );
		*ppdq = NULL;
	}
}
//--------------------------------------------------------------------------
static PDATAQUEUE ExpandDataQueueEx( PDATAQUEUE *ppdq, INDEX entries DBG_PASS )
{
	PDATAQUEUE pdqNew = NULL;
	if( ppdq )
	{
		PDATAQUEUE pdq = *ppdq;
		//pdq->Cnt += entries;
		pdqNew = (PDATAQUEUE)AllocateEx( (uint32_t)offsetof( DATAQUEUE, data[0] ) + ((pdq->Cnt+entries)  * pdq->Size) DBG_RELAY );
		pdqNew->Cnt = pdq->Cnt + entries;
		pdqNew->ExpandBy = pdq->ExpandBy;
		pdqNew->Bottom = 0;
		pdqNew->Size = pdq->Size;
		if( pdq->Bottom > pdq->Top )
		{
			INDEX bottom_half;
			/* if you see '- entries' in a diff... it was decided to not add it to the original queue above, instead */
			pdqNew->Top = (bottom_half = ( pdq->Cnt ) - pdq->Bottom ) + pdq->Top;
			MemCpy( pdqNew->data
				, pdq->data + (pdq->Bottom * pdq->Size)
				, pdq->Size * bottom_half );
			MemCpy( pdqNew->data + ( bottom_half * pdq->Size )
				, pdq->data
				, pdq->Size * pdq->Top );
		}
		else
		{
			pdqNew->Top = pdq->Top - pdq->Bottom;
			MemCpy( pdqNew->data
				, pdq->data + (pdq->Bottom * pdq->Size)
				, pdq->Size * pdqNew->Top );
		}
		(*ppdq) = pdqNew;
		Release( pdq );
	}
	return pdqNew;
}
PDATAQUEUE  CreateLargeDataQueueEx( INDEX size, INDEX entries, INDEX expand DBG_PASS )
{
	PDATAQUEUE pdq = CreateDataQueueEx( size DBG_RELAY );
	pdq->ExpandBy = expand;
	ExpandDataQueueEx( &pdq, entries DBG_RELAY );
	return pdq;
}
//--------------------------------------------------------------------------
 PDATAQUEUE  EnqueDataEx ( PDATAQUEUE *ppdq, POINTER link DBG_PASS )
{
	INDEX tmp;
	PDATAQUEUE pdq;
	if( !ppdq )
		return NULL;
	if( !(*ppdq) )
 // cannot create this - no idea how big.
		return NULL;
	while( LockedExchange( data_queue_local_lock, 1 ) )
		Relinquish();
	pdq = *ppdq;
	if( link )
	{
		tmp = pdq->Top + 1;
		if( tmp >= pdq->Cnt )
			tmp -= pdq->Cnt;
 // collided with self...
		if( tmp == pdq->Bottom )
		{
			pdq = ExpandDataQueueEx( ppdq, (*ppdq)->ExpandBy DBG_RELAY );
 // should be room at the end of phsyical array....
			tmp = pdq->Top + 1;
		}
		MemCpy( pdq->data + ( pdq->Top * pdq->Size ), link, pdq->Size );
		pdq->Top = tmp;
	}
	data_queue_local_lock[0] = 0;
	return pdq;
}
//--------------------------------------------------------------------------
 PDATAQUEUE  PrequeDataEx ( PDATAQUEUE *ppdq, POINTER link DBG_PASS )
{
	INDEX tmp;
	PDATAQUEUE pdq;
	if( !ppdq )
		return NULL;
	if( !(*ppdq) )
 // cannot create this - no idea how big.
		return NULL;
	while( LockedExchange( data_queue_local_lock, 1 ) )
		Relinquish();
	pdq = *ppdq;
	if( link )
	{
		tmp = pdq->Bottom - 1;
		if( tmp > 0x80000000 )
			tmp += pdq->Cnt;
 // collided with self...
		if( tmp == pdq->Top )
		{
			// expand re-aligns queue elements so bottom is 0 and top is N
			// so the bottom will always wrap when we try to add to the beginning...
			pdq = ExpandDataQueueEx( ppdq, (*ppdq)->ExpandBy DBG_RELAY );
 // should be room at the end of phsyical array....
			tmp = pdq->Cnt - 1;
		}
		MemCpy( pdq->data + ( tmp * pdq->Size ), link, pdq->Size );
		pdq->Bottom = tmp;
	}
	data_queue_local_lock[0] = 0;
	return pdq;
}
//--------------------------------------------------------------------------
 LOGICAL  IsDataQueueEmpty ( PDATAQUEUE *ppdq  )
{
	if( !ppdq || !(*ppdq) ||
		(*ppdq)->Bottom == (*ppdq)->Top )
		return TRUE;
	return FALSE;
}
//--------------------------------------------------------------------------
 LOGICAL  DequeData ( PDATAQUEUE *ppdq, POINTER result )
{
	LOGICAL p;
	INDEX tmp;
	if( ppdq && *ppdq )
		while( LockedExchange( data_queue_local_lock, 1 ) )
			Relinquish();
	else
		return 0;
	p = 0;
	if( (*ppdq)->Bottom != (*ppdq)->Top )
	{
		tmp = (*ppdq)->Bottom + 1;
		if( tmp >= (*ppdq)->Cnt )
			tmp -= (*ppdq)->Cnt;
		if( result )
			MemCpy( result
					, (*ppdq)->data + (*ppdq)->Bottom * (*ppdq)->Size
					, (*ppdq)->Size );
		p = 1;
		(*ppdq)->Bottom = tmp;
	}
	data_queue_local_lock[0] = 0;
	return p;
}
//--------------------------------------------------------------------------
 LOGICAL  UnqueData ( PDATAQUEUE *ppdq, POINTER result )
{
	LOGICAL p;
	INDEX tmp;
	if( ppdq && *ppdq )
		while( LockedExchange( data_queue_local_lock, 1 ) )
			Relinquish();
	else
		return 0;
	p = 0;
	if( (*ppdq)->Bottom != (*ppdq)->Top )
	{
		tmp = (*ppdq)->Top;
		if( tmp )
			tmp--;
		else
			tmp = ((*ppdq)->Cnt)-1;
		if( result )
			MemCpy( result
					, (*ppdq)->data + tmp * (*ppdq)->Size
					, (*ppdq)->Size );
		p = 1;
		(*ppdq)->Top = tmp;
	}
	data_queue_local_lock[0] = 0;
	return p;
}
//--------------------------------------------------------------------------
// zero is the first,
#undef PeekDataQueueEx
 LOGICAL  PeekDataQueueEx ( PDATAQUEUE *ppdq, POINTER result, INDEX idx )
{
	INDEX top;
	if( ppdq && *ppdq )
		while( LockedExchange( data_queue_local_lock, 1 ) )
			Relinquish();
	else
		return 0;
	// cannot get invalid id.
	if( idx != INVALID_INDEX )
	{
		for( top = (*ppdq)->Bottom;
			 idx != INVALID_INDEX && top != (*ppdq)->Top
			 ; )
		{
			idx--;
			if( idx != INVALID_INDEX )
			{
				top++;
				if( (top) >= (*ppdq)->Cnt )
					top = top-(*ppdq)->Cnt;
			}
		}
		if( idx == INVALID_INDEX )
		{
			MemCpy( result, (*ppdq)->data + top * (*ppdq)->Size, (*ppdq)->Size );
			data_queue_local_lock[0] = 0;
			return 1;
			//return (*ppdq)->pNode + top;
		}
	}
	data_queue_local_lock[0] = 0;
	return 0;
}
#undef PeekDataQueue
 LOGICAL  PeekDataQueue ( PDATAQUEUE *ppdq, POINTER result )
{
	return PeekDataQueueEx( ppdq, result, 0 );
}
void  EmptyDataQueue ( PDATAQUEUE *ppdq )
{
	if( ppdq && *ppdq )
	{
		while( LockedExchange( data_queue_local_lock, 1 ) )
			Relinquish();
		(*ppdq)->Bottom = (*ppdq)->Top = 0;
		data_queue_local_lock[0] = 0;
	}
}
#ifdef __cplusplus
//		namespace data_queue {
};
#endif
PRIORITY_PRELOAD( InitLocals, NAMESPACE_PRELOAD_PRIORITY + 1 )
{
#ifdef __cplusplus
	RegisterAndCreateGlobal((POINTER*)&list::_list_local, sizeof( *list::_list_local ), WIDE("_list_local") );
	RegisterAndCreateGlobal((POINTER*)&data_list::_data_list_local, sizeof( *data_list::_data_list_local ), WIDE("_data_list_local") );
	RegisterAndCreateGlobal((POINTER*)&queue::_link_queue_local, sizeof( *queue::_link_queue_local ), WIDE("_link_queue_local") );
	RegisterAndCreateGlobal((POINTER*)&data_queue::_data_queue_local, sizeof( *data_queue::_data_queue_local ), WIDE("_data_queue_local") );
#else
	SimpleRegisterAndCreateGlobal( _list_local );
	SimpleRegisterAndCreateGlobal( _data_list_local );
	SimpleRegisterAndCreateGlobal( _link_queue_local );
	SimpleRegisterAndCreateGlobal( _data_queue_local );
#endif
}
#ifdef __cplusplus
 //namespace sack {
};
 //	namespace containers {
};
#endif
//--------------------------------------------------------------
// $Log: typecode.c,v $
// Revision 1.47  2005/05/25 16:50:30  d3x0r
// Synch with working repository.
//
// Revision 1.56  2005/05/20 23:15:13  jim
// Remove a noisy logging statement
//
// Revision 1.55  2005/05/16 23:18:22  jim
// Allocate the correct amount of space for the message queue - it's a MSGQUEUE not a DATAQUEUE.  Also implement DequeMessage() in such a way that the waited for message ID can change.
//
// Revision 1.54  2005/05/02 17:02:58  jim
// Moved the process-wait information to a seperate queue... does not work inline with normal messages...
//
// Revision 1.53  2005/04/20 23:38:20  jim
// Fixed leaving the critical section under a loop condition that resulted in error.
//
// Revision 1.52  2005/04/18 15:55:59  jim
// Much logging added to sack's implementation of SYSV msgq communications.
//
// Revision 1.51  2005/03/22 12:33:50  panther
// Restore disabled message queue logging
//
// Revision 1.50  2005/03/17 02:23:53  panther
// Checkpoint - working on message server abstraction interface... some of this seems to work quite well, some of this is still broken very badly...
//
// Revision 1.49  2005/03/14 16:04:03  panther
// If someone is waiting for any message, then they are definatly waiting for the currently enquing message.
//
// Revision 1.48  2005/01/27 07:18:34  panther
// Linux cleaned.
//
// Revision 1.47  2004/12/19 15:44:40  panther
// Extended set methods to interact with raw index numbers
//
// Revision 1.46  2004/10/25 10:40:00  d3x0r
// Linux compilation cleaning requirements...
//
// Revision 1.45  2004/10/02 19:49:57  d3x0r
// Fix logging... trying to track down multiple update display issues.... keys are queued, events are locally queued...
//
// Revision 1.44  2004/09/30 22:02:43  d3x0r
// checkpoing
//
// Revision 1.43  2004/09/30 09:42:52  d3x0r
// Fixed message queues for single app, all wraps, and nearly for two apps, but when removing logging, lost stability :(
//
// Revision 1.42  2004/09/30 01:14:48  d3x0r
// Cleaned up consistancy of PID and thread ID... extended message service a bit to supply event PID both ways.
//
// Revision 1.41  2004/09/29 16:43:03  d3x0r
// fixed queues a bit - added a test wait function for timers/threads
//
// Revision 1.40  2004/09/29 00:49:00  d3x0r
// Store waiting thread IDs IN the message queue... need to figure out how to shuffle these around.
//
// Revision 1.39  2004/09/24 08:09:49  d3x0r
// Test tial meeting the head...
//
// Revision 1.38  2004/09/23 11:07:33  d3x0r
// Minor adjustments...
//
// Revision 1.37  2004/09/23 00:36:55  d3x0r
// Fix result code when error no message and no wait... fix test for read messages and end of queue messages.
//
// Revision 1.36  2004/08/16 06:32:10  d3x0r
// Fix message queue routines... protect against no handle
//
// Revision 1.35  2004/07/13 04:17:49  d3x0r
// clean some warnings, and fix definiton of PRELOAD to be compiler friendly.
//
// Revision 1.34  2004/06/12 09:09:41  d3x0r
// ug - if queue is empty peek must be NULL...
//
// Revision 1.33  2004/05/24 16:40:29  d3x0r
// Add PeekQueue and GetQUeueLength
//
// Revision 1.32  2003/11/28 20:21:35  panther
// Add and fix EmptyList
//
// Revision 1.31  2003/10/31 02:24:53  panther
// Modified test to take variable msg count.
//
// Revision 1.30  2003/10/26 23:40:46  panther
// minor type fixes
//
// Revision 1.29  2003/10/26 23:32:17  panther
// Looks like most issues with simple message queuing are done.
//
// Revision 1.28  2003/10/22 10:45:40  panther
// Handle null lists in find
//
// Revision 1.27  2003/10/21 01:39:37  panther
// Fixed some issues with new perma-wait critical sections...
//
// Revision 1.26  2003/10/20 03:01:21  panther
// Fix getmythreadid - split depending if getpid returns ppid or pid.
// Fix memory allocator to init region correctly...
// fix initial status of found thred to reflect sleeping
// in /proc/#/status
//
// Revision 1.25  2003/10/20 00:04:21  panther
// Extend OpenSpace in SharedMem
// revise msgqueue operations to more resemble sysVipc msgq
//
// Revision 1.24  2003/10/18 23:41:04  panther
// Checkpoint... probably defuct
//
// Revision 1.23  2003/10/18 04:43:00  panther
// Quick patch...
//
// Revision 1.22  2003/10/17 00:56:05  panther
// Rework critical sections.
// Moved most of heart of these sections to timers.
// When waiting, sleep forever is used, waking only when
// released... This is preferred rather than continuous
// polling of section with a Relinquish.
// Things to test, event wakeup order uner linxu and windows.
// Even see if the wake ever happens.
// Wake should be able to occur across processes.
// Also begin implmeenting MessageQueue in containers....
// These work out of a common shared memory so multiple
// processes have access to this region.
//
// Revision 1.21  2003/08/20 08:07:13  panther
// some fixes to blot scaled... fixed to makefiles test projects... fixes to export containters lib funcs
//
// Revision 1.20  2003/07/25 10:21:57  panther
// Fix callback for foralllinks
//
// Revision 1.19  2003/05/12 01:31:52  panther
// Fix return
//
// Revision 1.18  2003/05/02 01:11:26  panther
// Many minor fixes, tweaks....
//
// Revision 1.17  2003/04/21 11:46:52  panther
// Ug - forgot a commit somewhere... return pointer at set data item
//
// Revision 1.16  2003/04/20 08:14:07  panther
// *** empty log message ***
//
// Revision 1.15  2003/04/12 20:52:46  panther
// Added new type contrainer - data list.
//
// Revision 1.14  2003/03/31 01:11:28  panther
// Tweaks to work better under service application
//
// Revision 1.13  2003/03/30 21:15:57  panther
// Added EX functions to pass application source to DataStack allocations
//
// Revision 1.12  2003/03/30 00:14:36  panther
// fix pop stack data function
//
// Revision 1.11  2003/01/28 16:37:48  panther
// More logging extended logging
//
// Revision 1.10  2003/01/27 09:20:34  panther
// Error in passing debug argument to create queue
//
// Revision 1.9  2003/01/22 17:10:09  panther
// Added forwarding in EnqueLink To CreateQueue
//
// Revision 1.8  2002/11/06 09:49:17  panther
// Fixed data-queue allocation/copy.
//
// Revision 1.7  2002/11/04 09:29:50  panther
// Added container class - DATAQUEUE.
//
//
//  - Added DataQueue to compliment LinkQueue  (datastack/linkstack)
//  - Added EmptyDataStack method to quickly remove all items on stack.
// Revision 1.6  2002/07/15 08:28:56  panther
// Fixed some debug passing to allocate.
//
//
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   code to provide a robust text class for C
 *   Parsing, text substitution, replacment, phrase splitting
 *   options for paired parsing of almost all pairable symbols
 *   used in common language.
 *
 *
 * see also - include/typelib.h
 *
 */
#ifdef _UNICODE
#define _INCLUDE_NLS
#endif
#define NO_UNICODE_C
#ifdef __cplusplus
namespace sack {
namespace containers {
namespace text {
	using namespace sack::memory;
	using namespace sack::logging;
	using namespace sack::containers::queue;
#endif
typedef PTEXT (CPROC*GetTextOfProc)( uintptr_t, POINTER );
typedef struct text_exension_tag {
	uint32_t bits;
	GetTextOfProc TextOf;
	uintptr_t psvData;
}  TEXT_EXTENSION, *PTEXT_EXTENSION;
typedef struct vartext_tag {
	TEXTSTR collect_text;
	size_t collect_used;
	size_t collect_avail;
	size_t expand_by;
	PTEXT collect;
	PTEXT commit;
} VARTEXT;
//#ifdef __cplusplus
static PTEXT newline;
static PTEXT blank;
PRELOAD( AllocateDefaults )
{
	newline = (PTEXT)SegCreateFromText( WIDE("") );
	blank = (PTEXT)SegCreateFromText( WIDE(" ") );
}
//#define newline (*newline)
//#define blank	(*blank)
//#else
//__declspec( dllexport ) TEXT newline = { TF_STATIC, NULL, NULL, {1,1},{0,WIDE("")}};
//__declspec( dllexport ) TEXT blank = { TF_STATIC, NULL, NULL, {1,1},{1,WIDE(" ")}};
//#endif
static PLIST pTextExtensions;
//---------------------------------------------------------------------------
PTEXT SegCreateEx( size_t size DBG_PASS )
{
	PTEXT pTemp;
#if defined( _MSC_VER )
	//if( size > 0x8000 )
	//	_asm int 3;
#endif
	pTemp = (PTEXT)AllocateEx( sizeof(TEXT) + (size
#ifdef _MSC_VER
		+ 1
#endif
		)*sizeof(TEXTCHAR)
 // good thing [1] is already counted.
		DBG_RELAY );
	MemSet( pTemp, 0, sizeof(TEXT) + (size*sizeof(TEXTCHAR)) );
	pTemp->format.flags.prior_background = 1;
	pTemp->format.flags.prior_foreground = 1;
 // physical space IS one more....
	pTemp->data.size = size;
	return pTemp;
}
//---------------------------------------------------------------------------
PTEXT GetIndirect(PTEXT segment )
{
	if( !segment )
		return NULL;
	if( (segment->flags&TF_APPLICATION) )
	{
		INDEX idx;
		PTEXT_EXTENSION pte;
		LIST_FORALL( pTextExtensions, idx, PTEXT_EXTENSION, pte )
		{
			if( pte->bits & segment->flags )
			{
				// size is used as a pointer...
				segment = pte->TextOf( pte->psvData, (POINTER)segment->data.size );
				break;
			}
		}
		if( !pte )
			return NULL;
		return segment;
	}
	// if it's not indirect... don't result..
	if( !(segment->flags&TF_INDIRECT) )
		return NULL;
	return (PTEXT)(segment->data.size);
}
//---------------------------------------------------------------------------
TEXTSTR GetText( PTEXT segment )
{
	while( segment )
	{
		if( segment->flags & (TF_INDIRECT|TF_APPLICATION) )
		{
			segment = GetIndirect( segment );
		}
		else
			return segment->data.data;
	}
	return NULL;
}
//---------------------------------------------------------------------------
size_t GetTextSize( PTEXT segment )
{
	while( segment )
	{
		if( segment->flags & (TF_INDIRECT|TF_APPLICATION) )
		{
			segment = GetIndirect( segment );
		}
		else
			if( !segment->data.size )
			{
				if( segment->flags & IS_DATA_FLAGS )
				{
					//lprintf( "Is Data falgs returns 2. %08x", segment->flags & IS_DATA_FLAGS );
 // is data even if is not acurate....
					return segment->data.size;
				}
				break;
			}
			else
				return segment->data.size;
	}
	return 0;
}
//---------------------------------------------------------------------------
uint32_t GetTextFlags( PTEXT segment )
{
	if( !segment )
		return 0;
	if( segment->flags & (TF_INDIRECT|TF_APPLICATION) )
		return GetTextFlags( GetIndirect( segment ) );
	return segment->flags;
}
//---------------------------------------------------------------------------
void SegCopyFormat( PTEXT to_this, PTEXT copy_this )
{
	if( to_this && copy_this )
	{
		if( copy_this && !( copy_this->flags & TF_FORMATPOS ) )
		{
			to_this->format.position.offset.tabs = copy_this->format.position.offset.tabs;
			to_this->format.position.offset.spaces = copy_this->format.position.offset.spaces;
		}
		else
		{
			// copy absolute positioning...
		}
	}
}
//---------------------------------------------------------------------------
PTEXT SegDuplicateEx( PTEXT pText DBG_PASS )
{
	PTEXT t;
	size_t n;
	if( pText )
	{
		if( pText->flags & TF_APPLICATION )
		{
			t = SegCreateIndirect( (PTEXT)pText->data.size );
			t->format = pText->format;
			t->flags = pText->flags;
		}
		else if( pText->flags & TF_INDIRECT )
		{
			t = SegCreateIndirectEx( SegDuplicateEx( GetIndirect( pText ) DBG_RELAY ) DBG_RELAY );
			t->format = pText->format;
			// some other mask needs to be here.. the getindirect
			// will have other flags...
			t->flags = pText->flags;
		}
		else
		{
			t = SegCreateEx( n = GetTextSize( pText ) DBG_RELAY );
			t->format = pText->format;
			MemCpy( GetText(t), GetText(pText), sizeof( TEXTCHAR ) * ( n + 1 ) );
			t->flags = pText->flags;
		}
		t->flags &= ~(TF_DEEP|TF_STATIC);
		return t;
	}
	return NULL;
}
//---------------------------------------------------------------------------
PTEXT LineDuplicateEx( PTEXT pText DBG_PASS )
{
	PTEXT pt;
	pt = pText;
	while( pt )
	{
		if( !(pt->flags&TF_STATIC) )
			HoldEx( (uint8_t*)pt DBG_RELAY  );
		if( (pt->flags & TF_INDIRECT ) || (pt->flags&TF_APPLICATION) )
			LineDuplicateEx( GetIndirect( pt ) DBG_RELAY );
		pt = NEXTLINE( pt );
	}
	return pText;
}
//---------------------------------------------------------------------------
PTEXT TextDuplicateEx( PTEXT pText, int bSingle DBG_PASS )
{
	PTEXT pt;
	PTEXT pDup = NULL, pNew;
	pt = pText;
	while( pt )
	{
		if( (pt->flags & TF_INDIRECT ) && !(pt->flags&TF_APPLICATION) )
		{
			pNew = SegCreateIndirectEx(
			            TextDuplicateEx(
			                  GetIndirect( pt ), bSingle DBG_RELAY ) DBG_RELAY );
			pNew->format.position = pt->format.position;
			pNew->flags |= pt->flags&(IS_DATA_FLAGS);
			pNew->flags |= TF_DEEP;
		}
		else
			pNew = SegDuplicateEx( pt DBG_RELAY );
		pDup = SegAppend( pDup, pNew );
		if( bSingle )
			break;
		pt = NEXTLINE( pt );
	}
	return pDup;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromTextEx( CTEXTSTR text DBG_PASS )
{
	PTEXT pTemp;
	size_t nSize;
	if( text )
	{
		pTemp = SegCreateEx( nSize = StrLen( text ) DBG_RELAY );
		// include nul on copy
		MemCpy( pTemp->data.data, text, sizeof( TEXTCHAR ) * ( nSize + 1 ) );
		return pTemp;
	}
	return NULL;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromCharLenEx( const char *text, size_t len DBG_PASS )
{
	PTEXT pTemp;
	if( text )
	{
#ifdef _UNICODE
		TEXTSTR text_string = CharWConvertLen( text, len );
		pTemp = SegCreateEx( len DBG_RELAY );
		// include nul on copy
		MemCpy( pTemp->data.data, text_string, sizeof( TEXTCHAR ) * ( len + 1 ) );
		Deallocate( TEXTSTR, text_string );
#else
		pTemp = SegCreateEx( len DBG_RELAY );
		MemCpy( pTemp->data.data, text, sizeof( TEXTCHAR ) * ( len + 1 ) );
#endif
		return pTemp;
	}
	return NULL;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromCharEx( const char *text DBG_PASS )
{
	return SegCreateFromCharLenEx( text, strlen( text ) DBG_RELAY );
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromWideLenEx( const wchar_t *text, size_t nSize DBG_PASS )
{
	PTEXT pTemp;
	if( text )
	{
#ifdef _UNICODE
		pTemp = SegCreateEx( nSize DBG_RELAY );
		// include nul on copy
		MemCpy( pTemp->data.data, text, sizeof( TEXTCHAR ) * ( nSize + 1 ) );
#else
		TEXTSTR text_string = WcharConvertLen( text, nSize );
		int outlen;
		for( outlen = 0; text_string[outlen]; outlen++ );
		pTemp = SegCreateEx( outlen DBG_RELAY );
		// include nul on copy
		MemCpy( pTemp->data.data, text_string, sizeof( TEXTCHAR ) * ( outlen + 1 ) );
		Deallocate( TEXTSTR, text_string );
#endif
		return pTemp;
	}
	return NULL;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromWideEx( const wchar_t *text DBG_PASS )
{
	return SegCreateFromWideLenEx( text, wcslen( text ) DBG_RELAY );
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromIntEx( int value DBG_PASS )
{
	PTEXT pResult;
	pResult = SegCreateEx( 12 DBG_RELAY);
#ifdef _UNICODE
	pResult->data.size = swprintf( pResult->data.data, 12, WIDE("%d"), value );
#else
	pResult->data.size = snprintf( pResult->data.data, 12, WIDE("%d"), value );
#endif
	pResult->data.data[11] = 0;
	return pResult;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFrom_64Ex( int64_t value DBG_PASS )
{
	PTEXT pResult;
	pResult = SegCreateEx( 32 DBG_RELAY);
#ifdef _UNICODE
	pResult->data.size = swprintf( pResult->data.data, 32, WIDE("%")_64f, value );
#else
	pResult->data.size = snprintf( pResult->data.data, 32, WIDE("%")_64f, value );
#endif
pResult->data.data[31] = 0;
	return pResult;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromFloatEx( float value DBG_PASS )
{
	PTEXT pResult;
	pResult = SegCreateEx( 32 DBG_RELAY);
#ifdef _UNICODE
	pResult->data.size = swprintf( pResult->data.data, 32, WIDE("%f"), value );
#else
	pResult->data.size = snprintf( pResult->data.data, 32, WIDE("%f"), value );
#endif
	pResult->data.data[31] = 0;
	return pResult;
}
//---------------------------------------------------------------------------
PTEXT SegCreateIndirectEx( PTEXT pText DBG_PASS )
{
	PTEXT pSeg;
 // no data content for indirect...
	pSeg = SegCreateEx( -1 DBG_RELAY );
	pSeg->flags |= TF_INDIRECT;
	pSeg->data.size = (uintptr_t)pText;
	return pSeg;
}
//---------------------------------------------------------------------------
  // remove leading segments.
PTEXT SegBreak(PTEXT segment)
	 // return leading segments!  might be ORPHANED if not handled.
{
	PTEXT temp;
	if( !segment )
		return NULL;
	if((temp=PRIORLINE(segment)))
		SETNEXTLINE(temp,NULL);
	SETPRIORLINE(segment,NULL);
	return(temp);
}
INDEX  GetSegmentSpaceEx ( PTEXT segment, size_t position, int nTabs, INDEX *tabs)
{
	INDEX total = 0;
	do
	{
		if( segment && !( segment->flags & TF_FORMATPOS ) )
		{
			int n;
			for( n = 0; n < nTabs && (INDEX)position > tabs[n]; n++ );
			if( n < nTabs )
				// now position is before the first tab... such that
				for( ; n < nTabs && n < segment->format.position.offset.tabs; n++ )
				{
					total += tabs[n]-position;
					position = tabs[n];
				}
			lprintf( WIDE("Adding %d spaces"), segment->format.position.offset.spaces );
			total += segment->format.position.offset.spaces;
		}
	}
	while( (segment->flags & TF_INDIRECT) && ( segment = GetIndirect( segment ) ) );
	return total;
}
//---------------------------------------------------------------------------
INDEX  GetSegmentSpace ( PTEXT segment, INDEX position, int nTabSize )
{
	INDEX total = 0;
	do
	{
		if( segment && !( segment->flags & TF_FORMATPOS ) )
		{
			int n;
			for( n = 0; n < segment->format.position.offset.tabs; n++ )
			{
				if( !total )
					// I think this is wrong.  need to validate this equation.
					total += (position % nTabSize) + 1;
				else
					total += nTabSize;
			}
			total += segment->format.position.offset.spaces;
		}
	}
	while( (segment->flags & TF_INDIRECT) && ( segment = GetIndirect( segment ) ) );
	return total;
}
//---------------------------------------------------------------------------
INDEX  GetSegmentLengthEx ( PTEXT segment, size_t position, int nTabs, INDEX *tabs )
{
	while( segment && segment->flags & TF_INDIRECT )
		segment = GetIndirect( segment );
	return GetSegmentSpaceEx( segment, position, nTabs, tabs ) + GetTextSize( segment );
}
//---------------------------------------------------------------------------
INDEX  GetSegmentLength ( PTEXT segment, size_t position, int nTabSize )
{
	while( segment && segment->flags & TF_INDIRECT )
		segment = GetIndirect( segment );
	return GetSegmentSpace( segment, position, nTabSize ) + GetTextSize( segment );
}
//---------------------------------------------------------------------------
PTEXT SegAppend(PTEXT source,PTEXT other)
{
	PTEXT temp=source;
	if( temp )
	{
		if( other )
		{
			SetEnd(temp);
			SETNEXTLINE(temp,other);
			SETPRIORLINE(other,temp);
		}
	}
	else
	{
  // nothing was before...
		source=other;
	}
	return(source);
}
//---------------------------------------------------------------------------
void SegReleaseEx( PTEXT seg DBG_PASS)
{
	if( seg )
		ReleaseEx( seg DBG_RELAY );
}
//---------------------------------------------------------------------------
PTEXT SegExpandEx(PTEXT source, INDEX nSize DBG_PASS)
{
	PTEXT temp;
	//Log1( WIDE("SegExpand...%d"), nSize );
	temp = SegCreateEx( GetTextSize( source ) + nSize  DBG_RELAY );
	if( source )
	{
		MemCpy( temp->data.data, source->data.data, sizeof( TEXTCHAR)*(GetTextSize( source ) + 1) );
		temp->flags = source->flags;
		temp->format = source->format;
		SegSubst( temp, source );
		SegRelease( source );
	}
	return temp;
}
//---------------------------------------------------------------------------
void LineReleaseEx(PTEXT line DBG_PASS )
{
	PTEXT temp;
	if( !line )
		return;
	SetStart(line);
	while(line)
	{
		temp=NEXTLINE(line);
		if( !(line->flags&TF_STATIC) )
		{
			if( (( line->flags & (TF_INDIRECT|TF_DEEP) ) == (TF_INDIRECT|TF_DEEP) ) )
 // if indirect, don't want to release application content
				if( !(line->flags & TF_APPLICATION) )
					LineReleaseEx( GetIndirect( line ) DBG_RELAY );
			ReleaseEx( line DBG_RELAY );
		}
		line=temp;
	}
}
//---------------------------------------------------------------------------
PTEXT SegConcatEx(PTEXT output,PTEXT input,int32_t offset,size_t length DBG_PASS )
{
	size_t idx=0;
	size_t len=0;
	PTEXT newseg;
	SegAppend( output, newseg = SegCreateEx( length DBG_RELAY ) );
	output = newseg;
	//output=SegExpandEx(output, length DBG_RELAY); /* add 1 for a null */
	GetText(output)[0]=0;
	while (input&&idx<length)
	{
		//#define min(a,b) (((a)<(b))?(a):(b))
		if( ( GetTextSize( input ) - offset ) < ( length-idx  ) )
			len = GetTextSize( input ) - offset;
		else
         len = length - idx;
		MemCpy( GetText(output) + idx,
				  GetText(input) + offset,
				  sizeof( TEXTCHAR ) * ( len + 1 ) );
		idx += len;
		offset = 0;
		input=NEXTLINE(input);
	}
	GetText(output)[idx]=0;
	return(output);
}
//---------------------------------------------------------------------------
PTEXT SegUnlink(PTEXT segment)
{
	PTEXT temp;
	if (segment)
	{
		if( ( temp = PRIORLINE(segment) ) )
			SETNEXTLINE(temp,NEXTLINE(segment));
		if( ( temp = NEXTLINE(segment) ) )
			SETPRIORLINE(temp,PRIORLINE(segment));
		SETPRIORLINE(segment, NULL);
		SETNEXTLINE(segment, NULL);
	}
	return segment;
}
//---------------------------------------------------------------------------
PTEXT SegGrab( PTEXT segment )
{
	SegUnlink( segment );
	return segment;
}
//---------------------------------------------------------------------------
PTEXT SegDelete( PTEXT segment )
{
	LineReleaseEx( SegGrab( segment ) DBG_SRC );
	return NULL;
}
//---------------------------------------------------------------------------
PTEXT SegInsert( PTEXT what, PTEXT before )
{
	PTEXT that_start = what ,
			that_end= what;
	SetStart( that_start );
	SetEnd( that_end );
	if( before )
	{
		if( ( that_start->Prior = before->Prior) )
			that_start->Prior->Next = that_start;
		if( ( that_end->Next = before ) )
			that_end->Next->Prior = that_end;
	}
	return what;
}
//---------------------------------------------------------------------------
PTEXT SegSubst( PTEXT _this, PTEXT that )
{
	PTEXT that_start = that ,
			that_end= that;
	SetStart( that_start );
	SetEnd( that_end );
	if( ( that_end->Next = _this->Next ) )
		that_end->Next->Prior = that_end;
	if( ( that_start->Prior = _this->Prior) )
		that_start->Prior->Next = that_start;
	_this->Next = NULL;
	_this->Prior = NULL;
	return _this;
}
//---------------------------------------------------------------------------
PTEXT SegSplitEx( PTEXT *pLine, INDEX nPos  DBG_PASS)
{
	// there includes the character at nPos - so all calculations
	// on there are +1...
	PTEXT here, there;
	size_t nLen;
	nLen = GetTextSize( *pLine );
	if( nPos > nLen )
	{
		return NULL;
	}
	if( nPos == nLen )
		return *pLine;
	here = SegCreateEx( nPos DBG_RELAY );
	here->flags  = (*pLine)->flags;
	here->format = (*pLine)->format;
	there = SegCreateEx( (nLen - nPos) DBG_RELAY );
	there->flags  = (*pLine)->flags;
	there->format = (*pLine)->format;
 // was two characters presumably...
	there->format.position.offset.spaces = 0;
	there->format.position.offset.tabs = 0;
	MemCpy( GetText( here ), GetText( *pLine ), sizeof(TEXTCHAR)*nPos );
	GetText( here )[nPos] = 0;
	if( nLen - nPos )
	{
		MemCpy( GetText( there ), GetText( *pLine ) + nPos, sizeof(TEXTCHAR)*(nLen - nPos) );
		GetText( there )[nLen-nPos] = 0;
	}
	SETNEXTLINE( PRIORLINE( *pLine ), here );
	SETPRIORLINE( here, PRIORLINE( *pLine ) );
	SETNEXTLINE( here, there );
	SETPRIORLINE( there, here );
	SETNEXTLINE( there, NEXTLINE( *pLine ) );
	SETPRIORLINE( NEXTLINE( *pLine ), there );
	SETNEXTLINE( *pLine, NULL );
	SETPRIORLINE( *pLine, NULL );
	LineReleaseEx( *pLine DBG_RELAY );
	*pLine = here;
	return here;
}
//----------------------------------------------------------------------
TEXTCHAR NextCharEx( PTEXT input, size_t idx )
{
	if( ( ++idx ) >= input->data.size )
	{
		idx -= input->data.size;
		input = NEXTLINE( input );
	}
	if( input )
		return input->data.data[idx];
	return 0;
}
#define NextChar() NextCharEx( input, index )
//----------------------------------------------------------------------
// In this final implementation - it was decided that for a general
// library, that expressions, escapes of expressions, apostrophes
// were of no consequence, and without expressions, there is no excess
// so this simply is text stream in, text stream out.
// these are just shortcuts - these bits of code were used repeatedly....
#define SET_SPACES() do {		word->format.position.offset.spaces = (uint16_t)spaces;		 word->format.position.offset.tabs = (uint16_t)tabs;		                             spaces = 0;		                                                         tabs = 0; } while(0)
//static CTEXTSTR normal_punctuation=WIDE("\'\"\\({[<>]}):@%/,;!?=*&$^~#`");
//static CTEXTSTR not_punctuation;
PTEXT TextParse( PTEXT input, CTEXTSTR punctuation, CTEXTSTR filter_space, int bTabs, int bSpaces  DBG_PASS )
// returns a TEXT list of parsed data
{
//#define DBG_OVERRIDE DBG_SRC
#define DBG_OVERRIDE DBG_RELAY
	/* takes a line of input and creates a line equivalent to it, but
	   burst into its block peices.*/
	VARTEXT out;
	PTEXT outdata=(PTEXT)NULL,
	      word;
	TEXTSTR tempText;
	int has_minus = -1;
	int has_plus = -1;
	uint32_t index;
	INDEX size;
	TEXTCHAR character;
	uint32_t elipses = FALSE,
	   spaces = 0, tabs = 0;
        // if nothing new to process- return nothing processed.
	if (!input)
		return((PTEXT)NULL);
	VarTextInitEx( &out DBG_OVERRIDE );
  // while there is data to process...
	while (input)
	{
		if( input->flags & TF_INDIRECT )
		{
			word = VarTextGetEx( &out DBG_OVERRIDE );
			if( word )
			{
				SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
			outdata = SegAppend( outdata, TextParse( GetIndirect( input ), punctuation, filter_space, bTabs, bSpaces DBG_RELAY ) );
			input = NEXTLINE( input );
			continue;
		}
  // point to the data to process...
		tempText = GetText(input);
		size = GetTextSize(input);
		if( input->format.position.offset.spaces || input->format.position.offset.tabs )
		{
			word = VarTextGetEx( &out DBG_OVERRIDE );
			if( word )
			{
				SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
		}
		spaces += input->format.position.offset.spaces;
		tabs += input->format.position.offset.tabs;
		//Log1( WIDE("Assuming %d spaces... "), spaces );
		for (index=0;(character = tempText[index]),
 // while not at the
                   (index < size); index++)
                                         // end of the line.
		{
			if( elipses && character != '.' )
			{
				if( VarTextEndEx( &out DBG_OVERRIDE ) )
				{
					PTEXT word = VarTextGetEx( &out DBG_OVERRIDE );
					if( word )
					{
						SET_SPACES();
						outdata = SegAppend( outdata, word );
					}
					//else
					//	Log( WIDE("VarTextGet Failed to result.") );
				}
				elipses = FALSE;
			}
 // elipses and character is . - continue
			else if( elipses )
			{
				VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
				continue;
			}
		if( StrChr( filter_space, character ) )
		{
			goto is_a_space;
		}
		else if( StrChr( punctuation, character ) )
		{
			if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
			{
				outdata = SegAppend( outdata, word );
				SET_SPACES();
				VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
				word = VarTextGetEx( &out DBG_OVERRIDE );
				outdata = SegAppend( outdata, word );
			}
			else
			{
				VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
				word = VarTextGetEx( &out DBG_OVERRIDE );
				SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
		}
		else switch(character)
		{
		case '\n':
			if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
			{
					SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
 // add a line-break packet
			outdata = SegAppend( outdata, SegCreate( 0 ) );
			break;
		case ' ':
			if( bSpaces )
			{
			is_a_space:
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				spaces++;
				break;
			}
				if(0) {
		case '\t':
					if( bTabs )
					{
						if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
						{
							SET_SPACES();
							outdata = SegAppend( outdata, word );
						}
						if( spaces )
						{
						//lprintf( WIDE("Input stream has mangled spaces and tabs.") );
 // assume that the tab takes care of appropriate spacing
							spaces = 0;
						}
						tabs++;
						break;
					}
				} else if(0) {
 // a space space character...
		case '\r':
					if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
					{
						SET_SPACES();
						outdata = SegAppend( outdata, word );
					}
					break;
				} else if(0) {
 // handle multiple periods grouped (elipses)
		case '.':
				//goto NormalPunctuation;
				{
					TEXTCHAR c;
					if( ( !elipses &&
						  ( c = NextChar() ) &&
						  ( c == '.' ) ) )
						{
							if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
							{
								outdata = SegAppend( outdata, word );
								SET_SPACES();
							}
							VarTextAddCharacterEx( &out, '.' DBG_OVERRIDE );
							elipses = TRUE;
							break;
						}
						if( ( c = NextChar() ) &&
							( c >= '0' && c <= '9' ) )
						{
							// gather together as a floating point number...
							VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
							break;
						}
					}
				} else if(0) {
  // work seperations flaming-long-sword
				case '-':
					if( has_minus == -1 ) {
						if( !punctuation || StrChr( punctuation, '-' ) )
							has_minus = 1;
						else
							has_minus = 0;
					}
					if( !has_minus )
					{
						VarTextAddCharacterEx( &out, '-' DBG_OVERRIDE );
						break;
					}
				case '+':
				{
					int c;
					if( has_plus == -1 ) {
						if( !punctuation || StrChr( punctuation, '-' ) )
							has_plus = 1;
						else
							has_plus = 0;
					}
					if( !has_plus )
					{
						VarTextAddCharacterEx( &out, '-' DBG_OVERRIDE );
						break;
					}
					if( ( c = NextChar() ) &&
						( c >= '0' && c <= '9' ) )
					{
						if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
						{
							outdata = SegAppend( outdata, word );
							SET_SPACES();
							// gather together as a sign indication on a number.
						}
						VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
						break;
					}
				}
//			NormalPunctuation:
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					outdata = SegAppend( outdata, word );
					SET_SPACES();
					VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
					word = VarTextGetEx( &out DBG_OVERRIDE );
					outdata = SegAppend( outdata, word );
				}
				else
				{
					VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
					word = VarTextGetEx( &out DBG_OVERRIDE );
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				break;
				}
			default:
				if( elipses )
				{
					if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
					{
						outdata = SegAppend( outdata, word );
						SET_SPACES();
					}
					elipses = FALSE;
				}
				VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
				break;
			}
		}
		input=NEXTLINE(input);
	}
 // any generic outstanding data?
	if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
	{
		outdata = SegAppend( outdata, word );
		SET_SPACES();
	}
	SetStart(outdata);
	VarTextEmptyEx( &out DBG_OVERRIDE );
	return(outdata);
}
PTEXT burstEx( PTEXT input DBG_PASS )
// returns a TEXT list of parsed data
{
//#define DBG_OVERRIDE DBG_SRC
//#define DBG_OVERRIDE DBG_RELAY
	/* takes a line of input and creates a line equivalent to it, but
		burst into its block peices.*/
	VARTEXT out;
	PTEXT outdata=(PTEXT)NULL,
			word;
	TEXTSTR tempText;
	uint32_t index;
	size_t size;
	TEXTCHAR character;
	uint32_t elipses = FALSE,
		spaces = 0, tabs = 0;
		  // if nothing new to process- return nothing processed.
	if (!input)
		return((PTEXT)NULL);
	VarTextInitEx( &out DBG_OVERRIDE );
  // while there is data to process...
	while (input)
	{
		if( input->flags & TF_INDIRECT )
		{
			word = VarTextGetEx( &out DBG_OVERRIDE );
			if( word )
			{
				SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
			outdata = SegAppend( outdata, burst( GetIndirect( input ) ) );
			input = NEXTLINE( input );
			continue;
		}
  // point to the data to process...
		tempText = GetText(input);
		size = GetTextSize(input);
		if( input->format.position.offset.spaces || input->format.position.offset.tabs )
		{
			word = VarTextGetEx( &out DBG_OVERRIDE );
			if( word )
			{
				SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
		}
		spaces += input->format.position.offset.spaces;
		tabs += input->format.position.offset.tabs;
		//Log1( WIDE("Assuming %d spaces... "), spaces );
		for (index=0;(character = tempText[index]),
 // while not at the
		             (index < size); index++)
		                                      // end of the line.
		{
			if( elipses && character != '.' )
			{
				if( VarTextEndEx( &out DBG_OVERRIDE ) )
				{
					PTEXT word = VarTextGetEx( &out DBG_OVERRIDE );
					if( word )
					{
						SET_SPACES();
						outdata = SegAppend( outdata, word );
					}
					//else
					//	Log( WIDE("VarTextGet Failed to result.") );
				}
				elipses = FALSE;
			}
 // elipses and character is . - continue
			else if( elipses )
			{
				VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
				continue;
			}
			switch(character)
			{
			case '\n':
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
 // add a line-break packet
				outdata = SegAppend( outdata, SegCreate( 0 ) );
				break;
			case ' ':
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				spaces++;
				break;
			case '\t':
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				if( spaces )
				{
				//lprintf( WIDE("Input stream has mangled spaces and tabs.") );
					spaces = 0;
				}
				tabs++;
				break;
 // a space space character...
			case '\r':
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				break;
 // handle multiple periods grouped (elipses)
			case '.':
				//goto NormalPunctuation;
				{
					TEXTCHAR c;
					if( ( !elipses &&
							( c = NextChar() ) &&
							( c == '.' ) ) )
					{
						if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
						{
							outdata = SegAppend( outdata, word );
							SET_SPACES();
						}
						VarTextAddCharacterEx( &out, '.' DBG_OVERRIDE );
						elipses = TRUE;
						break;
					}
					if( ( c = NextChar() ) &&
						 ( c >= '0' && c <= '9' ) )
					{
						// gather together as a floating point number...
						VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
						break;
					}
				}
  // work seperations flaming-long-sword
			case '-':
			case '+':
				{
					int c;
					if( ( c = NextChar() ) &&
						( c >= '0' && c <= '9' ) )
					{
						if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
						{
							outdata = SegAppend( outdata, word );
							SET_SPACES();
						}
						// gather together as a sign indication on a number.
						VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
						break;
					}
				}
 // single quote bound
			case '\'':
 // double quote bound
			case '\"':
 // escape next thingy... unusable in c processor
			case '\\':
 // expression bounders
			case '(':
			case '{':
			case '[':
			case '<':
 // expression closers
			case ')':
			case '}':
			case ']':
			case '>':
  // internet addresses
			case ':':
  // email addresses
			case '@':
			case '%':
			case '/':
			case ',':
			case ';':
			case '!':
			case '?':
			case '=':
			case '*':
			case '&':
			case '$':
			case '^':
			case '~':
			case '#':
			case '`':
//			NormalPunctuation:
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					outdata = SegAppend( outdata, word );
					SET_SPACES();
					VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
					word = VarTextGetEx( &out DBG_OVERRIDE );
					outdata = SegAppend( outdata, word );
				}
				else
				{
					VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
					word = VarTextGetEx( &out DBG_OVERRIDE );
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				break;
			default:
				if( elipses )
				{
					if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
					{
						outdata = SegAppend( outdata, word );
						SET_SPACES();
					}
					elipses = FALSE;
				}
				VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
				break;
			}
		}
		input=NEXTLINE(input);
	}
 // any generic outstanding data?
	if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
	{
		outdata = SegAppend( outdata, word );
		SET_SPACES();
	}
	SetStart(outdata);
	VarTextEmptyEx( &out DBG_OVERRIDE );
	return(outdata);
}
//---------------------------------------------------------------------------
#undef LineLengthExx
size_t LineLengthExx( PTEXT pt, LOGICAL bSingle, PTEXT pEOL )
{
	return LineLengthExEx( pt, bSingle, 8, pEOL );
}
size_t LineLengthExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL )
{
	int	TopSingle = bSingle;
	PTEXT pStack[32];
	int	nStack;
	int	skipspaces = ( PRIORLINE(pt) != NULL );
	size_t length = 0;
	nStack = 0;
	while( pt )
	{
		if( pt->flags & TF_BINARY )
		{
			pt = NEXTLINE( pt );
			if( bSingle )
				break;
			continue;
		}
		if( !(pt->flags & ( IS_DATA_FLAGS | TF_INDIRECT)) &&
			 !pt->data.size
		  )
		{
			if( pEOL )
				length += pEOL->data.size;
			else
 // full binary \r\n insertion assumed
				length += 2;
		}
		else
		{
			if( skipspaces )
				skipspaces = FALSE;
			else
			{
				if( !(pt->flags & (TF_FORMATABS|TF_FORMATREL)) )
 // not-including NULL.
					length += GetSegmentSpace( pt, length, nTabsize );
			}
			if( pt->flags&TF_INDIRECT )
			{
 // will be restored when we get back to top seg.
				bSingle = FALSE;
				pStack[nStack++] = pt;
				pt = GetIndirect( pt );
				//if( nStack >= 32 )
				//	DebugBreak();
				continue;
			}
			else
 // not-including NULL.
				length += GetTextSize( pt );
stack_resume:
			if( pt->flags&TF_TAG )
				length += 2;
			if( pt->flags&TF_PAREN )
				length += 2;
			if( pt->flags&TF_BRACE )
				length += 2;
			if( pt->flags&TF_BRACKET )
				length += 2;
			if( pt->flags&TF_QUOTE )
				length += 2;
			if( pt->flags&TF_SQUOTE )
				length += 2;
		}
		if( bSingle )
		{
			bSingle = FALSE;
			break;
		}
		pt = NEXTLINE( pt );
	}
	if( nStack )
	{
		pt = pStack[--nStack];
		if( !nStack )
			bSingle = TopSingle;
		goto stack_resume;
	}
//	if( length > 60000 )
//		_asm int 3;
	return length;
}
#undef LineLengthEx
INDEX LineLengthEx( PTEXT pt, LOGICAL bSingle )
{
	return LineLengthExx( pt, bSingle, NULL );
}
//---------------------------------------------------------------------------
// attempts to build a solitary line segment from the text passed
// however, if there are color changes, or absolute position changes
// this cannot work... and it must provide multiple peices...
#undef BuildLineExx
PTEXT BuildLineExx( PTEXT pt, LOGICAL bSingle, PTEXT pEOL DBG_PASS )
{
	return BuildLineExEx( pt, bSingle, 8, pEOL DBG_RELAY );
}
PTEXT BuildLineExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL DBG_PASS )
{
	TEXTSTR buf;
	int	TopSingle = bSingle;
	PTEXT pStack[32];
	int	nStack, firstadded;
	int	skipspaces = ( PRIORLINE(pt) != NULL );
	PTEXT pOut;
	uintptr_t ofs;
	{
		INDEX len;
		len = LineLengthExx( pt,bSingle,pEOL );
		if( !len )
			return NULL;
		pOut = SegCreateEx( len DBG_RELAY );
		firstadded = TRUE;
		buf = GetText( pOut );
	}
	ofs = 0;
	nStack = 0;
	while( pt )
	{
		if( pt->flags & TF_BINARY )
		{
			pt = NEXTLINE( pt );
			if( bSingle )
				break;
			continue;
		}
		// test color fields vs PRIOR_COLOR
		// if either the color IS the prior color - OR the value IS PRIOR_COLOR
		// then they can still be collapsed... DEFAULT_COLOR MAY be prior color
		// but there's no real telling... default is more like after a
		// attribute reset occurs...
		if( firstadded )
		{
			pOut->format.flags.foreground = pt->format.flags.foreground;
			pOut->format.flags.background = pt->format.flags.background;
			firstadded = FALSE;
		}
		else
		{
			if( ( !pt->format.flags.prior_foreground &&
				  !pt->format.flags.default_foreground &&
					pt->format.flags.foreground != pOut->format.flags.foreground ) ||
				 ( !pt->format.flags.prior_background &&
				  !pt->format.flags.default_background &&
					pt->format.flags.background != pOut->format.flags.background )
			  )
			{
				PTEXT pSplit;
				// ofs is the next valid character position....
				//Log( WIDE("Changing segment's color...") );
				if( ofs )
				{
					pSplit = SegSplitEx( &pOut, ofs DBG_RELAY );
					if( !pSplit )
					{
						lprintf( WIDE("Line was shorter than offset: %") _size_f WIDE(" vs %") _PTRSZVALfs WIDE(""), GetTextSize( pOut ), ofs );
					}
					pOut = NEXTLINE( pSplit );
					// new segments takes on the new attributes...
					pOut->format.flags.foreground = pt->format.flags.foreground;
					pOut->format.flags.background = pt->format.flags.background;
						//Log2( WIDE("Split at %d result %d"), ofs, GetTextSize( pOut ) );
						buf = GetText( pOut );
					ofs = 0;
				}
				else
				{
					pOut->format.flags.foreground = pt->format.flags.foreground;
					pOut->format.flags.background = pt->format.flags.background;
				}
			}
		}
		if( !(pt->flags& (TF_INDIRECT|IS_DATA_FLAGS)) &&
			 !pt->data.size
		  )
		{
			if( pEOL )
			{
				MemCpy( buf + ofs, pEOL->data.data, sizeof( TEXTCHAR )*(pEOL->data.size + 1) );
				ofs += pEOL->data.size;
			}
			else
			{
				buf[ofs++] = '\r';
				buf[ofs++] = '\n';
			}
		}
		else
		{
			if( skipspaces )
			{
				skipspaces = FALSE;
			}
			else if( !(pt->flags & (TF_FORMATABS|TF_FORMATREL)) )
			{
				size_t spaces = GetSegmentSpace( pt, ofs, nTabsize );
				// else we cannot collapse into single line (similar to colors.)
				while( spaces-- )
				{
					buf[ofs++] = ' ';
				}
			}
			// at this point spaces before tags, and after tags
			// which used to be expression level parsed are not
			// reconstructed correctly...
			if( pt->flags&TF_TAG )
				buf[ofs++] = '<';
			if( pt->flags&TF_PAREN )
				buf[ofs++] = '(';
			if( pt->flags&TF_BRACE )
				buf[ofs++] = '{';
			if( pt->flags&TF_BRACKET )
				buf[ofs++] = '[';
			if( pt->flags&TF_QUOTE )
				buf[ofs++] = '\"';
			if( pt->flags&TF_SQUOTE )
				buf[ofs++] = '\'';
			if( pt->flags&TF_INDIRECT )
			{
 // will be restored when we get back to top.
				bSingle = FALSE;
				pStack[nStack++] = pt;
				pt = GetIndirect( pt );
				//if( nStack >= 32 )
				//	DebugBreak();
				continue;
			}
			else
			{
				size_t len;
				MemCpy( buf+ofs, GetText( pt ), sizeof( TEXTCHAR) * (len = GetTextSize( pt ))+1 );
					ofs += len;
			}
stack_resume:
			if( pt->flags&TF_SQUOTE )
				buf[ofs++] = '\'';
			if( pt->flags&TF_QUOTE )
				buf[ofs++] = '\"';
			if( pt->flags&TF_BRACKET )
				buf[ofs++] = ']';
			if( pt->flags&TF_BRACE )
				buf[ofs++] = '}';
			if( pt->flags&TF_PAREN )
				buf[ofs++] = ')';
			if( pt->flags&TF_TAG )
				buf[ofs++] = '>';
		}
		if( bSingle )
		{
			bSingle = FALSE;
			break;
		}
		pt = NEXTLINE( pt );
	}
	if( nStack )
	{
		pt = pStack[--nStack];
		if( !nStack )
			bSingle = TopSingle;
		goto stack_resume;
	}
 // have to return length instead of new text seg...
	if( !pOut )
		return (PTEXT)ofs;
 // if formatting was inserted into the stream...
	SetStart( pOut );
	return pOut;
}
#undef BuildLineEx
PTEXT BuildLineEx( PTEXT pt, int bSingle DBG_PASS )
{
	return BuildLineExx( pt, bSingle, FALSE DBG_RELAY );
}
PTEXT FlattenLine( PTEXT pLine )
{
	 PTEXT pCur, p;
	 pCur = pLine;
	 // all indirected segments get promoted to
	 // the first level...
	 while( pCur )
	 {
		  if( pCur->flags & TF_STATIC )
		  {
			  p = SegDuplicate( pCur );
			  if( p )
			  {
				  SegSubst( pCur, p );
				  if( pCur == pLine )
					  pLine = p;
				  LineReleaseEx( pCur DBG_SRC );
				  pCur = p;
			  }
			  else
			  {
					PTEXT next = NEXTLINE( pCur );
					SegGrab( pCur );
					LineRelease( pCur );
					pCur = next;
					continue;
			  }
		  }
		  if( pCur->flags & TF_INDIRECT )
		  {
				if( pCur->flags & TF_DEEP )
				{
					 p = FlattenLine( GetIndirect( pCur ) );
					 pCur->flags &= ~TF_DEEP;
				}
				else
				{
					 p = TextDuplicate( GetIndirect( pCur ), FALSE );
				}
				if( p )
				{
					SegSubst( pCur, p );
					if( pCur == pLine )
						pLine = p;
					p->flags |= pCur->flags & (~(TF_INDIRECT|TF_DEEP));
					LineReleaseEx( pCur DBG_SRC );
					pCur = p;
				}
				else
				{
					PTEXT next = NEXTLINE( pCur );
					SegGrab( pCur );
					LineRelease( pCur );
					pCur = next;
				}
				continue;
		  }
		  pCur = NEXTLINE( pCur );
	 }
	 return pLine;
}
//----------------------------------------------------------------------------
POINTER GetApplicationPointer( PTEXT text )
{
	// okay indirects up to application data are okay.
	while( ( text->flags & TF_INDIRECT ) && !(text->flags & TF_APPLICATION) )
		return GetApplicationPointer( (PTEXT)text->data.size );
	if( text->flags & TF_APPLICATION )
		return (POINTER)text->data.size;
	return NULL;
}
//----------------------------------------------------------------------------
void SetApplicationPointer( PTEXT text, POINTER p)
{
	// sets only this segment.
	if( text )
	{
		text->flags |= TF_APPLICATION;
		text->data.size = (uintptr_t)p;
	}
}
//----------------------------------------------------------------------------
void RegisterTextExtension( uint32_t flags, PTEXT(CPROC*TextOf)(uintptr_t,POINTER), uintptr_t psvData)
{
	PTEXT_EXTENSION pte = (PTEXT_EXTENSION)Allocate( sizeof( TEXT_EXTENSION ) );
	pte->bits = flags;
	pte->TextOf = TextOf;
	pte->psvData = psvData;
	AddLink( &pTextExtensions, pte );
#if 0
	if( text && ( text->flags & TF_APPLICATION ) )
	{
		INDEX idx;
		PTEXT_EXENSTION pte;
		LIST_FORALL( pTextExtension, idx, PTEXT_EXTENSION, pte )
		{
			if( pte->flags & text->flags )
			{
				text = pte->TextOf( text );
				break;
			}
		}
	}
#endif
	return;
}
//---------------------------------------------------------------------------
int TextIs( PTEXT pText, CTEXTSTR string )
{
	CTEXTSTR data = GetText( pText );
	if( data )
		return !StrCmp( data, string );
	return 0;
}
//---------------------------------------------------------------------------
int TextLike( PTEXT pText, CTEXTSTR string )
{
	CTEXTSTR data = GetText( pText );
	if( data )
		return !StrCaseCmp( data, string );
	return 0;
}
//---------------------------------------------------------------------------
int TextSimilar( PTEXT pText, CTEXTSTR string )
{
	CTEXTSTR data = GetText( pText );
	if( data )
	{
		size_t len1 = data ? StrLen( data ) : 0;
		size_t len2 = string ? StrLen( string ) : 0;
		return !StrCaseCmpEx( data, string, textmin( len1, len2 ) );
	}
	return 0;
}
//---------------------------------------------------------------------------
int SameText( PTEXT l1, PTEXT l2 )
{
	CTEXTSTR d1 = GetText( l1 );
	CTEXTSTR d2 = GetText( l2 );
	if( d1 && d2 )
		return StrCmp( d1, d2 );
	else if( d1 )
		return 1;
	else if( d2 )
		return -1;
	return 0;
}
//---------------------------------------------------------------------------
int LikeText( PTEXT l1, PTEXT l2 )
{
	CTEXTSTR d1 = GetText( l1 );
	size_t len1 = d1 ? StrLen( d1 ) : 0;
	CTEXTSTR d2 = GetText( l2 );
	size_t len2 = d2 ? StrLen( d2 ) : 0;
	if( d1 && d2 )
		return StrCaseCmpEx( d1, d2, textmin( len1, len2 ) );
	else if( d1 )
		return 1;
	else if( d2 )
		return -1;
	return 0;
}
//---------------------------------------------------------------------------
int CompareStrings( PTEXT pt1, int single1
                  , PTEXT pt2, int single2
                  , int bExact )
{
	while( pt1 && pt2 )
	{
		while( pt1 &&
				 pt1->flags && ( pt1->flags & TF_BINARY ) )
			pt1 = NEXTLINE( pt1 );
		while( pt2 &&
				 pt2->flags && ( pt2->flags & TF_BINARY ) )
			pt2 = NEXTLINE( pt2 );
		if( !pt1 && pt2 )
			return FALSE;
		if( pt1 && !pt2 )
			return FALSE;
		if( bExact )
		{
			if( SameText( pt1, pt2 ) != 0 )
				return FALSE;
		}
		else
		{
			// Like returns string compare function literal...
			if( LikeText( pt1, pt2 ) != 0 )
				return FALSE;
		}
		if( !single1 )
		{
			pt1 = NEXTLINE( pt1 );
			if( pt1 &&
				 !GetTextSize( pt1 ) && !(pt1->flags & IS_DATA_FLAGS))
				pt1 = NULL;
		}
		else
			pt1 = NULL;
		if( !single2 )
		{
			pt2 = NEXTLINE( pt2 );
			if( pt2 &&
				 !GetTextSize( pt2 ) &&
				 !(pt2->flags & IS_DATA_FLAGS))
				pt2 = NULL;
		}
		else
			pt2 = NULL;
	}
	if( !pt1 && !pt2 )
		return TRUE;
	return FALSE;
}
//--------------------------------------------------------------------------
int64_t IntCreateFromText( CTEXTSTR p )
{
	//CTEXTSTR p;
	int s;
	int begin;
	int64_t num;
	LOGICAL altBase = FALSE;
	LOGICAL altBase2 = FALSE;
	int64_t base = 10;
	//p = GetText( pText );
	if( !p )
		return 0;
	//if( pText->flags & TF_INDIRECT )
	//   return IntCreateFromSeg( GetIndirect( pText ) );
	s = 0;
	num = 0;
	begin = TRUE;
	while( *p )
	{
		if( *p == '.' )
			break;
		else if( *p == '+' )
		{
		}
		else if( *p == '-' && begin)
		{
			s++;
		}
		else if( *p < '0' || *p > '9' )
		{
			if( !altBase2 ) {
				if( *p == 'x' ) { altBase2 = TRUE; base = 16; }
				else if( *p == 'b' ) { altBase2 = TRUE; base = 2; }
				else break;
			} else {
				if( base > 10 ) {
					if( *p >= 'a' && *p <= 'f' ) {
						num *= base;
						num += *p - 'a' + 10;
					}
					else if( *p >= 'A' && *p <= 'F' ) {
						num *= base;
						num += *p - 'A' + 10;
					}
					else break;
				}
				else break;
			}
		}
		else
		{
			if( ( !altBase ) && (*p == '0') ) { altBase = TRUE; base = 8; }
			else { if( (*p - '0') >= base ) { break; } altBase = TRUE; }
			num *= base;
			num += *p - '0';
		}
		begin = FALSE;
		p++;
	}
	if( s & 1 )
		num *= -1;
	return num;
}
//--------------------------------------------------------------------------
int64_t IntCreateFromSeg( PTEXT pText )
{
	CTEXTSTR p;
	p = GetText( pText );
	if( !pText || !p )
		return FALSE;
	if( pText->flags & TF_INDIRECT )
		return IntCreateFromSeg( GetIndirect( pText ) );
	return IntCreateFromText( p );
}
//--------------------------------------------------------------------------
double FloatCreateFromText( CTEXTSTR p, CTEXTSTR *vp )
{
	return strtod( p, (char **)vp );
	int s, begin, bDec = FALSE;
	double num;
	double base = 1;
	double temp;
	if( !p )
	{
		if( vp )
			(*vp) = p;
		return 0;
	}
	s = 0;
	num = 0;
	begin = TRUE;
	while( *p )
	{
		if( *p == '-' && begin )
		{
			s++;
		}
		else if( *p < '0' || *p > '9' )
		{
			if( *p == '.' )
			{
				bDec = TRUE;
				base = 0.1;
			}
			else
				break;
		}
		else
		{
			if( bDec )
			{
				temp = *p - '0';
				num += base * temp;
				base /= 10;
			}
			else
			{
				num *= 10;
				num += *p - '0';
			}
		}
		begin = FALSE;
		p++;
	}
	if( vp )
		(*vp) = p;
	if( s )
		num *= -1;
	return num;
}
//--------------------------------------------------------------------------
double FloatCreateFromSeg( PTEXT pText )
{
	CTEXTSTR p;
	p = GetText( pText );
	if( !p )
		return FALSE;
	return FloatCreateFromText( p, NULL );
}
//--------------------------------------------------------------------------
// if bUseAll - all segments must be part of the number
// otherwise, only as many segments as are needed for the number are used...
int IsSegAnyNumberEx( PTEXT *ppText, double *fNumber, int64_t *iNumber, int *bIntNumber, int bUseAll )
{
	CTEXTSTR pCurrentCharacter;
	PTEXT pBegin;
	PTEXT pText = *ppText;
	int decimal_count, s, begin = TRUE, digits;
	// remember where we started...
	// if the first segment is indirect, collect it and only it
	// as the number... making indirects within a number what then?
	if( pText->flags & TF_INDIRECT )
	{
		int status;
		PTEXT pTemp = GetIndirect( pText );
		if( pTemp
			&& (status = IsSegAnyNumberEx( &pTemp, fNumber, iNumber, bIntNumber, TRUE )) )
		{
			// step to next token - so we toss just this
			// one indirect statement.
			if( fNumber || iNumber )
			{
				// if resulting with a number, then step the text...
				(*ppText) = NEXTLINE( pText );
			}
			return status;
		}
		// not a number....
		return FALSE;
	}
	pBegin = pText;
	decimal_count = 0;
	s = 0;
	digits = 0;
	while( pText )
	{
		// at this point... is this really valid?
		if( pText->flags & TF_INDIRECT )
		{
			lprintf( WIDE("Encountered indirect segment gathering number, stopping.") );
			break;
		}
		if( !begin &&
			( pText->format.position.offset.spaces || pText->format.position.offset.tabs ) )
		{
			// had to continue with new segment, but it had spaces so stop now
			break;
		}
		pCurrentCharacter = GetText( pText );
		while( pCurrentCharacter && *pCurrentCharacter )
		{
			if( *pCurrentCharacter == '.' )
			{
				if( !decimal_count )
					decimal_count++;
				else
					break;
			}
			else if( ((*pCurrentCharacter) == '-') && begin)
			{
				s++;
			}
			else if( ((*pCurrentCharacter) < '0') || ((*pCurrentCharacter) > '9') )
			{
				if( digits && ( pCurrentCharacter == GetText( pText ) ) )
				{
					pCurrentCharacter = GetText( PRIORLINE( pText ) );
					while( pCurrentCharacter[0] )
					{
						// if the number ended in a decimal, it can qualify as an integer
						if( pCurrentCharacter[0] == '.' && !pCurrentCharacter[1] )
							decimal_count--;
						pCurrentCharacter++;
					}
					pText = NULL;
				}
				break;
			}
			else
				digits++;
			begin = FALSE;
			pCurrentCharacter++;
		}
		// invalid character - stop, we're to abort.
		if( *pCurrentCharacter )
			break;
		pText = NEXTLINE( pText );
 //while( pText );
	}
	if( bUseAll && pText )
		// it's not a number, cause we didn't use all segments to get one
		return FALSE;
	if( *pCurrentCharacter || ( decimal_count > 1 ) || !digits )
	{
		// didn't collect enough meaningful info to be a number..
		// or information in this state is
		return FALSE;
	}
	// yeah it was a number, update the incoming pointer...
	if( fNumber || iNumber )
	{
		// if resulting with a number, then step the text...
		(*ppText) = pText;
	}
	if( decimal_count == 1 )
	{
		if( fNumber )
			(*fNumber) = FloatCreateFromSeg( pBegin );
		if( bIntNumber )
			(*bIntNumber) = 0;
 // return specifically it's a floating point number
		return 2;
	}
	if( iNumber )
		(*iNumber) = IntCreateFromSeg( pBegin );
	if( bIntNumber )
		(*bIntNumber) = 1;
 // return yes, and it's an int number
	return 1;
}
//---------------------------------------------------------------------------
//#define VERBOSE_DEBUG_VARTEXT
//---------------------------------------------------------------------------
#define COLLECT_LEN 4096
void VarTextInitEx( PVARTEXT pvt DBG_PASS )
{
	pvt->commit = NULL;
	pvt->collect = SegCreateEx( COLLECT_LEN DBG_RELAY );
	pvt->collect_text = GetText( pvt->collect );
#ifdef VERBOSE_DEBUG_VARTEXT
	Log( WIDE("Resetting collect_used (init)") );
#endif
	pvt->collect_used = 0;
	pvt->collect_avail = COLLECT_LEN;
	pvt->expand_by = 0;
}
 PVARTEXT  VarTextCreateExEx ( uint32_t initial, uint32_t expand DBG_PASS )
{
	PVARTEXT pvt = (PVARTEXT)AllocateEx( sizeof( VARTEXT ) DBG_RELAY );
	pvt->commit = NULL;
	pvt->collect = SegCreateEx( initial DBG_RELAY );
	pvt->collect_text = GetText( pvt->collect );
	pvt->collect_used = 0;
	pvt->collect_avail = initial;
	pvt->expand_by = expand;
	return pvt;
}
//---------------------------------------------------------------------------
PVARTEXT VarTextCreateEx( DBG_VOIDPASS )
{
	PVARTEXT pvt = (PVARTEXT)AllocateEx( sizeof( VARTEXT ) DBG_RELAY );
	VarTextInitEx( pvt DBG_RELAY );
	return pvt;
}
//---------------------------------------------------------------------------
void VarTextDestroyEx( PVARTEXT *ppvt DBG_PASS )
{
	if( ppvt && *ppvt )
	{
		VarTextEmptyEx( *ppvt DBG_RELAY );
		ReleaseEx( (*ppvt) DBG_RELAY );
		*ppvt = NULL;
	}
}
//---------------------------------------------------------------------------
void VarTextEmptyEx( PVARTEXT pvt DBG_PASS )
{
	if( pvt )
	{
		size_t expand = pvt->expand_by;
		LineReleaseEx( pvt->collect DBG_RELAY );
		LineReleaseEx( pvt->commit DBG_RELAY );
		MemSet( pvt, 0, sizeof( VARTEXT ) );
		pvt->expand_by = expand;
	}
}
//---------------------------------------------------------------------------
void VarTextAddCharacterEx( PVARTEXT pvt, TEXTCHAR c DBG_PASS )
{
	if( !pvt->collect )
		VarTextInitEx( pvt DBG_RELAY );
#ifdef VERBOSE_DEBUG_VARTEXT
	Log1( WIDE("Adding character %c"), c );
#endif
	if( c == '\b' )
	{
		if( pvt->collect_used )
		{
			pvt->collect_used--;
			pvt->collect_text[pvt->collect_used] = 0;
		}
	}
	else
	{
		pvt->collect_text[pvt->collect_used++] = c;
		if( pvt->collect_used >= pvt->collect_avail )
		{
			//lprintf( WIDE("Expanding segment to make sure we have room to extend...(old %d)"), pvt->collect->data.size );
			pvt->collect = SegExpandEx( pvt->collect, pvt->collect_avail * 2 DBG_RELAY );
			pvt->collect_avail = pvt->collect->data.size;
			pvt->collect_text = GetText( pvt->collect );
		}
	}
}
void VarTextAddRuneEx( PVARTEXT pvt, TEXTRUNE c, LOGICAL overlong DBG_PASS )
{
	int chars;
	int n;
#ifdef _UNICODE
	wchar_t output[3];
	chars = ConvertToUTF16( output, c );
#else
	char output[6];
	chars = ConvertToUTF8Ex( output, c, overlong );
#endif
	for( n = 0; n < chars; n++ )
		VarTextAddCharacterEx( pvt, output[n] DBG_RELAY );
}
//---------------------------------------------------------------------------
void VarTextAddDataEx( PVARTEXT pvt, CTEXTSTR block, size_t length DBG_PASS )
{
	if( !pvt->collect )
		VarTextInitEx( pvt DBG_RELAY );
#ifdef VERBOSE_DEBUG_VARTEXT
	Log1( WIDE("Adding character %c"), c );
#endif
	{
		uint32_t n;
		for( n = 0; n < length; n++ )
		{
			if( !block[n] && ( length == VARTEXT_ADD_DATA_NULTERM ) )
				break;
			pvt->collect_text[pvt->collect_used++] = block[n];
			if( pvt->collect_used >= pvt->collect_avail )
			{
				//lprintf( WIDE("Expanding segment to make sure we have room to extend...(old %d)"), pvt->collect->data.size );
				pvt->collect = SegExpandEx( pvt->collect, pvt->collect_avail * 2 + COLLECT_LEN DBG_RELAY );
				pvt->collect_avail = pvt->collect->data.size;
				pvt->collect_text = GetText( pvt->collect );
			}
		}
	}
}
//---------------------------------------------------------------------------
LOGICAL VarTextEndEx( PVARTEXT pvt DBG_PASS )
{
 // otherwise ofs will be 0...
	if( pvt && pvt->collect_used )
	{
		PTEXT segs= SegSplitEx( &pvt->collect, pvt->collect_used DBG_RELAY );
		//lprintf( WIDE("End collect at %d %d"), pvt->collect_used, segs?segs->data.size:pvt->collect->data.size );
		if( !segs )
		{
			segs = pvt->collect;
		}
		//Log1( WIDE("Breaking collection adding... %s"), GetText( segs ) );
		// so now the remaining buffer( if any )
		// is assigned to collect into.
		// This results in...
		pvt->collect = NEXTLINE( segs );
 // used all of the line...
		if( !pvt->collect )
		{
#ifdef VERBOSE_DEBUG_VARTEXT
			Log( WIDE("Starting with new buffers ") );
#endif
			VarTextInitEx( pvt DBG_RELAY );
		}
		else
		{
			 //Log1( WIDE("Remaining buffer is %d"), GetTextSize( pvt->collect ) );
			SegBreak( pvt->collect );
			pvt->collect_text = GetText( pvt->collect );
#ifdef VERBOSE_DEBUG_VARTEXT
			Log( WIDE("resetting collect_used after split") );
#endif
			pvt->collect_avail -= pvt->collect_used;
			pvt->collect_used = 0;
		}
		pvt->commit = SegAppend( pvt->commit, segs );
		return 1;
	}
	if( pvt && pvt->commit )
		return 1;
	return 0;
}
//---------------------------------------------------------------------------
PTEXT VarTextGetEx( PVARTEXT pvt DBG_PASS )
{
	if( !pvt )
	{
#ifdef VERBOSE_DEBUG_VARTEXT
		lprintf( DBG_FILELINEFMT "Get Text failed - no PVT." DBG_RELAY );
#endif
		return NULL;
	}
#ifdef VERBOSE_DEBUG_VARTEXT
	lprintf( DBG_FILELINEFMT "Grabbing the text from %p..." DBG_RELAY, pvt );
#endif
	if( VarTextEndEx( pvt DBG_RELAY ) )
	{
		PTEXT result = pvt->commit;
		pvt->commit = NULL;
		return result;
	}
	return NULL;
}
//---------------------------------------------------------------------------
 PTEXT  VarTextPeekEx ( PVARTEXT pvt DBG_PASS )
{
	if( !pvt )
		return NULL;
 // otherwise ofs will be 0...
	if( pvt && pvt->collect_used )
	{
		SetTextSize( pvt->collect, pvt->collect_used );
		//VarTextAddCharacterEx( pvt, 0 DBG_RELAY );
		return pvt->collect;
	}
	return NULL;
}
//---------------------------------------------------------------------------
void VarTextExpandEx( PVARTEXT pvt, INDEX size DBG_PASS)
{
	pvt->collect = SegExpandEx( pvt->collect, size DBG_RELAY );
	pvt->collect_text = GetText( pvt->collect );
	pvt->collect_avail += size;
}
//---------------------------------------------------------------------------
INDEX VarTextLength( PVARTEXT pvt )
{
	//Log1( WIDE("Length is : %d"), pvt->collect_used );
	if( pvt )
		return pvt->collect_used;
	return 0;
}
//---------------------------------------------------------------------------
INDEX vvtprintf( PVARTEXT pvt, CTEXTSTR format, va_list args )
{
	INDEX len;
// this might be unicode...
#if ( defined( UNDER_CE ) || defined( _WIN32 ) ) && !defined( MINGW_SUX )
#  ifdef USE_UCRT
	{
		va_list tmp_args;
		va_copy( tmp_args, args );
#    ifdef _UNICODE
#       define vsnprintf vswprintf
#    endif
		// len returns number of characters (not NUL)
		len = vsnprintf( NULL, 0, format
							, args
							);
 // nothign to add... we'll get stuck looping if this is not checked.
		if( !len )
			return 0;
		va_end( tmp_args );
		// allocate +1 for length with NUL
		if( ((uint32_t)len+1) >= (pvt->collect_avail-pvt->collect_used) )
		{
			// expand when we need more room.
			VarTextExpand( pvt, ((len+1)<pvt->expand_by)?pvt->expand_by:(len+1+pvt->expand_by)  );
		}
#ifdef VERBOSE_DEBUG_VARTEXT
		Log3( WIDE("Print Length: %d into %d after %s"), len, pvt->collect_used, pvt->collect_text );
#endif
		// include NUL in the limit of characters able to print...
		vsnprintf( pvt->collect_text + pvt->collect_used, len+1, format, args );
	}
#  else
	int tries = 0;
	while( 1 )
	{
		size_t destlen;
		if( pvt->collect_text )
		{
			len = StringCbVPrintf ( pvt->collect_text + pvt->collect_used
									, ((destlen = pvt->collect_avail - pvt->collect_used) * sizeof( TEXTCHAR ))
									, format, args );
		}
		else
			len = STRSAFE_E_INSUFFICIENT_BUFFER;
		if( len == STRSAFE_E_INSUFFICIENT_BUFFER )
		{
			tries++;
			if( tries == 100 )
			{
				lprintf( WIDE( "Single buffer expanded more then %d" ), tries * ( (pvt->expand_by)?pvt->expand_by:(16384+pvt->expand_by) ) );
 // didn't add any
				return 0;
			}
			VarTextExpand( pvt, (pvt->expand_by)?pvt->expand_by:(16384)  );
			continue;
		}
		len = StrLen( pvt->collect_text + pvt->collect_used );
		pvt->collect_used += len;
		break;
	}
	return len;
#  endif
#elif defined( __GNUC__ ) && !defined( _WIN32 )
	{
		va_list tmp_args;
		va_copy( tmp_args, args );
#    ifdef _UNICODE
#      define vsnprintf vswprintf
#    endif
		// len returns number of characters (not NUL)
		len = vsnprintf( NULL, 0, format
#  ifdef __GNUC__
							, tmp_args
#  else
							, args
#  endif
							);
 // nothign to add... we'll get stuck looping if this is not checked.
		if( !len )
			return 0;
#  ifdef __GNUC__
		va_end( tmp_args );
#  endif
		// allocate +1 for length with NUL
		if( ((uint32_t)len+1) >= (pvt->collect_avail-pvt->collect_used) )
		{
			// expand when we need more room.
			VarTextExpand( pvt, ((len+1)<pvt->expand_by)?pvt->expand_by:(len+1+pvt->expand_by)  );
		}
#  ifdef VERBOSE_DEBUG_VARTEXT
		Log3( WIDE("Print Length: %d into %d after %s"), len, pvt->collect_used, pvt->collect_text );
#  endif
		// include NUL in the limit of characters able to print...
		vsnprintf( pvt->collect_text + pvt->collect_used, len+1, format, args );
	}
#elif defined( __WATCOMC__ )
	{
		int destlen;
		va_list _args;
		_args[0] = args[0];
		do {
#  ifdef VERBOSE_DEBUG_VARTEXT
			Log2( WIDE("Print Length: ofs %d after %s")
				 , pvt->collect_used
				 , pvt->collect_text );
#  endif
			args[0] = _args[0];
			//va_start( args, format );
#  ifdef _UNICODE
#    define vsnprintf _vsnwprintf
#  endif
			len = vsnprintf( pvt->collect_text + pvt->collect_used
								, destlen = pvt->collect_avail - pvt->collect_used
								, format, args );
 // nothign to add... we'll get stuck looping if this is not checked.
			if( !len )
				return 0;
#  ifdef VERBOSE_DEBUG_VARTEXT
			lprintf( WIDE("result of vsnprintf: %d(%d) \'%s\' (%s)")
					 , len, destlen
					 , pvt->collect_text
					 , format );
#  endif
			if( len >= destlen )
			{
				// vsnwprintf() for NULL and 0 length returns -1
				// so, make length be something larger than -1, and keep expanding by that much.
				if( len == -1 )
					len = 256;
				VarTextExpand( pvt, len + pvt->expand_by );
			}
		} while( len >= destlen );
	}
#else
	// uhmm not sure what state this is then...
	{
		do {
			len = vsnprintf( pvt->collect_text + pvt->collect_used
								, pvt->collect_avail - pvt->collect_used
								, format, args );
			if( len < 0 )
				VarTextExpand( pvt, pvt->expand_by?pvt->expand_by:4096 );
			//					 VarTextExpandEx( pvt, 32 DBG_SRC );
		} while( len < 0 );
		//Log1( WIDE("Print Length: %d"), len );
	}
#endif
#ifdef VERBOSE_DEBUG_VARTEXT
	Log2( WIDE("used: %d plus %d"), pvt->collect_used , len );
#endif
	pvt->collect_used += len;
	return len;
}
//---------------------------------------------------------------------------
INDEX vtprintfEx( PVARTEXT pvt , CTEXTSTR format, ... )
{
	va_list args;
	va_start( args, format );
	return vvtprintf( pvt, format, args );
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//
// PTEXT DumpText( PTEXT somestring )
//	 PTExT (single data segment with full description \r in text)
//
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
static CTEXTSTR Ops[] = {
	WIDE("FORMAT_OP_CLEAR_END_OF_LINE"),
	WIDE("FORMAT_OP_CLEAR_START_OF_LINE"),
	WIDE("FORMAT_OP_CLEAR_LINE "),
	WIDE("FORMAT_OP_CLEAR_END_OF_PAGE"),
	WIDE("FORMAT_OP_CLEAR_START_OF_PAGE"),
	WIDE("FORMAT_OP_CLEAR_PAGE"),
	WIDE("FORMAT_OP_CONCEAL")
 // background is how many to delete.
	  , WIDE("FORMAT_OP_DELETE_CHARS")
 // format.x, y are start/end of region -1,-1 clears.
	  , WIDE("FORMAT_OP_SET_SCROLL_REGION")
 // this works as a transaction...
	  , WIDE("FORMAT_OP_GET_CURSOR")
 // responce to getcursor...
	  , WIDE("FORMAT_OP_SET_CURSOR")
 // clear page, home page... result in page break...
	  , WIDE("FORMAT_OP_PAGE_BREAK")
 // break between paragraphs - kinda same as lines...
	  , WIDE("FORMAT_OP_PARAGRAPH_BREAK")
};
//---------------------------------------------------------------------------
static void BuildTextFlags( PVARTEXT vt, PTEXT pSeg )
{
	vtprintf( vt, WIDE( "Text Flags: " ));
	if( pSeg->flags & TF_STATIC )
		vtprintf( vt, WIDE( "static " ) );
	if( pSeg->flags & TF_QUOTE )
		vtprintf( vt, WIDE( "\"\" " ) );
	if( pSeg->flags & TF_SQUOTE )
		vtprintf( vt, WIDE( "\'\' " ) );
	if( pSeg->flags & TF_BRACKET )
		vtprintf( vt, WIDE( "[] " ) );
	if( pSeg->flags & TF_BRACE )
		vtprintf( vt, WIDE( "{} " ) );
	if( pSeg->flags & TF_PAREN )
		vtprintf( vt, WIDE( "() " ) );
	if( pSeg->flags & TF_TAG )
		vtprintf( vt, WIDE( "<> " ) );
	if( pSeg->flags & TF_INDIRECT )
		vtprintf( vt, WIDE( "Indirect " ) );
	/*
	if( pSeg->flags & TF_SINGLE )
	vtprintf( vt, WIDE( "single " ) );
	*/
	if( pSeg->flags & TF_FORMATREL )
		vtprintf( vt, WIDE( "format x,y(REL) " ) );
	if( pSeg->flags & TF_FORMATABS )
		vtprintf( vt, WIDE( "format x,y " ) );
	else
		vtprintf( vt, WIDE( "format spaces " ) );
	if( pSeg->flags & TF_COMPLETE )
		vtprintf( vt, WIDE( "complete " ) );
	if( pSeg->flags & TF_BINARY )
		vtprintf( vt, WIDE( "binary " ) );
	if( pSeg->flags & TF_DEEP )
		vtprintf( vt, WIDE( "deep " ) );
#ifdef DEKWARE_APP_FLAGS
	if( pSeg->flags & TF_ENTITY )
		vtprintf( vt, WIDE( "entity " ) );
	if( pSeg->flags & TF_SENTIENT )
		vtprintf( vt, WIDE( "sentient " ) );
#endif
	if( pSeg->flags & TF_NORETURN )
		vtprintf( vt, WIDE( "NoReturn " ) );
	if( pSeg->flags & TF_LOWER )
		vtprintf( vt, WIDE( "Lower " ) );
	if( pSeg->flags & TF_UPPER )
		vtprintf( vt, WIDE( "Upper " ) );
	if( pSeg->flags & TF_EQUAL )
		vtprintf( vt, WIDE( "Equal " ) );
	if( pSeg->flags & TF_TEMP )
		vtprintf( vt, WIDE( "Temp " ) );
#ifdef DEKWARE_APP_FLAGS
	if( pSeg->flags & TF_PROMPT )
		vtprintf( vt, WIDE( "Prompt " ) );
	if( pSeg->flags & TF_PLUGIN )
		vtprintf( vt, WIDE( "Plugin=%02x " ), (uint8_t)(( pSeg->flags >> 26 ) & 0x3f ) );
#endif
	if( (pSeg->flags & TF_FORMATABS ) )
		vtprintf( vt, WIDE( "Pos:%d,%d " )
				, pSeg->format.position.coords.x
				, pSeg->format.position.coords.y  );
	else if( (pSeg->flags & TF_FORMATREL ) )
		vtprintf( vt, WIDE( "Rel:%d,%d " )
				, pSeg->format.position.coords.x
				, pSeg->format.position.coords.y  );
	else
		vtprintf( vt, WIDE( "%d tabs %d spaces" )
				  , pSeg->format.position.offset.tabs
				  , pSeg->format.position.offset.spaces
				  );
	if( pSeg->flags & TF_FORMATEX )
		vtprintf( vt, WIDE( "format extended(%s) length:%d" )
					  , Ops[ pSeg->format.flags.format_op
							 - FORMAT_OP_CLEAR_END_OF_LINE ]
					  , GetTextSize( pSeg ) );
	else
		vtprintf( vt, WIDE( "Fore:%d Back:%d length:%d" )
					, pSeg->format.flags.foreground
					, pSeg->format.flags.background
					, GetTextSize( pSeg ) );
}
PTEXT DumpText( PTEXT text )
{
	if( text )
	{
		PVARTEXT pvt = VarTextCreate();
		PTEXT textsave = text;
		while( text )
		{
			BuildTextFlags( pvt, text );
			vtprintf( pvt, WIDE( "\n->%s\n" ), GetText( text ) );
			text = NEXTLINE( text );
		}
		textsave = VarTextGet( pvt );
		VarTextDestroy( &pvt );
		return textsave;
	}
	return NULL;
}
//---------------------------------------------------------------------------
/*
**  ASCII <=> EBCDIC conversion functions
*/
TEXTSTR ConvertAsciiEbdic( TEXTSTR text, INDEX length )
{
	static unsigned char a2e[256] = {
		0,  1,  2,  3, 55, 45, 46, 47, 22,  5, 37, 11, 12, 13, 14, 15,
		16, 17, 18, 19, 60, 61, 50, 38, 24, 25, 63, 39, 28, 29, 30, 31,
		64, 79,127,123, 91,108, 80,125, 77, 93, 92, 78,107, 96, 75, 97,
		240,241,242,243,244,245,246,247,248,249,122, 94, 76,126,110,111,
		124,193,194,195,196,197,198,199,200,201,209,210,211,212,213,214,
		215,216,217,226,227,228,229,230,231,232,233, 74,224, 90, 95,109,
		121,129,130,131,132,133,134,135,136,137,145,146,147,148,149,150,
		151,152,153,162,163,164,165,166,167,168,169,192,106,208,161,  7,
		32, 33, 34, 35, 36, 21,  6, 23, 40, 41, 42, 43, 44,  9, 10, 27,
		48, 49, 26, 51, 52, 53, 54,  8, 56, 57, 58, 59,  4, 20, 62,225,
		65, 66, 67, 68, 69, 70, 71, 72, 73, 81, 82, 83, 84, 85, 86, 87,
		88, 89, 98, 99,100,101,102,103,104,105,112,113,114,115,116,117,
		118,119,120,128,138,139,140,141,142,143,144,154,155,156,157,158,
		159,160,170,171,172,173,174,175,176,177,178,179,180,181,182,183,
		184,185,186,187,188,189,190,191,202,203,204,205,206,207,218,219,
		220,221,222,223,234,235,236,237,238,239,250,251,252,253,254,255
	};
	{
		INDEX n;
		for( n = 0; length?(n<length):text[n]; n++ )
		{
			text[n] = a2e[(unsigned)text[n]];
		}
	}
	return text;
}
/*
**  ASCII <=> EBCDIC conversion functions
*/
TEXTSTR ConvertEbcdicAscii( TEXTSTR text, INDEX length )
{
	static unsigned char e2a[256] = {
		0,  1,  2,  3,156,  9,134,127,151,141,142, 11, 12, 13, 14, 15,
		16, 17, 18, 19,157,133,  8,135, 24, 25,146,143, 28, 29, 30, 31,
		128,129,130,131,132, 10, 23, 27,136,137,138,139,140,  5,  6,  7,
		144,145, 22,147,148,149,150,  4,152,153,154,155, 20, 21,158, 26,
		32,160,161,162,163,164,165,166,167,168, 91, 46, 60, 40, 43, 33,
		38,169,170,171,172,173,174,175,176,177, 93, 36, 42, 41, 59, 94,
		45, 47,178,179,180,181,182,183,184,185,124, 44, 37, 95, 62, 63,
		186,187,188,189,190,191,192,193,194, 96, 58, 35, 64, 39, 61, 34,
		195, 97, 98, 99,100,101,102,103,104,105,196,197,198,199,200,201,
		202,106,107,108,109,110,111,112,113,114,203,204,205,206,207,208,
		209,126,115,116,117,118,119,120,121,122,210,211,212,213,214,215,
		216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,
		123, 65, 66, 67, 68, 69, 70, 71, 72, 73,232,233,234,235,236,237,
		125, 74, 75, 76, 77, 78, 79, 80, 81, 82,238,239,240,241,242,243,
		92,159, 83, 84, 85, 86, 87, 88, 89, 90,244,245,246,247,248,249,
		48, 49, 50, 51, 52, 53, 54, 55, 56, 57,250,251,252,253,254,255
	};
	{
		INDEX n;
		for( n = 0; length?(n<length):text[n]; n++ )
		{
			text[n] = e2a[(unsigned)text[n]];
		}
	}
	return text;
}
//---------------------------------------------------------------------------
#define NUM_RESERVED (sizeof(reserved_uri)/sizeof(reserved_uri[0]))
static TEXTCHAR reserved_uri[] = {'!','*','\'','(',')',';',':','@','&','=','+','$',',','/','?','#','[',']'
												  ,'<','>','~','.','"','{','}','|','\\','-','`','_','^','%',' '
												  , 0 };
static const TEXTCHAR *translated[] = { WIDE( "%21" ),WIDE( "%2A" ),WIDE( "%27" ),WIDE( "%28" ),WIDE( "%29" ),WIDE( "%3B" ),WIDE( "%3A" )
												,WIDE( "%40" ),WIDE( "%26" ),WIDE( "%3D" ),WIDE( "%2B" ),WIDE( "%24" ),WIDE( "%2C" ),WIDE( "%2F" )
												 ,WIDE( "%3F" ),WIDE( "%23" ),WIDE( "%5B" ),WIDE( "%5D" )
												 ,WIDE( "%3C" ),WIDE( "%3E" ),WIDE( "%7E" ),WIDE( "%2E" ),WIDE( "%22" ),WIDE( "%7B" ),WIDE( "%7D" ),WIDE( "%7C" ),WIDE( "%5C" ),WIDE( "%2D" ),WIDE( "%60" ),WIDE( "%5F" ),WIDE( "%5E" ),WIDE( "%25" ),WIDE( "%20" )
};
static int MeasureTextURI( CTEXTSTR text, INDEX length, int skip_slash )
{
	// compute how long it should be.
	INDEX i;
	int out_length = 0;
	for( i = 0; i < length && text[i]; i++ )
	{
		if( skip_slash && text[i] == '/' )
			out_length++;
		else if( StrChr( reserved_uri, text[i] ) )
			out_length += 3;
		else
			out_length++;
	}
	return out_length;
}
TEXTSTR ConvertTextURI( CTEXTSTR text, INDEX length, int skip_slash )
{
	int target_len = MeasureTextURI( text, length, skip_slash );
	TEXTSTR target = NewArray( TEXTCHAR, target_len + 1 );
	INDEX i;
	TEXTSTR out_pos = target;
	const TEXTCHAR *char_pos;
	for( i = 0; i < length && text[i]; i++ )
	{
		if( skip_slash && text[i] == '/' )
		{
			out_pos[0] = text[i];
			out_pos++;
		}
		else if( ( char_pos = StrChr( reserved_uri, text[i] ) ) )
		{
#ifdef __cplusplus
			sack::memory::
#endif
			StrCpyEx( out_pos, translated[char_pos - reserved_uri], target_len - ( out_pos - target ) );
			out_pos += 3;
		}
		else
		{
			out_pos[0] = text[i];
			out_pos++;
		}
	}
	out_pos[0] = 0;
	return target;
}
static int MeasureURIText( CTEXTSTR text, INDEX length )
{
	// compute how long it should be.
	INDEX i;
	int out_length = 0;
	for( i = 0; i < length && text[i]; i++ )
	{
		if( text[i] == '%' )
		{
			i += 2;
			out_length++;
		}
		else
			out_length++;
	}
	return out_length;
}
TEXTSTR ConvertURIText( CTEXTSTR text, INDEX length )
{
	int target_len = MeasureURIText( text, length );
	TEXTSTR target = NewArray( TEXTCHAR, target_len + 1 );
	INDEX i;
	TEXTSTR out_pos = target;
	for( i = 0; i < length && text[i]; i++ )
	{
		if( text[i] == '%' )
		{
			char char_byte;
			// A 41
			// a 61
			// 0 30
			char_byte = (((text[i+1] & 10)?(text[i+1]-0x30)
							  : (text[i+1] & 20)?(text[i+1]-'a'+10)
							  : (text[i+1]-'A'+10)) << 4 )
				| (((text[i+2] & 10)?(text[i+2]-0x30)
					 : (text[i+2] & 20)?(text[i+2]-'a'+10)
					 : (text[i+2]-'A'+10)) );
			out_pos[0] = char_byte;
			out_pos++;
		}
		else
		{
			out_pos[0] = text[i];
			out_pos++;
		}
	}
	out_pos[0] = 0;
	//out_pos++;
	return target;
}
//---------------------------------------------------------------------------
int ConvertToUTF16( wchar_t *output, TEXTRUNE rune )
{
	if( !( rune & 0xFFFF0000 ) )
	{
		if( rune < 0xD800 || rune >= 0xE000 )
		{
			output[0] = (wchar_t)rune;
			return 1;
		}
		else
 // invalid rune specified.
			return 0;
	}
	else
	{
		rune -= 0x10000;
		if( !( rune & 0xFFFFF ) )
		{
			output[0] = 0xD800 + (wchar_t)( ( rune & 0xFFC00 ) >> 10 );
			output[1] = 0xDC00 + (wchar_t)( ( rune & 0x003FF ) );
			return 2;
		}
	}
 // invalid rune.
	return 0;
}
int ConvertToUTF8( char *output, TEXTRUNE rune )
{
	int ch = 1;
	if( !( rune & 0xFFFFFF80 ) )
	{
		// 7 bits
		(*output++) = (char)rune;
		goto plus0;
	}
	else if( !( rune & 0xFFFFF800 ) )
	{
		// 11 bits
		(*output++) = 0xC0 | ( ( ( rune & 0x07C0 ) >> 6 ) & 0xFF );
		goto plus1;
	}
	else if( !( rune & 0xFFFF0000 ) )
	{
		// 16 bits
		(*output++) = 0xE0 | ( ( ( rune & 0xF000 ) >> 12 ) & 0xFF );
		goto plus2;
	}
	else if( !( rune & 0xFFE00000 ) )
	{
		// 21 bits
		(*output++) = 0xF0 | ( ( ( rune & 0x1C0000 ) >> 15 ) & 0xFF );
		goto plus3;
	}
	else if( !( rune & 0xFC000000 ) )
	{
		// 26 bits
		(*output++) = 0xF8 | ( ( ( rune & 0x3000000 ) >> 24 ) & 0xFF );
		goto plus4;
	}
	else if( !( rune & 0x80000000 ) )
	{
		// 31 bits
		(*output++) = 0xFC | ( ( ( rune & 0x40000000 ) >> 30 ) & 0xFF );
		//goto plus5;
	}
	// invalid rune (out of range)
//plus5:
	ch++; (*output++) = 0x80 | (((rune & 0x3F000000) >> 24) & 0xFF);
plus4:
	ch++; (*output++) = 0x80 | (((rune & 0x0FC0000) >> 18) & 0xFF);
plus3:
	ch++; (*output++) = 0x80 | (((rune & 0x03F000) >> 12) & 0xFF);
plus2:
	ch++; (*output++) = 0x80 | (((rune & 0x0FC0) >> 6) & 0xFF);
plus1:
	ch++; (*output++) = 0x80 | (rune & 0x3F);
plus0:
	return ch;
}
int ConvertToUTF8Ex( char *output, TEXTRUNE rune, LOGICAL overlong )
{
	int ch = 1;
	if( !overlong ) return ConvertToUTF8( output, rune );
	if( !(rune & 0xFFFFFF80) )
	{
		// 11 bits
		(*output++) = 0xC0 | (((rune & 0x07C0) >> 6) & 0xFF);
		goto plus1;
	}
	else if( !(rune & 0xFFFFF800) )
	{
		// 16 bits
		(*output++) = 0xE0 | (((rune & 0xF000) >> 12) & 0xFF);
		goto plus2;
	}
	else if( !(rune & 0xFFFF0000) )
	{
		// 21 bits
		(*output++) = 0xF0 | (((rune & 0x1C0000) >> 15) & 0xFF);
		goto plus3;
	}
	else if( !(rune & 0xFFE00000) )
	{
		// 26 bits
		(*output++) = 0xF8 | (((rune & 0x3000000) >> 24) & 0xFF);
		goto plus4;
	}
	else if( !(rune & 0xFC000000) )
	{
		// 31 bits
		(*output++) = 0xFC | (((rune & 0x40000000) >> 30) & 0xFF);
		goto plus5;
	}
	else if( !(rune & 0x80000000) ) {
		(*output++) = 0xFEU;
	}
	ch++; (*output++) = 0x80 | (((rune & 0xC0000000) >> 30) & 0xFF);
plus5:
	ch++; (*output++) = 0x80 | (((rune & 0x3F000000) >> 24) & 0xFF);
plus4:
	ch++; (*output++) = 0x80 | (((rune & 0x0FC0000) >> 18) & 0xFF);
plus3:
	ch++; (*output++) = 0x80 | (((rune & 0x03F000) >> 12) & 0xFF);
plus2:
	ch++; (*output++) = 0x80 | (((rune & 0x0FC0) >> 6) & 0xFF);
plus1:
	ch++; (*output++) = 0x80 | (rune & 0x3F);
//plus0:
	return ch;
}
char * WcharConvertExx ( const wchar_t *wch, size_t len DBG_PASS )
{
	// Conversion to char* :
	// Can just convert wchar_t* to char* using one of the
	// conversion functions such as:
	// WideCharToMultiByte()
	// wcstombs_s()
	// ... etc
	size_t  sizeInBytes;
	char  tmp[2];
	char	 *ch;
	char	 *_ch;
	const wchar_t *_wch = wch;
 // start with 1 for the ending nul
	sizeInBytes = 1;
	_ch = ch = tmp;
	{
		size_t n;
		for( n = 0; n < len; n++ )
		{
			//lprintf( "wch = %04x", wch[0] );
			if( !( wch[0] & 0xFF80 ) )
			{
				//lprintf( "1 byte encode..." );
				sizeInBytes++;
			}
			else if( !( wch[0] & 0xF800 ) )
			{
				//lprintf( "2 byte encode..." );
				sizeInBytes += 2;
			}
			else if( (  ( ( wch[0] & 0xFC00 ) >= 0xD800 )
					   && ( ( wch[0] & 0xFC00 ) < 0xDC00 ) )
					 && ( ( ( wch[1] & 0xFC00 ) >= 0xDC00 )
					   && ( ( wch[1] & 0xFC00 ) < 0xE000 ) )
					 )
			{
				int longer_value = 0x10000 + ( ( ( wch[0] & 0x3ff ) << 10 ) | ( ( wch[1] & 0x3ff ) ) );
				//lprintf( "3 or 4 byte encode..." );
				if( !(longer_value & 0xFFFF0000 ) )
					sizeInBytes += 3;
 // hack a way to encode D800-DFFF
				else if( ( longer_value >= 0xF0000 ) && ( longer_value < 0xF0800 ) )
					sizeInBytes += 2;
				else
					sizeInBytes += 4;
				wch++;
			}
			else
			{
				// just encode the 16 bits as it is.
				//lprintf( " 3 byte encode?" );
				sizeInBytes+= 3;
			}
			wch++;
		}
	}
	wch = _wch;
	_ch = ch = NewArray( char, sizeInBytes);
	{
		size_t n;
		for( n = 0; n < len; n++ )
		{
			{
				if( !( wch[0] & 0xFF80 ) )
				{
					(*ch++) = ((unsigned char*)wch)[0];
				}
				else if( !( wch[0] & 0xFF00 ) )
				{
					//(*ch++) = ((unsigned char*)wch)[0];
					(*ch++) = 0xC0 | ( ( ((unsigned char*)wch)[1] & 0x7 ) << 2 ) | ( ( ((unsigned char*)wch)[0] ) >> 6 );
					(*ch++) = 0x80 | ( ((unsigned char*)wch)[0] & 0x3F );
				}
				else if( !( wch[0] & 0xF800 ) )
				{
					(*ch++) = 0xC0 | ( ( ((unsigned char*)wch)[1] & 0x7 ) << 2 ) | ( ( ((unsigned char*)wch)[0] ) >> 6 );
					(*ch++) = 0x80 | ( ((unsigned char*)wch)[0] & 0x3F );
				}
				else if( (  ( ( wch[0] & 0xFC00 ) >= 0xD800 )
							 && ( ( wch[0] & 0xFC00 ) < 0xDC00 ) )
						  && ( ( ( wch[1] & 0xFC00 ) >= 0xDC00 )
								&& ( ( wch[1] & 0xFC00 ) < 0xE000 ) )
					 )
				{
					uint32_t longer_value;
					longer_value = 0x10000 + ( ( ( wch[0] & 0x3ff ) << 10 ) | ( ( wch[1] & 0x3ff ) ) );
 // hack a way to encode D800-DFFF
					if( ( longer_value >= 0xF0000 ) && ( longer_value < 0xF0800 ) )
					{
						longer_value = ( longer_value - 0xF0000 ) + 0xD800;
						sizeInBytes += 2;
					}
					wch++;
					if( !(longer_value & 0xFFFF ) )
					{
						// 16 bit encoding (shouldn't be hit
						(*ch++) = 0xE0 | (char)( ( longer_value >> 12 ) & 0x0F );
						(*ch++) = 0x80 | (char)( ( longer_value >> 6 ) & 0x3f );
						(*ch++) = 0x80 | (char)( ( longer_value >> 0 ) & 0x3f );
					}
					else if( !( longer_value & 0xFFE00000 ) )
					{
						// 21 bit encoding ...
						(*ch++) = 0xF0 | (char)( ( longer_value >> 18 ) & 0x07 );
						(*ch++) = 0x80 | (char)( ( longer_value >> 12 ) & 0x3f );
						(*ch++) = 0x80 | (char)( ( longer_value >> 6 ) & 0x3f );
						(*ch++) = 0x80 | (char)( ( longer_value >> 0 ) & 0x3f );
					}
					/*  ** functionally removed from spec ..... surrogates cannot be this long.
					else if( !( longer_value & 0xFC000000 ) )
					{
						(*ch++) = 0xF8 | ( longer_value >> 24 );
						(*ch++) = 0x80 | ( ( longer_value >> 18 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 12 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 6 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 0 ) & 0x3f );
					}
					else  if( !( longer_value & 0x80000000 ) )
					{
						// 31 bit encode
						(*ch++) = 0xFC | ( longer_value >> 30 );
						(*ch++) = 0x80 | ( ( longer_value >> 24 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 18 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 12 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 6 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 0 ) & 0x3f );
					}
					*/
					else
					{
						// too long to encode.
					}
				}
				else
				{
					   //lprintf( " 3 byte encode?  16 bits" );
 // mask just in case of stupid compiles that tread wchar as signed?
						(*ch++) = 0xE0 | ( ( wch[0] >> 12 ) & 0x0F );
						(*ch++) = 0x80 | ( ( wch[0] >> 6 ) & 0x3f );
						(*ch++) = 0x80 | ( ( wch[0] >> 0 ) & 0x3f );
				}
			}
			wch++;
		}
	}
	(*ch) = 0;
	ch = _ch;
	return ch;
}
char * WcharConvertEx ( const wchar_t *wch DBG_PASS )
{
	size_t len;
	for( len = 0; wch[len]; len++ );
	return WcharConvertExx( wch, len DBG_RELAY );
}
wchar_t * CharWConvertExx ( const char *wch, size_t len DBG_PASS )
{
	// Conversion to wchar_t* :
	// Can just convert wchar_t* to char* using one of the
	// conversion functions such as:
	// WideCharToMultiByte()
	// wcstombs_s()
	// ... etc
	size_t  sizeInChars = 0;
	const char *_wch = wch;
	wchar_t	*ch;
	wchar_t   *_ch;
	{
		size_t n;
		for( n = 0; n < len; n++ )
		{
			//lprintf( "first char is %d (%08x)", wch[0] );
			if( (wch[0] & 0xE0) == 0xC0 )
				wch += 2;
			else if( (wch[0] & 0xF0) == 0xE0 )
				wch += 3;
			else if( (wch[0] & 0xF0) == 0xF0 )
			{
				sizeInChars++;
				wch += 4;
			}
			else
				wch++;
			sizeInChars++;
		}
	}
	wch = _wch;
	_ch = ch = NewArray( wchar_t, sizeInChars + 1 );
	{
		size_t n;
		for( n = 0; n < len; n++ )
		{
			//lprintf( "first char is %d (%08x)", wch[0] );
			if( ( wch[0] & 0xE0 ) == 0xC0 )
			{
				ch[0] = ( ( (wchar_t)wch[0] & 0x1F ) << 6 ) | ( (wchar_t)wch[1] & 0x3f );
				wch += 2;
			}
			else if( ( wch[0] & 0xF0 ) == 0xE0 )
			{
				ch[0] = ( ( (wchar_t)wch[0] & 0xF ) << 12 )
					| ( ( (wchar_t)wch[1] & 0x3F ) << 6 )
					| ( (wchar_t)wch[2] & 0x3f );
				wch += 3;
			}
			else if( ( wch[0] & 0xF0 ) == 0xF0 )
			{
				uint32_t literal_char =  ( ( (wchar_t)wch[0] & 0x7 ) << 18 )
				                 | ( ( (wchar_t)wch[1] & 0x3F ) << 12 )
				                 | ( (wchar_t)wch[2] & 0x3f ) << 6
				                 | ( (wchar_t)wch[3] & 0x3f );
				//lprintf( "literal char is %d (%08x", literal_char, literal_char );
// ((wchar_t*)&literal_char)[0];
				ch[0] = 0xD800 + ( ( ( literal_char - 0x10000 ) & 0xFFC00 ) >> 10 );
// ((wchar_t*)&literal_char)[1];
				ch[1] = 0xDC00 + ( ( literal_char - 0x10000 ) & 0x3ff );
				ch++;
				wch += 4;
			}
			else
			{
				ch[0] = wch[0] & 0x7f;
				wch++;
			}
			ch++;
		}
		ch[0] = 0;
	}
	return _ch;
}
wchar_t * CharWConvertEx ( const char *ch DBG_PASS )
{
	int len;
	for( len = 0; ch[len]; len++ );
	return CharWConvertExx( ch, len DBG_RELAY );
}
LOGICAL ParseStringVector( CTEXTSTR data, CTEXTSTR **pData, int *nData )
{
	if( !data[0] )
	{
		*nData = 0;
		return 0;
	}
	//xlprintf(2100)( "ParseStringVector" );
	//if( StrChr( data, ',' ) )
	{
		CTEXTSTR start, end;
		int count = 0;
		end = data;
		do
		{
			count++;
			start = end;
			end = StrChr( start, ',' );
			if( end )
				end++;
		}
		while( end );
		if( (*pData) )
		{
			//lprintf( "Had old data, release and make new" );
			Release( (POINTER)(*pData) );
		}
		(*pData) = NewArray( CTEXTSTR, count );
		(*nData) = count;
		count = 0;
		end = data;
		do
		{
			size_t len;
			start = end;
			end = StrChr( start, ',' );
			if( end )
			{
				end++;
				(*pData)[count] = NewArray( TEXTCHAR, len = end - start );
			}
			else
			{
				(*pData)[count] = NewArray( TEXTCHAR, len = StrLen( start ) + 1 );
			}
			StrCpyEx( (TEXTSTR)(*pData)[count], start, len );
			count++;
		}
		while( end );
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------------
TEXTRUNE GetUtfChar( const char * *from )
{
	TEXTRUNE result = (unsigned char)(*from)[0];
	//if( !result ) return result;
	if( (*from)[0] & 0x80 )
	{
		if( ( (*from)[0] & 0xE0 ) == 0xC0 )
		{
			if( ( (*from)[1] & 0xC0 ) == 0x80 )
			{
				result = ( ( (unsigned int)(*from)[0] & 0x1F ) << 6 ) | ( (unsigned int)(*from)[1] & 0x3f );
				(*from) += 2;
			}
			else
			{
				result = 0;
				//lprintf( "a 2 byte code with improper continuation encodings following it was found. %02x %02x"
				//		, (*from)[0]
				//		, (*from)[1]
				//		);
				(*from)++;
			}
		}
		else if( ( (*from)[0] & 0xF0 ) == 0xE0 )
		{
			if( ( ( (*from)[1] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[2] & 0xC0 ) == 0x80 ) )
			{
				result = ( ( (unsigned int)(*from)[0] & 0xF ) << 12 ) | ( ( (unsigned int)(*from)[1] & 0x3F ) << 6 ) | ( (unsigned int)(*from)[2] & 0x3f );
				(*from) += 3;
			}
			else
			{
				result = 0;
				//lprintf( "a 3 byte code with improper continuation encodings following it was found. %02x %02x %02x"
				//	, (*from)[0]
				//	, (*from)[1]
				//	, (*from)[2]
				//	);
				(*from)++;
			}
		}
		else if( ( (*from)[0] & 0xF8 ) == 0xF0 )
		{
			if( ( ( (*from)[1] & 0xC0 ) == 0x80 ) && ( ( (*from)[2] & 0xC0 ) == 0x80 ) && ( ( (*from)[3] & 0xC0 ) == 0x80 ) )
			{
				result =   ( ( (unsigned int)(*from)[0] & 0x7 ) << 18 )
						| ( ( (unsigned int)(*from)[1] & 0x3F ) << 12 )
						| ( ( (unsigned int)(*from)[2] & 0x3f ) << 6 )
						| ( (unsigned int)(*from)[3] & 0x3f );
				(*from) += 4;
			}
			else
			{
				result = 0;
				//lprintf( "a 4 byte code with improper continuation encodings following it was found." );
				(*from)++;
			}
		}
		else if( ( (*from)[0] & 0xFC ) == 0xF8 )
		{
			if( ( ( (*from)[1] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[2] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[3] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[4] & 0xC0 ) == 0x80 )
			  )
			{
				result =   ( ( (unsigned int)(*from)[0] & 0x3 ) << 24 )
						| ( ( (unsigned int)(*from)[1] & 0x3F ) << 18 )
						| ( ( (unsigned int)(*from)[2] & 0x3F ) << 12 )
						| ( ( (unsigned int)(*from)[3] & 0x3f ) << 6 )
						| ( (unsigned int)(*from)[4] & 0x3f );
				(*from) += 5;
			}
			else
			{
				result = 0;
				//lprintf( "a 4 byte code with improper continuation encodings following it was found." );
				(*from)++;
			}
		}
		else if( ( (*from)[0] & 0xFE ) == 0xFC )
		{
			if( ( ( (*from)[1] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[2] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[3] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[4] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[5] & 0xC0 ) == 0x80 )
			  )
			{
				result =   ( ( (unsigned int)(*from)[0] & 0x1 ) << 30 )
						| ( ( (unsigned int)(*from)[1] & 0x3F ) << 24 )
						| ( ( (unsigned int)(*from)[2] & 0x3F ) << 18 )
						| ( ( (unsigned int)(*from)[3] & 0x3F ) << 12 )
						| ( ( (unsigned int)(*from)[4] & 0x3f ) << 6 )
						| ( (unsigned int)(*from)[5] & 0x3f );
				(*from) += 6;
			}
			else
			{
				result = 0;
				//lprintf( "a 4 byte code with improper continuation encodings following it was found." );
				(*from)++;
			}
		}
		else if( ( (*from)[0] & 0xC0 ) == 0x80 )
		{
			// things like 0x9F, 0x9A is OK; is a single byte character, is a unicode application escape
			//lprintf( "a continuation encoding was found." );
			//result = (unsigned char)(*from)[0];
			(*from)++;
		}
		else
		{
			//result = (unsigned char)(*from)[0];
			(*from)++;
		}
	}
	else
	{
		result = (unsigned char)(*from)[0];
		(*from)++;
	}
	return result;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetUtfCharIndexed( const char * pc, size_t *n, size_t length )
{
	if( length )
	{
		CTEXTSTR orig = pc + n[0];
		CTEXTSTR tmp = orig;
		TEXTRUNE result = GetUtfChar( &tmp );
		if( (size_t)( tmp - orig ) <= length ) {
			n[0] += tmp - orig;
			return result;
		}
		// if illformed character was at the end... return 0
	   // cap result to length.
		( *n ) = length;
	}
	return 0;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetPriorUtfChar( const char *start, const char * *from )
{
	TEXTRUNE result;
	if( (*from) == start ) return 0;
	result = (unsigned char)(*from)[-1];
	if( !result ) return result;
	if( (*from)[-1] & 0x80 )
	{
		CTEXTSTR end;
		while( (*from > start) && ( (*from)[-1] & 0xC0 ) == 0x80 )
			(*from)--;
		if( (*from > start) ) {
			(*from)--;
			end = (*from);
			result = GetUtfChar( from );
			(*from) = end;
		}
		else
			result = 0;
	}
	else
	{
		result = (unsigned char)(*from)[-1];
		(*from)--;
	}
	return result;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetPriorUtfCharIndexed( const char *pc, size_t *n )
{
	if( *n )
	{
		CTEXTSTR orig = pc + n[0];
		CTEXTSTR tmp = orig;
		TEXTRUNE result = GetPriorUtfChar( pc, &tmp );
		if( tmp <= orig ) {
			n[0] -= orig - tmp;
			return result;
		}
	}
	return INVALID_RUNE;
}
//---------------------------------------------------------------------------
TEXTRUNE GetUtfCharW( const wchar_t * *from )
{
	TEXTRUNE result = (unsigned)(*from)[0];
	if( !result ) return result;
	if( ( ( (*from)[0] & 0xFC00 ) >= 0xD800 )
		&& ( ( (*from)[0] & 0xFC00 ) <= 0xDF00 ) )
	{
		result = 0x10000 + ( ( ( (*from)[0] & 0x3ff ) << 10 ) | ( ( (*from)[1] & 0x3ff ) ) );
		(*from) += 2;
	}
	else
	{
		(*from)++;
	}
	return result;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetUtfCharIndexedW( const wchar_t* pc, size_t *n )
{
	const wchar_t * orig = pc + n[0];
	const wchar_t * tmp = orig;
	TEXTRUNE result = GetUtfCharW( &tmp );
	n[0] += tmp - orig;
	return result;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetPriorUtfCharW( const wchar_t*start, const wchar_t* *from )
{
	TEXTRUNE result = (unsigned)(*from)[-1];
	if( !result ) return result;
	if( ( ( (*from)[0] & 0xFC00 ) >= 0xD800 )
		&& ( ( (*from)[0] & 0xFC00 ) <= 0xDF00 ) )
	{
		result = 0x10000 + ( ( ( (*from)[0] & 0x3ff ) << 10 ) | ( ( (*from)[1] & 0x3ff ) ) );
		(*from) += 2;
	}
	else
	{
		(*from)++;
	}
	return result;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetPriorUtfCharIndexedW( const wchar_t *pc, size_t *n )
{
	if( *n )
	{
		const wchar_t * orig = pc + n[0];
		const wchar_t * tmp = orig;
		TEXTRUNE result = GetPriorUtfCharW( pc, &tmp );
		n[0] += tmp - orig;
		return result;
	}
	return 0;
}
//---------------------------------------------------------------------------
// Return the integer character from the string
// using utf-8 or utf-16 decoding appropriately.  No more extended-ascii.
static int Step( CTEXTSTR *pc, size_t *nLen )
{
	CTEXTSTR _pc = (*pc);
	int ch;
	//lprintf( "Step (%s[%*.*s])", (*pc), nLen,nLen, (*pc) );
	if( nLen && !*nLen )
		return 0;
	ch = GetUtfChar( pc );
	//if( ch & 0xFFE00000 )
	//	DebugBreak();
	if( nLen )
		(*nLen) -= (*pc) - _pc;
	_pc = (*pc);
	if( ch )
	{
		while( ch == WIDE('\x9F') )
		{
			while( ch && ( ch != WIDE( '\x9C' ) ) )
			{
				ch = GetUtfChar( pc );
				if( nLen )
					(*nLen) -= (*pc) - _pc;
				_pc = (*pc);
			}
			// if the string ended...
			if( !ch )
			{
				// this is done.  There's nothing left... command with no data is bad form, but not illegal.
				return FALSE;
			}
  // pc is now on the stop command, advance one....
			else
			{
				// this is in a loop, and the next character may be another command....
				ch = GetUtfChar( pc );
				if( nLen )
					(*nLen) -= (*pc) - _pc;
				_pc = (*pc);
			}
		}
	}
	return ch;
}
size_t GetDisplayableCharacterBytes( CTEXTSTR string, size_t character_count )
{
	CTEXTSTR original = string;
	int ch;
	if( !string ) return 0;
	while( character_count &&
		( ch = Step( &string, NULL ) ) )
	{
		character_count--;
	}
	return string - original;
}
size_t GetDisplayableCharacterCount( CTEXTSTR string, size_t max_bytes )
{
	int ch;
	size_t count = 0;
	if( !string ) return 0;
	while( ( ch = Step( &string, &max_bytes ) ) )
	{
		count++;
	}
	return count;
}
CTEXTSTR GetDisplayableCharactersAtCount( CTEXTSTR string, size_t nLen )
{
	int ch;
	if( !string ) return 0;
	while( nLen > 0 &&
		 ( ch = Step( &string, NULL ) ) )
	{
		nLen--;
	}
	return string;
}
LOGICAL ParseIntVector( CTEXTSTR data, int **pData, int *nData )
{
	if( !data[0] )
	{
		*nData = 0;
		return 0;
	}
	//xlprintf(2100)( "ParseIntVector" );
	//if( StrChr( data, ',' ) )
	{
		CTEXTSTR start, end;
		int count = 0;
		end = data;
		do
		{
			count++;
			start = end;
			end = StrChr( start, ',' );
			if( end )
				end++;
		}
		while( end );
		if( (*pData) )
		{
			//lprintf( "Had old data, release and make new" );
			Release( (*pData) );
		}
		(*pData) = NewArray( int, count );
		(*nData) = count;
		count = 0;
		end = data;
		do
		{
#ifndef _MSC_VER
#if defined( _UNICODE )
#   define sscanf     swscanf
#endif
#else
#if defined( _UNICODE )
#   undef sscanf
#   define sscanf     swscanf_s
#endif
#endif
			start = end;
			sscanf( start, WIDE("%d"), (*pData) + count );
			count++;
			end = StrChr( start, ',' );
			if( end )
				end++;
		}
		while( end );
		return TRUE;
	}
	return FALSE;
}
const char encodings[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$_";
const char encodings2[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
static TEXTCHAR b64xor_table[256][256];
static TEXTCHAR u8xor_table[256][256];
static TEXTCHAR b64xor_table2[256][256];
static TEXTCHAR u8xor_table2[256][256];
PRELOAD( initTables ) {
	int n, m;
	for( n = 0; n < (sizeof( encodings )-1); n++ )
		for( m = 0; m < (sizeof( encodings )-1); m++ ) {
			b64xor_table[encodings[n]][encodings[m]] = encodings[n^m];
			u8xor_table[n][encodings[m]] = n^m;
			b64xor_table2[encodings2[n]][encodings2[m]] = encodings2[n^m];
			u8xor_table2[n][encodings2[m]] = n^m;
	}
	//LogBinary( (uint8_t*)u8xor_table[0], sizeof( u8xor_table ) );
	b64xor_table['=']['='] = '=';
}
char * b64xor( const char *a, const char *b ) {
	int n;
	char *out = NewArray( char, strlen(a) + 1);
	for( n = 0; a[n]; n++ ) {
		out[n] = b64xor_table[a[n]][b[n]];
	}
	out[n] = 0;
	return out;
}
char * u8xor( const char *a, size_t alen, const char *b, size_t blen, int *ofs ) {
	size_t n;
	size_t keylen = blen-5;
	int o = ofs[0];
	size_t outlen;
	char *out = NewArray( char, (outlen=alen) + 1);
	char *_out = out;
	int l = 0;
	int _mask = 0x3f;
	for( n = 0; n < alen; n++ ) {
		char v = (*a++);
		int mask;
		mask = _mask;
		if( (v & 0x80) == 0x00 ) { if( l ) lprintf( "short utf8 sequence found" ); mask = 0x3f; _mask = 0x3f; }
		else if( (v & 0xC0) == 0x80 ) { if( !l ) lprintf( "invalid utf8 sequence" ); l--; _mask = 0x3f; }
		else if( (v & 0xE0) == 0xC0 ) { if( l )
  // 6 + 1 == 7
			lprintf( "short utf8 sequence found" ); l = 1; mask = 0x1; _mask = 0x3f; }
		else if( (v & 0xF0) == 0xE0 ) { if( l )
  // 6 + 5 + 0 == 11
			lprintf( "short utf8 sequence found" ); l = 2; mask = 0;  _mask = 0x1f; }
		else if( (v & 0xF8) == 0xF0 ) { if( l )
  // 6(2) + 4 + 0 == 16
			lprintf( "short utf8 sequence found" ); l = 3; mask = 0;  _mask = 0x0f; }
		else if( (v & 0xFC) == 0xF8 ) { if( l )
  // 6(3) + 3 + 0 == 21
			lprintf( "short utf8 sequence found" ); l = 4; mask = 0;  _mask = 0x07; }
		else if( (v & 0xFE) == 0xFC ) { if( l )
  // 6(4) + 2 + 0 == 26
			lprintf( "short utf8 sequence found" ); l = 5; mask = 0;  _mask = 0x03; }
		char bchar = b[(n+o)%(keylen)];
		(*out) = (v & ~mask ) | ( u8xor_table[v & mask ][bchar] & mask );
		out++;
	}
	(*out) = 0;
	ofs[0] = (int)((ofs[0]+outlen)%keylen);
	return _out;
}
static const char * const _base642 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$_=";
static const char * const _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
static void encodeblock( unsigned char in[3], TEXTCHAR out[4], size_t len, const char *base64 )
{
	out[0] = base64[ in[0] >> 2 ];
	out[1] = base64[ ((in[0] & 0x03) << 4) | ( ( len > 0 ) ? ((in[1] & 0xf0) >> 4) : 0 ) ];
	out[2] = (len > 1 ? base64[ ((in[1] & 0x0f) << 2) | ( ( len > 2 ) ? ((in[2] & 0xc0) >> 6) : 0 ) ] : base64[64]);
	out[3] = (len > 2 ? base64[ in[2] & 0x3f ] : base64[64]);
}
static void decodeblock( unsigned char in[4], char out[3], size_t len, const char *base64 )
{
	const char *index[4];
	int n;
	for( n = 0; n < 4; n++ )
	{
		index[n] = strchr( base64, in[n] );
		//if( ( index[n] - base64 ) == 64 )
		//	last_byte = 1;
	}
	//if(
	out[0] = (char)(( index[0] - base64 ) << 2 | ( index[1] - base64 ) >> 4);
	out[1] = (char)(( index[1] - base64 ) << 4 | ( ( ( index[2] - base64 ) >> 2 ) & 0x0f ));
	out[2] = (char)(( index[2] - base64 ) << 6 | ( ( index[3] - base64 ) & 0x3F ));
	//out[] = (len > 2 ? base64[ in[2] & 0x3f ] : 0);
}
TEXTCHAR *EncodeBase64Ex( uint8_t* buf, size_t length, size_t *outsize, const char *base64 )
{
	TEXTCHAR * real_output;
	if( !base64 )
		base64 = _base64;
	else if( ((uintptr_t)base64) == 1 )
		base64 = _base642;
	real_output = NewArray( TEXTCHAR, 1 + ( ( length * 4 + 2) / 3 ) + 1 + 1 + 1 );
	{
		size_t n;
		for( n = 0; n < (length+2)/3; n++ )
		{
			size_t blocklen;
			blocklen = length - n*3;
			if( blocklen > 3 )
				blocklen = 3;
			encodeblock( ((uint8_t*)buf) + n * 3, real_output + n*4, blocklen, base64 );
		}
		(*outsize) = n*4 + 1;
		real_output[n*4] = 0;
	}
	return real_output;
}
char *DecodeBase64Ex( uint8_t* buf, size_t length, size_t *outsize, const char *base64 )
{
	char * real_output;
	if( !base64 )
		base64 = _base64;
	else if( ((uintptr_t)base64) == 1 )
		base64 = _base642;
	real_output = NewArray( char, ( ( ( length + 1 ) * 3 ) / 4 ) + 1 );
	{
		size_t n;
		for( n = 0; n < (length+3)/4; n++ )
		{
			size_t blocklen;
			blocklen = length - n*4;
			if( blocklen > 4 )
				blocklen = 4;
			decodeblock( ((uint8_t*)buf) + n * 4, real_output + n*3, blocklen, base64 );
		}
		real_output[n*3] = 0;
	}
	return real_output;
}
#ifdef __cplusplus
 //namespace text {
};
 //namespace containers {
};
 // namespace sack {
};
#endif
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   A binary tree container storing a user pointer blob of some user defined structure
 *   and a uintptr_t key which is used to check for content matchin.
 *   Binary tree has algorithms to become balanced, if the input is known to be weighted,
 *   or if statistics are pulled that indicate that the tree should be balanced, this
 *   function is available on demand.  Also searching through the tree using
 *   Least, Greatest, lesser, and greater is available.
 *
 * see also - include/typelib.h
 *
 */
//#include <sack_types.h>
//#include <sharemem.h>
//#include <logging.h>
//#define DEBUG_STEPPING
#ifdef __cplusplus
namespace sack {
	namespace containers {
		namespace BinaryTree {
		using namespace sack::memory;
		using namespace sack::logging;
#endif
// consider slab allocation... 32 bytes even.
struct treenode_tag {
	struct {
		BIT_FIELD bUsed:1;
		BIT_FIELD bRoot:1;
	} flags;
	uint32_t children;
	CPOINTER userdata;
	uintptr_t key;
	struct treenode_tag *lesser;
	struct treenode_tag *greater;
	struct treenode_tag **me;
	struct treenode_tag *parent;
};
typedef struct treenode_tag TREENODE;
#define MAXTREENODESPERSET 256
DeclareSet( TREENODE );
typedef struct treeroot_tag {
	struct {
		BIT_FIELD bUsed:1;
		BIT_FIELD bRoot:1;
 // tree points to the real TREEROOT (not a node)
		BIT_FIELD bShadow:1;
		BIT_FIELD bNoDuplicate : 1;
	} flags;
	uint32_t children;
	uint32_t lock;
	GenericDestroy Destroy;
	GenericCompare Compare;
	PTREENODE tree;
	PTREENODE prior, current, lastfound;
} TREEROOT;
static PTREENODESET TreeNodeSet;
CPOINTER GetLesserNodeExx( PTREEROOT root, PTREENODE *from );
CPOINTER GetGreaterNodeExx( PTREEROOT root, PTREENODE *from );
//---------------------------------------------------------------------------
PTREEROOT FindTreeRoot( PTREENODE node )
{
	while( node && (!node->flags.bRoot) && node->parent )
	{
		node = node->parent;
	}
	return (PTREEROOT)node;
}
//---------------------------------------------------------------------------
int CPROC BinaryCompareInt( uintptr_t old, uintptr_t new_key )
{
	if( old > new_key )
		return 1;
	else if( old < new_key )
		return -1;
	return 0;
}
//---------------------------------------------------------------------------
PTREENODE RotateToRight( PTREENODE node )
{
	PTREENODE greater = node->greater;
	*node->me = node->greater;
	// my parent's nodes do NOT change....
	// node->parent->children += node->greater->children - node->children;
	greater->me       = node->me;
	greater->parent   = node->parent;
	node->children   -= (greater->children+1);
	if( ( node->greater = greater->lesser ) )
	{
		greater->lesser->me     = &node->greater;
		greater->lesser->parent = node;
		node->children    += (greater->lesser->children + 1);
		greater->children -= (greater->lesser->children + 1);
	}
	greater->lesser = node;
	node->me        = &greater->lesser;
	node->parent    = greater;
	greater->children += (node->children + 1);
	return greater;
}
//---------------------------------------------------------------------------
PTREENODE RotateToLeft( PTREENODE node )
{
	PTREENODE lesser = node->lesser;
	*node->me = node->lesser;
	// my parent's nodes do NOT change....
	// node->parent->children += node->lesser->children - node->children;
	lesser->me       = node->me;
	lesser->parent   = node->parent;
	node->children  -= (lesser->children+1);
	if( ( node->lesser = lesser->greater ) )
	{
		lesser->greater->me     = &node->lesser;
		lesser->greater->parent = node;
		node->children   += (lesser->greater->children + 1);
		lesser->children -= (lesser->greater->children + 1);
	}
	lesser->greater = node;
	node->me        = &lesser->greater;
	node->parent    = lesser;
	lesser->children += (node->children + 1);
	return lesser;
}
//---------------------------------------------------------------------------
// RotateToLeft - make left node root/current.
// RotateToRight - make right node root/current
static int BalanceBinaryBranch( PTREENODE root )
{
	PTREENODE check;
	int balances = 0;
	//while( balances )
	{
		balances = 0;
	   if( ( check = root ) )
	   {
		    if( check->lesser && check->greater)
		 {
			int left = check->lesser->children
			 , right = check->greater->children;
			if( left && right && ( left > ( right * 2 ) ) )
			{
				//if( left > 2+((left+right)*55)/100 )
				{
					 //Log2( WIDE("rotateing to left (%d/%d)"), left, right );
					root = RotateToLeft( check );
					balances++;
				}
				//else
				//	root = NULL;
			}
			else if( right > ( left * 2 ) )
			{
				//if( right  > 2+((left+right)*55)/100 )
				{
					 //Log2( WIDE("rotateing to right (%d/%d)"), right, left );
					root = RotateToRight( check );
					balances++;
				}
				//else
				//	root = NULL;
			}
		 }
		 else if( check->lesser && ( check->children >= 2 ) )
		 {
			 //Log1( WIDE("rotateing to left (%d)"), check->children );
			 root = RotateToLeft( check );
			balances++;
		 }
		 else if( check->greater && ( check->children >= 2 )  )
		 {
			 //Log1( WIDE("rotateing to right (%d)"), check->children );
			 root = RotateToRight( check );
			balances++;
		 }
		 //else
		 //	root = NULL;
		 if( root )
		 {
			balances += BalanceBinaryBranch( root->lesser );
			balances += BalanceBinaryBranch( root->greater );
		  }
	    }
	 }
	 return balances;
}
//---------------------------------------------------------------------------
void BalanceBinaryTree( PTREEROOT root )
{
	while( LockedExchange( &root->lock, 1 ) )
		Relinquish();
	while( BalanceBinaryBranch( root->tree ) > 1 && 0);
	root->lock = 0;
	//Log( WIDE("=========") );;
}
//---------------------------------------------------------------------------
int HangBinaryNode( PTREEROOT root, PTREENODE node )
{
	PTREENODE check;
	if( !node )
		return 0;
	root->children += ( node->children + 1 );
	if( !(root->tree) )
	{
		root->tree = node;
		node->me = &root->tree;
		node->parent = (PTREENODE)root;
		return 1;
	}
	 check = root->tree;
	 while( check )
	 {
		 int dir = root->Compare( node->key, check->key );
		 check->children += (node->children + 1);
		 if( dir < 0 )
		 {
			 if( check->lesser )
			 {
				 check = check->lesser;
			 }
			else
			{
				check->lesser = node;
				node->me = &check->lesser;
				node->parent = check;
				break;
			}
		 }
		 else if( dir > 0 )
			 if( check->greater )
			 {
				 check = check->greater;
			 }
			else
			{
				check->greater = node;
				node->me = &check->greater;
				node->parent = check;
				break;
			}
		else if( root->flags.bNoDuplicate )
		{
			while( check && !check->flags.bRoot )
			{
				check->children -= (node->children + 1);
				check = check->parent;
			}
			if( check )
				check->children -= (node->children + 1);
			DeleteFromSet( TREENODE, TreeNodeSet, node );
			//Release( node );
		 return 0;
		}
		else
		{
			int leftchildren = 0, rightchildren = 0;
			if( check->lesser )
				leftchildren = check->lesser->children;
			if( check->greater )
				rightchildren = check->greater->children;
			if( leftchildren <= rightchildren )
			{
				if( check->lesser )
					check = check->lesser;
				else
				{
					check->lesser = node;
					node->me = &check->lesser;
					node->parent = check;
					break;
				}
			}
			else
			{
				if( check->greater )
					check = check->greater;
				else
				{
					check->greater = node;
					node->me = &check->greater;
					node->parent = check;
					break;
				}
			}
		}
	}
	return 1;
}
//---------------------------------------------------------------------------
int AddBinaryNodeEx( PTREEROOT root
                   , CPOINTER userdata
                   , uintptr_t key DBG_PASS )
{
	PTREENODE node;
	if( !root )
		return 0;
//AllocateEx( sizeof( TREENODE ) DBG_RELAY );
	node = GetFromSet( TREENODE, &TreeNodeSet );
	node->lesser = NULL;
	node->greater = NULL;
	node->me = NULL;
	node->children = 0;
	node->userdata = userdata;
	node->key = key;
	node->flags.bUsed = 1;
	node->flags.bRoot = 0;
	return HangBinaryNode( root, node );
}
#undef AddBinaryNode
int AddBinaryNode( PTREEROOT root
						, CPOINTER userdata
					  , uintptr_t key )
{
	return AddBinaryNodeEx( root, userdata, key DBG_SRC );
}
//---------------------------------------------------------------------------
static void RehangBranch( PTREEROOT root, PTREENODE node )
{
	if( node )
	{
 // make sure I'm out of the tree...
		(*node->me) = NULL;
		if( node->greater )
		{
			RehangBranch( root, node->greater );
		}
		if( node->lesser )
		{
			RehangBranch( root, node->lesser );
		}
		node->children = 0;
		//lprintf( "putting self node back in tree %p", node );
		HangBinaryNode( root, node );
	}
}
static void DecrementParentCounts( PTREENODE node, int count )
{
	PTREENODE parent;
	for( parent = node; parent && !parent->flags.bRoot; parent = parent->parent )
	{
		parent->children -= count;
	}
}
static void NativeRemoveBinaryNode( PTREEROOT root, PTREENODE node )
{
	if( root )
	{
		// lprintf( "Removing node from tree.. %p under %p", node, node->parent );
		if( node->parent->lesser != node && node->parent->greater != node )
		{
			*(int*)0=0;
		}
		// lprintf( "%p should be removed!", node );
 // pull me out of the tree.
		(*node->me) = NULL;
		DecrementParentCounts( node->parent, node->children+1 );
		// hang my right...
		RehangBranch( root, node->greater );
		// hang my left...
		RehangBranch( root, node->lesser );
		if( root->Destroy )
			root->Destroy( node->userdata, node->key );
		MemSet( node, 0, sizeof( node ) );
		DeleteFromSet( TREENODE, TreeNodeSet, node );
		//Release( node );
		return;
	}
	lprintf( WIDE("Fatal RemoveBinaryNode could not find the root!") );
}
//---------------------------------------------------------------------------
 void  RemoveBinaryNode ( PTREEROOT root, POINTER data, uintptr_t key )
{
	PTREENODE node;
	if( !root )
		return;
	node = root->tree;
	while( node )
	{
		int dir = root->Compare( key, node->key );
		if( dir > 0 )
			node = node->greater;
		else if( dir < 0 )
			node = node->lesser;
		else
		{
			if( node->userdata == data )
			{
				NativeRemoveBinaryNode( root, node );
				break;
			}
			else
			{
				// hmm same key different data...
				break;
			}
		}
	}
	return ;
}
//---------------------------------------------------------------------------
#define MAXTREEROOTSPERSET 128
DeclareSet( TREEROOT );
static PTREEROOTSET treepool;
//---------------------------------------------------------------------------
void ResetBinaryTree( PTREEROOT root )
{
	while( root->tree )
		NativeRemoveBinaryNode( root, root->tree );
}
//---------------------------------------------------------------------------
void DestroyBinaryTree( PTREEROOT root )
{
	while( root->tree )
		NativeRemoveBinaryNode( root, root->tree );
	DeleteFromSet( TREEROOT, treepool, root );
}
//---------------------------------------------------------------------------
PTREEROOT CreateBinaryTreeExtended( uint32_t flags
									  , GenericCompare Compare
									  , GenericDestroy Destroy DBG_PASS )
{
	PTREEROOT root;
//(PTREEROOT)AllocateEx( sizeof( TREEROOT ) DBG_RELAY );
	root = GetFromSet( TREEROOT, &treepool );
	MemSet( root, 0, sizeof( TREEROOT ) );
	root->flags.bRoot = 1;
	root->flags.bUsed = 1;
	if( flags & BT_OPT_NODUPLICATES  )
		root->flags.bNoDuplicate = 1;
	root->Destroy = Destroy;
	//root->return  = NULL; // upgoing... (return from right )
	if( Compare )
		root->Compare = Compare;
	else
		root->Compare = BinaryCompareInt;
	return root;
}
#undef CreateBinaryTreeEx
PTREEROOT CreateBinaryTreeEx( GenericCompare Compare
								    , GenericDestroy Destroy )
{
	return CreateBinaryTreeExx( 0, Compare, Destroy );
}
//---------------------------------------------------------------------------
int maxlevel = 0;
void DumpNode( PTREENODE node, int level, int (*DumpMethod)( CPOINTER user, uintptr_t key ) )
{
	int print;
	if( !node )
		return;
	if( level > maxlevel )
		maxlevel = level;
	DumpNode( node->lesser, level+1, DumpMethod );
	if( DumpMethod )
		print = DumpMethod( node->userdata, node->key );
	else
		print = TRUE;
	//else
	if( print )
		lprintf( WIDE("[%3d] %p Node has %3")_32f WIDE(" children (%p %3")_32f WIDE(",%p %3")_32f WIDE("). %10") _PTRSZVALfs
				 , level, node, node->children
				 , node->lesser
				 , (node->lesser)?(node->lesser->children+1):0
				 , node->greater
				 , (node->greater)?(node->greater->children+1):0
				 , node->key
				 );
	DumpNode( node->greater, level+1, DumpMethod );
}
//---------------------------------------------------------------------------
void DumpTree( PTREEROOT root
				 , int (*Dump)( CPOINTER user, uintptr_t key ) )
{
	maxlevel = 0;
	if( !Dump ) lprintf( WIDE("Tree %p has %")_32f WIDE(" nodes. %p is root"), root, root->children, root->tree );
	DumpNode( root->tree, 1, Dump );
	if( !Dump ) lprintf( WIDE("Tree had %d levels."), maxlevel );
}
//---------------------------------------------------------------------------
CPOINTER FindInBinaryTree( PTREEROOT root, uintptr_t key )
{
	PTREENODE node;
	if( !root )
		return 0;
	node = root->tree;
	while( node )
	{
		int dir = root->Compare( key, node->key );
		if( dir > 0 )
			node = node->greater;
		else if( dir < 0 )
			node = node->lesser;
		else
			break;
	}
	root->lastfound = node;
	if( node )
		return node->userdata;
	return 0;
}
//---------------------------------------------------------------------------
int CPROC TextMatchLocate( uintptr_t key1, uintptr_t key2 )
{
	size_t k1len = StrLen( (CTEXTSTR)key1 );
	size_t k2len = StrLen( (CTEXTSTR)key2 );
	//lprintf( "COmpare %s(%d) vs %s(%d)", key1, k1len, key2, k2len );
	if( k2len < k1len )
	{
		// cannot match this.... but should
		// try to choose a direction
		int dir = StrCaseCmpEx( (CTEXTSTR)key1, (CTEXTSTR)key2, k2len );
		if( dir == 0 )
			return 101;
		if( dir > 0 )
			return 1;
		return -1;
	}
	else if( k2len > k1len )
	{
		int dir = StrCaseCmpEx( (CTEXTSTR)key1, (CTEXTSTR)key2, k1len );
		// is exact match, but only part of key2
		if( dir == 0 )
			return 100;
		// I doubt these will really matter...
		// could compute distance...
		if( dir > 0 )
			return 1;
		else
			return -1;
	}
	else
	{
		int dir = StrCaseCmp( (CTEXTSTR)key1, (CTEXTSTR)key2 );
		if( dir == 0 )
			return 0;
		if( dir > 0 )
			return 1;
		else
			return -1;
	}
}
// the key value passed does not have to be the same as the key in the tree
// it can be an abstrat reference of a strucutre that contains a key for the tree
// result of fuzzy routine is 0 = match.  100 = inexact match
// 1 = no match, actual may be larger
// -1 = no match, actual may be lesser
// 100 = inexact match- checks nodes near for better match.
CPOINTER LocateInBinaryTree( PTREEROOT root, uintptr_t key
								  , int (CPROC*fuzzy)( uintptr_t psv, uintptr_t node_key )
								  )
{
	PTREENODE node;
	node = root->tree;
	if( !fuzzy )
		fuzzy = TextMatchLocate;
	while( node )
	{
		int _dir;
		int dir = fuzzy( key, node->key );
		if( dir == 100 || dir == 101 )
		{
			PTREENODE one_up;
			PTREENODE one_down;
			// this matched, in an inexact length.
			// to be really careful we should match one up and one down.
			// well, we'll match better only if we had exact length
			// so - go up one node, until we find exact length
			//lprintf( " - Found a near match..." );
			one_up = node;
			one_down = node;
			_dir = dir;
			do
			{
				GetLesserNodeExx( root, &one_up );
				if( one_up )
				{
					dir = fuzzy( key, one_up->key );
					if( dir == 100 )
						continue;
					if( dir == 0 )
					{
						root->lastfound = one_up;
						return (one_up->userdata);
					}
					else
						one_up = NULL;
				}
				GetGreaterNodeExx( root, &one_down );
				if( one_down )
				{
					dir = fuzzy( key, one_down->key );
					if( dir == 100 )
						continue;
					if( dir == 0 )
					{
						root->lastfound = one_down;
						return (one_down->userdata);
					}
					else
						one_down = NULL;
				}
			}
			while( one_up || one_down );
			if( _dir == 101 )
			{
				node = NULL;
			}
			root->lastfound = node;
			if( node )
				return( node->userdata );
			return 0;
		}
		if( dir > 0 )
		{
			node = node->greater;
		}
		else if( dir < 0 )
		{
			node = node->lesser;
		}
		else
			break;
	}
	root->lastfound = node;
	if( node )
		return node->userdata;
	return 0;
}
//---------------------------------------------------------------------------
CPOINTER GetCurrentNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root || !(*cursor) )
		return NULL;
	return (*(struct treenode_tag **)cursor)->userdata;
}
CPOINTER GetCurrentNode( PTREEROOT root )
{
	return GetCurrentNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
void RemoveLastFoundNode( PTREEROOT root )
{
	if( !root || !root->lastfound )
		return;
	NativeRemoveBinaryNode( root, root->lastfound );
}
//---------------------------------------------------------------------------
void RemoveCurrentNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root || !(*cursor) )
		return;
	NativeRemoveBinaryNode( root, (PTREENODE)(*cursor) );
	(*cursor) = NULL;
}
void RemoveCurrentNode( PTREEROOT root )
{
	RemoveCurrentNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetGreaterNodeExx( PTREEROOT root, PTREENODE *from )
{
	if( !root || !(*from) ) return 0;
	if( !(*from)->greater && !(*from)->lesser )
	{
		// Up 1
		root->prior = (*from);
		(*from) = (*from)->parent;
		if( (*from)->flags.bRoot )
		{
			// Root - end
			(*from) = NULL;
			return 0;
		}
		while( root->prior == (*from)->greater )
		{
			// up 2
			root->prior = (*from);
			(*from) = (*from)->parent;
			if( (*from)->flags.bRoot )
			{
				// Root
				(*from) = NULL;
				return 0;
			}
		}
		// Do it
		return (*from)->userdata;
	}
	if( (*from)->greater )
	{
		// right
		(*from) = (*from)->greater;
		while( (*from)->lesser )
		{
			// Left
			(*from) = (*from)->lesser;
		}
		// Do it 1
		return (*from)->userdata;
	}
	do
	{
		// Up 3
		root->prior = (*from);
		(*from) = (*from)->parent;
		if( (*from)->flags.bRoot )
		{
			// Root
			(*from) = NULL;
			return 0;
		}
	} while( (*from)->greater == root->prior );
	// Do it 2
	return (*from)->userdata;
}
CPOINTER GetGreaterNodeEx( PTREEROOT root, POINTER *cursor )
{
	return GetGreaterNodeExx( root, (PTREENODE*)cursor );
}
CPOINTER GetGreaterNode( PTREEROOT root )
{
	return GetGreaterNodeExx( root, &root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetLesserNodeExx( PTREEROOT root, PTREENODE *from )
{
	if( !root || !(*from) ) return 0;
	if( !(*from)->lesser && !(*from)->greater )
	{
		// Up 1
		root->prior = (*from);
		(*from) = (*from)->parent;
		if( (*from)->flags.bRoot )
		{
			// Root - end
			(*from) = NULL;
			return 0;
		}
		while( root->prior == (*from)->lesser )
		{
			// up 2
			root->prior = (*from);
			(*from) = (*from)->parent;
			if( (*from)->flags.bRoot )
			{
				// Root
				(*from) = NULL;
				return 0;
			}
		}
		// Do it
		return (*from)->userdata;
	}
	if( (*from)->lesser )
	{
		// right
		(*from) = (*from)->lesser;
		while( (*from)->greater )
		{
			// Left
			(*from) = (*from)->greater;
		}
		// Do it 1
		return (*from)->userdata;
	}
	do
	{
		// Up 3
		root->prior = (*from);
		(*from) = (*from)->parent;
		if( (*from)->flags.bRoot )
		{
			// Root
			(*from) = NULL;
			return 0;
		}
	} while( (*from)->lesser == root->prior );
	// Do it 2
	return (*from)->userdata;
}
CPOINTER GetLesserNodeEx( PTREEROOT root, POINTER *cursor )
{
	return GetLesserNodeExx( root, (PTREENODE*)cursor );
}
CPOINTER GetLesserNode( PTREEROOT root )
{
	return GetLesserNodeExx( root, &root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetLeastNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root ) return 0;
	(*(struct treenode_tag **)cursor) = root->tree;
	root->prior = NULL;
	while( (*(struct treenode_tag **)cursor) && (*(struct treenode_tag **)cursor)->lesser )
		(*(struct treenode_tag **)cursor) = (*(struct treenode_tag **)cursor)->lesser;
	if( (*(struct treenode_tag **)cursor) )
		return (*(struct treenode_tag **)cursor)->userdata;
	return 0;
}
CPOINTER GetLeastNode( PTREEROOT root )
{
	return GetLeastNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetGreatestNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root ) return 0;
	root->prior = NULL;
	(*(struct treenode_tag **)cursor) = root->tree;
	while( (*(struct treenode_tag **)cursor) && (*(struct treenode_tag **)cursor)->greater )
		(*(struct treenode_tag **)cursor) = (*(struct treenode_tag **)cursor)->greater;
	if( (*(struct treenode_tag **)cursor) )
		return (*(struct treenode_tag **)cursor)->userdata;
	return 0;
}
CPOINTER GetGreatestNode( PTREEROOT root )
{
	return GetGreatestNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetRootNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root ) return 0;
	root->prior = NULL;
	(*(struct treenode_tag **)cursor) = root->tree;
	if( (*(struct treenode_tag **)cursor) )
		return (*(struct treenode_tag **)cursor)->userdata;
	return 0;
}
CPOINTER GetRootNode( PTREEROOT root )
{
	return GetRootNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetParentNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root ) return 0;
	if( (*(struct treenode_tag **)cursor) )
	{
		root->prior = (*(struct treenode_tag **)cursor);
		if( !(*(struct treenode_tag **)cursor)->parent->flags.bRoot )
			(*(struct treenode_tag **)cursor) = (*(struct treenode_tag **)cursor)->parent;
		if( (*(struct treenode_tag **)cursor) )
			return (*(struct treenode_tag **)cursor)->userdata;
	}
	return 0;
}
CPOINTER GetParentNode( PTREEROOT root )
{
	return GetParentNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetChildNodeEx( PTREEROOT root, POINTER *cursor, int direction )
{
	if( !root ) return 0;
	if( (*(struct treenode_tag **)cursor) )
	{
		root->prior = (*(struct treenode_tag **)cursor);
		if( direction < 0 )
		{
			(*(struct treenode_tag **)cursor) = (*(struct treenode_tag **)cursor)->lesser;
		}
		else
			(*(struct treenode_tag **)cursor) = (*(struct treenode_tag **)cursor)->greater;
		if( (*(struct treenode_tag **)cursor) )
			return (*(struct treenode_tag **)cursor)->userdata;
	}
	return 0;
}
CPOINTER GetChildNode( PTREEROOT root, int direction )
{
	return GetChildNodeEx( root, (POINTER*)&root->current, direction );
}
//---------------------------------------------------------------------------
CPOINTER GetPriorNodeEx( PTREEROOT root, POINTER *cursor )
{
	PTREENODE cur;
	if( !root ) return 0;
	cur = (*(struct treenode_tag **)cursor);
	(*(struct treenode_tag **)cursor) = root->prior;
	root->prior = cur;
	if( (*(struct treenode_tag **)cursor) )
		return (*(struct treenode_tag **)cursor)->userdata;
	return 0;
}
CPOINTER GetPriorNode( PTREEROOT root )
{
	return GetPriorNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
uint32_t GetNodeCount( PTREEROOT root )
{
	return root->children;
}
//---------------------------------------------------------------------------
PTREEROOT ShadowBinaryTree( PTREEROOT Original )
{
	PTREEROOT root;
	Log( WIDE("Use of binary tree shadows is fraught with danger!") );
	root = (PTREEROOT)Allocate( sizeof( TREEROOT ) );
	MemSet( root, 0, sizeof( TREEROOT ) );
	root->flags.bRoot = 1;
	root->flags.bUsed = 1;
	root->flags.bShadow = 1;
	root->children = 0;
	root->Compare = Original->Compare;
	root->Destroy = Original->Destroy;
	root->tree = Original->tree;
	return root;
}
#ifdef __cplusplus
 // namespace BinaryTree {
};
 //namespace containers {
};
 //namespace sack {
};
#endif
//---------------------------------------------------------------------------
// $Log: binarylist.c,v $
// Revision 1.19  2005/01/27 07:18:34  panther
// Linux cleaned.
//
// Revision 1.18  2004/05/04 17:23:44  d3x0r
// Fix getlessernode
//
// Revision 1.17  2004/04/26 09:47:26  d3x0r
// Cleanup some C++ problems, and standard C issues even...
//
// Revision 1.16  2004/01/31 01:30:20  d3x0r
// Mods to extend/test procreglib.
//
// Revision 1.15  2004/01/29 10:13:44  d3x0r
// Remove ifdeffed logging, fix dumpnode to dump to log if no write method
//
// Revision 1.14  2003/10/24 14:50:11  panther
// Fix remove binary node, keep last found for quick delete
//
// Revision 1.13  2003/03/06 09:06:07  panther
// Oops - forgot to decrement the root count itself
//
// Revision 1.12  2003/03/06 08:56:06  panther
// fix code to unwind non-hung nodes
//
// Revision 1.11  2003/03/06 08:39:16  panther
// Stripped \r's.  Added GetNodeCount()
//
// Revision 1.10  2003/03/04 16:28:36  panther
// Cleanup warnings in typecode.  Convert uintptr_t to POINTER literal in binarylist
//
// Revision 1.9  2003/03/02 18:50:21  panther
// Added NO_DUPLICATES opption to  binary trees
//
// Revision 1.8  2003/02/20 02:35:17  panther
// Added debug message option flag
//
// Revision 1.7  2003/01/13 00:40:13  panther
// removed old msvc projects.
// Added new visual studio projects.
// Mods to compile cleanly under msvc.
//
// Revision 1.6  2002/08/12 22:16:02  panther
// Fixed buf in GetGreaterNode - last test tested prior->greater vs current
// which will never be true.
//
//
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   A binary tree is often fine for sorting, but for relational things
 *   a Family tree that tracks parent, child, and peers is often required.
 *   The list of peers is a circular linked list based on LinkThing macros
 *   The List is actually broken foward cicularly, but not in a reverse direction
 *
 * see also - include/typelib.h
 *
 */
#define FAMILY_TREE_SOURCE_CODE
#ifdef __cplusplus
namespace sack {
namespace containers {
namespace family {
//	using namespace sack::memory;
#endif
// consider slab allocation... 32 bytes even.
struct familynode_tag {
	struct {
		BIT_FIELD bUsed:1;
	} flags;
	POINTER userdata;
	uintptr_t key;
	struct familynode_tag *elder, *younger, *parent, *child;
};
typedef struct familynode_tag FAMILYNODE;
#define MAXFAMILYNODESPERSET 256
DeclareSet( FAMILYNODE );
struct familyroot_tag {
	struct {
		BIT_FIELD bUsed:1;
		BIT_FIELD bRoot:1;
 // family points to the real FAMILYTREE (not a node)
		BIT_FIELD bShadow:1;
		BIT_FIELD bNoDuplicate : 1;
	} flags;
	void (CPROC *Destroy)( POINTER user, uintptr_t key );
	int (CPROC *Compare)(uintptr_t old,uintptr_t newx);
	PFAMILYNODESET nodes;
	PFAMILYNODE family;
	PFAMILYNODE prior
		// current is where things are added
		// newly added nodes become current?
		// prior is the last state, so after adding
      // a child node, the parent may be returned to.
//, prior
										, current
	// hmm lastfound... enumeration from this value?
	// what sort of enumeration of family trees exist?
										, lastfound;
};
typedef struct familyroot_tag FAMILYTREE;
//----------------------------------------------------------------------------
 PFAMILYTREE  CreateFamilyTree ( int (CPROC*Compare)(uintptr_t old,uintptr_t new_key),
															 void (CPROC*Destroy)( POINTER user, uintptr_t key ) )
{
	PFAMILYTREE root = (PFAMILYTREE)Allocate( sizeof( FAMILYTREE ) );
	MemSet( root, 0, sizeof( FAMILYTREE ) );
	root->Compare = Compare;
	root->Destroy = Destroy;
	return root;
}
//----------------------------------------------------------------------------
enum {
	RELATE_CHILD_OF
      , RELATE
};
//----------------------------------------------------------------------------
 POINTER  FamilyTreeFindChildEx ( PFAMILYTREE root, PFAMILYNODE root_node
													 , uintptr_t psvKey )
{
	PFAMILYNODE node = root_node;
	root->prior = root_node;
	if( node )
		node = node->child;
	else
		node = root->family;
	while( node )
	{
		int d;
		if( root->Compare )
			d = root->Compare( node->key, psvKey );
		else
			d = node->key > psvKey?1:node->key<psvKey?-1:0;
		if( !d )
			break;
		node = node->elder;
	}
	root->current = node;
	if( !node )
		return NULL;
	root->lastfound = node;
	return node->userdata;
}
POINTER  FamilyTreeFindChild ( PFAMILYTREE root, uintptr_t psvKey )
{
	return FamilyTreeFindChildEx( root, root->lastfound, psvKey );
}
//----------------------------------------------------------------------------
// scans the whole tree to find a node
LOGICAL FamilyTreeForEachChild( PFAMILYTREE root, PFAMILYNODE node
			, LOGICAL (CPROC *ProcessNode)( uintptr_t psvForeach, uintptr_t psvNodeData )
			, uintptr_t psvUserData )
{
	if( !node )
		node = root->family;
	else
		node = node->child;
	while( node )
	{
		LOGICAL process_result;
		process_result = ProcessNode( psvUserData, (uintptr_t)node->userdata );
		if( !process_result )
			return process_result;
		node = node->elder;
	}
	return TRUE;
}
// scans the whole tree to find a node
LOGICAL FamilyTreeForEach( PFAMILYTREE root, PFAMILYNODE node
			, LOGICAL (CPROC *ProcessNode)( uintptr_t psvForeach, uintptr_t psvNodeData, int level )
			, uintptr_t psvUserData )
{
	static int level;
	if( !node )
		node = root->family;
	else
		node = node->child;
	level++;
	while( node )
	{
		LOGICAL process_result;
		//lprintf( "node %p", node );
		process_result = ProcessNode( psvUserData, (uintptr_t)node->userdata, level );
		if( !process_result )
			return process_result;
		if( node->child )
			FamilyTreeForEach( root, node, ProcessNode, psvUserData );
		node = node->elder;
	}
	level--;
	return TRUE;
}
static  uintptr_t CPROC DestroyNode(void* p,uintptr_t psvUser )
{
	PFAMILYTREE option_tree = (PFAMILYTREE)psvUser;
	if( option_tree->Destroy )
		option_tree->Destroy( ((PFAMILYNODE)p)->userdata, ((PFAMILYNODE)p)->key );
	DeleteFromSet( FAMILYNODE, option_tree->nodes, p );
	return 0;
}
void  FamilyTreeClear ( PFAMILYTREE option_tree )
{
	ForAllInSet( FAMILYNODE, option_tree->nodes, DestroyNode, (uintptr_t)option_tree );
	DeleteSetEx( FAMILYNODE, &option_tree->nodes );
	option_tree->family = NULL;
//	option_tree->nodes
}
//----------------------------------------------------------------------------
// resets the search conditions, and possibley makes aa tree if it isn't already.
void  FamilyTreeReset ( PFAMILYTREE *option_tree )
{
	if( !option_tree )
		return;
	if( !(*option_tree ) )
		(*option_tree) = CreateFamilyTree( NULL, NULL );
	(*option_tree)->lastfound = NULL;
	(*option_tree)->current = NULL;
}
//----------------------------------------------------------------------------
PFAMILYNODE  FamilyTreeAddChild ( PFAMILYTREE *root, PFAMILYNODE parent, POINTER userdata, uintptr_t key )
{
	if( root )
	{
		PFAMILYNODE node;
		if( !(*root ) )
			(*root) = CreateFamilyTree( NULL, NULL );
 /*Allocate( sizeof( FAMILYNODE )*/
		node = (PFAMILYNODE)GetFromSet( FAMILYNODE, &(*root)->nodes );
		node->child = NULL;
		node->younger = NULL;
		node->flags.bUsed = 0;
		node->userdata = userdata;
		node->key = key;
//(*root)->prior;
		node->parent = parent;
		if( !node->parent )
		{
			if( ( node->elder = (*root)->family ) )
				(*root)->family->younger = node;
			(*root)->family = node;
		}
		else
		{
			if( ( node->elder = (*root)->prior->child ) )
				node->elder->younger = node;
			(*root)->prior->child = node;
		}
		(*root)->prior = node;
		(*root)->lastfound = node;
		(*root)->current = node;
		return node;
	}
	return NULL;
}
#ifdef __cplusplus
 //namespace family {
};
 //namespace containers {
};
 //namespace sack {
};
#endif
/*
 *
 *   Crafted by Jim Buckeyne
 *    Purpose: Provide slab allocated set objects
 *      things like points, lines, etc, are cheaper to store
 *      in sets of 128, 256, instead of one at a time, since the
 *      allocation tracking block is larger than the object itself.
 *      Secondarily, this can result in compact, indexable, arrays
 *      for saving data - these resemble a PDATALIST
 *
 *  (c)1999-2006++ Freedom Collective
 */
//#undef GetFromSet
//#undef GetArrayFromSet
//#undef DeleteFromSet
//#undef DeleteArrayFromSet
//#undef CountUsedInSet
//#undef GetLinearSetArray
//#undef ForAllInSet
//----------------------------------------------------------------------------
 // put into a global structure, and configure.
static int bLog;
#ifdef __cplusplus
namespace sack {
	namespace containers {
	namespace sets {
		using namespace sack::memory;
		using namespace sack::logging;
#endif
#ifndef __NO_OPTIONS__
PRELOAD( InitSetLogging )
{
	bLog = SACK_GetProfileIntEx( WIDE( "SACK" ), WIDE( "type library/sets/Enable Logging" ), 0, TRUE );
}
#endif
void DeleteSet( GENERICSET **ppSet )
{
	GENERICSET *pSet;
	 if( !ppSet )
		 return;
	 pSet = *ppSet;
	if( bLog ) lprintf( WIDE( "Deleted set %p" ), pSet );
	while( pSet )
	{
		GENERICSET *next;
		next = pSet->next;
		Release( pSet );
		pSet = next;
	}
	*ppSet = NULL;
}
//----------------------------------------------------------------------------
PGENERICSET GetFromSetPoolEx( GENERICSET **pSetSet, int setsetsizea, int setunitsize, int setmaxcnt
							 , GENERICSET **pSet, int setsizea, int unitsize, int maxcnt DBG_PASS ){
	PGENERICSET set;
	uint32_t maxbias = 0;
	void *unit = NULL;
	uintptr_t ofs = ( ( ( maxcnt + 31 ) / 32 ) * 4 );
	if( !pSet )
 // can never return something from nothing.
		return NULL;
	if( !(*pSet) )
	{
		if( pSetSet )
		{
			set = GetFromSetPoolEx( NULL, 0, 0, 0, pSetSet, setsetsizea, setunitsize, setmaxcnt DBG_RELAY );
			set->nBias = 0;
		}
		else
		{
			set = (PGENERICSET)AllocateEx( setsizea DBG_RELAY );
			set->nBias = 0;
			//Log4( WIDE("Allocating a Set for %d elements sized %d total %d %08x"), maxcnt, unitsize, setsize, set );
			MemSet( set, 0, setsizea );
		}
		*pSet = set;
	}
	{
		int n;
		set = *pSet;
ExtendSet:
		while( (size_t)set->nUsed == (size_t)maxcnt )
		{
			if( !set->next )
			{
				PGENERICSET newset;
				if( pSetSet )
				{
					newset = GetFromSetPoolEx( NULL, 0, 0, 0, pSetSet, setsetsizea, setunitsize, setmaxcnt DBG_RELAY );
					if( set->nBias > maxbias )
						maxbias = set->nBias;
					newset->nBias = maxbias + maxcnt;
				}
				else
				{
					newset = (PGENERICSET)AllocateEx( setsizea DBG_RELAY );
					//Log4( WIDE("Allocating a Set for %d elements sized %d total %d %08x"), maxcnt, unitsize, setsize, set );
					MemSet( newset, 0, setsizea );
					if( set->nBias > maxbias )
						maxbias = set->nBias;
					newset->nBias = maxbias + maxcnt;
				}
#if 1
				if( ( newset->next = (*pSet) ) )
				{
					newset->next->me = &newset->next;
				}
				// insert newset at nead of list - then next time through
				// free ones are the first checked...
				(*(newset->me = pSet)) = newset;
#else
				set->next = newset;
				newset->me = &set->next;
#endif
				set = newset;
				// new, empty set, it's going to fail nUsed == maxcnt
				break;
			}
			else
			{
				if( set->nBias > maxbias )
					maxbias = set->nBias;
			}
			set = set->next;
		}
		while( !unit && set )
		{
			uintptr_t base = ( (uintptr_t)set->bUsed ) + ofs;
			// quick skip for 32 bit blocks of used members...
			n = 0;
			for( n = 0; n < maxcnt && ((maxcnt-n) >= 32) && AllUsed( set,n ); n+=32 );
			if( n == maxcnt )
			{
				// occastionally the 'nUsed' counter may not be in sync with actual usage.
				// this set, after inspecing the bitmasks is actually full.   Update
				// the usage counter and go back up to where the set gets extended.
				set->nUsed = n;
				goto ExtendSet;
			}
			for( n = n; n < maxcnt; n++ )
			{
				if( !IsUsed( set, n ) )
				{
 // go to the appropriate offset
					unit = (void*)( base + n * unitsize );
					SetUsed( set, n );
					return (PGENERICSET)unit;
				}
			}
			if( n == maxcnt )
			{
				if( !set->next ) {
					// synchronize this; obviusly every member IS used.
					set->nUsed = n;
 // for some reason didn't find anything; maybe it's a small set of less than 32 elements?
					goto ExtendSet;
				}
				set = set->next;
			}
		}
#ifdef Z_DEBUG
		if( bLog ) _lprintf( DBG_RELAY )( WIDE( "Unit result: %p from %p %d %d %d %d" ), unit, set, unitsize, maxcnt, n, ( ( (maxcnt +31) / 32 ) * 4 )  );
#endif
	}
	return (PGENERICSET)unit;
}
//----------------------------------------------------------------------------
void *GetFromSetEx( GENERICSET **pSet, int setsizea, int unitsize, int maxcnt DBG_PASS )
{
	return GetFromSetPoolEx( NULL, 0, 0, 0
								  , pSet, setsizea, unitsize, maxcnt DBG_RELAY );
}
static POINTER GetSetMemberExx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt, int *bUsed DBG_PASS )
{
	PGENERICSET set;
	uint32_t maxbias = 0;
	if( nMember == INVALID_INDEX )
		return NULL;
	if( !pSet )
 // can never return something from nothing.
		return NULL;
	if( !(*pSet) )
	{
		set = (PGENERICSET)AllocateEx( setsize DBG_RELAY );
		//Log4( WIDE("Allocating a Set for %d elements sized %d total %d %08x"), maxcnt, unitsize, setsize, set );
		MemSet( set, 0, setsize );
		set->nBias = 0;
		*pSet = set;
	}
	else
		set = (*pSet );
	while( 1 )
	{
		if( nMember >= set->nBias &&
			nMember < ( set->nBias + maxcnt ) )
		{
			nMember -= set->nBias;
			break;
		}
		if( !set->next )
		{
			PGENERICSET newset = (PGENERICSET)AllocateEx( setsize DBG_RELAY );
			//Log4( WIDE("Allocating a Set for %d elements sized %d total %d %08x"), maxcnt, unitsize, setsize, set );
			MemSet( newset, 0, setsize );
			if( set->nBias > maxbias )
				maxbias = set->nBias;
			newset->nBias = maxbias + maxcnt;
			set->next = newset;
			newset->me = &set->next;
		}
		else
		{
			if( set->nBias > maxbias )
				maxbias = set->nBias;
		}
		//nMember -= maxcnt;
		set = set->next;
	}
	if( !IsUsed( set, nMember ) )
		(*bUsed) = 0;
	else
		(*bUsed) = 1;
	if( bLog ) _lprintf(DBG_RELAY)( WIDE( "Resulting unit %" ) _PTRSZVALfs,  ((uintptr_t)(set->bUsed))
 // skip over the bUsed bitbuffer
						+ ( ( (maxcnt +31) / 32 ) * 4 )
						+ nMember * unitsize );
	return (void*)( ((uintptr_t)(set->bUsed))
 // skip over the bUsed bitbuffer
						+ ( ( (maxcnt +31) / 32 ) * 4 )
 // go to the appropriate offset
						+ nMember * unitsize );
}
//----------------------------------------------------------------------------
POINTER GetUsedSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS )
{
	POINTER result;
	int bUsed;
	result = GetSetMemberExx( pSet, nMember, setsize, unitsize, maxcnt, &bUsed DBG_RELAY );
	if( !bUsed )
		return NULL;
	return result;
}
//----------------------------------------------------------------------------
POINTER GetSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS )
{
	POINTER result;
	int bUsed;
	if( nMember == INVALID_INDEX )
		return NULL;
	//if( nMember > 1000 )
	//	DebugBreak();
	result = GetSetMemberExx( pSet, nMember, setsize, unitsize, maxcnt, &bUsed DBG_RELAY );
	if( !bUsed )
		SetUsed( *pSet, nMember );
	return result;
}
//----------------------------------------------------------------------------
#undef GetMemberIndex
INDEX GetMemberIndex(GENERICSET **ppSet, POINTER unit, int unitsize, int max )
{
	GENERICSET *pSet = ppSet?*ppSet:NULL;
	uintptr_t nUnit = (uintptr_t)unit;
	int ofs = ( ( max + 31 ) / 32) * 4;
	int base = 0;
	while( pSet )
	{
		if( nUnit >= ((uintptr_t)(pSet->bUsed) + ofs ) &&
			 nUnit <= ((uintptr_t)(pSet->bUsed) + ofs + unitsize*max ) )
		{
			uintptr_t n = nUnit - ( ((uintptr_t)(pSet->bUsed)) + ofs );
			if( n % unitsize )
			{
				lprintf( WIDE("Error in set member alignment! %") _PTRSZVALfs WIDE(" of %d"), n % unitsize, unitsize );
				DebugBreak();
				return INVALID_INDEX;
			}
			n /= unitsize;
			return (INDEX)(n + pSet->nBias);
		}
		base += max;
		pSet = pSet->next;
	}
	return INVALID_INDEX;
}
//----------------------------------------------------------------------------
#undef MemberValidInSet
int MemberValidInSet( GENERICSET *pSet, void *unit, int unitsize, int max )
{
	uintptr_t nUnit = (uintptr_t)unit;
	int ofs = ( ( max + 31 ) / 32) * 4;
	while( pSet )
	{
		if( nUnit >= ((uintptr_t)(pSet->bUsed) + ofs ) &&
			 nUnit <= ((uintptr_t)(pSet->bUsed) + ofs + unitsize*max ) )
		{
			uintptr_t n = nUnit - ( ((uintptr_t)(pSet->bUsed)) + ofs );
			if( n % unitsize )
			{
				lprintf( WIDE("Error in set member alignment! %") _PTRSZVALfs WIDE(" of %d"), n % unitsize, unitsize );
				DebugBreak();
				return FALSE;
			}
			n /= unitsize;
			return IsUsed( pSet, n );
		}
		pSet = pSet->next;
	}
	return FALSE;
}
//----------------------------------------------------------------------------
void DeleteFromSetExx( GENERICSET *pSet, void *unit, int unitsize, int max DBG_PASS )
{
	uintptr_t nUnit = (uintptr_t)unit;
	uintptr_t ofs = ( ( max + 31 ) / 32) * 4;
	uintptr_t base;
	//if( bLog ) _lprintf(DBG_RELAY)( WIDE("Deleting from  %p of %p "), pSet, unit );
	while( pSet )
	{
		base = ( (uintptr_t)( pSet->bUsed ) + ofs );
		if( (nUnit >= base) &&
		    (nUnit < ( base + unitsize*max )) )
		{
			uintptr_t n = nUnit - base;
#ifdef Z_DEBUG
			if( n % unitsize )
			{
				lprintf( WIDE("Error in set member alignment! %p %p %p  %d %")_PTRSZVALfs WIDE(" %")_PTRSZVALfs WIDE(" of %d")
						 , unit
						 , pSet
						 , &pSet->bUsed
						, ofs
						 , n, n % unitsize, unitsize );
				DebugBreak();
				return;
			}
#endif
			n /= unitsize;
			ClearUsed( pSet, n );
			break;
		}
		pSet = pSet->next;
	}
#ifdef Z_DEBUG
	if( !pSet )
		Log( WIDE("Failed to find node in set!") );
#endif
}
//----------------------------------------------------------------------------
void DeleteSetMemberEx( GENERICSET *pSet, INDEX iMember, uintptr_t unitsize, INDEX max )
{
	//Log2( WIDE("Deleting from  %08x of %08x "), pSet, iMember );
	while( pSet )
	{
		if( iMember >= max )
		{
			iMember -= max;
			pSet = pSet->next;
			continue;
		}
		break;
	}
	if( pSet )
	{
		if( !IsUsed( pSet, iMember ) )
		{
			DebugBreak();
			lprintf( WIDE("Deleting set member which is already released? not decrementing used counter") );
		}
		else
		{
			ClearUsed( pSet, iMember );
			//pSet->nUsed--; // one not used - quick reference counter
		}
	}
	else
		Log( WIDE("Failed to find node in set!") );
}
#undef DeleteSetMember
void DeleteSetMember( GENERICSET *pSet, INDEX iMember, int unitsize, int max )
{
	DeleteSetMemberEx( pSet, iMember, unitsize, max );
}
//----------------------------------------------------------------------------
int CountUsedInSetEx( GENERICSET *pSet, int max )
{
	int cnt = 0, n;
	while( pSet )
	{
		for( n = 0; n < max; n++ )
			if( IsUsed( pSet, n ) )
				cnt++;
		pSet = pSet->next;
	}
	return cnt;
}
//----------------------------------------------------------------------------
void **GetLinearSetArrayEx( GENERICSET *pSet, int *pCount, int unitsize, int max )
{
	void  **array;
	int items, cnt, n, ofs;
	INDEX nMin, nNewMin;
	GENERICSET *pCur, *pNewMin;
	//Log2( WIDE("Building Array unit size: %d(%08x)"), unitsize, unitsize );
	items = CountUsedInSetEx( pSet, max );
	if( pCount )
		*pCount = items;
	ofs = ( ( max + 31) / 32 ) * 4;
	array = (void**)Allocate( sizeof( void* ) * items );
 // 0
	nMin = 0;
	do
	{
		pCur = pSet;
 // 0xFFFFFFFF (max)
		nNewMin = INVALID_INDEX;
		while( pCur )
		{
			// maybe instead of ordering elements
			// by ID - order by physical memory?
			// that allows findinarray to work better...
			if( (uintptr_t)pCur->nBias < nNewMin &&
				 (uintptr_t)pCur->nBias >= nMin )
			{
				pNewMin = pCur;
				nNewMin = pCur->nBias;
			}
			pCur = pCur->next;
		}
		if( (uintptr_t)nNewMin != INVALID_INDEX )
		{
			cnt = 0;
			for( n = 0; n < max; n++ )
				if( IsUsed( pNewMin, n ) )
				{
					array[cnt] = (void*)( ((uintptr_t)(pNewMin->bUsed))
												  + ofs
												  + n * unitsize );
					cnt++;
				}
		}
		nMin = nNewMin+1;
	}while( nNewMin != INVALID_INDEX );
	return array;
}
//----------------------------------------------------------------------------
int FindInArray( void **pArray, int nArraySize, void *unit )
{
	//int32_t idx;
	if( pArray )
	{
		int i, j, m;
		uintptr_t psvUnit, psvArray;
		i = 0;
		j = nArraySize-1;
		psvUnit = (uintptr_t)unit;
		do
		{
			m = (i+j)/2;
			psvArray = (uintptr_t)pArray[m];
			if( psvUnit < psvArray )
				j = m - 1;
			else if( psvUnit > psvArray )
				i = m + 1;
			else
				break;
		}
		while( i <= j );
		if( i > j )
			return -1;
		return m;
	}
	return -1;
}
//----------------------------------------------------------------------------
uintptr_t _ForAllInSet( GENERICSET *pSet, int unitsize, int max, FAISCallback f, uintptr_t psv )
{
	//Log2( WIDE("Doing all in set - size: %d setsize: %d"), unitsize, max );
	if( f )
	{
		int ofs, n;
		ofs = ( ( max + 31) / 32 ) * 4;
		while( pSet )
		{
			for( n = 0; n < max; n++ )
				if( IsUsed( pSet, n ) )
				{
					uintptr_t psvReturn;
					psvReturn = f( (void*)( ((uintptr_t)(pSet->bUsed))
											  + ofs
											  + n * unitsize ), psv );
					if( psvReturn )
					{
						//Log( WIDE("Return short? "));
						return psvReturn;
					}
				}
			pSet = pSet->next;
		}
	}
	return 0;
}
//----------------------------------------------------------------------------
#undef ForEachSetMember
uintptr_t ForEachSetMember( GENERICSET *pSet, int unitsize, int max, FESMCallback f, uintptr_t psv )
{
	//Log2( WIDE("Doing all in set - size: %d setsize: %d"), unitsize, max );
	if( f )
	{
		int total = 0;
		int n;
		while( pSet )
		{
			int nFound = 0;
			for( n = 0; nFound < (int)pSet->nUsed && n < max; n++ )
				if( IsUsed( pSet, n ) )
				{
					uintptr_t psvReturn;
					nFound++;
					psvReturn = f( total+n, psv );
					if( psvReturn )
					{
						//Log( WIDE("Return short? "));
						return psvReturn;
					}
				}
			total += n;
			pSet = pSet->next;
		}
	}
	return 0;
}
#ifdef __cplusplus
//	namespace sets {
	};
 //	namespace containers {
	};
 //namespace sack {
};
#endif
// $Log: sets.c,v $
// Revision 1.15  2005/05/20 21:47:10  jim
// Add base to get member index... so we don't get index of member in a set, but the actual index of the member in order... also fix a spot of set slab linking.  Also, fix resulting of the member for an index...
//
// Revision 1.14  2005/05/18 21:19:32  jim
// Define a method which will only get a valid set member from a set.
//
// Revision 1.13  2005/03/07 12:53:15  panther
// Only check what's used in a set instead of all memebers.
//
// Revision 1.12  2005/02/09 22:40:22  panther
// allow timers library to steal sets code....
//
// Revision 1.11  2005/02/04 19:25:30  panther
// Added iterator for sets that's a little different
//
// Revision 1.10  2005/01/10 21:43:42  panther
// Unix-centralize makefiles, also modify set container handling of getmember index
//
// Revision 1.9  2004/12/19 15:44:40  panther
// Extended set methods to interact with raw index numbers
//
// Revision 1.8  2004/10/04 03:56:26  d3x0r
// protect against null array passed to find_in_array
//
// Revision 1.7  2004/02/18 20:47:04  d3x0r
// Undef MemberInSet
//
// Revision 1.6  2004/02/14 01:19:04  d3x0r
// Extensions of Set structure in containers, C++ interface extension
//
// Revision 1.5  2003/04/11 16:03:53  panther
// Added  LogN for gcc.  Fixed set code to search for first available instead of add at end always.  Added MKCFLAGS MKLDFLAGS for lnx makes.
// Fixed target of APP_DEFAULT_DATA.
// Updated display to use a meta buffer between for soft cursors.
//
// Revision 1.4  2003/03/25 09:37:58  panther
// Fix file tails mangled by CVS logging
//
// Revision 1.3  2003/03/25 08:45:58  panther
// Added CVS logging tag
//
/* Generalized HTTP Processing. All POST, GET, RESPONSE packets
   all fit within this structure.
                                                                */
#ifndef HTTP_PROCESSING_INCLUDED
/* Multiple inclusion protection symbol */
#define HTTP_PROCESSING_INCLUDED
#ifdef HTTP_SOURCE
#define HTTP_EXPORT EXPORT_METHOD
#else
/* Defines how external functions are referenced
   (dllimport/export/extern)                     */
#define HTTP_EXPORT IMPORT_METHOD
#endif
/* The API type of HTTP functions - default to CPROC. */
#define HTTPAPI CPROC
#ifdef __cplusplus
/* A symbol to define the sub-namespace of HTTP_NAMESPACE  */
#define _HTTP_NAMESPACE namespace http {
/* A macro to end just the HTTP sub namespace. */
#define _HTTP_NAMESPACE_END }
#else
#define _HTTP_NAMESPACE
#define _HTTP_NAMESPACE_END
#endif
/* HTTP full namespace  */
#define HTTP_NAMESPACE TEXT_NAMESPACE _HTTP_NAMESPACE
/* Macro to use to define where http utility namespace ends. */
#define HTTP_NAMESPACE_END _HTTP_NAMESPACE_END TEXT_NAMESPACE_END
SACK_CONTAINER_NAMESPACE
/* Text library functions. PTEXT is kept as a linked list of
   segments of text. Each text segment has a size and the data,
   and additional format flags. PTEXT may also be indirect
   segments (that is this segment points at another list of
   segments that are the actualy content for this place.
                                                                */
_TEXT_NAMESPACE
	/* Simple HTTP Packet processing state. Its only intelligence is
	   that there are fields of http header, and that one of those
	   fields might be content-length; so it can seperate individual
	   fields name-value pairs and the packet content.               */
	_HTTP_NAMESPACE
struct HttpField {
	PTEXT name;
	PTEXT value;
};
typedef struct HttpState *HTTPState;
enum ProcessHttpResult{
	HTTP_STATE_RESULT_NOTHING = 0,
	HTTP_STATE_RESULT_CONTENT = 200,
    HTTP_STATE_RESULT_CONTINUE = 100,
	HTTP_STATE_INTERNAL_SERVER_ERROR=500,
	HTTP_STATE_RESOURCE_NOT_FOUND=404,
   HTTP_STATE_BAD_REQUEST=400,
};
HTTP_EXPORT
 /* Creates an empty http state, the next operation should be
   AddHttpData.                                              */
HTTPState  HTTPAPI CreateHttpState( void );
HTTP_EXPORT
 /* Destroys a http state, releasing all resources associated
   with it.                                                  */
void HTTPAPI DestroyHttpState( HTTPState pHttpState );
HTTP_EXPORT
 /* Add another bit of data to the block. After adding data,
   ProcessHttp should be called to see if the data has completed
   a packet.
   Parameters
   pHttpState :  state to add data to
   buffer :      pointer to some data bytes
   size :        length of data bytes
   Returns: TRUE if content is added... if collecting chunked encoding may return FALSE.
   */
LOGICAL HTTPAPI AddHttpData( HTTPState pHttpState, POINTER buffer, size_t size );
/* \returns TRUE if completed until content-length if
   content-length is not specified, data is still collected, but
   the status never results TRUE.
	Parameters
	pc : Occasionally the http processor needs to send data on the
	     socket without application being aware it did.
   pHttpState :  Http State to process (after having added data to
                 it)
   Return Value List
   TRUE :   A completed HTTP packet has been gathered \- according
            to 'content\-length' meta tag.
   FALSE :  Still collecting full packet                           */
//HTTP_EXPORT int HTTPAPI ProcessHttp( HTTPState pHttpState );
HTTP_EXPORT int HTTPAPI ProcessHttp( PCLIENT pc, HTTPState pHttpState );
HTTP_EXPORT
 /* Gets the specific result code at the header of the packet -
   http 2.0 OK sort of thing.                                  */
PTEXT HTTPAPI GetHttpResponce( HTTPState pHttpState );
/* Get the method of the request in ht e http state.
*/
HTTP_EXPORT PTEXT HTTPAPI GetHttpMethod( struct HttpState *pHttpState );
/*Get the value of a HTTP header field, by name
   Parameters
	pHttpState: the state to get the header field from.
	name: name of the field to get (checked case insensitive)
*/
HTTP_EXPORT PTEXT HTTPAPI GetHTTPField( HTTPState pHttpState, CTEXTSTR name );
/* Gets the specific request code at the header of the packet -
   http 2.0 OK sort of thing.                                  */
HTTP_EXPORT PTEXT HTTPAPI GetHttpRequest( HTTPState pHttpState );
/* \Returns the body of the HTTP packet (the part of data
   specified by content-length or by termination of the
   connection(? think I didn't implement that right)      */
HTTP_EXPORT PTEXT HTTPAPI GetHttpContent( HTTPState pHttpState );
/* \Returns the resource path/name of the HTTP packet (the part of data
   specified by content-length or by termination of the
   connection(? think I didn't implement that right)      */
HTTP_EXPORT PTEXT HTTPAPI GetHttpResource( HTTPState pHttpState );
/* Returns a list of fields that were included in a request header.
   members of the list are of type struct HttpField.
   see also: ProcessHttpFields and ProcessCGIFields
*/
HTTP_EXPORT PLIST HTTPAPI GetHttpHeaderFields( HTTPState pHttpState );
HTTP_EXPORT int HTTPAPI GetHttpVersion( HTTPState pHttpState );
HTTP_EXPORT
 /* Enumerates the various http header fields by passing them
   each sequentially to the specified callback.
   Parameters
   pHttpState :  _nt_
   _nt_ :        _nt_
   psv :         _nt_                                        */
void HTTPAPI ProcessCGIFields( HTTPState pHttpState, void (CPROC*f)( uintptr_t psv, PTEXT name, PTEXT value ), uintptr_t psv );
HTTP_EXPORT
 /* Enumerates the various http header fields by passing them
   each sequentially to the specified callback.
   Parameters
   pHttpState :  _nt_
   _nt_ :        _nt_
   psv :         _nt_                                        */
void HTTPAPI ProcessHttpFields( HTTPState pHttpState, void (CPROC*f)( uintptr_t psv, PTEXT name, PTEXT value ), uintptr_t psv );
HTTP_EXPORT
 /* Resets a processing state, so it can start collecting the
   next state. After a ProcessHttp results with true, this
   should be called after processing the packet content.
   Parameters
   pHttpState :  state to reset for next read...             */
void HTTPAPI EndHttp( HTTPState pHttpState );
HTTP_EXPORT
/* reply message - 200/OK with this body, sent as Content-Type that was requested */
void HTTPAPI SendHttpMessage( HTTPState pHttpState, PCLIENT pc, PTEXT body );
HTTP_EXPORT
/* generate response message, specifies the numeric (200), the text (OK), the content type field value, and the body to send */
void HTTPAPI SendHttpResponse ( HTTPState pHttpState, PCLIENT pc, int numeric, CTEXTSTR text, CTEXTSTR content_type, PTEXT body );
/* Callback type used when creating an http server.
 If there is no registered handler match, then this is called.
 This should return FALSE if there was no content, allowing a 404 status result.
 Additional ways of dispatching need to be implemented (like handlers for paths, wildcards...)
 */
typedef LOGICAL (CPROC *ProcessHttpRequest)( uintptr_t psv
												 , HTTPState pHttpState );
HTTP_EXPORT
/* Intended to create a generic http service, which you can
   attach URL handlers to. Incomplete
   Works mostly?  OnGet has been known to get called....
   */
struct HttpServer *CreateHttpServerEx( CTEXTSTR interface_address, CTEXTSTR TargetName, CTEXTSTR site, ProcessHttpRequest handle_request, uintptr_t psv );
HTTP_EXPORT
/* Intended to create a generic http service, which you can
   attach URL handlers to. Incomplete
   Works mostly?  OnGet has been known to get called....
   */
struct HttpServer *CreateHttpsServerEx( CTEXTSTR interface_address, CTEXTSTR TargetName, CTEXTSTR site, ProcessHttpRequest handle_request, uintptr_t psv );
/* results with just the content of the message; no access to other information avaialble */
HTTP_EXPORT PTEXT HTTPAPI PostHttp( PTEXT site, PTEXT resource, PTEXT content );
/* results with just the content of the message; no access to other information avaialble */
HTTP_EXPORT PTEXT HTTPAPI GetHttp( PTEXT site, PTEXT resource, LOGICAL secure );
/* results with just the content of the message; no access to other information avaialble */
HTTP_EXPORT PTEXT HTTPAPI GetHttps( PTEXT address, PTEXT url, const char *certChain );
/* results with the http state of the message response; Allows getting other detailed information about the result */
HTTP_EXPORT HTTPState  HTTPAPI PostHttpQuery( PTEXT site, PTEXT resource, PTEXT content );
/* results with the http state of the message response; Allows getting other detailed information about the result */
HTTP_EXPORT HTTPState  HTTPAPI GetHttpQuery( PTEXT site, PTEXT resource );
/* results with the http state of the message response; Allows getting other detailed information about the result */
HTTP_EXPORT HTTPState HTTPAPI GetHttpsQuery( PTEXT site, PTEXT resource, const char *certChain );
/* return the numeric response code of a http reply. */
HTTP_EXPORT int HTTPAPI GetHttpResponseCode( HTTPState pHttpState );
#define CreateHttpServer(interface_address,site,psv) CreateHttpServerEx( interface_address,NULL,site,NULL,psv )
#define CreateHttpServer2(interface_address,site,default_handler,psv) CreateHttpServerEx( interface_address,NULL,site,default_handler,psv )
// receives events for either GET if aspecific OnHttpRequest has not been defined for the specific resource
// Return TRUE if processed, otherwise will attempt to match other Get Handlers
#define OnHttpGet( site, resource )	 __DefineRegistryMethod(WIDE( "SACK/Http/Methods" ),OnHttpGet,site,resource,WIDE( "Get" ),LOGICAL,(uintptr_t,PCLIENT,struct HttpState *,PTEXT),__LINE__)
// receives events for either GET if aspecific OnHttpRequest has not been defined for the specific resource
// Return TRUE if processed, otherwise will attempt to match other Get Handlers
#define OnHttpPost( site, resource )	 __DefineRegistryMethod(WIDE( "SACK/Http/Methods" ),OnHttpPost,site,resource,WIDE( "Post" ),LOGICAL,(uintptr_t,PCLIENT,struct HttpState *,PTEXT),__LINE__)
// define a specific handler for a specific resource name on a host
#define OnHttpRequest( site, resource )	 __DefineRegistryMethod(WIDE( "SACK/Http/Methods" ),OnHttpRequest,WIDE( "something" ),site WIDE( "/" ) resource,WIDE( "Get" ),void,(uintptr_t,PCLIENT,struct HttpState *,PTEXT),__LINE__)
//--------------------------------------------------------------
//  URL.c  (url parsing utility)
struct url_cgi_data
{
	CTEXTSTR name;
	CTEXTSTR value;
};
struct url_data
{
	CTEXTSTR protocol;
	CTEXTSTR user;
	CTEXTSTR password;
	CTEXTSTR host;
	int default_port;
  // encoding RFC3986 http://tools.ietf.org/html/rfc3986  specifies port characters are in the set of digits.
	int port;
	//CTEXTSTR port_data;  // during collection, the password may be in the place of 'port'
	CTEXTSTR resource_path;
	CTEXTSTR resource_file;
	CTEXTSTR resource_extension;
	CTEXTSTR resource_anchor;
   // list of struct url_cgi_data *
	PLIST cgi_parameters;
};
HTTP_EXPORT struct url_data * HTTPAPI SACK_URLParse( const char *url );
HTTP_EXPORT char *HTTPAPI SACK_BuildURL( struct url_data *data );
HTTP_EXPORT void HTTPAPI SACK_ReleaseURL( struct url_data *data );
	_HTTP_NAMESPACE_END
TEXT_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::containers::text::http;
#endif
#endif
HTTP_NAMESPACE
enum ReadChunkState {
	READ_VALUE, READ_VALUE_CR, READ_VALUE_LF, READ_CR, READ_LF, READ_BYTES
};
struct HttpState {
	// add input into pvt_collector
	PVARTEXT pvt_collector;
  // an accumulator that moves data from collector into whatever we've got leftover
	PTEXT partial;
	PTEXT method;
 // the first line of the http responce... (or request)
	PTEXT response_status;
 // the path of the resource - mostly for when this is used to receive requests.
	PTEXT resource;
 // list of struct HttpField *, these other the other meta fields in the header.
	PLIST fields;
 // list of HttpField *, taken in from the URL or content (get or post)
	PLIST cgi_fields;
	size_t content_length;
 // content of the message, POST,PUT,PATCH and replies have this.
	PTEXT content;
	LOGICAL returned_status;
 // boolean flag - indicates that the header portion of the http request is finished.
	int final;
 //for handling requests, have to read somewhere
	POINTER buffer;
	int numeric_code;
	int response_version;
	TEXTSTR text_code;
 // when a request comes in to the server, it is kept in a new http state, this is set for Send Response
	PCLIENT request_socket;
	LOGICAL ssl;
 // this is filled with a request ready to go out; used for HTTPS
	PVARTEXT pvtOut;
	LOGICAL read_chunks;
	size_t read_chunk_byte;
	size_t read_chunk_length;
	size_t read_chunk_total_length;
	enum ReadChunkState read_chunk_state;
	uint32_t last_read_tick;
	PTHREAD waiter;
	PCLIENT *pc;
	struct httpStateFlags {
		BIT_FIELD keep_alive : 1;
		BIT_FIELD close : 1;
		BIT_FIELD upgrade : 1;
		BIT_FIELD h2c_upgrade : 1;
		BIT_FIELD ws_upgrade : 1;
 // prevent issuing network reads... ssl pushes data from internal buffers
		BIT_FIELD ssl : 1;
		BIT_FIELD success : 1;
	}flags;
};
struct HttpServer {
	PCLIENT server;
	PLIST clients;
	ProcessHttpRequest handle_request;
	uintptr_t psvRequest;
	CTEXTSTR site;
	PCLASSROOT methods;
};
static struct local_http_data
{
	struct http_data_flags {
		BIT_FIELD bLogReceived : 1;
	} flags;
	PLIST pendingConnects;
}local_http_data;
#define l local_http_data
struct pendingConnect {
	PCLIENT pc;
	struct HttpState *state;
};
PRELOAD( loadOption ) {
#ifndef __NO_OPTIONS__
	l.flags.bLogReceived = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/HTTP/Enable Logging Received Data" ), 0, TRUE );
#endif
}
void GatherHttpData( struct HttpState *pHttpState )
{
	if( pHttpState->content_length )
	{
		PTEXT pMergedLine;
		PTEXT pInput = VarTextGet( pHttpState->pvt_collector );
		PTEXT pNewLine = SegAppend( pHttpState->partial, pInput );
		//lprintf( "Gathering http data with content length..." );
		pMergedLine = SegConcat( NULL, pNewLine, 0, GetTextSize( pHttpState->partial ) + GetTextSize( pInput ) );
		LineRelease( pNewLine );
		pHttpState->partial = pMergedLine;
		if( GetTextSize( pHttpState->partial ) >= pHttpState->content_length )
		{
			//lprintf( "Partial is complete with %d", GetTextSize( pHttpState->partial ) );
			pHttpState->content = SegSplit( &pHttpState->partial, pHttpState->content_length );
			pHttpState->partial = NEXTLINE( pHttpState->partial );
			SegGrab( pHttpState->partial );
			pHttpState->flags.success = 1;
		}
		//else
		//	lprintf( "Partial is only %d", GetTextSize( pHttpState->partial ) );
	}
	else
	{
		PTEXT pMergedLine;
		PTEXT pInput = VarTextGet( pHttpState->pvt_collector );
		PTEXT pNewLine = SegAppend( pHttpState->partial, pInput );
		pMergedLine = SegConcat( NULL, pNewLine, 0, GetTextSize( pHttpState->partial ) + GetTextSize( pInput ) );
		LineRelease( pNewLine );
		pHttpState->partial = pMergedLine;
		//lprintf( "Setting content to partial... " );
		pHttpState->content = pHttpState->partial;
	}
}
void ProcessURL_CGI( struct HttpState *pHttpState, PTEXT params )
{
	PTEXT start = TextParse( params, WIDE( "&=" ), NULL, 1, 1 DBG_SRC );
	PTEXT next = start;
	PTEXT tmp;
	//lprintf( "Input was %s", GetText( params ) );
	while( ( tmp = next ) )
	{
		PTEXT name = tmp;
		/*PTEXT equals = */
( next = NEXTLINE( tmp ) );
		PTEXT value = ( next = NEXTLINE( next ) );
		/*PTEXT ampersand = */
( next = NEXTLINE( next ) );
		struct HttpField *field = New( struct HttpField );
		field->name = SegDuplicate( name );
		field->value = SegDuplicate( value );
		//lprintf( "Added %s=%s", GetText( field->name ), GetText( field->value ) );
		AddLink( &pHttpState->cgi_fields, field );
		next = NEXTLINE( next );
	}
	LineRelease( start );
}
//int ProcessHttp( struct HttpState *pHttpState )
int ProcessHttp( PCLIENT pc, struct HttpState *pHttpState )
{
	if( pHttpState->final )
	{
		GatherHttpData( pHttpState );
		if( pHttpState->flags.success && !pHttpState->returned_status ) {
			pHttpState->returned_status = 1;
			return pHttpState->numeric_code;
		}
		return HTTP_STATE_RESULT_NOTHING;
	}
	else
	{
//, pStart;
		PTEXT pCurrent;
		PTEXT pLine = NULL;
		TEXTCHAR *c, *line;
		size_t size, pos, len;
		size_t bLine;
		INDEX start = 0;
		PTEXT pMergedLine;
		PTEXT pInput = VarTextGet( pHttpState->pvt_collector );
		PTEXT pNewLine = SegAppend( pHttpState->partial, pInput );
		pMergedLine = SegConcat( NULL, pNewLine, 0, GetTextSize( pHttpState->partial ) + GetTextSize( pInput ) );
		LineRelease( pNewLine );
		pHttpState->partial = pMergedLine;
		pCurrent = pHttpState->partial;
		//pStart = pCurrent; // at lest is this block....
		//LogBinary( (const uint8_t*)GetText( pInput ), GetTextSize( pInput ) );
		len = 0;
		// we always start without having a line yet, because all input is already merged
		bLine = 0;
		{
			//lprintf( "%s", GetText( pCurrent ) );
			size = GetTextSize( pCurrent );
			c = GetText( pCurrent );
			if( bLine < 4 )
			{
				//start = 0; // new packet and still collecting header....
				for( pos = 0; ( pos < size ) && !pHttpState->final; pos++ )
				{
					if( (pos - start - bLine) < 0 )
						continue;
					if( c[pos] == '\r' )
						bLine++;
					else if( c[pos] == '\n' )
						bLine++;
 // non end of line character....
					else
					{
	FinalCheck:
 // had an end of line...
						if( bLine >= 2 )
						{
							// response status is the data from the fist bit of the packet (on receiving http 1.1/OK ...)
							if( pHttpState->response_status )
							{
								CTEXTSTR field_start;
								CTEXTSTR colon;
								CTEXTSTR field_end;
								CTEXTSTR val_start;
								PTEXT field_name;
								PTEXT value;
								pLine = SegCreate( pos - start - bLine );
								if( (pos-start) < bLine )
								{
									lprintf( WIDE("Failure.") );
								}
								MemCpy( line = GetText( pLine ), c + start, (pos - start - bLine)*sizeof(TEXTCHAR));
								line[pos-start-bLine] = 0;
								field_start = GetText( pLine );
								// this is a  request field.
								colon = StrChr( field_start, ':' );
								if( colon )
								{
									PTEXT trash;
									val_start = colon + 1;
									field_end = colon;
									while( ( field_end > field_start )&& field_end[-1] == ' ' )
										field_end--;
									while( ( val_start[0] && ( val_start[0] == ' ' ) ) )
										val_start++;
									SegSplit( &pLine, val_start - field_start );
									value = NEXTLINE( pLine );
									field_name = SegSplit( &pLine, field_end - field_start );
									trash = NEXTLINE( field_name );
									{
										struct HttpField *field = New( struct HttpField );
										field->name = SegGrab( field_name );
										field->value = SegGrab( value );
										if( TextLike( field->name, "connection" ) )
										{
											if( TextLike( field->value, "keep-alive" ) ) {
												pHttpState->flags.keep_alive = 1;
											}
											if( TextLike( field->value, "close" ) ) {
												pHttpState->flags.close = 1;
											}
										}
										LineRelease( trash );
										AddLink( &pHttpState->fields, field );
									}
								}
								else
								{
									lprintf( WIDE( "Header field [%s] invalid" ), GetText( pLine ) );
									LineRelease( pLine );
								}
							}
							else
							{
								pLine = SegCreate( pos - start - bLine );
								MemCpy( line = GetText( pLine ), c + start, (pos - start - bLine)*sizeof(TEXTCHAR));
								line[pos-start-bLine] = 0;
								pHttpState->response_status = pLine;
 // initialize to assume it's incomplete; NOT OK.  (requests should be OK)
								pHttpState->numeric_code = 0;
								{
									PTEXT request = TextParse( pHttpState->response_status, WIDE( "?#" ), WIDE( " " ), 1, 1 DBG_SRC );
									{
										PTEXT tmp;
										PTEXT resource_path = NULL;
										PTEXT next;
										if( TextSimilar( request, WIDE( "GET" ) ) )
										{
 // initialize to assume it's incomplete; NOT OK.  (requests should be OK)
											pHttpState->numeric_code = HTTP_STATE_RESULT_CONTENT;
											request = NEXTLINE( request );
											pHttpState->method = SegBreak( request );
										}
										else if( TextSimilar( request, WIDE( "POST" ) ) )
										{
 // initialize to assume it's incomplete; NOT OK.  (requests should be OK)
											pHttpState->numeric_code = HTTP_STATE_RESULT_CONTENT;
											lprintf( WIDE("probably shouldn't post final until content length is also received...") );
											request = NEXTLINE( request );
											pHttpState->method = SegBreak( request );
										}
										// this loop is used for both client and server http requests...
										// this will be the first part of a HTTP response (this one will have a result code, the other is just version)
										else if( TextSimilar( request, WIDE( "HTTP/" ) ) )
										{
											TEXTCHAR *tmp2 = (TEXTCHAR*)StrChr( GetText( request ), '.' );
											pHttpState->response_version = (int)((IntCreateFromText( GetText( request ) + 5 ) * 100) + IntCreateFromText( tmp2 + 1 ));
											{
												PTEXT nextword = NEXTLINE( request );
												if( nextword )
												{
													next = NEXTLINE( nextword );
													// cast from int64_t
													pHttpState->numeric_code = (int)IntCreateFromText( GetText( nextword ) );
													nextword = next;
													if( nextword )
													{
														next = NEXTLINE( nextword );
														if( pHttpState->text_code )
															Release( pHttpState->text_code );
														pHttpState->text_code = StrDup( GetText( nextword ) );
													}
												}
												else
												{
													lprintf( WIDE( "failed to find result code in %s" ), line );
												}
											}
										}
										else {
											lprintf( "Unsupported Command:%s", GetText( request ) );
											request = NEXTLINE( request );
											pHttpState->method = SegBreak( request );
										}
										for( tmp = request; tmp; tmp = next )
										{
											//lprintf( WIDE( "word %s" ), GetText( tmp ) );
											next = NEXTLINE( tmp );
											//lprintf( "Line : %s", GetText( pLine ) );
											if( TextSimilar( tmp, WIDE("HTTP/") ) )
											{
												TEXTCHAR *tmp2 = (TEXTCHAR*)StrChr( GetText( tmp ), '.' );
												pHttpState->response_version = (int)(( IntCreateFromText( GetText( tmp ) + 5 ) * 100 ) + IntCreateFromText( tmp2 + 1 ));
											}
											else if( GetText(tmp)[0] == '?' )
											{
												ProcessURL_CGI( pHttpState, next );
												next = NEXTLINE( next );
											}
											else if( GetText(tmp)[0] == '#' )
											{
												lprintf( WIDE("Page anchor is lost... %s"), GetText( next ) );
												next = NEXTLINE( next );
											}
											else
											{
												if( (resource_path && tmp->format.position.offset.spaces) )
												{
													break;
												}
												else
												{
													resource_path = SegAppend( resource_path, SegGrab( tmp ) );
													request = next;
												}
											}
										}
										pHttpState->resource = resource_path;
									}
									LineRelease( request );
								}
								//else
								//	lprintf( "Not Http header?" );
							}
							// could perhaps append a newline segment block...
							// but probably do not need such a thing....
							// since the return should be assumed as a continuous
							// stream of datas....
							start = pos;
							if( bLine == 2 )
								bLine = 0;
						}
						// may not receive anything other than header information?
						if( bLine == 4 )
						{
							// end of header
							// copy the previous line out...
							//pStart = pCurrent;
 // remaing size
							len = size - pos;
							break;
						}
					}
					if( bLine == 4 )
					{
						pos++;
						pHttpState->final = 1;
						goto FinalCheck;
					}
				}
				if( pos == size &&
					bLine == 4 &&
					start != pos )
				{
					pHttpState->final = 1;
					goto FinalCheck;
				}
			}
			else
				len += size;
			//pCurrent = NEXTLINE( pCurrent );
			/* Move the remaining data into a single binary data packet...*/
		}
		if( start )
		{
			/*PTEXT tmp = */
SegSplit( &pCurrent, start );
			pHttpState->partial = NEXTLINE( pCurrent );
			LineRelease( SegGrab( pCurrent ) );
			start = 0;
		}
		// final is having received the end of the HTTP header, not nessecarily all data
		if( pHttpState->final )
		{
			INDEX idx;
			struct HttpField *field;
			LIST_FORALL( pHttpState->fields, idx, struct HttpField *, field )
			{
				if( TextLike( field->name, WIDE( "content-length" ) ) )
				{
					// down convert from int64_t
					pHttpState->content_length = (int)IntCreateFromSeg( field->value );
					//lprintf( "content lenght: %d", pHttpState->content_length );
				}
				else if( TextLike( field->name, WIDE( "upgrade" ) ) )
				{
					if( TextLike( field->value, "websocket" ) ) {
						pHttpState->flags.ws_upgrade = 1;
					}
					else if( TextLike( field->value, "h2c" ) ) {
						pHttpState->flags.h2c_upgrade = 1;
					}
				}
				else if( TextLike( field->name, WIDE( "connection" ) ) )
				{
					if( TextLike( field->value, "upgrade" ) ) {
						pHttpState->flags.upgrade = 1;
					}
				}
				else if( TextLike( field->name, WIDE( "Transfer-Encoding" ) ) )
				{
					if( TextLike( field->value, "chunked" ) )
					{
						pHttpState->content_length = 0xFFFFFFF;
						pHttpState->read_chunks = TRUE;
						pHttpState->read_chunk_state = READ_VALUE;
						pHttpState->read_chunk_length = 0;
						pHttpState->read_chunk_total_length = 0;
					}
				}
				else if( TextLike( field->name, WIDE( "Expect" ) ) )
				{
					if( TextLike( field->value, WIDE( "100-continue" ) ) )
					{
						if( l.flags.bLogReceived )
							lprintf( WIDE("Generating 100-continue response...") );
						SendTCP( pc, "HTTP/1.1 100 Continue\r\n\r\n", 25 );
					}
				}
			}
			// do one gather here... with whatever remainder we had.
			GatherHttpData( pHttpState );
		}
	}
	if( pHttpState->final &&
		( ( pHttpState->content_length
			&& ( ( GetTextSize( pHttpState->partial ) >= pHttpState->content_length )
				||( GetTextSize( pHttpState->content ) >= pHttpState->content_length ) ) )
			|| ( !pHttpState->content_length )
			) )
	{
		pHttpState->returned_status = 1;
		if( pHttpState->numeric_code == 500 )
			return HTTP_STATE_INTERNAL_SERVER_ERROR;
		if( pHttpState->content && (pHttpState->numeric_code == 200) ) {
			return HTTP_STATE_RESULT_CONTENT;
		}
		if( pHttpState->numeric_code == 100 )
			return HTTP_STATE_RESULT_CONTINUE;
		if( pHttpState->numeric_code == 404 )
			return HTTP_STATE_RESOURCE_NOT_FOUND;
		if( pHttpState->numeric_code == 400 )
			return HTTP_STATE_BAD_REQUEST;
		return pHttpState->numeric_code;
	}
	return HTTP_STATE_RESULT_NOTHING;
}
LOGICAL AddHttpData( struct HttpState *pHttpState, POINTER buffer, size_t size )
{
	pHttpState->last_read_tick = GetTickCount();
	if( pHttpState->read_chunks )
	{
		uint8_t* buf = (uint8_t*)buffer;
		size_t ofs = 0;
		while( ofs < size )
		{
			switch( pHttpState->read_chunk_state )
			{
			case READ_VALUE:
				if( buf[0] >= '0' && buf[0] <= '9' )
				{
					pHttpState->read_chunk_length *= 16;
					pHttpState->read_chunk_length += buf[0] - '0';
				}
				else if( ( buf[0] | 0x20 ) >= 'a' && (buf[0] | 0x20) <= 'f' )
				{
					pHttpState->read_chunk_length *= 16;
					pHttpState->read_chunk_length += (buf[0] | 0x20) - 'a' + 10;
				}
				else if( buf[0] == '\r' )
				{
					pHttpState->read_chunk_total_length += pHttpState->read_chunk_length;
					if( l.flags.bLogReceived ) {
						lprintf( "Chunck will be %zd", pHttpState->read_chunk_length );
					}
					pHttpState->read_chunk_state = READ_VALUE_LF;
				}
				else
				{
					lprintf( "Chunk Processing Error expected \\n, found %d(%c)", buf[0], buf[0] );
					RemoveClient( pHttpState->request_socket );
					return FALSE;
				}
				break;
			case READ_VALUE_CR:
            // didn't actually implement to get into this state... just looks for newlines really.
            break;
			case READ_VALUE_LF:
				if( buf[0] == '\n' )
				{
					if( pHttpState->read_chunk_length == 0 )
						pHttpState->read_chunk_state = READ_CR;
					else
						pHttpState->read_chunk_state = READ_BYTES;
				}
				else
				{
					lprintf( "Chunk Processing Error expected \\n, found %d(%c)", buf[0], buf[0] );
					RemoveClient( pHttpState->request_socket );
					return FALSE;
				}
				break;
			case READ_CR:
				if( buf[0] == '\r' )
				{
					pHttpState->read_chunk_state = READ_LF;
				}
				else
				{
					lprintf( "Chunk Processing Error expected \\r, found %d(%c)", buf[0], buf[0] );
					RemoveClient( pHttpState->request_socket );
					return FALSE;
				}
				break;
			case READ_LF:
				if( buf[0] == '\n' )
				{
					if( pHttpState->read_chunk_length )
					{
						pHttpState->read_chunk_length = 0;
						pHttpState->read_chunk_state = READ_VALUE;
					}
					else
					{
						pHttpState->content_length = GetTextSize( VarTextPeek( pHttpState->pvt_collector ) );
						if( pHttpState->waiter ) {
							//lprintf( "Waking waiting to return with result." );
							WakeThread( pHttpState->waiter );
						}
						return TRUE;
					}
				}
				else
				{
					lprintf( "Chunk Processing Error expected \\n, found %d(%c)", buf[0], buf[0] );
					RemoveClient( pHttpState->request_socket );
					return FALSE;
				}
				break;
			case READ_BYTES:
				VarTextAddData( pHttpState->pvt_collector, (CTEXTSTR)(buf), 1 );
				pHttpState->read_chunk_byte++;
				if( pHttpState->read_chunk_byte == pHttpState->read_chunk_length )
					pHttpState->read_chunk_state = READ_CR;
				break;
			}
			ofs++;
			buf++;
		}
		if( l.flags.bLogReceived ) {
			lprintf( "chunk read is %zd of %zd", pHttpState->read_chunk_byte, pHttpState->read_chunk_total_length );
		}
		return FALSE;
	}
	else
	{
		VarTextAddData( pHttpState->pvt_collector, (CTEXTSTR)buffer, size );
		return TRUE;
	}
}
struct HttpState *CreateHttpState( void )
{
	struct HttpState *pHttpState;
	pHttpState = New( struct HttpState );
	MemSet( pHttpState, 0, sizeof( struct HttpState ) );
	pHttpState->pvt_collector = VarTextCreate();
	return pHttpState;
}
void EndHttp( struct HttpState *pHttpState )
{
	pHttpState->final = 0;
	pHttpState->content_length = 0;
	LineRelease( pHttpState->method );
	pHttpState->method = NULL;
	LineRelease( pHttpState->content );
	LineRelease( pHttpState->resource );
	pHttpState->resource = NULL;
	if( pHttpState->partial != pHttpState->content )
	{
		LineRelease( pHttpState->partial );
	}
	pHttpState->partial = NULL;
	pHttpState->content = NULL;
	LineRelease( pHttpState->response_status );
	pHttpState->response_status = NULL;
	pHttpState->numeric_code = 0;
	if( pHttpState->text_code )
	{
		Release( pHttpState->text_code );
		pHttpState->text_code = NULL;
	}
	{
		INDEX idx;
		struct HttpField *field;
		LIST_FORALL( pHttpState->fields, idx, struct HttpField *, field )
		{
			LineRelease( field->name );
			LineRelease( field->value );
			Release( field );
		}
		EmptyList( &pHttpState->fields );
	}
}
PTEXT GetHttpContent( struct HttpState *pHttpState )
{
	if( pHttpState->read_chunks )
	{
		/* did a timeout happen? */
		if( pHttpState->content_length == pHttpState->read_chunk_total_length )
			return pHttpState->content;
		return NULL;
	}
	if( pHttpState->content_length )
		return pHttpState->content;
	return NULL;
}
void ProcessHttpFields( struct HttpState *pHttpState, void (CPROC*f)( uintptr_t psv, PTEXT name, PTEXT value ), uintptr_t psv )
{
	INDEX idx;
	struct HttpField *field;
	LIST_FORALL( pHttpState->fields, idx, struct HttpField *, field )
	{
		f( psv, field->name, field->value );
	}
}
void ProcessCGIFields( struct HttpState *pHttpState, void (CPROC*f)( uintptr_t psv, PTEXT name, PTEXT value ), uintptr_t psv )
{
	INDEX idx;
	struct HttpField *field;
	LIST_FORALL( pHttpState->cgi_fields, idx, struct HttpField *, field )
	{
		f( psv, field->name, field->value );
	}
}
PTEXT GetHttpField( struct HttpState *pHttpState, CTEXTSTR name )
{
	INDEX idx;
	struct HttpField *field;
	LIST_FORALL( pHttpState->fields, idx, struct HttpField *, field )
	{
		if( StrCaseCmp( GetText( field->name ), name ) == 0 )
			return field->value;
	}
	return NULL;
}
PTEXT GetHttpResponce( struct HttpState *pHttpState )
{
	return pHttpState->response_status;
}
PTEXT GetHttpRequest( struct HttpState *pHttpState )
{
	return pHttpState->resource;
}
PTEXT GetHttpResource( struct HttpState *pHttpState )
{
	return pHttpState->resource;
}
PTEXT GetHttpMethod( struct HttpState *pHttpState )
{
	return pHttpState->method;
}
void DestroyHttpStateEx( struct HttpState *pHttpState DBG_PASS )
{
   //_lprintf(DBG_RELAY)( "Destroy http state... (should clear content too?" );
 // empties variables
	EndHttp( pHttpState );
	DeleteList( &pHttpState->fields );
	VarTextDestroy( &pHttpState->pvtOut );
	VarTextDestroy( &pHttpState->pvt_collector );
	if( pHttpState->buffer )
		Release( pHttpState->buffer );
	Release( pHttpState );
}
void DestroyHttpState( struct HttpState *pHttpState ) {
   DestroyHttpStateEx( pHttpState DBG_SRC );
}
#define DestroyHttpState(state) DestroyHttpStateEx(state DBG_SRC )
void SendHttpResponse ( struct HttpState *pHttpState, PCLIENT pc, int numeric, CTEXTSTR text, CTEXTSTR content_type, PTEXT body )
{
	//int offset = 0;
	PVARTEXT pvt_message = VarTextCreate();
	PTEXT header;
	PTEXT tmp_content;
	//TEXTCHAR message[500];
	vtprintf( pvt_message, WIDE( "HTTP/1.1 %d %s\r\n" ), numeric, text );
	if( content_type && body )
	{
		vtprintf( pvt_message, WIDE( "Content-Length: %d\r\n" ), GetTextSize(body));
		vtprintf( pvt_message, WIDE( "Content-Type: %s\r\n" )
				  , content_type?content_type
					:(tmp_content=GetHttpField( pHttpState, WIDE("Accept") ))?GetText(tmp_content)
					:WIDE("text/plain; charset=utf-8")  );
	}
	//else
	//	vtprintf( pvt_message, WIDE( "%s\r\n" ), GetText( body ) );
	vtprintf( pvt_message, WIDE( "Server: SACK Core Library 2.x\r\n" )  );
	if( body )
		vtprintf( pvt_message, WIDE( "\r\n" )  );
	header = VarTextPeek( pvt_message );
	//offset += snprintf( message + offset, sizeof( message ) - offset, WIDE( "%s" ),  "Body");
	if( l.flags.bLogReceived )
	{
		lprintf( WIDE("Sending response...") );
		LogBinary( (uint8_t*)GetText( header ), GetTextSize( header ) );
		if( content_type )
			LogBinary( (uint8_t*)GetText( body ), GetTextSize( body ) );
	}
	if( !pc )
		pc = pHttpState->request_socket;
	SendTCP( pc, GetText( header ), GetTextSize( header ) );
	if( content_type )
		SendTCP( pc, GetText( body ), GetTextSize( body ) );
	VarTextDestroy( &pvt_message );
}
void SendHttpMessage ( struct HttpState *pHttpState, PCLIENT pc, PTEXT body )
{
	PTEXT message;
	PVARTEXT pvt_message = VarTextCreate();
	PTEXT content_type;
	vtprintf( pvt_message, WIDE( "%s" ),  WIDE("HTTP/1.1 200 OK\r\n") );
	vtprintf( pvt_message, WIDE( "Content-Length: %d\r\n" ), GetTextSize( body ));
	vtprintf( pvt_message, WIDE( "Content-Type: %s\r\n" )
		, (content_type = GetHttpField( pHttpState, WIDE("Accept") ))?GetText(content_type):WIDE("text/plain" ));
	vtprintf( pvt_message, WIDE( "\r\n" )  );
	vtprintf( pvt_message, WIDE( "%s" ), GetText( body ));
	message = VarTextGet( pvt_message );
	if( l.flags.bLogReceived )
	{
		lprintf( WIDE(" Response Message:" ));
		LogBinary( (uint8_t*)GetText( message ), GetTextSize( message ));
	}
	SendTCP( pc, GetText( message ), GetTextSize( message ));
}
//---------- CLIENT --------------------------------------------
static void CPROC HttpReader( PCLIENT pc, POINTER buffer, size_t size )
{
	struct HttpState *state = (struct HttpState *)GetNetworkLong( pc, 0 );
	if( !buffer )
	{
		//lprintf( "Initial read on HTTP requestor" );
		if( state && state->ssl )
		{
			PTEXT send = VarTextGet( state->pvtOut );
			if( l.flags.bLogReceived )
			{
				lprintf( WIDE("Sending Request...") );
				LogBinary( (uint8_t*)GetText( send ), GetTextSize( send ) );
			}
#ifndef NO_SSL
			// had to wait for handshake, so NULL event
			// on secure has already had time to build the send
			// but had to wait until now to do that.
			ssl_Send( pc, GetText( send ), GetTextSize( send ) );
#endif
			LineRelease( send );
		}
		else
		{
			state->buffer = Allocate( 4096 );
			ReadTCP( pc, state->buffer, 4096 );
		}
	}
	else
	{
		if( l.flags.bLogReceived )
		{
			lprintf( WIDE("Received web request... %zu"), size );
			//LogBinary( buffer, size );
		}
		if( AddHttpData( state, buffer, size ) )
			if( ProcessHttp( pc, state ) )
			{
				RemoveClient( pc );
				return;
			}
	}
	// read is handled by the SSL layer instead of here.  Just trust that someone will give us data later
	if( buffer && ( !state || !state->ssl ) )
	{
		ReadTCP( pc, state->buffer, 4096 );
	}
}
static void CPROC HttpReaderClose( PCLIENT pc )
{
	struct HttpState *data = (struct HttpState *)GetNetworkLong( pc, 0 );
// (PCLIENT*)GetNetworkLong( pc, 0 );
	PCLIENT *ppc = data->pc;
	if( ppc )
		ppc[0] = NULL;
	if( data->waiter ) {
		//lprintf( "(on close) Waking waiting to return with result." );
		WakeThread( data->waiter );
	}
	//if( !data->flags.success )
	//	DestroyHttpState( data );
}
static void CPROC HttpConnected( PCLIENT pc, int error ) {
	INDEX idx;
	struct pendingConnect *connect;
	while( 1 ) {
		LIST_FORALL( l.pendingConnects, idx, struct pendingConnect *, connect ) {
			if( connect->pc == pc ) {
				SetLink( &l.pendingConnects, idx, NULL );
				break;
			}
		}
		if( connect )
			break;
		Relinquish();
	}
	SetNetworkLong( pc, 0, (uintptr_t)connect->state );
	Release( connect );
}
HTTPState PostHttpQuery( PTEXT address, PTEXT url, PTEXT content )
{
	struct HttpState *state = CreateHttpState();
	PCLIENT pc;
	struct pendingConnect *connect = New( struct pendingConnect );
	connect->state = state;
	AddLink( &l.pendingConnects, connect );
	pc = OpenTCPClientExx( GetText( address ), 80, HttpReader, NULL, NULL, HttpConnected );
	connect->pc = pc;
	PVARTEXT pvtOut = VarTextCreate();
	vtprintf( pvtOut, WIDE( "POST %s HTTP/1.1\r\n" ), url );
	vtprintf( pvtOut, WIDE( "content-length:%d\r\n" ), GetTextSize( content ) );
	vtprintf( pvtOut, WIDE( "\r\n\r\n" ) );
	VarTextAddData( pvtOut, GetText( content ), GetTextSize( content ) );
	if( pc )
	{
		PTEXT send = VarTextGet( pvtOut );
		state->pc = &pc;
		state->waiter = MakeThread();
		SetNetworkLong( pc, 0, (uintptr_t)state );
		SetNetworkCloseCallback( pc, HttpReaderClose );
		if( l.flags.bLogReceived )
		{
			lprintf( WIDE("Sending POST...") );
			LogBinary( (uint8_t*)GetText( send ), GetTextSize( send ) );
		}
		SendTCP( pc, GetText( send ), GetTextSize( send ) );
		LineRelease( send );
		while( pc )
		{
			WakeableSleep( 100 );
		}
	}
	VarTextDestroy( &pvtOut );
	return state;
}
PTEXT PostHttp( PTEXT address, PTEXT url, PTEXT content )
{
	HTTPState state = PostHttpQuery( address, url, content );
	if( state )
	{
		PTEXT result = GetHttpContent( state );
		if( result )
			Hold( result );
		DestroyHttpState( state );
		return result;
	}
	return NULL;
}
static void httpConnected( PCLIENT pc, int error ) {
	if( error ) {
		struct HttpState *state = (struct HttpState *)GetNetworkLong( pc, 0 );
		RemoveClient( pc );
		return;
	}
	{
		INDEX idx;
		struct pendingConnect *connect;
		while( 1 ) {
			LIST_FORALL( l.pendingConnects, idx, struct pendingConnect *, connect ) {
				if( connect->pc == pc ) {
					SetLink( &l.pendingConnects, idx, NULL );
					break;
				}
			}
			if( connect )
				break;
			Relinquish();
		}
		SetNetworkLong( pc, 0, (uintptr_t)connect->state );
		Release( connect );
	}
}
HTTPState GetHttpQuery( PTEXT address, PTEXT url )
{
	if( !address )
		return NULL;
	{
		PCLIENT pc;
		SOCKADDR *addr = CreateSockAddress( GetText( address ), 443 );
		struct HttpState *state = CreateHttpState();
		struct pendingConnect *connect = New( struct pendingConnect );
		connect->state = state;
		AddLink( &l.pendingConnects, connect );
		pc = OpenTCPClientAddrExxx( addr, HttpReader, HttpReaderClose, NULL, httpConnected, 0 DBG_SRC );
		connect->pc = pc;
		ReleaseAddress( addr );
		if( pc ) {
			PVARTEXT pvtOut = VarTextCreate();
			SetTCPNoDelay( pc, TRUE );
			vtprintf( pvtOut, WIDE( "GET %s HTTP/1.1\r\n" ), GetText( url ) );
			vtprintf( pvtOut, WIDE( "Host: %s\r\n" ), GetText( address ) );
			vtprintf( pvtOut, WIDE( "\r\n" ) );
			if( pc )
			{
				PTEXT send = VarTextGet( pvtOut );
				state->waiter = MakeThread();
				state->pc = &pc;
				SetNetworkLong( pc, 0, (uintptr_t)state );
				SetNetworkCloseCallback( pc, HttpReaderClose );
				if( l.flags.bLogReceived )
				{
					lprintf( WIDE( "Sending POST..." ) );
					LogBinary( (uint8_t*)GetText( send ), GetTextSize( send ) );
				}
				SendTCP( pc, GetText( send ), GetTextSize( send ) );
				LineRelease( send );
				while( pc )
				{
					WakeableSleep( 100 );
				}
			}
			VarTextDestroy( &pvtOut );
			return state;
		}
	}
	return NULL;
}
HTTPState GetHttpsQuery( PTEXT address, PTEXT url, const char *certChain )
{
	if( !address )
		return NULL;
	{
		struct HttpState *state = CreateHttpState();
		static PCLIENT pc;
		SOCKADDR *addr = CreateSockAddress( GetText( address ), 443 );
		struct pendingConnect *connect = New( struct pendingConnect );
		connect->state = state;
		AddLink( &l.pendingConnects, connect );
		//DumpAddr( "Http Address:", addr );
		pc = OpenTCPClientAddrExxx( addr, HttpReader, HttpReaderClose, NULL, httpConnected, OPEN_TCP_FLAG_DELAY_CONNECT DBG_SRC );
		connect->pc = pc;
		ReleaseAddress( addr );
		if( pc )
		{
			state->last_read_tick = GetTickCount();
			state->waiter = MakeThread();
			state->pc = &pc;
			SetNetworkLong( pc, 0, (uintptr_t)state );
			//SetNetworkConn
			state->ssl = TRUE;
			state->pvtOut = VarTextCreate();
			vtprintf( state->pvtOut, WIDE( "GET %s HTTP/1.1\r\n" ), GetText( url ) );
			vtprintf( state->pvtOut, WIDE( "Host: %s\r\n" ), GetText( address ) );
			vtprintf( state->pvtOut, "User-Agent: SACK(%s)\r\n", "System" );
			vtprintf( state->pvtOut, WIDE( "\r\n" ) );
#ifndef NO_SSL
			if( ssl_BeginClientSession( pc, NULL, 0, NULL, 0, certChain, certChain ? strlen( certChain ) : 0 ) )
			{
				if( !certChain )
					ssl_SetIgnoreVerification( pc );
				if( NetworkConnectTCP( pc ) < 0 ) {
					DestroyHttpState( state );
					return NULL;
				}
				state->waiter = MakeThread();
				while( pc && ( state->last_read_tick > ( GetTickCount() - 20000 ) ) )
				{
					WakeableSleep( 1000 );
				}
				//lprintf( "Request has completed.... %p %p", pc, state->content );
				if( pc )
					RemoveClient( pc );
			}
			else
				RemoveClient( pc );
#endif
			VarTextDestroy( &state->pvtOut );
			if( !pc )
				return state;
		}
		else
		{
			RemoveClient( pc );
			DestroyHttpState( state );
		}
	}
	return NULL;
}
PTEXT GetHttp( PTEXT address, PTEXT url, LOGICAL secure )
{
	if( secure )
		return GetHttps( address, url, NULL );
	else
	{
	HTTPState state = GetHttpQuery( address, url );
	if( state )
	{
		PTEXT result = GetHttpContent( state );
		if( result )
			Hold( result );
		DestroyHttpState( state );
		return result;
	}}
	return NULL;
}
PTEXT GetHttps( PTEXT address, PTEXT url, const char *ca )
{
	HTTPState state = GetHttpsQuery( address, url, ca );
	if( state )
	{
		PTEXT result = GetHttpContent( state );
		if( result )
			Hold( result );
		DestroyHttpState( state );
		return result;
	}
	return NULL;
}
//---------- SERVER --------------------------------------------
static LOGICAL InvokeMethod( PCLIENT pc, struct HttpServer *server, struct HttpState *pHttpState )
{
	PTEXT method = GetHttpMethod( pHttpState );
	//PTEXT request = TextParse( pHttpState->response_status, WIDE( "?#" ), WIDE( " " ), 1, 1 DBG_SRC );
	if( TextLike( method, WIDE( "get" ) ) || TextLike( method, WIDE( "post" ) ) )
	{
		LOGICAL (CPROC *f)(uintptr_t, PCLIENT, struct HttpState *, PTEXT);
		LOGICAL status = FALSE;
		f = (LOGICAL (CPROC*)(uintptr_t, PCLIENT, struct HttpState *, PTEXT))GetRegisteredProcedureExxx( server->methods, (PCLASSROOT)(GetText( pHttpState->resource ) + 1), "LOGICAL", GetText(method), "(uintptr_t, PCLIENT, struct HttpState *, PTEXT)" );
		//lprintf( "got for %s %s", (PCLASSROOT)(GetText( pHttpState->resource ) + 1),  GetText( request ) );
		if( f )
			status = f( server->psvRequest, pc, pHttpState, pHttpState->content );
		if( !status )
		{
			if( server->handle_request )
				status = server->handle_request( server->psvRequest, pHttpState );
		}
		if( !status )
		{
			DECLTEXT( body, WIDE( "<HTML><HEAD><TITLE>Bad Request</TITLE></HEAD><BODY>Resource handler not found" ) );
			SendHttpResponse( pHttpState, NULL, 404, WIDE("NOT FOUND"), WIDE("text/html"), (PTEXT)&body );
		}
		return 1;
	}
	else
		lprintf( WIDE("not a get or a post?") );
	//LineRelease( request );
	return 0;
}
static void CPROC HandleRequest( PCLIENT pc, POINTER buffer, size_t length )
{
	if( !buffer )
	{
		struct HttpState *pHttpStateServer = (struct HttpState *)GetNetworkLong( pc, 0 );
		struct HttpState *pHttpState = CreateHttpState();
		pHttpState->ssl = pHttpStateServer->ssl;
		buffer = pHttpState->buffer = Allocate( 4096 );
		pHttpState->request_socket = pc;
		SetNetworkLong( pc, 1, (uintptr_t)pHttpState );
	}
	else
	{
		int result;
		struct HttpState *pHttpState = (struct HttpState *)GetNetworkLong( pc, 1 );
		if( l.flags.bLogReceived )
		{
			lprintf( WIDE("Received web request...") );
			LogBinary( (uint8_t*)buffer, length );
		}
		AddHttpData( pHttpState, buffer, length );
		while( ( result = ProcessHttp( pc, pHttpState ) ) )
		{
			int status;
			struct HttpServer *server = (struct HttpServer *)GetNetworkLong( pc, 0 );
			//lprintf( "result = %d", result );
			switch( result )
			{
			case HTTP_STATE_RESULT_CONTENT:
				status = InvokeMethod( pc, server, pHttpState );
				if( status
					&& ( ( pHttpState->response_version == 9 )
					|| (pHttpState->response_version == 100 && !pHttpState->flags.keep_alive)
					||( pHttpState->response_version == 101 && pHttpState->flags.close ) ) ) {
					RemoveClientEx( pc, 0, 1 );
					return;
				}
				else
					EndHttp( pHttpState );
				break;
			case HTTP_STATE_RESULT_CONTINUE:
				break;
			}
		}
		if( !pHttpState->ssl )
			ReadTCP( pc, buffer, 4096 );
	}
}
static void CPROC RequestorClosed( PCLIENT pc )
{
	struct HttpServer *server = (struct HttpServer *)GetNetworkLong( pc, 0 );
	struct HttpState *pHttpState = (struct HttpState *)GetNetworkLong( pc, 1 );
	DeleteLink( &server->clients, pc );
	if( pHttpState )
		DestroyHttpState( pHttpState );
}
static void CPROC AcceptHttpClient( PCLIENT pc_server, PCLIENT pc_new )
{
	struct HttpServer *server;
	while( !(server = (struct HttpServer *)GetNetworkLong( pc_server, 0 )) ) {
		Relinquish();
	}
	AddLink( &server->clients, pc_new );
	SetNetworkLong( pc_new, 0, (uintptr_t)server );
	SetNetworkReadComplete( pc_new, HandleRequest );
	SetNetworkCloseCallback( pc_new, RequestorClosed );
}
#ifndef NO_SSL
struct HttpServer *CreateHttpsServerEx( CTEXTSTR interface_address, CTEXTSTR TargetName, CTEXTSTR site, ProcessHttpRequest handle_request, uintptr_t psv ) {
	struct HttpServer *server = New( struct HttpServer );
	SOCKADDR *tmp;
	TEXTCHAR class_name[256];
	server->clients = NULL;
	server->handle_request = handle_request;
	server->psvRequest = psv;
	server->site = StrDup( site );
	tnprintf( class_name, sizeof( class_name ), WIDE( "SACK/Http/Methods/%s%s%s" )
		, TargetName ? TargetName : WIDE( "" )
		, (TargetName && site) ? WIDE( "/" ) : WIDE( "" )
		, site ? site : WIDE( "" ) );
	//lprintf( "Server root = %s", class_name );
	server->methods = GetClassRoot( class_name );
	NetworkStart();
	server->server = OpenTCPListenerAddrEx( tmp = CreateSockAddress( interface_address ? interface_address : WIDE( "0.0.0.0" ), 80 )
		, AcceptHttpClient );
	SetNetworkLong( server->server, 0, (uintptr_t)server );
	ssl_BeginServer( server->server, NULL, 0, NULL, 0, NULL, 0 );
	ReleaseAddress( tmp );
	if( !server->server )
	{
		Release( server );
		return NULL;
	}
	return server;
}
#endif
struct HttpServer *CreateHttpServerEx( CTEXTSTR interface_address, CTEXTSTR TargetName, CTEXTSTR site, ProcessHttpRequest handle_request, uintptr_t psv )
{
	struct HttpServer *server = New( struct HttpServer );
	SOCKADDR *tmp;
	TEXTCHAR class_name[256];
	server->clients = NULL;
	server->handle_request = handle_request;
	server->psvRequest = psv;
	server->site = StrDup( site );
	tnprintf( class_name, sizeof( class_name ), WIDE( "SACK/Http/Methods/%s%s%s" )
			  , TargetName?TargetName:WIDE("")
			  , ( TargetName && site )?WIDE( "/" ):WIDE( "" )
			  , site?site:WIDE( "" ) );
	//lprintf( "Server root = %s", class_name );
	server->methods = GetClassRoot( class_name );
	NetworkStart();
	server->server = OpenTCPListenerAddrEx( tmp = CreateSockAddress( interface_address?interface_address:WIDE( "0.0.0.0" ), 80 )
													  , AcceptHttpClient );
	ReleaseAddress( tmp );
	if( !server->server )
	{
		Release( server );
		return NULL;
	}
	SetNetworkLong( server->server, 0, (uintptr_t)server );
	return server;
}
PTEXT GetHTTPField( struct HttpState *pHttpState, CTEXTSTR name )
{
	INDEX idx;
	struct HttpField *field;
	LIST_FORALL( pHttpState->fields, idx, struct HttpField *, field )
	{
		if( TextLike( field->name, name ) )
			return field->value;
	}
	return NULL;
}
PLIST GetHttpHeaderFields( HTTPState pHttpState )
{
	return pHttpState->fields;
}
int GetHttpVersion( HTTPState pHttpState ) {
	return pHttpState->response_version;
}
int GetHttpResponseCode( HTTPState pHttpState ) {
	return pHttpState->numeric_code;
}
HTTP_NAMESPACE_END
#undef l
// not really, but close enough
#define HTTP_SOURCE
HTTP_NAMESPACE
struct default_port
{
	CTEXTSTR name;
	int number;
};
#define num_defaults (sizeof(default_ports)/sizeof(default_ports[0]))
static struct default_port default_ports[] = { { WIDE("http"), 80 }
															, { WIDE("ftp"), 21 }
															, { WIDE("ssh"), 22 }
															, { WIDE("telnet"), 23 }
															, { WIDE("https"), 443 }
															, { WIDE("ws"), 80 }
															, { WIDE("wss"), 443 }
															, { WIDE("file"), 0 }
															};
// TEXTSTR result = ConvertURIText( addr, length )
// SACK_ParseURL takes a URL string and gets the peices it can identify
// if a peice is not specified, the result will be NULL.
enum URLParseState
{
  // find ':', store characters in buffer
	PARSE_STATE_COLLECT_PROTOCOL = 0
  // find '/', eat /
	, PARSE_STATE_COLLECT_PROTOCOL_1
  // eat '/', eat /
	, PARSE_STATE_COLLECT_PROTOCOL_2
	, PARSE_STATE_COLLECT_USER
	, PARSE_STATE_COLLECT_PASSWORD
	, PARSE_STATE_COLLECT_ADDRESS
	, PARSE_STATE_COLLECT_PORT
	, PARSE_STATE_COLLECT_RESOURCE_PATH
	, PARSE_STATE_COLLECT_RESOURCE_NAME
	, PARSE_STATE_COLLECT_RESOURCE_EXTENSION
	, PARSE_STATE_COLLECT_RESOURCE_ANCHOR
	, PARSE_STATE_COLLECT_CGI_NAME
	, PARSE_STATE_COLLECT_CGI_VALUE
	, PARSE_STATE_COLLECT_IPV6
};
static void AppendBuffer( CTEXTSTR *output, CTEXTSTR seperator, CTEXTSTR input )
{
	CTEXTSTR tmpbuf = ConvertURIText( input, StrLen( input ) + 1 );
	TEXTSTR newout;
	if( *output )
	{
		size_t len;
		len = StrLen( *output ) + StrLen( tmpbuf ) + 1;
		if( seperator )
			len += StrLen( seperator );
		newout = NewArray( TEXTCHAR, len );
		tnprintf( newout, len, WIDE("%s%s%s"), (*output), seperator?seperator:WIDE(""), tmpbuf );
		Release( (POINTER)*output );
		(*output) = newout;
		Release( (POINTER)tmpbuf );
	}
	else
	{
		(*output) = tmpbuf;
	}
}
struct url_data * SACK_URLParse( const char *url )
{
	const char *_url = url;;
	struct url_data *data = New( struct url_data );
	struct url_cgi_data *cgi_data;
	TEXTRUNE ch;
	int outchar = 0;
	char * outbuf = NewArray( TEXTCHAR, StrLen( url ) + 1 );
	char *_outbuf = outbuf;
	int _state, state;
	char *newUrl = outbuf;
	int decode = 0;
	while( _url[0] ) {
		if( decode ) {
			ch *= 16;
			if( _url[0] >= '0' && _url[0] <= '9' )
				ch += _url[0] - '0';
			else if( _url[0] >= 'A' && _url[0] <= 'A' )
				ch += (_url[0] - 'A') + 10;
			else if( _url[0] >= '0' && _url[0] <= '9' )
				ch += (_url[0] - 'a' ) + 10;
			else {
				Deallocate( char *, outbuf );
				return NULL;
			}
			decode--;
			if( !decode )
				newUrl[0] = (char)decode;
			newUrl++;
		}
		else if( _url[0] == '%' ) {
			ch = 0;
			decode = 2;
		}
		else {
			newUrl[0] = _url[0];
			newUrl++;
		}
		_url++;
	}
	newUrl[0] = _url[0];
	_url = url = outbuf;
	_state = -1;
	state = PARSE_STATE_COLLECT_PROTOCOL;
	MemSet( data, 0, sizeof( struct url_data ) );
	while( ch = GetUtfChar(&url) )
	{
		int use_char;
		use_char = 0;
		switch( ch )
		{
		case '[':
			if( ( state == PARSE_STATE_COLLECT_ADDRESS )
				||( state == PARSE_STATE_COLLECT_USER ) ) {
				state = PARSE_STATE_COLLECT_IPV6;
				use_char = 1;
			}
			break;
		case ']':
			if( state == PARSE_STATE_COLLECT_IPV6 ) {
				// hit the colon between address and port
				outbuf[outchar++] = ch;
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->host, NULL, outbuf );
				state = PARSE_STATE_COLLECT_ADDRESS;
				continue;
			}
			break;
		case '&':
			if( state == PARSE_STATE_COLLECT_CGI_NAME )
			{
				cgi_data = New( struct url_cgi_data );
				cgi_data->name = NULL;
				cgi_data->value = NULL;
				AddLink( &data->cgi_parameters, cgi_data );
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &cgi_data->name, NULL, outbuf );
  // same state, just a blank cgi param
				state = PARSE_STATE_COLLECT_CGI_NAME;
			}
			if( state == PARSE_STATE_COLLECT_CGI_VALUE )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &cgi_data->value, NULL, outbuf );
				state = PARSE_STATE_COLLECT_CGI_NAME;
			}
			break;
		case '=':
			if( state == PARSE_STATE_COLLECT_CGI_NAME )
			{
				cgi_data = New( struct url_cgi_data );
				cgi_data->name = NULL;
				cgi_data->value = NULL;
				AddLink( &data->cgi_parameters, cgi_data );
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &cgi_data->name, NULL, outbuf );
				state = PARSE_STATE_COLLECT_CGI_VALUE;
			}
			break;
		case '?':
			if( state == PARSE_STATE_COLLECT_RESOURCE_EXTENSION )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_extension, NULL, outbuf );
				state = PARSE_STATE_COLLECT_CGI_NAME;
				continue;
			}
			if( state == PARSE_STATE_COLLECT_RESOURCE_NAME )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_file, NULL, outbuf );
				state = PARSE_STATE_COLLECT_CGI_NAME;
			}
			if( state == PARSE_STATE_COLLECT_RESOURCE_ANCHOR )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_anchor, NULL, outbuf );
				state = PARSE_STATE_COLLECT_CGI_NAME;
			}
			break;
		case '#':
			if( state == PARSE_STATE_COLLECT_RESOURCE_EXTENSION )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_extension, NULL, outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_ANCHOR;
			}
			else if( ( state == PARSE_STATE_COLLECT_RESOURCE_NAME )
				|| ( state == PARSE_STATE_COLLECT_RESOURCE_PATH ) )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_file, NULL, outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_ANCHOR;
			}
			break;
		case '.':
			// I just want to process the '.' when finding the extension.
			// just because we will always want to know it for other reasons later
			if( state == PARSE_STATE_COLLECT_RESOURCE_PATH
				|| state == PARSE_STATE_COLLECT_RESOURCE_NAME )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_file, NULL, outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_EXTENSION;
			}
			else
				use_char = 1;
			break;
		case '/':
			if( state == PARSE_STATE_COLLECT_PROTOCOL_1 )
			{
				if( outchar > 0 )
					lprintf( WIDE("Characters between protocol ':' and first slash") );
				state = PARSE_STATE_COLLECT_PROTOCOL_2;
			}
			else if( state == PARSE_STATE_COLLECT_PROTOCOL_2 )
			{
				if( outchar > 0 )
					lprintf( WIDE("Characters between protocol first and second slash") );
				state = PARSE_STATE_COLLECT_USER;
			}
			else if( state == PARSE_STATE_COLLECT_USER )
			{
				// what was collected was really
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->host, NULL, outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_PATH;
			}
			else if( state == PARSE_STATE_COLLECT_PASSWORD )
			{
				// what was collected was really the ip:port not user:password
				data->host = data->user;
				data->user = NULL;
				outbuf[outchar] = 0;
				outchar = 0;
				// should validate port is in numeric.
				data->port = (int)IntCreateFromText( outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_PATH;
			}
			else if( state == PARSE_STATE_COLLECT_ADDRESS )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->host, NULL, outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_PATH;
			}
			else if( state == PARSE_STATE_COLLECT_PORT )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				data->port = (int)IntCreateFromText( outbuf );
				//AppendBuffer( &data->port, NULL, outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_PATH;
			}
			else if( state == PARSE_STATE_COLLECT_RESOURCE_PATH )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_path, WIDE("/"), outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_NAME;
			}
			else if( state == PARSE_STATE_COLLECT_RESOURCE_NAME )
			{
				// this isn't really the name, it's another part of the resource path
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_path, WIDE("/"), outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_NAME;
			}
			break;
		case '@':
  // hit the colon between user and password
			if( state == PARSE_STATE_COLLECT_USER )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->user, NULL, outbuf );
				state = PARSE_STATE_COLLECT_ADDRESS;
			}
			if( state == PARSE_STATE_COLLECT_PASSWORD )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->password, NULL, outbuf );
				state = PARSE_STATE_COLLECT_ADDRESS;
			}
			break;
		case ':':
			if( state == PARSE_STATE_COLLECT_PROTOCOL )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->protocol, NULL, outbuf );
				{
					size_t n;
					for( n = 0; n < num_defaults; n++ )
					{
						if( strcmp( outbuf, default_ports[n].name ) == 0 )
						{
							data->default_port = default_ports[n].number;
						}
					}
				}
				state = PARSE_STATE_COLLECT_PROTOCOL_1;
				continue;
			}
  // hit the colon between user and password
			else if( state == PARSE_STATE_COLLECT_USER )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->user, NULL, outbuf );
				state = PARSE_STATE_COLLECT_PASSWORD;
				continue;
			}
  // hit the colon between address and port
			else if( state == PARSE_STATE_COLLECT_IPV6 )
			{
				use_char = 1;
			}
  // hit the colon between address and port
			else if( state == PARSE_STATE_COLLECT_ADDRESS )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->host, NULL, outbuf );
				state = PARSE_STATE_COLLECT_PORT;
				continue;
			}
			else
			{
 // error
				;
			}
			break;
		default:
			switch( state )
			{
			case PARSE_STATE_COLLECT_PROTOCOL_1:
				// the thing after the ':' was not a '/', so this isn't the protocol.
				break;
			case PARSE_STATE_COLLECT_PROTOCOL_2:
				break;
			default:
				use_char = 1;
			}
			break;
		}
		if( use_char )
			outchar += ConvertToUTF8( outbuf + outchar, ch );
		else
		{
			if( _state == state
  // after starting the path, look for fliename, if the extension or other is not found
				&& ( state != PARSE_STATE_COLLECT_RESOURCE_NAME )
 // blank cgi names go & to & and stay in the same state
				&& ( state != PARSE_STATE_COLLECT_CGI_NAME )
				)
				lprintf( WIDE("Dropping character (%d) '%c' in %s"), url - _outbuf, ch, _outbuf );
		}
		_state = state;
	}
	switch( state )
	{
	// this means user name, but if we hit the end of the buffer, it's the address
	case PARSE_STATE_COLLECT_USER:
		outbuf[outchar] = 0;
		outchar = 0;
		AppendBuffer( &data->host, NULL, outbuf );
		break;
	// this is the first colon, but no @ found, but end of buffer name is host and this is port.
	case PARSE_STATE_COLLECT_PASSWORD:
		data->host = data->user;
		data->user = NULL;
		outbuf[outchar] = 0;
		outchar = 0;
		data->port = (int)IntCreateFromText( outbuf );
		//AppendBuffer( &data->port, NULL, outbuf );
		break;
	case PARSE_STATE_COLLECT_CGI_NAME:
		cgi_data = New( struct url_cgi_data );
		cgi_data->name = NULL;
		cgi_data->value = NULL;
		AddLink( &data->cgi_parameters, cgi_data );
		outbuf[outchar] = 0;
		outchar = 0;
		AppendBuffer( &cgi_data->name, NULL, outbuf );
		break;
	case PARSE_STATE_COLLECT_CGI_VALUE:
		outbuf[outchar] = 0;
		outchar = 0;
		AppendBuffer( &cgi_data->value, NULL, outbuf );
		break;
	case PARSE_STATE_COLLECT_RESOURCE_PATH:
		outbuf[outchar] = 0;
		outchar = 0;
		AppendBuffer( &data->resource_file, NULL, outbuf );
		// this would be one word, no slashes, collecting a path . this is resource name
		break;
	default:
		if( outchar )
		{
			if( state == PARSE_STATE_COLLECT_RESOURCE_NAME )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_path, WIDE("/"), outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_NAME;
			}
			else
			{
				outbuf[outchar] = 0;
				lprintf( WIDE("Unused output: state %d [%s]"), state, outbuf );
			}
		}
		break;
	}
	Release( outbuf );
	return data;
}
char *SACK_BuildURL( struct url_data *data )
{
	PVARTEXT pvt = VarTextCreate();
	CTEXTSTR tmp = NULL;
	CTEXTSTR tmp2 = NULL;
	if( data->protocol )
		vtprintf( pvt, WIDE("%s://"), tmp = ConvertTextURI( data->protocol, StrLen( data->protocol ), 0 ) );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	// must be a user to use the password, setting just a password is an error really
	if( data->user )
		vtprintf( pvt, WIDE("%s%s%s@")
				  , tmp = ConvertTextURI( data->user, StrLen( data->user ), 0 )
				  , data->password?WIDE(":"):WIDE("")
				  , data->password?(tmp2 = ConvertTextURI( data->password, StrLen( data->password ), 0 )):WIDE("") );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( tmp2 )
	{
		Release( (POINTER)tmp2 );
		tmp2 = NULL;
	}
	if( data->host )
		vtprintf( pvt, WIDE("%s")
				  , tmp = ConvertTextURI( data->host, StrLen( data->host ), 0 ) );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( data->port )
		vtprintf( pvt, WIDE(":%d"), data->port );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( data->resource_path )
		vtprintf( pvt, WIDE("/%s")
				  , tmp = ConvertTextURI( data->resource_path, StrLen( data->resource_path), 1 ) );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( data->resource_file )
		vtprintf( pvt, WIDE("/%s")
				  , tmp = ConvertTextURI( data->resource_file, StrLen( data->resource_file), 0 ) );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( data->resource_extension )
		vtprintf( pvt, WIDE(".%s")
				  , tmp = ConvertTextURI( data->resource_extension, StrLen( data->resource_extension), 0 ) );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( data->resource_anchor )
		vtprintf( pvt, WIDE("#%s")
				  , tmp = ConvertTextURI( data->resource_anchor, StrLen( data->resource_anchor), 0 ) );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( data->cgi_parameters )
	{
		int first = 1;
		INDEX idx;
		struct url_cgi_data *cgi_data;
		LIST_FORALL( data->cgi_parameters, idx, struct url_cgi_data *, cgi_data )
		{
			if( cgi_data->value )
				vtprintf( pvt, WIDE("%s%s=%s"), first?WIDE("?"):WIDE("&"), cgi_data->name, cgi_data->value );
			else
				vtprintf( pvt, WIDE("%s%s"), first?WIDE("?"):WIDE("&"), cgi_data->name );
			first = 0;
		}
	}
	{
		PTEXT text_result = VarTextGet( pvt );
		char *result = StrDup( GetText( text_result ) );
		return result;
	}
}
void SACK_ReleaseURL( struct url_data *data )
{
	struct url_cgi_data *cgi_data;
	INDEX idx;
	LIST_FORALL( data->cgi_parameters, idx, struct url_cgi_data *, cgi_data )
	{
		Release( (POINTER)cgi_data->name );
		Release( (POINTER)cgi_data->value );
	}
	DeleteList( &data->cgi_parameters );
	Release( (POINTER)data->protocol );
	Release( (POINTER)data->user );
	Release( (POINTER)data->password );
	Release( (POINTER)data->host );
	Release( (POINTER)data->resource_path );
	Release( (POINTER)data->resource_file );
	Release( (POINTER)data->resource_extension );
	Release( (POINTER)data->resource_anchor );
	Release( data );
}
HTTP_NAMESPACE_END
///////////////////////////////////////////////////////////////////////////
//
// Filename    -  Network.C
//
// Description -  Network services for Communications Client
//
// Author      -  James Buckeyne
//
// Create Date -  Before now.
// Conversion update for Linux GLIBC 2.1 9/26/2000
//
///////////////////////////////////////////////////////////////////////////
//
//  DEBUG FLAGS IN netstruc.h
//
#define FIX_RELEASE_COM_COLLISION
#define NO_UNICODE_C
#define MAIN_PROGRAM
 // critical section
//#include "../contrib/MatrixSSL/3.7.1/matrixssl/matrixsslApi.h"
// debugging flag for socket creation/closing
//#define LOG_SOCKET_CREATION
// there were some messages regarding the close sequence of sockets
// they were left open... so developers might track why sockets were closing...
// these should be probably be re-enabled and be controlled with a runtime option flag.
//#define LOG_DEBUG_CLOSING
// started using this symbol more in the later days of disabling logging...
//#define VERBOSE_DEBUG
//#define LOG_STARTUP_SHUTDOWN
// Define this symbol to use Log( ghLog, WIDE("") ) to log pending
// write status...
//#define LOG_PENDING
// for windows - this will log all FD_XXXX notifications processed...
//#define LOG_NOTICES
//#define LOG_CLIENT_LISTS
//#define LOG_NETWORK_LOCKING
/// for windows - this logs detailed info about the new threaded events
//#define LOG_NETWORK_EVENT_THREAD
//TODO: modify the client struct to contain the MAC addr
#ifndef __LINUX__
#define USE_WSA_EVENTS
#endif
#ifndef CLIENT_DEFINED
#define CLIENT_DEFINED
SACK_NETWORK_NAMESPACE
#define MAGIC_SOCKADDR_LENGTH ( sizeof(SOCKADDR_IN)< 256?256:sizeof( SOCKADDR_IN) )
#define IN_SOCKADDR_LENGTH sizeof(struct sockaddr_in)
#define IN6_SOCKADDR_LENGTH sizeof(struct sockaddr_in6)
// this might have to be like sock_addr_len_t
#define SOCKADDR_LENGTH(sa) ( (int)*(uintptr_t*)( ( (uintptr_t)(sa) ) - 2*sizeof(uintptr_t) ) )
#ifdef __MAC__
#  define SET_SOCKADDR_LENGTH(sa,size) ( ( ( *(uintptr_t*)( ( (uintptr_t)(sa) ) - 2*sizeof(uintptr_t) ) ) = size ), ( sa->sa_len = size ) )
#else
#  define SET_SOCKADDR_LENGTH(sa,size) ( ( *(uintptr_t*)( ( (uintptr_t)(sa) ) - 2*sizeof(uintptr_t) ) ) = size )
#endif
// used by the network thread dispatched network layer messages...
  // messages for UDP use this window Message
#define SOCKMSG_UDP (WM_USER+1)
  // Messages for TCP use this Window Message
#define SOCKMSG_TCP (WM_USER+2)
 // Message for Network layer shutdown.
#define SOCKMSG_CLOSE (WM_USER+3)
// not sure if this is used anywhere....
      // maximum length of a host's text name...
#define HOSTNAME_LEN 50
typedef struct PendingBuffer
{
                // number of bytes to be read yet
   size_t dwAvail;
                 // Number of bytes already read.
   size_t dwUsed;
             // number of bytes received on last read.
   size_t dwLastRead;
   struct {
    // is a stream request...
      int  bStream:1;
 // lpBuffer was malloced...
      int  bDynBuffer:1;
	}s;
	union {
              // Buffer Pointer.
		CPOINTER c;
		POINTER p;
	} buffer;
 // Next Pending Message to be handled
   struct PendingBuffer *lpNext;
}PendingBuffer;
enum NetworkConnectionFlags {
	CF_UDP               = 0x00000001
	// no flag... is NOT UDP....
	, CF_TCP             = 0x00000000
	, CF_LISTEN          = 0x00000002
	// some write is left hanging to output
	, CF_WRITEPENDING    = 0x00000004
	// set if buffers have been set by a read
	, CF_READPENDING     = 0x00000008
	// set if next read to pend should recv also
	, CF_READREADY       = 0x00000010
	// set if reading application is waiting in-line for result.
	, CF_READWAITING     = 0x00008000
	// set when FD_CONNECT is issued...
	, CF_CONNECTED       = 0x00000020
	, CF_CONNECTERROR    = 0x00000040
	, CF_CONNECTING      = 0x00000080
	, CF_CONNECT_WAITING = 0x00008000
	, CF_CONNECT_CLOSED  = 0x00100000
	, CF_TOCLOSE         = 0x00000100
	, CF_WRITEISPENDED   = 0x00000200
	, CF_CLOSING         = 0x00000400
	, CF_DRAINING        = 0x00000800
	// closed, handled everything except releasing the socket.
	, CF_CLOSED          = 0x00001000
	, CF_ACTIVE          = 0x00002000
	, CF_AVAILABLE       = 0x00004000
	, CF_CPPCONNECT      = 0x00010000
	// server/client is implied in usage....
	// much like Read, ReadEX are implied in TCP/UDP usage...
	//#define CF_CPPSERVERCONNECT 0x010000
	//#define CF_CPPCLIENTCONNECT 0x020000
	, CF_CPPREAD         = 0x00020000
	, CF_CPPCLOSE        = 0x00040000
	, CF_CPPWRITE        = 0x00080000
	, CF_CALLBACKTYPES   = 0x00010000
                        | 0x00020000
                        | 0x00040000
//(CF_CPPCONNECT | CF_CPPREAD | CF_CPPCLOSE | CF_CPPWRITE)
                        | 0x00080000
  //( CF_ACTIVE | CF_AVAILABLE | CF_CLOSED)
	, CF_STATEFLAGS      = 0x1000 | 0x2000 | 0x4000
	//, CF_WANTS_GLOBAL_LOCK = 0x10000000
	, CF_PROCESSING      = 0x20000000
};
#ifdef __cplusplus
#  ifndef DEFINE_ENUM_FLAG_OPERATORS
#    ifdef __GNUC__
// used as an approximation of std::underlying_type<T>
template <size_t S>
struct _ENUM_FLAG_INTEGER_FOR_SIZE;
template <>
struct _ENUM_FLAG_INTEGER_FOR_SIZE<1>
{
	typedef int8_t type;
};
template <>
struct _ENUM_FLAG_INTEGER_FOR_SIZE<2>
{
	typedef int16_t type;
};
template <>
struct _ENUM_FLAG_INTEGER_FOR_SIZE<4>
{
	typedef int32_t type;
};
template <class T>
struct _ENUM_FLAG_SIZED_INTEGER
{
	typedef typename _ENUM_FLAG_INTEGER_FOR_SIZE<sizeof( T )>::type type;
};
#    endif
#    define DEFINE_ENUM_FLAG_OPERATORS(ENUMTYPE)         extern "C++" {         inline ENUMTYPE operator | ( ENUMTYPE a, ENUMTYPE b ) { return ENUMTYPE( ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b) ); }         inline ENUMTYPE &operator |= ( ENUMTYPE &a, ENUMTYPE b ) { return (ENUMTYPE &)(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); }         inline ENUMTYPE operator & ( ENUMTYPE a, ENUMTYPE b ) { return ENUMTYPE( ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b) ); }         inline ENUMTYPE &operator &= ( ENUMTYPE &a, ENUMTYPE b ) { return (ENUMTYPE &)(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); }         inline ENUMTYPE operator ~ ( ENUMTYPE a ) { return ENUMTYPE( ~((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) ); }         inline ENUMTYPE operator ^ ( ENUMTYPE a, ENUMTYPE b ) { return ENUMTYPE( ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b) ); }         inline ENUMTYPE &operator ^= ( ENUMTYPE &a, ENUMTYPE b ) { return (ENUMTYPE &)(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); }         }
#  endif
DEFINE_ENUM_FLAG_OPERATORS( NetworkConnectionFlags )
#endif
struct peer_thread_info
{
	struct peer_thread_info *parent_peer;
	struct peer_thread_info *child_peer;
   // list of PCLIENT which are waiting on
	PLIST monitor_list;
 // list of HANDLE which is waited on
	PDATALIST event_list;
	PTHREAD thread;
#ifdef _WIN32
	WSAEVENT hThread;
	int nEvents;
	LOGICAL counting;
 // updated with count thread is waiting on
	int nWaitEvents;
#endif
#ifdef __LINUX__
#  ifdef __MAC__
	int kqueue;
   PDATALIST kevents;
#  else
	int epoll_fd;
#  endif
	uint32_t nEvents;
#endif
	struct {
		BIT_FIELD bProcessing : 1;
		BIT_FIELD bBuildingList : 1;
	} flags;
};
struct NetworkClient
{
  //Dest Address
	SOCKADDR *saClient;
  //Local Address of this port ...
	SOCKADDR *saSource;
 // use this for UDP recvfrom
	SOCKADDR *saLastClient;
	uint8_t     hwClient[6];
	uint8_t     hwSource[6];
	//  ServeUDP( WIDE("SourceIP"), SourcePort );
	//		 saSource w/ no Dest - read is a connect...
	//  ConnectUDP( WIDE("DestIP"), DestPort );
	//     saClient is DestIP
	//		saSource and implied source...
	//     USE TCP to locate MY Address?
	//     bind(UDP) results in?
	//     connect(UDP) results in?
	SOCKET      Socket;
 // okay keep both...
	SOCKET      SocketBroadcast;
	struct interfaceAddress* interfaceAddress;
 // CF_
	enum NetworkConnectionFlags  dwFlags;
	uintptr_t        *lpUserData;
	union {
 // new incoming client.
		void (CPROC*ClientConnected)( struct NetworkClient *old, struct NetworkClient *newclient );
		void (CPROC*ThisConnected)(struct NetworkClient *me, int nStatus );
 // new incoming client.
		void (CPROC*CPPClientConnected)( uintptr_t psv, struct NetworkClient *newclient );
		void (CPROC*CPPThisConnected)( uintptr_t psv, int nStatus );
	}connect;
	uintptr_t psvConnect;
	union {
		void (CPROC*CloseCallback)(struct NetworkClient *);
		void (CPROC*CPPCloseCallback)(uintptr_t psv);
	} close;
	uintptr_t psvClose;
	union {
		cReadComplete ReadComplete;
		cppReadComplete CPPReadComplete;
		cReadCompleteEx ReadCompleteEx;
		cppReadCompleteEx CPPReadCompleteEx;
	}read;
	uintptr_t psvRead;
	union {
		void (CPROC*WriteComplete)( struct NetworkClient * );
		void (CPROC*CPPWriteComplete)( uintptr_t psv );
	}write;
	uintptr_t psvWrite;
 // set during bWriteComplete Notify...
	LOGICAL        bWriteComplete;
    // byte sink functions.... JAB:980202
	LOGICAL        bDraining;
  // length does not matter - read until one empty read.
	LOGICAL        bDrainExact;
	size_t         nDrainLength;
#if defined( USE_WSA_EVENTS )
	WSAEVENT event;
#endif
    // per client lock.
	CRITICALSECTION csLockRead;
   // per client lock.
	CRITICALSECTION csLockWrite;
 // Thread which is waiting for a result...
	PTHREAD pWaiting;
 // current incoming buffer
	PendingBuffer RecvPending, FirstWritePending;
 // outgoing buffers
	PendingBuffer *lpFirstPending,*lpLastPending;
 // GetTickCount() of last event...
	uint32_t    LastEvent;
	DeclareLink( struct NetworkClient );
 // listeners opened with port only have two connections, one IPV4 one IPV6
	PCLIENT pcOther;
	struct network_client_flags {
		BIT_FIELD bAddedToEvents : 1;
		BIT_FIELD bRemoveFromEvents : 1;
		BIT_FIELD bSecure : 1;
		BIT_FIELD bAllowDowngrade : 1;
	} flags;
	// this is set to what the thread that's waiting for this event is.
	struct peer_thread_info *this_thread;
	int tcp_delay_count;
	struct ssl_session *ssl_session;
};
typedef struct NetworkClient CLIENT;
#ifdef MAIN_PROGRAM
#define LOCATION
#else
#define LOCATION extern
#endif
//LOCATION CRITICALSECTION csNetwork;
#define MAX_NETCLIENTS  globalNetworkData.nMaxClients
typedef struct client_slab_tag {
	uint32_t count;
	uintptr_t* pUserData;
	CLIENT client[1];
} CLIENT_SLAB, *PCLIENT_SLAB;
// global network data goes here...
LOCATION struct network_global_data{
	uint32_t     nMaxClients;
     // number of longs.
	int     nUserData;
	//uint8_t*     pUserData;
	PLIST   ClientSlabs;
	LOGICAL bLog;
	LOGICAL bQuit;
 // list of all threads - needed because of limit of 64 sockets per multiplewait
	PLIST   pThreads;
	PCLIENT AvailableClients;
	PCLIENT ActiveClients;
	PCLIENT ClosedClients;
	CRITICALSECTION csNetwork;
	uint32_t uNetworkPauseTimer;
	uint32_t uPendingTimer;
#ifndef __LINUX__
	HWND ghWndNetwork;
#endif
	CTEXTSTR system_name;
#ifdef WIN32
	int nProtos;
	WSAPROTOCOL_INFOW *pProtos;
	INDEX tcp_protocol;
	INDEX udp_protocol;
	INDEX tcp_protocolv6;
	INDEX udp_protocolv6;
#endif
#if defined( USE_WSA_EVENTS )
   HANDLE hMonitorThreadControlEvent;
  // shorter list of new sockets to monitor than the full list
   PLINKQUEUE client_schedule;
#endif
	uint32_t dwReadTimeout;
	uint32_t dwConnectTimeout;
	PLIST addresses;
	struct {
		BIT_FIELD bLogNotices : 1;
		BIT_FIELD bShortLogReceivedData : 1;
		BIT_FIELD bLogReceivedData : 1;
		BIT_FIELD bLogSentData : 1;
		BIT_FIELD bThreadInitComplete : 1;
		BIT_FIELD bThreadExit : 1;
		BIT_FIELD bNetworkReady : 1;
		BIT_FIELD bThreadInitOkay : 1;
		BIT_FIELD bLogProtocols : 1;
	} flags;
 // how many peer threads do we have
	int nPeers;
	struct peer_thread_info *root_thread;
#if !defined( USE_WSA_EVENTS ) && defined( WIN32 )
	WNDCLASS wc;
#endif
}
 // aka 'globalNetworkData'
*global_network_data;
#define globalNetworkData (*global_network_data)
#ifdef _WIN32
#ifndef errno
#define errno WSAGetLastError()
#endif
#else
#endif
//---------------------------------------------------------------------
// routines exported from the core for use in external modules
PCLIENT GetFreeNetworkClientEx( DBG_VOIDPASS );
#define GetFreeNetworkClient() GetFreeNetworkClientEx( DBG_VOIDSRC )
_UDP_NAMESPACE
int FinishUDPRead( PCLIENT pc, int broadcastEvent );
_UDP_NAMESPACE_END
#ifdef WIN32
	// errors started arrising because of faulty driver stacks.
	// spontaneous 10106 errors in socket require migration to winsock2.
   // socket is opened specifically by protocol descriptor...
SOCKET OpenSocket( LOGICAL v4, LOGICAL bStream, LOGICAL bRaw, int another_offset );
int SystemCheck( void );
#endif
// internal functions
const char * GetAddrName( SOCKADDR *addr );
void TerminateClosedClientEx( PCLIENT pc DBG_PASS );
#define TerminateClosedClient(pc) TerminateClosedClientEx(pc DBG_SRC)
void InternalRemoveClientExx(PCLIENT lpClient, LOGICAL bBlockNofity, LOGICAL bLinger DBG_PASS );
#define InternalRemoveClientEx(c,b,l) InternalRemoveClientExx(c,b,l DBG_SRC)
#define InternalRemoveClient(c) InternalRemoveClientEx(c, FALSE, FALSE )
struct peer_thread_info *IsNetworkThread( void );
SOCKADDR *AllocAddrEx( DBG_VOIDPASS );
#define AllocAddr() AllocAddrEx( DBG_VOIDSRC )
PCLIENT AddActive( PCLIENT pClient );
void RemoveThreadEvent( PCLIENT pc );
void AddThreadEvent( PCLIENT pc, int broadcast );
#define IsValid(S)   ((S)!=INVALID_SOCKET)
#define IsInvalid(S) ((S)==INVALID_SOCKET)
#define CLIENT_DEFINED
SACK_NETWORK_NAMESPACE_END
#endif
//#define DO_LOGGING // override no _DEBUG def to do loggings...
//#define NO_LOGGING // force neverlog....
#ifdef __LINUX__
#endif
//for GetMacAddress
#ifdef __LINUX__
//#include <sys/timeb.h>
//*******************8
#include <sys/ioctl.h>
#include <net/if_arp.h>
#ifndef __ANDROID__
#include <ifaddrs.h>
#else
/* from https://github.com/morristech/android-ifaddrs/blob/master/ifaddrs.h  2017/25/12 */
/*
 * Copyright (c) 1995, 1999
 *	Berkeley Software Design, Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * THIS SOFTWARE IS PROVIDED BY Berkeley Software Design, Inc. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Berkeley Software Design, Inc. BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	BSDI ifaddrs.h,v 2.5 2000/02/23 14:51:59 dab Exp
 */
#ifndef	_IFADDRS_H_
#define	_IFADDRS_H_
struct ifaddrs {
	struct ifaddrs  *ifa_next;
	char		*ifa_name;
	unsigned int	 ifa_flags;
	struct sockaddr	*ifa_addr;
	struct sockaddr	*ifa_netmask;
	struct sockaddr	*ifa_dstaddr;
	void		*ifa_data;
};
/*
 * This may have been defined in <net/if.h>.  Note that if <net/if.h> is
 * to be included it must be included before this header file.
 */
#ifndef	ifa_broadaddr
#define	ifa_broadaddr	ifa_dstaddr
#endif
#include <sys/cdefs.h>
__BEGIN_DECLS
extern int getifaddrs(struct ifaddrs **ifap);
extern void freeifaddrs(struct ifaddrs *ifa);
__END_DECLS
#endif
#define EPOLLRDHUP EPOLLHUP
#define EPOLL_CLOEXEC 0
#endif
#ifdef __MAC__
#include <sys/event.h>
#else
#include <sys/epoll.h>
#endif
//*******************8
#endif
#ifdef WIN32
#ifdef __CYGWIN__
#include <mingw/tchar.h>
#else
#endif
#include <wincrypt.h>
#include <iphlpapi.h>
#endif
SACK_NETWORK_NAMESPACE
PRELOAD( InitNetworkGlobalOptions )
{
#ifdef __LINUX__
	signal(SIGPIPE, SIG_IGN);
#endif
#ifndef __NO_OPTIONS__
	globalNetworkData.flags.bLogProtocols = SACK_GetProfileIntEx( WIDE("SACK"), WIDE( "Network/Log Protocols" ), 0, TRUE );
	globalNetworkData.flags.bShortLogReceivedData = SACK_GetProfileIntEx( WIDE( "SACK" ), WIDE( "Network/Log Network Received Data(64 byte max)" ), 0, TRUE );
	globalNetworkData.flags.bLogReceivedData = SACK_GetProfileIntEx( WIDE( "SACK" ), WIDE( "Network/Log Network Received Data" ), 0, TRUE );
	globalNetworkData.flags.bLogSentData = SACK_GetProfileIntEx( WIDE( "SACK" ), WIDE( "Network/Log Network Sent Data" ), globalNetworkData.flags.bLogReceivedData, TRUE );
#  ifdef LOG_NOTICES
	globalNetworkData.flags.bLogNotices = SACK_GetProfileIntEx( WIDE( "SACK" ), WIDE( "Network/Log Network Notifications" ), 0, TRUE );
#  endif
	globalNetworkData.dwReadTimeout = SACK_GetProfileIntEx( WIDE( "SACK" ), WIDE( "Network/Read wait timeout" ), 5000, TRUE );
	globalNetworkData.dwConnectTimeout = SACK_GetProfileIntEx( WIDE( "SACK" ), WIDE( "Network/Connect timeout" ), 10000, TRUE );
#else
	globalNetworkData.flags.bLogNotices = 0;
	globalNetworkData.dwReadTimeout = 5000;
	globalNetworkData.dwConnectTimeout = 10000;
#endif
}
static void LowLevelNetworkInit( void )
{
	if( !global_network_data ) {
		SimpleRegisterAndCreateGlobal( global_network_data );
		InitializeCriticalSec( &globalNetworkData.csNetwork );
	}
}
PRIORITY_PRELOAD( InitNetworkGlobal, CONFIG_SCRIPT_PRELOAD_PRIORITY - 1 )
{
	LowLevelNetworkInit();
	if( !globalNetworkData.system_name )
	{
		globalNetworkData.system_name = WIDE("no.network");
	}
}
//----------------------------------------------------------------------------
// forward declaration for the window proc...
_TCP_NAMESPACE
void AcceptClient(PCLIENT pc);
int TCPWriteEx(PCLIENT pc DBG_PASS);
#define TCPWrite(pc) TCPWriteEx(pc DBG_SRC)
int FinishPendingRead(PCLIENT lpClient DBG_PASS );
LOGICAL TCPDrainRead( PCLIENT pClient );
_TCP_NAMESPACE_END
//----------------------------------------------------------------------------
#ifndef __MAC__
#  define INCLUDE_MAC_SUPPORT
#endif
//int get_mac_addr (char *device, unsigned char *buffer)
NETWORK_PROC( int, GetMacAddress)(PCLIENT pc, uint8_t* buf, size_t *buflen )
{
#ifdef INCLUDE_MAC_SUPPORT
#  ifdef __LINUX__
#    ifdef __THIS_CODE_GETS_MY_MAC_ADDRESS___
	int fd;
	struct ifreq ifr;
	fd = socket(PF_UNIX, SOCK_DGRAM, 0);
	if (fd == -1)
	{
		lprintf(WIDE ("Unable to create socket for pclient: %p"), pc);
		return -1;
	}
	strcpy (ifr.ifr_name, GetNetworkLong(pc,GNL_IP));
	if (ioctl (fd, SIOCGIFFLAGS, &ifr) < 0)
	{
		close (fd);
		return -1;
	}
	if (ioctl (fd, SIOCGIFHWADDR, &ifr) < 0)
	{
		close (fd);
		return -1;
	}
	close (fd);
	memcpy (pc->hwClient, ifr.ifr_hwaddr.sa_data, 6);
	return 0;
#    endif
	   /* this code queries the arp table to figure out who the other side is */
	//int fd;
	struct arpreq arpr;
	struct ifconf ifc;
	MemSet( &arpr, 0, sizeof( arpr ) );
	lprintf( WIDE( "this is broken." ) );
	MemCpy( &arpr.arp_pa, pc->saClient, sizeof( SOCKADDR ) );
	arpr.arp_ha.sa_family = AF_INET;
	{
		char buf[256];
		ifc.ifc_len = sizeof( buf );
		ifc.ifc_buf = buf;
		ioctl( pc->Socket, SIOCGIFCONF, &ifc );
		{
			int i;
			struct ifreq *IFR;
			IFR = ifc.ifc_req;
			for( i = ifc.ifc_len / sizeof( struct ifreq); --i >=0; IFR++ )
			{
				printf( WIDE( "IF: %s\n" ), IFR->ifr_name );
				strcpy( arpr.arp_dev, WIDE( "eth0" ) );
			}
		}
	}
	DebugBreak();
	if( ioctl( pc->Socket, SIOCGARP, &arpr ) < 0 )
	{
		lprintf( WIDE( "Error of some sort ... %s" ), strerror( errno ) );
		DebugBreak();
	}
	return 0;
#  endif
#  ifdef WIN32
	HRESULT hr;
	ULONG   ulLen;
	// I don't understand this useless cast - from size_t to ULONG?
	// isn't that the same thing?
	ulLen = (ULONG)(*buflen);
	//needs ws2_32.lib and iphlpapi.lib in the linker.
	hr = SendARP ( (IPAddr)GetNetworkLong(pc,GNL_MYIP), (IPAddr)GetNetworkLong(pc,GNL_MYIP), (PULONG)buf, &ulLen);
	(*buflen) = ulLen;
//  The second parameter of SendARP is a PULONG, which is typedef'ed to a pointer to
//  an unsigned long.  The pc->hwClient is a pointer to an array of uint8_t (unsigned chars),
//  actually defined in netstruc.h as uint8_t hwClient[6]; Well, in the end, they are all
//  just addresses, whether they be address to information of eight bits in length, or
//  of (sizeof(unsigned)) in length.  Although this may, in the future, throw a warning.
	//hr = SendARP (GetNetworkLong(pc,GNL_IP), 0, (PULONG)pc->hwClient, &ulLen);
	//lprintf (WIDE("Return %08x, length %8d\n"), hr, ulLen);
	return hr == S_OK;
#  endif
#else
	return 0;
#endif
}
//int get_mac_addr (char *device, unsigned char *buffer)
NETWORK_PROC( PLIST, GetMacAddresses)( void )
{
#ifdef INCLUDE_MAC_SUPPORT
#ifdef __LINUX__
#ifdef __THIS_CODE_GETS_MY_MAC_ADDRESS___
	int fd;
	struct ifreq ifr;
	fd = socket(PF_UNIX, SOCK_DGRAM, 0);
	if (fd == -1)
	{
		lprintf(WIDE ("Unable to create socket for pclient: %p"), pc);
		return -1;
	}
	strcpy (ifr.ifr_name, GetNetworkLong(pc,GNL_IP));
	if (ioctl (fd, SIOCGIFFLAGS, &ifr) < 0)
	{
		close (fd);
		return -1;
	}
	if (ioctl (fd, SIOCGIFHWADDR, &ifr) < 0)
	{
		close (fd);
		return -1;
	}
	close (fd);
	memcpy (pc->hwClient, ifr.ifr_hwaddr.sa_data, 6);
	return 0;
#endif
	/* this code queries the arp table to figure out who the other side is */
	//int fd;
	struct arpreq arpr;
	MemSet( &arpr, 0, sizeof( arpr ) );
#if 0
	lprintf( WIDE( "this is broken." ) );
	MemCpy( &arpr.arp_pa, pc->saClient, sizeof( SOCKADDR ) );
	arpr.arp_ha.sa_family = AF_INET;
	{
		char buf[256];
		ifc.ifc_len = sizeof( buf );
		ifc.ifc_buf = buf;
		ioctl( pc->Socket, SIOCGIFCONF, &ifc );
		{
			int i;
			struct ifreq *IFR;
			IFR = ifc.ifc_req;
			for( i = ifc.ifc_len / sizeof( struct ifreq); --i >=0; IFR++ )
			{
				printf( WIDE( "IF: %s\n" ), IFR->ifr_name );
				strcpy( arpr.arp_dev, WIDE( "eth0" ) );
			}
		}
	}
	DebugBreak();
	if( ioctl( pc->Socket, SIOCGARP, &arpr ) < 0 )
	{
		lprintf( WIDE( "Error of some sort ... %s" ), strerror( errno ) );
		DebugBreak();
	}
#endif
	return 0;
#endif
#ifdef WIN32
	HRESULT hr;
	ULONG   ulLen;
	uint8_t hwClient[6];
	ulLen = 6;
	//needs ws2_32.lib and iphlpapi.lib in the linker.
	hr = SendARP ((IPAddr)GetNetworkLong(NULL,GNL_IP), 0x100007f, (PULONG)&hwClient, &ulLen);
//  The second parameter of SendARP is a PULONG, which is typedef'ed to a pointer to
//  an unsigned long.  The pc->hwClient is a pointer to an array of uint8_t (unsigned chars),
//  actually defined in netstruc.h as uint8_t hwClient[6]; Well, in the end, they are all
//  just addresses, whether they be address to information of eight bits in length, or
//  of (sizeof(unsigned)) in length.  Although this may, in the future, throw a warning.
	//hr = SendARP (GetNetworkLong(pc,GNL_IP), 0, (PULONG)pc->hwClient, &ulLen);
	lprintf (WIDE("Return %08x, length %8d\n"), hr, ulLen);
	return 0;
#endif
#else
	return 0;
#endif
}
//----------------------------------------------------------------------------
void DumpLists( void )
{
	int c = 0;
	PCLIENT pc;
	for( pc = globalNetworkData.AvailableClients; c < 50 && pc; pc = pc->next )
	{
		//lprintf( WIDE("Available %p"), pc );
		if( (*pc->me) != pc )
			DebugBreak();
		c++;
	}
	if( c > 50 )
	{
		lprintf( WIDE( "Overflow available clients." ) );
		//DebugBreak();
	}
	c = 0;
	for( pc = globalNetworkData.ActiveClients; c < 50 && pc; pc = pc->next )
	{
		//lprintf( WIDE( WIDE( "Active %p(%d)" ) ), pc, pc->Socket );
		if( (*pc->me) != pc )
			DebugBreak();
		c++;
	}
	if( c > 50 )
	{
		lprintf( WIDE( "Overflow active clients." ) );
		DebugBreak();
	}
	c = 0;
	for( pc = globalNetworkData.ClosedClients; c < 50 && pc; pc = pc->next )
	{
		//lprintf( WIDE( "Closed %p(%d)" ), pc, pc->Socket );
		if( (*pc->me) != pc )
			DebugBreak();
		c++;
	}
	if( c > 50 )
	{
		lprintf( WIDE( "Overflow closed clients." ) );
		DebugBreak();
	}
}
//----------------------------------------------------------------------------
LOGICAL IsAddressV6( SOCKADDR *addr )
{
	if( addr->sa_family == AF_INET6 && SOCKADDR_LENGTH( addr ) == 28 )
		return TRUE;
	return FALSE;
}
const char * GetAddrString( SOCKADDR *addr )
{
	static char buf[256];
	//lprintf( "addr family is: %d", addr->sa_family );
	if( addr->sa_family == AF_INET )
		snprintf( buf, 256, "%d.%d.%d.%d"
			, *(((unsigned char *)addr) + 4),
			*(((unsigned char *)addr) + 5),
			*(((unsigned char *)addr) + 6),
			*(((unsigned char *)addr) + 7) );
	else if( addr->sa_family == AF_INET6 )
	{
		int first0 = 8;
		int last0 = 0;
		int after0 = 0;
		int n;
		int ofs = 0;
		uint32_t peice;
		for( n = 0; n < 8; n++ ) {
			peice = (*(((unsigned short *)((unsigned char*)addr + 8 + (n * 2)))));
			if( peice ) {
				if( first0 < 8 )
					after0 = 1;
				if( !ofs ) {
					ofs += snprintf( buf + ofs, 256 - ofs, "%x", ntohs( peice ) );
				}
				else {
					//console.log( last0, n );
					if( last0 == 4 && first0 == 0 )
						if( peice == 0xFFFF ) {
							snprintf( buf, 256, "::ffff:%d.%d.%d.%d",
								(*((unsigned char*)addr + 20)),
								(*((unsigned char*)addr + 21)),
								(*((unsigned char*)addr + 22)),
								(*((unsigned char*)addr + 23)) );
							break;
						}
					ofs += snprintf( buf + ofs, 256 - ofs, ":%x", ntohs( peice ) );
				}
			}
			else {
				if( !after0 ) {
					if( first0 > n ) {
						first0 = n;
						ofs += snprintf( buf + ofs, 256 - ofs, ":" );
					}
					if( last0 < n )
						last0 = n;
				}
				if( last0 < n )
					ofs += snprintf( buf + ofs, 256 - ofs, ":%x", ntohs( peice ) );
			}
		}
		if( !after0 )
			ofs += snprintf( buf + ofs, 256 - ofs, ":" );
	}
	else
		snprintf( buf, 256, "unknown protocol" );
	return buf;
}
const char * GetAddrName( SOCKADDR *addr )
{
	char * tmp = ((char**)addr)[-1];
	if( !tmp )
	{
		const char *buf = GetAddrString( addr );
		((char**)addr)[-1] = strdup( buf );
	}
	return ((char**)addr)[-1];
}
void SetAddrName( SOCKADDR *addr, const char *name )
{
	((uintptr_t*)addr)[-1] = (uintptr_t)strdup( name );
}
//---------------------------------------------------------------------------
SOCKADDR *AllocAddrEx( DBG_VOIDPASS )
{
	SOCKADDR *lpsaAddr=(SOCKADDR*)AllocateEx( MAGIC_SOCKADDR_LENGTH + 2 * sizeof( uintptr_t ) DBG_RELAY );
	memset( lpsaAddr, 0, MAGIC_SOCKADDR_LENGTH );
	//initialize socket length to something identifiable?
	((uintptr_t*)lpsaAddr)[0] = 3;
 // string representation of address
	((uintptr_t*)lpsaAddr)[1] = 0;
	lpsaAddr = (SOCKADDR*)( ( (uintptr_t)lpsaAddr ) + sizeof(uintptr_t) * 2 );
	return lpsaAddr;
}
//----------------------------------------------------------------------------
PCLIENT GrabClientEx( PCLIENT pClient DBG_PASS )
#define GrabClient(pc) GrabClientEx( pc DBG_SRC )
{
	if( pClient )
	{
#ifdef LOG_CLIENT_LISTS
		_lprintf(DBG_RELAY)( WIDE( "grabbed client %p(%d)" ), pClient, pClient->Socket );
		lprintf( WIDE( "grabbed client %p Ac:%p(%p(%d)) Av:%p(%p(%d)) Cl:%p(%p(%d))" )
				 , pClient->me
					 , &globalNetworkData.ActiveClients, globalNetworkData.ActiveClients, globalNetworkData.ActiveClients?globalNetworkData.ActiveClients->Socket:0
					 , &globalNetworkData.AvailableClients, globalNetworkData.AvailableClients, globalNetworkData.AvailableClients?globalNetworkData.AvailableClients->Socket:0
					 , &globalNetworkData.ClosedClients, globalNetworkData.ClosedClients, globalNetworkData.ClosedClients?globalNetworkData.ClosedClients->Socket:0
				 );
		DumpLists();
#endif
		pClient->dwFlags &= ~CF_STATEFLAGS;
		if( pClient->dwFlags & CF_AVAILABLE )
			lprintf( "Grabbed. %p  %08x", pClient, pClient->dwFlags );
		pClient->LastEvent = GetTickCount();
		if( ( (*pClient->me) = pClient->next ) )
			pClient->next->me = pClient->me;
	}
	return pClient;
}
//----------------------------------------------------------------------------
static PCLIENT AddAvailable( PCLIENT pClient )
{
	if( pClient )
	{
#ifdef LOG_CLIENT_LISTS
		lprintf( WIDE( "Add Avail client %p(%d)" ), pClient, pClient->Socket );
		DumpLists();
#endif
		pClient->dwFlags |= CF_AVAILABLE;
		pClient->LastEvent = GetTickCount();
		pClient->me = &globalNetworkData.AvailableClients;
		if( ( pClient->next = globalNetworkData.AvailableClients ) )
			globalNetworkData.AvailableClients->me = &pClient->next;
		globalNetworkData.AvailableClients = pClient;
	}
	return pClient;
}
//----------------------------------------------------------------------------
// used externally by udp/tcp
PCLIENT AddActive( PCLIENT pClient )
{
	if( pClient )
	{
#ifdef LOG_CLIENT_LISTS
		lprintf( WIDE( "Add Active client %p(%d)" ), pClient, pClient->Socket );
		DumpLists();
#endif
		pClient->dwFlags |= CF_ACTIVE;
		pClient->LastEvent = GetTickCount();
		pClient->me = &globalNetworkData.ActiveClients;
		if( ( pClient->next = globalNetworkData.ActiveClients ) )
			globalNetworkData.ActiveClients->me = &pClient->next;
		globalNetworkData.ActiveClients = pClient;
	}
	return pClient;
}
//----------------------------------------------------------------------------
static PCLIENT AddClosed( PCLIENT pClient )
{
	if( pClient )
	{
#ifdef LOG_CLIENT_LISTS
		lprintf( WIDE( "Add Closed client %p(%d)" ), pClient, pClient->Socket );
		DumpLists();
#endif
		pClient->dwFlags |= CF_CLOSED;
		pClient->LastEvent = GetTickCount();
		pClient->me = &globalNetworkData.ClosedClients;
		if( ( pClient->next = globalNetworkData.ClosedClients ) )
			globalNetworkData.ClosedClients->me = &pClient->next;
		globalNetworkData.ClosedClients = pClient;
	}
	return pClient;
}
//----------------------------------------------------------------------------
static void ClearClient( PCLIENT pc DBG_PASS )
{
	uintptr_t* pbtemp;
	PCLIENT next;
	PCLIENT *me;
	CRITICALSECTION csr;
	CRITICALSECTION csw;
	// keep the closing flag until it's really been closed. (getfreeclient will try to nab it)
	enum NetworkConnectionFlags  dwFlags = pc->dwFlags & (CF_STATEFLAGS | CF_CLOSING | CF_CONNECT_WAITING | CF_CONNECT_CLOSED);
#ifdef VERBOSE_DEBUG
	lprintf( WIDE("CLEAR CLIENT!") );
#endif
	me = pc->me;
	next = pc->next;
	pbtemp = pc->lpUserData;
	csr = pc->csLockRead;
	csw = pc->csLockWrite;
	ReleaseAddress( pc->saClient );
	ReleaseAddress( pc->saSource );
#if _WIN32
	if( pc->event ) {
		if( globalNetworkData.flags.bLogNotices )
			_lprintf(DBG_RELAY)( "Closing network event:%p  %p", pc, pc->event );
		WSACloseEvent( pc->event );
	}
#endif
	// sets socket to 0 - so it's not quite == INVALID_SOCKET
#ifdef LOG_NETWORK_EVENT_THREAD
	if( globalNetworkData.flags.bLogNotices )
		_lprintf(DBG_RELAY)( WIDE( "Clear Client %p  %08x   %08x" ), pc, pc->dwFlags, dwFlags );
#endif
 // clear all information...
	MemSet( pc, 0, sizeof( CLIENT ) );
	// Socket is now 0; which for linux is a valid handle... which is what I get for events...
	pc->csLockRead = csr;
	pc->csLockWrite = csw;
	pc->lpUserData = pbtemp;
	if( pc->lpUserData )
		MemSet( pc->lpUserData, 0, globalNetworkData.nUserData * sizeof( uintptr_t ) );
	pc->next = next;
	pc->me = me;
	pc->dwFlags = dwFlags;
}
//----------------------------------------------------------------------------
static void NetworkGlobalLock( DBG_VOIDPASS ) {
	LOGICAL locked = FALSE;
	do {
#ifdef USE_NATIVE_CRITICAL_SECTION
		if( TryEnterCriticalSection( &globalNetworkData.csNetwork ) < 1 )
#else
		if( EnterCriticalSecNoWaitEx( &globalNetworkData.csNetwork, NULL DBG_RELAY ) < 1 )
#endif
		{
#ifdef LOG_NETWORK_LOCKING
			_lprintf( DBG_RELAY )(WIDE( "Failed enter global? %lld" ), globalNetworkData.csNetwork.dwThreadID );
#endif
			Relinquish();
		}
		else
			locked = TRUE;
#ifdef LOG_NETWORK_LOCKING
		_lprintf( DBG_RELAY )(WIDE( "Got global lock" ));
#endif
	} while( !locked );
}
void NetworkGloalUnlock( DBG_VOIDPASS ) {
#ifdef USE_NATIVE_CRITICAL_SECTION
	LeaveCriticalSection( &globalNetworkData.csNetwork );
#else
	LeaveCriticalSecEx( &globalNetworkData.csNetwork DBG_RELAY );
#endif
}
//----------------------------------------------------------------------------
void TerminateClosedClientEx( PCLIENT pc DBG_PASS )
{
#ifdef VERBOSE_DEBUG
	_lprintf(DBG_RELAY)( WIDE( "terminate client %p " ), pc );
#endif
	if( !pc )
		return;
	if( pc->dwFlags & CF_TOCLOSE ) {
#ifdef VERBOSE_DEBUG
		lprintf( "WAIT FOR CLOSE LATER... %x", pc->dwFlags );
#endif
		//return;
	}
	if( pc->dwFlags & CF_CLOSED )
	{
		PendingBuffer * lpNext;
		EnterCriticalSec( &globalNetworkData.csNetwork );
#ifdef VERBOSE_DEBUG
		lprintf( "REMOVED EVENT...." );
#endif
		RemoveThreadEvent( pc );
		//lprintf( WIDE( "Terminating closed client..." ) );
		if( IsValid( pc->Socket ) )
		{
#ifdef VERBOSE_DEBUG
			lprintf( "close soekcet." );
#endif
#if !defined( SHUT_WR ) && defined( _WIN32 )
#  define SHUT_WR SD_SEND
#endif
			shutdown( pc->Socket, SHUT_WR );
#if defined( _WIN32 )
#undef SHUT_WR
#endif
			closesocket( pc->Socket );
			while( pc->lpFirstPending )
			{
				lpNext = pc->lpFirstPending -> lpNext;
				if( pc->lpFirstPending->s.bDynBuffer )
					Deallocate( POINTER, pc->lpFirstPending->buffer.p );
				if( pc->lpFirstPending != &pc->FirstWritePending )
				{
#ifdef LOG_PENDING
					lprintf( WIDE(WIDE( "Data queued...Deleting in remove." )) );
#endif
					Deallocate( PendingBuffer*, pc->lpFirstPending);
				}
				else
				{
#ifdef LOG_PENDING
					lprintf( WIDE("Normal send queued...Deleting in remove.") );
#endif
				}
				if (!lpNext)
					pc->lpLastPending = NULL;
				pc->lpFirstPending = lpNext;
			}
		}
		ClearClient( pc DBG_RELAY );
		// this should move from globalNetworkData.close to globalNetworkData.available.
		AddAvailable( GrabClient( pc ) );
 // it's no longer closing.  (was set during the course of closure)
		pc->dwFlags &= ~CF_CLOSING;
		LeaveCriticalSec( &globalNetworkData.csNetwork );
		//NetworkUnlock( pc );
	}
#ifdef LOG_PENDING
	else
		lprintf( WIDE("Client's state was not CLOSED...") );
#endif
}
//----------------------------------------------------------------------------
#ifdef _WIN32
//----------------------------------------------------------------------------
static int NetworkStartup( void )
{
	static int attempt = 0;
	static int nStep = 0,
	          nError;
	static SOCKET sockMaster;
	static SOCKADDR remSin;
	switch( nStep )
	{
	case 0 :
		SystemCheck();
		nStep++;
		attempt = 0;
	case 1 :
		// Sit around, waiting for the network to start...
		//--------------------
		// sorry this is really really ugly to read!
		sockMaster = OpenSocket( TRUE, FALSE, FALSE, 0 );
		if( sockMaster == INVALID_SOCKET )
		{
			lprintf( WIDE( "Clever OpenSocket failed... fallback... and survey sez..." ) );
			//--------------------
			sockMaster = socket( AF_INET, SOCK_DGRAM, 0);
			//--------------------
		}
		//--------------------
		if( sockMaster == INVALID_SOCKET )
		{
			nError = WSAGetLastError();
			lprintf( WIDE( "Failed to create a socket - error is %ld" ), WSAGetLastError() );
 // provvider init fail )
			if( nError == 10106 )
			{
				if( ++attempt >= 30 ) return NetworkQuit();
				return -2;
			}
			if( nError == WSAENETDOWN )
			{
				if( ++attempt >= 30 ) return NetworkQuit();
				//else return NetworkPause(WIDE( "Socket is delaying..." ));
			}
 // reset...
			 nStep = 0;
			if( ++attempt >= 30 ) return NetworkQuit();
//NetworkQuit();
			return 1;
		}
		// Retrieve my IP address and UDP Port number
		remSin.sa_family=AF_INET;
		remSin.sa_data[0]=0;
		remSin.sa_data[1]=0;
		((SOCKADDR_IN*)&remSin)->sin_addr.s_addr=INADDR_ANY;
		nStep++;
		attempt = 0;
		// Fall into next state..............
	case 2 :
		// Associate an address with a socket. (bind)
		if( bind( sockMaster, (PSOCKADDR)&remSin, sizeof(remSin))
			 == SOCKET_ERROR )
		{
			if( WSAGetLastError() == WSAENETDOWN )
			{
				if( ++attempt >= 30 ) return NetworkQuit();
				//else return NetworkPause(WIDE( "Bind is Delaying" ));
			}
 // reset...
			nStep = 0;
			return NetworkQuit();
		}
		nStep++;
		attempt = 0;
		// Fall into next state..............
	case 3 :
		closesocket(sockMaster);
		sockMaster = INVALID_SOCKET;
 // reset...
		nStep = 0;
		break;
	}
	return 0;
}
//----------------------------------------------------------------------------
static void CPROC NetworkPauseTimer( uintptr_t psv )
{
	int nResult;
	nResult = NetworkStartup();
	if( nResult == 0 )
	{
		while( !globalNetworkData.uNetworkPauseTimer )
			Relinquish();
		RemoveTimer( globalNetworkData.uNetworkPauseTimer );
		globalNetworkData.flags.bNetworkReady = TRUE;
		globalNetworkData.flags.bThreadInitOkay = TRUE;
	}
	else if( nResult == -1 )
	{
		globalNetworkData.flags.bNetworkReady = TRUE;
		globalNetworkData.flags.bThreadInitOkay = FALSE;
		// exiting ... bad stuff happens
	}
	else if( nResult == -2 )
	{
		// delaying... okay....
	}
}
//----------------------------------------------------------------------------
static void HandleEvent( PCLIENT pClient )
{
	WSANETWORKEVENTS networkEvents;
	if( globalNetworkData.bQuit )
	{
		lprintf( WIDE( "Task is shutting down network... don't handle event." ) );
		return;
	}
	if( !pClient )
	{
		lprintf( WIDE( "How did a NULL client get here?!" ) );
		return;
	}
	pClient->dwFlags |= CF_PROCESSING;
#ifdef LOG_NETWORK_EVENT_THREAD
	//if( globalNetworkData.flags.bLogNotices )
	//	lprintf( WIDE( "Client event on %p" ), pClient );
#endif
	if( WSAEnumNetworkEvents( pClient->Socket, pClient->event, &networkEvents ) == ERROR_SUCCESS )
	{
		if( networkEvents.lNetworkEvents == 0 ) {
#ifdef LOG_NETWORK_EVENT_THREAD
			if( globalNetworkData.flags.bLogNotices )
				lprintf( WIDE( "zero events...%p %p %p" ), pClient, pClient->Socket, pClient->event );
#endif
			return;
		}
		{
			if( pClient->dwFlags & CF_UDP )
			{
				if( networkEvents.lNetworkEvents & FD_READ )
				{
#ifdef LOG_NOTICES
					if( globalNetworkData.flags.bLogNotices )
						lprintf( WIDE( "Got UDP FD_READ" ) );
#endif
					FinishUDPRead( pClient, 0 );
				}
			}
			else
			{
				THREAD_ID prior = 0;
#ifdef LOG_CLIENT_LISTS
				lprintf( WIDE( "client lists Ac:%p(%p(%d)) Av:%p(%p(%d)) Cl:%p(%p(%d))" )
						 , &globalNetworkData.ActiveClients, globalNetworkData.ActiveClients, globalNetworkData.ActiveClients?globalNetworkData.ActiveClients->Socket:0
						 , &globalNetworkData.AvailableClients, globalNetworkData.AvailableClients, globalNetworkData.AvailableClients?globalNetworkData.AvailableClients->Socket:0
						 , &globalNetworkData.ClosedClients, globalNetworkData.ClosedClients, globalNetworkData.ClosedClients?globalNetworkData.ClosedClients->Socket:0
						 );
#endif
#ifdef LOG_NETWORK_LOCKING
				lprintf( WIDE( "Handle Event left global" ) );
#endif
				// if an unknown socket issued a
				// notification - close it - unknown handling of unknown socket.
#ifdef LOG_NETWORK_EVENT_THREAD
				if( globalNetworkData.flags.bLogNotices )
					lprintf( WIDE( "events : %08x on %p" ), networkEvents.lNetworkEvents, pClient );
#endif
				if( networkEvents.lNetworkEvents & FD_CONNECT )
				{
					{
						uint16_t wError = networkEvents.iErrorCode[FD_CONNECT_BIT];
#ifdef LOG_NOTICES
						if( globalNetworkData.flags.bLogNotices )
							lprintf( WIDE("FD_CONNECT on %p"), pClient );
#endif
						if( !wError )
							pClient->dwFlags |= CF_CONNECTED;
						else
						{
#ifdef LOG_NOTICES
							if( globalNetworkData.flags.bLogNotices )
								lprintf( WIDE("Connect error: %d"), wError );
#endif
							pClient->dwFlags |= CF_CONNECTERROR;
						}
						if( !( pClient->dwFlags & CF_CONNECTERROR ) )
						{
							// since this is done before connecting is clear, tcpwrite
							// may make notice of previously queued data to
							// connection opening...
							//lprintf( WIDE("Sending any previously queued data.") );
							// with events, we get a FD_WRITE also... which calls tcpwrite.
							//TCPWrite( pClient );
						}
						pClient->dwFlags &= ~CF_CONNECTING;
						if( pClient->connect.ThisConnected )
						{
							if( !wError && !pClient->saSource ) {
#ifdef __LINUX__
								socklen_t
#else
								int
#endif
									nLen = MAGIC_SOCKADDR_LENGTH;
								if( !pClient->saSource )
									pClient->saSource = AllocAddr();
								if( getsockname( pClient->Socket, pClient->saSource, &nLen ) )
								{
									lprintf( WIDE( "getsockname errno = %d" ), errno );
								}
							}
#ifdef LOG_NOTICES
							if( globalNetworkData.flags.bLogNotices )
								lprintf( WIDE( "Post connect to application %p  error:%d" ), pClient, wError );
#endif
							if( pClient->dwFlags & CF_CPPCONNECT )
								pClient->connect.CPPThisConnected( pClient->psvConnect, wError );
							else
								pClient->connect.ThisConnected( pClient, wError );
						}
						//lprintf( WIDE("Returned from application connected callback") );
						// check to see if the read was queued before the connect
						// actually completed...
						if( (pClient->dwFlags & ( CF_ACTIVE | CF_CONNECTED )) ==
							( CF_ACTIVE | CF_CONNECTED ) )
						{
							if( pClient->read.ReadComplete )
								if( pClient->dwFlags & CF_CPPREAD )
									pClient->read.CPPReadComplete( pClient->psvRead, NULL, 0 );
								else
									pClient->read.ReadComplete( pClient, NULL, 0 );
						}
						if( pClient->pWaiting )
							WakeThread( pClient->pWaiting );
#ifdef LOG_NOTICES
						if( globalNetworkData.flags.bLogNotices )
							lprintf( WIDE( "FD_CONNECT Completed" ) );
#endif
						//lprintf( WIDE("Returned from application inital read complete.") );
					}
				}
				if( networkEvents.lNetworkEvents & FD_READ )
				{
					PCLIENT pcLock;
					while( !( pcLock = NetworkLockEx( pClient, 1 DBG_SRC ) ) ) {
						// done with events; inactive sockets can't have events
						if( !( pClient->dwFlags & CF_ACTIVE ) ) {
							pcLock = NULL;
							break;
						}
						Relinquish();
					}
#ifdef LOG_NOTICES
					//if( globalNetworkData.flags.bLogNotices )
					//	lprintf( WIDE( "FD_READ" ) );
#endif
					  if( ( pClient->dwFlags & CF_ACTIVE ) ) {
						if( pClient->bDraining )
						{
							TCPDrainRead( pClient );
						}
						else
						{
							// got a network event, and won't get another until recv is called.
							// mark that the socket has data, then the pend_read code will trigger the finishpendingread.
							if( FinishPendingRead( pClient DBG_SRC ) == 0 )
							{
								pClient->dwFlags |= CF_READREADY;
							}
							if( pClient->dwFlags & CF_TOCLOSE )
							{
								lprintf( WIDE( "Pending read failed - and wants to close." ) );
								//InternalRemoveClientEx( pc, TRUE, FALSE );
							}
						}
						NetworkUnlock( pClient, 1 );
					}
				}
				if( networkEvents.lNetworkEvents & FD_WRITE )
				{
					PCLIENT pcLock;
					while( !( pcLock = NetworkLockEx( pClient, 0 DBG_SRC ) ) ) {
						// done with events; inactive sockets can't have events
						if( !( pClient->dwFlags & CF_ACTIVE ) ) {
							pcLock = NULL;
							break;
						}
						Relinquish();
					}
					if( pClient->dwFlags & CF_ACTIVE ) {
#ifdef LOG_NOTICES
						//if( globalNetworkData.flags.bLogNotices )
						//	lprintf( WIDE("FD_Write") );
#endif
						// returns true while it wrote or there is data to write
						if( pClient->lpFirstPending )
							TCPWrite(pClient);
						if( !pClient->lpFirstPending ) {
							if( pClient->dwFlags & CF_TOCLOSE )
							{
								pClient->dwFlags &= ~CF_TOCLOSE;
								lprintf( WIDE( "Pending read failed - and wants to close." ) );
								InternalRemoveClientEx( pClient, FALSE, TRUE );
								TerminateClosedClient( pClient );
							}
						}
						NetworkUnlock( pClient, 0 );
					}
				}
				if( networkEvents.lNetworkEvents & FD_CLOSE )
				{
					if( !pClient->bDraining )
					{
						size_t bytes_read;
						// act of reading can result in a close...
						// there are things like IE which close and send
						// adn we might get the close notice at application level indicating there might still be data...
						while( ( bytes_read = FinishPendingRead( pClient DBG_SRC) ) > 0
 // try and read...
							&& bytes_read != (size_t)-1 );
						//if( pClient->dwFlags & CF_TOCLOSE )
						{
							//lprintf( "Pending read failed - reset connection. (well this is FD_CLOSE so yeah...??]" );
							//InternalRemoveClientEx( pc, TRUE, FALSE );
						}
					}
#ifdef LOG_NOTICES
					if( globalNetworkData.flags.bLogNotices )
						lprintf(WIDE( "FD_CLOSE... %p  %08x" ), pClient, pClient->dwFlags );
#endif
					if( pClient->dwFlags & CF_ACTIVE )
					{
						// might already be cleared and gone..
						InternalRemoveClientEx( pClient, FALSE, TRUE );
						TerminateClosedClient( pClient );
					}
					// section will be blank after termination...(correction, we keep the section state now)
 // it's no longer closing.  (was set during the course of closure)
					pClient->dwFlags &= ~CF_CLOSING;
				}
				if( networkEvents.lNetworkEvents & FD_ACCEPT )
				{
#ifdef LOG_NOTICES
					//if( globalNetworkData.flags.bLogNotices )
					//	lprintf( WIDE("FD_ACCEPT on %p"), pClient );
#endif
					AcceptClient(pClient);
					//NetworkUnlock( pClient, 1 );
				}
				//lprintf( WIDE("leaveing event handler...") );
				//lprintf( WIDE("Left event handler CS.") );
			}
		}
	}
	else
	{
		DWORD dwError = WSAGetLastError();
		if( dwError == 10038 )
		{
			// no longer a socket, probably in a closed or closing state.
		}
		else
			lprintf( WIDE( "Event enum failed... do what? close socket? %p %" _32f ), pClient, dwError );
	}
	pClient->dwFlags &= ~CF_PROCESSING;
}
 // if defined _WIN32
#endif
//----------------------------------------------------------------------------
void SetNetworkWriteComplete( PCLIENT pClient
                            , cWriteComplete WriteComplete )
{
	if( pClient && IsValid( pClient->Socket ) )
	{
		pClient->write.WriteComplete = WriteComplete;
	}
}
//----------------------------------------------------------------------------
void SetCPPNetworkWriteComplete( PCLIENT pClient
                               , cppWriteComplete WriteComplete
                               , uintptr_t psv)
{
	if( pClient && IsValid( pClient->Socket ) )
	{
		pClient->write.CPPWriteComplete = WriteComplete;
		pClient->psvWrite = psv;
		pClient->dwFlags |= CF_CPPWRITE;
	}
}
//----------------------------------------------------------------------------
void SetNetworkCloseCallback( PCLIENT pClient
                            , cCloseCallback CloseCallback )
{
	if( pClient && IsValid(pClient->Socket) )
	{
		pClient->close.CloseCallback = CloseCallback;
	}
}
//----------------------------------------------------------------------------
void SetCPPNetworkCloseCallback( PCLIENT pClient
                               , cppCloseCallback CloseCallback
                               , uintptr_t psv)
{
	if( pClient && IsValid(pClient->Socket) )
	{
		pClient->close.CPPCloseCallback = CloseCallback;
		pClient->psvClose = psv;
		pClient->dwFlags |= CF_CPPCLOSE;
	}
}
//----------------------------------------------------------------------------
void SetNetworkReadComplete( PCLIENT pClient
                           , cReadComplete pReadComplete )
{
	if( pClient && IsValid(pClient->Socket) )
	{
		pClient->read.ReadComplete = pReadComplete;
	}
}
//----------------------------------------------------------------------------
void SetCPPNetworkReadComplete( PCLIENT pClient
                              , cppReadComplete pReadComplete
                              , uintptr_t psv)
{
	if( pClient && IsValid(pClient->Socket) )
	{
		pClient->read.CPPReadComplete = pReadComplete;
		pClient->psvRead = psv;
		pClient->dwFlags |= CF_CPPREAD;
	}
}
//----------------------------------------------------------------------------
#if defined( _WIN32 )
//----------------------------------------------------------------------------
static uintptr_t CPROC NetworkThreadProc( PTHREAD thread );
void RemoveThreadEvent( PCLIENT pc ) {
	struct peer_thread_info *thread = pc->this_thread;
 // could be closed (accept, initial read, protocol causes close before ever completing getting scheduled)
	if( !thread ) return;
	// reduce peer wait count to 1.
#ifdef LOG_NETWORK_EVENT_THREAD
	lprintf( "Remove client %p from %p thread events...  proc:%d  ev:%d  wait:%d", pc, thread, thread->flags.bProcessing, thread->nEvents, thread->nWaitEvents );
#endif
	thread->counting = TRUE;
	thread->nEvents = 1;
	if( thread->thread != MakeThread() && !thread->flags.bProcessing )
		while( thread->nEvents != thread->nWaitEvents ) {
			if( !thread->flags.bProcessing )
			{
				// have to make sure threads reset to the new list.
				//lprintf( "have to wait for thread to be in wait state..." );
				WSASetEvent( thread->hThread );
				LeaveCriticalSec( &globalNetworkData.csNetwork );
				while( (thread->nWaitEvents > 1) || thread->flags.bProcessing )
					Relinquish();
				EnterCriticalSec( &globalNetworkData.csNetwork );
			}
			else
  // if it's processing, race it; build new list, count it.
				break;
			Relinquish();
		}
	{
		INDEX idx;
		INDEX c = 0;
		PCLIENT previous;
		PLIST newList = CreateList();
		SetLink( &newList, 65, 0 );
		//EmptyDataList( &thread->event_list );
		LIST_FORALL( thread->monitor_list, idx, PCLIENT, previous ) {
			if( previous != pc )
			{
				AddLink( &newList, previous );
				SetDataItem( &thread->event_list, c++, GetDataItem( &thread->event_list, idx ) );
			}
		}
		thread->event_list->Cnt = c;
		thread->nEvents = (int)c;
		thread->counting = FALSE;
		DeleteListEx( &thread->monitor_list DBG_SRC );
		thread->monitor_list = newList;
		pc->this_thread = NULL;
#ifdef LOG_NETWORK_EVENT_THREAD
		lprintf( "peer %p now has %d events", thread, thread->nEvents );
#endif
	}
  // don't bubble sort root thread
	if( thread->parent_peer )
		while( ( thread->nEvents < thread->parent_peer->nEvents ) && thread->parent_peer->parent_peer ) {
#ifdef LOG_NETWORK_EVENT_THREAD
			//lprintf( "swapping this with parent peer ... this events %d  parent %d", thread->nEvents, thread->parent_peer->nEvents );
#endif
			if( thread->child_peer )
				thread->child_peer->parent_peer = thread->parent_peer;
			thread->parent_peer->child_peer = thread->child_peer;
			struct peer_thread_info *tmp = thread->parent_peer;
			tmp->parent_peer->child_peer = thread;
			thread->parent_peer = tmp->parent_peer;
			tmp->parent_peer = thread;
			thread->child_peer = tmp;
		}
}
// unused parameter broadcsat on windows; not needed.
void AddThreadEvent( PCLIENT pc, int broadcsat )
{
	struct peer_thread_info *peer = globalNetworkData.root_thread;
	LOGICAL addPeer = FALSE;
#ifdef LOG_NOTICES
	if( globalNetworkData.flags.bLogNotices )
		lprintf( "Add thread event %p %p %08x", pc, pc->event, pc->dwFlags );
#endif
	for( ; peer; peer = peer->child_peer ) {
		if( !peer->child_peer ) {
#ifdef LOG_NOTICES
			if( globalNetworkData.flags.bLogNotices )
				lprintf( "On last peer..." );
#endif
			if( peer->nEvents > globalNetworkData.nPeers ) {
#ifdef LOG_NOTICES
				if( globalNetworkData.flags.bLogNotices )
					lprintf( "global peers is %d, this has %d", globalNetworkData.nPeers, peer->nEvents );
#endif
				addPeer = TRUE;
				break;
			}
			if( peer->nEvents >= 60 ) {
#ifdef LOG_NOTICES
				if( globalNetworkData.flags.bLogNotices )
					lprintf( "this has max events already....", globalNetworkData.nPeers, peer->nEvents );
#endif
				addPeer = TRUE;
				break;
			}
		}
		if( peer->nEvents < 60 ) {
// last thread.
			if( !peer->child_peer )
				break;
			if( peer->nEvents < peer->child_peer->nEvents ) {
#ifdef LOG_NOTICES
				//if( globalNetworkData.flags.bLogNotices )
				//	lprintf( "this event has fewer than the next thread's events %d  %d", peer->nEvents, peer->child_peer->nEvents );
#endif
				break;
			}
		}
	}
	if( addPeer ) {
#ifdef LOG_NOTICES
		if( globalNetworkData.flags.bLogNotices )
			lprintf( "Creating a new thread...." );
#endif
		AddLink( &globalNetworkData.pThreads, ThreadTo( NetworkThreadProc, (uintptr_t)peer ) );
		globalNetworkData.nPeers++;
		while( !peer->child_peer )
			Relinquish();
		if( globalNetworkData.root_thread != peer ) {
			// relink to be higher in list of peers so it's found earlier.
#ifdef LOG_NOTICES
			if( globalNetworkData.flags.bLogNotices )
				lprintf( "Relinking thread to be after root peer (no events, so it must be first)" );
#endif
			peer->child_peer->child_peer = globalNetworkData.root_thread->child_peer;
			globalNetworkData.root_thread->child_peer->parent_peer = peer->child_peer;
			globalNetworkData.root_thread->child_peer = peer->child_peer;
			peer->child_peer->parent_peer = globalNetworkData.root_thread;
			peer->child_peer = NULL;
			peer = globalNetworkData.root_thread->child_peer;
		}
		else
			peer = peer->child_peer;
	}
	// make sure to only add this handle when the first peer will also be added.
	// this means the list can be 61 and at this time no more.
	AddLink( &peer->monitor_list, pc );
	AddDataItem( &peer->event_list, &pc->event );
	pc->this_thread = peer;
	pc->flags.bAddedToEvents = 1;
	peer->nEvents++;
#ifdef LOG_NETWORK_EVENT_THREAD
	lprintf( "peer %p now has %d events", peer, peer->nEvents );
#endif
 // scheduler thread already awake do not wake him.
	if( !peer->flags.bProcessing && peer->parent_peer )
		WSASetEvent( peer->hThread );
}
// this is passed '0' when it is called internally
// this is passed '1' when it is called by idleproc
int CPROC ProcessNetworkMessages( struct peer_thread_info *thread, uintptr_t quick_check )
{
	//lprintf( WIDE("Check messages.") );
	if( globalNetworkData.bQuit )
		return -1;
	if( thread->flags.bProcessing )
		return 0;
	// disallow changing of the lists.
	if( !thread->parent_peer )
	{
		EnterCriticalSec( &globalNetworkData.csNetwork );
		{
			PCLIENT pc;
			PCLIENT next;
			for( pc = globalNetworkData.ClosedClients; pc; pc = next )
			{
#    ifdef LOG_NOTICES
				lprintf( "Have a closed client to check..." );
#    endif
				next = pc->next;
				if( +GetTickCount() > (pc->LastEvent + 1000) )
				{
					lprintf( "Remove thread event on closed thread (should be terminate here..)" );
  // also does the remove.
					TerminateClosedClient( pc );
					//RemoveThreadEvent( pc ); // also does the close.
				}
			}
		}
		{
			PCLIENT pc;
			while( pc = (PCLIENT)DequeLink( &globalNetworkData.client_schedule ) )
			{
				// use this for "added to schedule".  Closing removes from schedule.
				if( !pc->flags.bAddedToEvents )
				{
					if( pc->dwFlags & CF_CLOSED || (!(pc->dwFlags & CF_ACTIVE)) )
					{
						lprintf( WIDE( " Found closed? %p" ), pc );
						continue;
					}
#ifdef LOG_NETWORK_EVENT_THREAD
					if( globalNetworkData.flags.bLogNotices )
						lprintf( WIDE( "Added to schedule : %p %08x" ), pc, pc->dwFlags );
#endif
					AddThreadEvent( pc, 0 );
				}
				else
					lprintf( "Client in schedule queue, but it is already schedule?! %p", pc );
			}
		}
		LeaveCriticalSec( &globalNetworkData.csNetwork );
#ifdef LOG_NETWORK_LOCKING
		lprintf( WIDE( "Process Network left global" ) );
#endif
	}
	else
	{
		// wait for master thread to set up the proper wait
		while( thread->nEvents == 0 )
			Relinquish();
	}
	while( 1 )
	{
		int32_t result;
		// want to wait here anyhow...
#ifdef LOG_NETWORK_EVENT_THREAD
		//if( globalNetworkData.flags.bLogNotices )
		//	lprintf( WIDE( "%p Waiting on %d events" ), thread, thread->nEvents );
#endif
		thread->nWaitEvents = thread->nEvents;
		thread->flags.bProcessing = 0;
		while( thread->counting ) { thread->nWaitEvents = thread->nEvents; Relinquish(); }
		result = WSAWaitForMultipleEvents( thread->nEvents
													, (const HANDLE *)thread->event_list->data
													, FALSE
													, (quick_check)?0:WSA_INFINITE
													, FALSE
													);
		if( globalNetworkData.bQuit )
			return -1;
#ifdef LOG_NETWORK_EVENT_THREAD
		//if( globalNetworkData.flags.bLogNotices )
		//	lprintf( WIDE( "Event Wait Result was %d" ), result );
#endif
		// this should never be 0, but we're awake, not sleeping, and should say we're in a place
		// where we probably do want to be woken on a 0 event.
		if( result != WSA_WAIT_EVENT_0 )
		{
#ifdef LOG_NETWORK_EVENT_THREAD
			//if( globalNetworkData.flags.bLogNotices )
			//	lprintf( WIDE("Begin - thread processing %d"), result );
#endif
			thread->flags.bProcessing = 1;
		}
		thread->nWaitEvents = 0;
		if( result == WSA_WAIT_FAILED )
		{
			DWORD dwError = WSAGetLastError();
			if( dwError == WSA_INVALID_HANDLE )
			{
				lprintf( WIDE( "Rebuild list, have a bad event handle somehow." ) );
				break;
			}
			lprintf( WIDE( "error of wait is %d   %p" ), dwError, thread );
			LogBinary( thread->event_list->data, 64 );
			break;
		}
#ifndef UNDER_CE
		else if( result == WSA_WAIT_IO_COMPLETION )
		{
			// reselect... not sure where io completion fits for network...
			continue;
		}
#endif
		else if( result == WSA_WAIT_TIMEOUT )
		{
			if( quick_check )
				return 1;
		}
		else if( result >= WSA_WAIT_EVENT_0 )
		{
			// if result is _0, then it's the global event, and we just return.
			if( result > WSA_WAIT_EVENT_0 )
			{
				PCLIENT pc = (PCLIENT)GetLink( &thread->monitor_list, result - (WSA_WAIT_EVENT_0) );
				//if( pcLock ) {
					if( !pc || ( pc->dwFlags & CF_AVAILABLE ) ) {
						//lprintf( "thread event happened on a now available client." );
					}
					else
						HandleEvent( pc );
				//}
				/*
				if( thread->parent_peer )
				{
					// if this is a child worker, wait for main to rebuild events.
					// if this was the main thread, it would wake us anyway...
					WSASetEvent( globalNetworkData.hMonitorThreadControlEvent );
					while( thread->nEvents != 1 )
						Relinquish();
				}
				*/
				if( !quick_check )
					continue;
			}
			//else
			{
#ifdef LOG_NOTICES
				if( globalNetworkData.flags.bLogNotices )
					lprintf( thread->parent_peer?WIDE("RESET THREAD EVENT"):WIDE( "RESET GLOBAL EVENT" ) );
#endif
				WSAResetEvent( thread->hThread );
			}
			return 1;
		}
	}
	// result 0... we had nothing to do
	// but we are this thread.
	return 0;
}
//----------------------------------------------------------------------------
static int CPROC IdleProcessNetworkMessages( uintptr_t quick_check )
{
	struct peer_thread_info *this_thread = IsNetworkThread();
	if( this_thread )
		return ProcessNetworkMessages( this_thread, quick_check );
	return -1;
}
 // if !__LINUX__
#else
static uintptr_t CPROC NetworkThreadProc( PTHREAD thread );
void RemoveThreadEvent( PCLIENT pc ) {
	struct peer_thread_info *thread = pc->this_thread;
	// could be closed (accept, initial read, protocol causes close before ever completing getting scheduled)
	if( !thread ) {
		 lprintf( "didn't have one? %p", pc );
		return;
	}
	{
#  ifdef __MAC__
#    ifdef __64__
		struct kevent64_s ev;
		if( pc->dwFlags & CF_LISTEN ) {
			EV_SET64( &ev, pc->Socket, EVFILT_READ, EV_DELETE, 0, 0, (uint64_t)pc, NULL, NULL );
			kevent64( thread->kqueue, &ev, 1, 0, 0, 0, 0 );
		} else {
			EV_SET64( &ev, pc->Socket, EVFILT_READ, EV_DELETE, 0, 0, (uintptr_t)pc, NULL, NULL );
			kevent64( thread->kqueue, &ev, 1, 0, 0, 0, 0 );
			EV_SET64( &ev, pc->Socket, EVFILT_WRITE, EV_DELETE, 0, 0, (uintptr_t)pc, NULL, NULL );
			kevent64( thread->kqueue, &ev, 1, 0, 0, 0, 0 );
		}
		if( pc->SocketBroadcast ) {
			EV_SET64( &ev, pc->SocketBroadcast, EVFILT_READ, EV_DELETE, 0, 0, (uint64_t)pc, NULL, NULL );
			kevent64( thread->kqueue, &ev, 1, 0, 0, 0, 0 );
		}
#    else
		struct kevent ev;
		if( pc->dwFlags & CF_LISTEN ) {
			EV_SET( &ev, pc->Socket, EVFILT_READ, EV_DELETE, 0, 0, (uint64_t)pc );
			kevent( thread->kqueue, &ev, 1, 0, 0, 0 );
		} else {
			EV_SET( &ev, pc->Socket, EVFILT_READ, EV_DELETE, 0, 0, (uintptr_t)pc );
			kevent( thread->kqueue, &ev, 1, 0, 0, 0 );
			EV_SET( &ev, pc->Socket, EVFILT_WRITE, EV_DELETE, 0, 0, (uintptr_t)pc );
			kevent( thread->kqueue, &ev, 1, 0, 0, 0 );
		}
		if( pc->SocketBroadcast ) {
			EV_SET( &ev, pc->SocketBroadcsat, EVFILT_READ, EV_DELETE, 0, 0, (uint64_t)pc );
			kevent( thread->kqueue, &ev, 1, 0, 0, 0 );
		}
#    endif
#  else
		int r;
#ifdef LOG_NETWORK_EVENT_THREAD
		lprintf( "Removing event %p   %d from poll %d", pc, pc->Socket, thread->epoll_fd );
#endif
		//r = epoll_ctl( thread->epoll_fd, EPOLL_CTL_DISABLE, pc->Socket, NULL );
		//if( r < 0 ) lprintf( "Error removing:%d", errno );
		r = epoll_ctl( thread->epoll_fd, EPOLL_CTL_DEL, pc->Socket, NULL );
		if( r < 0 ) lprintf( "Error removing:%d", errno );
		if( pc->SocketBroadcast ) {
			r = epoll_ctl( thread->epoll_fd, EPOLL_CTL_DEL, pc->SocketBroadcast, NULL );
			if( r < 0 ) lprintf( "Error removing:%d", errno );
		}
		pc->flags.bAddedToEvents = 0;
		pc->this_thread = NULL;
#  endif
	}
	LockedDecrement( &thread->nEvents );
	// don't bubble sort root thread
	if( thread->parent_peer )
		while( (thread->nEvents < thread->parent_peer->nEvents) && thread->parent_peer->parent_peer ) {
#ifdef LOG_NETWORK_EVENT_THREAD
			//lprintf( "swapping this with parent peer ... this events %d  parent %d", thread->nEvents, thread->parent_peer->nEvents );
#endif
			if( thread->child_peer )
				thread->child_peer->parent_peer = thread->parent_peer;
			thread->parent_peer->child_peer = thread->child_peer;
			struct peer_thread_info *tmp = thread->parent_peer;
			tmp->parent_peer->child_peer = thread;
			thread->parent_peer = tmp->parent_peer;
			tmp->parent_peer = thread;
			thread->child_peer = tmp;
		}
}
struct event_data {
	PCLIENT pc;
	int broadcast;
};
void AddThreadEvent( PCLIENT pc, int broadcast )
{
	struct peer_thread_info *peer = globalNetworkData.root_thread;
	LOGICAL addPeer = FALSE;
	if( pc->Socket <= 0 ) {
		lprintf( "SAVED FROM A FATAL INFINITE EVENT LOOP");
		return;
	}
#ifdef LOG_NOTICES
	//if( globalNetworkData.flags.bLogNotices )
		lprintf( "Add thread event %p %d %08x  %s", pc, broadcast?pc->SocketBroadcast:pc->Socket, pc->dwFlags, broadcast?"broadcast":"direct" );
#endif
	if( !broadcast ) {
		for( ; peer; peer = peer->child_peer ) {
			if( !peer->child_peer ) {
#ifdef LOG_NOTICES
				if( globalNetworkData.flags.bLogNotices )
					lprintf( "On last peer..." );
#endif
				if( peer->nEvents > globalNetworkData.nPeers ) {
#ifdef LOG_NOTICES
					if( globalNetworkData.flags.bLogNotices )
						lprintf( "global peers is %d, this has %d", globalNetworkData.nPeers, peer->nEvents );
#endif
					addPeer = TRUE;
					break;
				}
				if( peer->nEvents >= 2560 ) {
#ifdef LOG_NOTICES
					if( globalNetworkData.flags.bLogNotices )
						lprintf( "this has max events already.... %d %d", globalNetworkData.nPeers, peer->nEvents );
#endif
					addPeer = TRUE;
					break;
				}
			}
			if( peer->nEvents < 2560 ) {
												// last thread.
				if( !peer->child_peer )
					break;
				if( peer->nEvents < peer->child_peer->nEvents ) {
#ifdef LOG_NOTICES
					//if( globalNetworkData.flags.bLogNotices )
					//	lprintf( "this event has fewer than the next thread's events %d  %d", peer->nEvents, peer->child_peer->nEvents );
#endif
					break;
				}
			}
		}
		if( addPeer ) {
#ifdef LOG_NOTICES
			if( globalNetworkData.flags.bLogNotices )
				lprintf( "Creating a new thread...." );
#endif
			AddLink( &globalNetworkData.pThreads, ThreadTo( NetworkThreadProc, (uintptr_t)peer ) );
			globalNetworkData.nPeers++;
			while( !peer->child_peer )
				Relinquish();
			if( globalNetworkData.root_thread != peer ) {
				// relink to be higher in list of peers so it's found earlier.
#ifdef LOG_NOTICES
				if( globalNetworkData.flags.bLogNotices )
					lprintf( "Relinking thread to be after root peer (no events, so it must be first)" );
#endif
				peer->child_peer->child_peer = globalNetworkData.root_thread->child_peer;
				globalNetworkData.root_thread->child_peer->parent_peer = peer->child_peer;
				globalNetworkData.root_thread->child_peer = peer->child_peer;
				peer->child_peer->parent_peer = globalNetworkData.root_thread;
				peer->child_peer = NULL;
				peer = globalNetworkData.root_thread->child_peer;
			}
			else
				peer = peer->child_peer;
		}
	} else {
 // add broadcast to the same event as the original.
		peer = pc->this_thread;
	}
	// make sure to only add this handle when the first peer will also be added.
	// this means the list can be 61 and at this time no more.
	{
#  ifdef __MAC__
		struct event_data *data = New( struct event_data );
		data->pc = pc;
		data->broadcast = broadcast;
#    ifdef __64__
		struct kevent64_s ev;
		if( pc->dwFlags & CF_LISTEN ) {
			EV_SET64( &ev, broadcast?pc->SocketBroadcast:pc->Socket, EVFILT_READ, EV_ADD, 0, 0, (uintptr_t)data, NULL, NULL );
			kevent64( peer->kqueue, &ev, 1, 0, 0, 0, 0 );
		}
		else {
			EV_SET64( &ev, broadcast?pc->SocketBroadcast:pc->Socket, EVFILT_READ, EV_ADD, 0, 0, (uintptr_t)data, NULL, NULL );
			kevent64( peer->kqueue, &ev, 1, 0, 0, 0, 0 );
			EV_SET64( &ev, broadcast?pc->SocketBroadcast:pc->Socket, EVFILT_WRITE, EV_ADD | EV_CLEAR, 0, 0, (uintptr_t)data, NULL, NULL );
			kevent64( peer->kqueue, &ev, 1, 0, 0, 0, 0 );
		}
#    else
		struct kevent ev;
		if( pc->dwFlags & CF_LISTEN ) {
			EV_SET( &ev, broadcast?pc->SocketBroadcast:pc->Socket, EVFILT_READ, EV_ADD, 0, 0, (uintptr_t)data );
			kevent( peer->kqueue, &ev, 1, 0, 0, 0 );
		}
		else {
			EV_SET( &ev, broadcast?pc->SocketBroadcast:pc->Socket, EVFILT_READ, EV_ADD|EV_ENABLE, 0, 0, (uintptr_t)data );
			kevent( peer->kqueue, &ev, 1, 0, 0, 0 );
			EV_SET( &ev, broadcast?pc->SocketBroadcast:pc->Socket, EVFILT_WRITE, EV_ADD|EV_ENABLE|EV_CLEAR, 0, 0, (uintptr_t)data );
			kevent( peer->kqueue, &ev, 1, 0, 0, 0 );
		}
#    endif
#  else
		int r;
		struct epoll_event ev;
		ev.data.ptr = New( struct event_data );
		((struct event_data*)ev.data.ptr)->pc = pc;
		((struct event_data*)ev.data.ptr)->broadcast = broadcast;
		if( pc->dwFlags & CF_LISTEN )
			ev.events = EPOLLIN;
		else {
			ev.events = EPOLLIN | EPOLLOUT | EPOLLRDHUP | EPOLLET;
		}
#ifdef LOG_NETWORK_EVENT_THREAD
		lprintf( "peer add socket %d to %d now has 0x%x events", pc->Socket, peer->epoll_fd, ev.events );
#endif
		r = epoll_ctl( peer->epoll_fd, EPOLL_CTL_ADD, broadcast?pc->SocketBroadcast:pc->Socket, &ev );
		if( r < 0 ) lprintf( "Error adding:%d %d", errno, broadcast?pc->SocketBroadcast:pc->Socket );
#  endif
	}
#ifdef LOG_NETWORK_EVENT_THREAD
	lprintf( "added thread: %p  %p  %p  ", pc, pc->this_thread, peer );
#endif
	if( !pc->this_thread ) {
		LockedIncrement( &peer->nEvents );
		pc->this_thread = peer;
		pc->flags.bAddedToEvents = 1;
	}
#ifdef LOG_NETWORK_EVENT_THREAD
	lprintf( "peer %p now has %d events", peer, peer->nEvents );
#endif
	// scheduler thread already awake do not wake him.
}
int CPROC ProcessNetworkMessages( struct peer_thread_info *thread, uintptr_t unused )
{
	int cnt;
	struct timeval time;
	if( globalNetworkData.bQuit )
		return -1;
	{
#  ifdef __MAC__
#    ifdef __64__
		struct kevent64_s events[10];
		cnt = kevent64( thread->kqueue, NULL, 0, events, 10, 0, NULL );
#    else
		kevent events[10];
		cnt = kevent( thread->kqueue, NULL, 0, events, 10, NULL );
#    endif
#  else
		struct epoll_event events[10];
#    ifdef LOG_NETWORK_EVENT_THREAD
		lprintf( "Wait on %d", thread->epoll_fd );
#    endif
		cnt = epoll_wait( thread->epoll_fd, events, 10, -1 );
#  endif
		if( cnt < 0 )
		{
			int err = errno;
			if( err == EINTR )
				return 1;
			Log1( WIDE( "Sorry epoll_pwait/kevent call failed... %d" ), err );
			return 1;
		}
		if( cnt > 0 )
		{
			int closed;
			int n;
			struct event_data *event_data;
			THREAD_ID prior = 0;
			PCLIENT next;
#  ifdef LOG_NETWORK_EVENT_THREAD
			lprintf( "process %d events", cnt );
#  endif
			for( n = 0; n < cnt; n++ ) {
				closed = 0;
#  ifdef __MAC__
				event_data = (struct event_data*)events[n].udata;
#  ifdef LOG_NOTICES
				lprintf( "Process %d %x %x"
				       , ((uintptr_t)event_data == 1) ?0:event_data->broadcast?event_data->pc->SocketBroadcast:event_data->pc->Socket
				       , ((uintptr_t)event_data == 1) ?0:event_data->pc->dwFlags
				       , events[n].filter );
#  endif
#  else
				event_data = (struct event_data*)events[n].data.ptr;
#  ifdef LOG_NOTICES
				lprintf( "Process %d %x", event_data->broadcast?event_data->pc->SocketBroadcast:event_data->pc->Socket
				       , events[n].events );
#  endif
#  endif
				if( event_data == (struct event_data*)1 ) {
					//char buf;
					//stat = read( GetThreadSleeper( thread->pThread ), &buf, 1 );
					//call wakeable sleep to just clear the sleep; because this is an event on the sleep pipe.
					WakeableSleep( SLEEP_FOREVER );
					return 1;
				}
#  ifdef __MAC__
				if( events[n].filter == EVFILT_READ )
#  else
				if( events[n].events & EPOLLIN )
#  endif
				{
					int locked;
					locked = 1;
					while( !NetworkLock( event_data->pc, 1 ) ) {
						if( !( event_data->pc->dwFlags & CF_ACTIVE ) ) {
#  ifdef LOG_NETWORK_EVENT_THREAD
							lprintf( "failed lock dwFlags : %8x", event_data->pc->dwFlags );
#  endif
							locked = 0;
							break;
						}
						if( event_data->pc->dwFlags & CF_AVAILABLE ) {
							locked = 0;
							break;
						}
						Relinquish();
					}
					if( !( event_data->pc->dwFlags & ( CF_ACTIVE | CF_CLOSED ) ) ) {
#  ifdef LOG_NETWORK_EVENT_THREAD
						lprintf( "not active but locked? dwFlags : %8x", event_data->pc->dwFlags );
#  endif
						continue;
					}
					if( event_data->pc->dwFlags & CF_AVAILABLE )
						continue;
					if( !IsValid( event_data->pc->Socket ) ) {
						NetworkUnlock( event_data->pc, 1 );
						continue;
					}
#  ifdef LOG_NETWORK_EVENT_THREAD
					lprintf( "EPOLLIN/EVFILT_READ %x", event_data->pc->dwFlags );
#  endif
					if( event_data->pc->dwFlags & CF_CLOSED ) {
						PCLIENT pClient = event_data->pc;
						// close notice went to application; all resources for application are gone.
						// any pending reads are no longre valid.
						//lprintf( "socket is already closed... what do we need to do?");
						//WakeableSleep( 100 );
						if( 0 && !pClient->bDraining )
						{
							size_t bytes_read;
							// act of reading can result in a close...
							// there are things like IE which close and send
							// adn we might get the close notice at application level indicating there might still be data...
							while( ( bytes_read = FinishPendingRead( pClient DBG_SRC) ) > 0
 // try and read...
								&& bytes_read != (size_t)-1 );
							//if( pClient->dwFlags & CF_TOCLOSE )
							{
								//lprintf( "Pending read failed - reset connection. (well this is FD_CLOSE so yeah...??]" );
								//InternalRemoveClientEx( pc, TRUE, FALSE );
							}
						}
#  ifdef LOG_NOTICES
						//if( globalNetworkData.flags.bLogNotices )
							lprintf(WIDE( "FD_CLOSE... %p  %08x" ), pClient, pClient->dwFlags );
#  endif
						//if( pClient->dwFlags & CF_ACTIVE )
						{
							// might already be cleared and gone..
							//InternalRemoveClientEx( pClient, FALSE, TRUE );
							TerminateClosedClient( pClient );
							closed = 1;
						}
						// section will be blank after termination...(correction, we keep the section state now)
 // it's no longer closing.  (was set during the course of closure)
						pClient->dwFlags &= ~CF_CLOSING;
					} else if( !(event_data->pc->dwFlags & (CF_ACTIVE) ) ) {
						lprintf( "Event on socket no longer active..." );
						// change to inactive status by the time we got here...
					} else if( event_data->pc->dwFlags & CF_LISTEN )
					{
#ifdef LOG_NOTICES
						if( globalNetworkData.flags.bLogNotices )
							lprintf( WIDE( "accepting..." ) );
#endif
						AcceptClient( event_data->pc );
					}
					else if( event_data->pc->dwFlags & CF_UDP )
					{
#ifdef LOG_NOTICES
						if( globalNetworkData.flags.bLogNotices )
							lprintf( WIDE( "UDP Read Event..." ) );
#endif
						//lprintf( "UDP READ" );
						FinishUDPRead( event_data->pc, event_data->broadcast );
					}
					else if( event_data->pc->bDraining )
					{
#ifdef LOG_NOTICES
						if( globalNetworkData.flags.bLogNotices )
							lprintf( WIDE( "TCP Drain Event..." ) );
#endif
						TCPDrainRead( event_data->pc );
					}
					else if( event_data->pc->dwFlags & CF_READPENDING )
					{
						size_t read;
#ifdef LOG_NOTICES
						if( globalNetworkData.flags.bLogNotices )
							lprintf( WIDE( "TCP Read Event..." ) );
#endif
						// packet oriented things may probably be reading only
						// partial messages at a time...
						read = FinishPendingRead( event_data->pc DBG_SRC );
						//lprintf( "Read %d", read );
						if( ( read == -1 ) && ( event_data->pc->dwFlags & CF_TOCLOSE ) )
						{
#ifdef LOG_NOTICES
							//if( globalNetworkData.flags.bLogNotices )
								lprintf( WIDE( "Pending read failed - reset connection." ) );
#endif
							//InternalRemoveClientEx( event_data->pc, FALSE, FALSE );
							TerminateClosedClient( event_data->pc );
							closed = 1;
						}
						else if( !event_data->pc->RecvPending.s.bStream )
							event_data->pc->dwFlags |= CF_READREADY;
					}
					else
					{
#ifdef LOG_NOTICES
						if( globalNetworkData.flags.bLogNotices )
							lprintf( WIDE( "TCP Set read ready..." ) );
#endif
						event_data->pc->dwFlags |= CF_READREADY;
					}
					if( locked )
						LeaveCriticalSec( &event_data->pc->csLockRead );
				}
				if( !closed && ( event_data->pc->dwFlags & CF_ACTIVE ) ) {
					int locked;
					locked = 1;
#  ifdef __MAC__
					if( events[n].filter == EVFILT_WRITE )
#  else
					if( events[n].events & EPOLLOUT )
#  endif
					{
#  ifdef LOG_NETWORK_EVENT_THREAD
						lprintf( "EPOLLOUT %s", ( event_data->pc->dwFlags & CF_CONNECTING ) ? "connecting"
							: ( !( event_data->pc->dwFlags & CF_ACTIVE ) ) ? "closed" : "writing" );
#  endif
						while( !NetworkLock( event_data->pc, 0 ) ) {
							if( !( event_data->pc->dwFlags & CF_WRITEISPENDED ) ) {
								locked = 0;
								break;
							}
							if( !( event_data->pc->dwFlags & CF_ACTIVE ) ) {
#  ifdef LOG_NETWORK_EVENT_THREAD
								lprintf( "failed lock dwFlags : %8x", event_data->pc->dwFlags );
#  endif
								locked = 0;
								break;
							}
							if( event_data->pc->dwFlags & CF_AVAILABLE ) {
								locked = 0;
								break;
							}
							Relinquish();
						}
						if( !( event_data->pc->dwFlags & ( CF_ACTIVE | CF_CLOSED ) ) ) {
#  ifdef LOG_NETWORK_EVENT_THREAD
							lprintf( "not active but locked? dwFlags : %8x", event_data->pc->dwFlags );
#  endif
							continue;
						}
						if( event_data->pc->dwFlags & CF_AVAILABLE )
							continue;
						if( !IsValid( event_data->pc->Socket ) ) {
							NetworkUnlock( event_data->pc, 0 );
							continue;
						}
						if( !( event_data->pc->dwFlags & CF_ACTIVE ) ) {
							//lprintf( "FLAGS IS NOT ACTIVE BUT: %x", event_data->pc->dwFlags );
							// change to inactive status by the time we got here...
						} else if( event_data->pc->dwFlags & CF_CONNECTING ) {
#ifdef LOG_NOTICES
							if( globalNetworkData.flags.bLogNotices )
								lprintf( WIDE( "Connected!" ) );
#endif
							event_data->pc->dwFlags |= CF_CONNECTED;
							event_data->pc->dwFlags &= ~CF_CONNECTING;
							{
								PCLIENT pc = event_data->pc;
#ifdef __LINUX__
								socklen_t
#else
								int
#endif
									nLen = MAGIC_SOCKADDR_LENGTH;
								if( !pc->saSource )
									pc->saSource = AllocAddr();
								if( getsockname( pc->Socket, pc->saSource, &nLen ) ) {
									lprintf( WIDE( "getsockname errno = %d" ), errno );
								}
								if( pc->saSource->sa_family == AF_INET )
									SET_SOCKADDR_LENGTH( pc->saSource, IN_SOCKADDR_LENGTH );
								else if( pc->saSource->sa_family == AF_INET6 )
									SET_SOCKADDR_LENGTH( pc->saSource, IN6_SOCKADDR_LENGTH );
								else
									SET_SOCKADDR_LENGTH( pc->saSource, nLen );
							}
							{
								int error;
								socklen_t errlen = sizeof( error );
								getsockopt( event_data->pc->Socket, SOL_SOCKET
									, SO_ERROR
									, &error, &errlen );
								//lprintf( WIDE( "Error checking for connect is: %s on %d" ), strerror( error ), event_data->pc->Socket );
								if( event_data->pc->pWaiting ) {
#ifdef LOG_NOTICES
									if( globalNetworkData.flags.bLogNotices )
										lprintf( WIDE( "Got connect event, waking waiter.." ) );
#endif
									WakeThread( event_data->pc->pWaiting );
								}
								if( event_data->pc->connect.ThisConnected )
									event_data->pc->connect.ThisConnected( event_data->pc, error );
#ifdef LOG_NOTICES
								if( globalNetworkData.flags.bLogNotices )
									lprintf( "Connect error was: %d", error );
#endif
								// if connected okay - issue first read...
								if( !error ) {
#ifdef LOG_NOTICES
									lprintf( "Read Complete" );
#endif
									if( event_data->pc->read.ReadComplete ) {
#ifdef LOG_NOTICES
										lprintf( "Initial Read Complete" );
#endif
										event_data->pc->read.ReadComplete( event_data->pc, NULL, 0 );
									}
									if( event_data->pc->lpFirstPending ) {
										lprintf( WIDE( "Data was pending on a connecting socket, try sending it now" ) );
										TCPWrite( event_data->pc );
									}
								} else {
									event_data->pc->dwFlags |= CF_CONNECTERROR;
								}
							}
						} else if( event_data->pc->dwFlags & CF_UDP ) {
							//lprintf( "UDP WRITE IS NEVER QUEUED." );
							// udp write event complete....
							// do we ever care? probably sometime...
						} else {
#ifdef LOG_NOTICES
							if( globalNetworkData.flags.bLogNotices )
								lprintf( WIDE( "TCP Write Event..." ) );
#endif
							event_data->pc->dwFlags &= ~CF_WRITEISPENDED;
							TCPWrite( event_data->pc );
						}
						if( locked )
							NetworkUnlock( event_data->pc, 0 );
					}
				} else {
					//lprintf( "Already closed? Stop looping on this event? %p %d %x", event_data->pc, event_data->pc->Socket, event_data->pc->dwFlags );
				}
			}
			// had some event  - return 1 to continue working...
		}
		return 1;
	}
	//lprintf( WIDE("Attempting to wake thread (send sighup!)") );
	//WakeThread( globalNetworkData.pThread );
	//lprintf( WIDE("Only reason should get here is if it's not this thread...") );
	return -1;
}
//----------------------------------------------------------------------------
static int CPROC IdleProcessNetworkMessages( uintptr_t quick_check )
{
	struct peer_thread_info *this_thread = IsNetworkThread();
	if( this_thread )
		return ProcessNetworkMessages( this_thread, quick_check );
	return -1;
}
#endif
uintptr_t CPROC NetworkThreadProc( PTHREAD thread )
{
	struct peer_thread_info *peer_thread = (struct peer_thread_info*)GetThreadParam( thread );
	struct peer_thread_info this_thread;
	// and when unloading should remove these timers.
	if( !peer_thread )
	{
#ifdef _WIN32
		globalNetworkData.uNetworkPauseTimer = AddTimerEx( 1, 1000, NetworkPauseTimer, 0 );
		if( !globalNetworkData.client_schedule )
			globalNetworkData.client_schedule = CreateLinkQueue();
#endif
#ifdef __LINUX__
		globalNetworkData.flags.bNetworkReady = TRUE;
		globalNetworkData.flags.bThreadInitOkay = TRUE;
#endif
	}
	memset( &this_thread, 0, sizeof( this_thread ) );
	this_thread.monitor_list = NULL;
#ifdef _WIN32
	this_thread.event_list = CreateDataList( sizeof( WSAEVENT ) );
	this_thread.hThread = WSACreateEvent();
	// setup this as if it was cleared already.
	this_thread.nEvents = 1;
 // has to be a non zero value.  monitor is not referenced for wait event 0
	SetLink( &this_thread.monitor_list, 0, (POINTER)1 );
	SetDataItem( &this_thread.event_list, 0, &this_thread.hThread );
#else
	// have to fall back to poll() for __MAC__ builds. (probably client only)
	//this_thread.event_list = CreateDataList( sizeof( struct pollfd ) );
#ifdef __LINUX__
#ifdef __MAC__
	this_thread.kqueue = kqueue();
#else
#ifdef __ANDROID__
 // close on exec (no inherit)
	this_thread.epoll_fd = epoll_create( 128 );
#else
 // close on exec (no inherit)
	this_thread.epoll_fd = epoll_create1( EPOLL_CLOEXEC );
#endif
#endif
	{
#  ifdef __MAC__
#    ifdef __64__
		struct kevent64_s ev;
		this_thread.kevents = CreateDataList( sizeof( ev ) );
		EV_SET64( &ev, GetThreadSleeper( thread ), EVFILT_READ, EV_ADD, 0, 0, (uint64_t)1, NULL, NULL );
		kevent64( this_thread.kqueue, &ev, 1, 0, 0, 0, 0 );
#    else
		struct kevent ev;
		this_thread.kevents = CreateDataList( sizeof( ev ) );
		EV_SET( &ev, GetThreadSleeper( thread ), EVFILT_READ, EV_ADD, 0, 0, (uintptr_t)1 );
		kevent( this_thread.kqueue, &ev, 1, 0, 0, 0 );
#    endif
#  else
		struct epoll_event ev;
		ev.data.ptr = (void*)1;
		ev.events = EPOLLIN;
		epoll_ctl( this_thread.epoll_fd, EPOLL_CTL_ADD, GetThreadSleeper( thread ), &ev );
#  endif
	}
#endif
#endif
	this_thread.parent_peer = peer_thread;
	this_thread.child_peer = NULL;
	this_thread.thread = thread;
	if( peer_thread )
		peer_thread->child_peer = &this_thread;
	else {
		globalNetworkData.root_thread = &this_thread;
#ifdef _WIN32
		globalNetworkData.hMonitorThreadControlEvent = this_thread.hThread;
#endif
	}
 // creator won't pass until bThreadInitComplete is set.
	while( !globalNetworkData.pThreads )
		Relinquish();
	globalNetworkData.flags.bThreadInitOkay = TRUE;
	globalNetworkData.flags.bThreadInitComplete = TRUE;
	while( !globalNetworkData.bQuit )
	{
		ProcessNetworkMessages( &this_thread, 0 );
	}
	xlprintf( 2100 )(WIDE( "Enter global network on shutdown... (thread exiting)" ));
	EnterCriticalSec( &globalNetworkData.csNetwork );
#  ifdef LOG_NETWORK_LOCKING
	lprintf( WIDE( "NetworkThread(exit) in global" ) );
#  endif
	if( !this_thread.parent_peer )
	{
		if( globalNetworkData.root_thread = this_thread.child_peer )
			this_thread.child_peer->parent_peer = NULL;
	}
	else
	{
		if( this_thread.parent_peer->child_peer = this_thread.child_peer )
			this_thread.child_peer->parent_peer = this_thread.parent_peer;
	}
	// this used to be done in the WM_DESTROY
	DeleteLink( &globalNetworkData.pThreads, thread );
	globalNetworkData.flags.bThreadExit = TRUE;
	xlprintf( 2100 )(WIDE( "Shut down network thread." ));
	globalNetworkData.flags.bThreadInitComplete = FALSE;
	globalNetworkData.flags.bNetworkReady = FALSE;
	LeaveCriticalSec( &globalNetworkData.csNetwork );
#  ifdef LOG_NETWORK_LOCKING
	lprintf( WIDE( "NetworkThread(exit) left global" ) );
#  endif
	//DeleteCriticalSec( &globalNetworkData.csNetwork );	 //spv:980303
	return 0;
}
//----------------------------------------------------------------------------
struct peer_thread_info *IsNetworkThread( void )
{
	struct peer_thread_info *thread;
	PTHREAD this_thread = MakeThread();
	for( thread = globalNetworkData.root_thread; thread; thread = thread->child_peer )
	{
		if( thread->thread == this_thread )
			return thread;
	}
	return NULL;
}
//----------------------------------------------------------------------------
int NetworkQuit(void)
{
	if( !global_network_data )
		return 0;
#if 0
	if( globalNetworkData.uPendingTimer )
	{
		RemoveTimer( globalNetworkData.uPendingTimer );
		globalNetworkData.uPendingTimer = 0;
	}
#endif
	//while( globalNetworkData.ActiveClients )
	{
#ifdef LOG_NOTICES
		if( globalNetworkData.flags.bLogNotices )
			lprintf( WIDE("NetworkQuit - Remove active client %p"), globalNetworkData.ActiveClients );
#endif
		//InternalRemoveClientEx( globalNetworkData.ActiveClients, TRUE, FALSE );
	}
	globalNetworkData.bQuit = TRUE;
	{
		PTHREAD thread;
		INDEX idx;
#ifdef USE_WSA_EVENTS
		PLIST wakeEvents = NULL;
		struct peer_thread_info *peer_thread;
		WSAEVENT hThread;
		peer_thread = globalNetworkData.root_thread;
		globalNetworkData.root_thread = NULL;
		for( ; peer_thread; peer_thread = peer_thread->child_peer ) {
			AddLink( &wakeEvents, peer_thread->hThread );
		}
		LIST_FORALL( wakeEvents, idx, WSAEVENT, hThread )
			WSASetEvent( hThread );
#endif
		LIST_FORALL( globalNetworkData.pThreads, idx, PTHREAD, thread ) {
			WakeThread( thread );
		}
	}
#ifdef _WIN32
#  ifdef LOG_NOTICES
	if( globalNetworkData.flags.bLogNotices )
		lprintf( WIDE( "SET GLOBAL EVENT (trigger quit)" ) );
#  endif
	WSASetEvent( globalNetworkData.hMonitorThreadControlEvent );
#else
#  ifndef __LINUX__
	if( IsWindow( globalNetworkData.ghWndNetwork ) )
	{
		// okay forget this... at exit, cannot guarantee that
		// any other thread other than myself has any rights to do anything.
#    ifdef LOG_NOTICES
		if( globalNetworkData.flags.bLogNotices )
			lprintf( WIDE( "Post SOCKMSG_CLOSE" ) );
#    endif
		PostMessage( globalNetworkData.ghWndNetwork, SOCKMSG_CLOSE, 0, 0 );
		// also remove PCLIENT clients, and all client->pUserData allocated...
	}
#  else
	//while( globalNetworkData.pThread )
	//	Sleep(0);
	// should kill Our thread.... and close any active ockets...
#  endif
#endif
	globalNetworkData.flags.bThreadInitComplete = FALSE;
	//RemoveIdleProc( ProcessNetworkMessages );
	if( globalNetworkData.pThreads )
	{
		uint32_t started = timeGetTime() + 500;
 // allow network thread to gracefully exit
		Relinquish();
		while( globalNetworkData.flags.bNetworkReady && timeGetTime() < started )
			IdleFor( 20 );
		if( globalNetworkData.flags.bNetworkReady )
		{
#ifdef LOG_STARTUP_SHUTDOWN
			lprintf( WIDE( "Network was locked up?  Failed to allow network to exit in half a second (500ms)" ) );
#endif
		}
	}
	globalNetworkData.root_thread = NULL;
	return -1;
}
ATEXIT( NetworkShutdown )
{
	NetworkQuit();
}
//----------------------------------------------------------------------------
LOGICAL NetworkAlive( void )
{
	return !globalNetworkData.flags.bThreadExit;
}
//----------------------------------------------------------------------------
static void AddClients( void ) {
	PCLIENT_SLAB pClientSlab;
	// protect all structures.
	EnterCriticalSec( &globalNetworkData.csNetwork );
	{
		size_t n;
		//Log1( WIDE("Creating %d Client Resources"), MAX_NETCLIENTS );
		pClientSlab = NewPlus( CLIENT_SLAB, (MAX_NETCLIENTS - 1 )* sizeof( CLIENT ) );
		pClientSlab->pUserData = NewArray( uintptr_t, MAX_NETCLIENTS * globalNetworkData.nUserData );
 // can't clear the lpUserData Address!!!
		MemSet( pClientSlab->client, 0, (MAX_NETCLIENTS) * sizeof( CLIENT ) );
		MemSet( pClientSlab->pUserData, 0, (MAX_NETCLIENTS) * globalNetworkData.nUserData * sizeof( uintptr_t ) );
		pClientSlab->count = MAX_NETCLIENTS;
		for( n = 0; n < pClientSlab->count; n++ )
		{
 // unused sockets on all clients.
			pClientSlab->client[n].Socket = INVALID_SOCKET;
			pClientSlab->client[n].lpUserData = pClientSlab->pUserData + (n * globalNetworkData.nUserData);
			InitializeCriticalSec( &pClientSlab->client[n].csLockRead );
			InitializeCriticalSec( &pClientSlab->client[n].csLockWrite );
			AddAvailable( pClientSlab->client + n );
		}
		AddLink( &globalNetworkData.ClientSlabs, pClientSlab );
	}
	LeaveCriticalSec( &globalNetworkData.csNetwork );
}
//----------------------------------------------------------------------------
static void ReallocClients( uint32_t wClients, int nUserData )
{
	// protect all structures.
	EnterCriticalSec( &globalNetworkData.csNetwork );
	if( !wClients )
  // default 32 clients per slab...
		wClients = 32;
	if( !nUserData )
  // defualt to 4 pointer words per socket; most applications only use 1.
		nUserData = 4;
	// keep the max of specified data..
	if( nUserData < globalNetworkData.nUserData )
		nUserData = globalNetworkData.nUserData;
	// keep the max of specified connections..
	if( wClients < MAX_NETCLIENTS )
		wClients = MAX_NETCLIENTS;
	// if the client slab size increases, new slabs will be the new size; old slabs will still be the old size.
 // have to reallocate the user data for all sockets
	if( nUserData > globalNetworkData.nUserData )
	{
		INDEX idx;
		PCLIENT_SLAB slab;
		uint32_t n;
		// for all existing client slabs...
		LIST_FORALL( globalNetworkData.ClientSlabs, idx, PCLIENT_SLAB, slab )
		{
			uintptr_t* pUserData;
// slab->pUserData;
			pUserData = NewArray( uintptr_t, nUserData * sizeof( uintptr_t ) * slab->count );
			for( n = 0; n < slab->count; n++ )
			{
				if( slab->client[n].lpUserData )
					MemCpy( (char*)pUserData + (n * (nUserData * sizeof( uintptr_t )))
					      , slab->client[n].lpUserData
					      , globalNetworkData.nUserData * sizeof( uintptr_t ) );
				slab->client[n].lpUserData = pUserData + (n * nUserData);
			}
			Deallocate( uintptr_t*, slab->pUserData );
			slab->pUserData = pUserData;
		}
	}
	MAX_NETCLIENTS = wClients;
	globalNetworkData.nUserData = nUserData;
	LeaveCriticalSec( &globalNetworkData.csNetwork );
}
#ifdef __LINUX__
NETWORK_PROC( LOGICAL, NetworkWait )(POINTER unused,uint32_t wClients,int wUserData)
#else
NETWORK_PROC( LOGICAL, NetworkWait )(HWND hWndNotify,uint32_t wClients,int wUserData)
#endif
{
	// want to start the thead; clear quit.
	if( !global_network_data )
		LowLevelNetworkInit();
	// allow network to restart with new NetworkWait after NetworkQuit
	globalNetworkData.bQuit = FALSE;
	ReallocClients( wClients, wUserData );
	//-------------------------
	// please be mindful of the following data declared immediate...
	if( GetLinkCount( globalNetworkData.pThreads ) )
	{
		//xlprintf(200)( WIDE("Threads already active...") );
		// might do something... might not...
 // network thread active, do not realloc
		return TRUE;
	}
/*peer_thread==*/
	AddLink( &globalNetworkData.pThreads, ThreadTo( NetworkThreadProc, (uintptr_t)NULL ) );
	globalNetworkData.nPeers++;
	AddIdleProc( IdleProcessNetworkMessages, 1 );
	//lprintf( WIDE("Network Initialize..."));
	//lprintf( WIDE("Create network thread.") );
	while( !globalNetworkData.flags.bThreadInitComplete )
	{
		Relinquish();
	}
	if( !globalNetworkData.flags.bThreadInitOkay )
	{
		lprintf( WIDE("Abort network, init is NOT ok.") );
		return FALSE;
	}
	while( !globalNetworkData.flags.bNetworkReady )
 // wait for actual network...
		Relinquish();
	{
		char buffer[256];
		if( gethostname( buffer, sizeof( buffer ) ) == 0)
			globalNetworkData.system_name = DupCStr( buffer );
	}
	LoadNetworkAddresses();
  // return status of thread initialization
	return globalNetworkData.flags.bThreadInitOkay;
}
//----------------------------------------------------------------------------
PCLIENT GetFreeNetworkClientEx( DBG_VOIDPASS )
{
	PCLIENT pClient = NULL;
get_client:
	EnterCriticalSec( &globalNetworkData.csNetwork );
#ifdef LOG_NETWORK_LOCKING
	lprintf( WIDE("GetFreeNetworkClient in global") );
#endif
 // if there's none available, add some with current config
	if( !globalNetworkData.AvailableClients )
		AddClients();
	for( pClient = globalNetworkData.AvailableClients; pClient; pClient = pClient->next )
		if( !( pClient->dwFlags & CF_CLOSING ) )
			break;
	if( pClient )
	{
		int d;
		// oterhwise we'll deadlock the closing client...
		// an opening condition has global lock (above)
		// and a closing socket will want the global lock before it's done.
		pClient = GrabClient( pClient );
		do {
#ifdef USE_NATIVE_CRITICAL_SECTION
			d = EnterCriticalSecNoWait( &pClient->csLockRead, NULL );
#else
			d = EnterCriticalSecNoWaitEx( &pClient->csLockRead, NULL DBG_RELAY );
#endif
			if( d < 1 ) {
				LeaveCriticalSec( &globalNetworkData.csNetwork );
				goto get_client;
			}
		} while( d < 1 );
		do {
#ifdef USE_NATIVE_CRITICAL_SECTION
			d = EnterCriticalSecNoWait( &pClient->csLockWrite, NULL );
#else
			d = EnterCriticalSecNoWaitEx( &pClient->csLockWrite, NULL DBG_RELAY );
#endif
			if( d < 1 ) {
				LeaveCriticalSec( &pClient->csLockRead );
				LeaveCriticalSec( &globalNetworkData.csNetwork );
				goto get_client;
			}
		} while( d < 1 );
		if( pClient->dwFlags & CF_STATEFLAGS )
			DebugBreak();
 // clear client is redundant here... but saves the critical section now
		ClearClient( pClient DBG_SRC );
		//Log1( WIDE("New network client %p"), client );
	}
	else
	{
		LeaveCriticalSec( &globalNetworkData.csNetwork );
#ifdef LOG_NETWORK_LOCKING
		lprintf( WIDE("GetFreeNetworkClient left global") );
#endif
		Relinquish();
		if( globalNetworkData.AvailableClients )
		{
			lprintf( WIDE( "there were clients available... just in a closing state..." ) );
			goto get_client;
		}
		lprintf( WIDE("No unused network clients are available.") );
		return NULL;
	}
	LeaveCriticalSec( &globalNetworkData.csNetwork );
#ifdef LOG_NETWORK_LOCKING
	lprintf( WIDE("GetFreeNetworkClient left global") );
#endif
	return pClient;
}
//----------------------------------------------------------------------------
NETWORK_PROC( void, SetNetworkLong )(PCLIENT lpClient, int nLong, uintptr_t dwValue)
{
	if( lpClient && ( nLong < globalNetworkData.nUserData ) )
	{
		lpClient->lpUserData[nLong] = dwValue;
	}
	return;
}
//----------------------------------------------------------------------------
int GetAddressParts( SOCKADDR *sa, uint32_t *pdwIP, uint16_t *pdwPort )
{
	int result = TRUE;
	if( sa )
	{
		if( sa->sa_family == AF_INET ) {
			if( pdwIP )
				(*pdwIP) = (uint32_t)(((SOCKADDR_IN*)sa)->sin_addr.S_un.S_addr);
		}
		else if( sa->sa_family == AF_INET6 ) {
			if( pdwIP )
				memcpy( pdwIP, &(((SOCKADDR_IN*)sa)->sin_addr.S_un.S_addr), 16 );
		}
		else
			result = FALSE;
		if( (sa->sa_family == AF_INET) || (sa->sa_family = AF_INET6) ) {
			if( pdwPort )
				(*pdwPort) = ntohs((uint16_t)( (SOCKADDR_IN*)sa)->sin_port);
		}
		else
			result = FALSE;
	}
	return result;
}
NETWORK_PROC( uintptr_t, GetNetworkLong )(PCLIENT lpClient,int nLong)
{
	if( !lpClient )
	{
		return (uintptr_t)-1;
	}
	if( nLong < 0 )
	{
		switch( nLong )
		{
  // IP of destination
		case GNL_IP:
			if( lpClient->saClient )
				return *(uint32_t*)(lpClient->saClient->sa_data+2);
			break;
  // IP of destination
		case GNL_REMOTE_ADDRESS:
			  return (uintptr_t)lpClient->saClient;
			break;
  // IP of local side
		case GNL_LOCAL_ADDRESS:
			  return (uintptr_t)lpClient->saSource;
			break;
  // port of server...  STUPID PATCH?!  maybe...
		case GNL_PORT:
			if( lpClient->saClient )
				return ntohs( *(uint16_t*)(lpClient->saClient->sa_data) );
			break;
  // port of server...  STUPID PATCH?!  maybe...
		case GNL_MYPORT:
			if( lpClient->saSource )
				return ntohs( *(uint16_t*)(lpClient->saSource->sa_data) );
			break;
 // IP of myself (after connect?)
		case GNL_MYIP:
			if( lpClient->saSource )
				return *(uint32_t*)(lpClient->saSource->sa_data+2);
			break;
			//TODO if less than zero return a (high/low)portion of the  hardware address (MAC).
		}
	}
	else if( nLong < globalNetworkData.nUserData )
	{
		return lpClient->lpUserData[nLong];
	}
   //spv:980303
	return (uintptr_t)-1;
}
//----------------------------------------------------------------------------
 // return a copy of this address...
SOCKADDR* DuplicateAddressEx( SOCKADDR *pAddr DBG_PASS )
{
	POINTER tmp = (POINTER)( ( (uintptr_t)pAddr ) - 2*sizeof(uintptr_t) );
	SOCKADDR *dup = AllocAddrEx( DBG_VOIDRELAY );
	POINTER tmp2 = (POINTER)( ( (uintptr_t)dup ) - 2*sizeof(uintptr_t) );
	MemCpy( tmp2, tmp, SOCKADDR_LENGTH( pAddr ) + 2*sizeof(uintptr_t) );
	if( ((char**)( ( (uintptr_t)pAddr ) - sizeof(char*) ))[0] )
		( (char**)( ( (uintptr_t)dup ) - sizeof( char* ) ) )[0]
				= strdup( ((char**)( ( (uintptr_t)pAddr ) - sizeof( char* ) ))[0] );
	return dup;
}
//---------------------------------------------------------------------------
NETWORK_PROC( SOCKADDR *,CreateAddress_hton)( uint32_t dwIP,uint16_t nHisPort)
{
	SOCKADDR_IN *lpsaAddr=(SOCKADDR_IN*)AllocAddr();
	if (!lpsaAddr)
		return(NULL);
	SET_SOCKADDR_LENGTH( lpsaAddr, IN_SOCKADDR_LENGTH );
         // InetAddress Type.
	lpsaAddr->sin_family       = AF_INET;
	lpsaAddr->sin_addr.S_un.S_addr  = htonl(dwIP);
	lpsaAddr->sin_port         = htons(nHisPort);
	return((SOCKADDR*)lpsaAddr);
}
//---------------------------------------------------------------------------
#if defined( __LINUX__ ) && !defined( __CYGWIN__ )
 #define UNIX_PATH_MAX	 108
struct sockaddr_un {
#ifdef __MAC__
	u_char   sa_len;
#endif
	sa_family_t  sun_family;
	char	       sun_path[UNIX_PATH_MAX];
};
NETWORK_PROC( SOCKADDR *,CreateUnixAddress)( CTEXTSTR path )
{
	struct sockaddr_un *lpsaAddr;
#ifdef UNICODE
	char *tmp_path = CStrDup( path );
#endif
   lpsaAddr=(struct sockaddr_un*)AllocAddr();
	if (!lpsaAddr)
		return(NULL);
	((uintptr_t*)lpsaAddr)[-1] = StrLen( path ) + 1;
	lpsaAddr->sun_family = PF_UNIX;
#ifdef UNICODE
	strncpy( lpsaAddr->sun_path, tmp_path, 107 );
	Deallocate( char*, tmp_path );
#else
	strncpy( lpsaAddr->sun_path, path, 107 );
#endif
#ifdef __MAC__
	lpsaAddr->sa_len = 2+strlen( lpsaAddr->sun_path );
#endif
	return((SOCKADDR*)lpsaAddr);
}
#else
NETWORK_PROC( SOCKADDR *,CreateUnixAddress)( CTEXTSTR path )
{
	lprintf( WIDE( "-- CreateUnixAddress -- not available. " ) );
	return NULL;
}
#endif
//---------------------------------------------------------------------------
SOCKADDR *CreateAddress( uint32_t dwIP,uint16_t nHisPort)
{
	SOCKADDR_IN *lpsaAddr=(SOCKADDR_IN*)AllocAddr();
	if (!lpsaAddr)
		return(NULL);
	SET_SOCKADDR_LENGTH( lpsaAddr, IN_SOCKADDR_LENGTH );
         // InetAddress Type.
	lpsaAddr->sin_family	    = AF_INET;
	lpsaAddr->sin_addr.S_un.S_addr  = dwIP;
	lpsaAddr->sin_port         = htons(nHisPort);
	return((SOCKADDR*)lpsaAddr);
}
//---------------------------------------------------------------------------
SOCKADDR *CreateRemote( CTEXTSTR lpName,uint16_t nHisPort)
{
	SOCKADDR_IN *lpsaAddr;
	int conversion_success = FALSE;
	char *tmpName = NULL;
#ifdef UNICODE
	char *_lpName = CStrDup( lpName );
#  define lpName _lpName
#endif
#ifndef WIN32
	PHOSTENT phe;
	// a IP type name will never have a / in it, therefore
	// we can assume it's a unix type address....
	if( lpName && StrChr( lpName, '/' ) )
		return CreateUnixAddress( lpName );
#endif
	if( lpName[0] == '[' && lpName[StrLen( lpName ) - 1] == ']' ) {
		size_t len;
		tmpName = NewArray( char, len = StrLen( lpName ) );
		memcpy( tmpName, lpName + 1, len - 2 );
		tmpName[len - 2] = 0;
		lpName = tmpName;
	}
	lpsaAddr=(SOCKADDR_IN*)AllocAddr();
	if( !lpsaAddr )
	{
#ifdef UNICODE
		Deallocate( char *, _lpName );
#endif
		return(NULL);
	}
	SetAddrName( (SOCKADDR*)lpsaAddr, lpName );
	// if it's a numeric name... attempt to use as an address.
#ifdef __LINUX__
	if( lpName &&
		( lpName[0] >= '0' && lpName[0] <= '9' )
	  && StrChr( lpName, '.' ) )
	{
#ifdef UNICODE
		char *tmp = CStrDup( lpName );
		if( inet_pton( AF_INET, tmp, (struct in_addr*)&lpsaAddr->sin_addr ) > 0 )
		{
			SET_SOCKADDR_LENGTH( lpsaAddr, IN_SOCKADDR_LENGTH );
         // InetAddress Type.
			lpsaAddr->sin_family       = AF_INET;
			conversion_success = TRUE;
		}
		Deallocate( char *, tmp );
#else
		if( inet_pton( AF_INET, lpName, (struct in6_addr*)&lpsaAddr->sin_addr ) > 0 )
		{
			SET_SOCKADDR_LENGTH( lpsaAddr, IN_SOCKADDR_LENGTH );
         // InetAddress Type.
			lpsaAddr->sin_family       = AF_INET;
			conversion_success = TRUE;
		}
#endif
	}
	else if( lpName
		   && ( ( lpName[0] >= '0' && lpName[0] <= '9' )
		      || ( lpName[0] >= 'a' && lpName[0] <= 'f' )
		      || ( lpName[0] >= 'A' && lpName[0] <= 'F' )
		      || lpName[0] == ':'
		      || ( lpName[0] == '[' && lpName[StrLen( lpName ) - 1] == ']' ) )
		   && StrChr( lpName, ':' )!=StrRChr( lpName, ':' ) )
	{
#ifdef UNICODE
		char *tmp = CStrDup( lpName );
		if( inet_pton( AF_INET6, tmp, (struct in_addr*)&lpsaAddr->sin_addr ) > 0 )
		{
			SET_SOCKADDR_LENGTH( lpsaAddr, IN6_SOCKADDR_LENGTH );
         // InetAddress Type.
			lpsaAddr->sin_family       = AF_INET6;
			conversion_success = TRUE;
		}
		Deallocate( char *, tmp );
#else
		if( inet_pton( AF_INET6, lpName, (struct in6_addr*)&lpsaAddr->sin_addr ) > 0 )
		{
			SET_SOCKADDR_LENGTH( lpsaAddr, IN6_SOCKADDR_LENGTH );
         // InetAddress Type.
			lpsaAddr->sin_family       = AF_INET6;
			conversion_success = TRUE;
		}
#endif
	}
#endif
	if( !conversion_success )
	{
		if( lpName )
		{
#ifdef WIN32
			{
				struct addrinfo *result;
				struct addrinfo *test;
				int error;
				error = getaddrinfo( lpName, NULL, NULL, (struct addrinfo**)&result );
				if( error == 0 )
				{
					for( test = result; test; test = test->ai_next )
					{
						//SOCKADDR *tmp;
						//AddLink( &globalNetworkData.addresses, tmp = AllocAddr() );
						MemCpy( lpsaAddr, test->ai_addr, test->ai_addrlen );
						SET_SOCKADDR_LENGTH( lpsaAddr, test->ai_addrlen );
						break;
					}
				}
				else
					lprintf( WIDE( "getaddrinfo Error: %d for [%s]" ), error, lpName );
			}
 //WIN32
#else
			char *tmp = CStrDup( lpName );
//!(phe=gethostbyname(tmp)))
			if( 1 )
			{
				if( !(phe=gethostbyname2(tmp,AF_INET6) ) )
				{
					if( !(phe=gethostbyname2(tmp,AF_INET) ) )
					{
						 // could not find the name in the host file.
						Log1( WIDE("Could not Resolve to %s"), lpName );
						Deallocate(SOCKADDR_IN*, lpsaAddr);
						Deallocate( char*, tmp );
						if( tmpName ) Deallocate( char*, tmpName );
						return(NULL);
					}
					else
					{
						lprintf( WIDE( "Strange, gethostbyname failed, but AF_INET worked..." ) );
						SET_SOCKADDR_LENGTH( lpsaAddr, IN_SOCKADDR_LENGTH );
						lpsaAddr->sin_family = AF_INET;
           // save IP address from host entry.
						memcpy( &lpsaAddr->sin_addr.S_un.S_addr,
							 phe->h_addr,
							 phe->h_length);
					}
				}
				else
				{
					SET_SOCKADDR_LENGTH( lpsaAddr, IN6_SOCKADDR_LENGTH );
         // InetAddress Type.
					lpsaAddr->sin_family = AF_INET6;
#if note
	{
		__SOCKADDR_COMMON (sin6_);
		n_port_t sin6_port;
		uint32_t sin6_flowinfo;
		struct in6_addr sin6_addr;
		uint32_t sin6_scope_id;
	};
#endif
           // save IP address from host entry.
					memcpy( ((struct sockaddr_in6*)lpsaAddr)->sin6_addr.s6_addr,
							 phe->h_addr,
							 phe->h_length);
				}
			}
			else
			{
				Deallocate( char *, tmp );
				SET_SOCKADDR_LENGTH( lpsaAddr, IN_SOCKADDR_LENGTH );
         // InetAddress Type.
				lpsaAddr->sin_family = AF_INET;
           // save IP address from host entry.
				memcpy( &lpsaAddr->sin_addr.S_un.S_addr,
					 phe->h_addr,
					 phe->h_length);
			}
#endif
		}
		else
		{
         // InetAddress Type.
			lpsaAddr->sin_family      = AF_INET;
			lpsaAddr->sin_addr.S_un.S_addr = 0;
			SET_SOCKADDR_LENGTH( lpsaAddr, IN_SOCKADDR_LENGTH );
		}
	}
#ifdef UNICODE
	Deallocate( char *, _lpName );
#  undef lpName
#endif
	// put in his(destination) port number...
	if( tmpName ) Deallocate( char*, tmpName );
	lpsaAddr->sin_port         = htons(nHisPort);
	return((SOCKADDR*)lpsaAddr);
}
//----------------------------------------------------------------------------
#ifdef __cplusplus
namespace udp {
#endif
NETWORK_PROC( void, DumpAddrEx)( CTEXTSTR name, SOCKADDR *sa DBG_PASS )
	{
		if( !sa ) { _lprintf(DBG_RELAY)( "%s: NULL", name ); return; }
		LogBinary( (uint8_t *)sa, SOCKADDR_LENGTH( sa ) );
		if( sa->sa_family == AF_INET ) {
			_lprintf(DBG_RELAY)( WIDE("%s: (%s) %d.%d.%d.%d:%d "), name
			       , ( ((uintptr_t*)sa)[-1] & 0xFFFF0000 )?( ((char**)sa)[-1] ) : "no name"
			       //*(((unsigned char *)sa)+0),
			       //*(((unsigned char *)sa)+1),
			       ,*(((unsigned char *)sa)+4),
			       *(((unsigned char *)sa)+5),
			       *(((unsigned char *)sa)+6),
			       *(((unsigned char *)sa)+7)
			       , ntohs( *(((unsigned short *)((unsigned char*)sa + 2))) )
			);
		} else if( sa->sa_family == AF_INET6 )
		{
			lprintf( WIDE( "Socket address binary: %s" ), name );
			_lprintf(DBG_RELAY)( WIDE("%s: (%s) %03d %04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x ")
					 , name
					, ( ((uintptr_t*)sa)[-1] & 0xFFFF0000 )?( ((char**)sa)[-1] ) : "no name"
					 , ntohs(*(((unsigned short *)((unsigned char*)sa+2))))
					 , ntohs(*(((unsigned short *)((unsigned char*)sa+8))))
					 , ntohs(*(((unsigned short *)((unsigned char*)sa+10))))
					 , ntohs(*(((unsigned short *)((unsigned char*)sa+12))))
					 , ntohs(*(((unsigned short *)((unsigned char*)sa+14))))
					 , ntohs(*(((unsigned short *)((unsigned char*)sa+16))))
					 , ntohs(*(((unsigned short *)((unsigned char*)sa+18))))
					 , ntohs(*(((unsigned short *)((unsigned char*)sa+20))))
					 , ntohs(*(((unsigned short *)((unsigned char*)sa+22))))
					 );
		}
}
#ifdef __cplusplus
}
#endif
//----------------------------------------------------------------------------
NETWORK_PROC( SOCKADDR *, SetAddressPort )( SOCKADDR *pAddr, uint16_t nDefaultPort )
{
	if( pAddr )
		((SOCKADDR_IN *)pAddr)->sin_port = htons(nDefaultPort);
	return pAddr;
}
//----------------------------------------------------------------------------
NETWORK_PROC( SOCKADDR *, SetNonDefaultPort )( SOCKADDR *pAddr, uint16_t nDefaultPort )
{
	if( pAddr && !((SOCKADDR_IN *)pAddr)->sin_port )
		((SOCKADDR_IN *)pAddr)->sin_port = htons(nDefaultPort);
	return pAddr;
}
//----------------------------------------------------------------------------
NETWORK_PROC( SOCKADDR *,CreateSockAddress)(CTEXTSTR name, uint16_t nDefaultPort )
{
// blah... should process a ip:port - but - default port?!
	uint32_t bTmpName = 0;
	char * tmp;
	SOCKADDR *sa = NULL;
	char *port;
	uint16_t wPort;
	CTEXTSTR portName = name;
#ifdef UNICODE
	char *_name = CStrDup( name );
#  define name _name
#endif
	if( name[0] == '[' ) {
		while( portName[0] && portName[0] != ']' )
			portName++;
		if( portName[0] ) portName++;
	}
	if( name && portName[0] && ( port = (char*)strrchr( portName, ':' ) ) )
	{
		tmp = StrDup( name );
		bTmpName = 1;
		port = tmp + (port-name);
		name = tmp;
		//Log1( WIDE("Found ':' assuming %s is IP:PORT"), name );
		*port = 0;
		port++;
  // a trailing : could be IPV6 abbreviation.
		if( port[0] )
		{
			if( isdigit( *port ) )
			{
				wPort = (short)atoi( port );
			}
			else
			{
				struct servent *se;
				se = getservbyname( port, NULL );
				if( !se )
				{
#ifdef UNICODE
#define FMT WIDE("S")
#else
#define FMT WIDE("s")
#endif
					Log1( WIDE("Could not resolve \"%" ) FMT WIDE("\" as a valid service name"), port );
					//return NULL;
					wPort = nDefaultPort;
				}
				else
					wPort = htons(se->s_port);
				//Log1( WIDE("port alpha - name resolve to %d"), wPort );
			}
		}
		else
			wPort = nDefaultPort;
#ifdef UNICODE
#  undef name
#endif
		sa = CreateRemote( name, wPort );
		if( port )
		{
  // incase we obliterated it
			port[-1] = ':';
		}
	}
  // no port specification...
	else
	{
		//Log1( WIDE("%s does not have a ':'"), name );
		sa = CreateRemote( name, nDefaultPort );
	}
#ifdef UNICODE
	Deallocate( char *, _name );
#endif
	if( bTmpName ) Deallocate( char*, tmp );
	return sa;
}
//----------------------------------------------------------------------------
SOCKADDR *CreateLocal(uint16_t nMyPort)
{
	char lpHostName[HOSTNAME_LEN];
	if (gethostname(lpHostName,HOSTNAME_LEN))
	{
		return(NULL);
	}
	return CreateRemote( WIDE("0.0.0.0"), nMyPort );
}
//----------------------------------------------------------------------------
LOGICAL CompareAddressEx( SOCKADDR *sa1, SOCKADDR *sa2, int method )
{
	if( method == SA_COMPARE_FULL )
	{
		if( sa1 && sa2 )
		{
			if( ((SOCKADDR_IN*)sa1)->sin_family == ((SOCKADDR_IN*)sa2)->sin_family )
			{
				switch( ((SOCKADDR_IN*)sa1)->sin_family )
				{
				case AF_INET:
					{
						SOCKADDR_IN *sin1 = (SOCKADDR_IN*)sa1;
						SOCKADDR_IN *sin2 = (SOCKADDR_IN*)sa2;
						if( MemCmp( sin1, sin2, sizeof( SOCKADDR_IN ) ) == 0 )
							return 1;
					}
					break;
				default:
					xlprintf( LOG_ALWAYS )( WIDE("unhandled address type passed to compare, resulting FAILURE") );
					return 0;
				}
			}
		}
	}
	else
	{
		if( sa1 && sa2 )
		{
			if( ((SOCKADDR_IN*)sa1)->sin_family == ((SOCKADDR_IN*)sa2)->sin_family )
			{
				switch( ((SOCKADDR_IN*)sa1)->sin_family )
				{
				case AF_INET:
					{
						if( MemCmp( &((SOCKADDR_IN*)sa1)->sin_addr, &((SOCKADDR_IN*)sa2)->sin_addr, sizeof( ((SOCKADDR_IN*)sa2)->sin_addr ) ) == 0 )
							return 1;
					}
					break;
				default:
					xlprintf( LOG_ALWAYS )( WIDE("unhandled address type passed to compare, resulting FAILURE") );
					return 0;
				}
			}
		}
	}
	return 0;
}
//----------------------------------------------------------------------------
LOGICAL CompareAddress( SOCKADDR *sa1, SOCKADDR *sa2 )
{
	return CompareAddressEx( sa1, sa2, SA_COMPARE_FULL );
}
//----------------------------------------------------------------------------
PLIST GetLocalAddresses( void )
{
	return globalNetworkData.addresses;
}
//----------------------------------------------------------------------------
LOGICAL IsThisAddressMe( SOCKADDR *addr, uint16_t myport )
{
	struct interfaceAddress *test_addr;
	INDEX idx;
	LIST_FORALL( globalNetworkData.addresses, idx, struct interfaceAddress *, test_addr )
	{
		if( ((SOCKADDR_IN*)addr)->sin_family == ((SOCKADDR_IN*)test_addr->sa)->sin_family )
		{
			switch( ((SOCKADDR_IN*)addr)->sin_family )
			{
			case AF_INET:
				{
					if( MemCmp( &((SOCKADDR_IN*)addr)->sin_addr, &((SOCKADDR_IN*)test_addr->sa)->sin_addr, sizeof(((SOCKADDR_IN*)addr)->sin_addr)  ) == 0 )
					{
						return TRUE;
					}
				}
				break;
			default:
				lprintf( WIDE( "Unknown comparison" ) );
			}
		}
	}
	return FALSE;
}
//----------------------------------------------------------------------------
LOGICAL IsBroadcastAddressForInterface( struct interfaceAddress *address, SOCKADDR *addr ) {
	if( addr->sa_family == AF_INET ) {
      //lprintf( "can test for broadcast... %08x %08x %08x", ( ((uint32_t*)(address->saMask->sa_data+2))[0] | ((uint32_t*)(addr->sa_data+2))[0] ), ((uint32_t*)address->saMask->sa_data)[0] , ((uint32_t*)addr->sa_data)[0] );
		if( ( ((uint32_t*)(address->saMask->sa_data+2))[0] | ((uint32_t*)(addr->sa_data+2))[0] ) == 0xFFFFFFFFU )
         return TRUE;
	}
   return FALSE;
}
//----------------------------------------------------------------------------
struct interfaceAddress* GetInterfaceForAddress( SOCKADDR *addr )
{
	struct interfaceAddress *test_addr;
	INDEX idx;
	if( !globalNetworkData.addresses )
		LoadNetworkAddresses();
	LIST_FORALL( globalNetworkData.addresses, idx, struct interfaceAddress *, test_addr )
	{
		if( ((SOCKADDR_IN*)addr)->sin_family == ((SOCKADDR_IN*)test_addr->sa)->sin_family )
		{
			switch( ((SOCKADDR_IN*)addr)->sin_family )
			{
			case AF_INET:
				{
					if( MemCmp( &((SOCKADDR_IN*)addr)->sin_addr, test_addr->sa->sa_data + 2, sizeof(((SOCKADDR_IN*)addr)->sin_addr)  ) == 0 )
					{
						return test_addr;
					}
				}
				break;
			case AF_INET6:
				{
					if( MemCmp( &((SOCKADDR_IN*)addr)->sin_addr, test_addr->sa->sa_data + 2, 16 ) == 0 )
					{
						return test_addr;
					}
				}
				break;
			default:
				lprintf( WIDE( "Unknown comparison" ) );
			}
		}
	}
	return NULL;
}
//----------------------------------------------------------------------------
SOCKADDR* GetBroadcastAddressForInterface( SOCKADDR *addr )
{
	struct interfaceAddress *test_addr;
	INDEX idx;
	if( !globalNetworkData.addresses )
		LoadNetworkAddresses();
	LIST_FORALL( globalNetworkData.addresses, idx, struct interfaceAddress *, test_addr )
	{
		if( ((SOCKADDR_IN*)addr)->sin_family == ((SOCKADDR_IN*)test_addr->sa)->sin_family )
		{
			switch( ((SOCKADDR_IN*)addr)->sin_family )
			{
			case AF_INET:
				{
					if( MemCmp( &((SOCKADDR_IN*)addr)->sin_addr, test_addr->sa->sa_data + 2, sizeof(((SOCKADDR_IN*)addr)->sin_addr)  ) == 0 )
					{
						return test_addr->saBroadcast;
					}
				}
				break;
			case AF_INET6:
				{
					if( MemCmp( &((SOCKADDR_IN*)addr)->sin_addr, test_addr->sa->sa_data + 2, 16 ) == 0 )
					{
						return test_addr->saBroadcast;
					}
				}
				break;
			default:
				lprintf( WIDE( "Unknown comparison" ) );
			}
		}
	}
	return FALSE;
}
//----------------------------------------------------------------------------
SOCKADDR* GetInterfaceAddressForBroadcast( SOCKADDR *addr )
{
	struct interfaceAddress *test_addr;
	INDEX idx;
	if( !globalNetworkData.addresses )
		LoadNetworkAddresses();
	LIST_FORALL( globalNetworkData.addresses, idx, struct interfaceAddress *, test_addr )
	{
		if( ((SOCKADDR_IN*)addr)->sin_family == ((SOCKADDR_IN*)test_addr->sa)->sin_family )
		{
			switch( ((SOCKADDR_IN*)addr)->sin_family )
			{
			case AF_INET:
				{
					if( MemCmp( &((SOCKADDR_IN*)addr)->sin_addr, test_addr->saBroadcast->sa_data + 2, 4 ) == 0 )
					{
						return test_addr->sa;
					}
				}
				break;
			case AF_INET6:
				{
					if( MemCmp( &((SOCKADDR_IN*)addr)->sin_addr, test_addr->saBroadcast->sa_data + 2, 16  ) == 0 )
					{
						return test_addr->sa;
					}
				}
				break;
			default:
				lprintf( WIDE( "Unknown comparison" ) );
			}
		}
	}
	return FALSE;
}
//----------------------------------------------------------------------------
void ReleaseAddress(SOCKADDR *lpsaAddr)
{
	// sockaddr is often skewed from what I would expect it. (contains its own length)
	if( lpsaAddr )
	{
		/* strdup is used for the addr part so use free instead of release */
		free( ((POINTER*)( ( (uintptr_t)lpsaAddr ) - sizeof(uintptr_t) ))[0] );
		Deallocate(POINTER, (POINTER)( ( (uintptr_t)lpsaAddr ) - 2 * sizeof(uintptr_t) ));
	}
}
//----------------------------------------------------------------------------
// creates class C broadcast address
SOCKADDR *CreateBroadcast(uint16_t nPort)
{
	SOCKADDR_IN *bcast=(SOCKADDR_IN*)AllocAddr();
	SOCKADDR *lpMyAddr;
	if (!bcast)
		return(NULL);
	lpMyAddr = CreateLocal(0);
	SET_SOCKADDR_LENGTH( bcast, IN_SOCKADDR_LENGTH );
	bcast->sin_family	    = AF_INET;
	bcast->sin_addr.S_un.S_addr  = ((SOCKADDR_IN*)lpMyAddr)->sin_addr.S_un.S_addr;
 // Fake a subnet broadcast address
	bcast->sin_addr.S_un.S_un_b.s_b4 = 0xFF;
	bcast->sin_port        = htons(nPort);
	ReleaseAddress(lpMyAddr);
	return((SOCKADDR*)bcast);
}
//----------------------------------------------------------------------------
void DumpSocket( PCLIENT pc )
{
	DumpAddr( WIDE("REMOT"), pc->saClient );
	DumpAddr( WIDE("LOCAL"), pc->saSource );
	return;
}
#ifdef __cplusplus
namespace udp {
#endif
#undef DumpAddr
NETWORK_PROC( void, DumpAddr)( CTEXTSTR name, SOCKADDR *sa )
{
	DumpAddrEx( name, sa DBG_SRC );
}
#ifdef __cplusplus
}
#endif
//----------------------------------------------------------------------------
NETWORK_PROC( PCLIENT, NetworkLockEx)( PCLIENT lpClient, int readWrite DBG_PASS )
{
	if( lpClient )
	{
	start_lock:
		//lpClient->dwFlags |= CF_WANTS_GLOBAL_LOCK;
		//_lprintf(DBG_RELAY)( WIDE( "Lock %p" ), lpClient );
#ifdef USE_NATIVE_CRITICAL_SECTION
		if( EnterCriticalSecNoWait( &globalNetworkData.csNetwork, NULL ) < 1 )
#else
		if( EnterCriticalSecNoWaitEx( &globalNetworkData.csNetwork, NULL DBG_RELAY ) < 1 )
#endif
		{
			//lpClient->dwFlags &= ~CF_WANTS_GLOBAL_LOCK;
#ifdef LOG_NETWORK_LOCKING
			_lprintf(DBG_RELAY)( WIDE( "Failed enter global? %llx" ), globalNetworkData.csNetwork.dwThreadID  );
#endif
			Relinquish();
			return NULL;
			//DebugBreak();
		}
#ifdef LOG_NETWORK_LOCKING
		_lprintf( DBG_RELAY )( WIDE( "Got global lock %p %d" ), lpClient, readWrite );
#endif
		//lpClient->dwFlags &= ~CF_WANTS_GLOBAL_LOCK;
#ifdef USE_NATIVE_CRITICAL_SECTION
		if( !EnterCriticalSecNoWait( (readWrite? &lpClient->csLockRead:&lpClient->csLockWrite), NULL ) )
#else
		if( EnterCriticalSecNoWaitEx( ( readWrite ?&lpClient->csLockRead : &lpClient->csLockWrite ), NULL DBG_RELAY ) < 1 )
#endif
		{
			// unlock the global section for a moment..
			// client may be requiring both local and global locks (already has local lock)
#ifdef USE_NATIVE_CRITICAL_SECTION
			LeaveCriticalSec( &globalNetworkData.csNetwork);
#else
			LeaveCriticalSecEx( &globalNetworkData.csNetwork  DBG_RELAY);
#endif
			//lprintf( "Idle... socket lock failed, had global though..." );
			Relinquish();
			goto start_lock;
		}
		//EnterCriticalSec( readWrite ? &lpClient->csLockRead : &lpClient->csLockWrite );
#ifdef USE_NATIVE_CRITICAL_SECTION
		LeaveCriticalSec( &globalNetworkData.csNetwork );
#else
		LeaveCriticalSecEx( &globalNetworkData.csNetwork  DBG_RELAY);
#endif
		if( !(lpClient->dwFlags & (CF_ACTIVE|CF_CLOSED) ) )
		{
			// change to inactive status by the time we got here...
#ifdef USE_NATIVE_CRITICAL_SECTION
			LeaveCriticalSec( readWrite ? &lpClient->csLockRead : &lpClient->csLockWrite );
#else
			LeaveCriticalSecEx( readWrite?&lpClient->csLockRead:&lpClient->csLockWrite DBG_RELAY );
#endif
			_lprintf( DBG_RELAY )( WIDE( "Failed lock" ) );
			lprintf( WIDE( "%p  %08x %08x inactive, cannot lock." ), lpClient, lpClient->dwFlags, CF_ACTIVE );
			// this client is not available for client use!
			return NULL;
		}
	}
#ifdef LOG_NETWORK_LOCKING
		_lprintf( DBG_RELAY )( WIDE( "Got private lock %p %d" ), lpClient, readWrite );
#endif
	return lpClient;
}
//----------------------------------------------------------------------------
NETWORK_PROC( void, NetworkUnlockEx)( PCLIENT lpClient, int readWrite DBG_PASS )
{
	//_lprintf(DBG_RELAY)( WIDE( "Unlock %p" ), lpClient );
	// simple unlock.
	if( lpClient )
	{
#ifdef LOG_NETWORK_LOCKING
		_lprintf( DBG_RELAY )( WIDE( "Leave private lock %p %d" ), lpClient, readWrite );
#endif
#ifdef USE_NATIVE_CRITICAL_SECTION
		LeaveCriticalSec( readWrite ? &lpClient->csLockRead : &lpClient->csLockWrite );
#else
		LeaveCriticalSecEx( readWrite?&lpClient->csLockRead:&lpClient->csLockWrite DBG_RELAY );
#endif
	}
}
//----------------------------------------------------------------------------
void InternalRemoveClientExx(PCLIENT lpClient, LOGICAL bBlockNotify, LOGICAL bLinger DBG_PASS )
{
#ifdef LOG_SOCKET_CREATION
	_lprintf( DBG_RELAY )( WIDE("InternalRemoveClient Removing this client %p (%d)"), lpClient, lpClient->Socket );
#endif
	if( lpClient && IsValid(lpClient->Socket) )
	{
		if( !bLinger )
		{
#ifdef LOG_DEBUG_CLOSING
			lprintf( WIDE("Setting quick close?!") );
#endif
			if( 0 )
			{
				int nAllowReuse = 1;
				if (setsockopt(lpClient->Socket, SOL_SOCKET, SO_REUSEADDR,
									(char*)&nAllowReuse, sizeof(nAllowReuse)) <0 )
				{
					//cerr << "NFMSim:setHost:ERROR: could not set socket to reuse addr." << endl;
				}
				/*
				// missing symbol in windows?
				if (setsockopt(lpClient->Socket, SOL_SOCKET, SO_REUSEPORT,
									(char*)&nAllowReuse, sizeof(nAllowReuse)) <0 )
				{
					//cerr << "NFMSim:setHost:ERROR: could not set socket to reuse port." << endl;
					}
				*/
			}
			if( 1 )
			{
				// www.serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html
				//  the idea is to NEVER do this; but I had to do this for lots of parallel connections that were short lived...
				// windows registry http://technet.microsoft.com/en-us/library/cc938217.aspx 240 seconds time_wait timeout
				struct linger lingerSet;
 // on , with no time = off.
				lingerSet.l_onoff = 1;
 // 0 timeout sends reset.
				lingerSet.l_linger = 0;
										 // set server to allow reuse of socket port
            //lprintf( "Set no linger" );
				if (setsockopt(lpClient->Socket, SOL_SOCKET, SO_LINGER,
									(char*)&lingerSet, sizeof(lingerSet)) <0 )
				{
					lprintf( WIDE( "error setting no linger in close." ) );
					//cerr << "NFMSim:setHost:ERROR: could not set socket to linger." << endl;
				}
			}
		}
		else {
			struct linger lingerSet;
			// linger ON causes delay on close... otherwise close returns immediately
 // on , with no time = off.
			lingerSet.l_onoff = 1;
			lingerSet.l_linger = 2;
			// set server to allow reuse of socket port
			if( setsockopt( lpClient->Socket, SOL_SOCKET, SO_LINGER,
				(char*)&lingerSet, sizeof( lingerSet ) ) <0 )
			{
				lprintf( WIDE( "error setting 2 second linger in close." ) );
			}
		}
		if( !(lpClient->dwFlags & CF_ACTIVE) )
		{
			if( lpClient->dwFlags & CF_AVAILABLE )
			{
				lprintf( WIDE("Client was inactive?!?!?! removing from list and putting in available") );
				AddAvailable( GrabClient( lpClient ) );
			}
			// this is probably true, we've definatly already moved it from
			// active list to clsoed list.
			else if( !(lpClient->dwFlags & CF_CLOSED) )
			{
#ifdef LOG_DEBUG_CLOSING
				lprintf( WIDE("Client was NOT already closed?!?!") );
#endif
				AddClosed( GrabClient( lpClient ) );
			}
#ifdef LOG_DEBUG_CLOSING
			else
				lprintf( WIDE("Client's state is CLOSED") );
#endif
			return;
		}
		if( lpClient->lpFirstPending || ( lpClient->dwFlags & CF_WRITEPENDING ) ) {
#ifdef LOG_DEBUG_CLOSING
			lprintf( "CLOSE WHILE WAITING FOR WRITE TO FINISH..." );
#endif
			lpClient->dwFlags |= CF_TOCLOSE;
			return;
		}
		while( !NetworkLockEx( lpClient, 0 DBG_SRC ) )
		{
			if( !(lpClient->dwFlags & CF_ACTIVE ) )
			{
				return;
			}
			Relinquish();
		}
		while( !NetworkLockEx( lpClient, 1 DBG_SRC ) )
		{
			if( !(lpClient->dwFlags & CF_ACTIVE) )
			{
				return;
			}
			Relinquish();
		}
		// allow application a chance to clean it's references
		// to this structure before closing and cleaning it.
		if( !bBlockNotify )
		{
			lpClient->dwFlags |= CF_CONNECT_CLOSED;
			if( lpClient->pWaiting )
			{
				WakeThread( lpClient->pWaiting );
				while( lpClient->dwFlags & CF_CONNECT_WAITING )
					Relinquish();
			}
			lpClient->dwFlags &= ~CF_CONNECT_CLOSED;
 // prevent multiple notifications...
			if( !(lpClient->dwFlags & CF_CLOSING) )
			{
#ifdef LOG_DEBUG_CLOSING
				lprintf( WIDE( "Marked closing first, and dispatching callback?" ) );
#endif
				lpClient->dwFlags |= CF_CLOSING;
				if( lpClient->close.CloseCallback )
				{
					// during thisi if it wants a lock... and the application
					// is dispatching like
					if( lpClient->dwFlags & CF_CPPCLOSE )
						lpClient->close.CPPCloseCallback( lpClient->psvClose );
					else
						lpClient->close.CloseCallback( lpClient );
				}
#ifdef LOG_DEBUG_CLOSING
				else
					lprintf( WIDE( "no close callback!?" ) );
#endif
				// leave the flag closing set... we'll use that later
				// to avoid the double-lock;
				//lpClient->dwFlags &= ~CF_CLOSING;
			}
#ifdef LOG_DEBUG_CLOSING
			else
				lprintf( WIDE( "socket was already ispatched callback?" ) );
#endif
		}
		else
		{
#ifdef LOG_DEBUG_CLOSING
			lprintf( WIDE( "blocknotify on close..." ) );
#endif
		}
		EnterCriticalSec( &globalNetworkData.csNetwork );
#ifdef LOG_DEBUG_CLOSING
		lprintf( WIDE( "Adding current client to closed clients." ) );
#endif
		AddClosed( GrabClient( lpClient ) );
#ifdef LOG_DEBUG_CLOSING
		lprintf( WIDE( "Leaving client critical section" ) );
#endif
		//lprintf( WIDE( "Leaving network critical section" ) );
		LeaveCriticalSec( &globalNetworkData.csNetwork );
		NetworkUnlockEx( lpClient, 0 DBG_SRC );
		NetworkUnlockEx( lpClient, 1 DBG_SRC );
	}
#ifdef LOG_DEBUG_CLOSING
	else
	{
		lprintf( WIDE("No Client, or socket already closed?") );
	}
#endif
}
void RemoveClientExx(PCLIENT lpClient, LOGICAL bBlockNotify, LOGICAL bLinger DBG_PASS )
{
#ifdef _WIN32
#  define SHUT_WR SD_SEND
#endif
	if( !lpClient ) return;
#if 0
	if( !( lpClient->dwFlags & CF_UDP ) ) {
		lprintf( "TRIGGER SHUTDOWN WRITES" );
		shutdown( lpClient->Socket, SHUT_WR );
	} else
#endif
	{
		int n = 0;
		// UDP still needs to be done this way...
		//
		InternalRemoveClientExx( lpClient, bBlockNotify, bLinger DBG_RELAY );
#ifndef __LINUX__
		if( NetworkLock( lpClient, 0 ) && ((n=1),NetworkLock( lpClient, 1 )) ) {
			TerminateClosedClient( lpClient );
			NetworkUnlock( lpClient, 0 );
			NetworkUnlock( lpClient, 1 );
		}
		else if( n ) {
			NetworkUnlock( lpClient, 0 );
		}
#endif
	}
}
CTEXTSTR GetSystemName( void )
{
	// start the network with defaults... we're able to reallocate later.
#ifdef __ANDROID__
#if 0
	// dont' actually have to start winsock; but we do have to do work to get our IP
	int sock_startup = socket( AF_INET, SOCK_RAW, 0);
	if( sock_startup == -1 )
		sock_startup = socket( AF_INET, SOCK_DGRAM, 0);
	if( sock_startup == -1 )
		sock_startup = socket( AF_INET, SOCK_STREAM, 0);
	if( sock_startup >= 0 )
	{
		struct ifconf buffer;
		struct ifreq ifr[10];
		int ifc_num;
		int n;
		buffer.ifc_len = sizeof(ifr);
		buffer.ifc_ifcu.ifcu_buf = (char*)ifr;
		ioctl( sock_startup, SIOCGIFCONF, &buffer);
		ifc_num = buffer.ifc_len / sizeof(struct ifreq);
#define INT_TO_ADDR(_addr) (_addr & 0xFF), (_addr >> 8 & 0xFF), (_addr >> 16 & 0xFF), (_addr >> 24 & 0xFF)
		for( n = 0; n < ifc_num; n++ )
		{
			int sd, ifc_num, addr, bcast, mask, network;
			lprintf( "interface %d : %s", n, ifr[n].ifr_name );
			if (ifr[n].ifr_addr.sa_family != AF_INET)
			{
				continue;
			}
			/* display the interface name */
			lprintf("%d) interface: %s\n", n+1, ifr[n].ifr_name);
			/* Retrieve the IP address, broadcast address, and subnet mask. */
			if (ioctl(sd, SIOCGIFADDR, &ifr[n]) == 0)
			{
				addr = ((struct sockaddr_in *)(&ifr[n].ifr_addr))->sin_addr.s_addr;
				lprintf("%d) address: %d.%d.%d.%d\n", n+1, INT_TO_ADDR(addr));
			}
			if (ioctl(sd, SIOCGIFBRDADDR, &ifr[n]) == 0)
			{
				bcast = ((struct sockaddr_in *)(&ifr[n].ifr_broadaddr))->sin_addr.s_addr;
				lprintf("%d) broadcast: %d.%d.%d.%d\n", n+1, INT_TO_ADDR(bcast));
			}
			if (ioctl(sd, SIOCGIFNETMASK, &ifr[n]) == 0)
			{
				mask = ((struct sockaddr_in *)(&ifr[n].ifr_netmask))->sin_addr.s_addr;
				lprintf("%d) netmask: %d.%d.%d.%d\n", n+1, INT_TO_ADDR(mask));
			}
			/* Compute the current network value from the address and netmask. */
			network = addr & mask;
			lprintf("%d) network: %d.%d.%d.%d\n", n+1, INT_TO_ADDR(network));
		}
		close( sock_startup );
	}
	else
#endif
		globalNetworkData.system_name = WIDE("No Name Available");
#else
	NetworkStart();
#endif
	return globalNetworkData.system_name;
}
#undef NetworkLock
#undef NetworkUnlock
NETWORK_PROC( PCLIENT, NetworkLock)( PCLIENT lpClient, int readWrite )
{
	return NetworkLockEx( lpClient, readWrite DBG_SRC );
}
NETWORK_PROC( void, NetworkUnlock)( PCLIENT lpClient, int readWrite )
{
	NetworkUnlockEx( lpClient, readWrite DBG_SRC );
}
NETWORK_PROC( void, GetNetworkAddressBinary )( SOCKADDR *addr, uint8_t **data, size_t *datalen ) {
	if( addr ) {
		size_t namelen;
		size_t addrlen = SOCKADDR_LENGTH( addr );
		const char * tmp = ((const char**)addr)[-1];
		if( !( (uintptr_t)tmp & 0xFFFF0000 ) )
		{
			lprintf( WIDE("corrupted sockaddr.") );
			DebugBreak();
		}
		if( tmp )
		{
			namelen = StrLen( tmp );
		}
		else
			namelen = 0;
		(*datalen) = namelen + 1 + 1 + SOCKADDR_LENGTH( addr );
		(*data) = NewArray( uint8_t, (*datalen) );
		MemCpy( (*data), tmp, namelen + 1 );
		(*data)[namelen+1] = (uint8_t)addrlen;
		MemCpy( (*data) + namelen + 1, addr, addrlen );
	}
}
NETWORK_PROC( SOCKADDR *, MakeNetworkAddressFromBinary )( uintptr_t *data, size_t datalen ) {
	SOCKADDR *addr = AllocAddr();
	size_t namelen = strlen( (const char*)data );
 // if empty name, don't include it.
	if( namelen )
		SetAddrName( addr, (const char*)data );
	SET_SOCKADDR_LENGTH( addr, data[1] );
	MemCpy( addr, data + 2, data[1] );
	return addr;
}
#ifdef __LINUX__
void LoadNetworkAddresses( void ) {
	struct ifaddrs *addrs, *tmp;
	struct interfaceAddress *ia;
	getifaddrs( &addrs );
	tmp = addrs;
	ia = New( struct interfaceAddress );
	ia->sa = CreateRemote( "0.0.0.0", 0 );
	ia->saMask = NULL;
	ia->saBroadcast = CreateRemote( "255.255.255.255", 0 );
	AddLink( &globalNetworkData.addresses, ia );
	for( ; tmp; tmp = tmp->ifa_next )
	{
		SOCKADDR *dup;
		if( !tmp->ifa_addr )
			continue;
#  ifndef __MAC__
		if( tmp->ifa_addr && tmp->ifa_addr->sa_family == AF_PACKET )
			continue;
#  endif
		ia = New( struct interfaceAddress );
		dup = AllocAddr();
		if( tmp->ifa_addr->sa_family == AF_INET6 ) {
			continue;
			//memcpy( dup, tmp->ifa_addr, IN6_SOCKADDR_LENGTH );
			//SET_SOCKADDR_LENGTH( dup, IN6_SOCKADDR_LENGTH );
		}
		else {
			memcpy( dup, tmp->ifa_addr, IN_SOCKADDR_LENGTH );
			SET_SOCKADDR_LENGTH( dup, IN_SOCKADDR_LENGTH );
		}
		ia->sa = dup;
		dup = AllocAddr();
		if( tmp->ifa_addr->sa_family == AF_INET6 ) {
			//memcpy( dup, tmp->ifa_netmask, IN6_SOCKADDR_LENGTH );
			//SET_SOCKADDR_LENGTH( dup, IN6_SOCKADDR_LENGTH );
		}
		else {
			if( tmp->ifa_netmask ) {
				memcpy( dup, tmp->ifa_netmask, IN_SOCKADDR_LENGTH );
				SET_SOCKADDR_LENGTH( dup, IN_SOCKADDR_LENGTH );
			} else {
				memset( dup, 0, IN_SOCKADDR_LENGTH );
				SET_SOCKADDR_LENGTH( dup, IN_SOCKADDR_LENGTH );
			}
		}
		ia->saMask = dup;
		ia->saBroadcast = AllocAddr();
		ia->saBroadcast->sa_family = ia->sa->sa_family;
		ia->saBroadcast->sa_data[0] = 0;
		ia->saBroadcast->sa_data[1] = 0;
		ia->saBroadcast->sa_data[2] = (ia->sa->sa_data[2] & ia->saMask->sa_data[2]) | (~ia->saMask->sa_data[2]);
		ia->saBroadcast->sa_data[3] = (ia->sa->sa_data[3] & ia->saMask->sa_data[3]) | (~ia->saMask->sa_data[3]);
		ia->saBroadcast->sa_data[4] = (ia->sa->sa_data[4] & ia->saMask->sa_data[4]) | (~ia->saMask->sa_data[4]);
		ia->saBroadcast->sa_data[5] = (ia->sa->sa_data[5] & ia->saMask->sa_data[5]) | (~ia->saMask->sa_data[5]);
		SET_SOCKADDR_LENGTH( ia->saBroadcast, SOCKADDR_LENGTH( ia->sa ) );
		AddLink( &globalNetworkData.addresses, ia );
	}
	freeifaddrs( addrs );
}
#endif
#ifdef _WIN32
#if 0
#ifdef WIN32
	{
		struct addrinfo *result;
		struct addrinfo *test;
#ifdef _UNICODE
		char *tmp = WcharConvert( globalNetworkData.system_name );
		getaddrinfo( tmp, NULL, NULL, (struct addrinfo**)&result );
		Deallocate( char*, tmp );
#else
		getaddrinfo( globalNetworkData.system_name, NULL, NULL, (struct addrinfo**)&result );
#endif
		for( test = result; test; test = test->ai_next )
		{
			//if( test->ai_family == AF_INET )
			{
				SOCKADDR *tmp;
				AddLink( &globalNetworkData.addresses, tmp = AllocAddr() );
				((uintptr_t*)tmp)[-1] = test->ai_addrlen;
				MemCpy( tmp, test->ai_addr, test->ai_addrlen );
				//lprintf( "initialize addres..." );
				//DumpAddr( "blah", tmp );
			}
		}
	}
#endif
#endif
void LoadNetworkAddresses( void ) {
	// Declare and initialize variables
	PIP_INTERFACE_INFO pInfo;
	pInfo = (IP_INTERFACE_INFO *) malloc( sizeof(IP_INTERFACE_INFO) );
	DWORD dwRetVal = 0;
	PIP_ADAPTER_INFO pAdapterInfo;
	PIP_ADAPTER_INFO pAdapter = NULL;
	ULONG ulOutBufLen = sizeof (IP_ADAPTER_INFO);
	pAdapterInfo = New(IP_ADAPTER_INFO);
	if (pAdapterInfo == NULL) {
		lprintf("Error allocating memory needed to call GetAdaptersinfo\n");
		return;
	}
	// Make an initial call to GetAdaptersInfo to get
	// the necessary size into the ulOutBufLen variable
	if (GetAdaptersInfo(pAdapterInfo, &ulOutBufLen) == ERROR_BUFFER_OVERFLOW) {
		Deallocate( PIP_ADAPTER_INFO, pAdapterInfo);
		pAdapterInfo = (IP_ADAPTER_INFO *) NewArray(uint8_t, ulOutBufLen);
		if (pAdapterInfo == NULL) {
			lprintf("Error allocating memory needed to call GetAdaptersinfo\n");
			return;
		}
	}
	if ((dwRetVal = GetAdaptersInfo(pAdapterInfo, &ulOutBufLen)) == NO_ERROR) {
		pAdapter = pAdapterInfo;
		while (pAdapter) {
			PIP_ADDR_STRING ipadd = &pAdapter->IpAddressList;
			for( ; ipadd; ipadd = ipadd->Next ) {
			/*
			typedef struct _IP_ADDR_STRING {
			  struct _IP_ADDR_STRING  *Next;
			  IP_ADDRESS_STRING      IpAddress;
			  IP_MASK_STRING         IpMask;
			  DWORD                  Context;
			} IP_ADDR_STRING, *PIP_ADDR_STRING;
			*/
				if( StrCmp( ipadd->IpAddress.String, "0.0.0.0" ) == 0 )
					continue;
				struct interfaceAddress *ia = New( struct interfaceAddress );
				ia->sa = CreateRemote( ipadd->IpAddress.String, 0 );
				ia->saMask = CreateRemote( ipadd->IpMask.String, 0 );
				ia->saBroadcast = AllocAddr();
				ia->saBroadcast->sa_family = ia->sa->sa_family;
				ia->saBroadcast->sa_data[0] = 0;
				ia->saBroadcast->sa_data[1] = 0;
				ia->saBroadcast->sa_data[2] = (ia->sa->sa_data[2] & ia->saMask->sa_data[2]) | (~ia->saMask->sa_data[2]);
				ia->saBroadcast->sa_data[3] = (ia->sa->sa_data[3] & ia->saMask->sa_data[3]) | (~ia->saMask->sa_data[3]);
				ia->saBroadcast->sa_data[4] = (ia->sa->sa_data[4] & ia->saMask->sa_data[4]) | (~ia->saMask->sa_data[4]);
				ia->saBroadcast->sa_data[5] = (ia->sa->sa_data[5] & ia->saMask->sa_data[5]) | (~ia->saMask->sa_data[5]);
				AddLink( &globalNetworkData.addresses, ia );
			}
			pAdapter = pAdapter->Next;
		}
	}
	else {
		lprintf( "GetAdaptersInfo failed with error: %d\n", dwRetVal );
	}
#if 0
//msdn.microsoft.com/en-us/library/windows/desktop/aa365915%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
https:
    PIP_ADAPTER_ADDRESSES pAddresses = NULL;
    ULONG outBufLen = 0;
    ULONG Iterations = 0;
    PIP_ADAPTER_ADDRESSES pCurrAddresses = NULL;
    PIP_ADAPTER_UNICAST_ADDRESS pUnicast = NULL;
    PIP_ADAPTER_ANYCAST_ADDRESS pAnycast = NULL;
    PIP_ADAPTER_MULTICAST_ADDRESS pMulticast = NULL;
    IP_ADAPTER_DNS_SERVER_ADDRESS *pDnServer = NULL;
    IP_ADAPTER_PREFIX *pPrefix = NULL;
  do {
        pAddresses = (IP_ADAPTER_ADDRESSES *) MALLOC(outBufLen);
        if (pAddresses == NULL) {
            printf
                ("Memory allocation failed for IP_ADAPTER_ADDRESSES struct\n");
            exit(1);
        }
        dwRetVal =
            GetAdaptersAddresses(AF_UNSPEC
		, GAA_FLAG_SKIP_DNS_SERVER|GAA_FLAG_SKIP_FRIENDLY_NAME|GAA_FLAG_INCLUDE_ALL_INTERFACES
		, NULL, pAddresses, &outBufLen);
        if (dwRetVal == ERROR_BUFFER_OVERFLOW) {
            FREE(pAddresses);
            pAddresses = NULL;
        } else {
            break;
        }
        Iterations++;
    } while ((dwRetVal == ERROR_BUFFER_OVERFLOW) && (Iterations < MAX_TRIES));
#endif
}
#endif
SACK_NETWORK_NAMESPACE_END
// DEBUG FALGS in netstruc.h
//TODO: after the connect and just before the call to the connect callback fill in the PCLIENT's MAC addr field.
//TODO: After the accept, put in this code:
/*
NETWORK_PROC( int, GetMacAddress)(CTEXTSTR device, CTEXTSTR buffer )//int get_mac_addr (char *device, unsigned char *buffer)
{
int fd;
struct ifreq ifr;
fd = socket(PF_UNIX, SOCK_DGRAM, 0);
if (fd == -1)
{
perr ("Unable to create socket for device: %s", device);
return -1;
}
strcpy (ifr.ifr_name, device);
if (ioctl (fd, SIOCGIFFLAGS, &ifr) < 0)
{
close (fd);
return -1;
}
if (ioctl (fd, SIOCGIFHWADDR, &ifr) < 0)
{
close (fd);
return -1;
}
close (fd);
memcpy (buffer, ifr.ifr_hwaddr.sa_data, 6);
return 0;
}
*/
//#define DEBUG_SOCK_IO
#define LIBRARY_DEF
#ifndef UNDER_CE
#endif
#ifdef __LINUX__
#ifdef __LINUX__
#undef s_addr
 // IPPROTO_TCP
//#include <linux/in.h>  // IPPROTO_TCP
 // TCP_NODELAY
#include <netinet/tcp.h>
//#include <linux/tcp.h> // TCP_NODELAY
#else
#endif
 // SIGHUP defined
#define NetWakeSignal SIGHUP
#else
#define ioctl ioctlsocket
#endif
//#define NO_LOGGING // force neverlog....
SACK_NETWORK_NAMESPACE
	extern int CPROC ProcessNetworkMessages( struct peer_thread_info *thread, uintptr_t quick_check );
_TCP_NAMESPACE
//----------------------------------------------------------------------------
LOGICAL TCPDrainRead( PCLIENT pClient );
//----------------------------------------------------------------------------
void AcceptClient(PCLIENT pListen)
{
#ifdef __LINUX__
	socklen_t
#else
		int
#endif
		nTemp;
// just to be safe.
	PCLIENT pNewClient = NULL;
	pNewClient = GetFreeNetworkClient();
	// new client will be locked...
	if( !pNewClient )
	{
		SOCKADDR *junk = AllocAddr();
		nTemp = MAGIC_SOCKADDR_LENGTH;
		lprintf(WIDE( "GetFreeNetwork() returned NULL. Exiting AcceptClient, accept and drop connection" ));
		closesocket( accept( pListen->Socket, junk ,&nTemp	));
		ReleaseAddress( junk );
		return;
	}
	// without setting this value - the pointer to the value
	// contains a value which may be less than a valid address
	// length... usually didn't JAB: 980203
	nTemp = MAGIC_SOCKADDR_LENGTH;
	pNewClient->saClient = AllocAddr();
	pNewClient->flags.bSecure = pListen->flags.bSecure;
	pNewClient->flags.bAllowDowngrade = pListen->flags.bAllowDowngrade;
	pNewClient->Socket = accept( pListen->Socket
										, pNewClient->saClient
										,&nTemp
										);
	//lprintf( "Accept new client....%d", pNewClient->Socket );
#if WIN32
	SetHandleInformation( (HANDLE)pNewClient->Socket, HANDLE_FLAG_INHERIT, 0 );
#endif
#ifdef LOG_SOCKET_CREATION
	lprintf( WIDE("Accepted socket %p %d  (%d)"), pNewClient, pNewClient->Socket, nTemp );
#endif
	//DumpAddr( WIDE("Client's Address"), pNewClient->saClient );
	{
#ifdef __LINUX__
		socklen_t
#else
			int
#endif
			nLen = MAGIC_SOCKADDR_LENGTH;
		if( !pNewClient->saSource )
			pNewClient->saSource = AllocAddr();
		if( getsockname( pNewClient->Socket, pNewClient->saSource, &nLen ) )
		{
			lprintf( WIDE("getsockname errno = %d"), errno );
		}
		//lprintf( "sockaddrlen: %d", nLen );
		if( pNewClient->saSource->sa_family == AF_INET )
			SET_SOCKADDR_LENGTH( pNewClient->saSource, IN_SOCKADDR_LENGTH );
		else if( pNewClient->saSource->sa_family == AF_INET6 )
			SET_SOCKADDR_LENGTH( pNewClient->saSource, IN6_SOCKADDR_LENGTH );
		else
			SET_SOCKADDR_LENGTH( pNewClient->saSource, nLen );
	}
	pNewClient->read.ReadComplete = pListen->read.ReadComplete;
	pNewClient->psvRead = pListen->psvRead;
	pNewClient->close.CloseCallback     = pListen->close.CloseCallback;
	pNewClient->psvClose = pListen->psvClose;
	pNewClient->write.WriteComplete     = pListen->write.WriteComplete;
	pNewClient->psvWrite = pListen->psvWrite;
	pNewClient->dwFlags |= CF_CONNECTED | ( pListen->dwFlags & CF_CALLBACKTYPES );
	if( IsValid(pNewClient->Socket) )
 // and we get one from the accept...
	{
#ifdef _WIN32
#  ifdef USE_WSA_EVENTS
		pNewClient->event = WSACreateEvent();
#ifdef LOG_NETWORK_EVENT_THREAD
		lprintf( "New event on accepted %p", pNewClient->event );
#endif
		WSAEventSelect( pNewClient->Socket, pNewClient->event,
			FD_READ|FD_WRITE|FD_CLOSE );
#  else
		if( WSAAsyncSelect( pNewClient->Socket,globalNetworkData.ghWndNetwork, SOCKMSG_TCP
		                  , FD_READ | FD_WRITE | FD_CLOSE))
 // if there was a select error...
		{
			lprintf(WIDE( " Accept select Error" ));
			InternalRemoveClientEx( pNewClient, TRUE, FALSE );
			NetworkUnlockEx( pNewClient, 0 DBG_SRC );
			NetworkUnlockEx( pNewClient, 1 DBG_SRC );
			pNewClient = NULL;
		}
		else
#  endif
#else
		// yes this is an ugly transition from the above dangling
		// else...
			fcntl( pNewClient->Socket, F_SETFL, O_NONBLOCK );
#endif
		AddActive( pNewClient );
		{
			//lprintf( WIDE("Accepted and notifying...") );
			if( pListen->connect.ClientConnected )
			{
				if( pListen->dwFlags & CF_CPPCONNECT )
					pListen->connect.CPPClientConnected( pListen->psvConnect, pNewClient );
				else
					pListen->connect.ClientConnected( pListen, pNewClient );
			}
			// signal initial read.
			//lprintf(" Initial notifications...");
 // may be... at least we can fail sooner...
			pNewClient->dwFlags |= CF_READREADY;
			if( pNewClient->read.ReadComplete )
			{
				if( pListen->dwFlags & CF_CPPREAD )
  // process read to get data already pending...
					pNewClient->read.CPPReadComplete( pNewClient->psvRead, NULL, 0 );
				else
  // process read to get data already pending...
					pNewClient->read.ReadComplete( pNewClient, NULL, 0 );
			}
			if( pNewClient->write.WriteComplete  &&
				!pNewClient->bWriteComplete )
			{
				pNewClient->bWriteComplete = TRUE;
				if( pNewClient->dwFlags & CF_CPPWRITE )
					pNewClient->write.CPPWriteComplete( pNewClient->psvWrite );
				else
					pNewClient->write.WriteComplete( pNewClient );
				pNewClient->bWriteComplete = FALSE;
			}
			//lprintf( "Is it already closed HERE????");
			if( pNewClient->Socket ) {
#ifdef USE_WSA_EVENTS
				if( globalNetworkData.flags.bLogNotices )
					lprintf( WIDE( "SET GLOBAL EVENT (accepted socket added)  %p  %p" ), pNewClient, pNewClient->event );
				EnqueLink( &globalNetworkData.client_schedule, pNewClient );
				WSASetEvent( globalNetworkData.hMonitorThreadControlEvent );
#endif
#ifdef __LINUX__
				AddThreadEvent( pNewClient, 0 );
#endif
			}
			NetworkUnlockEx( pNewClient, 0 DBG_SRC );
			NetworkUnlockEx( pNewClient, 1 DBG_SRC );
		}
	}
 // accept failed...
	else
	{
		InternalRemoveClientEx( pNewClient, TRUE, FALSE );
		NetworkUnlockEx( pNewClient, 0 DBG_SRC );
		NetworkUnlockEx( pNewClient, 1 DBG_SRC );
		pNewClient = NULL;
	}
	if( !pNewClient )
	{
		lprintf(WIDE( "Failed Accept..." ));
	}
}
//----------------------------------------------------------------------------
PCLIENT CPPOpenTCPListenerAddrExx( SOCKADDR *pAddr
                                 , cppNotifyCallback NotifyCallback
                                 , uintptr_t psvConnect
                                 DBG_PASS )
{
	PCLIENT pListen;
	if( !pAddr )
		return NULL;
	pListen = GetFreeNetworkClient();
	if( !pListen )
	{
		lprintf( WIDE("Network has not been started.") );
		return NULL;
	}
	//	pListen->Socket = socket( *(uint16_t*)pAddr, SOCK_STREAM, 0 );
#ifdef WIN32
	pListen->Socket = OpenSocket( ((*(uint16_t*)pAddr) == AF_INET)?TRUE:FALSE, TRUE, FALSE, 0 );
	if( pListen->Socket == INVALID_SOCKET )
#endif
#ifdef __MAC__
		pListen->Socket = socket( ((uint8_t*)pAddr)[1]
										, SOCK_STREAM
										, ((((uint8_t*)pAddr)[1] == AF_INET)||((((uint8_t*)pAddr)[1]) == AF_INET6))?IPPROTO_TCP:0 );
#else
		pListen->Socket = socket( *(uint16_t*)pAddr
										, SOCK_STREAM
										, (((*(uint16_t*)pAddr) == AF_INET)||((*(uint16_t*)pAddr) == AF_INET6))?IPPROTO_TCP:0 );
#endif
#if WIN32
	SetHandleInformation( (HANDLE)pListen->Socket, HANDLE_FLAG_INHERIT, 0 );
#endif
#ifdef LOG_SOCKET_CREATION
	lprintf( WIDE( "Created new socket %d" ), pListen->Socket );
#endif
 // make sure this flag is clear!
	pListen->dwFlags &= ~CF_UDP;
	pListen->dwFlags |= CF_LISTEN;
	if( pListen->Socket == INVALID_SOCKET )
	{
		lprintf( WIDE(" Open Listen Socket Fail... %d"), errno);
		DumpAddr( "passed address to select:", pAddr );
		InternalRemoveClientEx( pListen, TRUE, FALSE );
		NetworkUnlockEx( pListen, 0 DBG_SRC );
		NetworkUnlockEx( pListen, 1 DBG_SRC );
		pListen = NULL;
		return NULL;
	}
#ifdef _WIN32
#  ifdef USE_WSA_EVENTS
	pListen->event = WSACreateEvent();
	WSAEventSelect( pListen->Socket, pListen->event, FD_ACCEPT|FD_CLOSE );
#  else
	if( WSAAsyncSelect( pListen->Socket, globalNetworkData.ghWndNetwork,
                       SOCKMSG_TCP, FD_ACCEPT|FD_CLOSE ) )
	{
		lprintf( WIDE("Windows AsynchSelect failed: %d"), WSAGetLastError() );
		InternalRemoveClientEx( pListen, TRUE, FALSE );
		NetworkUnlockEx( pListen, 0 DBG_SRC );
		NetworkUnlockEx( pListen, 1 DBG_SRC );
		return NULL;
	}
#  endif
	{
		int t = FALSE;
		setsockopt( pListen->Socket, IPPROTO_IPV6, IPV6_V6ONLY, (const char *)&t, 4 );
	}
#else
	{
		int t = TRUE;
		setsockopt( pListen->Socket, SOL_SOCKET, SO_REUSEADDR, &t, 4 );
		t = TRUE;
		fcntl( pListen->Socket, F_SETFL, O_NONBLOCK );
	}
#endif
#ifndef _WIN32
	if( pAddr->sa_family==AF_UNIX )
		unlink( (char*)(((uint16_t*)pAddr)+1));
#endif
	if (!pAddr ||
		 bind(pListen->Socket ,pAddr, SOCKADDR_LENGTH( pAddr ) ) )
	{
		_lprintf(DBG_RELAY)( WIDE("Cannot bind to address..:%d"), WSAGetLastError() );
		DumpAddr( "Bind address:", pAddr );
		InternalRemoveClientEx( pListen, TRUE, FALSE );
		NetworkUnlockEx( pListen, 0 DBG_SRC );
		NetworkUnlockEx( pListen, 1 DBG_SRC );
		return NULL;
	}
	pListen->saSource = DuplicateAddress( pAddr );
	if(listen(pListen->Socket, SOMAXCONN ) == SOCKET_ERROR )
	{
		lprintf( WIDE("listen(5) failed: %d"), WSAGetLastError() );
		InternalRemoveClientEx( pListen, TRUE, FALSE );
		NetworkUnlockEx( pListen, 0 DBG_SRC );
		NetworkUnlockEx( pListen, 1 DBG_SRC );
		return NULL;
	}
	pListen->connect.CPPClientConnected = NotifyCallback;
	pListen->psvConnect = psvConnect;
	pListen->dwFlags |= CF_CPPCONNECT;
	NetworkUnlockEx( pListen, 0 DBG_SRC );
	NetworkUnlockEx( pListen, 1 DBG_SRC );
	AddActive( pListen );
   // make sure to schedule this socket for events (connect)
#ifdef USE_WSA_EVENTS
	if( globalNetworkData.flags.bLogNotices )
		lprintf( WIDE( "SET GLOBAL EVENT (listener added)" ) );
	EnqueLink( &globalNetworkData.client_schedule, pListen );
	WSASetEvent( globalNetworkData.hMonitorThreadControlEvent );
#endif
#ifdef __LINUX__
	AddThreadEvent( pListen, 0 );
#endif
	return pListen;
}
//----------------------------------------------------------------------------
PCLIENT OpenTCPListenerAddrExx( SOCKADDR *pAddr
                              , cNotifyCallback NotifyCallback DBG_PASS )
{
	PCLIENT result = CPPOpenTCPListenerAddrExx( pAddr, (cppNotifyCallback)NotifyCallback, 0 DBG_RELAY );
	if( result )
		result->dwFlags &= ~CF_CPPCONNECT;
	return result;
}
//----------------------------------------------------------------------------
PCLIENT CPPOpenTCPListenerExx( uint16_t wPort
                             , cppNotifyCallback NotifyCallback
                             , uintptr_t psvConnect
                             DBG_PASS
                             )
{
	SOCKADDR *lpMyAddr = CreateLocal(wPort);
	PCLIENT pc = CPPOpenTCPListenerAddrExx( lpMyAddr, NotifyCallback, psvConnect DBG_RELAY );
	ReleaseAddress( lpMyAddr );
	if( pc )
	{
		// have to have the base one open or pcOther cannot be set.
		lpMyAddr = CreateSockAddress( WIDE(":::"), wPort );
		pc->pcOther = CPPOpenTCPListenerAddrExx( lpMyAddr, NotifyCallback, psvConnect DBG_RELAY );
		ReleaseAddress( lpMyAddr );
	}
	return pc;
}
//----------------------------------------------------------------------------
PCLIENT OpenTCPListenerExx(uint16_t wPort, cNotifyCallback NotifyCallback DBG_PASS )
{
	PCLIENT result = CPPOpenTCPListenerExx( wPort, (cppNotifyCallback)NotifyCallback, 0 DBG_RELAY );
	if( result )
		result->dwFlags &= ~CF_CPPCONNECT;
	return result;
}
//----------------------------------------------------------------------------
int NetworkConnectTCPEx( PCLIENT pc DBG_PASS ) {
	int err;
	while( !NetworkLockEx( pc, 0 DBG_SRC ) )
	{
		if( !(pc->dwFlags & CF_ACTIVE) )
		{
			return -1;
		}
		Relinquish();
	}
	pc->dwFlags |= CF_CONNECTING;
	//DumpAddr( WIDE("Connect to"), &pResult->saClient );
	if( (err = connect( pc->Socket, pc->saClient
		, SOCKADDR_LENGTH( pc->saClient ) )) )
	{
		uint32_t dwError;
		dwError = WSAGetLastError();
		if( dwError != WSAEWOULDBLOCK
#ifdef __LINUX__
			&& dwError != EINPROGRESS
#else
			&& dwError != WSAEINPROGRESS
#endif
			)
		{
			_lprintf( DBG_RELAY )(WIDE( "Connect FAIL: %d %d %" ) _32f, pc->Socket, err, dwError);
			InternalRemoveClientEx( pc, TRUE, FALSE );
			NetworkUnlockEx( pc, 0 DBG_SRC );
			pc = NULL;
			return -1;
		}
		else
		{
			//lprintf( WIDE("Pending connect has begun...") );
		}
	}
	else
	{
#ifdef VERBOSE_DEBUG
		lprintf( WIDE( "Connected before we even get a chance to wait" ) );
#endif
	}
	NetworkUnlockEx( pc, 0 DBG_SRC );
	return 0;
}
//----------------------------------------------------------------------------
static PCLIENT InternalTCPClientAddrFromAddrExxx( SOCKADDR *lpAddr, SOCKADDR *pFromAddr,
                                                  int bCPP,
                                                  cppReadComplete  pReadComplete,
                                                  uintptr_t psvRead,
                                                  cppCloseCallback CloseCallback,
                                                  uintptr_t psvClose,
                                                  cppWriteComplete WriteComplete,
                                                  uintptr_t psvWrite,
                                                  cppConnectCallback pConnectComplete,
                                                  uintptr_t psvConnect,
                                                  int flags
                                                  DBG_PASS
                                                )
{
	// Server's Port and Name.
	PCLIENT pResult;
	if( !lpAddr )
		return NULL;
	pResult = GetFreeNetworkClient();
	if( pResult )
	{
		struct peer_thread_info *this_thread = IsNetworkThread();
		// use the sockaddr to switch what type of socket this is.
#ifdef WIN32
		pResult->Socket = OpenSocket( ((*(uint16_t*)lpAddr) == AF_INET)?TRUE:FALSE, TRUE, FALSE, 0 );
		if( pResult->Socket == INVALID_SOCKET )
#endif
#ifdef __MAC__
			pResult->Socket=socket( ((uint8_t*)lpAddr)[1]
			                      , SOCK_STREAM
			                      , (((((uint8_t*)lpAddr)[1]) == AF_INET)||((((uint8_t*)lpAddr)[1]) == AF_INET6))?IPPROTO_TCP:0 );
#else
			pResult->Socket=socket( *(uint16_t*)lpAddr
			                      , SOCK_STREAM
			                      , (((*(uint16_t*)lpAddr) == AF_INET)||((*(uint16_t*)lpAddr) == AF_INET6))?IPPROTO_TCP:0 );
#endif
#ifdef LOG_SOCKET_CREATION
		lprintf( WIDE( "Created new socket %d" ), pResult->Socket );
#endif
		if (pResult->Socket==INVALID_SOCKET)
		{
			lprintf( WIDE("Create socket failed. %d"), WSAGetLastError() );
			InternalRemoveClientEx( pResult, TRUE, FALSE );
			NetworkUnlockEx( pResult, 1 DBG_SRC );
			NetworkUnlockEx( pResult, 0 DBG_SRC );
			return NULL;
		}
		else
		{
			int err;
#ifdef _WIN32
			if( 0 )
			{
				DWORD dwFlags;
				GetHandleInformation( (HANDLE)pResult->Socket, &dwFlags );
				lprintf( WIDE( "Natural was %d" ), dwFlags );
			}
			SetHandleInformation( (HANDLE)pResult->Socket, HANDLE_FLAG_INHERIT, 0 );
#  ifdef USE_WSA_EVENTS
			pResult->event = WSACreateEvent();
#    ifdef LOG_NETWORK_EVENT_THREAD
			lprintf( "new event is %p", pResult->event );
#    endif
			WSAEventSelect( pResult->Socket, pResult->event, FD_READ|FD_WRITE|FD_CONNECT|FD_CLOSE );
#  else
			if( WSAAsyncSelect( pResult->Socket,globalNetworkData.ghWndNetwork,SOCKMSG_TCP
			                  , FD_READ|FD_WRITE|FD_CLOSE|FD_CONNECT) )
			{
				lprintf( WIDE(" Select NewClient Fail! %d"), WSAGetLastError() );
				InternalRemoveClientEx( pResult, TRUE, FALSE );
				NetworkUnlockEx( pResult, 1 DBG_SRC );
				NetworkUnlockEx( pResult, 0 DBG_SRC );
				pResult = NULL;
				goto LeaveNow;
			}
#  endif
#else
			fcntl( pResult->Socket, F_SETFL, O_NONBLOCK );
#endif
			if( pFromAddr )
			{
				LOGICAL opt = 1;
				err = setsockopt( pResult->Socket, SOL_SOCKET, SO_REUSEADDR, (const char *)&opt, sizeof( opt ) );
				if( err )
				{
					uint32_t dwError = WSAGetLastError();
					lprintf( WIDE("Failed to set socket option REUSEADDR : %d"), dwError );
				}
				pResult->saSource = DuplicateAddress( pFromAddr );
				//DumpAddr( "source", pResult->saSource );
				if( ( err = bind( pResult->Socket, pResult->saSource
				                , SOCKADDR_LENGTH( pResult->saSource ) ) ) )
				{
					uint32_t dwError;
					dwError = WSAGetLastError();
					lprintf( WIDE("Error binding connecting socket to source address... continuing with connect : %d"), dwError );
				}
			}
			pResult->saClient = DuplicateAddress( lpAddr );
			// set up callbacks before asynch select...
			pResult->connect.CPPThisConnected  = pConnectComplete;
			pResult->psvConnect                = psvConnect;
			pResult->read.CPPReadComplete      = pReadComplete;
			pResult->psvRead                   = psvRead;
			pResult->close.CPPCloseCallback    = CloseCallback;
			pResult->psvClose                  = psvClose;
			pResult->write.CPPWriteComplete    = WriteComplete;
			pResult->psvWrite                  = psvWrite;
			if( bCPP )
				pResult->dwFlags |= ( CF_CALLBACKTYPES );
			AddActive( pResult );
			if( !(flags & OPEN_TCP_FLAG_DELAY_CONNECT) ) {
				NetworkConnectTCPEx( pResult DBG_RELAY );
			}
			//lprintf( WIDE("Leaving Client's critical section") );
			NetworkUnlockEx( pResult, 1 DBG_SRC );
			NetworkUnlockEx( pResult, 0 DBG_SRC );
			// socket should now get scheduled for events, after unlocking it?
#ifdef USE_WSA_EVENTS
			if( globalNetworkData.flags.bLogNotices )
				lprintf( WIDE( "SET GLOBAL EVENT (wait for connect) new %p %p  %08x %p" ), pResult, pResult->event, pResult->dwFlags, globalNetworkData.hMonitorThreadControlEvent );
			EnqueLink( &globalNetworkData.client_schedule, pResult );
			if( this_thread == globalNetworkData.root_thread ) {
				ProcessNetworkMessages( this_thread, 1 );
				if( !pResult->this_thread ) {
					WSASetEvent( globalNetworkData.hMonitorThreadControlEvent );
					//lprintf( "Failed to schedule myself in a single run of root thread that I am running on." );
				}
			}
			else {
				WSASetEvent( globalNetworkData.hMonitorThreadControlEvent );
				while( !pResult->this_thread )
 // wait for it to be added to waiting lists?
					Relinquish();
			}
#endif
#ifdef __LINUX__
			AddThreadEvent( pResult, 0 );
#endif
			if( !pConnectComplete && !(flags & OPEN_TCP_FLAG_DELAY_CONNECT) )
			{
				int Start, bProcessing = 0;
				// should trigger a rebuild (if it's the root thread)
				Start = (GetTickCount()&0xFFFFFFF);
				pResult->dwFlags |= CF_CONNECT_WAITING;
				// caller was expecting connect to block....
				while( !( pResult->dwFlags & (CF_CONNECTED|CF_CONNECTERROR|CF_CONNECT_CLOSED) ) &&
						( ( (GetTickCount()&0xFFFFFFF) - Start ) < globalNetworkData.dwConnectTimeout ) )
				{
					// may be this thread itself which connects...
					if( this_thread )
					{
						if( !bProcessing )
						{
							if( ProcessNetworkMessages( this_thread, 0 ) >= 0 )
								bProcessing = 1;
							else
								bProcessing = 2;
						}
						else
						{
							if( bProcessing >= 0 )
								ProcessNetworkMessages( this_thread, 0 );
						}
					}
					else
					{
						// isn't a network thread; so wait as an external thread
						bProcessing = 2;
					}
					if( bProcessing == 2 )
					{
						pResult->pWaiting = MakeThread();
						if( globalNetworkData.flags.bLogNotices )
							lprintf( WIDE( "Falling asleep 3 seconds waiting for connect on %p." ), pResult );
						pResult->tcp_delay_count++;
						WakeableSleep( 3000 );
						pResult->pWaiting = NULL;
						if( pResult->dwFlags & CF_CLOSING )
							return NULL;
					}
					else
					{
						lprintf( WIDE( "Spin wait for connect" ) );
						Relinquish();
					}
				}
				if( (( (GetTickCount()&0xFFFFFFF) - Start ) >= 10000)
					|| (pResult->dwFlags &  CF_CONNECTERROR ) )
				{
					if( pResult->dwFlags &  CF_CONNECTERROR )
					{
						//DumpAddr( WIDE("Connect to: "), lpAddr );
						//lprintf( WIDE("Connect FAIL: message result") );
					}
					else
						lprintf( WIDE("Connect FAIL: Timeout") );
					InternalRemoveClientEx( pResult, TRUE, FALSE );
					pResult->dwFlags &= ~CF_CONNECT_WAITING;
					pResult = NULL;
					goto LeaveNow;
				}
				{
			#ifdef __LINUX__
					socklen_t
			#else
						int
			#endif
						nLen = MAGIC_SOCKADDR_LENGTH;
					if( !pResult->saSource )
						pResult->saSource = AllocAddr();
					if( getsockname( pResult->Socket, pResult->saSource, &nLen ) )
					{
						lprintf( WIDE("getsockname errno = %d"), errno );
					}
				}
				//lprintf( WIDE("Connect did complete... returning to application"));
			}
#ifdef VERBOSE_DEBUG
			else
				lprintf( WIDE("Connect in progress, will notify application when done.") );
#endif
			pResult->dwFlags &= ~CF_CONNECT_WAITING;
		}
	}
LeaveNow:
  // didn't break out of the loop with a good return.
	if( !pResult )
	{
		//lprintf( WIDE("Failed Open TCP Client.") );
	}
	return pResult;
}
//----------------------------------------------------------------------------
NETWORK_PROC( PCLIENT, CPPOpenTCPClientAddrExxx )(SOCKADDR *lpAddr
                                                 , cppReadComplete  pReadComplete
                                                 , uintptr_t psvRead
                                                 , cppCloseCallback CloseCallback
                                                 , uintptr_t psvClose
                                                 , cppWriteComplete WriteComplete
                                                 , uintptr_t psvWrite
                                                 , cppConnectCallback pConnectComplete
                                                 , uintptr_t psvConnect
                                                 , int flags
                                                 DBG_PASS  )
{
	return InternalTCPClientAddrFromAddrExxx( lpAddr, NULL, TRUE
											 , pReadComplete, psvRead
											 , CloseCallback, psvClose
											 , WriteComplete, psvWrite
											 , pConnectComplete, psvConnect, flags DBG_RELAY );
}
//----------------------------------------------------------------------------
PCLIENT OpenTCPClientAddrExxx( SOCKADDR *lpAddr
                             , cReadComplete     pReadComplete
                             , cCloseCallback    CloseCallback
                             , cWriteComplete    WriteComplete
                             , cConnectCallback  pConnectComplete
                             , int flags
                             DBG_PASS
                             )
{
	return InternalTCPClientAddrFromAddrExxx( lpAddr, NULL, FALSE
											 , (cppReadComplete)pReadComplete, 0
											 , (cppCloseCallback)CloseCallback, 0
											 , (cppWriteComplete)WriteComplete, 0
											 , (cppConnectCallback)pConnectComplete, 0, flags DBG_RELAY );
}
PCLIENT OpenTCPClientAddrFromAddrEx(SOCKADDR *lpAddr, SOCKADDR *pFromAddr
															  , cReadComplete     pReadComplete
															  , cCloseCallback    CloseCallback
															  , cWriteComplete    WriteComplete
															  , cConnectCallback  pConnectComplete
	, int flags
                                               DBG_PASS
															 )
{
	return InternalTCPClientAddrFromAddrExxx( lpAddr, pFromAddr, FALSE
											 , (cppReadComplete)pReadComplete, 0
											 , (cppCloseCallback)CloseCallback, 0
											 , (cppWriteComplete)WriteComplete, 0
											 , (cppConnectCallback)pConnectComplete, 0, flags DBG_RELAY );
}
PCLIENT OpenTCPClientAddrFromEx(SOCKADDR *lpAddr, int port
															  , cReadComplete     pReadComplete															  , cCloseCallback    CloseCallback
															  , cWriteComplete    WriteComplete
															  , cConnectCallback  pConnectComplete
	, int flags
                                               DBG_PASS
															 )
{
	PCLIENT result;
	SOCKADDR *pFromAddr = CreateSockAddress( NULL, port );
	result = InternalTCPClientAddrFromAddrExxx( lpAddr, pFromAddr, FALSE
											 , (cppReadComplete)pReadComplete, 0
											 , (cppCloseCallback)CloseCallback, 0
											 , (cppWriteComplete)WriteComplete, 0
											 , (cppConnectCallback)pConnectComplete, 0, flags DBG_RELAY );
	ReleaseAddress( pFromAddr );
	return result;
}
//----------------------------------------------------------------------------
PCLIENT OpenTCPClientAddrExEx( SOCKADDR *lpAddr
                             , cReadComplete  pReadComplete
                             , cCloseCallback CloseCallback
                             , cWriteComplete WriteComplete
                             DBG_PASS )
{
   return OpenTCPClientAddrExxx( lpAddr, pReadComplete, CloseCallback, WriteComplete, NULL, 0 DBG_RELAY );
}
//----------------------------------------------------------------------------
PCLIENT CPPOpenTCPClientExEx(CTEXTSTR lpName,uint16_t wPort,
             cppReadComplete	 pReadComplete, uintptr_t psvRead,
             cppCloseCallback CloseCallback, uintptr_t psvClose,
             cppWriteComplete WriteComplete, uintptr_t psvWrite,
             cppConnectCallback pConnectComplete, uintptr_t psvConnect, int flags DBG_PASS )
{
	PCLIENT pClient;
	SOCKADDR *lpsaDest;
	pClient = NULL;
	if( lpName &&
	   (lpsaDest = CreateSockAddress(lpName,wPort) ) )
	{
		pClient = CPPOpenTCPClientAddrExxx( lpsaDest
		                                  , pReadComplete
		                                  , psvRead
		                                  , CloseCallback
		                                  , psvClose
		                                  , WriteComplete
		                                  , psvWrite
		                                  , pConnectComplete
		                                  , psvConnect
		                                  , flags
		                                    DBG_RELAY
		                                  );
		ReleaseAddress( lpsaDest );
	}
	return pClient;
}
//----------------------------------------------------------------------------
PCLIENT OpenTCPClientExxx(CTEXTSTR lpName,uint16_t wPort,
             cReadComplete  pReadComplete,
             cCloseCallback CloseCallback,
             cWriteComplete WriteComplete,
             cConnectCallback pConnectComplete,
             int flags
             DBG_PASS )
{
	PCLIENT pClient;
	SOCKADDR *lpsaDest;
	pClient = NULL;
	if( lpName &&
		(lpsaDest = CreateSockAddress(lpName,wPort) ) )
	{
		pClient = OpenTCPClientAddrExxx( lpsaDest
		                               , pReadComplete
		                               , CloseCallback
		                               , WriteComplete
		                               , pConnectComplete
		                               , flags DBG_RELAY );
		ReleaseAddress( lpsaDest );
	}
	return pClient;
}
//----------------------------------------------------------------------------
PCLIENT OpenTCPClientExEx(CTEXTSTR lpName,uint16_t wPort,
                          cReadComplete	 pReadComplete,
                          cCloseCallback CloseCallback,
                          cWriteComplete WriteComplete
                          DBG_PASS )
{
	return OpenTCPClientExxx( lpName, wPort, pReadComplete, CloseCallback, WriteComplete, NULL, 0 DBG_RELAY );
}
//----------------------------------------------------------------------------
  // only time this should be called is when there IS, cause
int FinishPendingRead(PCLIENT lpClient DBG_PASS )
                                 // we definaly have already gotten SOME data to leave in
                                 // a pending state...
{
	int nRecv;
#ifdef VERBOSE_DEBUG
	int nCount;
#endif
	uint32_t dwError;
	// returns amount of information left to get.
#ifdef VERBOSE_DEBUG
	nCount = 0;
#endif
	if( !( lpClient->dwFlags & CF_READPENDING ) )
	{
		//lpClient->dwFlags |= CF_READREADY; // read ready is set if FinishPendingRead returns 0; and it's from the core read...
		//lprintf( WIDE( "Finish pending - return, no pending read. %08x" ), lpClient->dwFlags );
	}
	do
	{
		if( lpClient->bDraining )
		{
			lprintf(WIDE( "LOG:ERROR trying to read during a drain state..." ) );
 // why error on draining with pending finish??
			return -1;
		}
		if( !(lpClient->dwFlags & CF_CONNECTED)  )
		{
#ifdef DEBUG_SOCK_IO
			lprintf( WIDE( "Finsih pending - return, not connected." ) );
#endif
 // amount of data available...
			return (int)lpClient->RecvPending.dwUsed;
		}
		//lprintf( WIDE(WIDE( "FinishPendingRead of %d" )), lpClient->RecvPending.dwAvail );
		if( !( lpClient->dwFlags & CF_READPENDING ) )
		{
			//lpClient->dwFlags |= CF_READREADY; // read ready is set if FinishPendingRead returns 0; and it's from the core read...
#ifdef DEBUG_SOCK_IO
			lprintf( WIDE( "Finish pending - return, no pending read. %08x" ), lpClient->dwFlags );
#endif
			// without a pending read, don't read, the buffers are not correct.
			return 0;
		}
  // if any room is availiable.
		while( lpClient->RecvPending.dwAvail )
		{
#ifdef DEBUG_SOCK_IO
			//nCount++;
			_lprintf( DBG_RELAY )( WIDE("FinishPendingRead %p %d %d" ), lpClient
				, lpClient->RecvPending.dwUsed, lpClient->RecvPending.dwAvail );
#endif
			nRecv = recv(lpClient->Socket,
							 (char*)lpClient->RecvPending.buffer.p +
							 lpClient->RecvPending.dwUsed,
							 (int)lpClient->RecvPending.dwAvail,0);
			 dwError = WSAGetLastError();
			//lprintf( "Network receive %d %d %d", nRecv, lpClient->RecvPending.dwUsed, lpClient->RecvPending.dwAvail );
			if (nRecv == SOCKET_ERROR)
			{
#ifdef DEBUG_SOCK_IO
				lprintf( "Received error (-1) %d", nRecv );
#endif
				switch( dwError)
				{
 // no data avail yet...
				case WSAEWOULDBLOCK:
					//lprintf( WIDE("Pending Receive would block...") );
					lpClient->dwFlags &= ~CF_READREADY;
					return (int)lpClient->RecvPending.dwUsed;
#ifdef __LINUX__
				case ECONNRESET:
#else
				case WSAECONNRESET:
				case WSAECONNABORTED:
#endif
#ifdef LOG_DEBUG_CLOSING
					lprintf( WIDE("Read from reset connection - closing. %p"), lpClient );
#endif
					if(0)
					{
					default:
						Log5( WIDE("Failed reading from %d (err:%d) into %p %") _size_f WIDE(" bytes %") _size_f WIDE(" read already."),
							  lpClient->Socket,
							  WSAGetLastError(),
							  lpClient->RecvPending.buffer.p,
							  lpClient->RecvPending.dwAvail,
							  lpClient->RecvPending.dwUsed );
						lprintf(WIDE("LOG:ERROR FinishPending discovered unhandled error (closing connection) %") _32f WIDE(""), dwError );
					}
					//InternalRemoveClient( lpClient );  // invalid channel now.
					lpClient->dwFlags |= CF_TOCLOSE;
   // return pending finished...
					return -1;
				}
			}
 // channel closed if received 0 bytes...
			else if (!nRecv)
   // otherwise WSAEWOULDBLOCK would be generated.
			{
#ifdef DEBUG_SOCK_IO
				lprintf( "Received (0) %d", nRecv );
#endif
				WakeableSleep( 100 );
				//_lprintf( DBG_RELAY )( WIDE("Closing closed socket... Hope there's also an event... "));
				lpClient->dwFlags |= CF_TOCLOSE;
 // while dwAvail... try read...
				break;
				//return -1;
			}
			else
			{
#ifdef DEBUG_SOCK_IO
				lprintf( "Received %d", nRecv );
#endif
				if( globalNetworkData.flags.bShortLogReceivedData )
				{
					LogBinary( (uint8_t*)lpClient->RecvPending.buffer.p
					         + lpClient->RecvPending.dwUsed,  (nRecv < 64) ? nRecv:64 );
				}
				if( globalNetworkData.flags.bLogReceivedData )
				{
					LogBinary( (uint8_t*)lpClient->RecvPending.buffer.p
					         + lpClient->RecvPending.dwUsed, nRecv );
				}
				if( lpClient->RecvPending.s.bStream )
					lpClient->dwFlags &= ~CF_READREADY;
				lpClient->RecvPending.dwLastRead = nRecv;
				lpClient->RecvPending.dwAvail -= nRecv;
				//lprintf( "Receive pending is now %d after %d", lpClient->RecvPending.dwAvail, nRecv );
				lpClient->RecvPending.dwUsed  += nRecv;
				if( lpClient->RecvPending.s.bStream &&
				    lpClient->RecvPending.dwAvail )
					break;
				//else
				//	lprintf( WIDE("Was not a stream read - try reading more...") );
			}
		}
		// if read notification okay - then do callback.
		if( !( lpClient->dwFlags & CF_READWAITING ) )
		{
#ifdef LOG_PENDING
			//lprintf( WIDE("Waiting on a queued read... result to callback.") );
#endif
 // completed all of the read
			if( ( !lpClient->RecvPending.dwAvail ||
   // or completed some of the read
				  ( lpClient->RecvPending.dwUsed &&
					lpClient->RecvPending.s.bStream ) ) )
			{
#ifdef LOG_PENDING
				//lprintf( WIDE("Sending completed read to application") );
#endif
				lpClient->dwFlags &= ~CF_READPENDING;
  // and there's a read complete callback available
				if( lpClient->read.ReadComplete )
				{
					// need to clear dwUsed...
					// otherwise the on-close notificatino can cause this to dispatch again.
					size_t length = lpClient->RecvPending.dwUsed;
					lpClient->RecvPending.dwUsed = 0;
#ifdef LOG_PENDING
					lprintf( WIDE( "Send to application...." ) );
#endif
					if( lpClient->dwFlags & CF_CPPREAD )
					{
						lpClient->read.CPPReadComplete( lpClient->psvRead
																, lpClient->RecvPending.buffer.p
																, length );
					}
					else
					{
						lpClient->read.ReadComplete( lpClient,
															 lpClient->RecvPending.buffer.p,
															 length );
					}
					if( !lpClient->Socket )
						return -1;
#ifdef LOG_PENDING
 // new read probably pending ehre...
					lprintf( WIDE( "back from applciation... (loop to next)" ) );
#endif
					continue;
				}
			}
			if( !( lpClient->dwFlags & CF_READPENDING ) )
			{
				lprintf( WIDE("somehow we didn't get a good read.") );
			}
		}
		else
		{
#ifdef LOG_PENDING
			lprintf( WIDE("Client is waiting for this data... should we wake him? %d"), lpClient->RecvPending.s.bStream );
#endif
 // completed all of the read
			if( ( !lpClient->RecvPending.dwAvail ||
   // or completed some of the read
				  ( lpClient->RecvPending.dwUsed &&
					lpClient->RecvPending.s.bStream ) ) )
			{
				lprintf( WIDE("Wake waiting thread... clearing pending read flag.") );
				lpClient->dwFlags &= ~CF_READPENDING;
				if( lpClient->pWaiting )
					WakeThread( lpClient->pWaiting );
			}
		}
		if( lpClient->dwFlags & CF_TOCLOSE )
			return -1;
 // returns amount of information which is available NOW.
		return (int)lpClient->RecvPending.dwUsed;
	} while ( 1 );
}
//----------------------------------------------------------------------------
size_t doReadExx2(PCLIENT lpClient,POINTER lpBuffer,size_t nBytes, LOGICAL bIsStream, LOGICAL bWait, int user_timeout DBG_PASS )
{
#ifdef LOG_PENDING
	_lprintf(DBG_RELAY)( WIDE( "Reading ... %p(%d) int %p %d (%s,%s)" ), lpClient, lpClient->Socket, lpBuffer, (uint32_t)nBytes, bIsStream?WIDE( "stream" ):WIDE( "block" ), bWait?WIDE( "Wait" ):WIDE( "NoWait" ) );
#endif
	if( !lpClient || !lpBuffer )
 // nothing read.... ???
		return 0;
	// don't try to read closed/inactive sockets.
	if( !(lpClient->dwFlags & CF_ACTIVE ) )
		return 0;
  //draining....
	if( TCPDrainRead( lpClient ) &&
 // and already queued next read.
		lpClient->RecvPending.dwAvail )
	{
		lprintf(WIDE( "LOG:ERROR is draining, and NEXT pending queued ALSO..." ));
  // read not queued... (ERROR)
		return -1;
	}
 // existing read was not a stream...
	if( !lpClient->RecvPending.s.bStream &&
   // AND is not at completion...
		lpClient->RecvPending.dwAvail )
	{
		lprintf(WIDE("LOG:ERROR was not a stream, and is not complete...%") _32f WIDE(" left "),
			  (uint32_t)lpClient->RecvPending.dwAvail );
 // this I guess is an error since we're queueing another
		return -1;
		// read on top of existing incoming 'guaranteed data'
	}
#ifdef REQUIRE_READ_LOCK
	while( !NetworkLockEx( lpClient, 1 DBG_RELAY ) )
	{
		if( !(lpClient->dwFlags & CF_ACTIVE ) )
		{
			return -1;
		}
		Relinquish();
	}
#endif
	if( !(lpClient->dwFlags & CF_ACTIVE ) )
	{
		// like say the callback we're being invoked from closed it;
		lprintf( WIDE( "inactive client, will not pend read." ) );
#ifdef REQUIRE_READ_LOCK
		NetworkUnlockEx( lpClient, 1 DBG_SRC );
#endif
		return -1;
	}
	//lprintf( "read %d", nBytes );
   // only worry if there IS data to read.
	if( nBytes )
	{
		// we can assume there is nothing now pending...
		lpClient->RecvPending.buffer.p = lpBuffer;
		//_lprintf(DBG_RELAY)( "Setup read avail: %d", nBytes );
		lpClient->RecvPending.dwAvail = nBytes;
		lpClient->RecvPending.dwUsed = 0;
		lpClient->RecvPending.s.bStream = bIsStream;
		// if the pending finishes it will call the ReadComplete Callback.
		// otherwise there will be more data to read...
		//lprintf( WIDE("Ok ... buffers set up - now we can handle read events") );
#ifdef LOG_PENDING
		lprintf( WIDE( "Setup read pending %08x" ), lpClient->dwFlags );
#endif
		lpClient->dwFlags |= CF_READPENDING;
#ifdef LOG_PENDING
		lprintf( WIDE( "Setup read pending %p %08x" ), lpClient, lpClient->dwFlags );
#endif
		if( bWait )
		{
			//lprintf( WIDE("setting read waiting so we get awoken... and callback dispatch does not happen.") );
			lpClient->dwFlags |= CF_READWAITING;
		}
		//else
		//   lprintf( WIDE("No read waiting... allow forward going...") );
		if( lpClient->dwFlags & CF_READREADY )
		{
#ifdef LOG_PENDING
			lprintf( WIDE("Data already present for read...") );
#endif
			FinishPendingRead( lpClient DBG_SRC );
		}
	}
	else
	{
		lprintf( WIDE( "zero byte read...." ) );
		if( !bWait )
		{
  // and there's a read complete callback available
			if( lpClient->read.ReadComplete )
			{
				lprintf( WIDE( "Read complete with 0 bytes immediate..." ) );
				lpClient->read.ReadComplete( lpClient, lpBuffer, 0 );
			}
		}
		else
		{
			lpClient->dwFlags &= ~CF_READWAITING;
		 }
	}
	if( bWait )
	{
		int this_timeout = user_timeout?user_timeout:globalNetworkData.dwReadTimeout;
		int timeout = 0;
		//lprintf( WIDE("Waiting for TCP data result...") );
		{
			uint32_t tick = timeGetTime();
			lpClient->pWaiting = MakeThread();
#ifdef REQUIRE_READ_LOCK
			NetworkUnlockEx( lpClient, 1 DBG_SRC );
#endif
			while( lpClient->dwFlags & CF_READPENDING )
			{
				// wait 5 seconds, then bail.
				if( ( tick + this_timeout ) < timeGetTime() )
				{
					//lprintf( "pending has timed out! return now." );
					timeout = 1;
					break;
				}
				if( !Idle() )
				{
					//lprintf( WIDE("Nothing significant to idle on... going to sleep forever.") );
					WakeableSleep( 1000 );
				}
			}
		}
		while( !NetworkLockEx( lpClient, 1 DBG_SRC ) )
		{
			if( !(lpClient->dwFlags & CF_ACTIVE ) )
			{
				return 0;
			}
			Relinquish();
		}
		if( !(lpClient->dwFlags & CF_ACTIVE ) )
		{
#ifdef REQUIRE_READ_LOCK
			NetworkUnlockEx( lpClient, 1 DBG_SRC );
#endif
			return -1;
		}
		 lpClient->dwFlags &= ~CF_READWAITING;
#ifdef REQUIRE_READ_LOCK
		NetworkUnlockEx( lpClient, 1 DBG_SRC);
#endif
		if( timeout )
			return 0;
		else
			return lpClient->RecvPending.dwUsed;
	}
#ifdef REQUIRE_READ_LOCK
	else
		NetworkUnlockEx( lpClient, 1 DBG_SRC );
#endif
 // unknown result really... success prolly
	return 0;
}
//----------------------------------------------------------------------------
static void PendWrite( PCLIENT pClient
                     , CPOINTER lpBuffer
                     , size_t nLen, int bLongBuffer )
{
	PendingBuffer *lpPend;
#ifdef LOG_PENDING
	{
		lprintf( WIDE("Pending %d Bytes to network...") , nLen );
	}
#endif
	lpPend = New( PendingBuffer );
	//lprintf( "Write pend %d", nLen );
	lpPend->dwAvail = nLen;
	lpPend->dwUsed	= 0;
	lpPend->lpNext	= NULL;
	if( !bLongBuffer )
	{
		 lpPend->s.bDynBuffer = TRUE;
		 lpPend->buffer.p = Allocate( nLen );
		 MemCpy( lpPend->buffer.p, lpBuffer, nLen );
	}
	else
	{
		 lpPend->s.bDynBuffer = FALSE;
		 lpPend->buffer.c = lpBuffer;
	}
	if (pClient->lpLastPending)
		pClient->lpLastPending->lpNext = lpPend;
	else
		pClient->lpFirstPending = lpPend;
	pClient->lpLastPending = lpPend;
}
//----------------------------------------------------------------------------
int TCPWriteEx(PCLIENT pc DBG_PASS)
{
	int nSent;
	PendingBuffer *lpNext;
	if( !pc || !(pc->dwFlags & CF_CONNECTED ) )
		return TRUE;
	while (pc->lpFirstPending)
	{
#ifdef VERBOSE_DEBUG
		if( pc->dwFlags & CF_CONNECTING )
			lprintf( WIDE("Sending previously queued data.") );
#endif
		if( pc->lpFirstPending->dwAvail )
		{
			  uint32_t dwError;
			if( globalNetworkData.flags.bLogSentData )
			{
				LogBinary( (uint8_t*)pc->lpFirstPending->buffer.c +
							 pc->lpFirstPending->dwUsed,
							 (int)pc->lpFirstPending->dwAvail );
			}
#ifdef DEBUG_SOCK_IO
			_lprintf(DBG_RELAY)( "Try to send... %d  %d", pc->lpFirstPending->dwUsed, pc->lpFirstPending->dwAvail );
#endif
			nSent = send(pc->Socket,
							 (char*)pc->lpFirstPending->buffer.c +
							 pc->lpFirstPending->dwUsed,
							 (int)pc->lpFirstPending->dwAvail,
							 0);
			  dwError = WSAGetLastError();
			//lprintf( "sent result: %d %d %d", nSent, pc->lpFirstPending->dwUsed, pc->lpFirstPending->dwAvail );
			if (nSent == SOCKET_ERROR) {
  // this is alright.
				if( dwError == WSAEWOULDBLOCK )
				{
#ifdef VERBOSE_DEBUG
					lprintf( WIDE("Pending write...") );
#endif
					pc->dwFlags |= CF_WRITEPENDING;
#ifdef __LINUX__
					//if( !(pc->dwFlags & CF_WRITEISPENDED ) )
					//{
					//	   lprintf( WIDE("Sending signal") );
					//    WakeThread( globalNetworkData.pThread );
					//}
					//else
					//    lprintf( WIDE("Yes... it was already pending..(no signal)") );
#endif
					return TRUE;
				}
				{
					_lprintf(DBG_RELAY)(WIDE(" Network Send Error: %5d(buffer:%p ofs: %") _size_f WIDE("  Len: %") _size_f WIDE(")"),
											  dwError,
											  pc->lpFirstPending->buffer.c,
											  pc->lpFirstPending->dwUsed,
											  pc->lpFirstPending->dwAvail );
 // ENOTCONN
					if( dwError == 10057
 // EFAULT
						||dwError == 10014
#ifdef __LINUX__
						|| dwError == EPIPE
#endif
					  )
					{
						InternalRemoveClient( pc );
					}
 // get out of here!
					return FALSE;
				}
 // other side closed.
			} else if (!nSent) {
				lprintf( WIDE("sent zero bytes - assume it was closed - and HOPE there's an event...") );
				InternalRemoveClient( pc );
				// if this happened - don't return TRUE result which would
				// result in queuing a pending buffer...
  // no sence processing the rest of this.
				return FALSE;
			} else if( nSent < (int)pc->lpFirstPending->dwAvail ) {
				//pc->lpFirstPending->dwUsed += nSent;
				//pc->lpFirstPending->dwAvail -= nSent;
				pc->dwFlags |= CF_WRITEPENDING;
				//lprintf( "THIS IS ANOTHER PENDING CONDITION THAT WASN'T ACCOUNTED %d of %d", nSent, pc->lpFirstPending->dwAvail  );
			}
		}
		else
			nSent = 0;
#ifdef DEBUG_SOCK_IO
		lprintf( "sent... %d %d %d", nSent, pc->lpFirstPending->dwUsed, pc->lpFirstPending->dwAvail );
#endif
  // sent some data - update pending buffer status.
		{
			if( pc->lpFirstPending )
			{
				pc->lpFirstPending->dwAvail -= nSent;
				//lprintf( "Subtracted %d got %d", nSent, pc->lpFirstPending->dwAvail );
				pc->lpFirstPending->dwUsed  += nSent;
  // no more to send...
				if (!pc->lpFirstPending->dwAvail)
				{
					lpNext = pc->lpFirstPending -> lpNext;
					if( pc->lpFirstPending->s.bDynBuffer )
						Release(pc->lpFirstPending->buffer.p );
					// there is one pending holder in the client
					// structure that was NOT allocated...
					if( pc->lpFirstPending != &pc->FirstWritePending )
					{
#ifdef LOG_PENDING
						lprintf( WIDE("Finished sending a pending buffer.") );
#endif
						Release(pc->lpFirstPending );
					}
					else
					{
#ifdef LOG_PENDING
 // this happens 99.99% of the time.
						if(0)
						{
							lprintf( WIDE("Normal send complete.") );
						}
#endif
					}
					if (!lpNext)
						pc->lpLastPending = NULL;
					pc->lpFirstPending = lpNext;
					if( pc->write.WriteComplete &&
						!pc->bWriteComplete )
					{
						pc->bWriteComplete = TRUE;
						if( pc->dwFlags & CF_CPPWRITE )
  // SOME WRITE!!!
							pc->write.CPPWriteComplete( pc->psvWrite );
						else
  // SOME WRITE!!!
							pc->write.WriteComplete( pc );
						pc->bWriteComplete = FALSE;
					}
					if( !pc->lpFirstPending )
						pc->dwFlags &= ~CF_WRITEPENDING;
				}
				else
				{
					if( !(pc->dwFlags & CF_WRITEPENDING) )
					{
						pc->dwFlags |= CF_WRITEPENDING;
#ifdef USE_WSA_EVENTS
						if( globalNetworkData.flags.bLogNotices )
							lprintf( WIDE( "SET GLOBAL EVENT (write pending)" ) );
						EnqueLink( &globalNetworkData.client_schedule, pc );
						WSASetEvent( globalNetworkData.hMonitorThreadControlEvent );
#endif
#ifdef __LINUX__
						AddThreadEvent( pc, 0 );
#endif
					}
					return TRUE;
				}
			}
		}
	}
 // 0 = everything sent / nothing left to send...
	return FALSE;
}
//----------------------------------------------------------------------------
LOGICAL doTCPWriteExx( PCLIENT lpClient
                     , CPOINTER pInBuffer
                     , size_t nInLen
                     , int bLongBuffer
                     , int failpending
                     DBG_PASS
                     )
{
	if( !lpClient )
	{
#ifdef VERBOSE_DEBUG
		lprintf( WIDE("TCP Write failed - invalid client.") );
#endif
  // cannot process a closed channel. data not sent.
		return FALSE;
	}
	while( !NetworkLockEx( lpClient, 0 DBG_SRC ) )
	{
		if( !(lpClient->dwFlags & CF_ACTIVE ) )
		{
			_lprintf(DBG_RELAY)( "Failing send..." );
			LogBinary( (uint8_t*)pInBuffer, nInLen );
			return FALSE;
		}
		Relinquish();
	}
	if( !(lpClient->dwFlags & CF_ACTIVE ) )
	{
#ifdef VERBOSE_DEBUG
		lprintf( WIDE("TCP Write failed - client is inactive") );
#endif
		// change to inactive status by the time we got here...
		NetworkUnlockEx( lpClient, 0 DBG_SRC );
		return FALSE;
	}
 // will already be in a wait on network state...
	if( lpClient->lpFirstPending )
	{
#ifdef VERBOSE_DEBUG
		_lprintf( DBG_RELAY )(  "Data already pending, pending buffer...%p %d", pInBuffer, nInLen );
#endif
		if( !failpending )
		{
#ifdef VERBOSE_DEBUG
			lprintf( WIDE("Queuing pending data anyhow...") );
#endif
			PendWrite( lpClient, pInBuffer, nInLen, bLongBuffer );
			//TCPWriteEx( lpClient DBG_SRC ); // make sure we don't lose a write event during the queuing...
			NetworkUnlockEx( lpClient, 0 DBG_SRC );
			return TRUE;
		}
		else
		{
#ifdef VERBOSE_DEBUG
			lprintf( WIDE("Failing pend.") );
#endif
			NetworkUnlockEx( lpClient, 0 DBG_SRC );
			return FALSE;
		}
	}
	else
	{
		// have to steal the buffer - :(
		lpClient->FirstWritePending.buffer.c   = pInBuffer;
		//lprintf( "First pending Write set to %d", nInLen );
		lpClient->FirstWritePending.dwAvail    = nInLen;
		lpClient->FirstWritePending.dwUsed     = 0;
		lpClient->FirstWritePending.s.bStream    = FALSE;
		lpClient->FirstWritePending.s.bDynBuffer = FALSE;
		lpClient->FirstWritePending.lpNext       = NULL;
		lpClient->lpLastPending =
		lpClient->lpFirstPending = &lpClient->FirstWritePending;
		if( TCPWriteEx( lpClient DBG_RELAY ) )
		{
#ifdef VERBOSE_DEBUG
			Log2( WIDE("Data not sent, pending buffer... %d bytes %d remain"), nInLen, lpClient->FirstWritePending.dwAvail );
#endif
 // caller will assume the buffer usable on return
			if( !bLongBuffer )
			{
				lpClient->FirstWritePending.buffer.p = Allocate( nInLen );
				MemCpy( lpClient->FirstWritePending.buffer.p, pInBuffer, nInLen );
				lpClient->FirstWritePending.s.bDynBuffer = TRUE;
			}
		}
#ifdef VERBOSE_DEBUG
		else
			_xlprintf( 1 DBG_RELAY )( WIDE("Data has been compeltely sent.") );
#endif
	}
	NetworkUnlockEx( lpClient, 0 DBG_SRC );
 // assume the data was sent.
	return TRUE;
}
//----------------------------------------------------------------------------
#define DRAIN_MAX_READ 2048
// used internally to read directly to drain buffer.
LOGICAL TCPDrainRead( PCLIENT pClient )
{
	size_t nDrainRead;
	char byBuffer[DRAIN_MAX_READ];
	while( pClient && pClient->nDrainLength )
	{
		nDrainRead = pClient->nDrainLength;
		if( nDrainRead > DRAIN_MAX_READ )
			nDrainRead = DRAIN_MAX_READ;
		nDrainRead = recv( pClient->Socket
							  , byBuffer
						 , (int)nDrainRead, 0 );
//SOCKET_ERROR )
		if( nDrainRead == 0 )
		{
			uint32_t dwError;
			dwError = WSAGetLastError();
			if( dwError == WSAEWOULDBLOCK )
			{
				if( !pClient->bDrainExact )
					pClient->nDrainLength = 0;
				break;
			}
			lprintf(WIDE(" Network Error during drain: %d (from: %p  to: %p  has: %") _size_f WIDE("  toget: %") _size_f WIDE(")")
			       , dwError
			       , pClient->Socket
			       , pClient->RecvPending.buffer.p
			       , pClient->RecvPending.dwUsed
			       , pClient->RecvPending.dwAvail );
			InternalRemoveClient( pClient );
			NetworkUnlockEx( pClient, 1 DBG_SRC );
			return FALSE;
		}
		else
		{
			if( globalNetworkData.flags.bShortLogReceivedData )
			{
				LogBinary( (uint8_t*)byBuffer, (nDrainRead<64 )?nDrainRead:64 );
			}
			if( globalNetworkData.flags.bLogReceivedData )
			{
				LogBinary( (uint8_t*)byBuffer, nDrainRead );
			}
		}
		if( nDrainRead == 0 )
		{
 // closed.
			InternalRemoveClient( pClient );
			NetworkUnlockEx( pClient, 1 DBG_SRC );
			return FALSE;
		}
		if( pClient->bDrainExact )
			pClient->nDrainLength -= nDrainRead;
	}
	if( pClient )
		return pClient->bDraining = (pClient->nDrainLength != 0);
 // no data available....
	return 0;
}
//----------------------------------------------------------------------------
NETWORK_PROC( LOGICAL, TCPDrainEx)( PCLIENT pClient, size_t nLength, int bExact )
{
	if( pClient )
	{
		LOGICAL bytes;
		while( !NetworkLockEx( pClient, 0 DBG_SRC ) )
		{
			if( !(pClient->dwFlags & CF_ACTIVE ) )
			{
				return FALSE;
			}
			Relinquish();
		}
		if( pClient->bDraining )
		{
			pClient->nDrainLength += nLength;
		}
		else
		{
			pClient->bDraining = TRUE;
			pClient->nDrainLength = nLength;
		}
		pClient->bDrainExact = bExact;
		if( !pClient->bDrainExact )
 // default optimal read
			pClient->nDrainLength = DRAIN_MAX_READ;
		bytes = TCPDrainRead( pClient );
		NetworkUnlockEx( pClient, 1 DBG_SRC );
		return bytes;
	}
	return 0;
}
//----------------------------------------------------------------------------
void SetTCPNoDelay( PCLIENT pClient, int bEnable )
{
	if( setsockopt( pClient->Socket, IPPROTO_TCP,
						TCP_NODELAY,
						(const char *)&bEnable, sizeof(bEnable) ) == SOCKET_ERROR )
	{
		lprintf( WIDE("Error(%d) setting Delay to : %d"), WSAGetLastError(), bEnable );
		// log some sort of error... and ignore...
	}
}
//----------------------------------------------------------------------------
void SetClientKeepAlive( PCLIENT pClient, int bEnable )
{
	if( setsockopt( pClient->Socket, SOL_SOCKET,
						SO_KEEPALIVE,
						(const char *)&bEnable, sizeof(bEnable) ) == SOCKET_ERROR )
	{
		lprintf( WIDE("Error(%d) setting KeepAlive to : %d"), WSAGetLastError(), bEnable );
		// log some sort of error... and ignore...
	}
}
SACK_NETWORK_TCP_NAMESPACE_END
#define LIBRARY_DEF
#ifdef __LINUX__
 // SIGHUP defined
#define NetWakeSignal SIGHUP
#else
#define ioctl ioctlsocket
#endif
//#define NO_LOGGING // force neverlog....
#define DO_LOGGING
SACK_NETWORK_NAMESPACE
// local extern in network.c
void DumpSocket( PCLIENT pc );
_UDP_NAMESPACE
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PCLIENT CPPServeUDPAddrEx( SOCKADDR *pAddr
                         , cReadCompleteEx pReadComplete
                         , uintptr_t psvRead
                         , cCloseCallback Close
                         , uintptr_t psvClose
                         , int bCPP DBG_PASS )
{
	PCLIENT pc;
	// open a UDP Port to listen for Pings for server...
	pc = GetFreeNetworkClient();
	if( !pc )
	{
		Log( WIDE("Network Resource Fail"));
		return NULL;
	}
#ifdef WIN32
	pc->Socket = OpenSocket(((*(uint16_t*)pAddr) == AF_INET)?TRUE:FALSE,FALSE, FALSE, 0);
	if( pc->Socket == INVALID_SOCKET )
#endif
#ifdef __MAC__
		pc->Socket = socket( PF_INET
		                   , SOCK_DGRAM
		                   , (((((uint8_t*)pAddr)[1]) == AF_INET)||((((uint8_t*)pAddr)[1]) == AF_INET6))?IPPROTO_UDP:0);
#else
    pc->Socket = socket( PF_INET
                       , SOCK_DGRAM
                       , (((*(uint16_t*)pAddr) == AF_INET)||((*(uint16_t*)pAddr) == AF_INET6))?IPPROTO_UDP:0);
#endif
	if( pc->Socket == INVALID_SOCKET )
	{
		_lprintf(DBG_RELAY)( WIDE("UDP Socket Fail") );
		InternalRemoveClientEx( pc, TRUE, FALSE );
		NetworkUnlock( pc, 0 );
		NetworkUnlock( pc, 1 );
		return NULL;
	}
#if WIN32
	if( 0 )
	{
		DWORD dwFlags;
		GetHandleInformation( (HANDLE)pc->Socket, &dwFlags );
		lprintf( WIDE( "Natural was %d" ), dwFlags );
	}
	SetHandleInformation( (HANDLE)pc->Socket, HANDLE_FLAG_INHERIT, 0 );
#endif
#ifdef LOG_SOCKET_CREATION
	lprintf( WIDE( "Created UDP %p(%d)" ), pc, pc->Socket );
#endif
	pc->dwFlags |= CF_UDP;
	if( pAddr? pc->saSource = DuplicateAddress( pAddr ),1:0 )
	{
		if (bind(pc->Socket,pc->saSource,SOCKADDR_LENGTH(pc->saSource)))
		{
			uint32_t err = WSAGetLastError();
			_lprintf(DBG_RELAY)( WIDE("Bind Fail: %d"), err );
			DumpAddr( WIDE( "BIND FAIL:" ), pc->saSource );
			InternalRemoveClientEx( pc, TRUE, FALSE );
			NetworkUnlock( pc, 0 );
			NetworkUnlock( pc, 1 );
			return NULL;
		}
		// get the port address back immediately.
		getsockname(pc->Socket, pc->saSource, (socklen_t*)(((uintptr_t)pc->saSource)-2*sizeof(uintptr_t)));
	}
	else
	{
		Log( WIDE("Bind Will Fail") );
		InternalRemoveClientEx( pc, TRUE, FALSE );
		NetworkUnlock( pc, 0 );
		NetworkUnlock( pc, 1 );
		return NULL;
	}
#ifdef _WIN32
#  ifdef USE_WSA_EVENTS
	pc->event = WSACreateEvent();
	WSAEventSelect( pc->Socket, pc->event, FD_READ|FD_WRITE );
#  else
	if (WSAAsyncSelect( pc->Socket,
	                   globalNetworkData.ghWndNetwork,
	                   SOCKMSG_UDP,
	                   FD_READ|FD_WRITE ) )
	{
		Log( WIDE("Select Fail"));
		InternalRemoveClientEx( pc, TRUE, FALSE );
		NetworkUnlock( pc, 0 );
		NetworkUnlock( pc, 1 );
		return NULL;
	}
#  endif
#else
	{
		int t = TRUE;
		ioctl( pc->Socket, FIONBIO, &t );
	}
#endif
	pc->read.ReadCompleteEx = pReadComplete;
	pc->psvRead = psvRead;
	pc->close.CloseCallback = Close;
	pc->psvClose = psvClose;
	if( bCPP )
		pc->dwFlags |= (CF_CPPREAD|CF_CPPCLOSE );
#ifdef __LINUX__
	AddThreadEvent( pc, 0 );
#endif
	if( pReadComplete )
	{
		if( pc->dwFlags & CF_CPPREAD )
			pc->read.CPPReadCompleteEx( pc->psvRead, NULL, 0, pc->saSource );
		else
			pc->read.ReadCompleteEx( pc, NULL, 0, pc->saSource );
	}else
		lprintf( "NO READ CALLBACK IS SET?!" );
#ifdef LOG_SOCKET_CREATION
	DumpSocket( pc );
#endif
	AddActive( pc );
	NetworkUnlock( pc, 0 );
	NetworkUnlock( pc, 1 );
#ifdef USE_WSA_EVENTS
	if( globalNetworkData.flags.bLogNotices )
		lprintf( WIDE( "SET GLOBAL EVENT (new udp socket %p)" ), pc );
	EnqueLink( &globalNetworkData.client_schedule, pc );
	WSASetEvent( globalNetworkData.hMonitorThreadControlEvent );
#endif
	return pc;
}
//----------------------------------------------------------------------------
PCLIENT ServeUDPAddrEx( SOCKADDR *pAddr
                      , cReadCompleteEx pReadComplete
                      , cCloseCallback Close DBG_PASS )
{
	PCLIENT result = CPPServeUDPAddrEx( pAddr, pReadComplete, 0, Close, 0, FALSE DBG_RELAY );
	if( result )
		result->dwFlags &= ~(CF_CPPREAD|CF_CPPCLOSE);
	return result;
}
//----------------------------------------------------------------------------
PCLIENT ServeUDPEx( CTEXTSTR pAddr, uint16_t wPort
                  , cReadCompleteEx pReadComplete
                  , cCloseCallback Close DBG_PASS )
{
	SOCKADDR *lpMyAddr;
	if( pAddr )
		lpMyAddr = CreateSockAddress( pAddr, wPort);
	else
	{
		// NOTE this is NOT create local which binds to only
		// one address and port - this IS "0.0.0.0" which is
		// any IP inteface on the box...
 // assume bind to any address...
		lpMyAddr = CreateSockAddress( WIDE("0.0.0.0"), wPort );
	}
	return ServeUDPAddrEx( lpMyAddr, pReadComplete, Close DBG_RELAY );
}
//----------------------------------------------------------------------------
void UDPEnableBroadcast( PCLIENT pc, int bEnable )
{
	if( pc ) {
#ifdef __LINUX__
		if( bEnable ) {
			uint16_t port;
			SOCKADDR *broadcastAddr;
			//RemoveThreadEvent( pc );
			//pc->Socket = close( pc->Socket );
			pc->interfaceAddress = GetInterfaceForAddress( pc->saSource );
			if( pc->interfaceAddress ) {
				pc->SocketBroadcast = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );
				{
					int t = TRUE;
					ioctl( pc->SocketBroadcast, FIONBIO, &t );
				}
				broadcastAddr = DuplicateAddress( GetBroadcastAddressForInterface( pc->saSource ) );
				GetAddressParts( pc->saSource, NULL, &port );
				SetAddressPort( broadcastAddr, port );
				if( bind( pc->SocketBroadcast, broadcastAddr, SOCKADDR_LENGTH( broadcastAddr ) ) ) {
					lprintf( "Failed to rebind to broadcast address when enabling... %d", errno );
				}
				if( setsockopt( pc->SocketBroadcast, SOL_SOCKET
				              , SO_BROADCAST, (char*)&bEnable, sizeof( bEnable ) ) )
				{
					uint32_t error = WSAGetLastError();
					lprintf( WIDE("Failed to set sock opt - BROADCAST(%d)"), error );
				}
				AddThreadEvent( pc, 1 );
#ifdef __LINUX__
				// need to set EAGAIN state on socket.
  // do actual read.... (results in read callback)
				FinishUDPRead( pc, 1 );
#endif
				ReleaseAddress( broadcastAddr );
			} else
				lprintf( "Network interface for socket address not found." );
		}
#else
		if( setsockopt( pc->Socket, SOL_SOCKET
		              , SO_BROADCAST, (char*)&bEnable, sizeof( bEnable ) ) )
		{
			uint32_t error = WSAGetLastError();
			lprintf( WIDE("Failed to set sock opt - BROADCAST(%d)"), error );
		}
#endif
	}
}
//----------------------------------------------------------------------------
LOGICAL GuaranteeAddr( PCLIENT pc, SOCKADDR *sa )
{
	if( sa )
	{
		pc->saClient = DuplicateAddress( sa );
	}
	else
		return FALSE;
#ifdef VERBOSE_DEBUG
	DumpSocket( pc );
#endif
	return TRUE;
}
//----------------------------------------------------------------------------
LOGICAL Guarantee( PCLIENT pc, CTEXTSTR pAddr, uint16_t wPort )
{
	SOCKADDR *lpMyAddr = CreateSockAddress( pAddr, wPort);
	int res = GuaranteeAddr( pc, lpMyAddr );
	ReleaseAddress( lpMyAddr );
	return res;
}
//----------------------------------------------------------------------------
PCLIENT CPPConnectUDPAddrEx( SOCKADDR *sa
                           , SOCKADDR *saTo
                           , cReadCompleteEx pReadComplete
                           , uintptr_t psvRead
                           , cCloseCallback Close
                           , uintptr_t psvClose DBG_PASS )
{
	PCLIENT pc;
	int bFixed = FALSE;
	if( !sa )
	{
 // use any address...
		sa = CreateLocal( 0 );
		bFixed = TRUE;
	}
	pc = ServeUDPAddrEx( sa, NULL, NULL DBG_RELAY );
	if( !pc )
	{
		Log( WIDE("Failed to establish incoming side of UDP Socket") );
		return NULL;
	}
	if( !GuaranteeAddr( pc, saTo ) )
	{
		Log( WIDE("Failed to set guaranteed UDP Send Address."));
		InternalRemoveClient( pc );
		return NULL;
	}
	if( bFixed )
		ReleaseAddress( sa );
	pc->read.ReadCompleteEx = pReadComplete;
	pc->psvRead = psvRead;
	pc->close.CloseCallback = Close;
	pc->psvClose = psvClose;
	pc->dwFlags |= (CF_CPPREAD|CF_CPPCLOSE );
	if( pReadComplete )
 // allow server to start a read method...
		pReadComplete( pc, NULL, 0, NULL );
	return pc;
}
PCLIENT CPPConnectUDPAddr( SOCKADDR *sa
                         , SOCKADDR *saTo
                         , cReadCompleteEx pReadComplete
                         , uintptr_t psvRead
                         , cCloseCallback Close
                         , uintptr_t psvClose )
{
	return CPPConnectUDPAddrEx( sa, saTo, pReadComplete, psvRead, Close, psvClose DBG_SRC );
}
//----------------------------------------------------------------------------
PCLIENT ConnectUDPAddrEx( SOCKADDR *sa
                        , SOCKADDR *saTo
                        , cReadCompleteEx pReadComplete
                        , cCloseCallback Close DBG_PASS )
{
	PCLIENT result = CPPConnectUDPAddrEx( sa, saTo, pReadComplete, 0, Close, 0 DBG_RELAY );
	if( result )
		result->dwFlags &= ~( CF_CPPREAD|CF_CPPCLOSE );
	return result;
}
//----------------------------------------------------------------------------
static PCLIENT CPPConnectUDPExx( CTEXTSTR pFromAddr, uint16_t wFromPort
                               , CTEXTSTR pToAddr, uint16_t wToPort
                               , cReadCompleteEx pReadComplete
                               , uintptr_t psvRead
                               , cCloseCallback Close
                               , uintptr_t psvClose
                               , LOGICAL bCPP
                               DBG_PASS )
{
	PCLIENT pc;
	pc = ServeUDPEx( pFromAddr, wFromPort, NULL, NULL DBG_RELAY );
	if( !pc )
	{
		Log( WIDE("Failed to establish incoming side of UDP Socket") );
		return NULL;
	}
	if( !Guarantee( pc, pToAddr, wToPort ) )
	{
		Log( WIDE("Failed to set guaranteed UDP Send Address."));
		InternalRemoveClient( pc );
		return NULL;
	}
	pc->read.ReadCompleteEx = pReadComplete;
	pc->psvRead = psvRead;
	pc->close.CloseCallback = Close;
	pc->psvClose = psvClose;
	if( bCPP )
	{
		pc->dwFlags |= (CF_CPPREAD|CF_CPPCLOSE );
		if( pReadComplete )
 // allow server to start a read method...
			pc->read.CPPReadCompleteEx( psvRead, NULL, 0, NULL );
	}
	else
	{
		pc->dwFlags &= ~( CF_CPPREAD|CF_CPPCLOSE );
		if( pReadComplete )
 // allow server to start a read method...
			pReadComplete( pc, NULL, 0, NULL );
	}
	return pc;
}
PCLIENT CPPConnectUDPEx( CTEXTSTR pFromAddr, uint16_t wFromPort,
                         CTEXTSTR pToAddr, uint16_t wToPort,
                         cReadCompleteEx pReadComplete,
                         uintptr_t psvRead,
                         cCloseCallback Close,
                         uintptr_t psvClose DBG_PASS )
{
	return CPPConnectUDPExx( pFromAddr, wFromPort, pToAddr, wToPort, pReadComplete, psvRead, Close, psvClose, TRUE DBG_RELAY );
}
PCLIENT ConnectUDPEx( CTEXTSTR pFromAddr, uint16_t wFromPort,
                      CTEXTSTR pToAddr, uint16_t wToPort,
                      cReadCompleteEx pReadComplete,
                      cCloseCallback Close DBG_PASS )
{
	return CPPConnectUDPExx( pFromAddr, wFromPort, pToAddr, wToPort, pReadComplete, 0, Close, 0, FALSE DBG_RELAY );
}
//----------------------------------------------------------------------------
NETWORK_PROC( LOGICAL, SendUDPEx )( PCLIENT pc, CPOINTER pBuf, size_t nSize, SOCKADDR *sa )
{
	int nSent;
	SOCKET sendSocket = pc->Socket;
	if( !sa)
		sa = pc->saClient;
	if( !sa )
      return FALSE;
	if( !pc )
		return FALSE;
#ifdef __LINUX__
	if( IsBroadcastAddressForInterface( pc->interfaceAddress, sa ) ) {
		sendSocket = pc->SocketBroadcast;
	}
#endif
	//LogBinary( (uint8_t*)pBuf, nSize );
	nSent = sendto( sendSocket
	              , (const char*)pBuf
	              , (int)nSize
	              , 0
	              , (sa)
	              , SOCKADDR_LENGTH((sa))
	              );
	if( nSent < 0 )
	{
		Log1( WIDE("SendUDP: Error (%d)"), WSAGetLastError() );
		DumpAddr( WIDE( "SendTo Socket" ), (sa) );
		return FALSE;
	}
 // this is all so very vague.....
	else if( SUS_LT( nSent, int, nSize, size_t ) )
	{
		Log( WIDE("SendUDP: Small send :(") );
		return FALSE;
	}
	return TRUE;
}
//----------------------------------------------------------------------------
NETWORK_PROC( LOGICAL, ReconnectUDP )( PCLIENT pc, CTEXTSTR pToAddr, uint16_t wPort )
{
	return Guarantee( pc, pToAddr, wPort );
}
//----------------------------------------------------------------------------
extern uint32_t uNetworkPauseTimer, uTCPPendingTimer;
//----------------------------------------------------------------------------
NETWORK_PROC( int, doUDPRead )( PCLIENT pc, POINTER lpBuffer, int nBytes )
{
	if( pc->RecvPending.dwAvail )
	{
		lprintf( WIDE("Read already pending for %")_size_fs WIDE("... not doing anything for this one..")
		        , pc->RecvPending.dwAvail );
		return FALSE;
	}
	//Log1( WIDE("UDPRead Pending:%d bytes"), nBytes );
	pc->RecvPending.dwAvail = nBytes;
	pc->RecvPending.dwUsed = 0;
	pc->RecvPending.buffer.p = lpBuffer;
	{
		pc->dwFlags |= CF_READPENDING;
		// we are now able to read, so schedule the socket.
	}
#if 0
#ifdef __LINUX__
	// need to set EAGAIN state on socket.
  // do actual read.... (results in read callback)
	FinishUDPRead( pc, 0 );
	if( pc->SocketBroadcast )
  // do actual read.... (results in read callback)
		FinishUDPRead( pc, 1 );
#endif
#endif
	return TRUE;
}
//----------------------------------------------------------------------------
int FinishUDPRead( PCLIENT pc, int broadcastEvent )
  // all UDP Reads return the address of the other side's message...
{
	int nReturn;
#ifdef __LINUX__
	socklen_t
#else
		int
#endif
  // echoed from server.
		Size=MAGIC_SOCKADDR_LENGTH;
	if( !pc->RecvPending.buffer.p || !pc->RecvPending.dwAvail )
	{
		//lprintf( WIDE("UDP Read without queued buffer for result. %p %") _size_fs, pc->RecvPending.buffer.p, pc->RecvPending.dwAvail );
		return FALSE;
	}
	//do{
	if( !pc->saLastClient )
		pc->saLastClient = AllocAddr();
	nReturn = recvfrom( broadcastEvent?pc->SocketBroadcast:pc->Socket,
	                    (char*)pc->RecvPending.buffer.p,
	                    (int)pc->RecvPending.dwAvail,0,
	                    pc->saLastClient,
// get address...
	                    &Size);
	uintptr_t name = (((uintptr_t*)pc->saLastClient) - 1)[0];
	if( name ) free( (void*)name );
	(((uintptr_t*)pc->saLastClient) - 1)[0] = 0;
	// address size in recvfrom on linux results with '256' which
	// then results with a sockaddr that can't sendto with.
	if( pc->saLastClient->sa_family == AF_INET )
		SET_SOCKADDR_LENGTH( pc->saLastClient, IN_SOCKADDR_LENGTH );
	else if( pc->saLastClient->sa_family == AF_INET6 )
		SET_SOCKADDR_LENGTH( pc->saLastClient, IN6_SOCKADDR_LENGTH );
	//lprintf( WIDE("Recvfrom result:%d"), nReturn );
	if (nReturn == SOCKET_ERROR)
	{
		uint32_t dwErr = WSAGetLastError();
		// shutdown the udp socket... not needed...???
		//lprintf( WIDE("Recvfrom result:%d"), dwErr );
		switch( dwErr )
		{
 // NO data returned....
		case WSAEWOULDBLOCK:
			//lprintf( "got EWOULDBLOCK(EAGAIN)..." );
			pc->dwFlags |= CF_READPENDING;
			return TRUE;
#ifdef _WIN32
		// this happens on WIN2K/XP - ICMP Port Unreachable (nothing listening there)
 // just ignore this error.
		case WSAECONNRESET:
			  Log( WIDE("ICMP Port unreachable on previous send.") );
			return TRUE;
#endif
		default:
				Log2( WIDE("FinishUDPRead Unknown error: %d %") _size_fs WIDE(""), WSAGetLastError(), pc->RecvPending.dwAvail );
			InternalRemoveClient( pc );
			return FALSE;
			break;
		}
	}
	//Log1( WIDE("UDPRead:%d bytes"), nReturn );
	if( globalNetworkData.flags.bShortLogReceivedData )
	{
		DumpAddr( WIDE("UDPRead at"), pc->saSource );
		LogBinary( (uint8_t*)pc->RecvPending.buffer.p +
					 pc->RecvPending.dwUsed, ( nReturn< 64 )?nReturn:64 );
	}
	if( globalNetworkData.flags.bLogReceivedData )
	{
		DumpAddr( WIDE("UDPRead at"), pc->saSource );
		LogBinary( (uint8_t*)pc->RecvPending.buffer.p +
					 pc->RecvPending.dwUsed, nReturn );
	}
	pc->dwFlags &= ~CF_READPENDING;
  // allow further reads...
	pc->RecvPending.dwAvail = 0;
	pc->RecvPending.dwUsed += nReturn;
	if( pc->read.ReadCompleteEx )
	{
		if( pc->dwFlags & CF_CPPREAD )
			pc->read.CPPReadCompleteEx( pc->psvRead, pc->RecvPending.buffer.p, nReturn, pc->saLastClient );
		else
		{
			//lprintf( WIDE("Calling UDP complete %p %p %d"), pc, pc->RecvPending.buffer.p, nReturn );
			pc->read.ReadCompleteEx( pc, pc->RecvPending.buffer.p, nReturn, pc->saLastClient );
		}
	}
	//}while(1);
	return TRUE;
}
int SetSocketReuseAddress( PCLIENT lpClient, int32_t enable )
{
	if (setsockopt(lpClient->Socket, SOL_SOCKET, SO_REUSEADDR,
						(char*)&enable, sizeof(enable)) <0 )
	{
		return 0;
		//cerr << "NFMSim:setHost:ERROR: could not set socket to reuse addr." << endl;
	}
	return 1;
}
int SetSocketReusePort( PCLIENT lpClient, int32_t enable )
{
#ifdef __LINUX__
	if (setsockopt(lpClient->Socket, SOL_SOCKET, SO_REUSEPORT,
						(char*)&enable, sizeof(enable)) < 0 )
	{
		return 0;
		//cerr << "NFMSim:setHost:ERROR: could not set socket to reuse addr." << endl;
	}
#else
	SetSocketReuseAddress( lpClient, enable );
#endif
	return 1;
}
_UDP_NAMESPACE_END
SACK_NETWORK_NAMESPACE_END
#ifndef __LINUX__
///////////////////////////////////////////////////////////////////////////
//
// Filename    -  Network.C
//
// Description -  Network services for Communications Client
//
// Author      -  James Buckeyne
//
// Create Date -  Before now.
// Conversion update for Linux GLIBC 2.1 9/26/2000
//
///////////////////////////////////////////////////////////////////////////
//
//  DEBUG FLAGS IN netstruc.h
//
SACK_NETWORK_NAMESPACE
   // should pass ipv4? v6? to switch?
SOCKET OpenSocket( LOGICAL v4, LOGICAL bStream, LOGICAL bRaw, int another_offset )
{
	if( another_offset )
	{
		SOCKET result;
      // need to index into saved sockets and try another provider.
		result = WSASocketW(v4?AF_INET:AF_INET6
										 , bRaw?SOCK_RAW:0
										 , 0
										 , v4
										  ?bStream
										  ?globalNetworkData.pProtos+globalNetworkData.tcp_protocol
										  :globalNetworkData.pProtos+globalNetworkData.udp_protocol
										  :bStream
										  ?globalNetworkData.pProtos+globalNetworkData.tcp_protocolv6
										  :globalNetworkData.pProtos+globalNetworkData.udp_protocolv6
										 , 0, 0 );
		return result;
	}
	else
	{
		SOCKET result = WSASocketW(v4?AF_INET:AF_INET6
										 , bRaw?SOCK_RAW:0
										 , 0
										 , v4
										  ?bStream
										  ?globalNetworkData.pProtos+globalNetworkData.tcp_protocol
										  :globalNetworkData.pProtos+globalNetworkData.udp_protocol
										  :bStream
										  ?globalNetworkData.pProtos+globalNetworkData.tcp_protocolv6
										  :globalNetworkData.pProtos+globalNetworkData.udp_protocolv6
										 , 0, 0 );
		return result;
	}
}
int SystemCheck( void )
{
	WSADATA wd;
	int i;
	int protoIndex = -1;
	int size;
	//lprintf( "Global is %d %p", sizeof( globalNetworkData ), &globalNetworkData.uNetworkPauseTimer, &globalNetworkData.nProtos );
	if (WSAStartup(MAKEWORD(2, 0), &wd) != 0)
	{
		lprintf(WIDE( "WSAStartup 2.0 failed: %d" ), h_errno);
		return 0;
	}
	if( globalNetworkData.flags.bLogProtocols )
		lprintf(WIDE( "Winsock Version: %d.%d" ), LOBYTE(wd.wVersion), HIBYTE(wd.wVersion));
	size = 0;
	if ((globalNetworkData.nProtos = WSAEnumProtocolsW(NULL, NULL, (DWORD *) &size)) == -1)
	{
		if( WSAGetLastError() != WSAENOBUFS )
		{
			lprintf(WIDE( "WSAEnumProtocols: %d" ), h_errno);
			return 0;
		}
	}
	globalNetworkData.pProtos = (WSAPROTOCOL_INFOW*)Allocate( size );
	if ((globalNetworkData.nProtos = WSAEnumProtocolsW(NULL, globalNetworkData.pProtos, (DWORD *) &size)) == -1)
	{
		lprintf(WIDE( "WSAEnumProtocols: %d" ), h_errno);
		return 0;
	}
	for (i = 0; i < globalNetworkData.nProtos; i++)
	{
		// IPv6
		if (wcscmp(globalNetworkData.pProtos[i].szProtocol, L"MSAFD Tcpip [TCP/IP]" ) == 0)
		{
			globalNetworkData.tcp_protocol = i;
			protoIndex = i;
		}
		if (wcscmp(globalNetworkData.pProtos[i].szProtocol, L"MSAFD Tcpip [UDP/IP]" ) == 0)
		{
			globalNetworkData.udp_protocol = i;
		}
		if (wcscmp(globalNetworkData.pProtos[i].szProtocol, L"MSAFD Tcpip [TCP/IPv6]" ) == 0)
		{
			globalNetworkData.tcp_protocolv6 = i;
		}
		if (wcscmp(globalNetworkData.pProtos[i].szProtocol, L"MSAFD Tcpip [UDP/IPv6]" ) == 0)
		{
			globalNetworkData.udp_protocolv6 = i;
		}
		if( globalNetworkData.flags.bLogProtocols )
			lprintf(WIDE( "Index #%d - name: '%S', type: %d, proto: %d" ), i, globalNetworkData.pProtos[i].szProtocol,
					  globalNetworkData.pProtos[i].iSocketType, globalNetworkData.pProtos[i].iProtocol);
	}
	if (protoIndex == -1)
	{
		lprintf(WIDE( "no valid TCP/IP protocol available" ));
		return 0;
	}
	return 0;
}
SACK_NETWORK_NAMESPACE_END
#endif
